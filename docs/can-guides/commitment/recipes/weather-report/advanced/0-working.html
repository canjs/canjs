<link href="https://fonts.googleapis.com/css?family=Dosis:300,400" rel="stylesheet">
<link rel="stylesheet" type="text/css" href="../weather-report.css">
<!-- eedfc9671818be40 -->
<script id="app-template" type="text/stache">
Latitude: {{ geoLocation.coords.latitude }},
Longitude: {{ geoLocation.coords.longitude }},
Error: {{ geoLocationError.message }}

  <div class="weather-widget">
    {{# if(showEnableGeoLocationMessage) }}
    <p class="loading-message">
	  Please Enable Location Services…
    </p>
    {{/ if }}

	{{# if(showEnterLocation) }}
    <div class="location-entry">
      <label for="location">Enter your location:</label>
      <input id="location" type="text" value:to="this.location" />
    </div>
	{{/ if }}

	{{# if(forecastPromise.isPending) }}
      <p class="loading-message">
        Loading forecast…
      </p>
    {{/ if }}

    {{# if(showPlacePicker) }}
      <div class="location-options">
        <label>Pick your place:</label>
        <ul>
          {{# for(place of forecastPromise.value) }}
            <li on:click="this.pickPlace(place)">{{ place.name }}, {{ place.admin1.content }},
                {{ place.country.code }} ({{ place.placeTypeName.content }})</li>
          {{/ for }}
        </ul>
      </div>
	{{/ if }}

    {{# if(place) }}
      <div class="forecast">
        <h1>10 day {{ place.name }} Weather Forecast</h1>
        <ul>
          {{# for(forecast of forecastPromise.value) }}
            <li>
              <span class="date">{{ forecast.date }}</span>
              <span class="description {{ toClassName(forecast.text) }}">{{ forecast.text }}</span>
              <span class="high-temp">{{ forecast.high }}<sup>&deg;</sup></span>
              <span class="low-temp">{{ forecast.low }}<sup>&deg;</sup></span>
            </li>
          {{/ for }}
        </ul>
      </div>
    {{/ if }}

  </div>
</script>
<script src="https://cdn.jsdelivr.net/kefir/3.6.0/kefir.js"></script>
<script>
  steal = {
    instantiated: {
      "kefir" : Kefir
    }
  }
</script>
<script src="../../../../../../node_modules/steal/steal.js" dev-bundle main="@empty">
import can from 'can/all';
import defineStreamKefir from 'can-define-stream-kefir';
can.defineStreamKefir = defineStreamKefir;
import Kefir from 'kefir';

const yqlURL = "https://query.yahooapis.com/v1/public/yql?";

const geoLocationStream = Kefir.stream(function(emitter) {
    navigator.geolocation.getCurrentPosition(function(position) {
      emitter.value(position);
    }, function(err) {
        console.log("getCurrentPositionErr",err);
        emitter.error(err);
    });


     const watch = navigator.geolocation.watchPosition(function(position) {
       emitter.value(position);
     }, function(err) {
         emitter.error(err);
     });

    return function() {
        navigator.geolocation.clearWatch(watch);
    };
});

const WeatherViewModel = can.DefineMap.extend({
    geoLocation: {
        stream: function() {
            return geoLocationStream;
        }
    },
    geoLocationError: {
        stream: function() {
            return geoLocationStream.withHandler(function(emitter, event) {
                if (event.type === "end") {
                    emitter.end();
                }
                if (event.type === "error") {
                    emitter.value(event.value);
                }
            });
        }
    },
    geoPlace: {
        get: function(lastSet, resolve) {
            if (this.geoLocation) {
                fetch("https://api.flickr.com/services/rest/?" +
                  can.param({
                      method: "flickr.places.findByLatLon",
                      api_key: "df0a221bb43ecbc2abb03426bd84e598",
                      lat: this.geoLocation.coords.latitude,
                      lon: this.geoLocation.coords.longitude,
                      format: "json",
                      nojsoncallback: 1
                  })
                ).then(response => {
                  return response.json();
                }).then(function(responseJSON) {
                  return responseJSON.places.place[0];
                }).then(resolve);
            }
        }
    },
	get showEnableGeoLocationMessage() {
        return !this.geoLocation && !this.geoLocationError;
    },
	get showEnterLocation() {
        return !!this.geoLocationError;
    },
    location: "string",
    get forecastPromise() {
        if (this.location && this.location.length > 2) {
            return fetch(
                yqlURL +
                can.param({
                    q: 'select * from geo.places where text="' + this.location + '"',
                    format: "json"
                })
            ).then(response => {
                return response.json();
            }).then(data => {
                console.log(data);
                if (Array.isArray(data.query.results.place)) {
                    return data.query.results.place;
                } else {
                    return [data.query.results.place];
                }
            });
        }
    },
    places: {
        get: function(lastSet, resolve) {
            if (this.forecastPromise) {
                this.forecastPromise.then(resolve);
            }
        }
    },
    get showPlacePicker() {
        return !this.place && this.places && this.places.length > 1;
    },
    place: {
        stream: function(setStream) {
            const resetStream = this.toStream(".location").map(function() {
                return null;
            });
            const onePlaceResultStream = this.toStream(".places").map(function(places) {
                if (places.length === 1) {
                    return places[0];
                } else {
                    return null;
                }
            });

            return onePlaceResultStream
                .merge(setStream)
                .merge(resetStream)
                .merge(this.toStream(".geoPlace"));
        }
    },
    pickPlace: function(place) {
        this.place = place;
    },
    get forecastPromise() {
        if (this.place) {
            console.log("place", this.place);
            return fetch(
                yqlURL +
                can.param({
                    q: 'select * from weather.forecast where woeid=' + this.place.woeid,
                    format: "json"
                })
            ).then(response => {
                return response.json();
            }).then(data => {
                console.log("forecast data", data);
                const forecast = data.query.results.channel.item.forecast;

                return forecast;
            });
        }
    },
    toClassName: function(text) {
        return text.toLowerCase().replace(/ /g, "-");
    }
});
can.defineStreamKefir(WeatherViewModel);

const vm = new WeatherViewModel();

const template = can.stache.from("app-template");
const fragment = template(vm);
document.body.appendChild(fragment);
</script>
