/*[system-bundles-config]*/
System.bundles = {"bundles/can/test/test.css!":["qunitjs@1.23.1#qunit/qunit.css!steal-css@1.3.2#css"],"bundles/react-view-model/test/test":["object-assign@4.1.1#index","fbjs@0.8.16#lib/emptyObject","fbjs@0.8.16#lib/emptyFunction","react@16.2.0#cjs/react.production.min","fbjs@0.8.16#lib/invariant","fbjs@0.8.16#lib/warning","prop-types@15.6.0#lib/ReactPropTypesSecret","prop-types@15.6.0#checkPropTypes","react@16.2.0#cjs/react.development","react@16.2.0#index","fbjs@0.8.16#lib/ExecutionEnvironment","fbjs@0.8.16#lib/EventListener","fbjs@0.8.16#lib/getActiveElement","fbjs@0.8.16#lib/shallowEqual","fbjs@0.8.16#lib/isNode","fbjs@0.8.16#lib/isTextNode","fbjs@0.8.16#lib/containsNode","fbjs@0.8.16#lib/focusNode","react-dom@16.2.0#cjs/react-dom.production.min","fbjs@0.8.16#lib/hyphenate","fbjs@0.8.16#lib/hyphenateStyleName","fbjs@0.8.16#lib/camelize","fbjs@0.8.16#lib/camelizeStyleName","react-dom@16.2.0#cjs/react-dom.development","react-dom@16.2.0#index","react-dom@16.2.0#cjs/react-dom-test-utils.production.min","react-dom@16.2.0#cjs/react-dom-test-utils.development","react-dom@16.2.0#test-utils","react-view-model@1.0.0#observer","react-view-model@1.0.0#helpers/make-enumerable","react-view-model@1.0.0#helpers/autobind-methods","react-view-model@1.0.0#component","react-view-model@1.0.0#helpers/observable-promise","react-view-model@1.0.0#react-view-model","react-view-model@1.0.0#test/utils","prop-types@15.6.0#factoryWithTypeCheckers","prop-types@15.6.0#factoryWithThrowingShims","prop-types@15.6.0#index","react-view-model@1.0.0#test/defined-view-model","react-view-model@1.0.0#test/test-define","react-view-model@1.0.0#test/test"]};
/*npm-utils*/
define('npm-utils', function (require, exports, module) {
    (function (global, require, exports, module) {
        var slice = Array.prototype.slice;
        var npmModuleRegEx = /.+@.+\..+\..+#.+/;
        var conditionalModuleRegEx = /#\{[^\}]+\}|#\?.+$/;
        var gitUrlEx = /(git|http(s?)):\/\//;
        var supportsSet = typeof Set === 'function';
        var utils = {
            extend: function (d, s, deep, existingSet) {
                var val;
                var set = existingSet;
                if (deep) {
                    if (!set) {
                        if (supportsSet) {
                            set = new Set();
                        } else {
                            set = [];
                        }
                    }
                    if (supportsSet) {
                        if (set.has(s)) {
                            return s;
                        } else {
                            set.add(s);
                        }
                    } else {
                        if (set.indexOf(s) !== -1) {
                            return s;
                        } else {
                            set.push(s);
                        }
                    }
                }
                for (var prop in s) {
                    val = s[prop];
                    if (deep) {
                        if (utils.isArray(val)) {
                            d[prop] = slice.call(val);
                        } else if (utils.isPlainObject(val)) {
                            d[prop] = utils.extend({}, val, deep, set);
                        } else {
                            d[prop] = s[prop];
                        }
                    } else {
                        d[prop] = s[prop];
                    }
                }
                return d;
            },
            map: function (arr, fn) {
                var i = 0, len = arr.length, out = [];
                for (; i < len; i++) {
                    out.push(fn.call(arr, arr[i]));
                }
                return out;
            },
            filter: function (arr, fn) {
                var i = 0, len = arr.length, out = [], res;
                for (; i < len; i++) {
                    res = fn.call(arr, arr[i]);
                    if (res) {
                        out.push(arr[i]);
                    }
                }
                return out;
            },
            forEach: function (arr, fn) {
                var i = 0, len = arr.length;
                for (; i < len; i++) {
                    fn.call(arr, arr[i], i);
                }
            },
            isObject: function (obj) {
                return typeof obj === 'object';
            },
            isPlainObject: function (obj) {
                return utils.isObject(obj) && (!obj || obj.__proto__ === Object.prototype);
            },
            isArray: Array.isArray || function (arr) {
                return Object.prototype.toString.call(arr) === '[object Array]';
            },
            isEnv: function (name) {
                return this.isEnv ? this.isEnv(name) : this.env === name;
            },
            isGitUrl: function (str) {
                return gitUrlEx.test(str);
            },
            warnOnce: function (msg) {
                var w = this._warnings = this._warnings || {};
                if (w[msg])
                    return;
                w[msg] = true;
                this.warn(msg);
            },
            warn: function (msg) {
                if (typeof steal !== 'undefined' && typeof console !== 'undefined' && console.warn) {
                    steal.done().then(function () {
                        if (steal.dev && steal.dev.warn) {
                        } else if (console.warn) {
                            console.warn('steal.js WARNING: ' + msg);
                        } else {
                            console.log(msg);
                        }
                    });
                }
            },
            relativeURI: function (baseURL, url) {
                return typeof steal !== 'undefined' ? steal.relativeURI(baseURL, url) : url;
            },
            moduleName: {
                create: function (descriptor, standard) {
                    if (standard) {
                        return descriptor.moduleName;
                    } else {
                        if (descriptor === '@empty') {
                            return descriptor;
                        }
                        var modulePath;
                        if (descriptor.modulePath) {
                            modulePath = descriptor.modulePath.substr(0, 2) === './' ? descriptor.modulePath.substr(2) : descriptor.modulePath;
                        }
                        return descriptor.packageName + (descriptor.version ? '@' + descriptor.version : '') + (modulePath ? '#' + modulePath : '') + (descriptor.plugin ? descriptor.plugin : '');
                    }
                },
                isNpm: function (moduleName) {
                    return npmModuleRegEx.test(moduleName);
                },
                isConditional: function (moduleName) {
                    return conditionalModuleRegEx.test(moduleName);
                },
                isFullyConvertedNpm: function (parsedModuleName) {
                    return !!(parsedModuleName.packageName && parsedModuleName.version && parsedModuleName.modulePath);
                },
                isScoped: function (moduleName) {
                    return moduleName[0] === '@';
                },
                parse: function (moduleName, currentPackageName, global, context) {
                    var pluginParts = moduleName.split('!');
                    var modulePathParts = pluginParts[0].split('#');
                    var versionParts = modulePathParts[0].split('@');
                    if (!modulePathParts[1] && !versionParts[0]) {
                        versionParts = ['@' + versionParts[1]];
                    }
                    if (versionParts.length === 3 && utils.moduleName.isScoped(moduleName)) {
                        versionParts.splice(0, 1);
                        versionParts[0] = '@' + versionParts[0];
                    }
                    var packageName, modulePath;
                    if (currentPackageName && utils.path.isRelative(moduleName)) {
                        packageName = currentPackageName;
                        modulePath = versionParts[0];
                    } else if (currentPackageName && utils.path.isInHomeDir(moduleName, context)) {
                        packageName = currentPackageName;
                        modulePath = versionParts[0].split('/').slice(1).join('/');
                    } else {
                        if (modulePathParts[1]) {
                            packageName = versionParts[0];
                            modulePath = modulePathParts[1];
                        } else {
                            var folderParts = versionParts[0].split('/');
                            if (folderParts.length && folderParts[0][0] === '@') {
                                packageName = folderParts.splice(0, 2).join('/');
                            } else {
                                packageName = folderParts.shift();
                            }
                            modulePath = folderParts.join('/');
                        }
                    }
                    modulePath = utils.path.removeJS(modulePath);
                    return {
                        plugin: pluginParts.length === 2 ? '!' + pluginParts[1] : undefined,
                        version: versionParts[1],
                        modulePath: modulePath,
                        packageName: packageName,
                        moduleName: moduleName,
                        isGlobal: global
                    };
                },
                parseFromPackage: function (loader, refPkg, name, parentName) {
                    var packageName = utils.pkg.name(refPkg), parsedModuleName = utils.moduleName.parse(name, packageName, undefined, { loader: loader }), isRelative = utils.path.isRelative(parsedModuleName.modulePath);
                    if (isRelative && !parentName) {
                        throw new Error('Cannot resolve a relative module identifier ' + 'with no parent module:', name);
                    }
                    if (isRelative) {
                        var parentParsed = utils.moduleName.parse(parentName, packageName);
                        if (parentParsed.packageName === parsedModuleName.packageName && parentParsed.modulePath) {
                            var makePathRelative = true;
                            if (name === '../' || name === './' || name === '..') {
                                var relativePath = utils.path.relativeTo(parentParsed.modulePath, name);
                                var isInRoot = utils.path.isPackageRootDir(relativePath);
                                if (isInRoot) {
                                    parsedModuleName.modulePath = utils.pkg.main(refPkg);
                                    makePathRelative = false;
                                } else {
                                    parsedModuleName.modulePath = name + (utils.path.endsWithSlash(name) ? '' : '/') + 'index';
                                }
                            }
                            if (makePathRelative) {
                                parsedModuleName.modulePath = utils.path.makeRelative(utils.path.joinURIs(parentParsed.modulePath, parsedModuleName.modulePath));
                            }
                        }
                    }
                    var mapName = utils.moduleName.create(parsedModuleName), refSteal = utils.pkg.config(refPkg), mappedName;
                    if (refPkg.browser && typeof refPkg.browser !== 'string' && mapName in refPkg.browser && (!refSteal || !refSteal.ignoreBrowser)) {
                        mappedName = refPkg.browser[mapName] === false ? '@empty' : refPkg.browser[mapName];
                    }
                    var global = loader && loader.globalBrowser && loader.globalBrowser[mapName];
                    if (global) {
                        mappedName = global.moduleName === false ? '@empty' : global.moduleName;
                    }
                    if (mappedName) {
                        return utils.moduleName.parse(mappedName, packageName, !!global);
                    } else {
                        return parsedModuleName;
                    }
                },
                nameAndVersion: function (parsedModuleName) {
                    return parsedModuleName.packageName + '@' + parsedModuleName.version;
                },
                isBareIdentifier: function (identifier) {
                    return identifier && identifier[0] !== '.' && identifier[0] !== '@';
                }
            },
            pkg: {
                name: function (pkg) {
                    var steal = utils.pkg.config(pkg);
                    return steal && steal.name || pkg.name;
                },
                main: function (pkg) {
                    var main;
                    var steal = utils.pkg.config(pkg);
                    if (steal && steal.main) {
                        main = steal.main;
                    } else if (typeof pkg.browser === 'string') {
                        if (utils.path.endsWithSlash(pkg.browser)) {
                            main = pkg.browser + 'index';
                        } else {
                            main = pkg.browser;
                        }
                    } else if (typeof pkg.jam === 'object' && pkg.jam.main) {
                        main = pkg.jam.main;
                    } else if (pkg.main) {
                        main = pkg.main;
                    } else {
                        main = 'index';
                    }
                    return utils.path.removeJS(utils.path.removeDotSlash(main));
                },
                rootDir: function (pkg, isRoot) {
                    var root = isRoot ? utils.path.removePackage(pkg.fileUrl) : utils.path.pkgDir(pkg.fileUrl);
                    var lib = utils.pkg.directoriesLib(pkg);
                    if (lib) {
                        root = utils.path.joinURIs(utils.path.addEndingSlash(root), lib);
                    }
                    return root;
                },
                isRoot: function (loader, pkg) {
                    var root = utils.pkg.getDefault(loader);
                    return pkg.name === root.name && pkg.version === root.version;
                },
                homeAlias: function (context) {
                    return context && context.loader && context.loader.homeAlias || '~';
                },
                getDefault: function (loader) {
                    return loader.npmPaths.__default;
                },
                findByModuleNameOrAddress: function (loader, moduleName, moduleAddress) {
                    if (loader.npm) {
                        if (moduleName) {
                            var parsed = utils.moduleName.parse(moduleName);
                            if (parsed.version && parsed.packageName) {
                                var name = parsed.packageName + '@' + parsed.version;
                                if (name in loader.npm) {
                                    return loader.npm[name];
                                }
                            }
                        }
                        if (moduleAddress) {
                            var startingAddress = utils.relativeURI(loader.baseURL, moduleAddress);
                            var packageFolder = utils.pkg.folderAddress(startingAddress);
                            return packageFolder ? loader.npmPaths[packageFolder] : utils.pkg.getDefault(loader);
                        } else {
                            return utils.pkg.getDefault(loader);
                        }
                    }
                },
                folderAddress: function (address) {
                    var nodeModules = '/node_modules/', nodeModulesIndex = address.lastIndexOf(nodeModules), nextSlash = address.indexOf('/', nodeModulesIndex + nodeModules.length);
                    if (nodeModulesIndex >= 0) {
                        return nextSlash >= 0 ? address.substr(0, nextSlash) : address;
                    }
                },
                findDep: function (loader, refPkg, name) {
                    if (loader.npm && refPkg && !utils.path.startsWithDotSlash(name)) {
                        var nameAndVersion = name + '@' + refPkg.resolutions[name];
                        var pkg = loader.npm[nameAndVersion];
                        return pkg;
                    }
                },
                findDepWalking: function (loader, refPackage, name) {
                    if (loader.npm && refPackage && !utils.path.startsWithDotSlash(name)) {
                        var curPackage = utils.path.depPackageDir(refPackage.fileUrl, name);
                        while (curPackage) {
                            var pkg = loader.npmPaths[curPackage];
                            if (pkg) {
                                return pkg;
                            }
                            var parentAddress = utils.path.parentNodeModuleAddress(curPackage);
                            if (!parentAddress) {
                                return;
                            }
                            curPackage = parentAddress + '/' + name;
                        }
                    }
                },
                findByName: function (loader, name) {
                    if (loader.npm && !utils.path.startsWithDotSlash(name)) {
                        return loader.npm[name];
                    }
                },
                findByNameAndVersion: function (loader, name, version) {
                    if (loader.npm && !utils.path.startsWithDotSlash(name)) {
                        var nameAndVersion = name + '@' + version;
                        return loader.npm[nameAndVersion];
                    }
                },
                findByUrl: function (loader, url) {
                    if (loader.npm) {
                        var fullUrl = utils.pkg.folderAddress(url);
                        return loader.npmPaths[fullUrl];
                    }
                },
                directoriesLib: function (pkg) {
                    var steal = utils.pkg.config(pkg);
                    var lib = steal && steal.directories && steal.directories.lib;
                    var ignores = [
                            '.',
                            '/'
                        ], ignore;
                    if (!lib)
                        return undefined;
                    while (!!(ignore = ignores.shift())) {
                        if (lib[0] === ignore) {
                            lib = lib.substr(1);
                        }
                    }
                    return lib;
                },
                hasDirectoriesLib: function (pkg) {
                    var steal = utils.pkg.config(pkg);
                    return steal && steal.directories && !!steal.directories.lib;
                },
                findPackageInfo: function (context, pkg) {
                    var pkgInfo = context.pkgInfo;
                    if (pkgInfo) {
                        var out;
                        utils.forEach(pkgInfo, function (p) {
                            if (pkg.name === p.name && pkg.version === p.version) {
                                out = p;
                            }
                        });
                        return out;
                    }
                },
                saveResolution: function (context, refPkg, pkg) {
                    var npmPkg = utils.pkg.findPackageInfo(context, refPkg);
                    npmPkg.resolutions[pkg.name] = refPkg.resolutions[pkg.name] = pkg.version;
                },
                config: function (pkg) {
                    return pkg.steal || pkg.system;
                }
            },
            path: {
                makeRelative: function (path) {
                    if (utils.path.isRelative(path) && path.substr(0, 1) !== '/') {
                        return path;
                    } else {
                        return './' + path;
                    }
                },
                removeJS: function (path) {
                    return path.replace(/\.js(!|$)/, function (whole, part) {
                        return part;
                    });
                },
                removePackage: function (path) {
                    return path.replace(/\/package\.json.*/, '');
                },
                addJS: function (path) {
                    if (/\.js(on)?$/.test(path)) {
                        return path;
                    } else {
                        return path + '.js';
                    }
                },
                isRelative: function (path) {
                    return path.substr(0, 1) === '.';
                },
                isInHomeDir: function (path, context) {
                    return path.substr(0, 2) === utils.pkg.homeAlias(context) + '/';
                },
                joinURIs: function (baseUri, rel) {
                    function removeDotSegments(input) {
                        var output = [];
                        input.replace(/^(\.\.?(\/|$))+/, '').replace(/\/(\.(\/|$))+/g, '/').replace(/\/\.\.$/, '/../').replace(/\/?[^\/]*/g, function (p) {
                            if (p === '/..') {
                                output.pop();
                            } else {
                                output.push(p);
                            }
                        });
                        return output.join('').replace(/^\//, input.charAt(0) === '/' ? '/' : '');
                    }
                    var href = parseURI(rel || '');
                    var base = parseURI(baseUri || '');
                    return !href || !base ? null : (href.protocol || base.protocol) + (href.protocol || href.authority ? href.authority : base.authority) + removeDotSegments(href.protocol || href.authority || href.pathname.charAt(0) === '/' ? href.pathname : href.pathname ? (base.authority && !base.pathname ? '/' : '') + base.pathname.slice(0, base.pathname.lastIndexOf('/') + 1) + href.pathname : base.pathname) + (href.protocol || href.authority || href.pathname ? href.search : href.search || base.search) + href.hash;
                },
                startsWithDotSlash: function (path) {
                    return path.substr(0, 2) === './';
                },
                removeDotSlash: function (path) {
                    return utils.path.startsWithDotSlash(path) ? path.substr(2) : path;
                },
                endsWithSlash: function (path) {
                    return path[path.length - 1] === '/';
                },
                addEndingSlash: function (path) {
                    return utils.path.endsWithSlash(path) ? path : path + '/';
                },
                depPackage: function (parentPackageAddress, childName) {
                    var packageFolderName = parentPackageAddress.replace(/\/package\.json.*/, '');
                    return (packageFolderName ? packageFolderName + '/' : '') + 'node_modules/' + childName + '/package.json';
                },
                peerPackage: function (parentPackageAddress, childName) {
                    var packageFolderName = parentPackageAddress.replace(/\/package\.json.*/, '');
                    return packageFolderName.substr(0, packageFolderName.lastIndexOf('/')) + '/' + childName + '/package.json';
                },
                depPackageDir: function (parentPackageAddress, childName) {
                    return utils.path.depPackage(parentPackageAddress, childName).replace(/\/package\.json.*/, '');
                },
                peerNodeModuleAddress: function (address) {
                    var nodeModules = '/node_modules/', nodeModulesIndex = address.lastIndexOf(nodeModules);
                    if (nodeModulesIndex >= 0) {
                        return address.substr(0, nodeModulesIndex + nodeModules.length - 1);
                    }
                },
                parentNodeModuleAddress: function (address) {
                    var nodeModules = '/node_modules/', nodeModulesIndex = address.lastIndexOf(nodeModules), prevModulesIndex = address.lastIndexOf(nodeModules, nodeModulesIndex - 1);
                    if (prevModulesIndex >= 0) {
                        return address.substr(0, prevModulesIndex + nodeModules.length - 1);
                    }
                },
                pkgDir: function (address) {
                    var nodeModules = '/node_modules/', nodeModulesIndex = address.lastIndexOf(nodeModules), nextSlash = address.indexOf('/', nodeModulesIndex + nodeModules.length);
                    if (address[nodeModulesIndex + nodeModules.length] === '@') {
                        nextSlash = address.indexOf('/', nextSlash + 1);
                    }
                    if (nodeModulesIndex >= 0) {
                        return nextSlash >= 0 ? address.substr(0, nextSlash) : address;
                    }
                },
                basename: function (address) {
                    var parts = address.split('/');
                    return parts[parts.length - 1];
                },
                relativeTo: function (modulePath, rel) {
                    var parts = modulePath.split('/');
                    var idx = 1;
                    while (rel[idx] === '.') {
                        parts.pop();
                        idx++;
                    }
                    return parts.join('/');
                },
                isPackageRootDir: function (pth) {
                    return pth.indexOf('/') === -1;
                }
            },
            json: {
                transform: function (loader, load, data) {
                    data.steal = utils.pkg.config(data);
                    var fn = loader.jsonOptions && loader.jsonOptions.transform;
                    if (!fn)
                        return data;
                    return fn.call(loader, load, data);
                }
            },
            includeInBuild: true
        };
        function parseURI(url) {
            var m = String(url).replace(/^\s+|\s+$/g, '').match(/^([^:\/?#]+:)?(\/\/(?:[^:@\/]*(?::[^:@\/]*)?@)?(([^:\/?#]*)(?::(\d*))?))?([^?#]*)(\?[^#]*)?(#[\s\S]*)?/);
            return m ? {
                href: m[0] || '',
                protocol: m[1] || '',
                authority: m[2] || '',
                host: m[3] || '',
                hostname: m[4] || '',
                port: m[5] || '',
                pathname: m[6] || '',
                search: m[7] || '',
                hash: m[8] || ''
            } : null;
        }
        module.exports = utils;
    }(function () {
        return this;
    }(), require, exports, module));
});
/*npm-extension*/
define('npm-extension', [
    'require',
    'exports',
    'module',
    '@steal',
    './npm-utils'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        'format cjs';
        var steal = require('@steal');
        var utils = require('./npm-utils');
        exports.includeInBuild = true;
        var isNode = typeof process === 'object' && {}.toString.call(process) === '[object process]';
        var isWorker = typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope;
        var isBrowser = typeof window !== 'undefined' && !isNode && !isWorker;
        exports.addExtension = function (System) {
            if (System._extensions) {
                System._extensions.push(exports.addExtension);
            }
            var oldNormalize = System.normalize;
            System.normalize = function (identifier, parentModuleName, parentAddress, pluginNormalize) {
                var name = identifier;
                var parentName = parentModuleName;
                if (parentName && this.npmParentMap && this.npmParentMap[parentName]) {
                    parentName = this.npmParentMap[parentName];
                }
                var hasNoParent = !parentName;
                var nameIsRelative = utils.path.isRelative(name);
                var parentIsNpmModule = utils.moduleName.isNpm(parentName);
                var identifierEndsWithSlash = utils.path.endsWithSlash(name);
                if (parentName && nameIsRelative && !parentIsNpmModule) {
                    return oldNormalize.call(this, name, parentName, parentAddress, pluginNormalize);
                }
                if (utils.moduleName.isConditional(name)) {
                    return oldNormalize.call(this, name, parentName, parentAddress, pluginNormalize);
                }
                var hasContextualMap = typeof this.map[parentName] === 'object' && this.map[parentName][name];
                if (hasContextualMap) {
                    return oldNormalize.call(this, name, parentName, parentAddress, pluginNormalize);
                }
                var refPkg = utils.pkg.findByModuleNameOrAddress(this, parentName, parentAddress);
                if (!refPkg) {
                    return oldNormalize.call(this, name, parentName, parentAddress, pluginNormalize);
                }
                var isPointingAtParentFolder = name === '../' || name === './';
                if (parentIsNpmModule && isPointingAtParentFolder) {
                    var parsedParentModuleName = utils.moduleName.parse(parentName);
                    var parentModulePath = parsedParentModuleName.modulePath || '';
                    var relativePath = utils.path.relativeTo(parentModulePath, name);
                    var isInRoot = utils.path.isPackageRootDir(relativePath);
                    if (isInRoot) {
                        name = refPkg.name + '#' + utils.path.removeJS(refPkg.main);
                    } else {
                        name = name + 'index';
                    }
                }
                var parsedModuleName = utils.moduleName.parseFromPackage(this, refPkg, name, parentName);
                var isRoot = utils.pkg.isRoot(this, refPkg);
                var parsedPackageNameIsReferringPackage = parsedModuleName.packageName === refPkg.name;
                var isRelativeToParentNpmModule = parentIsNpmModule && nameIsRelative && parsedPackageNameIsReferringPackage;
                var depPkg, wantedPkg;
                if (isRelativeToParentNpmModule) {
                    depPkg = refPkg;
                }
                var context = this.npmContext;
                var crawl = context && context.crawl;
                var isDev = !!crawl;
                if (!depPkg) {
                    if (crawl) {
                        var parentPkg = nameIsRelative ? null : crawl.matchedVersion(context, refPkg.name, refPkg.version);
                        if (parentPkg) {
                            var depMap = crawl.getFullDependencyMap(this, parentPkg, isRoot);
                            wantedPkg = depMap[parsedModuleName.packageName];
                            if (wantedPkg) {
                                var wantedVersion = refPkg.resolutions && refPkg.resolutions[wantedPkg.name] || wantedPkg.version;
                                var foundPkg = crawl.matchedVersion(this.npmContext, wantedPkg.name, wantedVersion);
                                if (foundPkg) {
                                    depPkg = utils.pkg.findByUrl(this, foundPkg.fileUrl);
                                }
                            }
                        }
                    } else {
                        if (isRoot) {
                            depPkg = utils.pkg.findDepWalking(this, refPkg, parsedModuleName.packageName);
                        } else {
                            depPkg = utils.pkg.findDep(this, refPkg, parsedModuleName.packageName);
                        }
                    }
                }
                if (parsedPackageNameIsReferringPackage) {
                    depPkg = utils.pkg.findByNameAndVersion(this, parsedModuleName.packageName, refPkg.version);
                }
                var lookupByName = parsedModuleName.isGlobal || hasNoParent;
                if (!depPkg) {
                    depPkg = utils.pkg.findByName(this, parsedModuleName.packageName);
                }
                var isThePackageWeWant = !isDev || !depPkg || (wantedPkg ? crawl.pkgSatisfies(depPkg, wantedPkg.version) : true);
                if (!isThePackageWeWant) {
                    depPkg = undefined;
                } else if (isDev && depPkg) {
                    utils.pkg.saveResolution(context, refPkg, depPkg);
                }
                if (!depPkg) {
                    var browserPackageName = this.globalBrowser[parsedModuleName.packageName];
                    if (browserPackageName) {
                        parsedModuleName.packageName = browserPackageName.moduleName;
                        depPkg = utils.pkg.findByName(this, parsedModuleName.packageName);
                    }
                }
                if (!depPkg && isRoot && name === refPkg.main && utils.pkg.hasDirectoriesLib(refPkg)) {
                    parsedModuleName.version = refPkg.version;
                    parsedModuleName.packageName = refPkg.name;
                    parsedModuleName.modulePath = utils.pkg.main(refPkg);
                    return oldNormalize.call(this, utils.moduleName.create(parsedModuleName), parentName, parentAddress, pluginNormalize);
                }
                var loader = this;
                if (!depPkg) {
                    if (crawl) {
                        var parentPkg = crawl.matchedVersion(this.npmContext, refPkg.name, refPkg.version);
                        if (parentPkg) {
                            var depMap = crawl.getFullDependencyMap(this, parentPkg, isRoot);
                            depPkg = depMap[parsedModuleName.packageName];
                            if (!depPkg) {
                                var parents = crawl.findPackageAndParents(this.npmContext, parsedModuleName.packageName);
                                if (parents) {
                                    depPkg = parents.package;
                                }
                            }
                        }
                    }
                    if (!depPkg) {
                        if (refPkg.browser && refPkg.browser[name]) {
                            return oldNormalize.call(this, refPkg.browser[name], parentName, parentAddress, pluginNormalize);
                        }
                        var steal = utils.pkg.config(refPkg);
                        if (steal && steal.map && typeof steal.map[name] === 'string') {
                            return loader.normalize(steal.map[name], parentName, parentAddress, pluginNormalize);
                        } else {
                            return oldNormalize.call(this, name, parentName, parentAddress, pluginNormalize);
                        }
                    }
                    return crawl.dep(this.npmContext, parentPkg, refPkg, depPkg, isRoot).then(createModuleNameAndNormalize);
                } else {
                    return createModuleNameAndNormalize(depPkg);
                }
                function createModuleNameAndNormalize(depPkg) {
                    parsedModuleName.version = depPkg.version;
                    if (!parsedModuleName.modulePath) {
                        parsedModuleName.modulePath = utils.pkg.main(depPkg);
                    }
                    var p = oldNormalize.call(loader, utils.moduleName.create(parsedModuleName), parentName, parentAddress, pluginNormalize);
                    if (identifierEndsWithSlash) {
                        p.then(function (name) {
                            if (context && context.forwardSlashMap) {
                                context.forwardSlashMap[name] = true;
                            }
                        });
                    }
                    return p;
                }
            };
            var oldLocate = System.locate;
            System.locate = function (load) {
                var parsedModuleName = utils.moduleName.parse(load.name), loader = this;
                load.metadata.parsedModuleName = parsedModuleName;
                if (parsedModuleName.version && this.npm && !loader.paths[load.name]) {
                    var pkg = this.npm[utils.moduleName.nameAndVersion(parsedModuleName)];
                    if (pkg) {
                        return oldLocate.call(this, load).then(function (locatedAddress) {
                            var address = locatedAddress;
                            var expectedAddress = utils.path.joinURIs(System.baseURL, load.name);
                            if (isBrowser) {
                                expectedAddress = expectedAddress.replace(/#/g, '%23');
                            }
                            if (address !== expectedAddress + '.js' && address !== expectedAddress) {
                                return address;
                            }
                            var root = utils.pkg.rootDir(pkg, utils.pkg.isRoot(loader, pkg));
                            if (parsedModuleName.modulePath) {
                                var npmAddress = utils.path.joinURIs(utils.path.addEndingSlash(root), parsedModuleName.plugin ? parsedModuleName.modulePath : utils.path.addJS(parsedModuleName.modulePath));
                                address = typeof steal !== 'undefined' ? utils.path.joinURIs(loader.baseURL, npmAddress) : npmAddress;
                            }
                            return address;
                        });
                    }
                }
                return oldLocate.call(this, load);
            };
            var oldFetch = System.fetch;
            System.fetch = function (load) {
                if (load.metadata.dryRun) {
                    return oldFetch.apply(this, arguments);
                }
                var loader = this;
                var context = loader.npmContext;
                var fetchPromise = Promise.resolve(oldFetch.apply(this, arguments));
                if (utils.moduleName.isNpm(load.name)) {
                    fetchPromise = fetchPromise.then(null, function (err) {
                        if (err.statusCode !== 404) {
                            return Promise.reject(err);
                        }
                        var types = [].slice.call(retryTypes);
                        return retryAll(types, err);
                        function retryAll(types, err) {
                            if (!types.length) {
                                throw err;
                            }
                            var type = types.shift();
                            if (!type.test(load)) {
                                throw err;
                            }
                            return Promise.resolve(retryFetch.call(loader, load, type)).then(null, function (err) {
                                return retryAll(types, err);
                            });
                        }
                    });
                }
                return fetchPromise.catch(function (error) {
                    if (error.statusCode === 404 && utils.moduleName.isBareIdentifier(load.name)) {
                        throw new Error([
                            'Could not load \'' + load.name + '\'',
                            'Is this an npm module not saved in your package.json?'
                        ].join('\n'));
                    } else {
                        throw error;
                    }
                });
            };
            var convertName = function (loader, name) {
                var pkg = utils.pkg.findByName(loader, name.split('/')[0]);
                if (pkg) {
                    var parsed = utils.moduleName.parse(name, pkg.name);
                    parsed.version = pkg.version;
                    if (!parsed.modulePath) {
                        parsed.modulePath = utils.pkg.main(pkg);
                    }
                    return utils.moduleName.create(parsed);
                }
                return name;
            };
            var configSpecial = {
                map: function (map) {
                    var newMap = {}, val;
                    for (var name in map) {
                        val = map[name];
                        newMap[convertName(this, name)] = typeof val === 'object' ? configSpecial.map(val) : convertName(this, val);
                    }
                    return newMap;
                },
                meta: function (map) {
                    var newMap = {};
                    for (var name in map) {
                        newMap[convertName(this, name)] = map[name];
                    }
                    return newMap;
                },
                paths: function (paths) {
                    var newPaths = {};
                    for (var name in paths) {
                        newPaths[convertName(this, name)] = paths[name];
                    }
                    return newPaths;
                }
            };
            var oldConfig = System.config;
            System.config = function (cfg) {
                var loader = this;
                if (loader.npmContext) {
                    var context = loader.npmContext;
                    var pkg = context.versions.__default;
                    context.convert.steal(context, pkg, cfg, true, false, false);
                    oldConfig.apply(loader, arguments);
                    return;
                }
                for (var name in cfg) {
                    if (configSpecial[name]) {
                        cfg[name] = configSpecial[name].call(loader, cfg[name]);
                    }
                }
                oldConfig.apply(loader, arguments);
            };
            steal.addNpmPackages = function (npmPackages) {
                var packages = npmPackages || [];
                var loader = this.loader;
                for (var i = 0; i < packages.length; i += 1) {
                    var pkg = packages[i];
                    var path = pkg && pkg.fileUrl;
                    if (path) {
                        loader.npmContext.paths[path] = pkg;
                    }
                }
            };
            steal.getNpmPackages = function () {
                var context = this.loader.npmContext;
                return context ? context.packages || [] : [];
            };
            function retryFetch(load, type) {
                var loader = this;
                var moduleName = typeof type.name === 'function' ? type.name(loader, load) : load.name + type.name;
                var local = utils.extend({}, load);
                local.name = moduleName;
                local.metadata = { dryRun: true };
                return Promise.resolve(loader.locate(local)).then(function (address) {
                    local.address = address;
                    return loader.fetch(local);
                }).then(function (source) {
                    load.metadata.address = local.address;
                    loader.npmParentMap[load.name] = local.name;
                    var npmLoad = loader.npmContext && loader.npmContext.npmLoad;
                    if (npmLoad) {
                        npmLoad.saveLoadIfNeeded(loader.npmContext);
                        if (!isNode) {
                            utils.warnOnce('Some 404s were encountered ' + 'while loading. Don\'t panic! ' + 'These will only happen in dev ' + 'and are harmless.');
                        }
                    }
                    return source;
                });
            }
            var retryTypes = [
                {
                    name: function (loader, load) {
                        var context = loader.npmContext;
                        if (context.forwardSlashMap[load.name]) {
                            var parts = load.name.split('/');
                            parts.pop();
                            return parts.concat(['index']).join('/');
                        }
                        return load.name + '/index';
                    },
                    test: function () {
                        return true;
                    }
                },
                {
                    name: '.json',
                    test: function (load) {
                        return utils.moduleName.isNpm(load.name) && utils.path.basename(load.address) === 'package.js';
                    }
                }
            ];
        };
    }(function () {
        return this;
    }(), require, exports, module));
});
/*node_modules/steal-conditional/conditional*/
define('node_modules/steal-conditional/conditional', [
    'module',
    'exports'
], function (module, exports) {
    exports.extensionBuilder = 'steal-conditional/slim';
    function addConditionals(loader) {
        var conditionalRegEx = /#\{[^\}]+\}|#\?.+$/;
        var isNode = typeof process === 'object' && {}.toString.call(process) === '[object process]';
        if (loader._extensions) {
            loader._extensions.push(addConditionals);
        }
        loader.set('@@conditional-helpers', loader.newModule({
            isConditionalModuleName: function (moduleName) {
                return conditionalRegEx.test(moduleName);
            }
        }));
        var normalize = loader.normalize;
        function readMemberExpression(p, value) {
            var pParts = p.split('.');
            while (pParts.length) {
                value = value[pParts.shift()];
            }
            return value;
        }
        function includeInBuild(loader, name) {
            var load = loader.getModuleLoad(name);
            load.metadata.includeInBuild = true;
        }
        function getGlob() {
            if (isNode) {
                return loader.import('@node-require', { name: module.id }).then(function (nodeRequire) {
                    return nodeRequire('glob');
                });
            }
            return Promise.resolve();
        }
        function pushIfUnique(array, item) {
            return array.indexOf(item) === -1 ? array.push(item) : array.length;
        }
        function getModuleName(nameWithConditional, variation) {
            var modName;
            var conditionIndex = nameWithConditional.search(conditionalRegEx);
            var lastSlashIndex = nameWithConditional.indexOf('/', nameWithConditional.indexOf('}'));
            if (lastSlashIndex !== -1) {
                modName = nameWithConditional.substr(0, conditionIndex) + variation;
            } else {
                modName = nameWithConditional.replace(conditionalRegEx, variation);
            }
            return modName;
        }
        loader.normalize = function (name, parentName, parentAddress, pluginNormalize) {
            var loader = this;
            var conditionalMatch = name.match(conditionalRegEx);
            if (conditionalMatch) {
                var substitution = conditionalMatch[0][1] !== '?';
                var conditionModule = substitution ? conditionalMatch[0].substr(2, conditionalMatch[0].length - 3) : conditionalMatch[0].substr(2);
                var conditionExport = 'default';
                var conditionExportParts = conditionModule.match(/^(?:\.\/|\.\.\/)+/);
                var conditionExportIndex = conditionModule.indexOf('.', conditionExportParts && conditionExportParts[0].length);
                if (conditionExportIndex !== -1) {
                    conditionExport = conditionModule.substr(conditionExportIndex + 1);
                    conditionModule = conditionModule.substr(0, conditionExportIndex);
                }
                var booleanNegation = !substitution && conditionModule[0] === '~';
                if (booleanNegation) {
                    conditionModule = conditionModule.substr(1);
                }
                var handleConditionalBuild = function () {
                };
                var handleConditionalEval = function (m) {
                    var conditionValue = typeof m === 'object' ? readMemberExpression(conditionExport, m) : m;
                    if (substitution) {
                        if (typeof conditionValue !== 'string') {
                            throw new TypeError('The condition value for ' + conditionalMatch[0] + ' doesn\'t resolve to a string.');
                        }
                        name = name.replace(conditionalRegEx, conditionValue);
                    } else {
                        if (typeof conditionValue !== 'boolean') {
                            throw new TypeError('The condition value for ' + conditionalMatch[0] + ' isn\'t resolving to a boolean.');
                        }
                        if (booleanNegation) {
                            conditionValue = !conditionValue;
                        }
                        if (!conditionValue) {
                            name = '@empty';
                        } else {
                            name = name.replace(conditionalRegEx, '');
                        }
                    }
                    if (name === '@empty') {
                        return normalize.call(loader, name, parentName, parentAddress, pluginNormalize);
                    } else {
                        return loader.normalize.call(loader, name, parentName, parentAddress, pluginNormalize);
                    }
                };
                var isBuild = (loader.env || '').indexOf('build') === 0;
                var pluginLoader = isBuild ? loader : loader.pluginLoader || loader;
                return pluginLoader['import'](conditionModule, {
                    name: parentName,
                    address: parentAddress
                }).then(function (m) {
                    return pluginLoader.normalize(conditionModule, parentName, parentAddress, pluginNormalize).then(function (fullName) {
                        includeInBuild(pluginLoader, fullName);
                        return m;
                    });
                }).then(function (m) {
                    return isBuild ? handleConditionalBuild() : handleConditionalEval(m);
                });
            }
            return Promise.resolve(normalize.call(loader, name, parentName, parentAddress, pluginNormalize));
        };
    }
    if (typeof System !== 'undefined') {
        addConditionals(System);
    }
});
/*npm-load*/
define('npm-load', [], function(){ return {}; });
/*semver*/
define('semver', [], function(){ return {}; });
/*npm-crawl*/
define('npm-crawl', [], function(){ return {}; });
/*npm-convert*/
define('npm-convert', [], function(){ return {}; });
/*npm*/
define('npm', [], function(){ return {}; });
/*package.json!npm*/
define('package.json!npm', [
    '@loader',
    'npm-extension',
    'module',
    './node_modules/steal-conditional/conditional.js'
], function (loader, npmExtension, module) {
    npmExtension.addExtension(loader);
    if (!loader.main) {
        loader.main = 'can@4.0.0-pre.14#can';
    }
    loader._npmExtensions = [].slice.call(arguments, 2);
    (function (loader, packages, options) {
        var g = loader.global;
        if (!g.process) {
            g.process = {
                argv: [],
                cwd: function () {
                    var baseURL = loader.baseURL;
                    return baseURL;
                },
                browser: true,
                env: { NODE_ENV: loader.env },
                version: '',
                platform: navigator && navigator.userAgent && /Windows/.test(navigator.userAgent) ? 'win' : ''
            };
        }
        if (!loader.npm) {
            loader.npm = {};
            loader.npmPaths = {};
            loader.globalBrowser = {};
        }
        if (!loader.npmParentMap) {
            loader.npmParentMap = options.npmParentMap || {};
        }
        var rootPkg = loader.npmPaths.__default = packages[0];
        var rootConfig = rootPkg.steal || rootPkg.system;
        var lib = rootConfig && rootConfig.directories && rootConfig.directories.lib;
        var setGlobalBrowser = function (globals, pkg) {
            for (var name in globals) {
                loader.globalBrowser[name] = {
                    pkg: pkg,
                    moduleName: globals[name]
                };
            }
        };
        var setInNpm = function (name, pkg) {
            if (!loader.npm[name]) {
                loader.npm[name] = pkg;
            }
            loader.npm[name + '@' + pkg.version] = pkg;
        };
        var forEach = function (arr, fn) {
            var i = 0, len = arr.length;
            for (; i < len; i++) {
                res = fn.call(arr, arr[i], i);
                if (res === false)
                    break;
            }
        };
        var setupLiveReload = function () {
            if (loader.liveReloadInstalled) {
                loader['import']('live-reload', { name: module.id }).then(function (reload) {
                    reload.dispose(function () {
                        var pkgInfo = loader.npmContext.pkgInfo;
                        delete pkgInfo[rootPkg.name + '@' + rootPkg.version];
                        var idx = -1;
                        forEach(pkgInfo, function (pkg, i) {
                            if (pkg.name === rootPkg.name && pkg.version === rootPkg.version) {
                                idx = i;
                                return false;
                            }
                        });
                        pkgInfo.splice(idx, 1);
                    });
                });
            }
        };
        var ignoredConfig = [
            'bundle',
            'configDependencies',
            'transpiler'
        ];
        packages.reverse();
        forEach(packages, function (pkg) {
            var steal = pkg.steal || pkg.system;
            if (steal) {
                var main = steal.main;
                delete steal.main;
                var configDeps = steal.configDependencies;
                if (pkg !== rootPkg) {
                    forEach(ignoredConfig, function (name) {
                        delete steal[name];
                    });
                }
                loader.config(steal);
                if (pkg === rootPkg) {
                    steal.configDependencies = configDeps;
                }
                steal.main = main;
            }
            if (pkg.globalBrowser) {
                var doNotApplyGlobalBrowser = pkg.name === 'steal' && rootConfig.builtins === false;
                if (!doNotApplyGlobalBrowser) {
                    setGlobalBrowser(pkg.globalBrowser, pkg);
                }
            }
            var systemName = steal && steal.name;
            if (systemName) {
                setInNpm(systemName, pkg);
            } else {
                setInNpm(pkg.name, pkg);
            }
            if (!loader.npm[pkg.name]) {
                loader.npm[pkg.name] = pkg;
            }
            loader.npm[pkg.name + '@' + pkg.version] = pkg;
            var pkgAddress = pkg.fileUrl.replace(/\/package\.json.*/, '');
            loader.npmPaths[pkgAddress] = pkg;
        });
        setupLiveReload();
        forEach(loader._npmExtensions || [], function (ext) {
            if (ext.systemConfig) {
                loader.config(ext.systemConfig);
            }
        });
    }(loader, [
        {
            'name': 'can',
            'version': '4.0.0-pre.14',
            'fileUrl': './package.json',
            'main': 'can.js',
            'steal': {
                'npmAlgorithm': 'flat',
                'main': 'can',
                'npmIgnore': {
                    'bit-docs': true,
                    'testee': true,
                    'async': true,
                    'saucelabs': true,
                    'test-saucelabs': true,
                    'wd': true,
                    'http-server': true
                },
                'meta': { 'socket.io-client/dist/socket.io': { 'format': 'cjs' } },
                'configDependencies': ['./node_modules/steal-conditional/conditional.js']
            },
            'resolutions': {
                'can': '4.0.0-pre.14',
                'can-component': '4.0.1',
                'can-define': '2.0.1',
                'can-stache-bindings': '4.0.5',
                'can-set': '1.5.1',
                'can-ajax': '1.1.4',
                'can-assign': '1.1.1',
                'can-construct': '3.3.0',
                'can-construct-super': '3.1.4',
                'can-control': '4.0.1',
                'can-define-lazy-value': '1.0.1',
                'can-deparam': '1.0.3',
                'can-dom-events': '1.1.1',
                'can-event-dom-enter': '2.1.0',
                'can-event-dom-radiochange': '2.1.0',
                'can-event-queue': '1.0.0',
                'can-globals': '1.0.0',
                'can-key-tree': '1.0.0',
                'can-param': '1.0.2',
                'can-parse-uri': '1.0.1',
                'can-queues': '1.0.0',
                'can-reflect': '1.13.2',
                'can-reflect-dependencies': '1.0.0',
                'can-reflect-promise': '2.0.1',
                'can-simple-dom': '1.3.4',
                'can-simple-observable': '2.0.1',
                'can-stache-key': '1.0.0',
                'can-symbol': '1.6.0',
                'can-util': '3.11.2',
                'can-validate-interface': '1.0.0',
                'can-view-live': '4.0.1',
                'can-view-model': '4.0.0',
                'can-view-nodelist': '4.0.1',
                'can-view-parser': '4.0.1',
                'can-view-scope': '4.0.1',
                'can-view-target': '4.0.0',
                'can-stache-converters': '4.0.1',
                'can-compute': '4.0.0',
                'can-list': '4.0.0',
                'can-map': '4.0.0',
                'can-fixture': '2.0.2',
                'can-kefir': '1.0.1',
                'can-stream': '1.0.0',
                'can-stream-kefir': '1.0.0',
                'can-ndjson-stream': '0.1.7',
                'can-define-stream': '1.0.0',
                'can-define-stream-kefir': '1.0.0',
                'can-validate': '1.1.3',
                'can-validate-validatejs': '0.1.2',
                'can-define-validate-validatejs': '1.0.0',
                'can-view-autorender': '4.0.0',
                'react-view-model': '1.0.0',
                'funcunit': '3.5.0',
                'steal-qunit': '1.0.1'
            }
        },
        {
            'name': 'can-component',
            'version': '4.0.1',
            'fileUrl': './node_modules/can-component/package.json',
            'main': 'can-component',
            'steal': {},
            'resolutions': {
                'can-component': '4.0.1',
                'can-view-model': '4.0.0',
                'can-simple-observable': '2.0.1',
                'can-define': '2.0.1',
                'can-view-scope': '4.0.1',
                'can-reflect': '1.13.2',
                'can-symbol': '1.6.0',
                'can-dom-events': '1.1.1',
                'can-construct': '3.3.0',
                'can-queues': '1.0.0',
                'can-util': '3.11.2',
                'can-dom-mutate': '1.0.2',
                'can-stache': '4.0.2',
                'can-dom-data-state': '1.0.1',
                'can-observe': '2.0.1',
                'can-view-callbacks': '4.0.0',
                'steal-qunit': '1.0.1',
                'can-simple-map': '4.0.0',
                'can-vdom': '4.0.0',
                'can-globals': '1.0.0',
                'can-namespace': '1.0.0',
                'can-stache-bindings': '4.0.5',
                'can-view-nodelist': '4.0.1',
                'can-log': '1.0.0',
                'can-assign': '1.1.1',
                'can-control': '4.0.1'
            }
        },
        {
            'name': 'can-define',
            'version': '2.0.1',
            'fileUrl': './node_modules/can-define/package.json',
            'main': 'can-define.js',
            'resolutions': {
                'can-define': '2.0.1',
                'can-queues': '1.0.0',
                'can-util': '3.11.2',
                'can-symbol': '1.6.0',
                'can-simple-observable': '2.0.1',
                'can-reflect': '1.13.2',
                'steal-qunit': '1.0.1',
                'can-test-helpers': '1.1.1',
                'can-observation': '4.0.0',
                'can-log': '1.0.0',
                'can-reflect-tests': '0.2.0',
                'can-construct': '3.3.0',
                'can-observation-recorder': '1.0.1',
                'can-namespace': '1.0.0',
                'can-event-queue': '1.0.0',
                'can-define-lazy-value': '1.0.1'
            }
        },
        {
            'name': 'can-stache-bindings',
            'version': '4.0.5',
            'fileUrl': './node_modules/can-stache-bindings/package.json',
            'main': 'can-stache-bindings',
            'steal': { 'main': 'can-stache-bindings' },
            'resolutions': {
                'can-stache-bindings': '4.0.5',
                'can-reflect': '1.13.2',
                'can-dom-events': '1.1.1',
                'can-dom-mutate': '1.0.2',
                'can-stache': '4.0.2',
                'can-simple-map': '4.0.0',
                'can-test-helpers': '1.1.1',
                'can-define': '2.0.1',
                'can-view-model': '4.0.0',
                'can-simple-observable': '2.0.1',
                'can-symbol': '1.6.0',
                'can-util': '3.11.2',
                'can-dom-data-state': '1.0.1',
                'can-event-dom-enter': '2.1.0',
                'can-view-callbacks': '4.0.0',
                'can-queues': '1.0.0',
                'can-reflect-dependencies': '1.0.0',
                'can-globals': '1.0.0',
                'can-observation': '4.0.0',
                'can-observation-recorder': '1.0.1',
                'can-event-dom-radiochange': '2.1.0',
                'steal-qunit': '1.0.1',
                'can-vdom': '4.0.0',
                'can-stache-key': '1.0.0',
                'can-log': '1.0.0',
                'can-attribute-encoder': '1.0.0',
                'can-view-scope': '4.0.1',
                'can-view-nodelist': '4.0.1',
                'can-types': '1.1.6'
            }
        },
        {
            'name': 'can-set',
            'version': '1.5.1',
            'fileUrl': './node_modules/can-set/package.json',
            'main': 'src/set.js',
            'steal': { 'plugins': ['steal-qunit'] },
            'resolutions': {
                'can-set': '1.5.1',
                'can-assign': '1.1.1',
                'steal-qunit': '1.0.1',
                'can-namespace': '1.0.0',
                'can-util': '3.11.2'
            }
        },
        {
            'name': 'can-ajax',
            'version': '1.1.4',
            'fileUrl': './node_modules/can-ajax/package.json',
            'main': 'dist/cjs/can-ajax',
            'steal': {
                'npmIgnore': {
                    'testee': true,
                    'generator-donejs': true,
                    'donejs-cli': true,
                    'steal-tools': true
                },
                'main': 'can-ajax'
            },
            'resolutions': {
                'can-ajax': '1.1.4',
                'can-globals': '1.0.0',
                'can-parse-uri': '1.0.1',
                'can-namespace': '1.0.0',
                'can-make-map': '1.0.1',
                'can-reflect': '1.13.2',
                'can-param': '1.0.2',
                'qunitjs': '2.4.1',
                'steal-qunit': '1.0.1'
            }
        },
        {
            'name': 'can-assign',
            'version': '1.1.1',
            'fileUrl': './node_modules/can-assign/package.json',
            'main': 'dist/cjs/can-assign',
            'steal': {
                'npmIgnore': {
                    'testee': true,
                    'generator-donejs': true,
                    'donejs-cli': true,
                    'steal-tools': true
                },
                'main': 'can-assign'
            },
            'resolutions': {
                'can-assign': '1.1.1',
                'steal-qunit': '1.0.1'
            }
        },
        {
            'name': 'can-construct',
            'version': '3.3.0',
            'fileUrl': './node_modules/can-construct/package.json',
            'main': 'can-construct',
            'steal': {},
            'resolutions': {
                'can-construct': '3.3.0',
                'can-util': '3.11.2',
                'steal-qunit': '1.0.1',
                'can-namespace': '1.0.0'
            }
        },
        {
            'name': 'can-construct-super',
            'version': '3.1.4',
            'fileUrl': './node_modules/can-construct-super/package.json',
            'main': 'can-construct-super',
            'steal': {
                'npmIgnore': {
                    'documentjs': true,
                    'testee': true,
                    'generator-donejs': true,
                    'donejs-cli': true,
                    'steal-tools': true
                },
                'main': 'can-construct-super'
            },
            'resolutions': {
                'can-construct-super': '3.1.4',
                'steal-qunit': '1.0.1',
                'can-util': '3.11.2',
                'can-construct': '3.3.0'
            }
        },
        {
            'name': 'can-control',
            'version': '4.0.1',
            'fileUrl': './node_modules/can-control/package.json',
            'main': 'can-control',
            'resolutions': {
                'can-control': '4.0.1',
                'can-util': '3.11.2',
                'can-dom-events': '1.1.1',
                'can-define': '2.0.1',
                'can-simple-observable': '2.0.1',
                'can-dom-mutate': '1.0.2',
                'can-simple-map': '4.0.0',
                'steal-qunit': '1.0.1',
                'can-construct': '3.3.0',
                'can-namespace': '1.0.0',
                'can-assign': '1.1.1',
                'can-stache-key': '1.0.0',
                'can-reflect': '1.13.2',
                'can-observation': '4.0.0',
                'can-event-queue': '1.0.0',
                'can-log': '1.0.0'
            }
        },
        {
            'name': 'can-define-lazy-value',
            'version': '1.0.1',
            'fileUrl': './node_modules/can-define-lazy-value/package.json',
            'main': 'define-lazy-value',
            'steal': {
                'npmIgnore': {
                    'testee': true,
                    'steal-tools': true
                }
            },
            'resolutions': {
                'can-define-lazy-value': '1.0.1',
                'steal-qunit': '1.0.1'
            }
        },
        {
            'name': 'can-deparam',
            'version': '1.0.3',
            'fileUrl': './node_modules/can-deparam/package.json',
            'main': 'dist/cjs/can-deparam',
            'steal': {
                'npmIgnore': {
                    'testee': true,
                    'generator-donejs': true,
                    'donejs-cli': true,
                    'steal-tools': true
                },
                'main': 'can-deparam'
            },
            'resolutions': {
                'can-deparam': '1.0.3',
                'steal-qunit': '1.0.1',
                'can-namespace': '1.0.0'
            }
        },
        {
            'name': 'can-dom-events',
            'version': '1.1.1',
            'fileUrl': './node_modules/can-dom-events/package.json',
            'main': 'can-dom-events',
            'resolutions': {
                'can-dom-events': '1.1.1',
                'can-namespace': '1.0.0',
                'steal-qunit': '1.0.1',
                'can-globals': '1.0.0',
                'can-key-tree': '1.0.0',
                'can-reflect': '1.13.2',
                'jquery': '3.3.1'
            }
        },
        {
            'name': 'can-event-dom-enter',
            'version': '2.1.0',
            'fileUrl': './node_modules/can-event-dom-enter/package.json',
            'main': 'can-event-dom-enter',
            'steal': {
                'npmIgnore': {
                    'testee': true,
                    'steal-tools': true
                },
                'main': 'can-event-dom-enter'
            },
            'resolutions': {
                'can-dom-events': '1.1.1',
                'can-event-dom-enter': '2.1.0',
                'can-namespace': '1.0.0',
                'steal-qunit': '1.0.1'
            }
        },
        {
            'name': 'can-event-dom-radiochange',
            'version': '2.1.0',
            'fileUrl': './node_modules/can-event-dom-radiochange/package.json',
            'main': 'can-event-dom-radiochange',
            'steal': {
                'npmIgnore': {
                    'testee': true,
                    'steal-tools': true
                },
                'main': 'can-event-dom-radiochange'
            },
            'resolutions': {
                'can-dom-events': '1.1.1',
                'can-event-dom-radiochange': '2.1.0',
                'steal-qunit': '1.0.1',
                'can-namespace': '1.0.0',
                'can-globals': '1.0.0'
            }
        },
        {
            'name': 'can-event-queue',
            'version': '1.0.0',
            'fileUrl': './node_modules/can-event-queue/package.json',
            'main': './can-event-queue.js',
            'steal': {
                'npmIgnore': {
                    'testee': true,
                    'generator-donejs': true,
                    'donejs-cli': true,
                    'steal-tools': true
                },
                'plugins': [
                    'steal-less',
                    'steal-stache'
                ]
            },
            'resolutions': {
                'can-event-queue': '1.0.0',
                'can-queues': '1.0.0',
                'can-dom-events': '1.1.1',
                'can-symbol': '1.6.0',
                'can-reflect': '1.13.2',
                'steal-qunit': '1.0.1',
                'can-log': '1.0.0',
                'can-key-tree': '1.0.0',
                'can-define-lazy-value': '1.0.1'
            }
        },
        {
            'name': 'can-globals',
            'version': '1.0.0',
            'fileUrl': './node_modules/can-globals/package.json',
            'main': 'can-globals.js',
            'resolutions': {
                'can-globals': '1.0.0',
                'can-reflect': '1.13.2',
                'qunitjs': '2.4.1',
                'steal-qunit': '1.0.1',
                'can-namespace': '1.0.0'
            }
        },
        {
            'name': 'can-key-tree',
            'version': '1.0.0',
            'fileUrl': './node_modules/can-key-tree/package.json',
            'main': 'dist/cjs/can-key-tree',
            'steal': {
                'npmIgnore': {
                    'testee': true,
                    'generator-donejs': true,
                    'donejs-cli': true,
                    'steal-tools': true
                },
                'plugins': [
                    'steal-less',
                    'steal-stache'
                ],
                'main': 'can-key-tree'
            },
            'browser': {},
            'resolutions': {
                'can-key-tree': '1.0.0',
                'can-reflect': '1.13.2',
                'steal-qunit': '1.0.1'
            }
        },
        {
            'name': 'can-param',
            'version': '1.0.2',
            'fileUrl': './node_modules/can-param/package.json',
            'main': 'dist/cjs/can-param',
            'steal': {
                'npmIgnore': {
                    'testee': true,
                    'generator-donejs': true,
                    'donejs-cli': true,
                    'steal-tools': true
                },
                'main': 'can-param'
            },
            'resolutions': {
                'can-param': '1.0.2',
                'steal-qunit': '1.0.1',
                'can-namespace': '1.0.0'
            }
        },
        {
            'name': 'can-parse-uri',
            'version': '1.0.1',
            'fileUrl': './node_modules/can-parse-uri/package.json',
            'main': 'dist/cjs/can-parse-uri',
            'steal': {
                'npmIgnore': {
                    'testee': true,
                    'generator-donejs': true,
                    'donejs-cli': true,
                    'steal-tools': true
                },
                'main': 'can-parse-uri'
            },
            'resolutions': {
                'can-parse-uri': '1.0.1',
                'steal-qunit': '1.0.1'
            }
        },
        {
            'name': 'can-queues',
            'version': '1.0.0',
            'fileUrl': './node_modules/can-queues/package.json',
            'main': './can-queues.js',
            'steal': {
                'npmIgnore': {
                    'testee': true,
                    'generator-donejs': true,
                    'donejs-cli': true,
                    'steal-tools': true
                },
                'main': 'can-queues'
            },
            'resolutions': {
                'can-queues': '1.0.0',
                'can-util': '3.11.2',
                'steal-qunit': '1.0.1',
                'can-namespace': '1.0.0',
                'can-log': '1.0.0',
                'can-assign': '1.1.1'
            }
        },
        {
            'name': 'can-reflect',
            'version': '1.13.2',
            'fileUrl': './node_modules/can-reflect/package.json',
            'main': 'can-reflect',
            'resolutions': {
                'can-reflect': '1.13.2',
                'can-symbol': '1.6.0',
                'can-namespace': '1.0.0',
                'steal-qunit': '1.0.1'
            }
        },
        {
            'name': 'can-reflect-dependencies',
            'version': '1.0.0',
            'fileUrl': './node_modules/can-reflect-dependencies/package.json',
            'main': 'can-reflect-dependencies.js',
            'resolutions': {
                'can-simple-observable': '2.0.1',
                'can-reflect-dependencies': '1.0.0',
                'steal-qunit': '1.0.1',
                'can-simple-map': '4.0.0',
                'can-reflect': '1.13.2',
                'can-symbol': '1.6.0'
            }
        },
        {
            'name': 'can-reflect-promise',
            'version': '2.0.1',
            'fileUrl': './node_modules/can-reflect-promise/package.json',
            'main': 'can-reflect-promise',
            'steal': { 'npmAlgorithm': 'flat' },
            'resolutions': {
                'can-util': '3.11.2',
                'can-symbol': '1.6.0',
                'can-reflect-promise': '2.0.1',
                'can-observation-recorder': '1.0.1',
                'can-test-helpers': '1.1.1',
                'steal-qunit': '1.0.1',
                'can-reflect': '1.13.2',
                'can-queues': '1.0.0',
                'can-key-tree': '1.0.0',
                'can-log': '1.0.0'
            }
        },
        {
            'name': 'can-simple-dom',
            'version': '1.3.4',
            'fileUrl': './node_modules/can-simple-dom/package.json',
            'main': 'dist/cjs/simple-dom.js',
            'steal': {
                'directories': { 'lib': 'lib' },
                'npmIgnore': { 'testee': true },
                'main': 'simple-dom.js'
            },
            'resolutions': {
                'can-simple-dom': '1.3.4',
                'steal-qunit': '1.0.1',
                'he': '1.1.1',
                'simple-html-tokenizer': '0.2.6',
                'micro-location': '0.1.5'
            }
        },
        {
            'name': 'can-simple-observable',
            'version': '2.0.1',
            'fileUrl': './node_modules/can-simple-observable/package.json',
            'main': 'can-simple-observable',
            'steal': {
                'npmIgnore': {
                    'testee': true,
                    'steal-tools': true
                }
            },
            'resolutions': {
                'can-symbol': '1.6.0',
                'can-simple-observable': '2.0.1',
                'can-reflect': '1.13.2',
                'steal-qunit': '1.0.1',
                'can-observation-recorder': '1.0.1',
                'can-observation': '4.0.0',
                'can-queues': '1.0.0',
                'can-event-queue': '1.0.0',
                'can-namespace': '1.0.0',
                'can-log': '1.0.0'
            }
        },
        {
            'name': 'can-stache-key',
            'version': '1.0.0',
            'fileUrl': './node_modules/can-stache-key/package.json',
            'main': 'can-stache-key',
            'steal': {
                'npmIgnore': {
                    'testee': true,
                    'generator-donejs': true,
                    'donejs-cli': true,
                    'steal-tools': true
                },
                'main': 'can-stache-key'
            },
            'resolutions': {
                'can-stache-key': '1.0.0',
                'can-event-queue': '1.0.0',
                'can-simple-observable': '2.0.1',
                'can-reflect': '1.13.2',
                'can-test-helpers': '1.1.1',
                'can-observation': '4.0.0',
                'steal-qunit': '1.0.1',
                'can-observation-recorder': '1.0.1',
                'can-simple-map': '4.0.0',
                'can-log': '1.0.0',
                'can-util': '3.11.2',
                'can-symbol': '1.6.0',
                'can-reflect-promise': '2.0.1'
            }
        },
        {
            'name': 'can-symbol',
            'version': '1.6.0',
            'fileUrl': './node_modules/can-symbol/package.json',
            'main': 'can-symbol',
            'steal': {
                'npmIgnore': {
                    'testee': true,
                    'generator-donejs': true,
                    'donejs-cli': true,
                    'steal-tools': true
                },
                'main': 'can-symbol'
            },
            'resolutions': {
                'can-symbol': '1.6.0',
                'steal-qunit': '1.0.1',
                'can-namespace': '1.0.0'
            }
        },
        {
            'name': 'can-util',
            'version': '3.11.2',
            'fileUrl': './node_modules/can-util/package.json',
            'main': 'can-util',
            'resolutions': {
                'can-util': '3.11.2',
                'can-globals': '1.0.0',
                'can-symbol': '1.6.0',
                'qunitjs': '2.4.1',
                'steal-qunit': '1.0.1',
                'can-assign': '1.1.1',
                'can-reflect': '1.13.2',
                'can-parse-uri': '1.0.1',
                'can-log': '1.0.0',
                'can-cid': '1.1.2'
            }
        },
        {
            'name': 'can-validate-interface',
            'version': '1.0.0',
            'fileUrl': './node_modules/can-validate-interface/package.json',
            'main': 'index.js',
            'resolutions': {
                'can-validate-interface': '1.0.0',
                'can-connect': '2.0.1',
                'steal-qunit': '1.0.1'
            }
        },
        {
            'name': 'can-view-live',
            'version': '4.0.1',
            'fileUrl': './node_modules/can-view-live/package.json',
            'main': 'can-view-live',
            'steal': {
                'npmIgnore': {
                    'documentjs': true,
                    'testee': true,
                    'generator-donejs': true,
                    'donejs-cli': true,
                    'steal-tools': true
                },
                'main': 'can-view-live'
            },
            'resolutions': {
                'can-view-live': '4.0.1',
                'can-define': '2.0.1',
                'can-observation': '4.0.0',
                'can-simple-observable': '2.0.1',
                'can-view-nodelist': '4.0.1',
                'can-test-helpers': '1.1.1',
                'can-symbol': '1.6.0',
                'can-simple-map': '4.0.0',
                'can-reflect': '1.13.2',
                'can-queues': '1.0.0',
                'can-util': '3.11.2',
                'can-dom-mutate': '1.0.2',
                'can-reflect-dependencies': '1.0.0',
                'steal-qunit': '1.0.1',
                'can-key-tree': '1.0.0',
                'can-view-parser': '4.0.1',
                'can-view-callbacks': '4.0.0'
            }
        },
        {
            'name': 'can-view-model',
            'version': '4.0.0',
            'fileUrl': './node_modules/can-view-model/package.json',
            'main': 'can-view-model',
            'resolutions': {
                'can-view-model': '4.0.0',
                'can-simple-map': '4.0.0',
                'steal-qunit': '1.0.1',
                'can-namespace': '1.0.0',
                'can-globals': '1.0.0',
                'can-reflect': '1.13.2',
                'can-symbol': '1.6.0'
            }
        },
        {
            'name': 'can-view-nodelist',
            'version': '4.0.1',
            'fileUrl': './node_modules/can-view-nodelist/package.json',
            'main': 'can-view-nodelist',
            'resolutions': {
                'can-view-nodelist': '4.0.1',
                'can-util': '3.11.2',
                'steal-qunit': '1.0.1',
                'can-namespace': '1.0.0',
                'can-dom-mutate': '1.0.2'
            }
        },
        {
            'name': 'can-view-parser',
            'version': '4.0.1',
            'fileUrl': './node_modules/can-view-parser/package.json',
            'main': 'can-view-parser',
            'resolutions': {
                'can-view-parser': '4.0.1',
                'can-log': '1.0.0',
                'can-attribute-encoder': '1.0.0',
                'steal-qunit': '1.0.1',
                'can-test-helpers': '1.1.1',
                'can-namespace': '1.0.0'
            }
        },
        {
            'name': 'can-view-scope',
            'version': '4.0.1',
            'fileUrl': './node_modules/can-view-scope/package.json',
            'main': 'can-view-scope',
            'resolutions': {
                'can-view-scope': '4.0.1',
                'can-stache-key': '1.0.0',
                'can-symbol': '1.6.0',
                'can-reflect': '1.13.2',
                'can-simple-observable': '2.0.1',
                'can-reflect-dependencies': '1.0.0',
                'can-test-helpers': '1.1.1',
                'can-observation': '4.0.0',
                'can-stache-helpers': '1.0.0',
                'steal-qunit': '1.0.1',
                'can-simple-map': '4.0.0',
                'can-observation-recorder': '1.0.1',
                'can-assign': '1.1.1',
                'can-util': '3.11.2',
                'can-namespace': '1.0.0',
                'can-log': '1.0.0',
                'can-define-lazy-value': '1.0.1',
                'can-cid': '1.1.2',
                'can-event-queue': '1.0.0'
            }
        },
        {
            'name': 'can-view-target',
            'version': '4.0.0',
            'fileUrl': './node_modules/can-view-target/package.json',
            'main': 'can-view-target',
            'resolutions': {
                'can-view-target': '4.0.0',
                'can-simple-dom': '1.3.4',
                'can-globals': '1.0.0',
                'steal-qunit': '1.0.1',
                'can-dom-mutate': '1.0.2',
                'can-namespace': '1.0.0'
            }
        },
        {
            'name': 'can-stache-converters',
            'version': '4.0.1',
            'fileUrl': './node_modules/can-stache-converters/package.json',
            'main': 'can-stache-converters',
            'steal': { 'main': 'can-stache-converters' },
            'resolutions': {
                'can-stache-converters': '4.0.1',
                'can-define': '2.0.1',
                'can-util': '3.11.2',
                'can-dom-events': '1.1.1',
                'can-compute': '4.0.0',
                'can-stache': '4.0.2',
                'steal-qunit': '1.0.1',
                'can-reflect': '1.13.2',
                'can-stache-bindings': '4.0.5'
            }
        },
        {
            'name': 'can-compute',
            'version': '4.0.0',
            'fileUrl': './node_modules/can-compute/package.json',
            'main': 'can-compute',
            'resolutions': {
                'can-compute': '4.0.0',
                'can-util': '3.11.2',
                'can-symbol': '1.6.0',
                'can-reflect': '1.13.2',
                'can-event-queue': '1.0.0',
                'can-queues': '1.0.0',
                'steal-qunit': '1.0.1',
                'can-observation-recorder': '1.0.1',
                'can-namespace': '1.0.0',
                'can-observation': '4.0.0',
                'can-stache-key': '1.0.0',
                'can-assign': '1.1.1'
            }
        },
        {
            'name': 'can-list',
            'version': '4.0.0',
            'fileUrl': './node_modules/can-list/package.json',
            'main': 'can-list',
            'steal': { 'npmAlgorithm': 'flat' },
            'resolutions': {
                'can-list': '4.0.0',
                'can-map': '4.0.0',
                'can-reflect': '1.13.2',
                'can-symbol': '1.6.0',
                'steal-qunit': '1.0.1',
                'can-observation': '4.0.0',
                'can-namespace': '1.0.0',
                'can-queues': '1.0.0',
                'can-event-queue': '1.0.0',
                'can-util': '3.11.2',
                'can-cid': '1.1.2',
                'can-types': '1.1.6'
            }
        },
        {
            'name': 'can-map',
            'version': '4.0.0',
            'fileUrl': './node_modules/can-map/package.json',
            'main': 'can-map',
            'steal': {},
            'resolutions': {
                'can-map': '4.0.0',
                'can-compute': '4.0.0',
                'can-construct': '3.3.0',
                'can-stache-key': '1.0.0',
                'can-reflect': '1.13.2',
                'can-symbol': '1.6.0',
                'can-queues': '1.0.0',
                'can-observation-recorder': '1.0.1',
                'can-reflect-tests': '0.2.0',
                'steal-qunit': '1.0.1',
                'can-event-queue': '1.0.0',
                'can-util': '3.11.2',
                'can-namespace': '1.0.0',
                'can-cid': '1.1.2',
                'can-types': '1.1.6'
            }
        },
        {
            'name': 'can-fixture',
            'version': '2.0.2',
            'fileUrl': './node_modules/can-fixture/package.json',
            'main': 'fixture.js',
            'resolutions': {
                'can-fixture': '2.0.2',
                'can-set': '1.5.1',
                'can-util': '3.11.2',
                'jquery': '3.3.1',
                'steal-qunit': '1.0.1',
                'can-namespace': '1.0.0',
                'can-connect': '2.0.1',
                'can-deparam': '1.0.3'
            }
        },
        {
            'name': 'can-kefir',
            'version': '1.0.1',
            'fileUrl': './node_modules/can-kefir/package.json',
            'main': 'can-kefir',
            'browser': {},
            'resolutions': {
                'can-kefir': '1.0.1',
                'can-queues': '1.0.0',
                'can-reflect': '1.13.2',
                'steal-qunit': '1.0.1',
                'can-symbol': '1.6.0',
                'can-event-queue': '1.0.0',
                'can-observation-recorder': '1.0.1',
                'kefir': '3.8.1'
            }
        },
        {
            'name': 'can-stream',
            'version': '1.0.0',
            'fileUrl': './node_modules/can-stream/package.json',
            'main': 'can-stream',
            'steal': {},
            'resolutions': {
                'can-compute': '4.0.0',
                'can-define': '2.0.1',
                'can-stream': '1.0.0',
                'steal-qunit': '1.0.1',
                'can-assign': '1.1.1',
                'can-reflect': '1.13.2',
                'can-namespace': '1.0.0'
            }
        },
        {
            'name': 'can-stream-kefir',
            'version': '1.0.0',
            'fileUrl': './node_modules/can-stream-kefir/package.json',
            'main': 'can-stream-kefir',
            'steal': {},
            'resolutions': {
                'can-stream-kefir': '1.0.0',
                'can-compute': '4.0.0',
                'can-reflect': '1.13.2',
                'can-define': '2.0.1',
                'steal-qunit': '1.0.1',
                'can-kefir': '1.0.1',
                'can-stream': '1.0.0',
                'can-symbol': '1.6.0',
                'can-namespace': '1.0.0'
            }
        },
        {
            'name': 'can-ndjson-stream',
            'version': '0.1.7',
            'fileUrl': './node_modules/can-ndjson-stream/package.json',
            'main': 'can-ndjson-stream',
            'steal': {
                'npmIgnore': {
                    'testee': true,
                    'generator-donejs': true,
                    'donejs-cli': true,
                    'steal-tools': true
                },
                'main': 'can-ndjson-stream'
            },
            'resolutions': {
                'can-ndjson-stream': '0.1.7',
                'steal-qunit': '1.0.1',
                'can-namespace': '1.0.0'
            }
        },
        {
            'name': 'can-define-stream',
            'version': '1.0.0',
            'fileUrl': './node_modules/can-define-stream/package.json',
            'main': 'can-define-stream',
            'steal': {},
            'resolutions': {
                'can-define': '2.0.1',
                'can-define-stream': '1.0.0',
                'can-compute': '4.0.0',
                'can-stream': '1.0.0',
                'can-symbol': '1.6.0',
                'steal-qunit': '1.0.1',
                'can-assign': '1.1.1',
                'can-reflect': '1.13.2'
            }
        },
        {
            'name': 'can-define-stream-kefir',
            'version': '1.0.0',
            'fileUrl': './node_modules/can-define-stream-kefir/package.json',
            'main': 'can-define-stream-kefir',
            'steal': {},
            'resolutions': {
                'can-define': '2.0.1',
                'can-define-stream-kefir': '1.0.0',
                'can-symbol': '1.6.0',
                'steal-qunit': '1.0.1',
                'can-namespace': '1.0.0',
                'can-define-stream': '1.0.0',
                'can-stream-kefir': '1.0.0'
            }
        },
        {
            'name': 'can-validate',
            'version': '1.1.3',
            'fileUrl': './node_modules/can-validate/package.json',
            'main': 'can-validate.js',
            'steal': {
                'ignoreBrowser': true,
                'npmIgnore': {
                    'documentjs': true,
                    'testee': true,
                    'steal-tools': true
                },
                'npmDependencies': { 'steal-qunit': true }
            },
            'browser': {},
            'resolutions': {
                'can-validate': '1.1.3',
                'steal-qunit': '1.0.1',
                'can-reflect': '1.13.2'
            }
        },
        {
            'name': 'can-validate-validatejs',
            'version': '0.1.2',
            'fileUrl': './node_modules/can-validate-validatejs/package.json',
            'main': 'can-validate-validatejs.js',
            'steal': {
                'ignoreBrowser': true,
                'npmIgnore': {
                    'bit-docs': true,
                    'testee': true,
                    'steal-tools': true
                },
                'npmDependencies': { 'steal-qunit': true },
                'paths': { 'validate.js@0.11.1#validate': './node_modules/validate.js/validate.js' }
            },
            'resolutions': {
                'can-validate-validatejs': '0.1.2',
                'steal-qunit': '1.0.1',
                'can-reflect': '1.13.2',
                'validate.js': '0.11.1'
            },
            'system': {
                'ignoreBrowser': true,
                'npmIgnore': {
                    'bit-docs': true,
                    'testee': true,
                    'steal-tools': true
                },
                'npmDependencies': { 'steal-qunit': true },
                'paths': { 'validate.js@0.11.1#validate': './node_modules/validate.js/validate.js' }
            }
        },
        {
            'name': 'can-define-validate-validatejs',
            'version': '1.0.0',
            'fileUrl': './node_modules/can-define-validate-validatejs/package.json',
            'main': 'can-define-validate-validatejs.js',
            'steal': {
                'ignoreBrowser': true,
                'npmIgnore': {
                    'documentjs': true,
                    'testee': true,
                    'steal-tools': true
                },
                'npmDependencies': { 'steal-qunit': true }
            },
            'browser': {},
            'resolutions': {
                'can-define-validate-validatejs': '1.0.0',
                'can-define': '2.0.1',
                'can-compute': '4.0.0',
                'steal-qunit': '1.0.1',
                'can-validate-validatejs': '0.1.2',
                'can-assign': '1.1.1',
                'can-reflect': '1.13.2',
                'can-validate': '1.1.3',
                'can-util': '3.11.2'
            }
        },
        {
            'name': 'can-view-autorender',
            'version': '4.0.0',
            'fileUrl': './node_modules/can-view-autorender/package.json',
            'main': 'can-view-autorender',
            'resolutions': {
                'can-view-autorender': '4.0.0',
                'steal-qunit': '1.0.1'
            }
        },
        {
            'name': 'react-view-model',
            'version': '1.0.0',
            'fileUrl': './node_modules/react-view-model/package.json',
            'main': 'react-view-model',
            'resolutions': {
                'steal-qunit': '1.0.1',
                'react-view-model': '1.0.0',
                'react': '16.2.0',
                'react-dom': '16.2.0',
                'can-util': '3.11.2',
                'can-namespace': '1.0.0',
                'can-define': '2.0.1',
                'can-reflect': '1.13.2',
                'can-stache-key': '1.0.0',
                'prop-types': '15.6.0',
                'can-observation-recorder': '1.0.1',
                'can-observation': '4.0.0',
                'can-queues': '1.0.0'
            }
        },
        {
            'name': 'can-namespace',
            'version': '1.0.0',
            'fileUrl': './node_modules/can-namespace/package.json',
            'main': 'can-namespace',
            'steal': { 'npmAlgorithm': 'flat' },
            'resolutions': {}
        },
        {
            'name': 'can-make-map',
            'version': '1.0.1',
            'fileUrl': './node_modules/can-make-map/package.json',
            'main': 'dist/cjs/can-make-map',
            'steal': {
                'npmIgnore': {
                    'testee': true,
                    'generator-donejs': true,
                    'donejs-cli': true,
                    'steal-tools': true
                },
                'main': 'can-make-map'
            },
            'resolutions': {}
        },
        {
            'name': 'steal-qunit',
            'version': '1.0.1',
            'fileUrl': './node_modules/steal-qunit/package.json',
            'main': 'steal-qunit',
            'steal': {
                'plugins': ['steal-css'],
                'meta': {
                    'qunitjs@1.23.1#qunit/qunit': {
                        'format': 'global',
                        'exports': 'QUnit',
                        'deps': ['steal-qunit/add-dom']
                    }
                }
            },
            'resolutions': {
                'qunitjs': '1.23.1',
                'steal-css': '1.3.2'
            },
            'system': {
                'plugins': ['steal-css'],
                'meta': {
                    'qunitjs@1.23.1#qunit/qunit': {
                        'format': 'global',
                        'exports': 'QUnit',
                        'deps': ['steal-qunit/add-dom']
                    }
                }
            }
        },
        {
            'name': 'can-dom-mutate',
            'version': '1.0.2',
            'fileUrl': './node_modules/can-dom-mutate/package.json',
            'main': 'can-dom-mutate',
            'steal': { 'main': 'can-dom-mutate' },
            'resolutions': {
                'can-globals': '1.0.0',
                'can-dom-mutate': '1.0.2'
            }
        },
        {
            'name': 'can-simple-map',
            'version': '4.0.0',
            'fileUrl': './node_modules/can-simple-map/package.json',
            'main': 'can-simple-map',
            'steal': {
                'npmIgnore': {
                    'documentjs': true,
                    'testee': true,
                    'generator-donejs': true,
                    'donejs-cli': true,
                    'steal-tools': true
                },
                'main': 'can-simple-map'
            },
            'resolutions': {
                'can-construct': '3.3.0',
                'can-event-queue': '1.0.0',
                'can-queues': '1.0.0',
                'can-util': '3.11.2',
                'can-observation-recorder': '1.0.1',
                'can-reflect': '1.13.2',
                'can-log': '1.0.0',
                'can-symbol': '1.6.0'
            }
        },
        {
            'name': 'can-observation-recorder',
            'version': '1.0.1',
            'fileUrl': './node_modules/can-observation-recorder/package.json',
            'main': './can-observation-recorder.js',
            'steal': {
                'npmIgnore': {
                    'testee': true,
                    'generator-donejs': true,
                    'donejs-cli': true,
                    'steal-tools': true
                }
            },
            'resolutions': { 'can-namespace': '1.0.0' }
        },
        {
            'name': 'can-test-helpers',
            'version': '1.1.1',
            'fileUrl': './node_modules/can-test-helpers/package.json',
            'main': 'can-test-helpers.js',
            'resolutions': {
                'can-test-helpers': '1.1.1',
                'can-log': '1.0.0',
                'can-util': '3.11.2'
            }
        },
        {
            'name': 'can-observation',
            'version': '4.0.0',
            'fileUrl': './node_modules/can-observation/package.json',
            'main': 'can-observation',
            'steal': { 'npmAlgorithm': 'flat' },
            'resolutions': {
                'can-namespace': '1.0.0',
                'can-reflect': '1.13.2',
                'can-queues': '1.0.0',
                'can-observation-recorder': '1.0.1',
                'can-symbol': '1.6.0',
                'can-log': '1.0.0',
                'can-event-queue': '1.0.0',
                'can-observation': '4.0.0'
            }
        },
        {
            'name': 'can-connect',
            'version': '2.0.1',
            'fileUrl': './node_modules/can-connect/package.json',
            'main': 'can-connect.js',
            'steal': {
                'plugins': [
                    'steal-stache',
                    'steal-css'
                ]
            },
            'resolutions': {
                'can-connect': '2.0.1',
                'can-namespace': '1.0.0',
                'can-util': '3.11.2',
                'can-set': '1.5.1'
            }
        },
        {
            'name': 'can-stache-helpers',
            'version': '1.0.0',
            'fileUrl': './node_modules/can-stache-helpers/package.json',
            'main': 'can-stache-helpers',
            'steal': {
                'npmIgnore': {
                    'testee': true,
                    'generator-donejs': true,
                    'donejs-cli': true,
                    'steal-tools': true
                }
            },
            'resolutions': { 'can-namespace': '1.0.0' }
        },
        {
            'name': 'can-log',
            'version': '1.0.0',
            'fileUrl': './node_modules/can-log/package.json',
            'main': 'dist/cjs/can-log',
            'steal': {
                'npmIgnore': {
                    'testee': true,
                    'generator-donejs': true,
                    'donejs-cli': true,
                    'steal-tools': true
                },
                'main': 'can-log'
            },
            'resolutions': { 'can-log': '1.0.0' }
        },
        {
            'name': 'can-attribute-encoder',
            'version': '1.0.0',
            'fileUrl': './node_modules/can-attribute-encoder/package.json',
            'main': 'can-attribute-encoder',
            'steal': {
                'npmIgnore': {
                    'testee': true,
                    'steal-tools': true
                },
                'main': 'can-attribute-encoder'
            },
            'resolutions': {
                'can-namespace': '1.0.0',
                'can-log': '1.0.0'
            }
        },
        {
            'name': 'can-reflect-tests',
            'version': '0.2.0',
            'fileUrl': './node_modules/can-reflect-tests/package.json',
            'main': 'can-reflect-tests',
            'steal': {
                'npmIgnore': {
                    'testee': true,
                    'generator-donejs': true,
                    'donejs-cli': true,
                    'steal-tools': true
                },
                'plugins': [
                    'steal-less',
                    'steal-stache'
                ],
                'main': 'can-reflect-tests'
            },
            'resolutions': {
                'can-reflect-tests': '0.2.0',
                'steal-qunit': '1.0.1',
                'can-symbol': '1.6.0',
                'can-reflect': '1.13.2'
            }
        },
        {
            'name': 'jquery',
            'version': '3.3.1',
            'fileUrl': './node_modules/jquery/package.json',
            'main': 'dist/jquery.js',
            'resolutions': {}
        },
        {
            'name': 'funcunit',
            'version': '3.5.0',
            'fileUrl': './node_modules/funcunit/package.json',
            'main': 'dist/cjs/funcunit.js',
            'steal': {
                'map': { 'chai': 'chai/chai' },
                'npmIgnore': {
                    'documentjs': true,
                    'steal': true,
                    'steal-tools': true,
                    'testee': true
                },
                'main': 'funcunit'
            },
            'resolutions': {
                'funcunit': '3.5.0',
                'syn': '0.13.0',
                'jquery': '1.11.0'
            }
        },
        {
            'name': 'can-stache',
            'version': '4.0.2',
            'fileUrl': './node_modules/can-stache/package.json',
            'main': 'can-stache',
            'resolutions': {
                'can-view-parser': '4.0.1',
                'can-view-callbacks': '4.0.0',
                'can-stache': '4.0.2',
                'can-attribute-encoder': '1.0.0',
                'can-log': '1.0.0',
                'can-namespace': '1.0.0',
                'can-globals': '1.0.0',
                'can-assign': '1.1.1',
                'can-util': '3.11.2',
                'can-reflect': '1.13.2',
                'can-view-target': '4.0.0',
                'can-view-nodelist': '4.0.1',
                'can-symbol': '1.6.0',
                'can-view-scope': '4.0.1',
                'can-observation': '4.0.0',
                'can-observation-recorder': '1.0.1',
                'can-view-live': '4.0.1',
                'can-dom-mutate': '1.0.2',
                'can-stache-helpers': '1.0.0',
                'can-dom-data-state': '1.0.1',
                'can-stache-key': '1.0.0',
                'can-simple-observable': '2.0.1'
            }
        },
        {
            'name': 'can-dom-data-state',
            'version': '1.0.1',
            'fileUrl': './node_modules/can-dom-data-state/package.json',
            'main': 'can-dom-data-state.js',
            'steal': {
                'npmIgnore': {
                    'testee': true,
                    'generator-donejs': true,
                    'donejs-cli': true,
                    'steal-tools': true
                },
                'main': 'can-dom-data-state'
            },
            'resolutions': {
                'can-namespace': '1.0.0',
                'can-dom-mutate': '1.0.2',
                'can-cid': '1.1.2'
            }
        },
        {
            'name': 'can-observe',
            'version': '2.0.1',
            'fileUrl': './node_modules/can-observe/package.json',
            'main': 'can-observe.js',
            'resolutions': {
                'can-observe': '2.0.1',
                'can-reflect': '1.13.2',
                'can-observation-recorder': '1.0.1',
                'can-event-queue': '1.0.0',
                'can-symbol': '1.6.0',
                'can-queues': '1.0.0',
                'can-observation': '4.0.0'
            }
        },
        {
            'name': 'can-view-callbacks',
            'version': '4.0.0',
            'fileUrl': './node_modules/can-view-callbacks/package.json',
            'main': 'can-view-callbacks',
            'resolutions': {
                'can-observation-recorder': '1.0.1',
                'can-log': '1.0.0',
                'can-globals': '1.0.0',
                'can-dom-mutate': '1.0.2',
                'can-namespace': '1.0.0',
                'can-view-nodelist': '4.0.1',
                'can-util': '3.11.2'
            }
        },
        {
            'name': 'steal-css',
            'version': '1.3.2',
            'fileUrl': './node_modules/steal-css/package.json',
            'main': 'css.js',
            'steal': {
                'ext': { 'css': 'steal-css' },
                'map': { '$css': 'steal-css@1.3.2#css' }
            },
            'resolutions': {}
        },
        {
            'name': 'qunitjs',
            'version': '2.4.1',
            'fileUrl': './node_modules/qunitjs/package.json',
            'main': 'qunit/qunit.js',
            'resolutions': {}
        },
        {
            'name': 'steal-stache',
            'version': '4.0.0',
            'fileUrl': './node_modules/steal-stache/package.json',
            'main': 'steal-stache.js',
            'steal': {
                'npmIgnore': {
                    'documentjs': true,
                    'testee': true,
                    'steal-tools': true
                },
                'npmAlgorithm': 'flat',
                'ext': { 'stache': 'steal-stache' },
                'main': 'steal-stache'
            },
            'resolutions': {}
        },
        {
            'name': 'can-vdom',
            'version': '4.0.0',
            'fileUrl': './node_modules/can-vdom/package.json',
            'main': 'can-vdom.js',
            'steal': {
                'map': { 'can-vdom@4.0.0#assert': 'chai/chai' },
                'meta': {
                    'chai/chai': {
                        'format': 'global',
                        'exports': 'chai.assert'
                    }
                },
                'plugins': ['chai'],
                'main': 'can-vdom'
            },
            'resolutions': {
                'can-simple-dom': '1.3.4',
                'can-vdom': '4.0.0',
                'can-view-parser': '4.0.1'
            }
        },
        {
            'name': 'can-cid',
            'version': '1.1.2',
            'fileUrl': './node_modules/can-cid/package.json',
            'main': 'can-cid',
            'resolutions': {
                'can-namespace': '1.0.0',
                'can-cid': '1.1.2'
            }
        },
        {
            'name': 'can-types',
            'version': '1.1.6',
            'fileUrl': './node_modules/can-types/package.json',
            'main': 'can-types',
            'resolutions': {
                'can-namespace': '1.0.0',
                'can-reflect': '1.13.2',
                'can-symbol': '1.6.0',
                'can-log': '1.0.0'
            }
        },
        {
            'name': 'syn',
            'version': '0.13.0',
            'fileUrl': './node_modules/syn/package.json',
            'main': 'dist/cjs/syn.js',
            'steal': {
                'directories': { 'lib': 'src' },
                'map': {},
                'ignoreBrowser': true,
                'main': 'syn'
            },
            'resolutions': { 'syn': '0.13.0' }
        },
        {
            'name': 'qunitjs',
            'version': '1.23.1',
            'fileUrl': './node_modules/steal-qunit/node_modules/qunitjs/package.json',
            'main': 'qunit/qunit.js',
            'resolutions': { 'steal-qunit': '1.0.1' }
        },
        {
            'name': 'he',
            'version': '1.1.1',
            'fileUrl': './node_modules/he/package.json',
            'main': 'he.js',
            'resolutions': {}
        },
        {
            'name': 'simple-html-tokenizer',
            'version': '0.2.6',
            'fileUrl': './node_modules/simple-html-tokenizer/package.json',
            'main': 'dist/simple-html-tokenizer.js',
            'resolutions': { 'simple-html-tokenizer': '0.2.6' }
        },
        {
            'name': 'kefir',
            'version': '3.8.1',
            'fileUrl': './node_modules/kefir/package.json',
            'main': 'dist/kefir.js',
            'resolutions': {}
        },
        {
            'name': 'validate.js',
            'version': '0.11.1',
            'fileUrl': './node_modules/validate.js/package.json',
            'main': 'validate.js',
            'resolutions': {}
        },
        {
            'name': 'micro-location',
            'version': '0.1.5',
            'fileUrl': './node_modules/micro-location/package.json',
            'main': 'lib/micro-location.js',
            'resolutions': {}
        },
        {
            'name': 'jquery',
            'version': '1.11.0',
            'fileUrl': './node_modules/funcunit/node_modules/jquery/package.json',
            'main': 'dist/jquery.js',
            'resolutions': {}
        },
        {
            'name': 'react',
            'version': '16.2.0',
            'fileUrl': './node_modules/react/package.json',
            'main': 'index.js',
            'browser': { 'transform': ['loose-envify'] },
            'resolutions': {
                'react': '16.2.0',
                'prop-types': '15.6.0',
                'fbjs': '0.8.16',
                'object-assign': '4.1.1'
            }
        },
        {
            'name': 'react-dom',
            'version': '16.2.0',
            'fileUrl': './node_modules/react-dom/package.json',
            'main': 'index.js',
            'browser': { 'react-dom#server': 'react-dom#server.browser' },
            'resolutions': {
                'react-dom': '16.2.0',
                'react': '16.2.0',
                'object-assign': '4.1.1',
                'fbjs': '0.8.16',
                'prop-types': '15.6.0'
            }
        },
        {
            'name': 'prop-types',
            'version': '15.6.0',
            'fileUrl': './node_modules/prop-types/package.json',
            'main': 'index.js',
            'browser': { 'transform': ['loose-envify'] },
            'resolutions': {
                'prop-types': '15.6.0',
                'fbjs': '0.8.16',
                'object-assign': '4.1.1'
            }
        },
        {
            'name': 'fbjs',
            'version': '0.8.16',
            'fileUrl': './node_modules/fbjs/package.json',
            'main': 'index.js',
            'browser': { 'transform': ['loose-envify'] },
            'resolutions': { 'fbjs': '0.8.16' }
        },
        {
            'name': 'object-assign',
            'version': '4.1.1',
            'fileUrl': './node_modules/react/node_modules/object-assign/package.json',
            'resolutions': {}
        }
    ], { 'npmParentMap': {} }));
});
/*can@4.0.0-pre.14#test/browser-supports-react*/
define('can@4.0.0-pre.14#test/browser-supports-react', function (require, exports, module) {
    module.exports = typeof Map !== 'undefined' && typeof Set !== 'undefined' && typeof window.requestAnimationFrame !== 'undefined';
});
/*steal-qunit@1.0.1#add-dom*/
define('steal-qunit@1.0.1#add-dom', function (require, exports, module) {
    'format cjs';
    if (!document.getElementById('qunit')) {
        var qunit = document.createElement('div');
        qunit.id = 'qunit';
        (document.body || document.documentElement).appendChild(qunit);
    }
});
/*qunitjs@1.23.1#qunit/qunit*/
define('qunitjs@1.23.1#qunit/qunit', [
    'module',
    '@loader',
    'require',
    'steal-qunit/add-dom'
], function (module, loader, require) {
    loader.get('@@global-helpers').prepareGlobal({
        require: require,
        name: module.id,
        deps: ['steal-qunit/add-dom'],
        exports: 'QUnit'
    });
    var define = loader.global.define;
    var require = loader.global.require;
    var source = '/*!\n * QUnit 1.23.1\n * https://qunitjs.com/\n *\n * Copyright jQuery Foundation and other contributors\n * Released under the MIT license\n * https://jquery.org/license\n *\n * Date: 2016-04-12T17:29Z\n */\n\n( function( global ) {\n\nvar QUnit = {};\n\nvar Date = global.Date;\nvar now = Date.now || function() {\n\treturn new Date().getTime();\n};\n\nvar setTimeout = global.setTimeout;\nvar clearTimeout = global.clearTimeout;\n\n// Store a local window from the global to allow direct references.\nvar window = global.window;\n\nvar defined = {\n\tdocument: window && window.document !== undefined,\n\tsetTimeout: setTimeout !== undefined,\n\tsessionStorage: ( function() {\n\t\tvar x = "qunit-test-string";\n\t\ttry {\n\t\t\tsessionStorage.setItem( x, x );\n\t\t\tsessionStorage.removeItem( x );\n\t\t\treturn true;\n\t\t} catch ( e ) {\n\t\t\treturn false;\n\t\t}\n\t}() )\n};\n\nvar fileName = ( sourceFromStacktrace( 0 ) || "" ).replace( /(:\\d+)+\\)?/, "" ).replace( /.+\\//, "" );\nvar globalStartCalled = false;\nvar runStarted = false;\n\nvar toString = Object.prototype.toString,\n\thasOwn = Object.prototype.hasOwnProperty;\n\n// Returns a new Array with the elements that are in a but not in b\nfunction diff( a, b ) {\n\tvar i, j,\n\t\tresult = a.slice();\n\n\tfor ( i = 0; i < result.length; i++ ) {\n\t\tfor ( j = 0; j < b.length; j++ ) {\n\t\t\tif ( result[ i ] === b[ j ] ) {\n\t\t\t\tresult.splice( i, 1 );\n\t\t\t\ti--;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}\n\n// From jquery.js\nfunction inArray( elem, array ) {\n\tif ( array.indexOf ) {\n\t\treturn array.indexOf( elem );\n\t}\n\n\tfor ( var i = 0, length = array.length; i < length; i++ ) {\n\t\tif ( array[ i ] === elem ) {\n\t\t\treturn i;\n\t\t}\n\t}\n\n\treturn -1;\n}\n\n/**\n * Makes a clone of an object using only Array or Object as base,\n * and copies over the own enumerable properties.\n *\n * @param {Object} obj\n * @return {Object} New object with only the own properties (recursively).\n */\nfunction objectValues ( obj ) {\n\tvar key, val,\n\t\tvals = QUnit.is( "array", obj ) ? [] : {};\n\tfor ( key in obj ) {\n\t\tif ( hasOwn.call( obj, key ) ) {\n\t\t\tval = obj[ key ];\n\t\t\tvals[ key ] = val === Object( val ) ? objectValues( val ) : val;\n\t\t}\n\t}\n\treturn vals;\n}\n\nfunction extend( a, b, undefOnly ) {\n\tfor ( var prop in b ) {\n\t\tif ( hasOwn.call( b, prop ) ) {\n\n\t\t\t// Avoid "Member not found" error in IE8 caused by messing with window.constructor\n\t\t\t// This block runs on every environment, so `global` is being used instead of `window`\n\t\t\t// to avoid errors on node.\n\t\t\tif ( prop !== "constructor" || a !== global ) {\n\t\t\t\tif ( b[ prop ] === undefined ) {\n\t\t\t\t\tdelete a[ prop ];\n\t\t\t\t} else if ( !( undefOnly && typeof a[ prop ] !== "undefined" ) ) {\n\t\t\t\t\ta[ prop ] = b[ prop ];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn a;\n}\n\nfunction objectType( obj ) {\n\tif ( typeof obj === "undefined" ) {\n\t\treturn "undefined";\n\t}\n\n\t// Consider: typeof null === object\n\tif ( obj === null ) {\n\t\treturn "null";\n\t}\n\n\tvar match = toString.call( obj ).match( /^\\[object\\s(.*)\\]$/ ),\n\t\ttype = match && match[ 1 ];\n\n\tswitch ( type ) {\n\t\tcase "Number":\n\t\t\tif ( isNaN( obj ) ) {\n\t\t\t\treturn "nan";\n\t\t\t}\n\t\t\treturn "number";\n\t\tcase "String":\n\t\tcase "Boolean":\n\t\tcase "Array":\n\t\tcase "Set":\n\t\tcase "Map":\n\t\tcase "Date":\n\t\tcase "RegExp":\n\t\tcase "Function":\n\t\tcase "Symbol":\n\t\t\treturn type.toLowerCase();\n\t}\n\tif ( typeof obj === "object" ) {\n\t\treturn "object";\n\t}\n}\n\n// Safe object type checking\nfunction is( type, obj ) {\n\treturn QUnit.objectType( obj ) === type;\n}\n\n// Doesn\'t support IE6 to IE9, it will return undefined on these browsers\n// See also https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error/Stack\nfunction extractStacktrace( e, offset ) {\n\toffset = offset === undefined ? 4 : offset;\n\n\tvar stack, include, i;\n\n\tif ( e.stack ) {\n\t\tstack = e.stack.split( "\\n" );\n\t\tif ( /^error$/i.test( stack[ 0 ] ) ) {\n\t\t\tstack.shift();\n\t\t}\n\t\tif ( fileName ) {\n\t\t\tinclude = [];\n\t\t\tfor ( i = offset; i < stack.length; i++ ) {\n\t\t\t\tif ( stack[ i ].indexOf( fileName ) !== -1 ) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tinclude.push( stack[ i ] );\n\t\t\t}\n\t\t\tif ( include.length ) {\n\t\t\t\treturn include.join( "\\n" );\n\t\t\t}\n\t\t}\n\t\treturn stack[ offset ];\n\n\t// Support: Safari <=6 only\n\t} else if ( e.sourceURL ) {\n\n\t\t// Exclude useless self-reference for generated Error objects\n\t\tif ( /qunit.js$/.test( e.sourceURL ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// For actual exceptions, this is useful\n\t\treturn e.sourceURL + ":" + e.line;\n\t}\n}\n\nfunction sourceFromStacktrace( offset ) {\n\tvar error = new Error();\n\n\t// Support: Safari <=7 only, IE <=10 - 11 only\n\t// Not all browsers generate the `stack` property for `new Error()`, see also #636\n\tif ( !error.stack ) {\n\t\ttry {\n\t\t\tthrow error;\n\t\t} catch ( err ) {\n\t\t\terror = err;\n\t\t}\n\t}\n\n\treturn extractStacktrace( error, offset );\n}\n\n/**\n * Config object: Maintain internal state\n * Later exposed as QUnit.config\n * `config` initialized at top of scope\n */\nvar config = {\n\n\t// The queue of tests to run\n\tqueue: [],\n\n\t// Block until document ready\n\tblocking: true,\n\n\t// By default, run previously failed tests first\n\t// very useful in combination with "Hide passed tests" checked\n\treorder: true,\n\n\t// By default, modify document.title when suite is done\n\taltertitle: true,\n\n\t// HTML Reporter: collapse every test except the first failing test\n\t// If false, all failing tests will be expanded\n\tcollapse: true,\n\n\t// By default, scroll to top of the page when suite is done\n\tscrolltop: true,\n\n\t// Depth up-to which object will be dumped\n\tmaxDepth: 5,\n\n\t// When enabled, all tests must call expect()\n\trequireExpects: false,\n\n\t// Placeholder for user-configurable form-exposed URL parameters\n\turlConfig: [],\n\n\t// Set of all modules.\n\tmodules: [],\n\n\t// Stack of nested modules\n\tmoduleStack: [],\n\n\t// The first unnamed module\n\tcurrentModule: {\n\t\tname: "",\n\t\ttests: []\n\t},\n\n\tcallbacks: {}\n};\n\n// Push a loose unnamed module to the modules collection\nconfig.modules.push( config.currentModule );\n\nvar loggingCallbacks = {};\n\n// Register logging callbacks\nfunction registerLoggingCallbacks( obj ) {\n\tvar i, l, key,\n\t\tcallbackNames = [ "begin", "done", "log", "testStart", "testDone",\n\t\t\t"moduleStart", "moduleDone" ];\n\n\tfunction registerLoggingCallback( key ) {\n\t\tvar loggingCallback = function( callback ) {\n\t\t\tif ( objectType( callback ) !== "function" ) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t"QUnit logging methods require a callback function as their first parameters."\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tconfig.callbacks[ key ].push( callback );\n\t\t};\n\n\t\t// DEPRECATED: This will be removed on QUnit 2.0.0+\n\t\t// Stores the registered functions allowing restoring\n\t\t// at verifyLoggingCallbacks() if modified\n\t\tloggingCallbacks[ key ] = loggingCallback;\n\n\t\treturn loggingCallback;\n\t}\n\n\tfor ( i = 0, l = callbackNames.length; i < l; i++ ) {\n\t\tkey = callbackNames[ i ];\n\n\t\t// Initialize key collection of logging callback\n\t\tif ( objectType( config.callbacks[ key ] ) === "undefined" ) {\n\t\t\tconfig.callbacks[ key ] = [];\n\t\t}\n\n\t\tobj[ key ] = registerLoggingCallback( key );\n\t}\n}\n\nfunction runLoggingCallbacks( key, args ) {\n\tvar i, l, callbacks;\n\n\tcallbacks = config.callbacks[ key ];\n\tfor ( i = 0, l = callbacks.length; i < l; i++ ) {\n\t\tcallbacks[ i ]( args );\n\t}\n}\n\n// DEPRECATED: This will be removed on 2.0.0+\n// This function verifies if the loggingCallbacks were modified by the user\n// If so, it will restore it, assign the given callback and print a console warning\nfunction verifyLoggingCallbacks() {\n\tvar loggingCallback, userCallback;\n\n\tfor ( loggingCallback in loggingCallbacks ) {\n\t\tif ( QUnit[ loggingCallback ] !== loggingCallbacks[ loggingCallback ] ) {\n\n\t\t\tuserCallback = QUnit[ loggingCallback ];\n\n\t\t\t// Restore the callback function\n\t\t\tQUnit[ loggingCallback ] = loggingCallbacks[ loggingCallback ];\n\n\t\t\t// Assign the deprecated given callback\n\t\t\tQUnit[ loggingCallback ]( userCallback );\n\n\t\t\tif ( global.console && global.console.warn ) {\n\t\t\t\tglobal.console.warn(\n\t\t\t\t\t"QUnit." + loggingCallback + " was replaced with a new value.\\n" +\n\t\t\t\t\t"Please, check out the documentation on how to apply logging callbacks.\\n" +\n\t\t\t\t\t"Reference: https://api.qunitjs.com/category/callbacks/"\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n}\n\n( function() {\n\tif ( !defined.document ) {\n\t\treturn;\n\t}\n\n\t// `onErrorFnPrev` initialized at top of scope\n\t// Preserve other handlers\n\tvar onErrorFnPrev = window.onerror;\n\n\t// Cover uncaught exceptions\n\t// Returning true will suppress the default browser handler,\n\t// returning false will let it run.\n\twindow.onerror = function( error, filePath, linerNr ) {\n\t\tvar ret = false;\n\t\tif ( onErrorFnPrev ) {\n\t\t\tret = onErrorFnPrev( error, filePath, linerNr );\n\t\t}\n\n\t\t// Treat return value as window.onerror itself does,\n\t\t// Only do our handling if not suppressed.\n\t\tif ( ret !== true ) {\n\t\t\tif ( QUnit.config.current ) {\n\t\t\t\tif ( QUnit.config.current.ignoreGlobalErrors ) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tQUnit.pushFailure( error, filePath + ":" + linerNr );\n\t\t\t} else {\n\t\t\t\tQUnit.test( "global failure", extend( function() {\n\t\t\t\t\tQUnit.pushFailure( error, filePath + ":" + linerNr );\n\t\t\t\t}, { validTest: true } ) );\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\treturn ret;\n\t};\n}() );\n\n// Figure out if we\'re running the tests from a server or not\nQUnit.isLocal = !( defined.document && window.location.protocol !== "file:" );\n\n// Expose the current QUnit version\nQUnit.version = "1.23.1";\n\nextend( QUnit, {\n\n\t// Call on start of module test to prepend name to all tests\n\tmodule: function( name, testEnvironment, executeNow ) {\n\t\tvar module, moduleFns;\n\t\tvar currentModule = config.currentModule;\n\n\t\tif ( arguments.length === 2 ) {\n\t\t\tif ( objectType( testEnvironment ) === "function" ) {\n\t\t\t\texecuteNow = testEnvironment;\n\t\t\t\ttestEnvironment = undefined;\n\t\t\t}\n\t\t}\n\n\t\t// DEPRECATED: handles setup/teardown functions,\n\t\t// beforeEach and afterEach should be used instead\n\t\tif ( testEnvironment && testEnvironment.setup ) {\n\t\t\ttestEnvironment.beforeEach = testEnvironment.setup;\n\t\t\tdelete testEnvironment.setup;\n\t\t}\n\t\tif ( testEnvironment && testEnvironment.teardown ) {\n\t\t\ttestEnvironment.afterEach = testEnvironment.teardown;\n\t\t\tdelete testEnvironment.teardown;\n\t\t}\n\n\t\tmodule = createModule();\n\n\t\tmoduleFns = {\n\t\t\tbeforeEach: setHook( module, "beforeEach" ),\n\t\t\tafterEach: setHook( module, "afterEach" )\n\t\t};\n\n\t\tif ( objectType( executeNow ) === "function" ) {\n\t\t\tconfig.moduleStack.push( module );\n\t\t\tsetCurrentModule( module );\n\t\t\texecuteNow.call( module.testEnvironment, moduleFns );\n\t\t\tconfig.moduleStack.pop();\n\t\t\tmodule = module.parentModule || currentModule;\n\t\t}\n\n\t\tsetCurrentModule( module );\n\n\t\tfunction createModule() {\n\t\t\tvar parentModule = config.moduleStack.length ?\n\t\t\t\tconfig.moduleStack.slice( -1 )[ 0 ] : null;\n\t\t\tvar moduleName = parentModule !== null ?\n\t\t\t\t[ parentModule.name, name ].join( " > " ) : name;\n\t\t\tvar module = {\n\t\t\t\tname: moduleName,\n\t\t\t\tparentModule: parentModule,\n\t\t\t\ttests: [],\n\t\t\t\tmoduleId: generateHash( moduleName )\n\t\t\t};\n\n\t\t\tvar env = {};\n\t\t\tif ( parentModule ) {\n\t\t\t\textend( env, parentModule.testEnvironment );\n\t\t\t\tdelete env.beforeEach;\n\t\t\t\tdelete env.afterEach;\n\t\t\t}\n\t\t\textend( env, testEnvironment );\n\t\t\tmodule.testEnvironment = env;\n\n\t\t\tconfig.modules.push( module );\n\t\t\treturn module;\n\t\t}\n\n\t\tfunction setCurrentModule( module ) {\n\t\t\tconfig.currentModule = module;\n\t\t}\n\n\t},\n\n\t// DEPRECATED: QUnit.asyncTest() will be removed in QUnit 2.0.\n\tasyncTest: asyncTest,\n\n\ttest: test,\n\n\tskip: skip,\n\n\tonly: only,\n\n\t// DEPRECATED: The functionality of QUnit.start() will be altered in QUnit 2.0.\n\t// In QUnit 2.0, invoking it will ONLY affect the `QUnit.config.autostart` blocking behavior.\n\tstart: function( count ) {\n\t\tvar globalStartAlreadyCalled = globalStartCalled;\n\n\t\tif ( !config.current ) {\n\t\t\tglobalStartCalled = true;\n\n\t\t\tif ( runStarted ) {\n\t\t\t\tthrow new Error( "Called start() outside of a test context while already started" );\n\t\t\t} else if ( globalStartAlreadyCalled || count > 1 ) {\n\t\t\t\tthrow new Error( "Called start() outside of a test context too many times" );\n\t\t\t} else if ( config.autostart ) {\n\t\t\t\tthrow new Error( "Called start() outside of a test context when " +\n\t\t\t\t\t"QUnit.config.autostart was true" );\n\t\t\t} else if ( !config.pageLoaded ) {\n\n\t\t\t\t// The page isn\'t completely loaded yet, so bail out and let `QUnit.load` handle it\n\t\t\t\tconfig.autostart = true;\n\t\t\t\treturn;\n\t\t\t}\n\t\t} else {\n\n\t\t\t// If a test is running, adjust its semaphore\n\t\t\tconfig.current.semaphore -= count || 1;\n\n\t\t\t// If semaphore is non-numeric, throw error\n\t\t\tif ( isNaN( config.current.semaphore ) ) {\n\t\t\t\tconfig.current.semaphore = 0;\n\n\t\t\t\tQUnit.pushFailure(\n\t\t\t\t\t"Called start() with a non-numeric decrement.",\n\t\t\t\t\tsourceFromStacktrace( 2 )\n\t\t\t\t);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Don\'t start until equal number of stop-calls\n\t\t\tif ( config.current.semaphore > 0 ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Throw an Error if start is called more often than stop\n\t\t\tif ( config.current.semaphore < 0 ) {\n\t\t\t\tconfig.current.semaphore = 0;\n\n\t\t\t\tQUnit.pushFailure(\n\t\t\t\t\t"Called start() while already started (test\'s semaphore was 0 already)",\n\t\t\t\t\tsourceFromStacktrace( 2 )\n\t\t\t\t);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tresumeProcessing();\n\t},\n\n\t// DEPRECATED: QUnit.stop() will be removed in QUnit 2.0.\n\tstop: function( count ) {\n\n\t\t// If there isn\'t a test running, don\'t allow QUnit.stop() to be called\n\t\tif ( !config.current ) {\n\t\t\tthrow new Error( "Called stop() outside of a test context" );\n\t\t}\n\n\t\t// If a test is running, adjust its semaphore\n\t\tconfig.current.semaphore += count || 1;\n\n\t\tpauseProcessing();\n\t},\n\n\tconfig: config,\n\n\tis: is,\n\n\tobjectType: objectType,\n\n\textend: extend,\n\n\tload: function() {\n\t\tconfig.pageLoaded = true;\n\n\t\t// Initialize the configuration options\n\t\textend( config, {\n\t\t\tstats: { all: 0, bad: 0 },\n\t\t\tmoduleStats: { all: 0, bad: 0 },\n\t\t\tstarted: 0,\n\t\t\tupdateRate: 1000,\n\t\t\tautostart: true,\n\t\t\tfilter: ""\n\t\t}, true );\n\n\t\tconfig.blocking = false;\n\n\t\tif ( config.autostart ) {\n\t\t\tresumeProcessing();\n\t\t}\n\t},\n\n\tstack: function( offset ) {\n\t\toffset = ( offset || 0 ) + 2;\n\t\treturn sourceFromStacktrace( offset );\n\t}\n} );\n\nregisterLoggingCallbacks( QUnit );\n\nfunction begin() {\n\tvar i, l,\n\t\tmodulesLog = [];\n\n\t// If the test run hasn\'t officially begun yet\n\tif ( !config.started ) {\n\n\t\t// Record the time of the test run\'s beginning\n\t\tconfig.started = now();\n\n\t\tverifyLoggingCallbacks();\n\n\t\t// Delete the loose unnamed module if unused.\n\t\tif ( config.modules[ 0 ].name === "" && config.modules[ 0 ].tests.length === 0 ) {\n\t\t\tconfig.modules.shift();\n\t\t}\n\n\t\t// Avoid unnecessary information by not logging modules\' test environments\n\t\tfor ( i = 0, l = config.modules.length; i < l; i++ ) {\n\t\t\tmodulesLog.push( {\n\t\t\t\tname: config.modules[ i ].name,\n\t\t\t\ttests: config.modules[ i ].tests\n\t\t\t} );\n\t\t}\n\n\t\t// The test run is officially beginning now\n\t\trunLoggingCallbacks( "begin", {\n\t\t\ttotalTests: Test.count,\n\t\t\tmodules: modulesLog\n\t\t} );\n\t}\n\n\tconfig.blocking = false;\n\tprocess( true );\n}\n\nfunction process( last ) {\n\tfunction next() {\n\t\tprocess( last );\n\t}\n\tvar start = now();\n\tconfig.depth = ( config.depth || 0 ) + 1;\n\n\twhile ( config.queue.length && !config.blocking ) {\n\t\tif ( !defined.setTimeout || config.updateRate <= 0 ||\n\t\t\t\t( ( now() - start ) < config.updateRate ) ) {\n\t\t\tif ( config.current ) {\n\n\t\t\t\t// Reset async tracking for each phase of the Test lifecycle\n\t\t\t\tconfig.current.usedAsync = false;\n\t\t\t}\n\t\t\tconfig.queue.shift()();\n\t\t} else {\n\t\t\tsetTimeout( next, 13 );\n\t\t\tbreak;\n\t\t}\n\t}\n\tconfig.depth--;\n\tif ( last && !config.blocking && !config.queue.length && config.depth === 0 ) {\n\t\tdone();\n\t}\n}\n\nfunction pauseProcessing() {\n\tconfig.blocking = true;\n\n\tif ( config.testTimeout && defined.setTimeout ) {\n\t\tclearTimeout( config.timeout );\n\t\tconfig.timeout = setTimeout( function() {\n\t\t\tif ( config.current ) {\n\t\t\t\tconfig.current.semaphore = 0;\n\t\t\t\tQUnit.pushFailure( "Test timed out", sourceFromStacktrace( 2 ) );\n\t\t\t} else {\n\t\t\t\tthrow new Error( "Test timed out" );\n\t\t\t}\n\t\t\tresumeProcessing();\n\t\t}, config.testTimeout );\n\t}\n}\n\nfunction resumeProcessing() {\n\trunStarted = true;\n\n\t// A slight delay to allow this iteration of the event loop to finish (more assertions, etc.)\n\tif ( defined.setTimeout ) {\n\t\tsetTimeout( function() {\n\t\t\tif ( config.current && config.current.semaphore > 0 ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif ( config.timeout ) {\n\t\t\t\tclearTimeout( config.timeout );\n\t\t\t}\n\n\t\t\tbegin();\n\t\t}, 13 );\n\t} else {\n\t\tbegin();\n\t}\n}\n\nfunction done() {\n\tvar runtime, passed;\n\n\tconfig.autorun = true;\n\n\t// Log the last module results\n\tif ( config.previousModule ) {\n\t\trunLoggingCallbacks( "moduleDone", {\n\t\t\tname: config.previousModule.name,\n\t\t\ttests: config.previousModule.tests,\n\t\t\tfailed: config.moduleStats.bad,\n\t\t\tpassed: config.moduleStats.all - config.moduleStats.bad,\n\t\t\ttotal: config.moduleStats.all,\n\t\t\truntime: now() - config.moduleStats.started\n\t\t} );\n\t}\n\tdelete config.previousModule;\n\n\truntime = now() - config.started;\n\tpassed = config.stats.all - config.stats.bad;\n\n\trunLoggingCallbacks( "done", {\n\t\tfailed: config.stats.bad,\n\t\tpassed: passed,\n\t\ttotal: config.stats.all,\n\t\truntime: runtime\n\t} );\n}\n\nfunction setHook( module, hookName ) {\n\tif ( module.testEnvironment === undefined ) {\n\t\tmodule.testEnvironment = {};\n\t}\n\n\treturn function( callback ) {\n\t\tmodule.testEnvironment[ hookName ] = callback;\n\t};\n}\n\nvar focused = false;\nvar priorityCount = 0;\nvar unitSampler;\n\nfunction Test( settings ) {\n\tvar i, l;\n\n\t++Test.count;\n\n\textend( this, settings );\n\tthis.assertions = [];\n\tthis.semaphore = 0;\n\tthis.usedAsync = false;\n\tthis.module = config.currentModule;\n\tthis.stack = sourceFromStacktrace( 3 );\n\n\t// Register unique strings\n\tfor ( i = 0, l = this.module.tests; i < l.length; i++ ) {\n\t\tif ( this.module.tests[ i ].name === this.testName ) {\n\t\t\tthis.testName += " ";\n\t\t}\n\t}\n\n\tthis.testId = generateHash( this.module.name, this.testName );\n\n\tthis.module.tests.push( {\n\t\tname: this.testName,\n\t\ttestId: this.testId\n\t} );\n\n\tif ( settings.skip ) {\n\n\t\t// Skipped tests will fully ignore any sent callback\n\t\tthis.callback = function() {};\n\t\tthis.async = false;\n\t\tthis.expected = 0;\n\t} else {\n\t\tthis.assert = new Assert( this );\n\t}\n}\n\nTest.count = 0;\n\nTest.prototype = {\n\tbefore: function() {\n\t\tif (\n\n\t\t\t// Emit moduleStart when we\'re switching from one module to another\n\t\t\tthis.module !== config.previousModule ||\n\n\t\t\t\t// They could be equal (both undefined) but if the previousModule property doesn\'t\n\t\t\t\t// yet exist it means this is the first test in a suite that isn\'t wrapped in a\n\t\t\t\t// module, in which case we\'ll just emit a moduleStart event for \'undefined\'.\n\t\t\t\t// Without this, reporters can get testStart before moduleStart  which is a problem.\n\t\t\t\t!hasOwn.call( config, "previousModule" )\n\t\t) {\n\t\t\tif ( hasOwn.call( config, "previousModule" ) ) {\n\t\t\t\trunLoggingCallbacks( "moduleDone", {\n\t\t\t\t\tname: config.previousModule.name,\n\t\t\t\t\ttests: config.previousModule.tests,\n\t\t\t\t\tfailed: config.moduleStats.bad,\n\t\t\t\t\tpassed: config.moduleStats.all - config.moduleStats.bad,\n\t\t\t\t\ttotal: config.moduleStats.all,\n\t\t\t\t\truntime: now() - config.moduleStats.started\n\t\t\t\t} );\n\t\t\t}\n\t\t\tconfig.previousModule = this.module;\n\t\t\tconfig.moduleStats = { all: 0, bad: 0, started: now() };\n\t\t\trunLoggingCallbacks( "moduleStart", {\n\t\t\t\tname: this.module.name,\n\t\t\t\ttests: this.module.tests\n\t\t\t} );\n\t\t}\n\n\t\tconfig.current = this;\n\n\t\tif ( this.module.testEnvironment ) {\n\t\t\tdelete this.module.testEnvironment.beforeEach;\n\t\t\tdelete this.module.testEnvironment.afterEach;\n\t\t}\n\t\tthis.testEnvironment = extend( {}, this.module.testEnvironment );\n\n\t\tthis.started = now();\n\t\trunLoggingCallbacks( "testStart", {\n\t\t\tname: this.testName,\n\t\t\tmodule: this.module.name,\n\t\t\ttestId: this.testId\n\t\t} );\n\n\t\tif ( !config.pollution ) {\n\t\t\tsaveGlobal();\n\t\t}\n\t},\n\n\trun: function() {\n\t\tvar promise;\n\n\t\tconfig.current = this;\n\n\t\tif ( this.async ) {\n\t\t\tQUnit.stop();\n\t\t}\n\n\t\tthis.callbackStarted = now();\n\n\t\tif ( config.notrycatch ) {\n\t\t\trunTest( this );\n\t\t\treturn;\n\t\t}\n\n\t\ttry {\n\t\t\trunTest( this );\n\t\t} catch ( e ) {\n\t\t\tthis.pushFailure( "Died on test #" + ( this.assertions.length + 1 ) + " " +\n\t\t\t\tthis.stack + ": " + ( e.message || e ), extractStacktrace( e, 0 ) );\n\n\t\t\t// Else next test will carry the responsibility\n\t\t\tsaveGlobal();\n\n\t\t\t// Restart the tests if they\'re blocking\n\t\t\tif ( config.blocking ) {\n\t\t\t\tQUnit.start();\n\t\t\t}\n\t\t}\n\n\t\tfunction runTest( test ) {\n\t\t\tpromise = test.callback.call( test.testEnvironment, test.assert );\n\t\t\ttest.resolvePromise( promise );\n\t\t}\n\t},\n\n\tafter: function() {\n\t\tcheckPollution();\n\t},\n\n\tqueueHook: function( hook, hookName ) {\n\t\tvar promise,\n\t\t\ttest = this;\n\t\treturn function runHook() {\n\t\t\tconfig.current = test;\n\t\t\tif ( config.notrycatch ) {\n\t\t\t\tcallHook();\n\t\t\t\treturn;\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tcallHook();\n\t\t\t} catch ( error ) {\n\t\t\t\ttest.pushFailure( hookName + " failed on " + test.testName + ": " +\n\t\t\t\t( error.message || error ), extractStacktrace( error, 0 ) );\n\t\t\t}\n\n\t\t\tfunction callHook() {\n\t\t\t\tpromise = hook.call( test.testEnvironment, test.assert );\n\t\t\t\ttest.resolvePromise( promise, hookName );\n\t\t\t}\n\t\t};\n\t},\n\n\t// Currently only used for module level hooks, can be used to add global level ones\n\thooks: function( handler ) {\n\t\tvar hooks = [];\n\n\t\tfunction processHooks( test, module ) {\n\t\t\tif ( module.parentModule ) {\n\t\t\t\tprocessHooks( test, module.parentModule );\n\t\t\t}\n\t\t\tif ( module.testEnvironment &&\n\t\t\t\tQUnit.objectType( module.testEnvironment[ handler ] ) === "function" ) {\n\t\t\t\thooks.push( test.queueHook( module.testEnvironment[ handler ], handler ) );\n\t\t\t}\n\t\t}\n\n\t\t// Hooks are ignored on skipped tests\n\t\tif ( !this.skip ) {\n\t\t\tprocessHooks( this, this.module );\n\t\t}\n\t\treturn hooks;\n\t},\n\n\tfinish: function() {\n\t\tconfig.current = this;\n\t\tif ( config.requireExpects && this.expected === null ) {\n\t\t\tthis.pushFailure( "Expected number of assertions to be defined, but expect() was " +\n\t\t\t\t"not called.", this.stack );\n\t\t} else if ( this.expected !== null && this.expected !== this.assertions.length ) {\n\t\t\tthis.pushFailure( "Expected " + this.expected + " assertions, but " +\n\t\t\t\tthis.assertions.length + " were run", this.stack );\n\t\t} else if ( this.expected === null && !this.assertions.length ) {\n\t\t\tthis.pushFailure( "Expected at least one assertion, but none were run - call " +\n\t\t\t\t"expect(0) to accept zero assertions.", this.stack );\n\t\t}\n\n\t\tvar i,\n\t\t\tbad = 0;\n\n\t\tthis.runtime = now() - this.started;\n\t\tconfig.stats.all += this.assertions.length;\n\t\tconfig.moduleStats.all += this.assertions.length;\n\n\t\tfor ( i = 0; i < this.assertions.length; i++ ) {\n\t\t\tif ( !this.assertions[ i ].result ) {\n\t\t\t\tbad++;\n\t\t\t\tconfig.stats.bad++;\n\t\t\t\tconfig.moduleStats.bad++;\n\t\t\t}\n\t\t}\n\n\t\trunLoggingCallbacks( "testDone", {\n\t\t\tname: this.testName,\n\t\t\tmodule: this.module.name,\n\t\t\tskipped: !!this.skip,\n\t\t\tfailed: bad,\n\t\t\tpassed: this.assertions.length - bad,\n\t\t\ttotal: this.assertions.length,\n\t\t\truntime: this.runtime,\n\n\t\t\t// HTML Reporter use\n\t\t\tassertions: this.assertions,\n\t\t\ttestId: this.testId,\n\n\t\t\t// Source of Test\n\t\t\tsource: this.stack,\n\n\t\t\t// DEPRECATED: this property will be removed in 2.0.0, use runtime instead\n\t\t\tduration: this.runtime\n\t\t} );\n\n\t\t// QUnit.reset() is deprecated and will be replaced for a new\n\t\t// fixture reset function on QUnit 2.0/2.1.\n\t\t// It\'s still called here for backwards compatibility handling\n\t\tQUnit.reset();\n\n\t\tconfig.current = undefined;\n\t},\n\n\tqueue: function() {\n\t\tvar priority,\n\t\t\ttest = this;\n\n\t\tif ( !this.valid() ) {\n\t\t\treturn;\n\t\t}\n\n\t\tfunction run() {\n\n\t\t\t// Each of these can by async\n\t\t\tsynchronize( [\n\t\t\t\tfunction() {\n\t\t\t\t\ttest.before();\n\t\t\t\t},\n\n\t\t\t\ttest.hooks( "beforeEach" ),\n\t\t\t\tfunction() {\n\t\t\t\t\ttest.run();\n\t\t\t\t},\n\n\t\t\t\ttest.hooks( "afterEach" ).reverse(),\n\n\t\t\t\tfunction() {\n\t\t\t\t\ttest.after();\n\t\t\t\t},\n\t\t\t\tfunction() {\n\t\t\t\t\ttest.finish();\n\t\t\t\t}\n\t\t\t] );\n\t\t}\n\n\t\t// Prioritize previously failed tests, detected from sessionStorage\n\t\tpriority = QUnit.config.reorder && defined.sessionStorage &&\n\t\t\t\t+sessionStorage.getItem( "qunit-test-" + this.module.name + "-" + this.testName );\n\n\t\treturn synchronize( run, priority, config.seed );\n\t},\n\n\tpushResult: function( resultInfo ) {\n\n\t\t// Destructure of resultInfo = { result, actual, expected, message, negative }\n\t\tvar source,\n\t\t\tdetails = {\n\t\t\t\tmodule: this.module.name,\n\t\t\t\tname: this.testName,\n\t\t\t\tresult: resultInfo.result,\n\t\t\t\tmessage: resultInfo.message,\n\t\t\t\tactual: resultInfo.actual,\n\t\t\t\texpected: resultInfo.expected,\n\t\t\t\ttestId: this.testId,\n\t\t\t\tnegative: resultInfo.negative || false,\n\t\t\t\truntime: now() - this.started\n\t\t\t};\n\n\t\tif ( !resultInfo.result ) {\n\t\t\tsource = sourceFromStacktrace();\n\n\t\t\tif ( source ) {\n\t\t\t\tdetails.source = source;\n\t\t\t}\n\t\t}\n\n\t\trunLoggingCallbacks( "log", details );\n\n\t\tthis.assertions.push( {\n\t\t\tresult: !!resultInfo.result,\n\t\t\tmessage: resultInfo.message\n\t\t} );\n\t},\n\n\tpushFailure: function( message, source, actual ) {\n\t\tif ( !( this instanceof Test ) ) {\n\t\t\tthrow new Error( "pushFailure() assertion outside test context, was " +\n\t\t\t\tsourceFromStacktrace( 2 ) );\n\t\t}\n\n\t\tvar details = {\n\t\t\t\tmodule: this.module.name,\n\t\t\t\tname: this.testName,\n\t\t\t\tresult: false,\n\t\t\t\tmessage: message || "error",\n\t\t\t\tactual: actual || null,\n\t\t\t\ttestId: this.testId,\n\t\t\t\truntime: now() - this.started\n\t\t\t};\n\n\t\tif ( source ) {\n\t\t\tdetails.source = source;\n\t\t}\n\n\t\trunLoggingCallbacks( "log", details );\n\n\t\tthis.assertions.push( {\n\t\t\tresult: false,\n\t\t\tmessage: message\n\t\t} );\n\t},\n\n\tresolvePromise: function( promise, phase ) {\n\t\tvar then, message,\n\t\t\ttest = this;\n\t\tif ( promise != null ) {\n\t\t\tthen = promise.then;\n\t\t\tif ( QUnit.objectType( then ) === "function" ) {\n\t\t\t\tQUnit.stop();\n\t\t\t\tthen.call(\n\t\t\t\t\tpromise,\n\t\t\t\t\tfunction() { QUnit.start(); },\n\t\t\t\t\tfunction( error ) {\n\t\t\t\t\t\tmessage = "Promise rejected " +\n\t\t\t\t\t\t\t( !phase ? "during" : phase.replace( /Each$/, "" ) ) +\n\t\t\t\t\t\t\t" " + test.testName + ": " + ( error.message || error );\n\t\t\t\t\t\ttest.pushFailure( message, extractStacktrace( error, 0 ) );\n\n\t\t\t\t\t\t// Else next test will carry the responsibility\n\t\t\t\t\t\tsaveGlobal();\n\n\t\t\t\t\t\t// Unblock\n\t\t\t\t\t\tQUnit.start();\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t},\n\n\tvalid: function() {\n\t\tvar filter = config.filter,\n\t\t\tregexFilter = /^(!?)\\/([\\w\\W]*)\\/(i?$)/.exec( filter ),\n\t\t\tmodule = config.module && config.module.toLowerCase(),\n\t\t\tfullName = ( this.module.name + ": " + this.testName );\n\n\t\tfunction moduleChainNameMatch( testModule ) {\n\t\t\tvar testModuleName = testModule.name ? testModule.name.toLowerCase() : null;\n\t\t\tif ( testModuleName === module ) {\n\t\t\t\treturn true;\n\t\t\t} else if ( testModule.parentModule ) {\n\t\t\t\treturn moduleChainNameMatch( testModule.parentModule );\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tfunction moduleChainIdMatch( testModule ) {\n\t\t\treturn inArray( testModule.moduleId, config.moduleId ) > -1 ||\n\t\t\t\ttestModule.parentModule && moduleChainIdMatch( testModule.parentModule );\n\t\t}\n\n\t\t// Internally-generated tests are always valid\n\t\tif ( this.callback && this.callback.validTest ) {\n\t\t\treturn true;\n\t\t}\n\n\t\tif ( config.moduleId && config.moduleId.length > 0 &&\n\t\t\t!moduleChainIdMatch( this.module ) ) {\n\n\t\t\treturn false;\n\t\t}\n\n\t\tif ( config.testId && config.testId.length > 0 &&\n\t\t\tinArray( this.testId, config.testId ) < 0 ) {\n\n\t\t\treturn false;\n\t\t}\n\n\t\tif ( module && !moduleChainNameMatch( this.module ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif ( !filter ) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn regexFilter ?\n\t\t\tthis.regexFilter( !!regexFilter[ 1 ], regexFilter[ 2 ], regexFilter[ 3 ], fullName ) :\n\t\t\tthis.stringFilter( filter, fullName );\n\t},\n\n\tregexFilter: function( exclude, pattern, flags, fullName ) {\n\t\tvar regex = new RegExp( pattern, flags );\n\t\tvar match = regex.test( fullName );\n\n\t\treturn match !== exclude;\n\t},\n\n\tstringFilter: function( filter, fullName ) {\n\t\tfilter = filter.toLowerCase();\n\t\tfullName = fullName.toLowerCase();\n\n\t\tvar include = filter.charAt( 0 ) !== "!";\n\t\tif ( !include ) {\n\t\t\tfilter = filter.slice( 1 );\n\t\t}\n\n\t\t// If the filter matches, we need to honour include\n\t\tif ( fullName.indexOf( filter ) !== -1 ) {\n\t\t\treturn include;\n\t\t}\n\n\t\t// Otherwise, do the opposite\n\t\treturn !include;\n\t}\n};\n\n// Resets the test setup. Useful for tests that modify the DOM.\n/*\nDEPRECATED: Use multiple tests instead of resetting inside a test.\nUse testStart or testDone for custom cleanup.\nThis method will throw an error in 2.0, and will be removed in 2.1\n*/\nQUnit.reset = function() {\n\n\t// Return on non-browser environments\n\t// This is necessary to not break on node tests\n\tif ( !defined.document ) {\n\t\treturn;\n\t}\n\n\tvar fixture = defined.document && document.getElementById &&\n\t\t\tdocument.getElementById( "qunit-fixture" );\n\n\tif ( fixture ) {\n\t\tfixture.innerHTML = config.fixture;\n\t}\n};\n\nQUnit.pushFailure = function() {\n\tif ( !QUnit.config.current ) {\n\t\tthrow new Error( "pushFailure() assertion outside test context, in " +\n\t\t\tsourceFromStacktrace( 2 ) );\n\t}\n\n\t// Gets current test obj\n\tvar currentTest = QUnit.config.current;\n\n\treturn currentTest.pushFailure.apply( currentTest, arguments );\n};\n\n// Based on Java\'s String.hashCode, a simple but not\n// rigorously collision resistant hashing function\nfunction generateHash( module, testName ) {\n\tvar hex,\n\t\ti = 0,\n\t\thash = 0,\n\t\tstr = module + "\\x1C" + testName,\n\t\tlen = str.length;\n\n\tfor ( ; i < len; i++ ) {\n\t\thash  = ( ( hash << 5 ) - hash ) + str.charCodeAt( i );\n\t\thash |= 0;\n\t}\n\n\t// Convert the possibly negative integer hash code into an 8 character hex string, which isn\'t\n\t// strictly necessary but increases user understanding that the id is a SHA-like hash\n\thex = ( 0x100000000 + hash ).toString( 16 );\n\tif ( hex.length < 8 ) {\n\t\thex = "0000000" + hex;\n\t}\n\n\treturn hex.slice( -8 );\n}\n\nfunction synchronize( callback, priority, seed ) {\n\tvar last = !priority,\n\t\tindex;\n\n\tif ( QUnit.objectType( callback ) === "array" ) {\n\t\twhile ( callback.length ) {\n\t\t\tsynchronize( callback.shift() );\n\t\t}\n\t\treturn;\n\t}\n\n\tif ( priority ) {\n\t\tconfig.queue.splice( priorityCount++, 0, callback );\n\t} else if ( seed ) {\n\t\tif ( !unitSampler ) {\n\t\t\tunitSampler = unitSamplerGenerator( seed );\n\t\t}\n\n\t\t// Insert into a random position after all priority items\n\t\tindex = Math.floor( unitSampler() * ( config.queue.length - priorityCount + 1 ) );\n\t\tconfig.queue.splice( priorityCount + index, 0, callback );\n\t} else {\n\t\tconfig.queue.push( callback );\n\t}\n\n\tif ( config.autorun && !config.blocking ) {\n\t\tprocess( last );\n\t}\n}\n\nfunction unitSamplerGenerator( seed ) {\n\n\t// 32-bit xorshift, requires only a nonzero seed\n\t// http://excamera.com/sphinx/article-xorshift.html\n\tvar sample = parseInt( generateHash( seed ), 16 ) || -1;\n\treturn function() {\n\t\tsample ^= sample << 13;\n\t\tsample ^= sample >>> 17;\n\t\tsample ^= sample << 5;\n\n\t\t// ECMAScript has no unsigned number type\n\t\tif ( sample < 0 ) {\n\t\t\tsample += 0x100000000;\n\t\t}\n\n\t\treturn sample / 0x100000000;\n\t};\n}\n\nfunction saveGlobal() {\n\tconfig.pollution = [];\n\n\tif ( config.noglobals ) {\n\t\tfor ( var key in global ) {\n\t\t\tif ( hasOwn.call( global, key ) ) {\n\n\t\t\t\t// In Opera sometimes DOM element ids show up here, ignore them\n\t\t\t\tif ( /^qunit-test-output/.test( key ) ) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tconfig.pollution.push( key );\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction checkPollution() {\n\tvar newGlobals,\n\t\tdeletedGlobals,\n\t\told = config.pollution;\n\n\tsaveGlobal();\n\n\tnewGlobals = diff( config.pollution, old );\n\tif ( newGlobals.length > 0 ) {\n\t\tQUnit.pushFailure( "Introduced global variable(s): " + newGlobals.join( ", " ) );\n\t}\n\n\tdeletedGlobals = diff( old, config.pollution );\n\tif ( deletedGlobals.length > 0 ) {\n\t\tQUnit.pushFailure( "Deleted global variable(s): " + deletedGlobals.join( ", " ) );\n\t}\n}\n\n// Will be exposed as QUnit.asyncTest\nfunction asyncTest( testName, expected, callback ) {\n\tif ( arguments.length === 2 ) {\n\t\tcallback = expected;\n\t\texpected = null;\n\t}\n\n\tQUnit.test( testName, expected, callback, true );\n}\n\n// Will be exposed as QUnit.test\nfunction test( testName, expected, callback, async ) {\n\tif ( focused )  { return; }\n\n\tvar newTest;\n\n\tif ( arguments.length === 2 ) {\n\t\tcallback = expected;\n\t\texpected = null;\n\t}\n\n\tnewTest = new Test( {\n\t\ttestName: testName,\n\t\texpected: expected,\n\t\tasync: async,\n\t\tcallback: callback\n\t} );\n\n\tnewTest.queue();\n}\n\n// Will be exposed as QUnit.skip\nfunction skip( testName ) {\n\tif ( focused )  { return; }\n\n\tvar test = new Test( {\n\t\ttestName: testName,\n\t\tskip: true\n\t} );\n\n\ttest.queue();\n}\n\n// Will be exposed as QUnit.only\nfunction only( testName, expected, callback, async ) {\n\tvar newTest;\n\n\tif ( focused )  { return; }\n\n\tQUnit.config.queue.length = 0;\n\tfocused = true;\n\n\tif ( arguments.length === 2 ) {\n\t\tcallback = expected;\n\t\texpected = null;\n\t}\n\n\tnewTest = new Test( {\n\t\ttestName: testName,\n\t\texpected: expected,\n\t\tasync: async,\n\t\tcallback: callback\n\t} );\n\n\tnewTest.queue();\n}\n\nfunction Assert( testContext ) {\n\tthis.test = testContext;\n}\n\n// Assert helpers\nQUnit.assert = Assert.prototype = {\n\n\t// Specify the number of expected assertions to guarantee that failed test\n\t// (no assertions are run at all) don\'t slip through.\n\texpect: function( asserts ) {\n\t\tif ( arguments.length === 1 ) {\n\t\t\tthis.test.expected = asserts;\n\t\t} else {\n\t\t\treturn this.test.expected;\n\t\t}\n\t},\n\n\t// Increment this Test\'s semaphore counter, then return a function that\n\t// decrements that counter a maximum of once.\n\tasync: function( count ) {\n\t\tvar test = this.test,\n\t\t\tpopped = false,\n\t\t\tacceptCallCount = count;\n\n\t\tif ( typeof acceptCallCount === "undefined" ) {\n\t\t\tacceptCallCount = 1;\n\t\t}\n\n\t\ttest.semaphore += 1;\n\t\ttest.usedAsync = true;\n\t\tpauseProcessing();\n\n\t\treturn function done() {\n\n\t\t\tif ( popped ) {\n\t\t\t\ttest.pushFailure( "Too many calls to the `assert.async` callback",\n\t\t\t\t\tsourceFromStacktrace( 2 ) );\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tacceptCallCount -= 1;\n\t\t\tif ( acceptCallCount > 0 ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\ttest.semaphore -= 1;\n\t\t\tpopped = true;\n\t\t\tresumeProcessing();\n\t\t};\n\t},\n\n\t// Exports test.push() to the user API\n\t// Alias of pushResult.\n\tpush: function( result, actual, expected, message, negative ) {\n\t\tvar currentAssert = this instanceof Assert ? this : QUnit.config.current.assert;\n\t\treturn currentAssert.pushResult( {\n\t\t\tresult: result,\n\t\t\tactual: actual,\n\t\t\texpected: expected,\n\t\t\tmessage: message,\n\t\t\tnegative: negative\n\t\t} );\n\t},\n\n\tpushResult: function( resultInfo ) {\n\n\t\t// Destructure of resultInfo = { result, actual, expected, message, negative }\n\t\tvar assert = this,\n\t\t\tcurrentTest = ( assert instanceof Assert && assert.test ) || QUnit.config.current;\n\n\t\t// Backwards compatibility fix.\n\t\t// Allows the direct use of global exported assertions and QUnit.assert.*\n\t\t// Although, it\'s use is not recommended as it can leak assertions\n\t\t// to other tests from async tests, because we only get a reference to the current test,\n\t\t// not exactly the test where assertion were intended to be called.\n\t\tif ( !currentTest ) {\n\t\t\tthrow new Error( "assertion outside test context, in " + sourceFromStacktrace( 2 ) );\n\t\t}\n\n\t\tif ( currentTest.usedAsync === true && currentTest.semaphore === 0 ) {\n\t\t\tcurrentTest.pushFailure( "Assertion after the final `assert.async` was resolved",\n\t\t\t\tsourceFromStacktrace( 2 ) );\n\n\t\t\t// Allow this assertion to continue running anyway...\n\t\t}\n\n\t\tif ( !( assert instanceof Assert ) ) {\n\t\t\tassert = currentTest.assert;\n\t\t}\n\n\t\treturn assert.test.pushResult( resultInfo );\n\t},\n\n\tok: function( result, message ) {\n\t\tmessage = message || ( result ? "okay" : "failed, expected argument to be truthy, was: " +\n\t\t\tQUnit.dump.parse( result ) );\n\t\tthis.pushResult( {\n\t\t\tresult: !!result,\n\t\t\tactual: result,\n\t\t\texpected: true,\n\t\t\tmessage: message\n\t\t} );\n\t},\n\n\tnotOk: function( result, message ) {\n\t\tmessage = message || ( !result ? "okay" : "failed, expected argument to be falsy, was: " +\n\t\t\tQUnit.dump.parse( result ) );\n\t\tthis.pushResult( {\n\t\t\tresult: !result,\n\t\t\tactual: result,\n\t\t\texpected: false,\n\t\t\tmessage: message\n\t\t} );\n\t},\n\n\tequal: function( actual, expected, message ) {\n\t\t/*jshint eqeqeq:false */\n\t\tthis.pushResult( {\n\t\t\tresult: expected == actual,\n\t\t\tactual: actual,\n\t\t\texpected: expected,\n\t\t\tmessage: message\n\t\t} );\n\t},\n\n\tnotEqual: function( actual, expected, message ) {\n\t\t/*jshint eqeqeq:false */\n\t\tthis.pushResult( {\n\t\t\tresult: expected != actual,\n\t\t\tactual: actual,\n\t\t\texpected: expected,\n\t\t\tmessage: message,\n\t\t\tnegative: true\n\t\t} );\n\t},\n\n\tpropEqual: function( actual, expected, message ) {\n\t\tactual = objectValues( actual );\n\t\texpected = objectValues( expected );\n\t\tthis.pushResult( {\n\t\t\tresult: QUnit.equiv( actual, expected ),\n\t\t\tactual: actual,\n\t\t\texpected: expected,\n\t\t\tmessage: message\n\t\t} );\n\t},\n\n\tnotPropEqual: function( actual, expected, message ) {\n\t\tactual = objectValues( actual );\n\t\texpected = objectValues( expected );\n\t\tthis.pushResult( {\n\t\t\tresult: !QUnit.equiv( actual, expected ),\n\t\t\tactual: actual,\n\t\t\texpected: expected,\n\t\t\tmessage: message,\n\t\t\tnegative: true\n\t\t} );\n\t},\n\n\tdeepEqual: function( actual, expected, message ) {\n\t\tthis.pushResult( {\n\t\t\tresult: QUnit.equiv( actual, expected ),\n\t\t\tactual: actual,\n\t\t\texpected: expected,\n\t\t\tmessage: message\n\t\t} );\n\t},\n\n\tnotDeepEqual: function( actual, expected, message ) {\n\t\tthis.pushResult( {\n\t\t\tresult: !QUnit.equiv( actual, expected ),\n\t\t\tactual: actual,\n\t\t\texpected: expected,\n\t\t\tmessage: message,\n\t\t\tnegative: true\n\t\t} );\n\t},\n\n\tstrictEqual: function( actual, expected, message ) {\n\t\tthis.pushResult( {\n\t\t\tresult: expected === actual,\n\t\t\tactual: actual,\n\t\t\texpected: expected,\n\t\t\tmessage: message\n\t\t} );\n\t},\n\n\tnotStrictEqual: function( actual, expected, message ) {\n\t\tthis.pushResult( {\n\t\t\tresult: expected !== actual,\n\t\t\tactual: actual,\n\t\t\texpected: expected,\n\t\t\tmessage: message,\n\t\t\tnegative: true\n\t\t} );\n\t},\n\n\t"throws": function( block, expected, message ) {\n\t\tvar actual, expectedType,\n\t\t\texpectedOutput = expected,\n\t\t\tok = false,\n\t\t\tcurrentTest = ( this instanceof Assert && this.test ) || QUnit.config.current;\n\n\t\t// \'expected\' is optional unless doing string comparison\n\t\tif ( message == null && typeof expected === "string" ) {\n\t\t\tmessage = expected;\n\t\t\texpected = null;\n\t\t}\n\n\t\tcurrentTest.ignoreGlobalErrors = true;\n\t\ttry {\n\t\t\tblock.call( currentTest.testEnvironment );\n\t\t} catch ( e ) {\n\t\t\tactual = e;\n\t\t}\n\t\tcurrentTest.ignoreGlobalErrors = false;\n\n\t\tif ( actual ) {\n\t\t\texpectedType = QUnit.objectType( expected );\n\n\t\t\t// We don\'t want to validate thrown error\n\t\t\tif ( !expected ) {\n\t\t\t\tok = true;\n\t\t\t\texpectedOutput = null;\n\n\t\t\t// Expected is a regexp\n\t\t\t} else if ( expectedType === "regexp" ) {\n\t\t\t\tok = expected.test( errorString( actual ) );\n\n\t\t\t// Expected is a string\n\t\t\t} else if ( expectedType === "string" ) {\n\t\t\t\tok = expected === errorString( actual );\n\n\t\t\t// Expected is a constructor, maybe an Error constructor\n\t\t\t} else if ( expectedType === "function" && actual instanceof expected ) {\n\t\t\t\tok = true;\n\n\t\t\t// Expected is an Error object\n\t\t\t} else if ( expectedType === "object" ) {\n\t\t\t\tok = actual instanceof expected.constructor &&\n\t\t\t\t\tactual.name === expected.name &&\n\t\t\t\t\tactual.message === expected.message;\n\n\t\t\t// Expected is a validation function which returns true if validation passed\n\t\t\t} else if ( expectedType === "function" && expected.call( {}, actual ) === true ) {\n\t\t\t\texpectedOutput = null;\n\t\t\t\tok = true;\n\t\t\t}\n\t\t}\n\n\t\tcurrentTest.assert.pushResult( {\n\t\t\tresult: ok,\n\t\t\tactual: actual,\n\t\t\texpected: expectedOutput,\n\t\t\tmessage: message\n\t\t} );\n\t}\n};\n\n// Provide an alternative to assert.throws(), for environments that consider throws a reserved word\n// Known to us are: Closure Compiler, Narwhal\n( function() {\n\t/*jshint sub:true */\n\tAssert.prototype.raises = Assert.prototype [ "throws" ]; //jscs:ignore requireDotNotation\n}() );\n\nfunction errorString( error ) {\n\tvar name, message,\n\t\tresultErrorString = error.toString();\n\tif ( resultErrorString.substring( 0, 7 ) === "[object" ) {\n\t\tname = error.name ? error.name.toString() : "Error";\n\t\tmessage = error.message ? error.message.toString() : "";\n\t\tif ( name && message ) {\n\t\t\treturn name + ": " + message;\n\t\t} else if ( name ) {\n\t\t\treturn name;\n\t\t} else if ( message ) {\n\t\t\treturn message;\n\t\t} else {\n\t\t\treturn "Error";\n\t\t}\n\t} else {\n\t\treturn resultErrorString;\n\t}\n}\n\n// Test for equality any JavaScript type.\n// Author: Philippe Rath <prathe@gmail.com>\nQUnit.equiv = ( function() {\n\n\t// Stack to decide between skip/abort functions\n\tvar callers = [];\n\n\t// Stack to avoiding loops from circular referencing\n\tvar parents = [];\n\tvar parentsB = [];\n\n\tvar getProto = Object.getPrototypeOf || function( obj ) {\n\n\t\t/*jshint proto: true */\n\t\treturn obj.__proto__;\n\t};\n\n\tfunction useStrictEquality( b, a ) {\n\n\t\t// To catch short annotation VS \'new\' annotation of a declaration. e.g.:\n\t\t// `var i = 1;`\n\t\t// `var j = new Number(1);`\n\t\tif ( typeof a === "object" ) {\n\t\t\ta = a.valueOf();\n\t\t}\n\t\tif ( typeof b === "object" ) {\n\t\t\tb = b.valueOf();\n\t\t}\n\n\t\treturn a === b;\n\t}\n\n\tfunction compareConstructors( a, b ) {\n\t\tvar protoA = getProto( a );\n\t\tvar protoB = getProto( b );\n\n\t\t// Comparing constructors is more strict than using `instanceof`\n\t\tif ( a.constructor === b.constructor ) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// Ref #851\n\t\t// If the obj prototype descends from a null constructor, treat it\n\t\t// as a null prototype.\n\t\tif ( protoA && protoA.constructor === null ) {\n\t\t\tprotoA = null;\n\t\t}\n\t\tif ( protoB && protoB.constructor === null ) {\n\t\t\tprotoB = null;\n\t\t}\n\n\t\t// Allow objects with no prototype to be equivalent to\n\t\t// objects with Object as their constructor.\n\t\tif ( ( protoA === null && protoB === Object.prototype ) ||\n\t\t\t\t( protoB === null && protoA === Object.prototype ) ) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tfunction getRegExpFlags( regexp ) {\n\t\treturn "flags" in regexp ? regexp.flags : regexp.toString().match( /[gimuy]*$/ )[ 0 ];\n\t}\n\n\tvar callbacks = {\n\t\t"string": useStrictEquality,\n\t\t"boolean": useStrictEquality,\n\t\t"number": useStrictEquality,\n\t\t"null": useStrictEquality,\n\t\t"undefined": useStrictEquality,\n\t\t"symbol": useStrictEquality,\n\t\t"date": useStrictEquality,\n\n\t\t"nan": function() {\n\t\t\treturn true;\n\t\t},\n\n\t\t"regexp": function( b, a ) {\n\t\t\treturn a.source === b.source &&\n\n\t\t\t\t// Include flags in the comparison\n\t\t\t\tgetRegExpFlags( a ) === getRegExpFlags( b );\n\t\t},\n\n\t\t// - skip when the property is a method of an instance (OOP)\n\t\t// - abort otherwise,\n\t\t// initial === would have catch identical references anyway\n\t\t"function": function() {\n\t\t\tvar caller = callers[ callers.length - 1 ];\n\t\t\treturn caller !== Object && typeof caller !== "undefined";\n\t\t},\n\n\t\t"array": function( b, a ) {\n\t\t\tvar i, j, len, loop, aCircular, bCircular;\n\n\t\t\tlen = a.length;\n\t\t\tif ( len !== b.length ) {\n\n\t\t\t\t// Safe and faster\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// Track reference to avoid circular references\n\t\t\tparents.push( a );\n\t\t\tparentsB.push( b );\n\t\t\tfor ( i = 0; i < len; i++ ) {\n\t\t\t\tloop = false;\n\t\t\t\tfor ( j = 0; j < parents.length; j++ ) {\n\t\t\t\t\taCircular = parents[ j ] === a[ i ];\n\t\t\t\t\tbCircular = parentsB[ j ] === b[ i ];\n\t\t\t\t\tif ( aCircular || bCircular ) {\n\t\t\t\t\t\tif ( a[ i ] === b[ i ] || aCircular && bCircular ) {\n\t\t\t\t\t\t\tloop = true;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tparents.pop();\n\t\t\t\t\t\t\tparentsB.pop();\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif ( !loop && !innerEquiv( a[ i ], b[ i ] ) ) {\n\t\t\t\t\tparents.pop();\n\t\t\t\t\tparentsB.pop();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tparents.pop();\n\t\t\tparentsB.pop();\n\t\t\treturn true;\n\t\t},\n\n\t\t"set": function( b, a ) {\n\t\t\tvar innerEq,\n\t\t\t\touterEq = true;\n\n\t\t\tif ( a.size !== b.size ) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\ta.forEach( function( aVal ) {\n\t\t\t\tinnerEq = false;\n\n\t\t\t\tb.forEach( function( bVal ) {\n\t\t\t\t\tif ( innerEquiv( bVal, aVal ) ) {\n\t\t\t\t\t\tinnerEq = true;\n\t\t\t\t\t}\n\t\t\t\t} );\n\n\t\t\t\tif ( !innerEq ) {\n\t\t\t\t\touterEq = false;\n\t\t\t\t}\n\t\t\t} );\n\n\t\t\treturn outerEq;\n\t\t},\n\n\t\t"map": function( b, a ) {\n\t\t\tvar innerEq,\n\t\t\t\touterEq = true;\n\n\t\t\tif ( a.size !== b.size ) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\ta.forEach( function( aVal, aKey ) {\n\t\t\t\tinnerEq = false;\n\n\t\t\t\tb.forEach( function( bVal, bKey ) {\n\t\t\t\t\tif ( innerEquiv( [ bVal, bKey ], [ aVal, aKey ] ) ) {\n\t\t\t\t\t\tinnerEq = true;\n\t\t\t\t\t}\n\t\t\t\t} );\n\n\t\t\t\tif ( !innerEq ) {\n\t\t\t\t\touterEq = false;\n\t\t\t\t}\n\t\t\t} );\n\n\t\t\treturn outerEq;\n\t\t},\n\n\t\t"object": function( b, a ) {\n\t\t\tvar i, j, loop, aCircular, bCircular;\n\n\t\t\t// Default to true\n\t\t\tvar eq = true;\n\t\t\tvar aProperties = [];\n\t\t\tvar bProperties = [];\n\n\t\t\tif ( compareConstructors( a, b ) === false ) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// Stack constructor before traversing properties\n\t\t\tcallers.push( a.constructor );\n\n\t\t\t// Track reference to avoid circular references\n\t\t\tparents.push( a );\n\t\t\tparentsB.push( b );\n\n\t\t\t// Be strict: don\'t ensure hasOwnProperty and go deep\n\t\t\tfor ( i in a ) {\n\t\t\t\tloop = false;\n\t\t\t\tfor ( j = 0; j < parents.length; j++ ) {\n\t\t\t\t\taCircular = parents[ j ] === a[ i ];\n\t\t\t\t\tbCircular = parentsB[ j ] === b[ i ];\n\t\t\t\t\tif ( aCircular || bCircular ) {\n\t\t\t\t\t\tif ( a[ i ] === b[ i ] || aCircular && bCircular ) {\n\t\t\t\t\t\t\tloop = true;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\teq = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\taProperties.push( i );\n\t\t\t\tif ( !loop && !innerEquiv( a[ i ], b[ i ] ) ) {\n\t\t\t\t\teq = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tparents.pop();\n\t\t\tparentsB.pop();\n\n\t\t\t// Unstack, we are done\n\t\t\tcallers.pop();\n\n\t\t\tfor ( i in b ) {\n\n\t\t\t\t// Collect b\'s properties\n\t\t\t\tbProperties.push( i );\n\t\t\t}\n\n\t\t\t// Ensures identical properties name\n\t\t\treturn eq && innerEquiv( aProperties.sort(), bProperties.sort() );\n\t\t}\n\t};\n\n\tfunction typeEquiv( a, b ) {\n\t\tvar type = QUnit.objectType( a );\n\t\treturn QUnit.objectType( b ) === type && callbacks[ type ]( b, a );\n\t}\n\n\t// The real equiv function\n\tfunction innerEquiv( a, b ) {\n\n\t\t// We\'re done when there\'s nothing more to compare\n\t\tif ( arguments.length < 2 ) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// Require type-specific equality\n\t\treturn ( a === b || typeEquiv( a, b ) ) &&\n\n\t\t\t// ...across all consecutive argument pairs\n\t\t\t( arguments.length === 2 || innerEquiv.apply( this, [].slice.call( arguments, 1 ) ) );\n\t}\n\n\treturn innerEquiv;\n}() );\n\n// Based on jsDump by Ariel Flesler\n// http://flesler.blogspot.com/2008/05/jsdump-pretty-dump-of-any-javascript.html\nQUnit.dump = ( function() {\n\tfunction quote( str ) {\n\t\treturn "\\"" + str.toString().replace( /\\\\/g, "\\\\\\\\" ).replace( /"/g, "\\\\\\"" ) + "\\"";\n\t}\n\tfunction literal( o ) {\n\t\treturn o + "";\n\t}\n\tfunction join( pre, arr, post ) {\n\t\tvar s = dump.separator(),\n\t\t\tbase = dump.indent(),\n\t\t\tinner = dump.indent( 1 );\n\t\tif ( arr.join ) {\n\t\t\tarr = arr.join( "," + s + inner );\n\t\t}\n\t\tif ( !arr ) {\n\t\t\treturn pre + post;\n\t\t}\n\t\treturn [ pre, inner + arr, base + post ].join( s );\n\t}\n\tfunction array( arr, stack ) {\n\t\tvar i = arr.length,\n\t\t\tret = new Array( i );\n\n\t\tif ( dump.maxDepth && dump.depth > dump.maxDepth ) {\n\t\t\treturn "[object Array]";\n\t\t}\n\n\t\tthis.up();\n\t\twhile ( i-- ) {\n\t\t\tret[ i ] = this.parse( arr[ i ], undefined, stack );\n\t\t}\n\t\tthis.down();\n\t\treturn join( "[", ret, "]" );\n\t}\n\n\tvar reName = /^function (\\w+)/,\n\t\tdump = {\n\n\t\t\t// The objType is used mostly internally, you can fix a (custom) type in advance\n\t\t\tparse: function( obj, objType, stack ) {\n\t\t\t\tstack = stack || [];\n\t\t\t\tvar res, parser, parserType,\n\t\t\t\t\tinStack = inArray( obj, stack );\n\n\t\t\t\tif ( inStack !== -1 ) {\n\t\t\t\t\treturn "recursion(" + ( inStack - stack.length ) + ")";\n\t\t\t\t}\n\n\t\t\t\tobjType = objType || this.typeOf( obj  );\n\t\t\t\tparser = this.parsers[ objType ];\n\t\t\t\tparserType = typeof parser;\n\n\t\t\t\tif ( parserType === "function" ) {\n\t\t\t\t\tstack.push( obj );\n\t\t\t\t\tres = parser.call( this, obj, stack );\n\t\t\t\t\tstack.pop();\n\t\t\t\t\treturn res;\n\t\t\t\t}\n\t\t\t\treturn ( parserType === "string" ) ? parser : this.parsers.error;\n\t\t\t},\n\t\t\ttypeOf: function( obj ) {\n\t\t\t\tvar type;\n\t\t\t\tif ( obj === null ) {\n\t\t\t\t\ttype = "null";\n\t\t\t\t} else if ( typeof obj === "undefined" ) {\n\t\t\t\t\ttype = "undefined";\n\t\t\t\t} else if ( QUnit.is( "regexp", obj ) ) {\n\t\t\t\t\ttype = "regexp";\n\t\t\t\t} else if ( QUnit.is( "date", obj ) ) {\n\t\t\t\t\ttype = "date";\n\t\t\t\t} else if ( QUnit.is( "function", obj ) ) {\n\t\t\t\t\ttype = "function";\n\t\t\t\t} else if ( obj.setInterval !== undefined &&\n\t\t\t\t\t\tobj.document !== undefined &&\n\t\t\t\t\t\tobj.nodeType === undefined ) {\n\t\t\t\t\ttype = "window";\n\t\t\t\t} else if ( obj.nodeType === 9 ) {\n\t\t\t\t\ttype = "document";\n\t\t\t\t} else if ( obj.nodeType ) {\n\t\t\t\t\ttype = "node";\n\t\t\t\t} else if (\n\n\t\t\t\t\t// Native arrays\n\t\t\t\t\ttoString.call( obj ) === "[object Array]" ||\n\n\t\t\t\t\t// NodeList objects\n\t\t\t\t\t( typeof obj.length === "number" && obj.item !== undefined &&\n\t\t\t\t\t( obj.length ? obj.item( 0 ) === obj[ 0 ] : ( obj.item( 0 ) === null &&\n\t\t\t\t\tobj[ 0 ] === undefined ) ) )\n\t\t\t\t) {\n\t\t\t\t\ttype = "array";\n\t\t\t\t} else if ( obj.constructor === Error.prototype.constructor ) {\n\t\t\t\t\ttype = "error";\n\t\t\t\t} else {\n\t\t\t\t\ttype = typeof obj;\n\t\t\t\t}\n\t\t\t\treturn type;\n\t\t\t},\n\n\t\t\tseparator: function() {\n\t\t\t\treturn this.multiline ? this.HTML ? "<br />" : "\\n" : this.HTML ? "&#160;" : " ";\n\t\t\t},\n\n\t\t\t// Extra can be a number, shortcut for increasing-calling-decreasing\n\t\t\tindent: function( extra ) {\n\t\t\t\tif ( !this.multiline ) {\n\t\t\t\t\treturn "";\n\t\t\t\t}\n\t\t\t\tvar chr = this.indentChar;\n\t\t\t\tif ( this.HTML ) {\n\t\t\t\t\tchr = chr.replace( /\\t/g, "   " ).replace( / /g, "&#160;" );\n\t\t\t\t}\n\t\t\t\treturn new Array( this.depth + ( extra || 0 ) ).join( chr );\n\t\t\t},\n\t\t\tup: function( a ) {\n\t\t\t\tthis.depth += a || 1;\n\t\t\t},\n\t\t\tdown: function( a ) {\n\t\t\t\tthis.depth -= a || 1;\n\t\t\t},\n\t\t\tsetParser: function( name, parser ) {\n\t\t\t\tthis.parsers[ name ] = parser;\n\t\t\t},\n\n\t\t\t// The next 3 are exposed so you can use them\n\t\t\tquote: quote,\n\t\t\tliteral: literal,\n\t\t\tjoin: join,\n\t\t\tdepth: 1,\n\t\t\tmaxDepth: QUnit.config.maxDepth,\n\n\t\t\t// This is the list of parsers, to modify them, use dump.setParser\n\t\t\tparsers: {\n\t\t\t\twindow: "[Window]",\n\t\t\t\tdocument: "[Document]",\n\t\t\t\terror: function( error ) {\n\t\t\t\t\treturn "Error(\\"" + error.message + "\\")";\n\t\t\t\t},\n\t\t\t\tunknown: "[Unknown]",\n\t\t\t\t"null": "null",\n\t\t\t\t"undefined": "undefined",\n\t\t\t\t"function": function( fn ) {\n\t\t\t\t\tvar ret = "function",\n\n\t\t\t\t\t\t// Functions never have name in IE\n\t\t\t\t\t\tname = "name" in fn ? fn.name : ( reName.exec( fn ) || [] )[ 1 ];\n\n\t\t\t\t\tif ( name ) {\n\t\t\t\t\t\tret += " " + name;\n\t\t\t\t\t}\n\t\t\t\t\tret += "(";\n\n\t\t\t\t\tret = [ ret, dump.parse( fn, "functionArgs" ), "){" ].join( "" );\n\t\t\t\t\treturn join( ret, dump.parse( fn, "functionCode" ), "}" );\n\t\t\t\t},\n\t\t\t\tarray: array,\n\t\t\t\tnodelist: array,\n\t\t\t\t"arguments": array,\n\t\t\t\tobject: function( map, stack ) {\n\t\t\t\t\tvar keys, key, val, i, nonEnumerableProperties,\n\t\t\t\t\t\tret = [];\n\n\t\t\t\t\tif ( dump.maxDepth && dump.depth > dump.maxDepth ) {\n\t\t\t\t\t\treturn "[object Object]";\n\t\t\t\t\t}\n\n\t\t\t\t\tdump.up();\n\t\t\t\t\tkeys = [];\n\t\t\t\t\tfor ( key in map ) {\n\t\t\t\t\t\tkeys.push( key );\n\t\t\t\t\t}\n\n\t\t\t\t\t// Some properties are not always enumerable on Error objects.\n\t\t\t\t\tnonEnumerableProperties = [ "message", "name" ];\n\t\t\t\t\tfor ( i in nonEnumerableProperties ) {\n\t\t\t\t\t\tkey = nonEnumerableProperties[ i ];\n\t\t\t\t\t\tif ( key in map && inArray( key, keys ) < 0 ) {\n\t\t\t\t\t\t\tkeys.push( key );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tkeys.sort();\n\t\t\t\t\tfor ( i = 0; i < keys.length; i++ ) {\n\t\t\t\t\t\tkey = keys[ i ];\n\t\t\t\t\t\tval = map[ key ];\n\t\t\t\t\t\tret.push( dump.parse( key, "key" ) + ": " +\n\t\t\t\t\t\t\tdump.parse( val, undefined, stack ) );\n\t\t\t\t\t}\n\t\t\t\t\tdump.down();\n\t\t\t\t\treturn join( "{", ret, "}" );\n\t\t\t\t},\n\t\t\t\tnode: function( node ) {\n\t\t\t\t\tvar len, i, val,\n\t\t\t\t\t\topen = dump.HTML ? "&lt;" : "<",\n\t\t\t\t\t\tclose = dump.HTML ? "&gt;" : ">",\n\t\t\t\t\t\ttag = node.nodeName.toLowerCase(),\n\t\t\t\t\t\tret = open + tag,\n\t\t\t\t\t\tattrs = node.attributes;\n\n\t\t\t\t\tif ( attrs ) {\n\t\t\t\t\t\tfor ( i = 0, len = attrs.length; i < len; i++ ) {\n\t\t\t\t\t\t\tval = attrs[ i ].nodeValue;\n\n\t\t\t\t\t\t\t// IE6 includes all attributes in .attributes, even ones not explicitly\n\t\t\t\t\t\t\t// set. Those have values like undefined, null, 0, false, "" or\n\t\t\t\t\t\t\t// "inherit".\n\t\t\t\t\t\t\tif ( val && val !== "inherit" ) {\n\t\t\t\t\t\t\t\tret += " " + attrs[ i ].nodeName + "=" +\n\t\t\t\t\t\t\t\t\tdump.parse( val, "attribute" );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tret += close;\n\n\t\t\t\t\t// Show content of TextNode or CDATASection\n\t\t\t\t\tif ( node.nodeType === 3 || node.nodeType === 4 ) {\n\t\t\t\t\t\tret += node.nodeValue;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn ret + open + "/" + tag + close;\n\t\t\t\t},\n\n\t\t\t\t// Function calls it internally, it\'s the arguments part of the function\n\t\t\t\tfunctionArgs: function( fn ) {\n\t\t\t\t\tvar args,\n\t\t\t\t\t\tl = fn.length;\n\n\t\t\t\t\tif ( !l ) {\n\t\t\t\t\t\treturn "";\n\t\t\t\t\t}\n\n\t\t\t\t\targs = new Array( l );\n\t\t\t\t\twhile ( l-- ) {\n\n\t\t\t\t\t\t// 97 is \'a\'\n\t\t\t\t\t\targs[ l ] = String.fromCharCode( 97 + l );\n\t\t\t\t\t}\n\t\t\t\t\treturn " " + args.join( ", " ) + " ";\n\t\t\t\t},\n\n\t\t\t\t// Object calls it internally, the key part of an item in a map\n\t\t\t\tkey: quote,\n\n\t\t\t\t// Function calls it internally, it\'s the content of the function\n\t\t\t\tfunctionCode: "[code]",\n\n\t\t\t\t// Node calls it internally, it\'s a html attribute value\n\t\t\t\tattribute: quote,\n\t\t\t\tstring: quote,\n\t\t\t\tdate: quote,\n\t\t\t\tregexp: literal,\n\t\t\t\tnumber: literal,\n\t\t\t\t"boolean": literal\n\t\t\t},\n\n\t\t\t// If true, entities are escaped ( <, >, \\t, space and \\n )\n\t\t\tHTML: false,\n\n\t\t\t// Indentation unit\n\t\t\tindentChar: "  ",\n\n\t\t\t// If true, items in a collection, are separated by a \\n, else just a space.\n\t\t\tmultiline: true\n\t\t};\n\n\treturn dump;\n}() );\n\n// Back compat\nQUnit.jsDump = QUnit.dump;\n\n// Deprecated\n// Extend assert methods to QUnit for Backwards compatibility\n( function() {\n\tvar i,\n\t\tassertions = Assert.prototype;\n\n\tfunction applyCurrent( current ) {\n\t\treturn function() {\n\t\t\tvar assert = new Assert( QUnit.config.current );\n\t\t\tcurrent.apply( assert, arguments );\n\t\t};\n\t}\n\n\tfor ( i in assertions ) {\n\t\tQUnit[ i ] = applyCurrent( assertions[ i ] );\n\t}\n}() );\n\n// For browser, export only select globals\nif ( defined.document ) {\n\n\t( function() {\n\t\tvar i, l,\n\t\t\tkeys = [\n\t\t\t\t"test",\n\t\t\t\t"module",\n\t\t\t\t"expect",\n\t\t\t\t"asyncTest",\n\t\t\t\t"start",\n\t\t\t\t"stop",\n\t\t\t\t"ok",\n\t\t\t\t"notOk",\n\t\t\t\t"equal",\n\t\t\t\t"notEqual",\n\t\t\t\t"propEqual",\n\t\t\t\t"notPropEqual",\n\t\t\t\t"deepEqual",\n\t\t\t\t"notDeepEqual",\n\t\t\t\t"strictEqual",\n\t\t\t\t"notStrictEqual",\n\t\t\t\t"throws",\n\t\t\t\t"raises"\n\t\t\t];\n\n\t\tfor ( i = 0, l = keys.length; i < l; i++ ) {\n\t\t\twindow[ keys[ i ] ] = QUnit[ keys[ i ] ];\n\t\t}\n\t}() );\n\n\twindow.QUnit = QUnit;\n}\n\n// For nodejs\nif ( typeof module !== "undefined" && module && module.exports ) {\n\tmodule.exports = QUnit;\n\n\t// For consistency with CommonJS environments\' exports\n\tmodule.exports.QUnit = QUnit;\n}\n\n// For CommonJS with exports, but without module.exports, like Rhino\nif ( typeof exports !== "undefined" && exports ) {\n\texports.QUnit = QUnit;\n}\n\nif ( typeof define === "function" && define.amd ) {\n\tdefine( function() {\n\t\treturn QUnit;\n\t} );\n\tQUnit.config.autostart = false;\n}\n\n// Get a reference to the global object, like window in browsers\n}( ( function() {\n\treturn this;\n}() ) ) );\n\n( function() {\n\n// Only interact with URLs via window.location\nvar location = typeof window !== "undefined" && window.location;\nif ( !location ) {\n\treturn;\n}\n\nvar urlParams = getUrlParams();\n\nQUnit.urlParams = urlParams;\n\n// Match module/test by inclusion in an array\nQUnit.config.moduleId = [].concat( urlParams.moduleId || [] );\nQUnit.config.testId = [].concat( urlParams.testId || [] );\n\n// Exact case-insensitive match of the module name\nQUnit.config.module = urlParams.module;\n\n// Regular expression or case-insenstive substring match against "moduleName: testName"\nQUnit.config.filter = urlParams.filter;\n\n// Test order randomization\nif ( urlParams.seed === true ) {\n\n\t// Generate a random seed if the option is specified without a value\n\tQUnit.config.seed = Math.random().toString( 36 ).slice( 2 );\n} else if ( urlParams.seed ) {\n\tQUnit.config.seed = urlParams.seed;\n}\n\n// Add URL-parameter-mapped config values with UI form rendering data\nQUnit.config.urlConfig.push(\n\t{\n\t\tid: "hidepassed",\n\t\tlabel: "Hide passed tests",\n\t\ttooltip: "Only show tests and assertions that fail. Stored as query-strings."\n\t},\n\t{\n\t\tid: "noglobals",\n\t\tlabel: "Check for Globals",\n\t\ttooltip: "Enabling this will test if any test introduces new properties on the " +\n\t\t\t"global object (`window` in Browsers). Stored as query-strings."\n\t},\n\t{\n\t\tid: "notrycatch",\n\t\tlabel: "No try-catch",\n\t\ttooltip: "Enabling this will run tests outside of a try-catch block. Makes debugging " +\n\t\t\t"exceptions in IE reasonable. Stored as query-strings."\n\t}\n);\n\nQUnit.begin( function() {\n\tvar i, option,\n\t\turlConfig = QUnit.config.urlConfig;\n\n\tfor ( i = 0; i < urlConfig.length; i++ ) {\n\n\t\t// Options can be either strings or objects with nonempty "id" properties\n\t\toption = QUnit.config.urlConfig[ i ];\n\t\tif ( typeof option !== "string" ) {\n\t\t\toption = option.id;\n\t\t}\n\n\t\tif ( QUnit.config[ option ] === undefined ) {\n\t\t\tQUnit.config[ option ] = urlParams[ option ];\n\t\t}\n\t}\n} );\n\nfunction getUrlParams() {\n\tvar i, param, name, value;\n\tvar urlParams = {};\n\tvar params = location.search.slice( 1 ).split( "&" );\n\tvar length = params.length;\n\n\tfor ( i = 0; i < length; i++ ) {\n\t\tif ( params[ i ] ) {\n\t\t\tparam = params[ i ].split( "=" );\n\t\t\tname = decodeURIComponent( param[ 0 ] );\n\n\t\t\t// Allow just a key to turn on a flag, e.g., test.html?noglobals\n\t\t\tvalue = param.length === 1 ||\n\t\t\t\tdecodeURIComponent( param.slice( 1 ).join( "=" ) ) ;\n\t\t\tif ( urlParams[ name ] ) {\n\t\t\t\turlParams[ name ] = [].concat( urlParams[ name ], value );\n\t\t\t} else {\n\t\t\t\turlParams[ name ] = value;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn urlParams;\n}\n\n// Don\'t load the HTML Reporter on non-browser environments\nif ( typeof window === "undefined" || !window.document ) {\n\treturn;\n}\n\n// Deprecated QUnit.init - Ref #530\n// Re-initialize the configuration options\nQUnit.init = function() {\n\tvar config = QUnit.config;\n\n\tconfig.stats = { all: 0, bad: 0 };\n\tconfig.moduleStats = { all: 0, bad: 0 };\n\tconfig.started = 0;\n\tconfig.updateRate = 1000;\n\tconfig.blocking = false;\n\tconfig.autostart = true;\n\tconfig.autorun = false;\n\tconfig.filter = "";\n\tconfig.queue = [];\n\n\tappendInterface();\n};\n\nvar config = QUnit.config,\n\tdocument = window.document,\n\tcollapseNext = false,\n\thasOwn = Object.prototype.hasOwnProperty,\n\tunfilteredUrl = setUrl( { filter: undefined, module: undefined,\n\t\tmoduleId: undefined, testId: undefined } ),\n\tdefined = {\n\t\tsessionStorage: ( function() {\n\t\t\tvar x = "qunit-test-string";\n\t\t\ttry {\n\t\t\t\tsessionStorage.setItem( x, x );\n\t\t\t\tsessionStorage.removeItem( x );\n\t\t\t\treturn true;\n\t\t\t} catch ( e ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}() )\n\t},\n\tmodulesList = [];\n\n/**\n* Escape text for attribute or text content.\n*/\nfunction escapeText( s ) {\n\tif ( !s ) {\n\t\treturn "";\n\t}\n\ts = s + "";\n\n\t// Both single quotes and double quotes (for attributes)\n\treturn s.replace( /[\'"<>&]/g, function( s ) {\n\t\tswitch ( s ) {\n\t\tcase "\'":\n\t\t\treturn "&#039;";\n\t\tcase "\\"":\n\t\t\treturn "&quot;";\n\t\tcase "<":\n\t\t\treturn "&lt;";\n\t\tcase ">":\n\t\t\treturn "&gt;";\n\t\tcase "&":\n\t\t\treturn "&amp;";\n\t\t}\n\t} );\n}\n\n/**\n * @param {HTMLElement} elem\n * @param {string} type\n * @param {Function} fn\n */\nfunction addEvent( elem, type, fn ) {\n\tif ( elem.addEventListener ) {\n\n\t\t// Standards-based browsers\n\t\telem.addEventListener( type, fn, false );\n\t} else if ( elem.attachEvent ) {\n\n\t\t// Support: IE <9\n\t\telem.attachEvent( "on" + type, function() {\n\t\t\tvar event = window.event;\n\t\t\tif ( !event.target ) {\n\t\t\t\tevent.target = event.srcElement || document;\n\t\t\t}\n\n\t\t\tfn.call( elem, event );\n\t\t} );\n\t}\n}\n\n/**\n * @param {Array|NodeList} elems\n * @param {string} type\n * @param {Function} fn\n */\nfunction addEvents( elems, type, fn ) {\n\tvar i = elems.length;\n\twhile ( i-- ) {\n\t\taddEvent( elems[ i ], type, fn );\n\t}\n}\n\nfunction hasClass( elem, name ) {\n\treturn ( " " + elem.className + " " ).indexOf( " " + name + " " ) >= 0;\n}\n\nfunction addClass( elem, name ) {\n\tif ( !hasClass( elem, name ) ) {\n\t\telem.className += ( elem.className ? " " : "" ) + name;\n\t}\n}\n\nfunction toggleClass( elem, name, force ) {\n\tif ( force || typeof force === "undefined" && !hasClass( elem, name ) ) {\n\t\taddClass( elem, name );\n\t} else {\n\t\tremoveClass( elem, name );\n\t}\n}\n\nfunction removeClass( elem, name ) {\n\tvar set = " " + elem.className + " ";\n\n\t// Class name may appear multiple times\n\twhile ( set.indexOf( " " + name + " " ) >= 0 ) {\n\t\tset = set.replace( " " + name + " ", " " );\n\t}\n\n\t// Trim for prettiness\n\telem.className = typeof set.trim === "function" ? set.trim() : set.replace( /^\\s+|\\s+$/g, "" );\n}\n\nfunction id( name ) {\n\treturn document.getElementById && document.getElementById( name );\n}\n\nfunction getUrlConfigHtml() {\n\tvar i, j, val,\n\t\tescaped, escapedTooltip,\n\t\tselection = false,\n\t\turlConfig = config.urlConfig,\n\t\turlConfigHtml = "";\n\n\tfor ( i = 0; i < urlConfig.length; i++ ) {\n\n\t\t// Options can be either strings or objects with nonempty "id" properties\n\t\tval = config.urlConfig[ i ];\n\t\tif ( typeof val === "string" ) {\n\t\t\tval = {\n\t\t\t\tid: val,\n\t\t\t\tlabel: val\n\t\t\t};\n\t\t}\n\n\t\tescaped = escapeText( val.id );\n\t\tescapedTooltip = escapeText( val.tooltip );\n\n\t\tif ( !val.value || typeof val.value === "string" ) {\n\t\t\turlConfigHtml += "<input id=\'qunit-urlconfig-" + escaped +\n\t\t\t\t"\' name=\'" + escaped + "\' type=\'checkbox\'" +\n\t\t\t\t( val.value ? " value=\'" + escapeText( val.value ) + "\'" : "" ) +\n\t\t\t\t( config[ val.id ] ? " checked=\'checked\'" : "" ) +\n\t\t\t\t" title=\'" + escapedTooltip + "\' /><label for=\'qunit-urlconfig-" + escaped +\n\t\t\t\t"\' title=\'" + escapedTooltip + "\'>" + val.label + "</label>";\n\t\t} else {\n\t\t\turlConfigHtml += "<label for=\'qunit-urlconfig-" + escaped +\n\t\t\t\t"\' title=\'" + escapedTooltip + "\'>" + val.label +\n\t\t\t\t": </label><select id=\'qunit-urlconfig-" + escaped +\n\t\t\t\t"\' name=\'" + escaped + "\' title=\'" + escapedTooltip + "\'><option></option>";\n\n\t\t\tif ( QUnit.is( "array", val.value ) ) {\n\t\t\t\tfor ( j = 0; j < val.value.length; j++ ) {\n\t\t\t\t\tescaped = escapeText( val.value[ j ] );\n\t\t\t\t\turlConfigHtml += "<option value=\'" + escaped + "\'" +\n\t\t\t\t\t\t( config[ val.id ] === val.value[ j ] ?\n\t\t\t\t\t\t\t( selection = true ) && " selected=\'selected\'" : "" ) +\n\t\t\t\t\t\t">" + escaped + "</option>";\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor ( j in val.value ) {\n\t\t\t\t\tif ( hasOwn.call( val.value, j ) ) {\n\t\t\t\t\t\turlConfigHtml += "<option value=\'" + escapeText( j ) + "\'" +\n\t\t\t\t\t\t\t( config[ val.id ] === j ?\n\t\t\t\t\t\t\t\t( selection = true ) && " selected=\'selected\'" : "" ) +\n\t\t\t\t\t\t\t">" + escapeText( val.value[ j ] ) + "</option>";\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ( config[ val.id ] && !selection ) {\n\t\t\t\tescaped = escapeText( config[ val.id ] );\n\t\t\t\turlConfigHtml += "<option value=\'" + escaped +\n\t\t\t\t\t"\' selected=\'selected\' disabled=\'disabled\'>" + escaped + "</option>";\n\t\t\t}\n\t\t\turlConfigHtml += "</select>";\n\t\t}\n\t}\n\n\treturn urlConfigHtml;\n}\n\n// Handle "click" events on toolbar checkboxes and "change" for select menus.\n// Updates the URL with the new state of `config.urlConfig` values.\nfunction toolbarChanged() {\n\tvar updatedUrl, value, tests,\n\t\tfield = this,\n\t\tparams = {};\n\n\t// Detect if field is a select menu or a checkbox\n\tif ( "selectedIndex" in field ) {\n\t\tvalue = field.options[ field.selectedIndex ].value || undefined;\n\t} else {\n\t\tvalue = field.checked ? ( field.defaultValue || true ) : undefined;\n\t}\n\n\tparams[ field.name ] = value;\n\tupdatedUrl = setUrl( params );\n\n\t// Check if we can apply the change without a page refresh\n\tif ( "hidepassed" === field.name && "replaceState" in window.history ) {\n\t\tQUnit.urlParams[ field.name ] = value;\n\t\tconfig[ field.name ] = value || false;\n\t\ttests = id( "qunit-tests" );\n\t\tif ( tests ) {\n\t\t\ttoggleClass( tests, "hidepass", value || false );\n\t\t}\n\t\twindow.history.replaceState( null, "", updatedUrl );\n\t} else {\n\t\twindow.location = updatedUrl;\n\t}\n}\n\nfunction setUrl( params ) {\n\tvar key, arrValue, i,\n\t\tquerystring = "?",\n\t\tlocation = window.location;\n\n\tparams = QUnit.extend( QUnit.extend( {}, QUnit.urlParams ), params );\n\n\tfor ( key in params ) {\n\n\t\t// Skip inherited or undefined properties\n\t\tif ( hasOwn.call( params, key ) && params[ key ] !== undefined ) {\n\n\t\t\t// Output a parameter for each value of this key (but usually just one)\n\t\t\tarrValue = [].concat( params[ key ] );\n\t\t\tfor ( i = 0; i < arrValue.length; i++ ) {\n\t\t\t\tquerystring += encodeURIComponent( key );\n\t\t\t\tif ( arrValue[ i ] !== true ) {\n\t\t\t\t\tquerystring += "=" + encodeURIComponent( arrValue[ i ] );\n\t\t\t\t}\n\t\t\t\tquerystring += "&";\n\t\t\t}\n\t\t}\n\t}\n\treturn location.protocol + "//" + location.host +\n\t\tlocation.pathname + querystring.slice( 0, -1 );\n}\n\nfunction applyUrlParams() {\n\tvar selectedModule,\n\t\tmodulesList = id( "qunit-modulefilter" ),\n\t\tfilter = id( "qunit-filter-input" ).value;\n\n\tselectedModule = modulesList ?\n\t\tdecodeURIComponent( modulesList.options[ modulesList.selectedIndex ].value ) :\n\t\tundefined;\n\n\twindow.location = setUrl( {\n\t\tmodule: ( selectedModule === "" ) ? undefined : selectedModule,\n\t\tfilter: ( filter === "" ) ? undefined : filter,\n\n\t\t// Remove moduleId and testId filters\n\t\tmoduleId: undefined,\n\t\ttestId: undefined\n\t} );\n}\n\nfunction toolbarUrlConfigContainer() {\n\tvar urlConfigContainer = document.createElement( "span" );\n\n\turlConfigContainer.innerHTML = getUrlConfigHtml();\n\taddClass( urlConfigContainer, "qunit-url-config" );\n\n\t// For oldIE support:\n\t// * Add handlers to the individual elements instead of the container\n\t// * Use "click" instead of "change" for checkboxes\n\taddEvents( urlConfigContainer.getElementsByTagName( "input" ), "click", toolbarChanged );\n\taddEvents( urlConfigContainer.getElementsByTagName( "select" ), "change", toolbarChanged );\n\n\treturn urlConfigContainer;\n}\n\nfunction toolbarLooseFilter() {\n\tvar filter = document.createElement( "form" ),\n\t\tlabel = document.createElement( "label" ),\n\t\tinput = document.createElement( "input" ),\n\t\tbutton = document.createElement( "button" );\n\n\taddClass( filter, "qunit-filter" );\n\n\tlabel.innerHTML = "Filter: ";\n\n\tinput.type = "text";\n\tinput.value = config.filter || "";\n\tinput.name = "filter";\n\tinput.id = "qunit-filter-input";\n\n\tbutton.innerHTML = "Go";\n\n\tlabel.appendChild( input );\n\n\tfilter.appendChild( label );\n\tfilter.appendChild( button );\n\taddEvent( filter, "submit", function( ev ) {\n\t\tapplyUrlParams();\n\n\t\tif ( ev && ev.preventDefault ) {\n\t\t\tev.preventDefault();\n\t\t}\n\n\t\treturn false;\n\t} );\n\n\treturn filter;\n}\n\nfunction toolbarModuleFilterHtml() {\n\tvar i,\n\t\tmoduleFilterHtml = "";\n\n\tif ( !modulesList.length ) {\n\t\treturn false;\n\t}\n\n\tmoduleFilterHtml += "<label for=\'qunit-modulefilter\'>Module: </label>" +\n\t\t"<select id=\'qunit-modulefilter\' name=\'modulefilter\'><option value=\'\' " +\n\t\t( QUnit.urlParams.module === undefined ? "selected=\'selected\'" : "" ) +\n\t\t">< All Modules ></option>";\n\n\tfor ( i = 0; i < modulesList.length; i++ ) {\n\t\tmoduleFilterHtml += "<option value=\'" +\n\t\t\tescapeText( encodeURIComponent( modulesList[ i ] ) ) + "\' " +\n\t\t\t( QUnit.urlParams.module === modulesList[ i ] ? "selected=\'selected\'" : "" ) +\n\t\t\t">" + escapeText( modulesList[ i ] ) + "</option>";\n\t}\n\tmoduleFilterHtml += "</select>";\n\n\treturn moduleFilterHtml;\n}\n\nfunction toolbarModuleFilter() {\n\tvar toolbar = id( "qunit-testrunner-toolbar" ),\n\t\tmoduleFilter = document.createElement( "span" ),\n\t\tmoduleFilterHtml = toolbarModuleFilterHtml();\n\n\tif ( !toolbar || !moduleFilterHtml ) {\n\t\treturn false;\n\t}\n\n\tmoduleFilter.setAttribute( "id", "qunit-modulefilter-container" );\n\tmoduleFilter.innerHTML = moduleFilterHtml;\n\n\taddEvent( moduleFilter.lastChild, "change", applyUrlParams );\n\n\ttoolbar.appendChild( moduleFilter );\n}\n\nfunction appendToolbar() {\n\tvar toolbar = id( "qunit-testrunner-toolbar" );\n\n\tif ( toolbar ) {\n\t\ttoolbar.appendChild( toolbarUrlConfigContainer() );\n\t\ttoolbar.appendChild( toolbarLooseFilter() );\n\t\ttoolbarModuleFilter();\n\t}\n}\n\nfunction appendHeader() {\n\tvar header = id( "qunit-header" );\n\n\tif ( header ) {\n\t\theader.innerHTML = "<a href=\'" + escapeText( unfilteredUrl ) + "\'>" + header.innerHTML +\n\t\t\t"</a> ";\n\t}\n}\n\nfunction appendBanner() {\n\tvar banner = id( "qunit-banner" );\n\n\tif ( banner ) {\n\t\tbanner.className = "";\n\t}\n}\n\nfunction appendTestResults() {\n\tvar tests = id( "qunit-tests" ),\n\t\tresult = id( "qunit-testresult" );\n\n\tif ( result ) {\n\t\tresult.parentNode.removeChild( result );\n\t}\n\n\tif ( tests ) {\n\t\ttests.innerHTML = "";\n\t\tresult = document.createElement( "p" );\n\t\tresult.id = "qunit-testresult";\n\t\tresult.className = "result";\n\t\ttests.parentNode.insertBefore( result, tests );\n\t\tresult.innerHTML = "Running...<br />&#160;";\n\t}\n}\n\nfunction storeFixture() {\n\tvar fixture = id( "qunit-fixture" );\n\tif ( fixture ) {\n\t\tconfig.fixture = fixture.innerHTML;\n\t}\n}\n\nfunction appendFilteredTest() {\n\tvar testId = QUnit.config.testId;\n\tif ( !testId || testId.length <= 0 ) {\n\t\treturn "";\n\t}\n\treturn "<div id=\'qunit-filteredTest\'>Rerunning selected tests: " +\n\t\tescapeText( testId.join( ", " ) ) +\n\t\t" <a id=\'qunit-clearFilter\' href=\'" +\n\t\tescapeText( unfilteredUrl ) +\n\t\t"\'>Run all tests</a></div>";\n}\n\nfunction appendUserAgent() {\n\tvar userAgent = id( "qunit-userAgent" );\n\n\tif ( userAgent ) {\n\t\tuserAgent.innerHTML = "";\n\t\tuserAgent.appendChild(\n\t\t\tdocument.createTextNode(\n\t\t\t\t"QUnit " + QUnit.version + "; " + navigator.userAgent\n\t\t\t)\n\t\t);\n\t}\n}\n\nfunction appendInterface() {\n\tvar qunit = id( "qunit" );\n\n\tif ( qunit ) {\n\t\tqunit.innerHTML =\n\t\t\t"<h1 id=\'qunit-header\'>" + escapeText( document.title ) + "</h1>" +\n\t\t\t"<h2 id=\'qunit-banner\'></h2>" +\n\t\t\t"<div id=\'qunit-testrunner-toolbar\'></div>" +\n\t\t\tappendFilteredTest() +\n\t\t\t"<h2 id=\'qunit-userAgent\'></h2>" +\n\t\t\t"<ol id=\'qunit-tests\'></ol>";\n\t}\n\n\tappendHeader();\n\tappendBanner();\n\tappendTestResults();\n\tappendUserAgent();\n\tappendToolbar();\n}\n\nfunction appendTestsList( modules ) {\n\tvar i, l, x, z, test, moduleObj;\n\n\tfor ( i = 0, l = modules.length; i < l; i++ ) {\n\t\tmoduleObj = modules[ i ];\n\n\t\tfor ( x = 0, z = moduleObj.tests.length; x < z; x++ ) {\n\t\t\ttest = moduleObj.tests[ x ];\n\n\t\t\tappendTest( test.name, test.testId, moduleObj.name );\n\t\t}\n\t}\n}\n\nfunction appendTest( name, testId, moduleName ) {\n\tvar title, rerunTrigger, testBlock, assertList,\n\t\ttests = id( "qunit-tests" );\n\n\tif ( !tests ) {\n\t\treturn;\n\t}\n\n\ttitle = document.createElement( "strong" );\n\ttitle.innerHTML = getNameHtml( name, moduleName );\n\n\trerunTrigger = document.createElement( "a" );\n\trerunTrigger.innerHTML = "Rerun";\n\trerunTrigger.href = setUrl( { testId: testId } );\n\n\ttestBlock = document.createElement( "li" );\n\ttestBlock.appendChild( title );\n\ttestBlock.appendChild( rerunTrigger );\n\ttestBlock.id = "qunit-test-output-" + testId;\n\n\tassertList = document.createElement( "ol" );\n\tassertList.className = "qunit-assert-list";\n\n\ttestBlock.appendChild( assertList );\n\n\ttests.appendChild( testBlock );\n}\n\n// HTML Reporter initialization and load\nQUnit.begin( function( details ) {\n\tvar i, moduleObj, tests;\n\n\t// Sort modules by name for the picker\n\tfor ( i = 0; i < details.modules.length; i++ ) {\n\t\tmoduleObj = details.modules[ i ];\n\t\tif ( moduleObj.name ) {\n\t\t\tmodulesList.push( moduleObj.name );\n\t\t}\n\t}\n\tmodulesList.sort( function( a, b ) {\n\t\treturn a.localeCompare( b );\n\t} );\n\n\t// Capture fixture HTML from the page\n\tstoreFixture();\n\n\t// Initialize QUnit elements\n\tappendInterface();\n\tappendTestsList( details.modules );\n\ttests = id( "qunit-tests" );\n\tif ( tests && config.hidepassed ) {\n\t\taddClass( tests, "hidepass" );\n\t}\n} );\n\nQUnit.done( function( details ) {\n\tvar i, key,\n\t\tbanner = id( "qunit-banner" ),\n\t\ttests = id( "qunit-tests" ),\n\t\thtml = [\n\t\t\t"Tests completed in ",\n\t\t\tdetails.runtime,\n\t\t\t" milliseconds.<br />",\n\t\t\t"<span class=\'passed\'>",\n\t\t\tdetails.passed,\n\t\t\t"</span> assertions of <span class=\'total\'>",\n\t\t\tdetails.total,\n\t\t\t"</span> passed, <span class=\'failed\'>",\n\t\t\tdetails.failed,\n\t\t\t"</span> failed."\n\t\t].join( "" );\n\n\tif ( banner ) {\n\t\tbanner.className = details.failed ? "qunit-fail" : "qunit-pass";\n\t}\n\n\tif ( tests ) {\n\t\tid( "qunit-testresult" ).innerHTML = html;\n\t}\n\n\tif ( config.altertitle && document.title ) {\n\n\t\t// Show \u2716 for good, \u2714 for bad suite result in title\n\t\t// use escape sequences in case file gets loaded with non-utf-8-charset\n\t\tdocument.title = [\n\t\t\t( details.failed ? "\\u2716" : "\\u2714" ),\n\t\t\tdocument.title.replace( /^[\\u2714\\u2716] /i, "" )\n\t\t].join( " " );\n\t}\n\n\t// Clear own sessionStorage items if all tests passed\n\tif ( config.reorder && defined.sessionStorage && details.failed === 0 ) {\n\t\tfor ( i = 0; i < sessionStorage.length; i++ ) {\n\t\t\tkey = sessionStorage.key( i++ );\n\t\t\tif ( key.indexOf( "qunit-test-" ) === 0 ) {\n\t\t\t\tsessionStorage.removeItem( key );\n\t\t\t}\n\t\t}\n\t}\n\n\t// Scroll back to top to show results\n\tif ( config.scrolltop && window.scrollTo ) {\n\t\twindow.scrollTo( 0, 0 );\n\t}\n} );\n\nfunction getNameHtml( name, module ) {\n\tvar nameHtml = "";\n\n\tif ( module ) {\n\t\tnameHtml = "<span class=\'module-name\'>" + escapeText( module ) + "</span>: ";\n\t}\n\n\tnameHtml += "<span class=\'test-name\'>" + escapeText( name ) + "</span>";\n\n\treturn nameHtml;\n}\n\nQUnit.testStart( function( details ) {\n\tvar running, testBlock, bad;\n\n\ttestBlock = id( "qunit-test-output-" + details.testId );\n\tif ( testBlock ) {\n\t\ttestBlock.className = "running";\n\t} else {\n\n\t\t// Report later registered tests\n\t\tappendTest( details.name, details.testId, details.module );\n\t}\n\n\trunning = id( "qunit-testresult" );\n\tif ( running ) {\n\t\tbad = QUnit.config.reorder && defined.sessionStorage &&\n\t\t\t+sessionStorage.getItem( "qunit-test-" + details.module + "-" + details.name );\n\n\t\trunning.innerHTML = ( bad ?\n\t\t\t"Rerunning previously failed test: <br />" :\n\t\t\t"Running: <br />" ) +\n\t\t\tgetNameHtml( details.name, details.module );\n\t}\n\n} );\n\nfunction stripHtml( string ) {\n\n\t// Strip tags, html entity and whitespaces\n\treturn string.replace( /<\\/?[^>]+(>|$)/g, "" ).replace( /\\&quot;/g, "" ).replace( /\\s+/g, "" );\n}\n\nQUnit.log( function( details ) {\n\tvar assertList, assertLi,\n\t\tmessage, expected, actual, diff,\n\t\tshowDiff = false,\n\t\ttestItem = id( "qunit-test-output-" + details.testId );\n\n\tif ( !testItem ) {\n\t\treturn;\n\t}\n\n\tmessage = escapeText( details.message ) || ( details.result ? "okay" : "failed" );\n\tmessage = "<span class=\'test-message\'>" + message + "</span>";\n\tmessage += "<span class=\'runtime\'>@ " + details.runtime + " ms</span>";\n\n\t// The pushFailure doesn\'t provide details.expected\n\t// when it calls, it\'s implicit to also not show expected and diff stuff\n\t// Also, we need to check details.expected existence, as it can exist and be undefined\n\tif ( !details.result && hasOwn.call( details, "expected" ) ) {\n\t\tif ( details.negative ) {\n\t\t\texpected = "NOT " + QUnit.dump.parse( details.expected );\n\t\t} else {\n\t\t\texpected = QUnit.dump.parse( details.expected );\n\t\t}\n\n\t\tactual = QUnit.dump.parse( details.actual );\n\t\tmessage += "<table><tr class=\'test-expected\'><th>Expected: </th><td><pre>" +\n\t\t\tescapeText( expected ) +\n\t\t\t"</pre></td></tr>";\n\n\t\tif ( actual !== expected ) {\n\n\t\t\tmessage += "<tr class=\'test-actual\'><th>Result: </th><td><pre>" +\n\t\t\t\tescapeText( actual ) + "</pre></td></tr>";\n\n\t\t\t// Don\'t show diff if actual or expected are booleans\n\t\t\tif ( !( /^(true|false)$/.test( actual ) ) &&\n\t\t\t\t\t!( /^(true|false)$/.test( expected ) ) ) {\n\t\t\t\tdiff = QUnit.diff( expected, actual );\n\t\t\t\tshowDiff = stripHtml( diff ).length !==\n\t\t\t\t\tstripHtml( expected ).length +\n\t\t\t\t\tstripHtml( actual ).length;\n\t\t\t}\n\n\t\t\t// Don\'t show diff if expected and actual are totally different\n\t\t\tif ( showDiff ) {\n\t\t\t\tmessage += "<tr class=\'test-diff\'><th>Diff: </th><td><pre>" +\n\t\t\t\t\tdiff + "</pre></td></tr>";\n\t\t\t}\n\t\t} else if ( expected.indexOf( "[object Array]" ) !== -1 ||\n\t\t\t\texpected.indexOf( "[object Object]" ) !== -1 ) {\n\t\t\tmessage += "<tr class=\'test-message\'><th>Message: </th><td>" +\n\t\t\t\t"Diff suppressed as the depth of object is more than current max depth (" +\n\t\t\t\tQUnit.config.maxDepth + ").<p>Hint: Use <code>QUnit.dump.maxDepth</code> to " +\n\t\t\t\t" run with a higher max depth or <a href=\'" +\n\t\t\t\tescapeText( setUrl( { maxDepth: -1 } ) ) + "\'>" +\n\t\t\t\t"Rerun</a> without max depth.</p></td></tr>";\n\t\t} else {\n\t\t\tmessage += "<tr class=\'test-message\'><th>Message: </th><td>" +\n\t\t\t\t"Diff suppressed as the expected and actual results have an equivalent" +\n\t\t\t\t" serialization</td></tr>";\n\t\t}\n\n\t\tif ( details.source ) {\n\t\t\tmessage += "<tr class=\'test-source\'><th>Source: </th><td><pre>" +\n\t\t\t\tescapeText( details.source ) + "</pre></td></tr>";\n\t\t}\n\n\t\tmessage += "</table>";\n\n\t// This occurs when pushFailure is set and we have an extracted stack trace\n\t} else if ( !details.result && details.source ) {\n\t\tmessage += "<table>" +\n\t\t\t"<tr class=\'test-source\'><th>Source: </th><td><pre>" +\n\t\t\tescapeText( details.source ) + "</pre></td></tr>" +\n\t\t\t"</table>";\n\t}\n\n\tassertList = testItem.getElementsByTagName( "ol" )[ 0 ];\n\n\tassertLi = document.createElement( "li" );\n\tassertLi.className = details.result ? "pass" : "fail";\n\tassertLi.innerHTML = message;\n\tassertList.appendChild( assertLi );\n} );\n\nQUnit.testDone( function( details ) {\n\tvar testTitle, time, testItem, assertList,\n\t\tgood, bad, testCounts, skipped, sourceName,\n\t\ttests = id( "qunit-tests" );\n\n\tif ( !tests ) {\n\t\treturn;\n\t}\n\n\ttestItem = id( "qunit-test-output-" + details.testId );\n\n\tassertList = testItem.getElementsByTagName( "ol" )[ 0 ];\n\n\tgood = details.passed;\n\tbad = details.failed;\n\n\t// Store result when possible\n\tif ( config.reorder && defined.sessionStorage ) {\n\t\tif ( bad ) {\n\t\t\tsessionStorage.setItem( "qunit-test-" + details.module + "-" + details.name, bad );\n\t\t} else {\n\t\t\tsessionStorage.removeItem( "qunit-test-" + details.module + "-" + details.name );\n\t\t}\n\t}\n\n\tif ( bad === 0 ) {\n\n\t\t// Collapse the passing tests\n\t\taddClass( assertList, "qunit-collapsed" );\n\t} else if ( bad && config.collapse && !collapseNext ) {\n\n\t\t// Skip collapsing the first failing test\n\t\tcollapseNext = true;\n\t} else {\n\n\t\t// Collapse remaining tests\n\t\taddClass( assertList, "qunit-collapsed" );\n\t}\n\n\t// The testItem.firstChild is the test name\n\ttestTitle = testItem.firstChild;\n\n\ttestCounts = bad ?\n\t\t"<b class=\'failed\'>" + bad + "</b>, " + "<b class=\'passed\'>" + good + "</b>, " :\n\t\t"";\n\n\ttestTitle.innerHTML += " <b class=\'counts\'>(" + testCounts +\n\t\tdetails.assertions.length + ")</b>";\n\n\tif ( details.skipped ) {\n\t\ttestItem.className = "skipped";\n\t\tskipped = document.createElement( "em" );\n\t\tskipped.className = "qunit-skipped-label";\n\t\tskipped.innerHTML = "skipped";\n\t\ttestItem.insertBefore( skipped, testTitle );\n\t} else {\n\t\taddEvent( testTitle, "click", function() {\n\t\t\ttoggleClass( assertList, "qunit-collapsed" );\n\t\t} );\n\n\t\ttestItem.className = bad ? "fail" : "pass";\n\n\t\ttime = document.createElement( "span" );\n\t\ttime.className = "runtime";\n\t\ttime.innerHTML = details.runtime + " ms";\n\t\ttestItem.insertBefore( time, assertList );\n\t}\n\n\t// Show the source of the test when showing assertions\n\tif ( details.source ) {\n\t\tsourceName = document.createElement( "p" );\n\t\tsourceName.innerHTML = "<strong>Source: </strong>" + details.source;\n\t\taddClass( sourceName, "qunit-source" );\n\t\tif ( bad === 0 ) {\n\t\t\taddClass( sourceName, "qunit-collapsed" );\n\t\t}\n\t\taddEvent( testTitle, "click", function() {\n\t\t\ttoggleClass( sourceName, "qunit-collapsed" );\n\t\t} );\n\t\ttestItem.appendChild( sourceName );\n\t}\n} );\n\n// Avoid readyState issue with phantomjs\n// Ref: #818\nvar notPhantom = ( function( p ) {\n\treturn !( p && p.version && p.version.major > 0 );\n} )( window.phantom );\n\nif ( notPhantom && document.readyState === "complete" ) {\n\tQUnit.load();\n} else {\n\taddEvent( window, "load", QUnit.load );\n}\n\n/*\n * This file is a modified version of google-diff-match-patch\'s JavaScript implementation\n * (https://code.google.com/p/google-diff-match-patch/source/browse/trunk/javascript/diff_match_patch_uncompressed.js),\n * modifications are licensed as more fully set forth in LICENSE.txt.\n *\n * The original source of google-diff-match-patch is attributable and licensed as follows:\n *\n * Copyright 2006 Google Inc.\n * https://code.google.com/p/google-diff-match-patch/\n *\n * Licensed under the Apache License, Version 2.0 (the "License");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an "AS IS" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * More Info:\n *  https://code.google.com/p/google-diff-match-patch/\n *\n * Usage: QUnit.diff(expected, actual)\n *\n */\nQUnit.diff = ( function() {\n\tfunction DiffMatchPatch() {\n\t}\n\n\t//  DIFF FUNCTIONS\n\n\t/**\n\t * The data structure representing a diff is an array of tuples:\n\t * [[DIFF_DELETE, \'Hello\'], [DIFF_INSERT, \'Goodbye\'], [DIFF_EQUAL, \' world.\']]\n\t * which means: delete \'Hello\', add \'Goodbye\' and keep \' world.\'\n\t */\n\tvar DIFF_DELETE = -1,\n\t\tDIFF_INSERT = 1,\n\t\tDIFF_EQUAL = 0;\n\n\t/**\n\t * Find the differences between two texts.  Simplifies the problem by stripping\n\t * any common prefix or suffix off the texts before diffing.\n\t * @param {string} text1 Old string to be diffed.\n\t * @param {string} text2 New string to be diffed.\n\t * @param {boolean=} optChecklines Optional speedup flag. If present and false,\n\t *     then don\'t run a line-level diff first to identify the changed areas.\n\t *     Defaults to true, which does a faster, slightly less optimal diff.\n\t * @return {!Array.<!DiffMatchPatch.Diff>} Array of diff tuples.\n\t */\n\tDiffMatchPatch.prototype.DiffMain = function( text1, text2, optChecklines ) {\n\t\tvar deadline, checklines, commonlength,\n\t\t\tcommonprefix, commonsuffix, diffs;\n\n\t\t// The diff must be complete in up to 1 second.\n\t\tdeadline = ( new Date() ).getTime() + 1000;\n\n\t\t// Check for null inputs.\n\t\tif ( text1 === null || text2 === null ) {\n\t\t\tthrow new Error( "Null input. (DiffMain)" );\n\t\t}\n\n\t\t// Check for equality (speedup).\n\t\tif ( text1 === text2 ) {\n\t\t\tif ( text1 ) {\n\t\t\t\treturn [\n\t\t\t\t\t[ DIFF_EQUAL, text1 ]\n\t\t\t\t];\n\t\t\t}\n\t\t\treturn [];\n\t\t}\n\n\t\tif ( typeof optChecklines === "undefined" ) {\n\t\t\toptChecklines = true;\n\t\t}\n\n\t\tchecklines = optChecklines;\n\n\t\t// Trim off common prefix (speedup).\n\t\tcommonlength = this.diffCommonPrefix( text1, text2 );\n\t\tcommonprefix = text1.substring( 0, commonlength );\n\t\ttext1 = text1.substring( commonlength );\n\t\ttext2 = text2.substring( commonlength );\n\n\t\t// Trim off common suffix (speedup).\n\t\tcommonlength = this.diffCommonSuffix( text1, text2 );\n\t\tcommonsuffix = text1.substring( text1.length - commonlength );\n\t\ttext1 = text1.substring( 0, text1.length - commonlength );\n\t\ttext2 = text2.substring( 0, text2.length - commonlength );\n\n\t\t// Compute the diff on the middle block.\n\t\tdiffs = this.diffCompute( text1, text2, checklines, deadline );\n\n\t\t// Restore the prefix and suffix.\n\t\tif ( commonprefix ) {\n\t\t\tdiffs.unshift( [ DIFF_EQUAL, commonprefix ] );\n\t\t}\n\t\tif ( commonsuffix ) {\n\t\t\tdiffs.push( [ DIFF_EQUAL, commonsuffix ] );\n\t\t}\n\t\tthis.diffCleanupMerge( diffs );\n\t\treturn diffs;\n\t};\n\n\t/**\n\t * Reduce the number of edits by eliminating operationally trivial equalities.\n\t * @param {!Array.<!DiffMatchPatch.Diff>} diffs Array of diff tuples.\n\t */\n\tDiffMatchPatch.prototype.diffCleanupEfficiency = function( diffs ) {\n\t\tvar changes, equalities, equalitiesLength, lastequality,\n\t\t\tpointer, preIns, preDel, postIns, postDel;\n\t\tchanges = false;\n\t\tequalities = []; // Stack of indices where equalities are found.\n\t\tequalitiesLength = 0; // Keeping our own length var is faster in JS.\n\t\t/** @type {?string} */\n\t\tlastequality = null;\n\n\t\t// Always equal to diffs[equalities[equalitiesLength - 1]][1]\n\t\tpointer = 0; // Index of current position.\n\n\t\t// Is there an insertion operation before the last equality.\n\t\tpreIns = false;\n\n\t\t// Is there a deletion operation before the last equality.\n\t\tpreDel = false;\n\n\t\t// Is there an insertion operation after the last equality.\n\t\tpostIns = false;\n\n\t\t// Is there a deletion operation after the last equality.\n\t\tpostDel = false;\n\t\twhile ( pointer < diffs.length ) {\n\n\t\t\t// Equality found.\n\t\t\tif ( diffs[ pointer ][ 0 ] === DIFF_EQUAL ) {\n\t\t\t\tif ( diffs[ pointer ][ 1 ].length < 4 && ( postIns || postDel ) ) {\n\n\t\t\t\t\t// Candidate found.\n\t\t\t\t\tequalities[ equalitiesLength++ ] = pointer;\n\t\t\t\t\tpreIns = postIns;\n\t\t\t\t\tpreDel = postDel;\n\t\t\t\t\tlastequality = diffs[ pointer ][ 1 ];\n\t\t\t\t} else {\n\n\t\t\t\t\t// Not a candidate, and can never become one.\n\t\t\t\t\tequalitiesLength = 0;\n\t\t\t\t\tlastequality = null;\n\t\t\t\t}\n\t\t\t\tpostIns = postDel = false;\n\n\t\t\t// An insertion or deletion.\n\t\t\t} else {\n\n\t\t\t\tif ( diffs[ pointer ][ 0 ] === DIFF_DELETE ) {\n\t\t\t\t\tpostDel = true;\n\t\t\t\t} else {\n\t\t\t\t\tpostIns = true;\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * Five types to be split:\n\t\t\t\t * <ins>A</ins><del>B</del>XY<ins>C</ins><del>D</del>\n\t\t\t\t * <ins>A</ins>X<ins>C</ins><del>D</del>\n\t\t\t\t * <ins>A</ins><del>B</del>X<ins>C</ins>\n\t\t\t\t * <ins>A</del>X<ins>C</ins><del>D</del>\n\t\t\t\t * <ins>A</ins><del>B</del>X<del>C</del>\n\t\t\t\t */\n\t\t\t\tif ( lastequality && ( ( preIns && preDel && postIns && postDel ) ||\n\t\t\t\t\t\t( ( lastequality.length < 2 ) &&\n\t\t\t\t\t\t( preIns + preDel + postIns + postDel ) === 3 ) ) ) {\n\n\t\t\t\t\t// Duplicate record.\n\t\t\t\t\tdiffs.splice(\n\t\t\t\t\t\tequalities[ equalitiesLength - 1 ],\n\t\t\t\t\t\t0,\n\t\t\t\t\t\t[ DIFF_DELETE, lastequality ]\n\t\t\t\t\t);\n\n\t\t\t\t\t// Change second copy to insert.\n\t\t\t\t\tdiffs[ equalities[ equalitiesLength - 1 ] + 1 ][ 0 ] = DIFF_INSERT;\n\t\t\t\t\tequalitiesLength--; // Throw away the equality we just deleted;\n\t\t\t\t\tlastequality = null;\n\t\t\t\t\tif ( preIns && preDel ) {\n\n\t\t\t\t\t\t// No changes made which could affect previous entry, keep going.\n\t\t\t\t\t\tpostIns = postDel = true;\n\t\t\t\t\t\tequalitiesLength = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tequalitiesLength--; // Throw away the previous equality.\n\t\t\t\t\t\tpointer = equalitiesLength > 0 ? equalities[ equalitiesLength - 1 ] : -1;\n\t\t\t\t\t\tpostIns = postDel = false;\n\t\t\t\t\t}\n\t\t\t\t\tchanges = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tpointer++;\n\t\t}\n\n\t\tif ( changes ) {\n\t\t\tthis.diffCleanupMerge( diffs );\n\t\t}\n\t};\n\n\t/**\n\t * Convert a diff array into a pretty HTML report.\n\t * @param {!Array.<!DiffMatchPatch.Diff>} diffs Array of diff tuples.\n\t * @param {integer} string to be beautified.\n\t * @return {string} HTML representation.\n\t */\n\tDiffMatchPatch.prototype.diffPrettyHtml = function( diffs ) {\n\t\tvar op, data, x,\n\t\t\thtml = [];\n\t\tfor ( x = 0; x < diffs.length; x++ ) {\n\t\t\top = diffs[ x ][ 0 ]; // Operation (insert, delete, equal)\n\t\t\tdata = diffs[ x ][ 1 ]; // Text of change.\n\t\t\tswitch ( op ) {\n\t\t\tcase DIFF_INSERT:\n\t\t\t\thtml[ x ] = "<ins>" + escapeText( data ) + "</ins>";\n\t\t\t\tbreak;\n\t\t\tcase DIFF_DELETE:\n\t\t\t\thtml[ x ] = "<del>" + escapeText( data ) + "</del>";\n\t\t\t\tbreak;\n\t\t\tcase DIFF_EQUAL:\n\t\t\t\thtml[ x ] = "<span>" + escapeText( data ) + "</span>";\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn html.join( "" );\n\t};\n\n\t/**\n\t * Determine the common prefix of two strings.\n\t * @param {string} text1 First string.\n\t * @param {string} text2 Second string.\n\t * @return {number} The number of characters common to the start of each\n\t *     string.\n\t */\n\tDiffMatchPatch.prototype.diffCommonPrefix = function( text1, text2 ) {\n\t\tvar pointermid, pointermax, pointermin, pointerstart;\n\n\t\t// Quick check for common null cases.\n\t\tif ( !text1 || !text2 || text1.charAt( 0 ) !== text2.charAt( 0 ) ) {\n\t\t\treturn 0;\n\t\t}\n\n\t\t// Binary search.\n\t\t// Performance analysis: https://neil.fraser.name/news/2007/10/09/\n\t\tpointermin = 0;\n\t\tpointermax = Math.min( text1.length, text2.length );\n\t\tpointermid = pointermax;\n\t\tpointerstart = 0;\n\t\twhile ( pointermin < pointermid ) {\n\t\t\tif ( text1.substring( pointerstart, pointermid ) ===\n\t\t\t\t\ttext2.substring( pointerstart, pointermid ) ) {\n\t\t\t\tpointermin = pointermid;\n\t\t\t\tpointerstart = pointermin;\n\t\t\t} else {\n\t\t\t\tpointermax = pointermid;\n\t\t\t}\n\t\t\tpointermid = Math.floor( ( pointermax - pointermin ) / 2 + pointermin );\n\t\t}\n\t\treturn pointermid;\n\t};\n\n\t/**\n\t * Determine the common suffix of two strings.\n\t * @param {string} text1 First string.\n\t * @param {string} text2 Second string.\n\t * @return {number} The number of characters common to the end of each string.\n\t */\n\tDiffMatchPatch.prototype.diffCommonSuffix = function( text1, text2 ) {\n\t\tvar pointermid, pointermax, pointermin, pointerend;\n\n\t\t// Quick check for common null cases.\n\t\tif ( !text1 ||\n\t\t\t\t!text2 ||\n\t\t\t\ttext1.charAt( text1.length - 1 ) !== text2.charAt( text2.length - 1 ) ) {\n\t\t\treturn 0;\n\t\t}\n\n\t\t// Binary search.\n\t\t// Performance analysis: https://neil.fraser.name/news/2007/10/09/\n\t\tpointermin = 0;\n\t\tpointermax = Math.min( text1.length, text2.length );\n\t\tpointermid = pointermax;\n\t\tpointerend = 0;\n\t\twhile ( pointermin < pointermid ) {\n\t\t\tif ( text1.substring( text1.length - pointermid, text1.length - pointerend ) ===\n\t\t\t\t\ttext2.substring( text2.length - pointermid, text2.length - pointerend ) ) {\n\t\t\t\tpointermin = pointermid;\n\t\t\t\tpointerend = pointermin;\n\t\t\t} else {\n\t\t\t\tpointermax = pointermid;\n\t\t\t}\n\t\t\tpointermid = Math.floor( ( pointermax - pointermin ) / 2 + pointermin );\n\t\t}\n\t\treturn pointermid;\n\t};\n\n\t/**\n\t * Find the differences between two texts.  Assumes that the texts do not\n\t * have any common prefix or suffix.\n\t * @param {string} text1 Old string to be diffed.\n\t * @param {string} text2 New string to be diffed.\n\t * @param {boolean} checklines Speedup flag.  If false, then don\'t run a\n\t *     line-level diff first to identify the changed areas.\n\t *     If true, then run a faster, slightly less optimal diff.\n\t * @param {number} deadline Time when the diff should be complete by.\n\t * @return {!Array.<!DiffMatchPatch.Diff>} Array of diff tuples.\n\t * @private\n\t */\n\tDiffMatchPatch.prototype.diffCompute = function( text1, text2, checklines, deadline ) {\n\t\tvar diffs, longtext, shorttext, i, hm,\n\t\t\ttext1A, text2A, text1B, text2B,\n\t\t\tmidCommon, diffsA, diffsB;\n\n\t\tif ( !text1 ) {\n\n\t\t\t// Just add some text (speedup).\n\t\t\treturn [\n\t\t\t\t[ DIFF_INSERT, text2 ]\n\t\t\t];\n\t\t}\n\n\t\tif ( !text2 ) {\n\n\t\t\t// Just delete some text (speedup).\n\t\t\treturn [\n\t\t\t\t[ DIFF_DELETE, text1 ]\n\t\t\t];\n\t\t}\n\n\t\tlongtext = text1.length > text2.length ? text1 : text2;\n\t\tshorttext = text1.length > text2.length ? text2 : text1;\n\t\ti = longtext.indexOf( shorttext );\n\t\tif ( i !== -1 ) {\n\n\t\t\t// Shorter text is inside the longer text (speedup).\n\t\t\tdiffs = [\n\t\t\t\t[ DIFF_INSERT, longtext.substring( 0, i ) ],\n\t\t\t\t[ DIFF_EQUAL, shorttext ],\n\t\t\t\t[ DIFF_INSERT, longtext.substring( i + shorttext.length ) ]\n\t\t\t];\n\n\t\t\t// Swap insertions for deletions if diff is reversed.\n\t\t\tif ( text1.length > text2.length ) {\n\t\t\t\tdiffs[ 0 ][ 0 ] = diffs[ 2 ][ 0 ] = DIFF_DELETE;\n\t\t\t}\n\t\t\treturn diffs;\n\t\t}\n\n\t\tif ( shorttext.length === 1 ) {\n\n\t\t\t// Single character string.\n\t\t\t// After the previous speedup, the character can\'t be an equality.\n\t\t\treturn [\n\t\t\t\t[ DIFF_DELETE, text1 ],\n\t\t\t\t[ DIFF_INSERT, text2 ]\n\t\t\t];\n\t\t}\n\n\t\t// Check to see if the problem can be split in two.\n\t\thm = this.diffHalfMatch( text1, text2 );\n\t\tif ( hm ) {\n\n\t\t\t// A half-match was found, sort out the return data.\n\t\t\ttext1A = hm[ 0 ];\n\t\t\ttext1B = hm[ 1 ];\n\t\t\ttext2A = hm[ 2 ];\n\t\t\ttext2B = hm[ 3 ];\n\t\t\tmidCommon = hm[ 4 ];\n\n\t\t\t// Send both pairs off for separate processing.\n\t\t\tdiffsA = this.DiffMain( text1A, text2A, checklines, deadline );\n\t\t\tdiffsB = this.DiffMain( text1B, text2B, checklines, deadline );\n\n\t\t\t// Merge the results.\n\t\t\treturn diffsA.concat( [\n\t\t\t\t[ DIFF_EQUAL, midCommon ]\n\t\t\t], diffsB );\n\t\t}\n\n\t\tif ( checklines && text1.length > 100 && text2.length > 100 ) {\n\t\t\treturn this.diffLineMode( text1, text2, deadline );\n\t\t}\n\n\t\treturn this.diffBisect( text1, text2, deadline );\n\t};\n\n\t/**\n\t * Do the two texts share a substring which is at least half the length of the\n\t * longer text?\n\t * This speedup can produce non-minimal diffs.\n\t * @param {string} text1 First string.\n\t * @param {string} text2 Second string.\n\t * @return {Array.<string>} Five element Array, containing the prefix of\n\t *     text1, the suffix of text1, the prefix of text2, the suffix of\n\t *     text2 and the common middle.  Or null if there was no match.\n\t * @private\n\t */\n\tDiffMatchPatch.prototype.diffHalfMatch = function( text1, text2 ) {\n\t\tvar longtext, shorttext, dmp,\n\t\t\ttext1A, text2B, text2A, text1B, midCommon,\n\t\t\thm1, hm2, hm;\n\n\t\tlongtext = text1.length > text2.length ? text1 : text2;\n\t\tshorttext = text1.length > text2.length ? text2 : text1;\n\t\tif ( longtext.length < 4 || shorttext.length * 2 < longtext.length ) {\n\t\t\treturn null; // Pointless.\n\t\t}\n\t\tdmp = this; // \'this\' becomes \'window\' in a closure.\n\n\t\t/**\n\t\t * Does a substring of shorttext exist within longtext such that the substring\n\t\t * is at least half the length of longtext?\n\t\t * Closure, but does not reference any external variables.\n\t\t * @param {string} longtext Longer string.\n\t\t * @param {string} shorttext Shorter string.\n\t\t * @param {number} i Start index of quarter length substring within longtext.\n\t\t * @return {Array.<string>} Five element Array, containing the prefix of\n\t\t *     longtext, the suffix of longtext, the prefix of shorttext, the suffix\n\t\t *     of shorttext and the common middle.  Or null if there was no match.\n\t\t * @private\n\t\t */\n\t\tfunction diffHalfMatchI( longtext, shorttext, i ) {\n\t\t\tvar seed, j, bestCommon, prefixLength, suffixLength,\n\t\t\t\tbestLongtextA, bestLongtextB, bestShorttextA, bestShorttextB;\n\n\t\t\t// Start with a 1/4 length substring at position i as a seed.\n\t\t\tseed = longtext.substring( i, i + Math.floor( longtext.length / 4 ) );\n\t\t\tj = -1;\n\t\t\tbestCommon = "";\n\t\t\twhile ( ( j = shorttext.indexOf( seed, j + 1 ) ) !== -1 ) {\n\t\t\t\tprefixLength = dmp.diffCommonPrefix( longtext.substring( i ),\n\t\t\t\t\tshorttext.substring( j ) );\n\t\t\t\tsuffixLength = dmp.diffCommonSuffix( longtext.substring( 0, i ),\n\t\t\t\t\tshorttext.substring( 0, j ) );\n\t\t\t\tif ( bestCommon.length < suffixLength + prefixLength ) {\n\t\t\t\t\tbestCommon = shorttext.substring( j - suffixLength, j ) +\n\t\t\t\t\t\tshorttext.substring( j, j + prefixLength );\n\t\t\t\t\tbestLongtextA = longtext.substring( 0, i - suffixLength );\n\t\t\t\t\tbestLongtextB = longtext.substring( i + prefixLength );\n\t\t\t\t\tbestShorttextA = shorttext.substring( 0, j - suffixLength );\n\t\t\t\t\tbestShorttextB = shorttext.substring( j + prefixLength );\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ( bestCommon.length * 2 >= longtext.length ) {\n\t\t\t\treturn [ bestLongtextA, bestLongtextB,\n\t\t\t\t\tbestShorttextA, bestShorttextB, bestCommon\n\t\t\t\t];\n\t\t\t} else {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\n\t\t// First check if the second quarter is the seed for a half-match.\n\t\thm1 = diffHalfMatchI( longtext, shorttext,\n\t\t\tMath.ceil( longtext.length / 4 ) );\n\n\t\t// Check again based on the third quarter.\n\t\thm2 = diffHalfMatchI( longtext, shorttext,\n\t\t\tMath.ceil( longtext.length / 2 ) );\n\t\tif ( !hm1 && !hm2 ) {\n\t\t\treturn null;\n\t\t} else if ( !hm2 ) {\n\t\t\thm = hm1;\n\t\t} else if ( !hm1 ) {\n\t\t\thm = hm2;\n\t\t} else {\n\n\t\t\t// Both matched.  Select the longest.\n\t\t\thm = hm1[ 4 ].length > hm2[ 4 ].length ? hm1 : hm2;\n\t\t}\n\n\t\t// A half-match was found, sort out the return data.\n\t\ttext1A, text1B, text2A, text2B;\n\t\tif ( text1.length > text2.length ) {\n\t\t\ttext1A = hm[ 0 ];\n\t\t\ttext1B = hm[ 1 ];\n\t\t\ttext2A = hm[ 2 ];\n\t\t\ttext2B = hm[ 3 ];\n\t\t} else {\n\t\t\ttext2A = hm[ 0 ];\n\t\t\ttext2B = hm[ 1 ];\n\t\t\ttext1A = hm[ 2 ];\n\t\t\ttext1B = hm[ 3 ];\n\t\t}\n\t\tmidCommon = hm[ 4 ];\n\t\treturn [ text1A, text1B, text2A, text2B, midCommon ];\n\t};\n\n\t/**\n\t * Do a quick line-level diff on both strings, then rediff the parts for\n\t * greater accuracy.\n\t * This speedup can produce non-minimal diffs.\n\t * @param {string} text1 Old string to be diffed.\n\t * @param {string} text2 New string to be diffed.\n\t * @param {number} deadline Time when the diff should be complete by.\n\t * @return {!Array.<!DiffMatchPatch.Diff>} Array of diff tuples.\n\t * @private\n\t */\n\tDiffMatchPatch.prototype.diffLineMode = function( text1, text2, deadline ) {\n\t\tvar a, diffs, linearray, pointer, countInsert,\n\t\t\tcountDelete, textInsert, textDelete, j;\n\n\t\t// Scan the text on a line-by-line basis first.\n\t\ta = this.diffLinesToChars( text1, text2 );\n\t\ttext1 = a.chars1;\n\t\ttext2 = a.chars2;\n\t\tlinearray = a.lineArray;\n\n\t\tdiffs = this.DiffMain( text1, text2, false, deadline );\n\n\t\t// Convert the diff back to original text.\n\t\tthis.diffCharsToLines( diffs, linearray );\n\n\t\t// Eliminate freak matches (e.g. blank lines)\n\t\tthis.diffCleanupSemantic( diffs );\n\n\t\t// Rediff any replacement blocks, this time character-by-character.\n\t\t// Add a dummy entry at the end.\n\t\tdiffs.push( [ DIFF_EQUAL, "" ] );\n\t\tpointer = 0;\n\t\tcountDelete = 0;\n\t\tcountInsert = 0;\n\t\ttextDelete = "";\n\t\ttextInsert = "";\n\t\twhile ( pointer < diffs.length ) {\n\t\t\tswitch ( diffs[ pointer ][ 0 ] ) {\n\t\t\tcase DIFF_INSERT:\n\t\t\t\tcountInsert++;\n\t\t\t\ttextInsert += diffs[ pointer ][ 1 ];\n\t\t\t\tbreak;\n\t\t\tcase DIFF_DELETE:\n\t\t\t\tcountDelete++;\n\t\t\t\ttextDelete += diffs[ pointer ][ 1 ];\n\t\t\t\tbreak;\n\t\t\tcase DIFF_EQUAL:\n\n\t\t\t\t// Upon reaching an equality, check for prior redundancies.\n\t\t\t\tif ( countDelete >= 1 && countInsert >= 1 ) {\n\n\t\t\t\t\t// Delete the offending records and add the merged ones.\n\t\t\t\t\tdiffs.splice( pointer - countDelete - countInsert,\n\t\t\t\t\t\tcountDelete + countInsert );\n\t\t\t\t\tpointer = pointer - countDelete - countInsert;\n\t\t\t\t\ta = this.DiffMain( textDelete, textInsert, false, deadline );\n\t\t\t\t\tfor ( j = a.length - 1; j >= 0; j-- ) {\n\t\t\t\t\t\tdiffs.splice( pointer, 0, a[ j ] );\n\t\t\t\t\t}\n\t\t\t\t\tpointer = pointer + a.length;\n\t\t\t\t}\n\t\t\t\tcountInsert = 0;\n\t\t\t\tcountDelete = 0;\n\t\t\t\ttextDelete = "";\n\t\t\t\ttextInsert = "";\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpointer++;\n\t\t}\n\t\tdiffs.pop(); // Remove the dummy entry at the end.\n\n\t\treturn diffs;\n\t};\n\n\t/**\n\t * Find the \'middle snake\' of a diff, split the problem in two\n\t * and return the recursively constructed diff.\n\t * See Myers 1986 paper: An O(ND) Difference Algorithm and Its Variations.\n\t * @param {string} text1 Old string to be diffed.\n\t * @param {string} text2 New string to be diffed.\n\t * @param {number} deadline Time at which to bail if not yet complete.\n\t * @return {!Array.<!DiffMatchPatch.Diff>} Array of diff tuples.\n\t * @private\n\t */\n\tDiffMatchPatch.prototype.diffBisect = function( text1, text2, deadline ) {\n\t\tvar text1Length, text2Length, maxD, vOffset, vLength,\n\t\t\tv1, v2, x, delta, front, k1start, k1end, k2start,\n\t\t\tk2end, k2Offset, k1Offset, x1, x2, y1, y2, d, k1, k2;\n\n\t\t// Cache the text lengths to prevent multiple calls.\n\t\ttext1Length = text1.length;\n\t\ttext2Length = text2.length;\n\t\tmaxD = Math.ceil( ( text1Length + text2Length ) / 2 );\n\t\tvOffset = maxD;\n\t\tvLength = 2 * maxD;\n\t\tv1 = new Array( vLength );\n\t\tv2 = new Array( vLength );\n\n\t\t// Setting all elements to -1 is faster in Chrome & Firefox than mixing\n\t\t// integers and undefined.\n\t\tfor ( x = 0; x < vLength; x++ ) {\n\t\t\tv1[ x ] = -1;\n\t\t\tv2[ x ] = -1;\n\t\t}\n\t\tv1[ vOffset + 1 ] = 0;\n\t\tv2[ vOffset + 1 ] = 0;\n\t\tdelta = text1Length - text2Length;\n\n\t\t// If the total number of characters is odd, then the front path will collide\n\t\t// with the reverse path.\n\t\tfront = ( delta % 2 !== 0 );\n\n\t\t// Offsets for start and end of k loop.\n\t\t// Prevents mapping of space beyond the grid.\n\t\tk1start = 0;\n\t\tk1end = 0;\n\t\tk2start = 0;\n\t\tk2end = 0;\n\t\tfor ( d = 0; d < maxD; d++ ) {\n\n\t\t\t// Bail out if deadline is reached.\n\t\t\tif ( ( new Date() ).getTime() > deadline ) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// Walk the front path one step.\n\t\t\tfor ( k1 = -d + k1start; k1 <= d - k1end; k1 += 2 ) {\n\t\t\t\tk1Offset = vOffset + k1;\n\t\t\t\tif ( k1 === -d || ( k1 !== d && v1[ k1Offset - 1 ] < v1[ k1Offset + 1 ] ) ) {\n\t\t\t\t\tx1 = v1[ k1Offset + 1 ];\n\t\t\t\t} else {\n\t\t\t\t\tx1 = v1[ k1Offset - 1 ] + 1;\n\t\t\t\t}\n\t\t\t\ty1 = x1 - k1;\n\t\t\t\twhile ( x1 < text1Length && y1 < text2Length &&\n\t\t\t\t\ttext1.charAt( x1 ) === text2.charAt( y1 ) ) {\n\t\t\t\t\tx1++;\n\t\t\t\t\ty1++;\n\t\t\t\t}\n\t\t\t\tv1[ k1Offset ] = x1;\n\t\t\t\tif ( x1 > text1Length ) {\n\n\t\t\t\t\t// Ran off the right of the graph.\n\t\t\t\t\tk1end += 2;\n\t\t\t\t} else if ( y1 > text2Length ) {\n\n\t\t\t\t\t// Ran off the bottom of the graph.\n\t\t\t\t\tk1start += 2;\n\t\t\t\t} else if ( front ) {\n\t\t\t\t\tk2Offset = vOffset + delta - k1;\n\t\t\t\t\tif ( k2Offset >= 0 && k2Offset < vLength && v2[ k2Offset ] !== -1 ) {\n\n\t\t\t\t\t\t// Mirror x2 onto top-left coordinate system.\n\t\t\t\t\t\tx2 = text1Length - v2[ k2Offset ];\n\t\t\t\t\t\tif ( x1 >= x2 ) {\n\n\t\t\t\t\t\t\t// Overlap detected.\n\t\t\t\t\t\t\treturn this.diffBisectSplit( text1, text2, x1, y1, deadline );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Walk the reverse path one step.\n\t\t\tfor ( k2 = -d + k2start; k2 <= d - k2end; k2 += 2 ) {\n\t\t\t\tk2Offset = vOffset + k2;\n\t\t\t\tif ( k2 === -d || ( k2 !== d && v2[ k2Offset - 1 ] < v2[ k2Offset + 1 ] ) ) {\n\t\t\t\t\tx2 = v2[ k2Offset + 1 ];\n\t\t\t\t} else {\n\t\t\t\t\tx2 = v2[ k2Offset - 1 ] + 1;\n\t\t\t\t}\n\t\t\t\ty2 = x2 - k2;\n\t\t\t\twhile ( x2 < text1Length && y2 < text2Length &&\n\t\t\t\t\ttext1.charAt( text1Length - x2 - 1 ) ===\n\t\t\t\t\ttext2.charAt( text2Length - y2 - 1 ) ) {\n\t\t\t\t\tx2++;\n\t\t\t\t\ty2++;\n\t\t\t\t}\n\t\t\t\tv2[ k2Offset ] = x2;\n\t\t\t\tif ( x2 > text1Length ) {\n\n\t\t\t\t\t// Ran off the left of the graph.\n\t\t\t\t\tk2end += 2;\n\t\t\t\t} else if ( y2 > text2Length ) {\n\n\t\t\t\t\t// Ran off the top of the graph.\n\t\t\t\t\tk2start += 2;\n\t\t\t\t} else if ( !front ) {\n\t\t\t\t\tk1Offset = vOffset + delta - k2;\n\t\t\t\t\tif ( k1Offset >= 0 && k1Offset < vLength && v1[ k1Offset ] !== -1 ) {\n\t\t\t\t\t\tx1 = v1[ k1Offset ];\n\t\t\t\t\t\ty1 = vOffset + x1 - k1Offset;\n\n\t\t\t\t\t\t// Mirror x2 onto top-left coordinate system.\n\t\t\t\t\t\tx2 = text1Length - x2;\n\t\t\t\t\t\tif ( x1 >= x2 ) {\n\n\t\t\t\t\t\t\t// Overlap detected.\n\t\t\t\t\t\t\treturn this.diffBisectSplit( text1, text2, x1, y1, deadline );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Diff took too long and hit the deadline or\n\t\t// number of diffs equals number of characters, no commonality at all.\n\t\treturn [\n\t\t\t[ DIFF_DELETE, text1 ],\n\t\t\t[ DIFF_INSERT, text2 ]\n\t\t];\n\t};\n\n\t/**\n\t * Given the location of the \'middle snake\', split the diff in two parts\n\t * and recurse.\n\t * @param {string} text1 Old string to be diffed.\n\t * @param {string} text2 New string to be diffed.\n\t * @param {number} x Index of split point in text1.\n\t * @param {number} y Index of split point in text2.\n\t * @param {number} deadline Time at which to bail if not yet complete.\n\t * @return {!Array.<!DiffMatchPatch.Diff>} Array of diff tuples.\n\t * @private\n\t */\n\tDiffMatchPatch.prototype.diffBisectSplit = function( text1, text2, x, y, deadline ) {\n\t\tvar text1a, text1b, text2a, text2b, diffs, diffsb;\n\t\ttext1a = text1.substring( 0, x );\n\t\ttext2a = text2.substring( 0, y );\n\t\ttext1b = text1.substring( x );\n\t\ttext2b = text2.substring( y );\n\n\t\t// Compute both diffs serially.\n\t\tdiffs = this.DiffMain( text1a, text2a, false, deadline );\n\t\tdiffsb = this.DiffMain( text1b, text2b, false, deadline );\n\n\t\treturn diffs.concat( diffsb );\n\t};\n\n\t/**\n\t * Reduce the number of edits by eliminating semantically trivial equalities.\n\t * @param {!Array.<!DiffMatchPatch.Diff>} diffs Array of diff tuples.\n\t */\n\tDiffMatchPatch.prototype.diffCleanupSemantic = function( diffs ) {\n\t\tvar changes, equalities, equalitiesLength, lastequality,\n\t\t\tpointer, lengthInsertions2, lengthDeletions2, lengthInsertions1,\n\t\t\tlengthDeletions1, deletion, insertion, overlapLength1, overlapLength2;\n\t\tchanges = false;\n\t\tequalities = []; // Stack of indices where equalities are found.\n\t\tequalitiesLength = 0; // Keeping our own length var is faster in JS.\n\t\t/** @type {?string} */\n\t\tlastequality = null;\n\n\t\t// Always equal to diffs[equalities[equalitiesLength - 1]][1]\n\t\tpointer = 0; // Index of current position.\n\n\t\t// Number of characters that changed prior to the equality.\n\t\tlengthInsertions1 = 0;\n\t\tlengthDeletions1 = 0;\n\n\t\t// Number of characters that changed after the equality.\n\t\tlengthInsertions2 = 0;\n\t\tlengthDeletions2 = 0;\n\t\twhile ( pointer < diffs.length ) {\n\t\t\tif ( diffs[ pointer ][ 0 ] === DIFF_EQUAL ) { // Equality found.\n\t\t\t\tequalities[ equalitiesLength++ ] = pointer;\n\t\t\t\tlengthInsertions1 = lengthInsertions2;\n\t\t\t\tlengthDeletions1 = lengthDeletions2;\n\t\t\t\tlengthInsertions2 = 0;\n\t\t\t\tlengthDeletions2 = 0;\n\t\t\t\tlastequality = diffs[ pointer ][ 1 ];\n\t\t\t} else { // An insertion or deletion.\n\t\t\t\tif ( diffs[ pointer ][ 0 ] === DIFF_INSERT ) {\n\t\t\t\t\tlengthInsertions2 += diffs[ pointer ][ 1 ].length;\n\t\t\t\t} else {\n\t\t\t\t\tlengthDeletions2 += diffs[ pointer ][ 1 ].length;\n\t\t\t\t}\n\n\t\t\t\t// Eliminate an equality that is smaller or equal to the edits on both\n\t\t\t\t// sides of it.\n\t\t\t\tif ( lastequality && ( lastequality.length <=\n\t\t\t\t\t\tMath.max( lengthInsertions1, lengthDeletions1 ) ) &&\n\t\t\t\t\t\t( lastequality.length <= Math.max( lengthInsertions2,\n\t\t\t\t\t\t\tlengthDeletions2 ) ) ) {\n\n\t\t\t\t\t// Duplicate record.\n\t\t\t\t\tdiffs.splice(\n\t\t\t\t\t\tequalities[ equalitiesLength - 1 ],\n\t\t\t\t\t\t0,\n\t\t\t\t\t\t[ DIFF_DELETE, lastequality ]\n\t\t\t\t\t);\n\n\t\t\t\t\t// Change second copy to insert.\n\t\t\t\t\tdiffs[ equalities[ equalitiesLength - 1 ] + 1 ][ 0 ] = DIFF_INSERT;\n\n\t\t\t\t\t// Throw away the equality we just deleted.\n\t\t\t\t\tequalitiesLength--;\n\n\t\t\t\t\t// Throw away the previous equality (it needs to be reevaluated).\n\t\t\t\t\tequalitiesLength--;\n\t\t\t\t\tpointer = equalitiesLength > 0 ? equalities[ equalitiesLength - 1 ] : -1;\n\n\t\t\t\t\t// Reset the counters.\n\t\t\t\t\tlengthInsertions1 = 0;\n\t\t\t\t\tlengthDeletions1 = 0;\n\t\t\t\t\tlengthInsertions2 = 0;\n\t\t\t\t\tlengthDeletions2 = 0;\n\t\t\t\t\tlastequality = null;\n\t\t\t\t\tchanges = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tpointer++;\n\t\t}\n\n\t\t// Normalize the diff.\n\t\tif ( changes ) {\n\t\t\tthis.diffCleanupMerge( diffs );\n\t\t}\n\n\t\t// Find any overlaps between deletions and insertions.\n\t\t// e.g: <del>abcxxx</del><ins>xxxdef</ins>\n\t\t//   -> <del>abc</del>xxx<ins>def</ins>\n\t\t// e.g: <del>xxxabc</del><ins>defxxx</ins>\n\t\t//   -> <ins>def</ins>xxx<del>abc</del>\n\t\t// Only extract an overlap if it is as big as the edit ahead or behind it.\n\t\tpointer = 1;\n\t\twhile ( pointer < diffs.length ) {\n\t\t\tif ( diffs[ pointer - 1 ][ 0 ] === DIFF_DELETE &&\n\t\t\t\t\tdiffs[ pointer ][ 0 ] === DIFF_INSERT ) {\n\t\t\t\tdeletion = diffs[ pointer - 1 ][ 1 ];\n\t\t\t\tinsertion = diffs[ pointer ][ 1 ];\n\t\t\t\toverlapLength1 = this.diffCommonOverlap( deletion, insertion );\n\t\t\t\toverlapLength2 = this.diffCommonOverlap( insertion, deletion );\n\t\t\t\tif ( overlapLength1 >= overlapLength2 ) {\n\t\t\t\t\tif ( overlapLength1 >= deletion.length / 2 ||\n\t\t\t\t\t\t\toverlapLength1 >= insertion.length / 2 ) {\n\n\t\t\t\t\t\t// Overlap found.  Insert an equality and trim the surrounding edits.\n\t\t\t\t\t\tdiffs.splice(\n\t\t\t\t\t\t\tpointer,\n\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t[ DIFF_EQUAL, insertion.substring( 0, overlapLength1 ) ]\n\t\t\t\t\t\t);\n\t\t\t\t\t\tdiffs[ pointer - 1 ][ 1 ] =\n\t\t\t\t\t\t\tdeletion.substring( 0, deletion.length - overlapLength1 );\n\t\t\t\t\t\tdiffs[ pointer + 1 ][ 1 ] = insertion.substring( overlapLength1 );\n\t\t\t\t\t\tpointer++;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif ( overlapLength2 >= deletion.length / 2 ||\n\t\t\t\t\t\t\toverlapLength2 >= insertion.length / 2 ) {\n\n\t\t\t\t\t\t// Reverse overlap found.\n\t\t\t\t\t\t// Insert an equality and swap and trim the surrounding edits.\n\t\t\t\t\t\tdiffs.splice(\n\t\t\t\t\t\t\tpointer,\n\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t[ DIFF_EQUAL, deletion.substring( 0, overlapLength2 ) ]\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tdiffs[ pointer - 1 ][ 0 ] = DIFF_INSERT;\n\t\t\t\t\t\tdiffs[ pointer - 1 ][ 1 ] =\n\t\t\t\t\t\t\tinsertion.substring( 0, insertion.length - overlapLength2 );\n\t\t\t\t\t\tdiffs[ pointer + 1 ][ 0 ] = DIFF_DELETE;\n\t\t\t\t\t\tdiffs[ pointer + 1 ][ 1 ] =\n\t\t\t\t\t\t\tdeletion.substring( overlapLength2 );\n\t\t\t\t\t\tpointer++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tpointer++;\n\t\t\t}\n\t\t\tpointer++;\n\t\t}\n\t};\n\n\t/**\n\t * Determine if the suffix of one string is the prefix of another.\n\t * @param {string} text1 First string.\n\t * @param {string} text2 Second string.\n\t * @return {number} The number of characters common to the end of the first\n\t *     string and the start of the second string.\n\t * @private\n\t */\n\tDiffMatchPatch.prototype.diffCommonOverlap = function( text1, text2 ) {\n\t\tvar text1Length, text2Length, textLength,\n\t\t\tbest, length, pattern, found;\n\n\t\t// Cache the text lengths to prevent multiple calls.\n\t\ttext1Length = text1.length;\n\t\ttext2Length = text2.length;\n\n\t\t// Eliminate the null case.\n\t\tif ( text1Length === 0 || text2Length === 0 ) {\n\t\t\treturn 0;\n\t\t}\n\n\t\t// Truncate the longer string.\n\t\tif ( text1Length > text2Length ) {\n\t\t\ttext1 = text1.substring( text1Length - text2Length );\n\t\t} else if ( text1Length < text2Length ) {\n\t\t\ttext2 = text2.substring( 0, text1Length );\n\t\t}\n\t\ttextLength = Math.min( text1Length, text2Length );\n\n\t\t// Quick check for the worst case.\n\t\tif ( text1 === text2 ) {\n\t\t\treturn textLength;\n\t\t}\n\n\t\t// Start by looking for a single character match\n\t\t// and increase length until no match is found.\n\t\t// Performance analysis: https://neil.fraser.name/news/2010/11/04/\n\t\tbest = 0;\n\t\tlength = 1;\n\t\twhile ( true ) {\n\t\t\tpattern = text1.substring( textLength - length );\n\t\t\tfound = text2.indexOf( pattern );\n\t\t\tif ( found === -1 ) {\n\t\t\t\treturn best;\n\t\t\t}\n\t\t\tlength += found;\n\t\t\tif ( found === 0 || text1.substring( textLength - length ) ===\n\t\t\t\t\ttext2.substring( 0, length ) ) {\n\t\t\t\tbest = length;\n\t\t\t\tlength++;\n\t\t\t}\n\t\t}\n\t};\n\n\t/**\n\t * Split two texts into an array of strings.  Reduce the texts to a string of\n\t * hashes where each Unicode character represents one line.\n\t * @param {string} text1 First string.\n\t * @param {string} text2 Second string.\n\t * @return {{chars1: string, chars2: string, lineArray: !Array.<string>}}\n\t *     An object containing the encoded text1, the encoded text2 and\n\t *     the array of unique strings.\n\t *     The zeroth element of the array of unique strings is intentionally blank.\n\t * @private\n\t */\n\tDiffMatchPatch.prototype.diffLinesToChars = function( text1, text2 ) {\n\t\tvar lineArray, lineHash, chars1, chars2;\n\t\tlineArray = []; // E.g. lineArray[4] === \'Hello\\n\'\n\t\tlineHash = {};  // E.g. lineHash[\'Hello\\n\'] === 4\n\n\t\t// \'\\x00\' is a valid character, but various debuggers don\'t like it.\n\t\t// So we\'ll insert a junk entry to avoid generating a null character.\n\t\tlineArray[ 0 ] = "";\n\n\t\t/**\n\t\t * Split a text into an array of strings.  Reduce the texts to a string of\n\t\t * hashes where each Unicode character represents one line.\n\t\t * Modifies linearray and linehash through being a closure.\n\t\t * @param {string} text String to encode.\n\t\t * @return {string} Encoded string.\n\t\t * @private\n\t\t */\n\t\tfunction diffLinesToCharsMunge( text ) {\n\t\t\tvar chars, lineStart, lineEnd, lineArrayLength, line;\n\t\t\tchars = "";\n\n\t\t\t// Walk the text, pulling out a substring for each line.\n\t\t\t// text.split(\'\\n\') would would temporarily double our memory footprint.\n\t\t\t// Modifying text would create many large strings to garbage collect.\n\t\t\tlineStart = 0;\n\t\t\tlineEnd = -1;\n\n\t\t\t// Keeping our own length variable is faster than looking it up.\n\t\t\tlineArrayLength = lineArray.length;\n\t\t\twhile ( lineEnd < text.length - 1 ) {\n\t\t\t\tlineEnd = text.indexOf( "\\n", lineStart );\n\t\t\t\tif ( lineEnd === -1 ) {\n\t\t\t\t\tlineEnd = text.length - 1;\n\t\t\t\t}\n\t\t\t\tline = text.substring( lineStart, lineEnd + 1 );\n\t\t\t\tlineStart = lineEnd + 1;\n\n\t\t\t\tif ( lineHash.hasOwnProperty ? lineHash.hasOwnProperty( line ) :\n\t\t\t\t\t\t\t( lineHash[ line ] !== undefined ) ) {\n\t\t\t\t\tchars += String.fromCharCode( lineHash[ line ] );\n\t\t\t\t} else {\n\t\t\t\t\tchars += String.fromCharCode( lineArrayLength );\n\t\t\t\t\tlineHash[ line ] = lineArrayLength;\n\t\t\t\t\tlineArray[ lineArrayLength++ ] = line;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn chars;\n\t\t}\n\n\t\tchars1 = diffLinesToCharsMunge( text1 );\n\t\tchars2 = diffLinesToCharsMunge( text2 );\n\t\treturn {\n\t\t\tchars1: chars1,\n\t\t\tchars2: chars2,\n\t\t\tlineArray: lineArray\n\t\t};\n\t};\n\n\t/**\n\t * Rehydrate the text in a diff from a string of line hashes to real lines of\n\t * text.\n\t * @param {!Array.<!DiffMatchPatch.Diff>} diffs Array of diff tuples.\n\t * @param {!Array.<string>} lineArray Array of unique strings.\n\t * @private\n\t */\n\tDiffMatchPatch.prototype.diffCharsToLines = function( diffs, lineArray ) {\n\t\tvar x, chars, text, y;\n\t\tfor ( x = 0; x < diffs.length; x++ ) {\n\t\t\tchars = diffs[ x ][ 1 ];\n\t\t\ttext = [];\n\t\t\tfor ( y = 0; y < chars.length; y++ ) {\n\t\t\t\ttext[ y ] = lineArray[ chars.charCodeAt( y ) ];\n\t\t\t}\n\t\t\tdiffs[ x ][ 1 ] = text.join( "" );\n\t\t}\n\t};\n\n\t/**\n\t * Reorder and merge like edit sections.  Merge equalities.\n\t * Any edit section can move as long as it doesn\'t cross an equality.\n\t * @param {!Array.<!DiffMatchPatch.Diff>} diffs Array of diff tuples.\n\t */\n\tDiffMatchPatch.prototype.diffCleanupMerge = function( diffs ) {\n\t\tvar pointer, countDelete, countInsert, textInsert, textDelete,\n\t\t\tcommonlength, changes, diffPointer, position;\n\t\tdiffs.push( [ DIFF_EQUAL, "" ] ); // Add a dummy entry at the end.\n\t\tpointer = 0;\n\t\tcountDelete = 0;\n\t\tcountInsert = 0;\n\t\ttextDelete = "";\n\t\ttextInsert = "";\n\t\tcommonlength;\n\t\twhile ( pointer < diffs.length ) {\n\t\t\tswitch ( diffs[ pointer ][ 0 ] ) {\n\t\t\tcase DIFF_INSERT:\n\t\t\t\tcountInsert++;\n\t\t\t\ttextInsert += diffs[ pointer ][ 1 ];\n\t\t\t\tpointer++;\n\t\t\t\tbreak;\n\t\t\tcase DIFF_DELETE:\n\t\t\t\tcountDelete++;\n\t\t\t\ttextDelete += diffs[ pointer ][ 1 ];\n\t\t\t\tpointer++;\n\t\t\t\tbreak;\n\t\t\tcase DIFF_EQUAL:\n\n\t\t\t\t// Upon reaching an equality, check for prior redundancies.\n\t\t\t\tif ( countDelete + countInsert > 1 ) {\n\t\t\t\t\tif ( countDelete !== 0 && countInsert !== 0 ) {\n\n\t\t\t\t\t\t// Factor out any common prefixes.\n\t\t\t\t\t\tcommonlength = this.diffCommonPrefix( textInsert, textDelete );\n\t\t\t\t\t\tif ( commonlength !== 0 ) {\n\t\t\t\t\t\t\tif ( ( pointer - countDelete - countInsert ) > 0 &&\n\t\t\t\t\t\t\t\t\tdiffs[ pointer - countDelete - countInsert - 1 ][ 0 ] ===\n\t\t\t\t\t\t\t\t\tDIFF_EQUAL ) {\n\t\t\t\t\t\t\t\tdiffs[ pointer - countDelete - countInsert - 1 ][ 1 ] +=\n\t\t\t\t\t\t\t\t\ttextInsert.substring( 0, commonlength );\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tdiffs.splice( 0, 0, [ DIFF_EQUAL,\n\t\t\t\t\t\t\t\t\ttextInsert.substring( 0, commonlength )\n\t\t\t\t\t\t\t\t] );\n\t\t\t\t\t\t\t\tpointer++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttextInsert = textInsert.substring( commonlength );\n\t\t\t\t\t\t\ttextDelete = textDelete.substring( commonlength );\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Factor out any common suffixies.\n\t\t\t\t\t\tcommonlength = this.diffCommonSuffix( textInsert, textDelete );\n\t\t\t\t\t\tif ( commonlength !== 0 ) {\n\t\t\t\t\t\t\tdiffs[ pointer ][ 1 ] = textInsert.substring( textInsert.length -\n\t\t\t\t\t\t\t\t\tcommonlength ) + diffs[ pointer ][ 1 ];\n\t\t\t\t\t\t\ttextInsert = textInsert.substring( 0, textInsert.length -\n\t\t\t\t\t\t\t\tcommonlength );\n\t\t\t\t\t\t\ttextDelete = textDelete.substring( 0, textDelete.length -\n\t\t\t\t\t\t\t\tcommonlength );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Delete the offending records and add the merged ones.\n\t\t\t\t\tif ( countDelete === 0 ) {\n\t\t\t\t\t\tdiffs.splice( pointer - countInsert,\n\t\t\t\t\t\t\tcountDelete + countInsert, [ DIFF_INSERT, textInsert ] );\n\t\t\t\t\t} else if ( countInsert === 0 ) {\n\t\t\t\t\t\tdiffs.splice( pointer - countDelete,\n\t\t\t\t\t\t\tcountDelete + countInsert, [ DIFF_DELETE, textDelete ] );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdiffs.splice(\n\t\t\t\t\t\t\tpointer - countDelete - countInsert,\n\t\t\t\t\t\t\tcountDelete + countInsert,\n\t\t\t\t\t\t\t[ DIFF_DELETE, textDelete ], [ DIFF_INSERT, textInsert ]\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\tpointer = pointer - countDelete - countInsert +\n\t\t\t\t\t\t( countDelete ? 1 : 0 ) + ( countInsert ? 1 : 0 ) + 1;\n\t\t\t\t} else if ( pointer !== 0 && diffs[ pointer - 1 ][ 0 ] === DIFF_EQUAL ) {\n\n\t\t\t\t\t// Merge this equality with the previous one.\n\t\t\t\t\tdiffs[ pointer - 1 ][ 1 ] += diffs[ pointer ][ 1 ];\n\t\t\t\t\tdiffs.splice( pointer, 1 );\n\t\t\t\t} else {\n\t\t\t\t\tpointer++;\n\t\t\t\t}\n\t\t\t\tcountInsert = 0;\n\t\t\t\tcountDelete = 0;\n\t\t\t\ttextDelete = "";\n\t\t\t\ttextInsert = "";\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif ( diffs[ diffs.length - 1 ][ 1 ] === "" ) {\n\t\t\tdiffs.pop(); // Remove the dummy entry at the end.\n\t\t}\n\n\t\t// Second pass: look for single edits surrounded on both sides by equalities\n\t\t// which can be shifted sideways to eliminate an equality.\n\t\t// e.g: A<ins>BA</ins>C -> <ins>AB</ins>AC\n\t\tchanges = false;\n\t\tpointer = 1;\n\n\t\t// Intentionally ignore the first and last element (don\'t need checking).\n\t\twhile ( pointer < diffs.length - 1 ) {\n\t\t\tif ( diffs[ pointer - 1 ][ 0 ] === DIFF_EQUAL &&\n\t\t\t\t\tdiffs[ pointer + 1 ][ 0 ] === DIFF_EQUAL ) {\n\n\t\t\t\tdiffPointer = diffs[ pointer ][ 1 ];\n\t\t\t\tposition = diffPointer.substring(\n\t\t\t\t\tdiffPointer.length - diffs[ pointer - 1 ][ 1 ].length\n\t\t\t\t);\n\n\t\t\t\t// This is a single edit surrounded by equalities.\n\t\t\t\tif ( position === diffs[ pointer - 1 ][ 1 ] ) {\n\n\t\t\t\t\t// Shift the edit over the previous equality.\n\t\t\t\t\tdiffs[ pointer ][ 1 ] = diffs[ pointer - 1 ][ 1 ] +\n\t\t\t\t\t\tdiffs[ pointer ][ 1 ].substring( 0, diffs[ pointer ][ 1 ].length -\n\t\t\t\t\t\t\tdiffs[ pointer - 1 ][ 1 ].length );\n\t\t\t\t\tdiffs[ pointer + 1 ][ 1 ] =\n\t\t\t\t\t\tdiffs[ pointer - 1 ][ 1 ] + diffs[ pointer + 1 ][ 1 ];\n\t\t\t\t\tdiffs.splice( pointer - 1, 1 );\n\t\t\t\t\tchanges = true;\n\t\t\t\t} else if ( diffPointer.substring( 0, diffs[ pointer + 1 ][ 1 ].length ) ===\n\t\t\t\t\t\tdiffs[ pointer + 1 ][ 1 ] ) {\n\n\t\t\t\t\t// Shift the edit over the next equality.\n\t\t\t\t\tdiffs[ pointer - 1 ][ 1 ] += diffs[ pointer + 1 ][ 1 ];\n\t\t\t\t\tdiffs[ pointer ][ 1 ] =\n\t\t\t\t\t\tdiffs[ pointer ][ 1 ].substring( diffs[ pointer + 1 ][ 1 ].length ) +\n\t\t\t\t\t\tdiffs[ pointer + 1 ][ 1 ];\n\t\t\t\t\tdiffs.splice( pointer + 1, 1 );\n\t\t\t\t\tchanges = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tpointer++;\n\t\t}\n\n\t\t// If shifts were made, the diff needs reordering and another shift sweep.\n\t\tif ( changes ) {\n\t\t\tthis.diffCleanupMerge( diffs );\n\t\t}\n\t};\n\n\treturn function( o, n ) {\n\t\tvar diff, output, text;\n\t\tdiff = new DiffMatchPatch();\n\t\toutput = diff.DiffMain( o, n );\n\t\tdiff.diffCleanupEfficiency( output );\n\t\ttext = diff.diffPrettyHtml( output );\n\n\t\treturn text;\n\t};\n}() );\n\n}() );\n';
    loader.global.define = undefined;
    loader.global.module = undefined;
    loader.global.exports = undefined;
    loader.__exec({
        'source': source,
        'address': module.uri
    });
    loader.global.require = require;
    loader.global.define = define;
    return loader.get('@@global-helpers').retrieveGlobal(module.id, 'QUnit');
});
/*steal-css@1.3.2#css*/
define('steal-css@1.3.2#css', [
    'require',
    'exports',
    'module',
    '@loader',
    '@steal'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        var loader = require('@loader');
        var steal = require('@steal');
        var isNode = typeof process === 'object' && {}.toString.call(process) === '[object process]';
        var importRegEx = /@import [^uU]['"]?([^'"\)]*)['"]?/g;
        var resourceRegEx = /url\(['"]?([^'"\)]*)['"]?\)/g;
        var waitSeconds = loader.cssOptions && loader.cssOptions.timeout ? parseInt(loader.cssOptions.timeout, 10) : 60;
        var onloadCss = function (link, cb) {
            var styleSheets = getDocument().styleSheets, i = styleSheets.length;
            while (i--) {
                if (styleSheets[i].href === link.href) {
                    return cb();
                }
            }
            setTimeout(function () {
                onloadCss(link, cb);
            });
        };
        function isIE9() {
            var doc = getDocument();
            return doc && !!Function('/*@cc_on return (/^9/.test(@_jscript_version) && /MSIE 9.0(?!.*IEMobile)/i.test(navigator.userAgent)); @*/')();
        }
        function getDocument() {
            if (typeof doneSsr !== 'undefined' && doneSsr.globalDocument) {
                return doneSsr.globalDocument;
            }
            if (typeof document !== 'undefined') {
                return document;
            }
            throw new Error('Unable to load CSS in an environment without a document.');
        }
        function getHead() {
            var doc = getDocument();
            var head = doc.head || doc.getElementsByTagName('head')[0];
            if (!head) {
                var docEl = doc.documentElement || doc;
                head = doc.createElement('head');
                docEl.insertBefore(head, docEl.firstChild);
            }
            return head;
        }
        function CSSModule(load, loader) {
            if (typeof load === 'object') {
                this.load = load;
                this.loader = loader;
                this.address = this.load.address;
                this.source = this.load.source;
            } else {
                this.address = load;
                this.source = loader;
            }
        }
        CSSModule.cssCount = 0;
        CSSModule.ie9MaxStyleSheets = 31;
        CSSModule.currentStyleSheet = null;
        CSSModule.prototype = {
            injectLink: function () {
                if (this._loaded) {
                    return this._loaded;
                }
                if (this.linkExists()) {
                    this._loaded = Promise.resolve('');
                    return this._loaded;
                }
                var doc = getDocument();
                var link = this.link = doc.createElement('link');
                link.type = 'text/css';
                link.rel = 'stylesheet';
                link.href = this.address;
                this._loaded = new Promise(function (resolve, reject) {
                    var timeout = setTimeout(function () {
                        reject('Unable to load CSS');
                    }, waitSeconds * 1000);
                    var loadCB = function (event) {
                        clearTimeout(timeout);
                        link.removeEventListener('load', loadCB);
                        link.removeEventListener('error', loadCB);
                        if (event && event.type === 'error') {
                            reject('Unable to load CSS');
                        } else {
                            resolve('');
                        }
                    };
                    if ('isApplicationInstalled' in navigator || !link.addEventListener) {
                        onloadCss(link, loadCB);
                    } else if (navigator.noUI) {
                        loadCB();
                    } else {
                        link.addEventListener('load', loadCB);
                        link.addEventListener('error', loadCB);
                    }
                    getHead().appendChild(link);
                });
                return this._loaded;
            },
            injectStyle: function () {
                var doc = getDocument();
                var head = getHead();
                var style = this.style = doc.createElement('style');
                style.type = 'text/css';
                if (style.sheet) {
                    style.sheet.cssText = this.source;
                } else if (style.styleSheet) {
                    style.styleSheet.cssText = this.source;
                } else {
                    style.appendChild(doc.createTextNode(this.source));
                }
                head.appendChild(style);
            },
            ie9StyleSheetLimitHack: function () {
                var doc = getDocument();
                if (!CSSModule.cssCount) {
                    CSSModule.currentStyleSheet = doc.createStyleSheet();
                }
                CSSModule.cssCount += 1;
                CSSModule.currentStyleSheet.cssText += this.source;
                if (CSSModule.cssCount === CSSModule.ie9MaxStyleSheets) {
                    CSSModule.cssCount = 0;
                }
            },
            updateURLs: function () {
                var rawSource = this.source, address = this.address;
                this.source = rawSource.replace(importRegEx, function (whole, part) {
                    if (isNode) {
                        return '@import url(' + part + ')';
                    } else {
                        return '@import url(' + steal.joinURIs(address, part) + ')';
                    }
                });
                if (!loader.isEnv('build')) {
                    this.source = this.source + '/*# sourceURL=' + address + ' */';
                    this.source = this.source.replace(resourceRegEx, function (whole, part) {
                        return 'url(' + steal.joinURIs(address, part) + ')';
                    });
                }
                return this.source;
            },
            getExistingNode: function () {
                var doc = getDocument();
                var selector = '[href=\'' + this.address + '\']';
                return doc.querySelector && doc.querySelector(selector);
            },
            linkExists: function () {
                var styleSheets = getDocument().styleSheets;
                for (var i = 0; i < styleSheets.length; ++i) {
                    if (this.address === styleSheets[i].href) {
                        return true;
                    }
                }
                return false;
            },
            setupLiveReload: function (loader, name) {
                var head = getHead();
                var css = this;
                if (loader.liveReloadInstalled) {
                    var cssReload = loader['import']('live-reload', { name: module.id });
                    Promise.resolve(cssReload).then(function (reload) {
                        loader['import'](name).then(function () {
                            reload.once('!dispose/' + name, function () {
                                css.style.__isDirty = true;
                                reload.once('!cycleComplete', function () {
                                    head.removeChild(css.style);
                                });
                            });
                        });
                    });
                }
            }
        };
        if (loader.isEnv('production')) {
            exports.fetch = function (load) {
                var css = new CSSModule(load.address);
                return css.injectLink();
            };
        } else {
            exports.instantiate = function (load) {
                var loader = this;
                var css = new CSSModule(load.address, load.source);
                load.source = css.updateURLs();
                load.metadata.deps = [];
                load.metadata.format = 'css';
                load.metadata.execute = function () {
                    if (getDocument()) {
                        if (isIE9()) {
                            css.ie9StyleSheetLimitHack();
                        } else {
                            css.injectStyle();
                        }
                        css.setupLiveReload(loader, load.name);
                    }
                    return loader.newModule({ source: css.source });
                };
            };
        }
        exports.CSSModule = CSSModule;
        exports.getDocument = getDocument;
        exports.getHead = getHead;
        exports.locateScheme = true;
        exports.buildType = 'css';
        exports.includeInBuild = true;
        exports.pluginBuilder = 'steal-css/slim';
    }(function () {
        return this;
    }(), require, exports, module));
});
/*steal-qunit@1.0.1#steal-qunit*/
'format amd';
define('steal-qunit@1.0.1#steal-qunit', [
    '@loader',
    'qunitjs/qunit/qunit',
    'qunitjs/qunit/qunit.css'
], function (loader, QUnit) {
    if (loader.has('live-reload')) {
        setupLiveReload();
    }
    setupSauceLabsReporting();
    function setupLiveReload() {
        QUnit.done(updateResults);
        function findModule(name) {
            var mods = QUnit.config.modules;
            return mods.filter(function (mod) {
                return mod.name === name;
            }).pop();
        }
        function findTestResult(mod, id) {
            var tests = mod.tests || [];
            return tests.filter(function (test) {
                return test.testId === id;
            })[0];
        }
        function updateResults() {
            var tests = document.getElementById('qunit-tests').children;
            var node, id, test, moduleName, mod;
            passed = true, removedNodes = [];
            for (var i = 0, len = tests.length; i < len; i++) {
                node = tests.item(i);
                id = node.id.split('-').pop();
                moduleName = node.querySelector('.module-name').textContent;
                mod = findModule(moduleName);
                test = findTestResult(mod, id);
                if (test) {
                    removeAllButLast(node, 'runtime');
                    if (node.className !== 'pass') {
                        passed = false;
                        break;
                    }
                } else {
                    removedNodes.push(node);
                }
            }
            removedNodes.forEach(function (node) {
                node.parentNode.removeChild(node);
            });
            document.getElementById('qunit-banner').className = passed ? 'qunit-pass' : 'qunit-fail';
        }
        function removeAllButLast(parent, className) {
            var node, nodes = [];
            var children = parent.children;
            for (var i = 0, len = children.length; i < len; i++) {
                node = children.item(i);
                if (node.className === className)
                    nodes.push(node);
            }
            while (nodes.length > 1) {
                node = nodes.shift();
                parent.removeChild(node);
            }
        }
    }
    function setupSauceLabsReporting() {
        var log = [];
        QUnit.done(function (test_results) {
            var tests = [];
            for (var i = 0, len = log.length; i < len; i++) {
                var details = log[i];
                tests.push({
                    name: details.name,
                    result: details.result,
                    expected: details.expected,
                    actual: details.actual,
                    source: details.source
                });
            }
            test_results.tests = tests;
            window.global_test_results = test_results;
        });
        QUnit.testStart(function (testDetails) {
            QUnit.log(function (details) {
                if (!details.result) {
                    details.name = testDetails.name;
                    log.push(details);
                }
            });
        });
    }
    QUnit.config.autorun = false;
    steal.done().then(function () {
        if (window.Testee && window.Testee.init) {
            Testee.init();
        }
        QUnit.load();
    });
    return QUnit;
});
/*can-namespace@1.0.0#can-namespace*/
define('can-namespace@1.0.0#can-namespace', function (require, exports, module) {
    module.exports = {};
});
/*can-symbol@1.6.0#can-symbol*/
define('can-symbol@1.6.0#can-symbol', [
    'require',
    'exports',
    'module',
    'can-namespace'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        var namespace = require('can-namespace');
        var CanSymbol;
        if (typeof Symbol !== 'undefined' && typeof Symbol.for === 'function') {
            CanSymbol = Symbol;
        } else {
            var symbolNum = 0;
            CanSymbol = function CanSymbolPolyfill(description) {
                var symbolValue = '@@symbol' + symbolNum++ + description;
                var symbol = {};
                Object.defineProperties(symbol, {
                    toString: {
                        value: function () {
                            return symbolValue;
                        }
                    }
                });
                return symbol;
            };
            var descriptionToSymbol = {};
            var symbolToDescription = {};
            CanSymbol.for = function (description) {
                var symbol = descriptionToSymbol[description];
                if (!symbol) {
                    symbol = descriptionToSymbol[description] = CanSymbol(description);
                    symbolToDescription[symbol] = description;
                }
                return symbol;
            };
            CanSymbol.keyFor = function (symbol) {
                return symbolToDescription[symbol];
            };
            [
                'hasInstance',
                'isConcatSpreadable',
                'iterator',
                'match',
                'prototype',
                'replace',
                'search',
                'species',
                'split',
                'toPrimitive',
                'toStringTag',
                'unscopables'
            ].forEach(function (name) {
                CanSymbol[name] = CanSymbol('Symbol.' + name);
            });
        }
        [
            'isMapLike',
            'isListLike',
            'isValueLike',
            'isFunctionLike',
            'getOwnKeys',
            'getOwnKeyDescriptor',
            'proto',
            'getOwnEnumerableKeys',
            'hasOwnKey',
            'hasKey',
            'size',
            'getName',
            'getIdentity',
            'assignDeep',
            'updateDeep',
            'getValue',
            'setValue',
            'getKeyValue',
            'setKeyValue',
            'updateValues',
            'addValue',
            'removeValues',
            'apply',
            'new',
            'onValue',
            'offValue',
            'onKeyValue',
            'offKeyValue',
            'getKeyDependencies',
            'getValueDependencies',
            'keyHasDependencies',
            'valueHasDependencies',
            'onKeys',
            'onKeysAdded',
            'onKeysRemoved',
            'onPatches'
        ].forEach(function (name) {
            CanSymbol.for('can.' + name);
        });
        module.exports = namespace.Symbol = CanSymbol;
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-reflect@1.13.2#reflections/helpers*/
define('can-reflect@1.13.2#reflections/helpers', [
    'require',
    'exports',
    'module',
    'can-symbol'
], function (require, exports, module) {
    var canSymbol = require('can-symbol');
    module.exports = {
        makeGetFirstSymbolValue: function (symbolNames) {
            var symbols = symbolNames.map(function (name) {
                return canSymbol.for(name);
            });
            var length = symbols.length;
            return function getFirstSymbol(obj) {
                var index = -1;
                while (++index < length) {
                    if (obj[symbols[index]] !== undefined) {
                        return obj[symbols[index]];
                    }
                }
            };
        },
        hasLength: function (list) {
            var type = typeof list;
            var length = list && type !== 'boolean' && typeof list !== 'number' && 'length' in list && list.length;
            return typeof list !== 'function' && (length === 0 || typeof length === 'number' && length > 0 && length - 1 in list);
        }
    };
});
/*can-reflect@1.13.2#reflections/type/type*/
define('can-reflect@1.13.2#reflections/type/type', [
    'require',
    'exports',
    'module',
    'can-symbol',
    '../helpers'
], function (require, exports, module) {
    var canSymbol = require('can-symbol');
    var helpers = require('../helpers');
    var plainFunctionPrototypePropertyNames = Object.getOwnPropertyNames(function () {
    }.prototype);
    var plainFunctionPrototypeProto = Object.getPrototypeOf(function () {
    }.prototype);
    function isConstructorLike(func) {
        var value = func[canSymbol.for('can.new')];
        if (value !== undefined) {
            return value;
        }
        if (typeof func !== 'function') {
            return false;
        }
        var prototype = func.prototype;
        if (!prototype) {
            return false;
        }
        if (plainFunctionPrototypeProto !== Object.getPrototypeOf(prototype)) {
            return true;
        }
        var propertyNames = Object.getOwnPropertyNames(prototype);
        if (propertyNames.length === plainFunctionPrototypePropertyNames.length) {
            for (var i = 0, len = propertyNames.length; i < len; i++) {
                if (propertyNames[i] !== plainFunctionPrototypePropertyNames[i]) {
                    return true;
                }
            }
            return false;
        } else {
            return true;
        }
    }
    var getNewOrApply = helpers.makeGetFirstSymbolValue([
        'can.new',
        'can.apply'
    ]);
    function isFunctionLike(obj) {
        var result, symbolValue = obj[canSymbol.for('can.isFunctionLike')];
        if (symbolValue !== undefined) {
            return symbolValue;
        }
        result = getNewOrApply(obj);
        if (result !== undefined) {
            return !!result;
        }
        return typeof obj === 'function';
    }
    function isPrimitive(obj) {
        var type = typeof obj;
        if (obj == null || type !== 'function' && type !== 'object') {
            return true;
        } else {
            return false;
        }
    }
    function isBuiltIn(obj) {
        if (isPrimitive(obj) || Array.isArray(obj) || isPlainObject(obj) || Object.prototype.toString.call(obj) !== '[object Object]' && Object.prototype.toString.call(obj).indexOf('[object ') !== -1) {
            return true;
        } else {
            return false;
        }
    }
    function isValueLike(obj) {
        var symbolValue;
        if (isPrimitive(obj)) {
            return true;
        }
        symbolValue = obj[canSymbol.for('can.isValueLike')];
        if (typeof symbolValue !== 'undefined') {
            return symbolValue;
        }
        var value = obj[canSymbol.for('can.getValue')];
        if (value !== undefined) {
            return !!value;
        }
    }
    function isMapLike(obj) {
        if (isPrimitive(obj)) {
            return false;
        }
        var isMapLike = obj[canSymbol.for('can.isMapLike')];
        if (typeof isMapLike !== 'undefined') {
            return !!isMapLike;
        }
        var value = obj[canSymbol.for('can.getKeyValue')];
        if (value !== undefined) {
            return !!value;
        }
        return true;
    }
    var onValueSymbol = canSymbol.for('can.onValue'), onKeyValueSymbol = canSymbol.for('can.onKeyValue'), onPatchesSymbol = canSymbol.for('can.onPatches');
    function isObservableLike(obj) {
        if (isPrimitive(obj)) {
            return false;
        }
        return Boolean(obj[onValueSymbol] || obj[onKeyValueSymbol] || obj[onPatchesSymbol]);
    }
    function isListLike(list) {
        var symbolValue, type = typeof list;
        if (type === 'string') {
            return true;
        }
        if (isPrimitive(list)) {
            return false;
        }
        symbolValue = list[canSymbol.for('can.isListLike')];
        if (typeof symbolValue !== 'undefined') {
            return symbolValue;
        }
        var value = list[canSymbol.iterator];
        if (value !== undefined) {
            return !!value;
        }
        if (Array.isArray(list)) {
            return true;
        }
        return helpers.hasLength(list);
    }
    var supportsSymbols = typeof Symbol !== 'undefined' && typeof Symbol.for === 'function';
    var isSymbolLike;
    if (supportsSymbols) {
        isSymbolLike = function (symbol) {
            return typeof symbol === 'symbol';
        };
    } else {
        var symbolStart = '@@symbol';
        isSymbolLike = function (symbol) {
            if (typeof symbol === 'object' && !Array.isArray(symbol)) {
                return symbol.toString().substr(0, symbolStart.length) === symbolStart;
            } else {
                return false;
            }
        };
    }
    var coreHasOwn = Object.prototype.hasOwnProperty;
    var funcToString = Function.prototype.toString;
    var objectCtorString = funcToString.call(Object);
    function isPlainObject(obj) {
        if (!obj || typeof obj !== 'object') {
            return false;
        }
        var proto = Object.getPrototypeOf(obj);
        if (proto === Object.prototype || proto === null) {
            return true;
        }
        var Constructor = coreHasOwn.call(proto, 'constructor') && proto.constructor;
        return typeof Constructor === 'function' && Constructor instanceof Constructor && funcToString.call(Constructor) === objectCtorString;
    }
    module.exports = {
        isConstructorLike: isConstructorLike,
        isFunctionLike: isFunctionLike,
        isListLike: isListLike,
        isMapLike: isMapLike,
        isObservableLike: isObservableLike,
        isPrimitive: isPrimitive,
        isBuiltIn: isBuiltIn,
        isValueLike: isValueLike,
        isSymbolLike: isSymbolLike,
        isMoreListLikeThanMapLike: function (obj) {
            if (Array.isArray(obj)) {
                return true;
            }
            if (obj instanceof Array) {
                return true;
            }
            var value = obj[canSymbol.for('can.isMoreListLikeThanMapLike')];
            if (value !== undefined) {
                return value;
            }
            var isListLike = this.isListLike(obj), isMapLike = this.isMapLike(obj);
            if (isListLike && !isMapLike) {
                return true;
            } else if (!isListLike && isMapLike) {
                return false;
            }
        },
        isIteratorLike: function (obj) {
            return obj && typeof obj === 'object' && typeof obj.next === 'function' && obj.next.length === 0;
        },
        isPromise: function (obj) {
            return obj instanceof Promise || Object.prototype.toString.call(obj) === '[object Promise]';
        },
        isPlainObject: isPlainObject
    };
});
/*can-reflect@1.13.2#reflections/call/call*/
define('can-reflect@1.13.2#reflections/call/call', [
    'require',
    'exports',
    'module',
    'can-symbol',
    '../type/type'
], function (require, exports, module) {
    var canSymbol = require('can-symbol');
    var typeReflections = require('../type/type');
    module.exports = {
        call: function (func, context) {
            var args = [].slice.call(arguments, 2);
            var apply = func[canSymbol.for('can.apply')];
            if (apply) {
                return apply.call(func, context, args);
            } else {
                return func.apply(context, args);
            }
        },
        apply: function (func, context, args) {
            var apply = func[canSymbol.for('can.apply')];
            if (apply) {
                return apply.call(func, context, args);
            } else {
                return func.apply(context, args);
            }
        },
        'new': function (func) {
            var args = [].slice.call(arguments, 1);
            var makeNew = func[canSymbol.for('can.new')];
            if (makeNew) {
                return makeNew.apply(func, args);
            } else {
                var context = Object.create(func.prototype);
                var ret = func.apply(context, args);
                if (typeReflections.isPrimitive(ret)) {
                    return context;
                } else {
                    return ret;
                }
            }
        }
    };
});
/*can-reflect@1.13.2#reflections/get-set/get-set*/
define('can-reflect@1.13.2#reflections/get-set/get-set', [
    'require',
    'exports',
    'module',
    'can-symbol',
    '../type/type'
], function (require, exports, module) {
    var canSymbol = require('can-symbol');
    var typeReflections = require('../type/type');
    var setKeyValueSymbol = canSymbol.for('can.setKeyValue'), getKeyValueSymbol = canSymbol.for('can.getKeyValue'), getValueSymbol = canSymbol.for('can.getValue'), setValueSymbol = canSymbol.for('can.setValue');
    var reflections = {
        setKeyValue: function (obj, key, value) {
            if (typeReflections.isSymbolLike(key)) {
                if (typeof key === 'symbol') {
                    obj[key] = value;
                } else {
                    Object.defineProperty(obj, key, {
                        enumerable: false,
                        configurable: true,
                        value: value,
                        writable: true
                    });
                }
                return;
            }
            var setKeyValue = obj[setKeyValueSymbol];
            if (setKeyValue !== undefined) {
                return setKeyValue.call(obj, key, value);
            } else {
                obj[key] = value;
            }
        },
        getKeyValue: function (obj, key) {
            var getKeyValue = obj[getKeyValueSymbol];
            if (getKeyValue) {
                return getKeyValue.call(obj, key);
            }
            return obj[key];
        },
        deleteKeyValue: function (obj, key) {
            var deleteKeyValue = obj[canSymbol.for('can.deleteKeyValue')];
            if (deleteKeyValue) {
                return deleteKeyValue.call(obj, key);
            }
            delete obj[key];
        },
        getValue: function (value) {
            if (typeReflections.isPrimitive(value)) {
                return value;
            }
            var getValue = value[getValueSymbol];
            if (getValue) {
                return getValue.call(value);
            }
            return value;
        },
        setValue: function (item, value) {
            var setValue = item && item[setValueSymbol];
            if (setValue) {
                return setValue.call(item, value);
            } else {
                throw new Error('can-reflect.setValue - Can not set value.');
            }
        },
        splice: function (obj, index, removing, adding) {
            var howMany;
            if (typeof removing !== 'number') {
                var updateValues = obj[canSymbol.for('can.updateValues')];
                if (updateValues) {
                    return updateValues.call(obj, index, removing, adding);
                }
                howMany = removing.length;
            } else {
                howMany = removing;
            }
            var splice = obj[canSymbol.for('can.splice')];
            if (splice) {
                return splice.call(obj, index, howMany, adding);
            }
            return [].splice.apply(obj, [
                index,
                howMany
            ].concat(adding));
        },
        addValues: function (obj, adding, index) {
            var add = obj[canSymbol.for('can.addValues')];
            if (add) {
                return add.call(obj, adding, index);
            }
            if (Array.isArray(obj) && index === undefined) {
                return obj.push.apply(obj, adding);
            }
            return reflections.splice(obj, index, [], adding);
        },
        removeValues: function (obj, removing, index) {
            var removeValues = obj[canSymbol.for('can.removeValues')];
            if (removeValues) {
                return removeValues.call(obj, removing, index);
            }
            if (Array.isArray(obj) && index === undefined) {
                removing.forEach(function (item) {
                    var index = obj.indexOf(item);
                    if (index >= 0) {
                        obj.splice(index, 1);
                    }
                });
                return;
            }
            return reflections.splice(obj, index, removing, []);
        }
    };
    reflections.get = reflections.getKeyValue;
    reflections.set = reflections.setKeyValue;
    reflections['delete'] = reflections.deleteKeyValue;
    module.exports = reflections;
});
/*can-reflect@1.13.2#reflections/observe/observe*/
define('can-reflect@1.13.2#reflections/observe/observe', [
    'require',
    'exports',
    'module',
    'can-symbol'
], function (require, exports, module) {
    var canSymbol = require('can-symbol');
    var slice = [].slice;
    function makeFallback(symbolName, fallbackName) {
        return function (obj, event, handler, queueName) {
            var method = obj[canSymbol.for(symbolName)];
            if (method !== undefined) {
                return method.call(obj, event, handler, queueName);
            }
            return this[fallbackName].apply(this, arguments);
        };
    }
    function makeErrorIfMissing(symbolName, errorMessage) {
        return function (obj) {
            var method = obj[canSymbol.for(symbolName)];
            if (method !== undefined) {
                var args = slice.call(arguments, 1);
                return method.apply(obj, args);
            }
            throw new Error(errorMessage);
        };
    }
    module.exports = {
        onKeyValue: makeFallback('can.onKeyValue', 'onEvent'),
        offKeyValue: makeFallback('can.offKeyValue', 'offEvent'),
        onKeys: makeErrorIfMissing('can.onKeys', 'can-reflect: can not observe an onKeys event'),
        onKeysAdded: makeErrorIfMissing('can.onKeysAdded', 'can-reflect: can not observe an onKeysAdded event'),
        onKeysRemoved: makeErrorIfMissing('can.onKeysRemoved', 'can-reflect: can not unobserve an onKeysRemoved event'),
        getKeyDependencies: makeErrorIfMissing('can.getKeyDependencies', 'can-reflect: can not determine dependencies'),
        getWhatIChange: makeErrorIfMissing('can.getWhatIChange', 'can-reflect: can not determine dependencies'),
        getChangesDependencyRecord: function getChangesDependencyRecord(handler) {
            var fn = handler[canSymbol.for('can.getChangesDependencyRecord')];
            if (typeof fn === 'function') {
                return fn();
            }
        },
        keyHasDependencies: makeErrorIfMissing('can.keyHasDependencies', 'can-reflect: can not determine if this has key dependencies'),
        onValue: makeErrorIfMissing('can.onValue', 'can-reflect: can not observe value change'),
        offValue: makeErrorIfMissing('can.offValue', 'can-reflect: can not unobserve value change'),
        getValueDependencies: makeErrorIfMissing('can.getValueDependencies', 'can-reflect: can not determine dependencies'),
        valueHasDependencies: makeErrorIfMissing('can.valueHasDependencies', 'can-reflect: can not determine if value has dependencies'),
        onPatches: makeErrorIfMissing('can.onPatches', 'can-reflect: can not observe patches on object'),
        offPatches: makeErrorIfMissing('can.offPatches', 'can-reflect: can not unobserve patches on object'),
        onInstancePatches: makeErrorIfMissing('can.onInstancePatches', 'can-reflect: can not observe onInstancePatches on Type'),
        offInstancePatches: makeErrorIfMissing('can.offInstancePatches', 'can-reflect: can not unobserve onInstancePatches on Type'),
        onInstanceBoundChange: makeErrorIfMissing('can.onInstanceBoundChange', 'can-reflect: can not observe bound state change in instances.'),
        offInstanceBoundChange: makeErrorIfMissing('can.offInstanceBoundChange', 'can-reflect: can not unobserve bound state change'),
        isBound: makeErrorIfMissing('can.isBound', 'can-reflect: cannot determine if object is bound'),
        onEvent: function (obj, eventName, callback, queue) {
            if (obj) {
                var onEvent = obj[canSymbol.for('can.onEvent')];
                if (onEvent !== undefined) {
                    return onEvent.call(obj, eventName, callback, queue);
                } else if (obj.addEventListener) {
                    obj.addEventListener(eventName, callback, queue);
                }
            }
        },
        offEvent: function (obj, eventName, callback, queue) {
            if (obj) {
                var offEvent = obj[canSymbol.for('can.offEvent')];
                if (offEvent !== undefined) {
                    return offEvent.call(obj, eventName, callback, queue);
                } else if (obj.removeEventListener) {
                    obj.removeEventListener(eventName, callback, queue);
                }
            }
        },
        setPriority: function (obj, priority) {
            if (obj) {
                var setPriority = obj[canSymbol.for('can.setPriority')];
                if (setPriority !== undefined) {
                    setPriority.call(obj, priority);
                    return true;
                }
            }
            return false;
        },
        getPriority: function (obj) {
            if (obj) {
                var getPriority = obj[canSymbol.for('can.getPriority')];
                if (getPriority !== undefined) {
                    return getPriority.call(obj);
                }
            }
            return undefined;
        }
    };
});
/*can-reflect@1.13.2#reflections/shape/shape*/
define('can-reflect@1.13.2#reflections/shape/shape', [
    'require',
    'exports',
    'module',
    'can-symbol',
    '../get-set/get-set',
    '../type/type',
    '../helpers'
], function (require, exports, module) {
    var canSymbol = require('can-symbol');
    var getSetReflections = require('../get-set/get-set');
    var typeReflections = require('../type/type');
    var helpers = require('../helpers');
    var ArrayMap;
    if (typeof Map === 'function') {
        ArrayMap = Map;
    } else {
        function isEven(num) {
            return !(num % 2);
        }
        ArrayMap = function () {
            this.contents = [];
        };
        ArrayMap.prototype = {
            _getIndex: function (key) {
                var idx;
                do {
                    idx = this.contents.indexOf(key, idx);
                } while (idx !== -1 && !isEven(idx));
                return idx;
            },
            has: function (key) {
                return this._getIndex(key) !== -1;
            },
            get: function (key) {
                var idx = this._getIndex(key);
                if (idx !== -1) {
                    return this.contents[idx + 1];
                }
            },
            set: function (key, value) {
                var idx = this._getIndex(key);
                if (idx !== -1) {
                    this.contents[idx + 1] = value;
                } else {
                    this.contents.push(key);
                    this.contents.push(value);
                }
            }
        };
    }
    var shapeReflections;
    var shiftFirstArgumentToThis = function (func) {
        return function () {
            var args = [this];
            args.push.apply(args, arguments);
            return func.apply(null, args);
        };
    };
    var getKeyValueSymbol = canSymbol.for('can.getKeyValue');
    var shiftedGetKeyValue = shiftFirstArgumentToThis(getSetReflections.getKeyValue);
    var setKeyValueSymbol = canSymbol.for('can.setKeyValue');
    var shiftedSetKeyValue = shiftFirstArgumentToThis(getSetReflections.setKeyValue);
    var sizeSymbol = canSymbol.for('can.size');
    var serializeMap = null;
    var hasUpdateSymbol = helpers.makeGetFirstSymbolValue([
        'can.updateDeep',
        'can.assignDeep',
        'can.setKeyValue'
    ]);
    var shouldUpdateOrAssign = function (obj) {
        return typeReflections.isPlainObject(obj) || Array.isArray(obj) || !!hasUpdateSymbol(obj);
    };
    function isSerializable(obj) {
        if (typeReflections.isPrimitive(obj)) {
            return true;
        }
        if (hasUpdateSymbol(obj)) {
            return false;
        }
        return typeReflections.isBuiltIn(obj) && !typeReflections.isPlainObject(obj);
    }
    var Object_Keys;
    try {
        Object.keys(1);
        Object_Keys = Object.keys;
    } catch (e) {
        Object_Keys = function (obj) {
            if (typeReflections.isPrimitive(obj)) {
                return [];
            } else {
                return Object.keys(obj);
            }
        };
    }
    function makeSerializer(methodName, symbolsToCheck) {
        return function serializer(value, MapType) {
            if (isSerializable(value)) {
                return value;
            }
            var firstSerialize;
            if (!serializeMap) {
                serializeMap = {
                    unwrap: MapType ? new MapType() : new ArrayMap(),
                    serialize: MapType ? new MapType() : new ArrayMap()
                };
                firstSerialize = true;
            }
            var serialized;
            if (typeReflections.isValueLike(value)) {
                serialized = this[methodName](getSetReflections.getValue(value));
            } else {
                var isListLike = typeReflections.isIteratorLike(value) || typeReflections.isMoreListLikeThanMapLike(value);
                serialized = isListLike ? [] : {};
                if (serializeMap) {
                    if (serializeMap[methodName].has(value)) {
                        return serializeMap[methodName].get(value);
                    } else {
                        serializeMap[methodName].set(value, serialized);
                    }
                }
                for (var i = 0, len = symbolsToCheck.length; i < len; i++) {
                    var serializer = value[symbolsToCheck[i]];
                    if (serializer) {
                        var result = serializer.call(value, serialized);
                        if (firstSerialize) {
                            serializeMap = null;
                        }
                        return result;
                    }
                }
                if (typeof obj === 'function') {
                    if (serializeMap) {
                        serializeMap[methodName].set(value, value);
                    }
                    serialized = value;
                } else if (isListLike) {
                    this.eachIndex(value, function (childValue, index) {
                        serialized[index] = this[methodName](childValue);
                    }, this);
                } else {
                    this.eachKey(value, function (childValue, prop) {
                        serialized[prop] = this[methodName](childValue);
                    }, this);
                }
            }
            if (firstSerialize) {
                serializeMap = null;
            }
            return serialized;
        };
    }
    var makeMap;
    if (typeof Map !== 'undefined') {
        makeMap = function (keys) {
            var map = new Map();
            shapeReflections.eachIndex(keys, function (key) {
                map.set(key, true);
            });
            return map;
        };
    } else {
        makeMap = function (keys) {
            var map = {};
            keys.forEach(function (key) {
                map[key] = true;
            });
            return {
                get: function (key) {
                    return map[key];
                },
                set: function (key, value) {
                    map[key] = value;
                },
                keys: function () {
                    return keys;
                }
            };
        };
    }
    var fastHasOwnKey = function (obj) {
        var hasOwnKey = obj[canSymbol.for('can.hasOwnKey')];
        if (hasOwnKey) {
            return hasOwnKey.bind(obj);
        } else {
            var map = makeMap(shapeReflections.getOwnEnumerableKeys(obj));
            return function (key) {
                return map.get(key);
            };
        }
    };
    function addPatch(patches, patch) {
        var lastPatch = patches[patches.length - 1];
        if (lastPatch) {
            if (lastPatch.deleteCount === lastPatch.insert.length && patch.index - lastPatch.index === lastPatch.deleteCount) {
                lastPatch.insert.push.apply(lastPatch.insert, patch.insert);
                lastPatch.deleteCount += patch.deleteCount;
                return;
            }
        }
        patches.push(patch);
    }
    function updateDeepList(target, source, isAssign) {
        var sourceArray = this.toArray(source);
        var patches = [], lastIndex = -1;
        this.eachIndex(target, function (curVal, index) {
            lastIndex = index;
            if (index >= sourceArray.length) {
                if (!isAssign) {
                    addPatch(patches, {
                        index: index,
                        deleteCount: target.length - index + 1,
                        insert: []
                    });
                }
                return false;
            }
            var newVal = sourceArray[index];
            if (typeReflections.isPrimitive(curVal) || typeReflections.isPrimitive(newVal) || shouldUpdateOrAssign(curVal) === false) {
                addPatch(patches, {
                    index: index,
                    deleteCount: 1,
                    insert: [newVal]
                });
            } else {
                this.updateDeep(curVal, newVal);
            }
        }, this);
        if (sourceArray.length > lastIndex) {
            addPatch(patches, {
                index: lastIndex + 1,
                deleteCount: 0,
                insert: sourceArray.slice(lastIndex + 1)
            });
        }
        for (var i = 0, patchLen = patches.length; i < patchLen; i++) {
            var patch = patches[i];
            getSetReflections.splice(target, patch.index, patch.deleteCount, patch.insert);
        }
        return target;
    }
    shapeReflections = {
        each: function (obj, callback, context) {
            if (typeReflections.isIteratorLike(obj) || typeReflections.isMoreListLikeThanMapLike(obj)) {
                return this.eachIndex(obj, callback, context);
            } else {
                return this.eachKey(obj, callback, context);
            }
        },
        eachIndex: function (list, callback, context) {
            if (Array.isArray(list)) {
                return this.eachListLike(list, callback, context);
            } else {
                var iter, iterator = list[canSymbol.iterator];
                if (typeReflections.isIteratorLike(list)) {
                    iter = list;
                } else if (iterator) {
                    iter = iterator.call(list);
                }
                if (iter) {
                    var res, index = 0;
                    while (!(res = iter.next()).done) {
                        if (callback.call(context || list, res.value, index++, list) === false) {
                            break;
                        }
                    }
                } else {
                    this.eachListLike(list, callback, context);
                }
            }
            return list;
        },
        eachListLike: function (list, callback, context) {
            var index = -1;
            var length = list.length;
            if (length === undefined) {
                var size = list[sizeSymbol];
                if (size) {
                    length = size.call(list);
                } else {
                    throw new Error('can-reflect: unable to iterate.');
                }
            }
            while (++index < length) {
                var item = list[index];
                if (callback.call(context || item, item, index, list) === false) {
                    break;
                }
            }
            return list;
        },
        toArray: function (obj) {
            var arr = [];
            this.each(obj, function (value) {
                arr.push(value);
            });
            return arr;
        },
        eachKey: function (obj, callback, context) {
            if (obj) {
                var enumerableKeys = this.getOwnEnumerableKeys(obj);
                var getKeyValue = obj[getKeyValueSymbol] || shiftedGetKeyValue;
                return this.eachIndex(enumerableKeys, function (key) {
                    var value = getKeyValue.call(obj, key);
                    return callback.call(context || obj, value, key, obj);
                });
            }
            return obj;
        },
        'hasOwnKey': function (obj, key) {
            var hasOwnKey = obj[canSymbol.for('can.hasOwnKey')];
            if (hasOwnKey) {
                return hasOwnKey.call(obj, key);
            }
            var getOwnKeys = obj[canSymbol.for('can.getOwnKeys')];
            if (getOwnKeys) {
                var found = false;
                this.eachIndex(getOwnKeys.call(obj), function (objKey) {
                    if (objKey === key) {
                        found = true;
                        return false;
                    }
                });
                return found;
            }
            return obj.hasOwnProperty(key);
        },
        getOwnEnumerableKeys: function (obj) {
            var getOwnEnumerableKeys = obj[canSymbol.for('can.getOwnEnumerableKeys')];
            if (getOwnEnumerableKeys) {
                return getOwnEnumerableKeys.call(obj);
            }
            if (obj[canSymbol.for('can.getOwnKeys')] && obj[canSymbol.for('can.getOwnKeyDescriptor')]) {
                var keys = [];
                this.eachIndex(this.getOwnKeys(obj), function (key) {
                    var descriptor = this.getOwnKeyDescriptor(obj, key);
                    if (descriptor.enumerable) {
                        keys.push(key);
                    }
                }, this);
                return keys;
            } else {
                return Object_Keys(obj);
            }
        },
        getOwnKeys: function (obj) {
            var getOwnKeys = obj[canSymbol.for('can.getOwnKeys')];
            if (getOwnKeys) {
                return getOwnKeys.call(obj);
            } else {
                return Object.getOwnPropertyNames(obj);
            }
        },
        getOwnKeyDescriptor: function (obj, key) {
            var getOwnKeyDescriptor = obj[canSymbol.for('can.getOwnKeyDescriptor')];
            if (getOwnKeyDescriptor) {
                return getOwnKeyDescriptor.call(obj, key);
            } else {
                return Object.getOwnPropertyDescriptor(obj, key);
            }
        },
        unwrap: makeSerializer('unwrap', [canSymbol.for('can.unwrap')]),
        serialize: makeSerializer('serialize', [
            canSymbol.for('can.serialize'),
            canSymbol.for('can.unwrap')
        ]),
        assignMap: function (target, source) {
            var hasOwnKey = fastHasOwnKey(target);
            var getKeyValue = target[getKeyValueSymbol] || shiftedGetKeyValue;
            var setKeyValue = target[setKeyValueSymbol] || shiftedSetKeyValue;
            this.eachKey(source, function (value, key) {
                if (!hasOwnKey(key) || getKeyValue.call(target, key) !== value) {
                    setKeyValue.call(target, key, value);
                }
            });
            return target;
        },
        assignList: function (target, source) {
            var inserting = this.toArray(source);
            getSetReflections.splice(target, 0, inserting, inserting);
            return target;
        },
        assign: function (target, source) {
            if (typeReflections.isIteratorLike(source) || typeReflections.isMoreListLikeThanMapLike(source)) {
                this.assignList(target, source);
            } else {
                this.assignMap(target, source);
            }
            return target;
        },
        assignDeepMap: function (target, source) {
            var hasOwnKey = fastHasOwnKey(target);
            var getKeyValue = target[getKeyValueSymbol] || shiftedGetKeyValue;
            var setKeyValue = target[setKeyValueSymbol] || shiftedSetKeyValue;
            this.eachKey(source, function (newVal, key) {
                if (!hasOwnKey(key)) {
                    getSetReflections.setKeyValue(target, key, newVal);
                } else {
                    var curVal = getKeyValue.call(target, key);
                    if (newVal === curVal) {
                    } else if (typeReflections.isPrimitive(curVal) || typeReflections.isPrimitive(newVal) || shouldUpdateOrAssign(curVal) === false) {
                        setKeyValue.call(target, key, newVal);
                    } else {
                        this.assignDeep(curVal, newVal);
                    }
                }
            }, this);
            return target;
        },
        assignDeepList: function (target, source) {
            return updateDeepList.call(this, target, source, true);
        },
        assignDeep: function (target, source) {
            var assignDeep = target[canSymbol.for('can.assignDeep')];
            if (assignDeep) {
                assignDeep.call(target, source);
            } else if (typeReflections.isMoreListLikeThanMapLike(source)) {
                this.assignDeepList(target, source);
            } else {
                this.assignDeepMap(target, source);
            }
            return target;
        },
        updateMap: function (target, source) {
            var sourceKeyMap = makeMap(this.getOwnEnumerableKeys(source));
            var sourceGetKeyValue = source[getKeyValueSymbol] || shiftedGetKeyValue;
            var targetSetKeyValue = target[setKeyValueSymbol] || shiftedSetKeyValue;
            this.eachKey(target, function (curVal, key) {
                if (!sourceKeyMap.get(key)) {
                    getSetReflections.deleteKeyValue(target, key);
                    return;
                }
                sourceKeyMap.set(key, false);
                var newVal = sourceGetKeyValue.call(source, key);
                if (newVal !== curVal) {
                    targetSetKeyValue.call(target, key, newVal);
                }
            }, this);
            this.eachIndex(sourceKeyMap.keys(), function (key) {
                if (sourceKeyMap.get(key)) {
                    targetSetKeyValue.call(target, key, sourceGetKeyValue.call(source, key));
                }
            });
            return target;
        },
        updateList: function (target, source) {
            var inserting = this.toArray(source);
            getSetReflections.splice(target, 0, target, inserting);
            return target;
        },
        update: function (target, source) {
            if (typeReflections.isIteratorLike(source) || typeReflections.isMoreListLikeThanMapLike(source)) {
                this.updateList(target, source);
            } else {
                this.updateMap(target, source);
            }
            return target;
        },
        updateDeepMap: function (target, source) {
            var sourceKeyMap = makeMap(this.getOwnEnumerableKeys(source));
            var sourceGetKeyValue = source[getKeyValueSymbol] || shiftedGetKeyValue;
            var targetSetKeyValue = target[setKeyValueSymbol] || shiftedSetKeyValue;
            this.eachKey(target, function (curVal, key) {
                if (!sourceKeyMap.get(key)) {
                    getSetReflections.deleteKeyValue(target, key);
                    return;
                }
                sourceKeyMap.set(key, false);
                var newVal = sourceGetKeyValue.call(source, key);
                if (typeReflections.isPrimitive(curVal) || typeReflections.isPrimitive(newVal) || shouldUpdateOrAssign(curVal) === false) {
                    targetSetKeyValue.call(target, key, newVal);
                } else {
                    this.updateDeep(curVal, newVal);
                }
            }, this);
            this.eachIndex(sourceKeyMap.keys(), function (key) {
                if (sourceKeyMap.get(key)) {
                    targetSetKeyValue.call(target, key, sourceGetKeyValue.call(source, key));
                }
            });
            return target;
        },
        updateDeepList: function (target, source) {
            return updateDeepList.call(this, target, source);
        },
        updateDeep: function (target, source) {
            var updateDeep = target[canSymbol.for('can.updateDeep')];
            if (updateDeep) {
                updateDeep.call(target, source);
            } else if (typeReflections.isMoreListLikeThanMapLike(source)) {
                this.updateDeepList(target, source);
            } else {
                this.updateDeepMap(target, source);
            }
            return target;
        },
        'hasKey': function (obj, key) {
            var hasKey = obj[canSymbol.for('can.hasKey')];
            if (hasKey) {
                return hasKey.call(obj, key);
            }
            var found = shapeReflections.hasOwnKey(obj, key);
            return found || key in obj;
        },
        getAllEnumerableKeys: function () {
        },
        getAllKeys: function () {
        },
        assignSymbols: function (target, source) {
            this.eachKey(source, function (value, key) {
                var symbol = typeReflections.isSymbolLike(canSymbol[key]) ? canSymbol[key] : canSymbol.for(key);
                getSetReflections.setKeyValue(target, symbol, value);
            });
            return target;
        },
        isSerializable: isSerializable,
        size: function (obj) {
            var size = obj[sizeSymbol];
            var count = 0;
            if (size) {
                return size.call(obj);
            } else if (helpers.hasLength(obj)) {
                return obj.length;
            } else if (typeReflections.isListLike(obj)) {
                this.each(obj, function () {
                    count++;
                });
                return count;
            } else if (obj) {
                for (var prop in obj) {
                    if (obj.hasOwnProperty(prop)) {
                        count++;
                    }
                }
                return count;
            } else {
                return undefined;
            }
        },
        defineInstanceKey: function (cls, key, properties) {
            var defineInstanceKey = cls[canSymbol.for('can.defineInstanceKey')];
            if (defineInstanceKey) {
                return defineInstanceKey.call(cls, key, properties);
            }
            var proto = cls.prototype;
            defineInstanceKey = proto[canSymbol.for('can.defineInstanceKey')];
            if (defineInstanceKey) {
                defineInstanceKey.call(proto, key, properties);
            } else {
                Object.defineProperty(proto, key, shapeReflections.assign({
                    configurable: true,
                    enumerable: !typeReflections.isSymbolLike(key),
                    writable: true
                }, properties));
            }
        }
    };
    shapeReflections.keys = shapeReflections.getOwnEnumerableKeys;
    module.exports = shapeReflections;
});
/*can-reflect@1.13.2#reflections/get-name/get-name*/
define('can-reflect@1.13.2#reflections/get-name/get-name', [
    'require',
    'exports',
    'module',
    'can-symbol',
    '../type/type'
], function (require, exports, module) {
    var canSymbol = require('can-symbol');
    var typeReflections = require('../type/type');
    var getNameSymbol = canSymbol.for('can.getName');
    function setName(obj, nameGetter) {
        if (typeof nameGetter !== 'function') {
            var value = nameGetter;
            nameGetter = function () {
                return value;
            };
        }
        Object.defineProperty(obj, getNameSymbol, { value: nameGetter });
    }
    function getName(obj) {
        var nameGetter = obj[getNameSymbol];
        if (nameGetter) {
            return nameGetter.call(obj);
        }
        if (typeof obj === 'function') {
            return obj.name;
        }
        if (obj.constructor && obj !== obj.constructor) {
            var parent = getName(obj.constructor);
            if (parent) {
                if (typeReflections.isValueLike(obj)) {
                    return parent + '<>';
                }
                if (typeReflections.isMoreListLikeThanMapLike(obj)) {
                    return parent + '[]';
                }
                if (typeReflections.isMapLike(obj)) {
                    return parent + '{}';
                }
            }
        }
        return undefined;
    }
    module.exports = {
        setName: setName,
        getName: getName
    };
});
/*can-reflect@1.13.2#types/map*/
define('can-reflect@1.13.2#types/map', [
    'require',
    'exports',
    'module',
    '../reflections/shape/shape',
    'can-symbol'
], function (require, exports, module) {
    var shape = require('../reflections/shape/shape');
    var CanSymbol = require('can-symbol');
    function keysPolyfill() {
        var keys = [];
        var currentIndex = 0;
        this.forEach(function (val, key) {
            keys.push(key);
        });
        return {
            next: function () {
                return {
                    value: keys[currentIndex],
                    done: currentIndex++ === keys.length
                };
            }
        };
    }
    if (typeof Map !== 'undefined') {
        shape.assignSymbols(Map.prototype, {
            'can.getOwnEnumerableKeys': Map.prototype.keys,
            'can.setKeyValue': Map.prototype.set,
            'can.getKeyValue': Map.prototype.get,
            'can.deleteKeyValue': Map.prototype['delete'],
            'can.hasOwnKey': Map.prototype.has
        });
        if (typeof Map.prototype.keys !== 'function') {
            Map.prototype.keys = Map.prototype[CanSymbol.for('can.getOwnEnumerableKeys')] = keysPolyfill;
        }
    }
    if (typeof WeakMap !== 'undefined') {
        shape.assignSymbols(WeakMap.prototype, {
            'can.getOwnEnumerableKeys': function () {
                throw new Error('can-reflect: WeakMaps do not have enumerable keys.');
            },
            'can.setKeyValue': WeakMap.prototype.set,
            'can.getKeyValue': WeakMap.prototype.get,
            'can.deleteKeyValue': WeakMap.prototype['delete'],
            'can.hasOwnKey': WeakMap.prototype.has
        });
    }
});
/*can-reflect@1.13.2#types/set*/
define('can-reflect@1.13.2#types/set', [
    'require',
    'exports',
    'module',
    '../reflections/shape/shape',
    'can-symbol'
], function (require, exports, module) {
    var shape = require('../reflections/shape/shape');
    var CanSymbol = require('can-symbol');
    if (typeof Set !== 'undefined') {
        shape.assignSymbols(Set.prototype, {
            'can.isMoreListLikeThanMapLike': true,
            'can.updateValues': function (index, removing, adding) {
                if (removing !== adding) {
                    shape.each(removing, function (value) {
                        this.delete(value);
                    }, this);
                }
                shape.each(adding, function (value) {
                    this.add(value);
                }, this);
            },
            'can.size': function () {
                return this.size;
            }
        });
        if (typeof Set.prototype[CanSymbol.iterator] !== 'function') {
            Set.prototype[CanSymbol.iterator] = function () {
                var arr = [];
                var currentIndex = 0;
                this.forEach(function (val) {
                    arr.push(val);
                });
                return {
                    next: function () {
                        return {
                            value: arr[currentIndex],
                            done: currentIndex++ === arr.length
                        };
                    }
                };
            };
        }
    }
    if (typeof WeakSet !== 'undefined') {
        shape.assignSymbols(WeakSet.prototype, {
            'can.isListLike': true,
            'can.isMoreListLikeThanMapLike': true,
            'can.updateValues': function (index, removing, adding) {
                if (removing !== adding) {
                    shape.each(removing, function (value) {
                        this.delete(value);
                    }, this);
                }
                shape.each(adding, function (value) {
                    this.add(value);
                }, this);
            },
            'can.size': function () {
                throw new Error('can-reflect: WeakSets do not have enumerable keys.');
            }
        });
    }
});
/*can-reflect@1.13.2#can-reflect*/
define('can-reflect@1.13.2#can-reflect', [
    'require',
    'exports',
    'module',
    './reflections/call/call',
    './reflections/get-set/get-set',
    './reflections/observe/observe',
    './reflections/shape/shape',
    './reflections/type/type',
    './reflections/get-name/get-name',
    'can-namespace',
    './types/map',
    './types/set'
], function (require, exports, module) {
    var functionReflections = require('./reflections/call/call');
    var getSet = require('./reflections/get-set/get-set');
    var observe = require('./reflections/observe/observe');
    var shape = require('./reflections/shape/shape');
    var type = require('./reflections/type/type');
    var getName = require('./reflections/get-name/get-name');
    var namespace = require('can-namespace');
    var reflect = {};
    [
        functionReflections,
        getSet,
        observe,
        shape,
        type,
        getName
    ].forEach(function (reflections) {
        for (var prop in reflections) {
            reflect[prop] = reflections[prop];
        }
    });
    require('./types/map');
    require('./types/set');
    module.exports = namespace.Reflect = reflect;
});
/*can-globals@1.0.0#can-globals-proto*/
define('can-globals@1.0.0#can-globals-proto', [
    'require',
    'exports',
    'module',
    'can-reflect'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        'use strict';
        var canReflect = require('can-reflect');
        function dispatch(key) {
            var handlers = this.eventHandlers[key];
            if (handlers) {
                var handlersCopy = handlers.slice();
                var value = this.getKeyValue(key);
                for (var i = 0; i < handlersCopy.length; i++) {
                    handlersCopy[i](value);
                }
            }
        }
        function Globals() {
            this.eventHandlers = {};
            this.properties = {};
        }
        Globals.prototype.define = function (key, value, enableCache) {
            if (enableCache === undefined) {
                enableCache = true;
            }
            if (!this.properties[key]) {
                this.properties[key] = {
                    default: value,
                    value: value,
                    enableCache: enableCache
                };
            }
            return this;
        };
        Globals.prototype.getKeyValue = function (key) {
            var property = this.properties[key];
            if (property) {
                if (typeof property.value === 'function') {
                    if (property.cachedValue) {
                        return property.cachedValue;
                    }
                    if (property.enableCache) {
                        property.cachedValue = property.value();
                        return property.cachedValue;
                    } else {
                        return property.value();
                    }
                }
                return property.value;
            }
        };
        Globals.prototype.makeExport = function (key) {
            return function (value) {
                if (arguments.length === 0) {
                    return this.getKeyValue(key);
                }
                if (typeof value === 'undefined' || value === null) {
                    this.deleteKeyValue(key);
                } else {
                    if (typeof value === 'function') {
                        this.setKeyValue(key, function () {
                            return value;
                        });
                    } else {
                        this.setKeyValue(key, value);
                    }
                    return value;
                }
            }.bind(this);
        };
        Globals.prototype.offKeyValue = function (key, handler) {
            if (this.properties[key]) {
                var handlers = this.eventHandlers[key];
                if (handlers) {
                    var i = handlers.indexOf(handler);
                    handlers.splice(i, 1);
                }
            }
            return this;
        };
        Globals.prototype.onKeyValue = function (key, handler) {
            if (this.properties[key]) {
                if (!this.eventHandlers[key]) {
                    this.eventHandlers[key] = [];
                }
                this.eventHandlers[key].push(handler);
            }
            return this;
        };
        Globals.prototype.deleteKeyValue = function (key) {
            var property = this.properties[key];
            if (property !== undefined) {
                property.value = property.default;
                property.cachedValue = undefined;
                dispatch.call(this, key);
            }
            return this;
        };
        Globals.prototype.setKeyValue = function (key, value) {
            if (!this.properties[key]) {
                return this.define(key, value);
            }
            var property = this.properties[key];
            property.value = value;
            property.cachedValue = undefined;
            dispatch.call(this, key);
            return this;
        };
        Globals.prototype.reset = function () {
            for (var key in this.properties) {
                if (this.properties.hasOwnProperty(key)) {
                    this.properties[key].value = this.properties[key].default;
                    this.properties[key].cachedValue = undefined;
                    dispatch.call(this, key);
                }
            }
            return this;
        };
        canReflect.assignSymbols(Globals.prototype, {
            'can.getKeyValue': Globals.prototype.getKeyValue,
            'can.setKeyValue': Globals.prototype.setKeyValue,
            'can.deleteKeyValue': Globals.prototype.deleteKeyValue,
            'can.onKeyValue': Globals.prototype.onKeyValue,
            'can.offKeyValue': Globals.prototype.offKeyValue
        });
        module.exports = Globals;
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-globals@1.0.0#can-globals-instance*/
define('can-globals@1.0.0#can-globals-instance', [
    'require',
    'exports',
    'module',
    'can-namespace',
    './can-globals-proto'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        'use strict';
        var namespace = require('can-namespace');
        var Globals = require('./can-globals-proto');
        var globals = new Globals();
        if (namespace.globals) {
            throw new Error('You can\'t have two versions of can-globals, check your dependencies');
        } else {
            module.exports = namespace.globals = globals;
        }
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-globals@1.0.0#global/global*/
define('can-globals@1.0.0#global/global', [
    'require',
    'exports',
    'module',
    'can-globals/can-globals-instance'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        'use strict';
        var globals = require('can-globals/can-globals-instance');
        globals.define('global', function () {
            return typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope ? self : typeof process === 'object' && {}.toString.call(process) === '[object process]' ? global : window;
        });
        module.exports = globals.makeExport('global');
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-globals@1.0.0#document/document*/
define('can-globals@1.0.0#document/document', [
    'require',
    'exports',
    'module',
    'can-globals/global/global',
    'can-globals/can-globals-instance'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        'use strict';
        require('can-globals/global/global');
        var globals = require('can-globals/can-globals-instance');
        globals.define('document', function () {
            return globals.getKeyValue('global').document;
        });
        module.exports = globals.makeExport('document');
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-globals@1.0.0#location/location*/
define('can-globals@1.0.0#location/location', [
    'require',
    'exports',
    'module',
    'can-globals/global/global',
    'can-globals/can-globals-instance'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        'use strict';
        require('can-globals/global/global');
        var globals = require('can-globals/can-globals-instance');
        globals.define('location', function () {
            return globals.getKeyValue('global').location;
        });
        module.exports = globals.makeExport('location');
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-globals@1.0.0#mutation-observer/mutation-observer*/
define('can-globals@1.0.0#mutation-observer/mutation-observer', [
    'require',
    'exports',
    'module',
    'can-globals/global/global',
    'can-globals/can-globals-instance'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        'use strict';
        require('can-globals/global/global');
        var globals = require('can-globals/can-globals-instance');
        globals.define('MutationObserver', function () {
            var GLOBAL = globals.getKeyValue('global');
            return GLOBAL.MutationObserver || GLOBAL.WebKitMutationObserver || GLOBAL.MozMutationObserver;
        });
        module.exports = globals.makeExport('MutationObserver');
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-globals@1.0.0#is-node/is-node*/
define('can-globals@1.0.0#is-node/is-node', [
    'require',
    'exports',
    'module',
    'can-globals/can-globals-instance'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        'use strict';
        var globals = require('can-globals/can-globals-instance');
        globals.define('isNode', function () {
            return typeof process === 'object' && {}.toString.call(process) === '[object process]';
        });
        module.exports = globals.makeExport('isNode');
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-globals@1.0.0#is-browser-window/is-browser-window*/
define('can-globals@1.0.0#is-browser-window/is-browser-window', [
    'require',
    'exports',
    'module',
    'can-globals/can-globals-instance',
    '../is-node/is-node'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        'use strict';
        var globals = require('can-globals/can-globals-instance');
        require('../is-node/is-node');
        globals.define('isBrowserWindow', function () {
            var isNode = globals.getKeyValue('isNode');
            return typeof window !== 'undefined' && typeof document !== 'undefined' && isNode === false;
        });
        module.exports = globals.makeExport('isBrowserWindow');
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-globals@1.0.0#custom-elements/custom-elements*/
define('can-globals@1.0.0#custom-elements/custom-elements', [
    'require',
    'exports',
    'module',
    'can-globals/global/global',
    'can-globals/can-globals-instance'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        'use strict';
        require('can-globals/global/global');
        var globals = require('can-globals/can-globals-instance');
        globals.define('customElements', function () {
            var GLOBAL = globals.getKeyValue('global');
            return GLOBAL.customElements;
        });
        module.exports = globals.makeExport('customElements');
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-globals@1.0.0#can-globals*/
define('can-globals@1.0.0#can-globals', [
    'require',
    'exports',
    'module',
    'can-globals/can-globals-instance',
    './global/global',
    './document/document',
    './location/location',
    './mutation-observer/mutation-observer',
    './is-browser-window/is-browser-window',
    './is-node/is-node',
    './custom-elements/custom-elements'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        'use strict';
        var globals = require('can-globals/can-globals-instance');
        require('./global/global');
        require('./document/document');
        require('./location/location');
        require('./mutation-observer/mutation-observer');
        require('./is-browser-window/is-browser-window');
        require('./is-node/is-node');
        require('./custom-elements/custom-elements');
        module.exports = globals;
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-util@3.11.2#dom/mutation-observer/mutation-observer*/
define('can-util@3.11.2#dom/mutation-observer/mutation-observer', [
    'require',
    'exports',
    'module',
    'can-globals'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        'use strict';
        var globals = require('can-globals');
        module.exports = function (setMO) {
            if (setMO !== undefined) {
                globals.setKeyValue('MutationObserver', function () {
                    return setMO;
                });
            }
            return globals.getKeyValue('MutationObserver');
        };
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-util@3.11.2#dom/document/document*/
define('can-util@3.11.2#dom/document/document', [
    'require',
    'exports',
    'module',
    'can-globals/document/document'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        'use strict';
        module.exports = require('can-globals/document/document');
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-simple-dom@1.3.4#simple-dom/document/node*/
define('can-simple-dom@1.3.4#simple-dom/document/node', ['exports'], function (exports) {
    'use strict';
    Object.defineProperty(exports, '__esModule', { value: true });
    function Node(nodeType, nodeName, nodeValue, ownerDocument) {
        this.nodeType = nodeType;
        this.nodeName = nodeName;
        this.nodeValue = nodeValue;
        this.ownerDocument = ownerDocument;
        this.childNodes = new ChildNodes(this);
        this.parentNode = null;
        this.previousSibling = null;
        this.nextSibling = null;
        this.firstChild = null;
        this.lastChild = null;
    }
    Node.prototype._cloneNode = function () {
        return new Node(this.nodeType, this.nodeName, this.nodeValue, this.ownerDocument);
    };
    Node.prototype.cloneNode = function (deep) {
        var node = this._cloneNode();
        if (deep) {
            var child = this.firstChild, nextChild = child;
            while (nextChild) {
                nextChild = child.nextSibling;
                nodeAppendChild.call(node, child.cloneNode(true));
                child = nextChild;
            }
        }
        return node;
    };
    var nodeAppendChild = Node.prototype.appendChild = function (node) {
        if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
            insertFragment(node, this, this.lastChild, null);
            return node;
        }
        if (node.parentNode) {
            nodeRemoveChild.call(node.parentNode, node);
        }
        node.parentNode = this;
        var refNode = this.lastChild;
        if (refNode === null) {
            this.firstChild = node;
            this.lastChild = node;
        } else {
            node.previousSibling = refNode;
            refNode.nextSibling = node;
            this.lastChild = node;
        }
        ensureOwnerDocument(this, node);
        return node;
    };
    function insertFragment(fragment, newParent, before, after) {
        if (!fragment.firstChild) {
            return;
        }
        var firstChild = fragment.firstChild;
        var lastChild = firstChild;
        var node = firstChild;
        firstChild.previousSibling = before;
        if (before) {
            before.nextSibling = firstChild;
        } else {
            newParent.firstChild = firstChild;
        }
        while (node) {
            node.parentNode = newParent;
            ensureOwnerDocument(newParent, node);
            lastChild = node;
            node = node.nextSibling;
        }
        lastChild.nextSibling = after;
        if (after) {
            after.previousSibling = lastChild;
        } else {
            newParent.lastChild = lastChild;
        }
        fragment.firstChild = null;
        fragment.lastChild = null;
    }
    function ensureOwnerDocument(parent, child) {
        var ownerDocument = parent.nodeType === 9 ? parent : parent.ownerDocument;
        if (parent.ownerDocument !== child.ownerDocument) {
            var node = child;
            while (node) {
                node.ownerDocument = ownerDocument;
                if (node.firstChild) {
                    ensureOwnerDocument(node, node.firstChild);
                }
                node = node.nextSibling;
            }
        }
    }
    var nodeInsertBefore = Node.prototype.insertBefore = function (node, refNode) {
        if (refNode == null) {
            return nodeAppendChild.call(this, node);
        }
        if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
            insertFragment(node, this, refNode ? refNode.previousSibling : null, refNode);
            return node;
        }
        if (node.parentNode) {
            nodeRemoveChild.call(node.parentNode, node);
        }
        node.parentNode = this;
        var previousSibling = refNode.previousSibling;
        if (previousSibling) {
            previousSibling.nextSibling = node;
            node.previousSibling = previousSibling;
        }
        refNode.previousSibling = node;
        node.nextSibling = refNode;
        if (this.firstChild === refNode) {
            this.firstChild = node;
        }
        ensureOwnerDocument(this, node);
        return node;
    };
    var nodeRemoveChild = Node.prototype.removeChild = function (refNode) {
        if (this.firstChild === refNode) {
            this.firstChild = refNode.nextSibling;
        }
        if (this.lastChild === refNode) {
            this.lastChild = refNode.previousSibling;
        }
        if (refNode.previousSibling) {
            refNode.previousSibling.nextSibling = refNode.nextSibling;
        }
        if (refNode.nextSibling) {
            refNode.nextSibling.previousSibling = refNode.previousSibling;
        }
        refNode.parentNode = null;
        refNode.nextSibling = null;
        refNode.previousSibling = null;
        return refNode;
    };
    Node.prototype.replaceChild = function (newChild, oldChild) {
        nodeInsertBefore.call(this, newChild, oldChild);
        nodeRemoveChild.call(this, oldChild);
        return oldChild;
    };
    Node.prototype.contains = function (child) {
        child = child.parentNode;
        while (child) {
            if (child === this) {
                return true;
            }
            child = child.parentNode;
        }
        return false;
    };
    Node.prototype.addEventListener = function () {
    };
    Node.prototype.removeEventListener = function () {
    };
    Node.ELEMENT_NODE = 1;
    Node.ATTRIBUTE_NODE = 2;
    Node.TEXT_NODE = 3;
    Node.CDATA_SECTION_NODE = 4;
    Node.ENTITY_REFERENCE_NODE = 5;
    Node.ENTITY_NODE = 6;
    Node.PROCESSING_INSTRUCTION_NODE = 7;
    Node.COMMENT_NODE = 8;
    Node.DOCUMENT_NODE = 9;
    Node.DOCUMENT_TYPE_NODE = 10;
    Node.DOCUMENT_FRAGMENT_NODE = 11;
    Node.NOTATION_NODE = 12;
    function ChildNodes(node) {
        this.node = node;
    }
    ChildNodes.prototype.item = function (index) {
        var child = this.node.firstChild;
        for (var i = 0; child && index !== i; i++) {
            child = child.nextSibling;
        }
        return child;
    };
    exports.default = Node;
    exports.nodeRemoveChild = nodeRemoveChild;
});
/*can-simple-dom@1.3.4#simple-dom/document/style*/
define('can-simple-dom@1.3.4#simple-dom/document/style', ['exports'], function (exports) {
    'use strict';
    Object.defineProperty(exports, '__esModule', { value: true });
    function CSSStyleDeclaration(node) {
        this.__node = node;
    }
    CSSStyleDeclaration.prototype.getPropertyValue = function () {
    };
    Object.defineProperty(CSSStyleDeclaration.prototype, 'cssText', {
        enumerable: true,
        configurable: true,
        get: function get() {
            return this.__node.getAttribute('style') || '';
        },
        set: function set(val) {
            this.__node._setAttribute('style', val);
        }
    });
    exports.default = CSSStyleDeclaration;
});
/*can-simple-dom@1.3.4#simple-dom/document/element*/
define('can-simple-dom@1.3.4#simple-dom/document/element', [
    'exports',
    './node',
    './style'
], function (exports, _node, _style) {
    'use strict';
    Object.defineProperty(exports, '__esModule', { value: true });
    var _node2 = _interopRequireDefault(_node);
    var _style2 = _interopRequireDefault(_style);
    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
    }
    var attrSpecial = {
        'class': function _class(element, value) {
            element._className = value;
        }
    };
    function Element(tagName, ownerDocument) {
        tagName = tagName.toUpperCase();
        this.nodeConstructor(1, tagName, null, ownerDocument);
        this.style = new _style2.default(this);
        this.attributes = [];
        this.tagName = tagName;
    }
    Element.prototype = Object.create(_node2.default.prototype);
    Element.prototype.constructor = Element;
    Element.prototype.nodeConstructor = _node2.default;
    Element.prototype._cloneNode = function () {
        var node = this.ownerDocument.createElement(this.tagName);
        node.attributes = this.attributes.map(function (attr) {
            return {
                name: attr.name,
                value: attr.value,
                specified: attr.specified
            };
        });
        return node;
    };
    Element.prototype.getAttribute = function (_name) {
        var attributes = this.attributes;
        var name = _name.toLowerCase();
        var attr;
        for (var i = 0, l = attributes.length; i < l; i++) {
            attr = attributes[i];
            if (attr.name === name) {
                return attr.value;
            }
        }
        return null;
    };
    Element.prototype.setAttribute = function () {
        return this._setAttribute.apply(this, arguments);
    };
    Element.prototype._setAttribute = function (_name, value) {
        var attributes = this.attributes;
        var name = _name.toLowerCase();
        var attr;
        for (var i = 0, l = attributes.length; i < l; i++) {
            attr = attributes[i];
            if (attr.name === name) {
                attr.value = value;
                var _special = attrSpecial[name];
                if (_special) {
                    _special(this, value);
                }
                return;
            }
        }
        attributes.push({
            name: name,
            value: value,
            specified: true
        });
        attributes[name] = value;
        var special = attrSpecial[name];
        if (special) {
            special(this, value);
        }
    };
    Element.prototype.hasAttribute = function (_name) {
        var attributes = this.attributes;
        var name = _name.toLowerCase();
        var attr;
        for (var i = 0, len = attributes.length; i < len; i++) {
            attr = attributes[i];
            if (attr.name === name) {
                return true;
            }
        }
        return false;
    };
    Element.prototype.removeAttribute = function (name) {
        var attributes = this.attributes;
        for (var i = 0, l = attributes.length; i < l; i++) {
            var attr = attributes[i];
            if (attr.name === name) {
                attributes.splice(i, 1);
                var special = attrSpecial[name];
                if (special) {
                    special(this, undefined);
                }
                delete attributes[name];
                return;
            }
        }
    };
    Element.prototype.getElementsByTagName = function (name) {
        name = name.toUpperCase();
        var elements = [];
        var cur = this.firstChild;
        while (cur) {
            if (cur.nodeType === _node2.default.ELEMENT_NODE) {
                if (cur.nodeName === name || name === '*') {
                    elements.push(cur);
                }
                elements.push.apply(elements, cur.getElementsByTagName(name));
            }
            cur = cur.nextSibling;
        }
        return elements;
    };
    Element.prototype.getElementById = function (id) {
        var cur = this.firstChild, child;
        while (cur) {
            if (cur.attributes && cur.attributes.length) {
                var attr;
                for (var i = 0, len = cur.attributes.length; i < len; i++) {
                    attr = cur.attributes[i];
                    if (attr.name === 'id' && attr.value === id) {
                        return cur;
                    }
                }
            }
            if (cur.getElementById) {
                child = cur.getElementById(id);
                if (child) {
                    return child;
                }
            }
            cur = cur.nextSibling;
        }
    };
    function Style(node) {
        this.__node = node;
    }
    if (Object.defineProperty) {
        Object.defineProperty(Element.prototype, 'className', {
            configurable: true,
            enumerable: true,
            get: function get() {
                return this._className || '';
            },
            set: function set(val) {
                this._setAttribute('class', val);
                this._className = val;
            }
        });
        Object.defineProperty(Element.prototype, 'innerHTML', {
            configurable: true,
            enumerable: true,
            get: function get() {
                var html = '';
                var cur = this.firstChild;
                while (cur) {
                    html += this.ownerDocument.__serializer.serialize(cur);
                    cur = cur.nextSibling;
                }
                return html;
            },
            set: function set(html) {
                this.lastChild = this.firstChild = null;
                var fragment;
                if (this.nodeName === 'SCRIPT' || this.nodeName === 'STYLE') {
                    fragment = this.ownerDocument.createTextNode(html);
                } else {
                    fragment = this.ownerDocument.__parser.parse(html);
                }
                this.appendChild(fragment);
            }
        });
        Object.defineProperty(Element.prototype, 'outerHTML', {
            get: function get() {
                return this.ownerDocument.__serializer.serialize(this);
            },
            set: function set(html) {
                this.parentNode.replaceChild(this.ownerDocument.__parser.parse(html), this);
            }
        });
        Object.defineProperty(Element.prototype, 'textContent', {
            get: function get() {
                var fc = this.firstChild;
                return fc && fc.nodeValue || '';
            },
            set: function set(val) {
                while (this.firstChild) {
                    _node.nodeRemoveChild.call(this, this.firstChild);
                }
                var tn = this.ownerDocument.createTextNode(val);
                this.appendChild(tn);
            }
        });
    }
    exports.default = Element;
});
/*can-simple-dom@1.3.4#simple-dom/document/text*/
define('can-simple-dom@1.3.4#simple-dom/document/text', [
    'exports',
    './node'
], function (exports, _node) {
    'use strict';
    Object.defineProperty(exports, '__esModule', { value: true });
    var _node2 = _interopRequireDefault(_node);
    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
    }
    function Text(text, ownerDocument) {
        this.nodeConstructor(3, '#text', text, ownerDocument);
    }
    Text.prototype._cloneNode = function () {
        return this.ownerDocument.createTextNode(this.nodeValue);
    };
    Text.prototype = Object.create(_node2.default.prototype);
    Text.prototype.constructor = Text;
    Text.prototype.nodeConstructor = _node2.default;
    exports.default = Text;
});
/*can-simple-dom@1.3.4#simple-dom/document/comment*/
define('can-simple-dom@1.3.4#simple-dom/document/comment', [
    'exports',
    './node'
], function (exports, _node) {
    'use strict';
    Object.defineProperty(exports, '__esModule', { value: true });
    var _node2 = _interopRequireDefault(_node);
    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
    }
    function Comment(text, ownerDocument) {
        this.nodeConstructor(8, '#comment', text, ownerDocument);
    }
    Comment.prototype._cloneNode = function () {
        return this.ownerDocument.createComment(this.nodeValue);
    };
    Comment.prototype = Object.create(_node2.default.prototype);
    Comment.prototype.constructor = Comment;
    Comment.prototype.nodeConstructor = _node2.default;
    exports.default = Comment;
});
/*can-simple-dom@1.3.4#simple-dom/document/document-fragment*/
define('can-simple-dom@1.3.4#simple-dom/document/document-fragment', [
    'exports',
    './node'
], function (exports, _node) {
    'use strict';
    Object.defineProperty(exports, '__esModule', { value: true });
    var _node2 = _interopRequireDefault(_node);
    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
    }
    function DocumentFragment(ownerDocument) {
        this.nodeConstructor(11, '#document-fragment', null, ownerDocument);
    }
    DocumentFragment.prototype._cloneNode = function () {
        return this.ownerDocument.createDocumentFragment();
    };
    DocumentFragment.prototype = Object.create(_node2.default.prototype);
    DocumentFragment.prototype.constructor = DocumentFragment;
    DocumentFragment.prototype.nodeConstructor = _node2.default;
    exports.default = DocumentFragment;
});
/*micro-location@0.1.5#lib/micro-location*/
function Location() {
    this.init.apply(this, arguments);
}
Location.prototype = {
    init: function (protocol, host, hostname, port, pathname, search, hash) {
        this.protocol = protocol;
        this.host = host;
        this.hostname = hostname;
        this.port = port || '';
        this.pathname = pathname || '';
        this.search = search || '';
        this.hash = hash || '';
        if (protocol) {
            with (this)
                this.href = protocol + '//' + host + pathname + search + hash;
        } else if (host) {
            with (this)
                this.href = '//' + host + pathname + search + hash;
        } else {
            with (this)
                this.href = pathname + search + hash;
        }
    },
    params: function (name) {
        if (!this._params) {
            var params = {};
            var pairs = this.search.substring(1).split(/[;&]/);
            for (var i = 0, len = pairs.length; i < len; i++) {
                if (!pairs[i])
                    continue;
                var pair = pairs[i].split(/=/);
                var key = decodeURIComponent(pair[0].replace(/\+/g, '%20'));
                var val = decodeURIComponent(pair[1].replace(/\+/g, '%20'));
                if (!params[key])
                    params[key] = [];
                params[key].push(val);
            }
            this._params = params;
        }
        switch (typeof name) {
        case 'undefined':
            return this._params;
        case 'object':
            return this.build(name);
        }
        return this._params[name] ? this._params[name][0] : null;
    },
    build: function (params) {
        if (!params)
            params = this._params;
        var ret = new Location();
        var _search = this.search;
        if (params) {
            var search = [];
            for (var key in params)
                if (params.hasOwnProperty(key)) {
                    var val = params[key];
                    switch (typeof val) {
                    case 'object':
                        for (var i = 0, len = val.length; i < len; i++) {
                            search.push(encodeURIComponent(key) + '=' + encodeURIComponent(val[i]));
                        }
                        break;
                    default:
                        search.push(encodeURIComponent(key) + '=' + encodeURIComponent(val));
                    }
                }
            _search = '?' + search.join('&');
        }
        with (this)
            ret.init.apply(ret, [
                protocol,
                host,
                hostname,
                port,
                pathname,
                _search,
                hash
            ]);
        return ret;
    }
};
Location.regexp = new RegExp('^(?:(https?:)//(([^:/]+)(:[^/]+)?))?([^#?]*)(\\?[^#]*)?(#.*)?$');
Location.parse = function (string) {
    var matched = String(string).match(this.regexp);
    var ret = new Location();
    ret.init.apply(ret, matched.slice(1));
    return ret;
};
(function (root, factory) {
    if (typeof module === 'object' && module.exports) {
        module.exports = { Location: factory() };
    } else if (typeof define === 'function' && define.amd) {
        define('micro-location@0.1.5#lib/micro-location', [], function () {
            return { Location: factory() };
        });
    } else {
        root.Location = factory();
    }
}(this, function () {
    return Location;
}));
/*can-simple-dom@1.3.4#simple-dom/extend*/
define('can-simple-dom@1.3.4#simple-dom/extend', ['exports'], function (exports) {
    'use strict';
    Object.defineProperty(exports, '__esModule', { value: true });
    exports.default = function (a, b) {
        for (var p in b) {
            a[p] = b[p];
        }
        return a;
    };
    ;
});
/*can-simple-dom@1.3.4#simple-dom/document/anchor-element*/
define('can-simple-dom@1.3.4#simple-dom/document/anchor-element', [
    'exports',
    './element',
    'micro-location',
    '../extend'
], function (exports, _element, _microLocation, _extend) {
    'use strict';
    Object.defineProperty(exports, '__esModule', { value: true });
    var _element2 = _interopRequireDefault(_element);
    var _microLocation2 = _interopRequireDefault(_microLocation);
    var _extend2 = _interopRequireDefault(_extend);
    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
    }
    var Location = _microLocation2.default.Location || _microLocation2.default;
    function AnchorElement(tagName, ownerDocument) {
        this.elementConstructor(tagName, ownerDocument);
        (0, _extend2.default)(this, Location.parse(''));
    }
    AnchorElement.prototype = Object.create(_element2.default.prototype);
    AnchorElement.prototype.constructor = AnchorElement;
    AnchorElement.prototype.elementConstructor = _element2.default;
    AnchorElement.prototype.setAttribute = function (_name, value) {
        _element2.default.prototype.setAttribute.apply(this, arguments);
        if (_name.toLowerCase() === 'href') {
            (0, _extend2.default)(this, Location.parse(value));
        }
    };
    exports.default = AnchorElement;
});
/*can-simple-dom@1.3.4#simple-dom/document/utils*/
define('can-simple-dom@1.3.4#simple-dom/document/utils', ['exports'], function (exports) {
    'use strict';
    Object.defineProperty(exports, '__esModule', { value: true });
    exports.propToAttr = propToAttr;
    function propToAttr(Element, name) {
        Object.defineProperty(Element.prototype, name, {
            configurable: true,
            enumerable: true,
            get: function get() {
                return this.getAttribute(name);
            },
            set: function set(val) {
                this.setAttribute(name, val);
            }
        });
    }
    ;
});
/*can-simple-dom@1.3.4#simple-dom/document/input-element*/
define('can-simple-dom@1.3.4#simple-dom/document/input-element', [
    'exports',
    './element',
    './utils.js'
], function (exports, _element, _utils) {
    'use strict';
    Object.defineProperty(exports, '__esModule', { value: true });
    var _element2 = _interopRequireDefault(_element);
    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
    }
    function InputElement(tagName, ownerDocument) {
        this.elementConstructor(tagName, ownerDocument);
    }
    InputElement.prototype = Object.create(_element2.default.prototype);
    InputElement.prototype.constructor = InputElement;
    InputElement.prototype.elementConstructor = _element2.default;
    (0, _utils.propToAttr)(InputElement, 'type');
    (0, _utils.propToAttr)(InputElement, 'value');
    Object.defineProperty(InputElement.prototype, 'checked', {
        configurable: true,
        enumerable: true,
        get: function get() {
            return this.hasAttribute('checked');
        },
        set: function set(value) {
            if (value) {
                this.setAttribute('checked', '');
            } else {
                this.removeAttribute('checked');
            }
        }
    });
    exports.default = InputElement;
});
/*can-simple-dom@1.3.4#simple-dom/document/option-element*/
define('can-simple-dom@1.3.4#simple-dom/document/option-element', [
    'exports',
    './element',
    './utils'
], function (exports, _element, _utils) {
    'use strict';
    Object.defineProperty(exports, '__esModule', { value: true });
    var _element2 = _interopRequireDefault(_element);
    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
    }
    function OptionElement(tagName, ownerDocument) {
        this.elementConstructor(tagName, ownerDocument);
    }
    OptionElement.prototype = Object.create(_element2.default.prototype);
    OptionElement.prototype.constructor = OptionElement;
    OptionElement.prototype.elementConstructor = _element2.default;
    (0, _utils.propToAttr)(OptionElement, 'value');
    Object.defineProperty(OptionElement.prototype, 'selected', {
        enumerable: true,
        configurable: true,
        get: function get() {
            var val = this.value || '';
            var parent = this.parentNode;
            return parent && parent.value == val;
        },
        set: function set(val) {
            if (val) {
                var parent = this.parentNode;
                if (parent) {
                    parent.value = this.value;
                }
            }
        }
    });
    exports.default = OptionElement;
});
/*can-simple-dom@1.3.4#simple-dom/document/select-element*/
define('can-simple-dom@1.3.4#simple-dom/document/select-element', [
    'exports',
    './element',
    './utils'
], function (exports, _element, _utils) {
    'use strict';
    Object.defineProperty(exports, '__esModule', { value: true });
    var _element2 = _interopRequireDefault(_element);
    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
    }
    function SelectElement(tagName, ownerDocument) {
        this.elementConstructor(tagName, ownerDocument);
        this.selectedIndex = 0;
    }
    SelectElement.prototype = Object.create(_element2.default.prototype);
    SelectElement.prototype.constructor = SelectElement;
    SelectElement.prototype.elementConstructor = _element2.default;
    (0, _utils.propToAttr)(SelectElement, 'value');
    exports.default = SelectElement;
});
/*can-simple-dom@1.3.4#simple-dom/document*/
define('can-simple-dom@1.3.4#simple-dom/document', [
    'exports',
    './document/node',
    './document/element',
    './document/text',
    './document/comment',
    './document/document-fragment',
    './document/anchor-element',
    './document/input-element',
    './document/option-element',
    './document/select-element'
], function (exports, _node, _element, _text, _comment, _documentFragment, _anchorElement, _inputElement, _optionElement, _selectElement) {
    'use strict';
    Object.defineProperty(exports, '__esModule', { value: true });
    var _node2 = _interopRequireDefault(_node);
    var _element2 = _interopRequireDefault(_element);
    var _text2 = _interopRequireDefault(_text);
    var _comment2 = _interopRequireDefault(_comment);
    var _documentFragment2 = _interopRequireDefault(_documentFragment);
    var _anchorElement2 = _interopRequireDefault(_anchorElement);
    var _inputElement2 = _interopRequireDefault(_inputElement);
    var _optionElement2 = _interopRequireDefault(_optionElement);
    var _selectElement2 = _interopRequireDefault(_selectElement);
    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
    }
    var noop = Function.prototype;
    function Document() {
        this.nodeConstructor(9, '#document', null, this);
        var documentElement = new _element2.default('html', this);
        var body = new _element2.default('body', this);
        var head = new _element2.default('head', this);
        documentElement.appendChild(head);
        documentElement.appendChild(body);
        this.appendChild(documentElement);
        var self = this;
        this.implementation = {
            createHTMLDocument: function createHTMLDocument(content) {
                var document = new Document();
                var frag = self.__parser.parse(content);
                var body = _element2.default.prototype.getElementsByTagName.call(frag, 'body')[0];
                var head = _element2.default.prototype.getElementsByTagName.call(frag, 'head')[0];
                if (!body && !head) {
                    document.body.appendChild(frag);
                } else {
                    if (body) {
                        document.documentElement.replaceChild(body, document.body);
                    }
                    if (head) {
                        document.documentElement.replaceChild(head, document.head);
                    }
                    document.documentElement.appendChild(frag);
                }
                document.__addSerializerAndParser(self.__serializer, self.__parser);
                return document;
            }
        };
    }
    Document.prototype = Object.create(_node2.default.prototype);
    Document.prototype.constructor = Document;
    Document.prototype.nodeConstructor = _node2.default;
    var specialElements = {
        'a': _anchorElement2.default,
        'input': _inputElement2.default,
        'option': _optionElement2.default,
        'select': _selectElement2.default
    };
    Document.prototype.createElement = function (tagName) {
        var Special = specialElements[tagName.toLowerCase()];
        if (Special) {
            return new Special(tagName, this);
        }
        return new _element2.default(tagName, this);
    };
    Document.prototype.createTextNode = function (text) {
        return new _text2.default(text, this);
    };
    Document.prototype.createComment = function (text) {
        return new _comment2.default(text, this);
    };
    Document.prototype.createDocumentFragment = function () {
        return new _documentFragment2.default(this);
    };
    Document.prototype.getElementsByTagName = function (name) {
        name = name.toUpperCase();
        var elements = [];
        var cur = this.firstChild;
        while (cur) {
            if (cur.nodeType === _node2.default.ELEMENT_NODE) {
                if (cur.nodeName === name || name === '*') {
                    elements.push(cur);
                }
                elements.push.apply(elements, cur.getElementsByTagName(name));
            }
            cur = cur.nextSibling;
        }
        return elements;
    };
    Document.prototype.getElementById = function (id) {
        return _element2.default.prototype.getElementById.apply(this.documentElement, arguments);
    };
    Document.prototype.__addSerializerAndParser = function (serializer, parser) {
        this.__parser = parser;
        this.__serializer = serializer;
    };
    if (Object.defineProperty) {
        var firstOfKind = function firstOfKind(root, nodeName) {
            if (root == null)
                return null;
            var node = root.firstChild;
            while (node) {
                if (node.nodeName === nodeName) {
                    return node;
                }
                node = node.nextSibling;
            }
            return null;
        };
        Object.defineProperty(Document.prototype, 'currentScript', {
            get: function get() {
                var scripts = this.getElementsByTagName('script');
                var first = scripts[scripts.length - 1];
                if (!first) {
                    first = this.createElement('script');
                }
                return first;
            }
        });
        Object.defineProperty(Document.prototype, 'documentElement', {
            get: function get() {
                return this.firstChild;
            },
            set: noop
        });
        [
            'head',
            'body'
        ].forEach(function (localName) {
            var nodeName = localName.toUpperCase();
            Object.defineProperty(Document.prototype, localName, {
                get: function get() {
                    return firstOfKind(this.documentElement, nodeName);
                },
                set: noop
            });
        });
    }
    exports.default = Document;
});
/*can-simple-dom@1.3.4#simple-dom/event*/
define('can-simple-dom@1.3.4#simple-dom/event', [
    'exports',
    './document/node',
    './document'
], function (exports, _node, _document) {
    'use strict';
    Object.defineProperty(exports, '__esModule', { value: true });
    var _node2 = _interopRequireDefault(_node);
    var _document2 = _interopRequireDefault(_document);
    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
    }
    var Event = function Event() {
    };
    Event.prototype.initEvent = function (type, bubbles, cancelable) {
        this.type = type;
        this.bubbles = !!bubbles;
        this.cancelable = !!cancelable;
    };
    Event.prototype.stopPropagation = function () {
        this.isPropagationStopped = true;
    };
    Event.prototype.preventDefault = function () {
        this.isDefaultPrevented = true;
    };
    _document2.default.prototype.createEvent = function (type) {
        return new Event();
    };
    _node2.default.prototype.addEventListener = function (event, handler, capture) {
        if (!this.__handlers) {
            Object.defineProperty(this, '__handlers', {
                value: {},
                enumerable: false
            });
        }
        var phase = capture ? 'capture' : 'bubble';
        var handlersByType = this.__handlers[event + ' ' + phase];
        if (!handlersByType) {
            handlersByType = this.__handlers[event + ' ' + phase] = [];
        }
        if (handlersByType.indexOf(handler) === -1) {
            handlersByType.push(handler);
        }
    };
    _node2.default.prototype.removeEventListener = function (event, handler, capture) {
        if (this.__handlers) {
            var phase = capture ? 'capture' : 'bubble';
            var handlersByType = this.__handlers[event + ' ' + phase];
            if (handlersByType) {
                var index = 0;
                while (index < handlersByType.length) {
                    if (handlersByType[index] === handler) {
                        handlersByType.splice(index, 1);
                    } else {
                        index++;
                    }
                }
            }
        }
    };
    _node2.default.prototype.dispatchEvent = function (event) {
        event.target = this;
        var cur = this;
        var dispatchHandlers = [];
        do {
            var handlers = cur.__handlers && cur.__handlers[event.type + ' bubble'];
            if (handlers) {
                dispatchHandlers.push({
                    node: cur,
                    handlers: handlers
                });
            }
            cur = cur.parentNode;
        } while (event.bubbles && cur);
        for (var i = 0; i < dispatchHandlers.length; i++) {
            var dispatches = dispatchHandlers[i];
            event.currentTarget = dispatches.node;
            for (var h = 0; h < dispatches.handlers.length; h++) {
                var handler = dispatches.handlers[h];
                var res = handler.call(this, event);
                if (res) {
                    event.stopPropagation();
                    event.preventDefault();
                }
                if (event.isImmediatePropagationStopped) {
                    return !event.isDefaultPrevented;
                }
            }
            if (event.isPropagationStopped) {
                return !event.isDefaultPrevented;
            }
        }
        return !event.isDefaultPrevented;
    };
    exports.default = Event;
});
/*he@1.1.1#he*/
;
(function (root) {
    var freeExports = typeof exports == 'object' && exports;
    var freeModule = typeof module == 'object' && module && module.exports == freeExports && module;
    var freeGlobal = typeof global == 'object' && global;
    if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {
        root = freeGlobal;
    }
    var regexAstralSymbols = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
    var regexAsciiWhitelist = /[\x01-\x7F]/g;
    var regexBmpWhitelist = /[\x01-\t\x0B\f\x0E-\x1F\x7F\x81\x8D\x8F\x90\x9D\xA0-\uFFFF]/g;
    var regexEncodeNonAscii = /<\u20D2|=\u20E5|>\u20D2|\u205F\u200A|\u219D\u0338|\u2202\u0338|\u2220\u20D2|\u2229\uFE00|\u222A\uFE00|\u223C\u20D2|\u223D\u0331|\u223E\u0333|\u2242\u0338|\u224B\u0338|\u224D\u20D2|\u224E\u0338|\u224F\u0338|\u2250\u0338|\u2261\u20E5|\u2264\u20D2|\u2265\u20D2|\u2266\u0338|\u2267\u0338|\u2268\uFE00|\u2269\uFE00|\u226A\u0338|\u226A\u20D2|\u226B\u0338|\u226B\u20D2|\u227F\u0338|\u2282\u20D2|\u2283\u20D2|\u228A\uFE00|\u228B\uFE00|\u228F\u0338|\u2290\u0338|\u2293\uFE00|\u2294\uFE00|\u22B4\u20D2|\u22B5\u20D2|\u22D8\u0338|\u22D9\u0338|\u22DA\uFE00|\u22DB\uFE00|\u22F5\u0338|\u22F9\u0338|\u2933\u0338|\u29CF\u0338|\u29D0\u0338|\u2A6D\u0338|\u2A70\u0338|\u2A7D\u0338|\u2A7E\u0338|\u2AA1\u0338|\u2AA2\u0338|\u2AAC\uFE00|\u2AAD\uFE00|\u2AAF\u0338|\u2AB0\u0338|\u2AC5\u0338|\u2AC6\u0338|\u2ACB\uFE00|\u2ACC\uFE00|\u2AFD\u20E5|[\xA0-\u0113\u0116-\u0122\u0124-\u012B\u012E-\u014D\u0150-\u017E\u0192\u01B5\u01F5\u0237\u02C6\u02C7\u02D8-\u02DD\u0311\u0391-\u03A1\u03A3-\u03A9\u03B1-\u03C9\u03D1\u03D2\u03D5\u03D6\u03DC\u03DD\u03F0\u03F1\u03F5\u03F6\u0401-\u040C\u040E-\u044F\u0451-\u045C\u045E\u045F\u2002-\u2005\u2007-\u2010\u2013-\u2016\u2018-\u201A\u201C-\u201E\u2020-\u2022\u2025\u2026\u2030-\u2035\u2039\u203A\u203E\u2041\u2043\u2044\u204F\u2057\u205F-\u2063\u20AC\u20DB\u20DC\u2102\u2105\u210A-\u2113\u2115-\u211E\u2122\u2124\u2127-\u2129\u212C\u212D\u212F-\u2131\u2133-\u2138\u2145-\u2148\u2153-\u215E\u2190-\u219B\u219D-\u21A7\u21A9-\u21AE\u21B0-\u21B3\u21B5-\u21B7\u21BA-\u21DB\u21DD\u21E4\u21E5\u21F5\u21FD-\u2205\u2207-\u2209\u220B\u220C\u220F-\u2214\u2216-\u2218\u221A\u221D-\u2238\u223A-\u2257\u2259\u225A\u225C\u225F-\u2262\u2264-\u228B\u228D-\u229B\u229D-\u22A5\u22A7-\u22B0\u22B2-\u22BB\u22BD-\u22DB\u22DE-\u22E3\u22E6-\u22F7\u22F9-\u22FE\u2305\u2306\u2308-\u2310\u2312\u2313\u2315\u2316\u231C-\u231F\u2322\u2323\u232D\u232E\u2336\u233D\u233F\u237C\u23B0\u23B1\u23B4-\u23B6\u23DC-\u23DF\u23E2\u23E7\u2423\u24C8\u2500\u2502\u250C\u2510\u2514\u2518\u251C\u2524\u252C\u2534\u253C\u2550-\u256C\u2580\u2584\u2588\u2591-\u2593\u25A1\u25AA\u25AB\u25AD\u25AE\u25B1\u25B3-\u25B5\u25B8\u25B9\u25BD-\u25BF\u25C2\u25C3\u25CA\u25CB\u25EC\u25EF\u25F8-\u25FC\u2605\u2606\u260E\u2640\u2642\u2660\u2663\u2665\u2666\u266A\u266D-\u266F\u2713\u2717\u2720\u2736\u2758\u2772\u2773\u27C8\u27C9\u27E6-\u27ED\u27F5-\u27FA\u27FC\u27FF\u2902-\u2905\u290C-\u2913\u2916\u2919-\u2920\u2923-\u292A\u2933\u2935-\u2939\u293C\u293D\u2945\u2948-\u294B\u294E-\u2976\u2978\u2979\u297B-\u297F\u2985\u2986\u298B-\u2996\u299A\u299C\u299D\u29A4-\u29B7\u29B9\u29BB\u29BC\u29BE-\u29C5\u29C9\u29CD-\u29D0\u29DC-\u29DE\u29E3-\u29E5\u29EB\u29F4\u29F6\u2A00-\u2A02\u2A04\u2A06\u2A0C\u2A0D\u2A10-\u2A17\u2A22-\u2A27\u2A29\u2A2A\u2A2D-\u2A31\u2A33-\u2A3C\u2A3F\u2A40\u2A42-\u2A4D\u2A50\u2A53-\u2A58\u2A5A-\u2A5D\u2A5F\u2A66\u2A6A\u2A6D-\u2A75\u2A77-\u2A9A\u2A9D-\u2AA2\u2AA4-\u2AB0\u2AB3-\u2AC8\u2ACB\u2ACC\u2ACF-\u2ADB\u2AE4\u2AE6-\u2AE9\u2AEB-\u2AF3\u2AFD\uFB00-\uFB04]|\uD835[\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDCCF\uDD04\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDD6B]/g;
    var encodeMap = {
        '\xAD': 'shy',
        '': 'zwnj',
        '': 'zwj',
        '\u200E': 'lrm',
        '\u2063': 'ic',
        '\u2062': 'it',
        '\u2061': 'af',
        '\u200F': 'rlm',
        '\u200B': 'ZeroWidthSpace',
        '\u2060': 'NoBreak',
        '': 'DownBreve',
        '': 'tdot',
        '': 'DotDot',
        '\t': 'Tab',
        '\n': 'NewLine',
        '\u2008': 'puncsp',
        '\u205F': 'MediumSpace',
        '\u2009': 'thinsp',
        '\u200A': 'hairsp',
        '\u2004': 'emsp13',
        '\u2002': 'ensp',
        '\u2005': 'emsp14',
        '\u2003': 'emsp',
        '\u2007': 'numsp',
        '\xA0': 'nbsp',
        '\u205F\u200A': 'ThickSpace',
        '\u203E': 'oline',
        '_': 'lowbar',
        '\u2010': 'dash',
        '\u2013': 'ndash',
        '\u2014': 'mdash',
        '\u2015': 'horbar',
        ',': 'comma',
        ';': 'semi',
        '\u204F': 'bsemi',
        ':': 'colon',
        '\u2A74': 'Colone',
        '!': 'excl',
        '\xA1': 'iexcl',
        '?': 'quest',
        '\xBF': 'iquest',
        '.': 'period',
        '\u2025': 'nldr',
        '\u2026': 'mldr',
        '\xB7': 'middot',
        '\'': 'apos',
        '\u2018': 'lsquo',
        '\u2019': 'rsquo',
        '\u201A': 'sbquo',
        '\u2039': 'lsaquo',
        '\u203A': 'rsaquo',
        '"': 'quot',
        '\u201C': 'ldquo',
        '\u201D': 'rdquo',
        '\u201E': 'bdquo',
        '\xAB': 'laquo',
        '\xBB': 'raquo',
        '(': 'lpar',
        ')': 'rpar',
        '[': 'lsqb',
        ']': 'rsqb',
        '{': 'lcub',
        '}': 'rcub',
        '\u2308': 'lceil',
        '\u2309': 'rceil',
        '\u230A': 'lfloor',
        '\u230B': 'rfloor',
        '\u2985': 'lopar',
        '\u2986': 'ropar',
        '\u298B': 'lbrke',
        '\u298C': 'rbrke',
        '\u298D': 'lbrkslu',
        '\u298E': 'rbrksld',
        '\u298F': 'lbrksld',
        '\u2990': 'rbrkslu',
        '\u2991': 'langd',
        '\u2992': 'rangd',
        '\u2993': 'lparlt',
        '\u2994': 'rpargt',
        '\u2995': 'gtlPar',
        '\u2996': 'ltrPar',
        '\u27E6': 'lobrk',
        '\u27E7': 'robrk',
        '\u27E8': 'lang',
        '\u27E9': 'rang',
        '\u27EA': 'Lang',
        '\u27EB': 'Rang',
        '\u27EC': 'loang',
        '\u27ED': 'roang',
        '\u2772': 'lbbrk',
        '\u2773': 'rbbrk',
        '\u2016': 'Vert',
        '\xA7': 'sect',
        '\xB6': 'para',
        '@': 'commat',
        '*': 'ast',
        '/': 'sol',
        'undefined': null,
        '&': 'amp',
        '#': 'num',
        '%': 'percnt',
        '\u2030': 'permil',
        '\u2031': 'pertenk',
        '\u2020': 'dagger',
        '\u2021': 'Dagger',
        '\u2022': 'bull',
        '\u2043': 'hybull',
        '\u2032': 'prime',
        '\u2033': 'Prime',
        '\u2034': 'tprime',
        '\u2057': 'qprime',
        '\u2035': 'bprime',
        '\u2041': 'caret',
        '`': 'grave',
        '\xB4': 'acute',
        '\u02DC': 'tilde',
        '^': 'Hat',
        '\xAF': 'macr',
        '\u02D8': 'breve',
        '\u02D9': 'dot',
        '\xA8': 'die',
        '\u02DA': 'ring',
        '\u02DD': 'dblac',
        '\xB8': 'cedil',
        '\u02DB': 'ogon',
        '': 'circ',
        '': 'caron',
        '\xB0': 'deg',
        '\xA9': 'copy',
        '\xAE': 'reg',
        '\u2117': 'copysr',
        '\u2118': 'wp',
        '\u211E': 'rx',
        '\u2127': 'mho',
        '\u2129': 'iiota',
        '\u2190': 'larr',
        '\u219A': 'nlarr',
        '\u2192': 'rarr',
        '\u219B': 'nrarr',
        '\u2191': 'uarr',
        '\u2193': 'darr',
        '\u2194': 'harr',
        '\u21AE': 'nharr',
        '\u2195': 'varr',
        '\u2196': 'nwarr',
        '\u2197': 'nearr',
        '\u2198': 'searr',
        '\u2199': 'swarr',
        '\u219D': 'rarrw',
        '\u219D': 'nrarrw',
        '\u219E': 'Larr',
        '\u219F': 'Uarr',
        '\u21A0': 'Rarr',
        '\u21A1': 'Darr',
        '\u21A2': 'larrtl',
        '\u21A3': 'rarrtl',
        '\u21A4': 'mapstoleft',
        '\u21A5': 'mapstoup',
        '\u21A6': 'map',
        '\u21A7': 'mapstodown',
        '\u21A9': 'larrhk',
        '\u21AA': 'rarrhk',
        '\u21AB': 'larrlp',
        '\u21AC': 'rarrlp',
        '\u21AD': 'harrw',
        '\u21B0': 'lsh',
        '\u21B1': 'rsh',
        '\u21B2': 'ldsh',
        '\u21B3': 'rdsh',
        '\u21B5': 'crarr',
        '\u21B6': 'cularr',
        '\u21B7': 'curarr',
        '\u21BA': 'olarr',
        '\u21BB': 'orarr',
        '\u21BC': 'lharu',
        '\u21BD': 'lhard',
        '\u21BE': 'uharr',
        '\u21BF': 'uharl',
        '\u21C0': 'rharu',
        '\u21C1': 'rhard',
        '\u21C2': 'dharr',
        '\u21C3': 'dharl',
        '\u21C4': 'rlarr',
        '\u21C5': 'udarr',
        '\u21C6': 'lrarr',
        '\u21C7': 'llarr',
        '\u21C8': 'uuarr',
        '\u21C9': 'rrarr',
        '\u21CA': 'ddarr',
        '\u21CB': 'lrhar',
        '\u21CC': 'rlhar',
        '\u21D0': 'lArr',
        '\u21CD': 'nlArr',
        '\u21D1': 'uArr',
        '\u21D2': 'rArr',
        '\u21CF': 'nrArr',
        '\u21D3': 'dArr',
        '\u21D4': 'iff',
        '\u21CE': 'nhArr',
        '\u21D5': 'vArr',
        '\u21D6': 'nwArr',
        '\u21D7': 'neArr',
        '\u21D8': 'seArr',
        '\u21D9': 'swArr',
        '\u21DA': 'lAarr',
        '\u21DB': 'rAarr',
        '\u21DD': 'zigrarr',
        '\u21E4': 'larrb',
        '\u21E5': 'rarrb',
        '\u21F5': 'duarr',
        '\u21FD': 'loarr',
        '\u21FE': 'roarr',
        '\u21FF': 'hoarr',
        '\u2200': 'forall',
        '\u2201': 'comp',
        '\u2202': 'part',
        '\u2202': 'npart',
        '\u2203': 'exist',
        '\u2204': 'nexist',
        '\u2205': 'empty',
        '\u2207': 'Del',
        '\u2208': 'in',
        '\u2209': 'notin',
        '\u220B': 'ni',
        '\u220C': 'notni',
        '\u03F6': 'bepsi',
        '\u220F': 'prod',
        '\u2210': 'coprod',
        '\u2211': 'sum',
        '+': 'plus',
        '\xB1': 'pm',
        '\xF7': 'div',
        '\xD7': 'times',
        '<': 'lt',
        '\u226E': 'nlt',
        '<': 'nvlt',
        '=': 'equals',
        '\u2260': 'ne',
        '=': 'bne',
        '\u2A75': 'Equal',
        '>': 'gt',
        '\u226F': 'ngt',
        '>': 'nvgt',
        '\xAC': 'not',
        '|': 'vert',
        '\xA6': 'brvbar',
        '\u2212': 'minus',
        '\u2213': 'mp',
        '\u2214': 'plusdo',
        '\u2044': 'frasl',
        '\u2216': 'setmn',
        '\u2217': 'lowast',
        '\u2218': 'compfn',
        '\u221A': 'Sqrt',
        '\u221D': 'prop',
        '\u221E': 'infin',
        '\u221F': 'angrt',
        '\u2220': 'ang',
        '\u2220': 'nang',
        '\u2221': 'angmsd',
        '\u2222': 'angsph',
        '\u2223': 'mid',
        '\u2224': 'nmid',
        '\u2225': 'par',
        '\u2226': 'npar',
        '\u2227': 'and',
        '\u2228': 'or',
        '\u2229': 'cap',
        '\u2229': 'caps',
        '\u222A': 'cup',
        '\u222A': 'cups',
        '\u222B': 'int',
        '\u222C': 'Int',
        '\u222D': 'tint',
        '\u2A0C': 'qint',
        '\u222E': 'oint',
        '\u222F': 'Conint',
        '\u2230': 'Cconint',
        '\u2231': 'cwint',
        '\u2232': 'cwconint',
        '\u2233': 'awconint',
        '\u2234': 'there4',
        '\u2235': 'becaus',
        '\u2236': 'ratio',
        '\u2237': 'Colon',
        '\u2238': 'minusd',
        '\u223A': 'mDDot',
        '\u223B': 'homtht',
        '\u223C': 'sim',
        '\u2241': 'nsim',
        '\u223C': 'nvsim',
        '\u223D': 'bsim',
        '\u223D': 'race',
        '\u223E': 'ac',
        '\u223E': 'acE',
        '\u223F': 'acd',
        '\u2240': 'wr',
        '\u2242': 'esim',
        '\u2242': 'nesim',
        '\u2243': 'sime',
        '\u2244': 'nsime',
        '\u2245': 'cong',
        '\u2247': 'ncong',
        '\u2246': 'simne',
        '\u2248': 'ap',
        '\u2249': 'nap',
        '\u224A': 'ape',
        '\u224B': 'apid',
        '\u224B': 'napid',
        '\u224C': 'bcong',
        '\u224D': 'CupCap',
        '\u226D': 'NotCupCap',
        '\u224D': 'nvap',
        '\u224E': 'bump',
        '\u224E': 'nbump',
        '\u224F': 'bumpe',
        '\u224F': 'nbumpe',
        '\u2250': 'doteq',
        '\u2250': 'nedot',
        '\u2251': 'eDot',
        '\u2252': 'efDot',
        '\u2253': 'erDot',
        '\u2254': 'colone',
        '\u2255': 'ecolon',
        '\u2256': 'ecir',
        '\u2257': 'cire',
        '\u2259': 'wedgeq',
        '\u225A': 'veeeq',
        '\u225C': 'trie',
        '\u225F': 'equest',
        '\u2261': 'equiv',
        '\u2262': 'nequiv',
        '\u2261': 'bnequiv',
        '\u2264': 'le',
        '\u2270': 'nle',
        '\u2264': 'nvle',
        '\u2265': 'ge',
        '\u2271': 'nge',
        '\u2265': 'nvge',
        '\u2266': 'lE',
        '\u2266': 'nlE',
        '\u2267': 'gE',
        '\u2267': 'ngE',
        '\u2268': 'lvnE',
        '\u2268': 'lnE',
        '\u2269': 'gnE',
        '\u2269': 'gvnE',
        '\u226A': 'll',
        '\u226A': 'nLtv',
        '\u226A': 'nLt',
        '\u226B': 'gg',
        '\u226B': 'nGtv',
        '\u226B': 'nGt',
        '\u226C': 'twixt',
        '\u2272': 'lsim',
        '\u2274': 'nlsim',
        '\u2273': 'gsim',
        '\u2275': 'ngsim',
        '\u2276': 'lg',
        '\u2278': 'ntlg',
        '\u2277': 'gl',
        '\u2279': 'ntgl',
        '\u227A': 'pr',
        '\u2280': 'npr',
        '\u227B': 'sc',
        '\u2281': 'nsc',
        '\u227C': 'prcue',
        '\u22E0': 'nprcue',
        '\u227D': 'sccue',
        '\u22E1': 'nsccue',
        '\u227E': 'prsim',
        '\u227F': 'scsim',
        '\u227F': 'NotSucceedsTilde',
        '\u2282': 'sub',
        '\u2284': 'nsub',
        '\u2282': 'vnsub',
        '\u2283': 'sup',
        '\u2285': 'nsup',
        '\u2283': 'vnsup',
        '\u2286': 'sube',
        '\u2288': 'nsube',
        '\u2287': 'supe',
        '\u2289': 'nsupe',
        '\u228A': 'vsubne',
        '\u228A': 'subne',
        '\u228B': 'vsupne',
        '\u228B': 'supne',
        '\u228D': 'cupdot',
        '\u228E': 'uplus',
        '\u228F': 'sqsub',
        '\u228F': 'NotSquareSubset',
        '\u2290': 'sqsup',
        '\u2290': 'NotSquareSuperset',
        '\u2291': 'sqsube',
        '\u22E2': 'nsqsube',
        '\u2292': 'sqsupe',
        '\u22E3': 'nsqsupe',
        '\u2293': 'sqcap',
        '\u2293': 'sqcaps',
        '\u2294': 'sqcup',
        '\u2294': 'sqcups',
        '\u2295': 'oplus',
        '\u2296': 'ominus',
        '\u2297': 'otimes',
        '\u2298': 'osol',
        '\u2299': 'odot',
        '\u229A': 'ocir',
        '\u229B': 'oast',
        '\u229D': 'odash',
        '\u229E': 'plusb',
        '\u229F': 'minusb',
        '\u22A0': 'timesb',
        '\u22A1': 'sdotb',
        '\u22A2': 'vdash',
        '\u22AC': 'nvdash',
        '\u22A3': 'dashv',
        '\u22A4': 'top',
        '\u22A5': 'bot',
        '\u22A7': 'models',
        '\u22A8': 'vDash',
        '\u22AD': 'nvDash',
        '\u22A9': 'Vdash',
        '\u22AE': 'nVdash',
        '\u22AA': 'Vvdash',
        '\u22AB': 'VDash',
        '\u22AF': 'nVDash',
        '\u22B0': 'prurel',
        '\u22B2': 'vltri',
        '\u22EA': 'nltri',
        '\u22B3': 'vrtri',
        '\u22EB': 'nrtri',
        '\u22B4': 'ltrie',
        '\u22EC': 'nltrie',
        '\u22B4': 'nvltrie',
        '\u22B5': 'rtrie',
        '\u22ED': 'nrtrie',
        '\u22B5': 'nvrtrie',
        '\u22B6': 'origof',
        '\u22B7': 'imof',
        '\u22B8': 'mumap',
        '\u22B9': 'hercon',
        '\u22BA': 'intcal',
        '\u22BB': 'veebar',
        '\u22BD': 'barvee',
        '\u22BE': 'angrtvb',
        '\u22BF': 'lrtri',
        '\u22C0': 'Wedge',
        '\u22C1': 'Vee',
        '\u22C2': 'xcap',
        '\u22C3': 'xcup',
        '\u22C4': 'diam',
        '\u22C5': 'sdot',
        '\u22C6': 'Star',
        '\u22C7': 'divonx',
        '\u22C8': 'bowtie',
        '\u22C9': 'ltimes',
        '\u22CA': 'rtimes',
        '\u22CB': 'lthree',
        '\u22CC': 'rthree',
        '\u22CD': 'bsime',
        '\u22CE': 'cuvee',
        '\u22CF': 'cuwed',
        '\u22D0': 'Sub',
        '\u22D1': 'Sup',
        '\u22D2': 'Cap',
        '\u22D3': 'Cup',
        '\u22D4': 'fork',
        '\u22D5': 'epar',
        '\u22D6': 'ltdot',
        '\u22D7': 'gtdot',
        '\u22D8': 'Ll',
        '\u22D8': 'nLl',
        '\u22D9': 'Gg',
        '\u22D9': 'nGg',
        '\u22DA': 'lesg',
        '\u22DA': 'leg',
        '\u22DB': 'gel',
        '\u22DB': 'gesl',
        '\u22DE': 'cuepr',
        '\u22DF': 'cuesc',
        '\u22E6': 'lnsim',
        '\u22E7': 'gnsim',
        '\u22E8': 'prnsim',
        '\u22E9': 'scnsim',
        '\u22EE': 'vellip',
        '\u22EF': 'ctdot',
        '\u22F0': 'utdot',
        '\u22F1': 'dtdot',
        '\u22F2': 'disin',
        '\u22F3': 'isinsv',
        '\u22F4': 'isins',
        '\u22F5': 'isindot',
        '\u22F5': 'notindot',
        '\u22F6': 'notinvc',
        '\u22F7': 'notinvb',
        '\u22F9': 'isinE',
        '\u22F9': 'notinE',
        '\u22FA': 'nisd',
        '\u22FB': 'xnis',
        '\u22FC': 'nis',
        '\u22FD': 'notnivc',
        '\u22FE': 'notnivb',
        '\u2305': 'barwed',
        '\u2306': 'Barwed',
        '\u230C': 'drcrop',
        '\u230D': 'dlcrop',
        '\u230E': 'urcrop',
        '\u230F': 'ulcrop',
        '\u2310': 'bnot',
        '\u2312': 'profline',
        '\u2313': 'profsurf',
        '\u2315': 'telrec',
        '\u2316': 'target',
        '\u231C': 'ulcorn',
        '\u231D': 'urcorn',
        '\u231E': 'dlcorn',
        '\u231F': 'drcorn',
        '\u2322': 'frown',
        '\u2323': 'smile',
        '\u232D': 'cylcty',
        '\u232E': 'profalar',
        '\u2336': 'topbot',
        '\u233D': 'ovbar',
        '\u233F': 'solbar',
        '\u237C': 'angzarr',
        '\u23B0': 'lmoust',
        '\u23B1': 'rmoust',
        '\u23B4': 'tbrk',
        '\u23B5': 'bbrk',
        '\u23B6': 'bbrktbrk',
        '\u23DC': 'OverParenthesis',
        '\u23DD': 'UnderParenthesis',
        '\u23DE': 'OverBrace',
        '\u23DF': 'UnderBrace',
        '\u23E2': 'trpezium',
        '\u23E7': 'elinters',
        '\u2423': 'blank',
        '\u2500': 'boxh',
        '\u2502': 'boxv',
        '\u250C': 'boxdr',
        '\u2510': 'boxdl',
        '\u2514': 'boxur',
        '\u2518': 'boxul',
        '\u251C': 'boxvr',
        '\u2524': 'boxvl',
        '\u252C': 'boxhd',
        '\u2534': 'boxhu',
        '\u253C': 'boxvh',
        '\u2550': 'boxH',
        '\u2551': 'boxV',
        '\u2552': 'boxdR',
        '\u2553': 'boxDr',
        '\u2554': 'boxDR',
        '\u2555': 'boxdL',
        '\u2556': 'boxDl',
        '\u2557': 'boxDL',
        '\u2558': 'boxuR',
        '\u2559': 'boxUr',
        '\u255A': 'boxUR',
        '\u255B': 'boxuL',
        '\u255C': 'boxUl',
        '\u255D': 'boxUL',
        '\u255E': 'boxvR',
        '\u255F': 'boxVr',
        '\u2560': 'boxVR',
        '\u2561': 'boxvL',
        '\u2562': 'boxVl',
        '\u2563': 'boxVL',
        '\u2564': 'boxHd',
        '\u2565': 'boxhD',
        '\u2566': 'boxHD',
        '\u2567': 'boxHu',
        '\u2568': 'boxhU',
        '\u2569': 'boxHU',
        '\u256A': 'boxvH',
        '\u256B': 'boxVh',
        '\u256C': 'boxVH',
        '\u2580': 'uhblk',
        '\u2584': 'lhblk',
        '\u2588': 'block',
        '\u2591': 'blk14',
        '\u2592': 'blk12',
        '\u2593': 'blk34',
        '\u25A1': 'squ',
        '\u25AA': 'squf',
        '\u25AB': 'EmptyVerySmallSquare',
        '\u25AD': 'rect',
        '\u25AE': 'marker',
        '\u25B1': 'fltns',
        '\u25B3': 'xutri',
        '\u25B4': 'utrif',
        '\u25B5': 'utri',
        '\u25B8': 'rtrif',
        '\u25B9': 'rtri',
        '\u25BD': 'xdtri',
        '\u25BE': 'dtrif',
        '\u25BF': 'dtri',
        '\u25C2': 'ltrif',
        '\u25C3': 'ltri',
        '\u25CA': 'loz',
        '\u25CB': 'cir',
        '\u25EC': 'tridot',
        '\u25EF': 'xcirc',
        '\u25F8': 'ultri',
        '\u25F9': 'urtri',
        '\u25FA': 'lltri',
        '\u25FB': 'EmptySmallSquare',
        '\u25FC': 'FilledSmallSquare',
        '\u2605': 'starf',
        '\u2606': 'star',
        '\u260E': 'phone',
        '\u2640': 'female',
        '\u2642': 'male',
        '\u2660': 'spades',
        '\u2663': 'clubs',
        '\u2665': 'hearts',
        '\u2666': 'diams',
        '\u266A': 'sung',
        '\u2713': 'check',
        '\u2717': 'cross',
        '\u2720': 'malt',
        '\u2736': 'sext',
        '\u2758': 'VerticalSeparator',
        '\u27C8': 'bsolhsub',
        '\u27C9': 'suphsol',
        '\u27F5': 'xlarr',
        '\u27F6': 'xrarr',
        '\u27F7': 'xharr',
        '\u27F8': 'xlArr',
        '\u27F9': 'xrArr',
        '\u27FA': 'xhArr',
        '\u27FC': 'xmap',
        '\u27FF': 'dzigrarr',
        '\u2902': 'nvlArr',
        '\u2903': 'nvrArr',
        '\u2904': 'nvHarr',
        '\u2905': 'Map',
        '\u290C': 'lbarr',
        '\u290D': 'rbarr',
        '\u290E': 'lBarr',
        '\u290F': 'rBarr',
        '\u2910': 'RBarr',
        '\u2911': 'DDotrahd',
        '\u2912': 'UpArrowBar',
        '\u2913': 'DownArrowBar',
        '\u2916': 'Rarrtl',
        '\u2919': 'latail',
        '\u291A': 'ratail',
        '\u291B': 'lAtail',
        '\u291C': 'rAtail',
        '\u291D': 'larrfs',
        '\u291E': 'rarrfs',
        '\u291F': 'larrbfs',
        '\u2920': 'rarrbfs',
        '\u2923': 'nwarhk',
        '\u2924': 'nearhk',
        '\u2925': 'searhk',
        '\u2926': 'swarhk',
        '\u2927': 'nwnear',
        '\u2928': 'toea',
        '\u2929': 'tosa',
        '\u292A': 'swnwar',
        '\u2933': 'rarrc',
        '\u2933': 'nrarrc',
        '\u2935': 'cudarrr',
        '\u2936': 'ldca',
        '\u2937': 'rdca',
        '\u2938': 'cudarrl',
        '\u2939': 'larrpl',
        '\u293C': 'curarrm',
        '\u293D': 'cularrp',
        '\u2945': 'rarrpl',
        '\u2948': 'harrcir',
        '\u2949': 'Uarrocir',
        '\u294A': 'lurdshar',
        '\u294B': 'ldrushar',
        '\u294E': 'LeftRightVector',
        '\u294F': 'RightUpDownVector',
        '\u2950': 'DownLeftRightVector',
        '\u2951': 'LeftUpDownVector',
        '\u2952': 'LeftVectorBar',
        '\u2953': 'RightVectorBar',
        '\u2954': 'RightUpVectorBar',
        '\u2955': 'RightDownVectorBar',
        '\u2956': 'DownLeftVectorBar',
        '\u2957': 'DownRightVectorBar',
        '\u2958': 'LeftUpVectorBar',
        '\u2959': 'LeftDownVectorBar',
        '\u295A': 'LeftTeeVector',
        '\u295B': 'RightTeeVector',
        '\u295C': 'RightUpTeeVector',
        '\u295D': 'RightDownTeeVector',
        '\u295E': 'DownLeftTeeVector',
        '\u295F': 'DownRightTeeVector',
        '\u2960': 'LeftUpTeeVector',
        '\u2961': 'LeftDownTeeVector',
        '\u2962': 'lHar',
        '\u2963': 'uHar',
        '\u2964': 'rHar',
        '\u2965': 'dHar',
        '\u2966': 'luruhar',
        '\u2967': 'ldrdhar',
        '\u2968': 'ruluhar',
        '\u2969': 'rdldhar',
        '\u296A': 'lharul',
        '\u296B': 'llhard',
        '\u296C': 'rharul',
        '\u296D': 'lrhard',
        '\u296E': 'udhar',
        '\u296F': 'duhar',
        '\u2970': 'RoundImplies',
        '\u2971': 'erarr',
        '\u2972': 'simrarr',
        '\u2973': 'larrsim',
        '\u2974': 'rarrsim',
        '\u2975': 'rarrap',
        '\u2976': 'ltlarr',
        '\u2978': 'gtrarr',
        '\u2979': 'subrarr',
        '\u297B': 'suplarr',
        '\u297C': 'lfisht',
        '\u297D': 'rfisht',
        '\u297E': 'ufisht',
        '\u297F': 'dfisht',
        '\u299A': 'vzigzag',
        '\u299C': 'vangrt',
        '\u299D': 'angrtvbd',
        '\u29A4': 'ange',
        '\u29A5': 'range',
        '\u29A6': 'dwangle',
        '\u29A7': 'uwangle',
        '\u29A8': 'angmsdaa',
        '\u29A9': 'angmsdab',
        '\u29AA': 'angmsdac',
        '\u29AB': 'angmsdad',
        '\u29AC': 'angmsdae',
        '\u29AD': 'angmsdaf',
        '\u29AE': 'angmsdag',
        '\u29AF': 'angmsdah',
        '\u29B0': 'bemptyv',
        '\u29B1': 'demptyv',
        '\u29B2': 'cemptyv',
        '\u29B3': 'raemptyv',
        '\u29B4': 'laemptyv',
        '\u29B5': 'ohbar',
        '\u29B6': 'omid',
        '\u29B7': 'opar',
        '\u29B9': 'operp',
        '\u29BB': 'olcross',
        '\u29BC': 'odsold',
        '\u29BE': 'olcir',
        '\u29BF': 'ofcir',
        '\u29C0': 'olt',
        '\u29C1': 'ogt',
        '\u29C2': 'cirscir',
        '\u29C3': 'cirE',
        '\u29C4': 'solb',
        '\u29C5': 'bsolb',
        '\u29C9': 'boxbox',
        '\u29CD': 'trisb',
        '\u29CE': 'rtriltri',
        '\u29CF': 'LeftTriangleBar',
        '\u29CF': 'NotLeftTriangleBar',
        '\u29D0': 'RightTriangleBar',
        '\u29D0': 'NotRightTriangleBar',
        '\u29DC': 'iinfin',
        '\u29DD': 'infintie',
        '\u29DE': 'nvinfin',
        '\u29E3': 'eparsl',
        '\u29E4': 'smeparsl',
        '\u29E5': 'eqvparsl',
        '\u29EB': 'lozf',
        '\u29F4': 'RuleDelayed',
        '\u29F6': 'dsol',
        '\u2A00': 'xodot',
        '\u2A01': 'xoplus',
        '\u2A02': 'xotime',
        '\u2A04': 'xuplus',
        '\u2A06': 'xsqcup',
        '\u2A0D': 'fpartint',
        '\u2A10': 'cirfnint',
        '\u2A11': 'awint',
        '\u2A12': 'rppolint',
        '\u2A13': 'scpolint',
        '\u2A14': 'npolint',
        '\u2A15': 'pointint',
        '\u2A16': 'quatint',
        '\u2A17': 'intlarhk',
        '\u2A22': 'pluscir',
        '\u2A23': 'plusacir',
        '\u2A24': 'simplus',
        '\u2A25': 'plusdu',
        '\u2A26': 'plussim',
        '\u2A27': 'plustwo',
        '\u2A29': 'mcomma',
        '\u2A2A': 'minusdu',
        '\u2A2D': 'loplus',
        '\u2A2E': 'roplus',
        '\u2A2F': 'Cross',
        '\u2A30': 'timesd',
        '\u2A31': 'timesbar',
        '\u2A33': 'smashp',
        '\u2A34': 'lotimes',
        '\u2A35': 'rotimes',
        '\u2A36': 'otimesas',
        '\u2A37': 'Otimes',
        '\u2A38': 'odiv',
        '\u2A39': 'triplus',
        '\u2A3A': 'triminus',
        '\u2A3B': 'tritime',
        '\u2A3C': 'iprod',
        '\u2A3F': 'amalg',
        '\u2A40': 'capdot',
        '\u2A42': 'ncup',
        '\u2A43': 'ncap',
        '\u2A44': 'capand',
        '\u2A45': 'cupor',
        '\u2A46': 'cupcap',
        '\u2A47': 'capcup',
        '\u2A48': 'cupbrcap',
        '\u2A49': 'capbrcup',
        '\u2A4A': 'cupcup',
        '\u2A4B': 'capcap',
        '\u2A4C': 'ccups',
        '\u2A4D': 'ccaps',
        '\u2A50': 'ccupssm',
        '\u2A53': 'And',
        '\u2A54': 'Or',
        '\u2A55': 'andand',
        '\u2A56': 'oror',
        '\u2A57': 'orslope',
        '\u2A58': 'andslope',
        '\u2A5A': 'andv',
        '\u2A5B': 'orv',
        '\u2A5C': 'andd',
        '\u2A5D': 'ord',
        '\u2A5F': 'wedbar',
        '\u2A66': 'sdote',
        '\u2A6A': 'simdot',
        '\u2A6D': 'congdot',
        '\u2A6D': 'ncongdot',
        '\u2A6E': 'easter',
        '\u2A6F': 'apacir',
        '\u2A70': 'apE',
        '\u2A70': 'napE',
        '\u2A71': 'eplus',
        '\u2A72': 'pluse',
        '\u2A73': 'Esim',
        '\u2A77': 'eDDot',
        '\u2A78': 'equivDD',
        '\u2A79': 'ltcir',
        '\u2A7A': 'gtcir',
        '\u2A7B': 'ltquest',
        '\u2A7C': 'gtquest',
        '\u2A7D': 'les',
        '\u2A7D': 'nles',
        '\u2A7E': 'ges',
        '\u2A7E': 'nges',
        '\u2A7F': 'lesdot',
        '\u2A80': 'gesdot',
        '\u2A81': 'lesdoto',
        '\u2A82': 'gesdoto',
        '\u2A83': 'lesdotor',
        '\u2A84': 'gesdotol',
        '\u2A85': 'lap',
        '\u2A86': 'gap',
        '\u2A87': 'lne',
        '\u2A88': 'gne',
        '\u2A89': 'lnap',
        '\u2A8A': 'gnap',
        '\u2A8B': 'lEg',
        '\u2A8C': 'gEl',
        '\u2A8D': 'lsime',
        '\u2A8E': 'gsime',
        '\u2A8F': 'lsimg',
        '\u2A90': 'gsiml',
        '\u2A91': 'lgE',
        '\u2A92': 'glE',
        '\u2A93': 'lesges',
        '\u2A94': 'gesles',
        '\u2A95': 'els',
        '\u2A96': 'egs',
        '\u2A97': 'elsdot',
        '\u2A98': 'egsdot',
        '\u2A99': 'el',
        '\u2A9A': 'eg',
        '\u2A9D': 'siml',
        '\u2A9E': 'simg',
        '\u2A9F': 'simlE',
        '\u2AA0': 'simgE',
        '\u2AA1': 'LessLess',
        '\u2AA1': 'NotNestedLessLess',
        '\u2AA2': 'GreaterGreater',
        '\u2AA2': 'NotNestedGreaterGreater',
        '\u2AA4': 'glj',
        '\u2AA5': 'gla',
        '\u2AA6': 'ltcc',
        '\u2AA7': 'gtcc',
        '\u2AA8': 'lescc',
        '\u2AA9': 'gescc',
        '\u2AAA': 'smt',
        '\u2AAB': 'lat',
        '\u2AAC': 'smte',
        '\u2AAC': 'smtes',
        '\u2AAD': 'late',
        '\u2AAD': 'lates',
        '\u2AAE': 'bumpE',
        '\u2AAF': 'pre',
        '\u2AAF': 'npre',
        '\u2AB0': 'sce',
        '\u2AB0': 'nsce',
        '\u2AB3': 'prE',
        '\u2AB4': 'scE',
        '\u2AB5': 'prnE',
        '\u2AB6': 'scnE',
        '\u2AB7': 'prap',
        '\u2AB8': 'scap',
        '\u2AB9': 'prnap',
        '\u2ABA': 'scnap',
        '\u2ABB': 'Pr',
        '\u2ABC': 'Sc',
        '\u2ABD': 'subdot',
        '\u2ABE': 'supdot',
        '\u2ABF': 'subplus',
        '\u2AC0': 'supplus',
        '\u2AC1': 'submult',
        '\u2AC2': 'supmult',
        '\u2AC3': 'subedot',
        '\u2AC4': 'supedot',
        '\u2AC5': 'subE',
        '\u2AC5': 'nsubE',
        '\u2AC6': 'supE',
        '\u2AC6': 'nsupE',
        '\u2AC7': 'subsim',
        '\u2AC8': 'supsim',
        '\u2ACB': 'vsubnE',
        '\u2ACB': 'subnE',
        '\u2ACC': 'vsupnE',
        '\u2ACC': 'supnE',
        '\u2ACF': 'csub',
        '\u2AD0': 'csup',
        '\u2AD1': 'csube',
        '\u2AD2': 'csupe',
        '\u2AD3': 'subsup',
        '\u2AD4': 'supsub',
        '\u2AD5': 'subsub',
        '\u2AD6': 'supsup',
        '\u2AD7': 'suphsub',
        '\u2AD8': 'supdsub',
        '\u2AD9': 'forkv',
        '\u2ADA': 'topfork',
        '\u2ADB': 'mlcp',
        '\u2AE4': 'Dashv',
        '\u2AE6': 'Vdashl',
        '\u2AE7': 'Barv',
        '\u2AE8': 'vBar',
        '\u2AE9': 'vBarv',
        '\u2AEB': 'Vbar',
        '\u2AEC': 'Not',
        '\u2AED': 'bNot',
        '\u2AEE': 'rnmid',
        '\u2AEF': 'cirmid',
        '\u2AF0': 'midcir',
        '\u2AF1': 'topcir',
        '\u2AF2': 'nhpar',
        '\u2AF3': 'parsim',
        '\u2AFD': 'parsl',
        '\u2AFD': 'nparsl',
        '\u266D': 'flat',
        '\u266E': 'natur',
        '\u266F': 'sharp',
        '\xA4': 'curren',
        '\xA2': 'cent',
        '$': 'dollar',
        '\xA3': 'pound',
        '\xA5': 'yen',
        '\u20AC': 'euro',
        '\xB9': 'sup1',
        '\xBD': 'half',
        '\u2153': 'frac13',
        '\xBC': 'frac14',
        '\u2155': 'frac15',
        '\u2159': 'frac16',
        '\u215B': 'frac18',
        '\xB2': 'sup2',
        '\u2154': 'frac23',
        '\u2156': 'frac25',
        '\xB3': 'sup3',
        '\xBE': 'frac34',
        '\u2157': 'frac35',
        '\u215C': 'frac38',
        '\u2158': 'frac45',
        '\u215A': 'frac56',
        '\u215D': 'frac58',
        '\u215E': 'frac78',
        '\uD835\uDCB6': 'ascr',
        '\uD835\uDD52': 'aopf',
        '\uD835\uDD1E': 'afr',
        '\uD835\uDD38': 'Aopf',
        '\uD835\uDD04': 'Afr',
        '\uD835\uDC9C': 'Ascr',
        '': 'ordf',
        '': 'aacute',
        '': 'Aacute',
        '': 'agrave',
        '': 'Agrave',
        '': 'abreve',
        '': 'Abreve',
        '': 'acirc',
        '': 'Acirc',
        '': 'aring',
        '': 'angst',
        '': 'auml',
        '': 'Auml',
        '': 'atilde',
        '': 'Atilde',
        '': 'aogon',
        '': 'Aogon',
        '': 'amacr',
        '': 'Amacr',
        '': 'aelig',
        '': 'AElig',
        '\uD835\uDCB7': 'bscr',
        '\uD835\uDD53': 'bopf',
        '\uD835\uDD1F': 'bfr',
        '\uD835\uDD39': 'Bopf',
        '': 'Bscr',
        '\uD835\uDD05': 'Bfr',
        '\uD835\uDD20': 'cfr',
        '\uD835\uDCB8': 'cscr',
        '\uD835\uDD54': 'copf',
        '': 'Cfr',
        '\uD835\uDC9E': 'Cscr',
        '': 'Copf',
        '': 'cacute',
        '': 'Cacute',
        '': 'ccirc',
        '': 'Ccirc',
        '': 'ccaron',
        '': 'Ccaron',
        '': 'cdot',
        '': 'Cdot',
        '': 'ccedil',
        '': 'Ccedil',
        '\u2105': 'incare',
        '\uD835\uDD21': 'dfr',
        '': 'dd',
        '\uD835\uDD55': 'dopf',
        '\uD835\uDCB9': 'dscr',
        '\uD835\uDC9F': 'Dscr',
        '\uD835\uDD07': 'Dfr',
        '': 'DD',
        '\uD835\uDD3B': 'Dopf',
        '': 'dcaron',
        '': 'Dcaron',
        '': 'dstrok',
        '': 'Dstrok',
        '': 'eth',
        '': 'ETH',
        '': 'ee',
        '': 'escr',
        '\uD835\uDD22': 'efr',
        '\uD835\uDD56': 'eopf',
        '': 'Escr',
        '\uD835\uDD08': 'Efr',
        '\uD835\uDD3C': 'Eopf',
        '': 'eacute',
        '': 'Eacute',
        '': 'egrave',
        '': 'Egrave',
        '': 'ecirc',
        '': 'Ecirc',
        '': 'ecaron',
        '': 'Ecaron',
        '': 'euml',
        '': 'Euml',
        '': 'edot',
        '': 'Edot',
        '': 'eogon',
        '': 'Eogon',
        '': 'emacr',
        '': 'Emacr',
        '\uD835\uDD23': 'ffr',
        '\uD835\uDD57': 'fopf',
        '\uD835\uDCBB': 'fscr',
        '\uD835\uDD09': 'Ffr',
        '\uD835\uDD3D': 'Fopf',
        '': 'Fscr',
        '': 'fflig',
        '': 'ffilig',
        '': 'ffllig',
        '': 'filig',
        'fj': 'fjlig',
        '': 'fllig',
        '': 'fnof',
        '': 'gscr',
        '\uD835\uDD58': 'gopf',
        '\uD835\uDD24': 'gfr',
        '\uD835\uDCA2': 'Gscr',
        '\uD835\uDD3E': 'Gopf',
        '\uD835\uDD0A': 'Gfr',
        '': 'gacute',
        '': 'gbreve',
        '': 'Gbreve',
        '': 'gcirc',
        '': 'Gcirc',
        '': 'gdot',
        '': 'Gdot',
        '': 'Gcedil',
        '\uD835\uDD25': 'hfr',
        '': 'planckh',
        '\uD835\uDCBD': 'hscr',
        '\uD835\uDD59': 'hopf',
        '': 'Hscr',
        '': 'Hfr',
        '': 'Hopf',
        '': 'hcirc',
        '': 'Hcirc',
        '': 'hbar',
        '': 'hstrok',
        '': 'Hstrok',
        '\uD835\uDD5A': 'iopf',
        '\uD835\uDD26': 'ifr',
        '\uD835\uDCBE': 'iscr',
        '': 'ii',
        '\uD835\uDD40': 'Iopf',
        '': 'Iscr',
        '': 'Im',
        '': 'iacute',
        '': 'Iacute',
        '': 'igrave',
        '': 'Igrave',
        '': 'icirc',
        '': 'Icirc',
        '': 'iuml',
        '': 'Iuml',
        '': 'itilde',
        '': 'Itilde',
        '': 'Idot',
        '': 'iogon',
        '': 'Iogon',
        '': 'imacr',
        '': 'Imacr',
        '': 'ijlig',
        '': 'IJlig',
        '': 'imath',
        '\uD835\uDCBF': 'jscr',
        '\uD835\uDD5B': 'jopf',
        '\uD835\uDD27': 'jfr',
        '\uD835\uDCA5': 'Jscr',
        '\uD835\uDD0D': 'Jfr',
        '\uD835\uDD41': 'Jopf',
        '': 'jcirc',
        '': 'Jcirc',
        '': 'jmath',
        '\uD835\uDD5C': 'kopf',
        '\uD835\uDCC0': 'kscr',
        '\uD835\uDD28': 'kfr',
        '\uD835\uDCA6': 'Kscr',
        '\uD835\uDD42': 'Kopf',
        '\uD835\uDD0E': 'Kfr',
        '': 'kcedil',
        '': 'Kcedil',
        '\uD835\uDD29': 'lfr',
        '\uD835\uDCC1': 'lscr',
        '': 'ell',
        '\uD835\uDD5D': 'lopf',
        '': 'Lscr',
        '\uD835\uDD0F': 'Lfr',
        '\uD835\uDD43': 'Lopf',
        '': 'lacute',
        '': 'Lacute',
        '': 'lcaron',
        '': 'Lcaron',
        '': 'lcedil',
        '': 'Lcedil',
        '': 'lstrok',
        '': 'Lstrok',
        '': 'lmidot',
        '': 'Lmidot',
        '\uD835\uDD2A': 'mfr',
        '\uD835\uDD5E': 'mopf',
        '\uD835\uDCC2': 'mscr',
        '\uD835\uDD10': 'Mfr',
        '\uD835\uDD44': 'Mopf',
        '': 'Mscr',
        '\uD835\uDD2B': 'nfr',
        '\uD835\uDD5F': 'nopf',
        '\uD835\uDCC3': 'nscr',
        '': 'Nopf',
        '\uD835\uDCA9': 'Nscr',
        '\uD835\uDD11': 'Nfr',
        '': 'nacute',
        '': 'Nacute',
        '': 'ncaron',
        '': 'Ncaron',
        '': 'ntilde',
        '': 'Ntilde',
        '': 'ncedil',
        '': 'Ncedil',
        '\u2116': 'numero',
        '': 'eng',
        '': 'ENG',
        '\uD835\uDD60': 'oopf',
        '\uD835\uDD2C': 'ofr',
        '': 'oscr',
        '\uD835\uDCAA': 'Oscr',
        '\uD835\uDD12': 'Ofr',
        '\uD835\uDD46': 'Oopf',
        '': 'ordm',
        '': 'oacute',
        '': 'Oacute',
        '': 'ograve',
        '': 'Ograve',
        '': 'ocirc',
        '': 'Ocirc',
        '': 'ouml',
        '': 'Ouml',
        '': 'odblac',
        '': 'Odblac',
        '': 'otilde',
        '': 'Otilde',
        '': 'oslash',
        '': 'Oslash',
        '': 'omacr',
        '': 'Omacr',
        '': 'oelig',
        '': 'OElig',
        '\uD835\uDD2D': 'pfr',
        '\uD835\uDCC5': 'pscr',
        '\uD835\uDD61': 'popf',
        '': 'Popf',
        '\uD835\uDD13': 'Pfr',
        '\uD835\uDCAB': 'Pscr',
        '\uD835\uDD62': 'qopf',
        '\uD835\uDD2E': 'qfr',
        '\uD835\uDCC6': 'qscr',
        '\uD835\uDCAC': 'Qscr',
        '\uD835\uDD14': 'Qfr',
        '': 'Qopf',
        '': 'kgreen',
        '\uD835\uDD2F': 'rfr',
        '\uD835\uDD63': 'ropf',
        '\uD835\uDCC7': 'rscr',
        '': 'Rscr',
        '': 'Re',
        '': 'Ropf',
        '': 'racute',
        '': 'Racute',
        '': 'rcaron',
        '': 'Rcaron',
        '': 'rcedil',
        '': 'Rcedil',
        '\uD835\uDD64': 'sopf',
        '\uD835\uDCC8': 'sscr',
        '\uD835\uDD30': 'sfr',
        '\uD835\uDD4A': 'Sopf',
        '\uD835\uDD16': 'Sfr',
        '\uD835\uDCAE': 'Sscr',
        '\u24C8': 'oS',
        '': 'sacute',
        '': 'Sacute',
        '': 'scirc',
        '': 'Scirc',
        '': 'scaron',
        '': 'Scaron',
        '': 'scedil',
        '': 'Scedil',
        '': 'szlig',
        '\uD835\uDD31': 'tfr',
        '\uD835\uDCC9': 'tscr',
        '\uD835\uDD65': 'topf',
        '\uD835\uDCAF': 'Tscr',
        '\uD835\uDD17': 'Tfr',
        '\uD835\uDD4B': 'Topf',
        '': 'tcaron',
        '': 'Tcaron',
        '': 'tcedil',
        '': 'Tcedil',
        '\u2122': 'trade',
        '': 'tstrok',
        '': 'Tstrok',
        '\uD835\uDCCA': 'uscr',
        '\uD835\uDD66': 'uopf',
        '\uD835\uDD32': 'ufr',
        '\uD835\uDD4C': 'Uopf',
        '\uD835\uDD18': 'Ufr',
        '\uD835\uDCB0': 'Uscr',
        '': 'uacute',
        '': 'Uacute',
        '': 'ugrave',
        '': 'Ugrave',
        '': 'ubreve',
        '': 'Ubreve',
        '': 'ucirc',
        '': 'Ucirc',
        '': 'uring',
        '': 'Uring',
        '': 'uuml',
        '': 'Uuml',
        '': 'udblac',
        '': 'Udblac',
        '': 'utilde',
        '': 'Utilde',
        '': 'uogon',
        '': 'Uogon',
        '': 'umacr',
        '': 'Umacr',
        '\uD835\uDD33': 'vfr',
        '\uD835\uDD67': 'vopf',
        '\uD835\uDCCB': 'vscr',
        '\uD835\uDD19': 'Vfr',
        '\uD835\uDD4D': 'Vopf',
        '\uD835\uDCB1': 'Vscr',
        '\uD835\uDD68': 'wopf',
        '\uD835\uDCCC': 'wscr',
        '\uD835\uDD34': 'wfr',
        '\uD835\uDCB2': 'Wscr',
        '\uD835\uDD4E': 'Wopf',
        '\uD835\uDD1A': 'Wfr',
        '': 'wcirc',
        '': 'Wcirc',
        '\uD835\uDD35': 'xfr',
        '\uD835\uDCCD': 'xscr',
        '\uD835\uDD69': 'xopf',
        '\uD835\uDD4F': 'Xopf',
        '\uD835\uDD1B': 'Xfr',
        '\uD835\uDCB3': 'Xscr',
        '\uD835\uDD36': 'yfr',
        '\uD835\uDCCE': 'yscr',
        '\uD835\uDD6A': 'yopf',
        '\uD835\uDCB4': 'Yscr',
        '\uD835\uDD1C': 'Yfr',
        '\uD835\uDD50': 'Yopf',
        '': 'yacute',
        '': 'Yacute',
        '': 'ycirc',
        '': 'Ycirc',
        '': 'yuml',
        '': 'Yuml',
        '\uD835\uDCCF': 'zscr',
        '\uD835\uDD37': 'zfr',
        '\uD835\uDD6B': 'zopf',
        '': 'Zfr',
        '': 'Zopf',
        '\uD835\uDCB5': 'Zscr',
        '': 'zacute',
        '': 'Zacute',
        '': 'zcaron',
        '': 'Zcaron',
        '': 'zdot',
        '': 'Zdot',
        '': 'imped',
        '': 'thorn',
        '': 'THORN',
        '': 'napos',
        '': 'alpha',
        '': 'Alpha',
        '': 'beta',
        '': 'Beta',
        '': 'gamma',
        '': 'Gamma',
        '': 'delta',
        '': 'Delta',
        '': 'epsi',
        '': 'epsiv',
        '': 'Epsilon',
        '': 'gammad',
        '': 'Gammad',
        '': 'zeta',
        '': 'Zeta',
        '': 'eta',
        '': 'Eta',
        '': 'theta',
        '': 'thetav',
        '': 'Theta',
        '': 'iota',
        '': 'Iota',
        '': 'kappa',
        '': 'kappav',
        '': 'Kappa',
        '': 'lambda',
        '': 'Lambda',
        '': 'mu',
        '': 'micro',
        '': 'Mu',
        '': 'nu',
        '': 'Nu',
        '': 'xi',
        '': 'Xi',
        '': 'omicron',
        '': 'Omicron',
        '': 'pi',
        '': 'piv',
        '': 'Pi',
        '': 'rho',
        '': 'rhov',
        '': 'Rho',
        '': 'sigma',
        '': 'Sigma',
        '': 'sigmaf',
        '': 'tau',
        '': 'Tau',
        '': 'upsi',
        '': 'Upsilon',
        '': 'Upsi',
        '': 'phi',
        '': 'phiv',
        '': 'Phi',
        '': 'chi',
        '': 'Chi',
        '': 'psi',
        '': 'Psi',
        '': 'omega',
        '': 'ohm',
        '': 'acy',
        '': 'Acy',
        '': 'bcy',
        '': 'Bcy',
        '': 'vcy',
        '': 'Vcy',
        '': 'gcy',
        '': 'Gcy',
        '': 'gjcy',
        '': 'GJcy',
        '': 'dcy',
        '': 'Dcy',
        '': 'djcy',
        '': 'DJcy',
        '': 'iecy',
        '': 'IEcy',
        '': 'iocy',
        '': 'IOcy',
        '': 'jukcy',
        '': 'Jukcy',
        '': 'zhcy',
        '': 'ZHcy',
        '': 'zcy',
        '': 'Zcy',
        '': 'dscy',
        '': 'DScy',
        '': 'icy',
        '': 'Icy',
        '': 'iukcy',
        '': 'Iukcy',
        '': 'yicy',
        '': 'YIcy',
        '': 'jcy',
        '': 'Jcy',
        '': 'jsercy',
        '': 'Jsercy',
        '': 'kcy',
        '': 'Kcy',
        '': 'kjcy',
        '': 'KJcy',
        '': 'lcy',
        '': 'Lcy',
        '': 'ljcy',
        '': 'LJcy',
        '': 'mcy',
        '': 'Mcy',
        '': 'ncy',
        '': 'Ncy',
        '': 'njcy',
        '': 'NJcy',
        '': 'ocy',
        '': 'Ocy',
        '': 'pcy',
        '': 'Pcy',
        '': 'rcy',
        '': 'Rcy',
        '': 'scy',
        '': 'Scy',
        '': 'tcy',
        '': 'Tcy',
        '': 'tshcy',
        '': 'TSHcy',
        '': 'ucy',
        '': 'Ucy',
        '': 'ubrcy',
        '': 'Ubrcy',
        '': 'fcy',
        '': 'Fcy',
        '': 'khcy',
        '': 'KHcy',
        '': 'tscy',
        '': 'TScy',
        '': 'chcy',
        '': 'CHcy',
        '': 'dzcy',
        '': 'DZcy',
        '': 'shcy',
        '': 'SHcy',
        '': 'shchcy',
        '': 'SHCHcy',
        '': 'hardcy',
        '': 'HARDcy',
        '': 'ycy',
        '': 'Ycy',
        '': 'softcy',
        '': 'SOFTcy',
        '': 'ecy',
        '': 'Ecy',
        '': 'yucy',
        '': 'YUcy',
        '': 'yacy',
        '': 'YAcy',
        '': 'aleph',
        '': 'beth',
        '': 'gimel',
        '': 'daleth'
    };
    var regexEscape = /["&'<>`]/g;
    var escapeMap = {
        '"': '&quot;',
        '&': '&amp;',
        '\'': '&#x27;',
        '<': '&lt;',
        '>': '&gt;',
        '`': '&#x60;'
    };
    var regexInvalidEntity = /&#(?:[xX][^a-fA-F0-9]|[^0-9xX])/;
    var regexInvalidRawCodePoint = /[\0-\x08\x0B\x0E-\x1F\x7F-\x9F\uFDD0-\uFDEF\uFFFE\uFFFF]|[\uD83F\uD87F\uD8BF\uD8FF\uD93F\uD97F\uD9BF\uD9FF\uDA3F\uDA7F\uDABF\uDAFF\uDB3F\uDB7F\uDBBF\uDBFF][\uDFFE\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
    var regexDecode = /&#([0-9]+)(;?)|&#[xX]([a-fA-F0-9]+)(;?)|&([0-9a-zA-Z]+);|&(Aacute|Agrave|Atilde|Ccedil|Eacute|Egrave|Iacute|Igrave|Ntilde|Oacute|Ograve|Oslash|Otilde|Uacute|Ugrave|Yacute|aacute|agrave|atilde|brvbar|ccedil|curren|divide|eacute|egrave|frac12|frac14|frac34|iacute|igrave|iquest|middot|ntilde|oacute|ograve|oslash|otilde|plusmn|uacute|ugrave|yacute|AElig|Acirc|Aring|Ecirc|Icirc|Ocirc|THORN|Ucirc|acirc|acute|aelig|aring|cedil|ecirc|icirc|iexcl|laquo|micro|ocirc|pound|raquo|szlig|thorn|times|ucirc|Auml|COPY|Euml|Iuml|Ouml|QUOT|Uuml|auml|cent|copy|euml|iuml|macr|nbsp|ordf|ordm|ouml|para|quot|sect|sup1|sup2|sup3|uuml|yuml|AMP|ETH|REG|amp|deg|eth|not|reg|shy|uml|yen|GT|LT|gt|lt)([=a-zA-Z0-9])?/g;
    var decodeMap = {
        'aacute': '',
        'Aacute': '',
        'abreve': '',
        'Abreve': '',
        'ac': '\u223E',
        'acd': '\u223F',
        'acE': '\u223E',
        'acirc': '',
        'Acirc': '',
        'acute': '\xB4',
        'acy': '',
        'Acy': '',
        'aelig': '',
        'AElig': '',
        'af': '\u2061',
        'afr': '\uD835\uDD1E',
        'Afr': '\uD835\uDD04',
        'agrave': '',
        'Agrave': '',
        'alefsym': '',
        'aleph': '',
        'alpha': '',
        'Alpha': '',
        'amacr': '',
        'Amacr': '',
        'amalg': '\u2A3F',
        'amp': '&',
        'AMP': '&',
        'and': '\u2227',
        'And': '\u2A53',
        'andand': '\u2A55',
        'andd': '\u2A5C',
        'andslope': '\u2A58',
        'andv': '\u2A5A',
        'ang': '\u2220',
        'ange': '\u29A4',
        'angle': '\u2220',
        'angmsd': '\u2221',
        'angmsdaa': '\u29A8',
        'angmsdab': '\u29A9',
        'angmsdac': '\u29AA',
        'angmsdad': '\u29AB',
        'angmsdae': '\u29AC',
        'angmsdaf': '\u29AD',
        'angmsdag': '\u29AE',
        'angmsdah': '\u29AF',
        'angrt': '\u221F',
        'angrtvb': '\u22BE',
        'angrtvbd': '\u299D',
        'angsph': '\u2222',
        'angst': '',
        'angzarr': '\u237C',
        'aogon': '',
        'Aogon': '',
        'aopf': '\uD835\uDD52',
        'Aopf': '\uD835\uDD38',
        'ap': '\u2248',
        'apacir': '\u2A6F',
        'ape': '\u224A',
        'apE': '\u2A70',
        'apid': '\u224B',
        'apos': '\'',
        'ApplyFunction': '\u2061',
        'approx': '\u2248',
        'approxeq': '\u224A',
        'aring': '',
        'Aring': '',
        'ascr': '\uD835\uDCB6',
        'Ascr': '\uD835\uDC9C',
        'Assign': '\u2254',
        'ast': '*',
        'asymp': '\u2248',
        'asympeq': '\u224D',
        'atilde': '',
        'Atilde': '',
        'auml': '',
        'Auml': '',
        'awconint': '\u2233',
        'awint': '\u2A11',
        'backcong': '\u224C',
        'backepsilon': '\u03F6',
        'backprime': '\u2035',
        'backsim': '\u223D',
        'backsimeq': '\u22CD',
        'Backslash': '\u2216',
        'Barv': '\u2AE7',
        'barvee': '\u22BD',
        'barwed': '\u2305',
        'Barwed': '\u2306',
        'barwedge': '\u2305',
        'bbrk': '\u23B5',
        'bbrktbrk': '\u23B6',
        'bcong': '\u224C',
        'bcy': '',
        'Bcy': '',
        'bdquo': '\u201E',
        'becaus': '\u2235',
        'because': '\u2235',
        'Because': '\u2235',
        'bemptyv': '\u29B0',
        'bepsi': '\u03F6',
        'bernou': '',
        'Bernoullis': '',
        'beta': '',
        'Beta': '',
        'beth': '',
        'between': '\u226C',
        'bfr': '\uD835\uDD1F',
        'Bfr': '\uD835\uDD05',
        'bigcap': '\u22C2',
        'bigcirc': '\u25EF',
        'bigcup': '\u22C3',
        'bigodot': '\u2A00',
        'bigoplus': '\u2A01',
        'bigotimes': '\u2A02',
        'bigsqcup': '\u2A06',
        'bigstar': '\u2605',
        'bigtriangledown': '\u25BD',
        'bigtriangleup': '\u25B3',
        'biguplus': '\u2A04',
        'bigvee': '\u22C1',
        'bigwedge': '\u22C0',
        'bkarow': '\u290D',
        'blacklozenge': '\u29EB',
        'blacksquare': '\u25AA',
        'blacktriangle': '\u25B4',
        'blacktriangledown': '\u25BE',
        'blacktriangleleft': '\u25C2',
        'blacktriangleright': '\u25B8',
        'blank': '\u2423',
        'blk12': '\u2592',
        'blk14': '\u2591',
        'blk34': '\u2593',
        'block': '\u2588',
        'bne': '=',
        'bnequiv': '\u2261',
        'bnot': '\u2310',
        'bNot': '\u2AED',
        'bopf': '\uD835\uDD53',
        'Bopf': '\uD835\uDD39',
        'bot': '\u22A5',
        'bottom': '\u22A5',
        'bowtie': '\u22C8',
        'boxbox': '\u29C9',
        'boxdl': '\u2510',
        'boxdL': '\u2555',
        'boxDl': '\u2556',
        'boxDL': '\u2557',
        'boxdr': '\u250C',
        'boxdR': '\u2552',
        'boxDr': '\u2553',
        'boxDR': '\u2554',
        'boxh': '\u2500',
        'boxH': '\u2550',
        'boxhd': '\u252C',
        'boxhD': '\u2565',
        'boxHd': '\u2564',
        'boxHD': '\u2566',
        'boxhu': '\u2534',
        'boxhU': '\u2568',
        'boxHu': '\u2567',
        'boxHU': '\u2569',
        'boxminus': '\u229F',
        'boxplus': '\u229E',
        'boxtimes': '\u22A0',
        'boxul': '\u2518',
        'boxuL': '\u255B',
        'boxUl': '\u255C',
        'boxUL': '\u255D',
        'boxur': '\u2514',
        'boxuR': '\u2558',
        'boxUr': '\u2559',
        'boxUR': '\u255A',
        'boxv': '\u2502',
        'boxV': '\u2551',
        'boxvh': '\u253C',
        'boxvH': '\u256A',
        'boxVh': '\u256B',
        'boxVH': '\u256C',
        'boxvl': '\u2524',
        'boxvL': '\u2561',
        'boxVl': '\u2562',
        'boxVL': '\u2563',
        'boxvr': '\u251C',
        'boxvR': '\u255E',
        'boxVr': '\u255F',
        'boxVR': '\u2560',
        'bprime': '\u2035',
        'breve': '\u02D8',
        'Breve': '\u02D8',
        'brvbar': '\xA6',
        'bscr': '\uD835\uDCB7',
        'Bscr': '',
        'bsemi': '\u204F',
        'bsim': '\u223D',
        'bsime': '\u22CD',
        'bsol': '\\',
        'bsolb': '\u29C5',
        'bsolhsub': '\u27C8',
        'bull': '\u2022',
        'bullet': '\u2022',
        'bump': '\u224E',
        'bumpe': '\u224F',
        'bumpE': '\u2AAE',
        'bumpeq': '\u224F',
        'Bumpeq': '\u224E',
        'cacute': '',
        'Cacute': '',
        'cap': '\u2229',
        'Cap': '\u22D2',
        'capand': '\u2A44',
        'capbrcup': '\u2A49',
        'capcap': '\u2A4B',
        'capcup': '\u2A47',
        'capdot': '\u2A40',
        'CapitalDifferentialD': '',
        'caps': '\u2229',
        'caret': '\u2041',
        'caron': '',
        'Cayleys': '',
        'ccaps': '\u2A4D',
        'ccaron': '',
        'Ccaron': '',
        'ccedil': '',
        'Ccedil': '',
        'ccirc': '',
        'Ccirc': '',
        'Cconint': '\u2230',
        'ccups': '\u2A4C',
        'ccupssm': '\u2A50',
        'cdot': '',
        'Cdot': '',
        'cedil': '\xB8',
        'Cedilla': '\xB8',
        'cemptyv': '\u29B2',
        'cent': '\xA2',
        'centerdot': '\xB7',
        'CenterDot': '\xB7',
        'cfr': '\uD835\uDD20',
        'Cfr': '',
        'chcy': '',
        'CHcy': '',
        'check': '\u2713',
        'checkmark': '\u2713',
        'chi': '',
        'Chi': '',
        'cir': '\u25CB',
        'circ': '',
        'circeq': '\u2257',
        'circlearrowleft': '\u21BA',
        'circlearrowright': '\u21BB',
        'circledast': '\u229B',
        'circledcirc': '\u229A',
        'circleddash': '\u229D',
        'CircleDot': '\u2299',
        'circledR': '\xAE',
        'circledS': '\u24C8',
        'CircleMinus': '\u2296',
        'CirclePlus': '\u2295',
        'CircleTimes': '\u2297',
        'cire': '\u2257',
        'cirE': '\u29C3',
        'cirfnint': '\u2A10',
        'cirmid': '\u2AEF',
        'cirscir': '\u29C2',
        'ClockwiseContourIntegral': '\u2232',
        'CloseCurlyDoubleQuote': '\u201D',
        'CloseCurlyQuote': '\u2019',
        'clubs': '\u2663',
        'clubsuit': '\u2663',
        'colon': ':',
        'Colon': '\u2237',
        'colone': '\u2254',
        'Colone': '\u2A74',
        'coloneq': '\u2254',
        'comma': ',',
        'commat': '@',
        'comp': '\u2201',
        'compfn': '\u2218',
        'complement': '\u2201',
        'complexes': '',
        'cong': '\u2245',
        'congdot': '\u2A6D',
        'Congruent': '\u2261',
        'conint': '\u222E',
        'Conint': '\u222F',
        'ContourIntegral': '\u222E',
        'copf': '\uD835\uDD54',
        'Copf': '',
        'coprod': '\u2210',
        'Coproduct': '\u2210',
        'copy': '\xA9',
        'COPY': '\xA9',
        'copysr': '\u2117',
        'CounterClockwiseContourIntegral': '\u2233',
        'crarr': '\u21B5',
        'cross': '\u2717',
        'Cross': '\u2A2F',
        'cscr': '\uD835\uDCB8',
        'Cscr': '\uD835\uDC9E',
        'csub': '\u2ACF',
        'csube': '\u2AD1',
        'csup': '\u2AD0',
        'csupe': '\u2AD2',
        'ctdot': '\u22EF',
        'cudarrl': '\u2938',
        'cudarrr': '\u2935',
        'cuepr': '\u22DE',
        'cuesc': '\u22DF',
        'cularr': '\u21B6',
        'cularrp': '\u293D',
        'cup': '\u222A',
        'Cup': '\u22D3',
        'cupbrcap': '\u2A48',
        'cupcap': '\u2A46',
        'CupCap': '\u224D',
        'cupcup': '\u2A4A',
        'cupdot': '\u228D',
        'cupor': '\u2A45',
        'cups': '\u222A',
        'curarr': '\u21B7',
        'curarrm': '\u293C',
        'curlyeqprec': '\u22DE',
        'curlyeqsucc': '\u22DF',
        'curlyvee': '\u22CE',
        'curlywedge': '\u22CF',
        'curren': '\xA4',
        'curvearrowleft': '\u21B6',
        'curvearrowright': '\u21B7',
        'cuvee': '\u22CE',
        'cuwed': '\u22CF',
        'cwconint': '\u2232',
        'cwint': '\u2231',
        'cylcty': '\u232D',
        'dagger': '\u2020',
        'Dagger': '\u2021',
        'daleth': '',
        'darr': '\u2193',
        'dArr': '\u21D3',
        'Darr': '\u21A1',
        'dash': '\u2010',
        'dashv': '\u22A3',
        'Dashv': '\u2AE4',
        'dbkarow': '\u290F',
        'dblac': '\u02DD',
        'dcaron': '',
        'Dcaron': '',
        'dcy': '',
        'Dcy': '',
        'dd': '',
        'DD': '',
        'ddagger': '\u2021',
        'ddarr': '\u21CA',
        'DDotrahd': '\u2911',
        'ddotseq': '\u2A77',
        'deg': '\xB0',
        'Del': '\u2207',
        'delta': '',
        'Delta': '',
        'demptyv': '\u29B1',
        'dfisht': '\u297F',
        'dfr': '\uD835\uDD21',
        'Dfr': '\uD835\uDD07',
        'dHar': '\u2965',
        'dharl': '\u21C3',
        'dharr': '\u21C2',
        'DiacriticalAcute': '\xB4',
        'DiacriticalDot': '\u02D9',
        'DiacriticalDoubleAcute': '\u02DD',
        'DiacriticalGrave': '`',
        'DiacriticalTilde': '\u02DC',
        'diam': '\u22C4',
        'diamond': '\u22C4',
        'Diamond': '\u22C4',
        'diamondsuit': '\u2666',
        'diams': '\u2666',
        'die': '\xA8',
        'DifferentialD': '',
        'digamma': '',
        'disin': '\u22F2',
        'div': '\xF7',
        'divide': '\xF7',
        'divideontimes': '\u22C7',
        'divonx': '\u22C7',
        'djcy': '',
        'DJcy': '',
        'dlcorn': '\u231E',
        'dlcrop': '\u230D',
        'dollar': '$',
        'dopf': '\uD835\uDD55',
        'Dopf': '\uD835\uDD3B',
        'dot': '\u02D9',
        'Dot': '\xA8',
        'DotDot': '',
        'doteq': '\u2250',
        'doteqdot': '\u2251',
        'DotEqual': '\u2250',
        'dotminus': '\u2238',
        'dotplus': '\u2214',
        'dotsquare': '\u22A1',
        'doublebarwedge': '\u2306',
        'DoubleContourIntegral': '\u222F',
        'DoubleDot': '\xA8',
        'DoubleDownArrow': '\u21D3',
        'DoubleLeftArrow': '\u21D0',
        'DoubleLeftRightArrow': '\u21D4',
        'DoubleLeftTee': '\u2AE4',
        'DoubleLongLeftArrow': '\u27F8',
        'DoubleLongLeftRightArrow': '\u27FA',
        'DoubleLongRightArrow': '\u27F9',
        'DoubleRightArrow': '\u21D2',
        'DoubleRightTee': '\u22A8',
        'DoubleUpArrow': '\u21D1',
        'DoubleUpDownArrow': '\u21D5',
        'DoubleVerticalBar': '\u2225',
        'downarrow': '\u2193',
        'Downarrow': '\u21D3',
        'DownArrow': '\u2193',
        'DownArrowBar': '\u2913',
        'DownArrowUpArrow': '\u21F5',
        'DownBreve': '',
        'downdownarrows': '\u21CA',
        'downharpoonleft': '\u21C3',
        'downharpoonright': '\u21C2',
        'DownLeftRightVector': '\u2950',
        'DownLeftTeeVector': '\u295E',
        'DownLeftVector': '\u21BD',
        'DownLeftVectorBar': '\u2956',
        'DownRightTeeVector': '\u295F',
        'DownRightVector': '\u21C1',
        'DownRightVectorBar': '\u2957',
        'DownTee': '\u22A4',
        'DownTeeArrow': '\u21A7',
        'drbkarow': '\u2910',
        'drcorn': '\u231F',
        'drcrop': '\u230C',
        'dscr': '\uD835\uDCB9',
        'Dscr': '\uD835\uDC9F',
        'dscy': '',
        'DScy': '',
        'dsol': '\u29F6',
        'dstrok': '',
        'Dstrok': '',
        'dtdot': '\u22F1',
        'dtri': '\u25BF',
        'dtrif': '\u25BE',
        'duarr': '\u21F5',
        'duhar': '\u296F',
        'dwangle': '\u29A6',
        'dzcy': '',
        'DZcy': '',
        'dzigrarr': '\u27FF',
        'eacute': '',
        'Eacute': '',
        'easter': '\u2A6E',
        'ecaron': '',
        'Ecaron': '',
        'ecir': '\u2256',
        'ecirc': '',
        'Ecirc': '',
        'ecolon': '\u2255',
        'ecy': '',
        'Ecy': '',
        'eDDot': '\u2A77',
        'edot': '',
        'eDot': '\u2251',
        'Edot': '',
        'ee': '',
        'efDot': '\u2252',
        'efr': '\uD835\uDD22',
        'Efr': '\uD835\uDD08',
        'eg': '\u2A9A',
        'egrave': '',
        'Egrave': '',
        'egs': '\u2A96',
        'egsdot': '\u2A98',
        'el': '\u2A99',
        'Element': '\u2208',
        'elinters': '\u23E7',
        'ell': '',
        'els': '\u2A95',
        'elsdot': '\u2A97',
        'emacr': '',
        'Emacr': '',
        'empty': '\u2205',
        'emptyset': '\u2205',
        'EmptySmallSquare': '\u25FB',
        'emptyv': '\u2205',
        'EmptyVerySmallSquare': '\u25AB',
        'emsp': '\u2003',
        'emsp13': '\u2004',
        'emsp14': '\u2005',
        'eng': '',
        'ENG': '',
        'ensp': '\u2002',
        'eogon': '',
        'Eogon': '',
        'eopf': '\uD835\uDD56',
        'Eopf': '\uD835\uDD3C',
        'epar': '\u22D5',
        'eparsl': '\u29E3',
        'eplus': '\u2A71',
        'epsi': '',
        'epsilon': '',
        'Epsilon': '',
        'epsiv': '',
        'eqcirc': '\u2256',
        'eqcolon': '\u2255',
        'eqsim': '\u2242',
        'eqslantgtr': '\u2A96',
        'eqslantless': '\u2A95',
        'Equal': '\u2A75',
        'equals': '=',
        'EqualTilde': '\u2242',
        'equest': '\u225F',
        'Equilibrium': '\u21CC',
        'equiv': '\u2261',
        'equivDD': '\u2A78',
        'eqvparsl': '\u29E5',
        'erarr': '\u2971',
        'erDot': '\u2253',
        'escr': '',
        'Escr': '',
        'esdot': '\u2250',
        'esim': '\u2242',
        'Esim': '\u2A73',
        'eta': '',
        'Eta': '',
        'eth': '',
        'ETH': '',
        'euml': '',
        'Euml': '',
        'euro': '\u20AC',
        'excl': '!',
        'exist': '\u2203',
        'Exists': '\u2203',
        'expectation': '',
        'exponentiale': '',
        'ExponentialE': '',
        'fallingdotseq': '\u2252',
        'fcy': '',
        'Fcy': '',
        'female': '\u2640',
        'ffilig': '',
        'fflig': '',
        'ffllig': '',
        'ffr': '\uD835\uDD23',
        'Ffr': '\uD835\uDD09',
        'filig': '',
        'FilledSmallSquare': '\u25FC',
        'FilledVerySmallSquare': '\u25AA',
        'fjlig': 'fj',
        'flat': '\u266D',
        'fllig': '',
        'fltns': '\u25B1',
        'fnof': '',
        'fopf': '\uD835\uDD57',
        'Fopf': '\uD835\uDD3D',
        'forall': '\u2200',
        'ForAll': '\u2200',
        'fork': '\u22D4',
        'forkv': '\u2AD9',
        'Fouriertrf': '',
        'fpartint': '\u2A0D',
        'frac12': '\xBD',
        'frac13': '\u2153',
        'frac14': '\xBC',
        'frac15': '\u2155',
        'frac16': '\u2159',
        'frac18': '\u215B',
        'frac23': '\u2154',
        'frac25': '\u2156',
        'frac34': '\xBE',
        'frac35': '\u2157',
        'frac38': '\u215C',
        'frac45': '\u2158',
        'frac56': '\u215A',
        'frac58': '\u215D',
        'frac78': '\u215E',
        'frasl': '\u2044',
        'frown': '\u2322',
        'fscr': '\uD835\uDCBB',
        'Fscr': '',
        'gacute': '',
        'gamma': '',
        'Gamma': '',
        'gammad': '',
        'Gammad': '',
        'gap': '\u2A86',
        'gbreve': '',
        'Gbreve': '',
        'Gcedil': '',
        'gcirc': '',
        'Gcirc': '',
        'gcy': '',
        'Gcy': '',
        'gdot': '',
        'Gdot': '',
        'ge': '\u2265',
        'gE': '\u2267',
        'gel': '\u22DB',
        'gEl': '\u2A8C',
        'geq': '\u2265',
        'geqq': '\u2267',
        'geqslant': '\u2A7E',
        'ges': '\u2A7E',
        'gescc': '\u2AA9',
        'gesdot': '\u2A80',
        'gesdoto': '\u2A82',
        'gesdotol': '\u2A84',
        'gesl': '\u22DB',
        'gesles': '\u2A94',
        'gfr': '\uD835\uDD24',
        'Gfr': '\uD835\uDD0A',
        'gg': '\u226B',
        'Gg': '\u22D9',
        'ggg': '\u22D9',
        'gimel': '',
        'gjcy': '',
        'GJcy': '',
        'gl': '\u2277',
        'gla': '\u2AA5',
        'glE': '\u2A92',
        'glj': '\u2AA4',
        'gnap': '\u2A8A',
        'gnapprox': '\u2A8A',
        'gne': '\u2A88',
        'gnE': '\u2269',
        'gneq': '\u2A88',
        'gneqq': '\u2269',
        'gnsim': '\u22E7',
        'gopf': '\uD835\uDD58',
        'Gopf': '\uD835\uDD3E',
        'grave': '`',
        'GreaterEqual': '\u2265',
        'GreaterEqualLess': '\u22DB',
        'GreaterFullEqual': '\u2267',
        'GreaterGreater': '\u2AA2',
        'GreaterLess': '\u2277',
        'GreaterSlantEqual': '\u2A7E',
        'GreaterTilde': '\u2273',
        'gscr': '',
        'Gscr': '\uD835\uDCA2',
        'gsim': '\u2273',
        'gsime': '\u2A8E',
        'gsiml': '\u2A90',
        'gt': '>',
        'Gt': '\u226B',
        'GT': '>',
        'gtcc': '\u2AA7',
        'gtcir': '\u2A7A',
        'gtdot': '\u22D7',
        'gtlPar': '\u2995',
        'gtquest': '\u2A7C',
        'gtrapprox': '\u2A86',
        'gtrarr': '\u2978',
        'gtrdot': '\u22D7',
        'gtreqless': '\u22DB',
        'gtreqqless': '\u2A8C',
        'gtrless': '\u2277',
        'gtrsim': '\u2273',
        'gvertneqq': '\u2269',
        'gvnE': '\u2269',
        'Hacek': '',
        'hairsp': '\u200A',
        'half': '\xBD',
        'hamilt': '',
        'hardcy': '',
        'HARDcy': '',
        'harr': '\u2194',
        'hArr': '\u21D4',
        'harrcir': '\u2948',
        'harrw': '\u21AD',
        'Hat': '^',
        'hbar': '',
        'hcirc': '',
        'Hcirc': '',
        'hearts': '\u2665',
        'heartsuit': '\u2665',
        'hellip': '\u2026',
        'hercon': '\u22B9',
        'hfr': '\uD835\uDD25',
        'Hfr': '',
        'HilbertSpace': '',
        'hksearow': '\u2925',
        'hkswarow': '\u2926',
        'hoarr': '\u21FF',
        'homtht': '\u223B',
        'hookleftarrow': '\u21A9',
        'hookrightarrow': '\u21AA',
        'hopf': '\uD835\uDD59',
        'Hopf': '',
        'horbar': '\u2015',
        'HorizontalLine': '\u2500',
        'hscr': '\uD835\uDCBD',
        'Hscr': '',
        'hslash': '',
        'hstrok': '',
        'Hstrok': '',
        'HumpDownHump': '\u224E',
        'HumpEqual': '\u224F',
        'hybull': '\u2043',
        'hyphen': '\u2010',
        'iacute': '',
        'Iacute': '',
        'ic': '\u2063',
        'icirc': '',
        'Icirc': '',
        'icy': '',
        'Icy': '',
        'Idot': '',
        'iecy': '',
        'IEcy': '',
        'iexcl': '\xA1',
        'iff': '\u21D4',
        'ifr': '\uD835\uDD26',
        'Ifr': '',
        'igrave': '',
        'Igrave': '',
        'ii': '',
        'iiiint': '\u2A0C',
        'iiint': '\u222D',
        'iinfin': '\u29DC',
        'iiota': '\u2129',
        'ijlig': '',
        'IJlig': '',
        'Im': '',
        'imacr': '',
        'Imacr': '',
        'image': '',
        'ImaginaryI': '',
        'imagline': '',
        'imagpart': '',
        'imath': '',
        'imof': '\u22B7',
        'imped': '',
        'Implies': '\u21D2',
        'in': '\u2208',
        'incare': '\u2105',
        'infin': '\u221E',
        'infintie': '\u29DD',
        'inodot': '',
        'int': '\u222B',
        'Int': '\u222C',
        'intcal': '\u22BA',
        'integers': '',
        'Integral': '\u222B',
        'intercal': '\u22BA',
        'Intersection': '\u22C2',
        'intlarhk': '\u2A17',
        'intprod': '\u2A3C',
        'InvisibleComma': '\u2063',
        'InvisibleTimes': '\u2062',
        'iocy': '',
        'IOcy': '',
        'iogon': '',
        'Iogon': '',
        'iopf': '\uD835\uDD5A',
        'Iopf': '\uD835\uDD40',
        'iota': '',
        'Iota': '',
        'iprod': '\u2A3C',
        'iquest': '\xBF',
        'iscr': '\uD835\uDCBE',
        'Iscr': '',
        'isin': '\u2208',
        'isindot': '\u22F5',
        'isinE': '\u22F9',
        'isins': '\u22F4',
        'isinsv': '\u22F3',
        'isinv': '\u2208',
        'it': '\u2062',
        'itilde': '',
        'Itilde': '',
        'iukcy': '',
        'Iukcy': '',
        'iuml': '',
        'Iuml': '',
        'jcirc': '',
        'Jcirc': '',
        'jcy': '',
        'Jcy': '',
        'jfr': '\uD835\uDD27',
        'Jfr': '\uD835\uDD0D',
        'jmath': '',
        'jopf': '\uD835\uDD5B',
        'Jopf': '\uD835\uDD41',
        'jscr': '\uD835\uDCBF',
        'Jscr': '\uD835\uDCA5',
        'jsercy': '',
        'Jsercy': '',
        'jukcy': '',
        'Jukcy': '',
        'kappa': '',
        'Kappa': '',
        'kappav': '',
        'kcedil': '',
        'Kcedil': '',
        'kcy': '',
        'Kcy': '',
        'kfr': '\uD835\uDD28',
        'Kfr': '\uD835\uDD0E',
        'kgreen': '',
        'khcy': '',
        'KHcy': '',
        'kjcy': '',
        'KJcy': '',
        'kopf': '\uD835\uDD5C',
        'Kopf': '\uD835\uDD42',
        'kscr': '\uD835\uDCC0',
        'Kscr': '\uD835\uDCA6',
        'lAarr': '\u21DA',
        'lacute': '',
        'Lacute': '',
        'laemptyv': '\u29B4',
        'lagran': '',
        'lambda': '',
        'Lambda': '',
        'lang': '\u27E8',
        'Lang': '\u27EA',
        'langd': '\u2991',
        'langle': '\u27E8',
        'lap': '\u2A85',
        'Laplacetrf': '',
        'laquo': '\xAB',
        'larr': '\u2190',
        'lArr': '\u21D0',
        'Larr': '\u219E',
        'larrb': '\u21E4',
        'larrbfs': '\u291F',
        'larrfs': '\u291D',
        'larrhk': '\u21A9',
        'larrlp': '\u21AB',
        'larrpl': '\u2939',
        'larrsim': '\u2973',
        'larrtl': '\u21A2',
        'lat': '\u2AAB',
        'latail': '\u2919',
        'lAtail': '\u291B',
        'late': '\u2AAD',
        'lates': '\u2AAD',
        'lbarr': '\u290C',
        'lBarr': '\u290E',
        'lbbrk': '\u2772',
        'lbrace': '{',
        'lbrack': '[',
        'lbrke': '\u298B',
        'lbrksld': '\u298F',
        'lbrkslu': '\u298D',
        'lcaron': '',
        'Lcaron': '',
        'lcedil': '',
        'Lcedil': '',
        'lceil': '\u2308',
        'lcub': '{',
        'lcy': '',
        'Lcy': '',
        'ldca': '\u2936',
        'ldquo': '\u201C',
        'ldquor': '\u201E',
        'ldrdhar': '\u2967',
        'ldrushar': '\u294B',
        'ldsh': '\u21B2',
        'le': '\u2264',
        'lE': '\u2266',
        'LeftAngleBracket': '\u27E8',
        'leftarrow': '\u2190',
        'Leftarrow': '\u21D0',
        'LeftArrow': '\u2190',
        'LeftArrowBar': '\u21E4',
        'LeftArrowRightArrow': '\u21C6',
        'leftarrowtail': '\u21A2',
        'LeftCeiling': '\u2308',
        'LeftDoubleBracket': '\u27E6',
        'LeftDownTeeVector': '\u2961',
        'LeftDownVector': '\u21C3',
        'LeftDownVectorBar': '\u2959',
        'LeftFloor': '\u230A',
        'leftharpoondown': '\u21BD',
        'leftharpoonup': '\u21BC',
        'leftleftarrows': '\u21C7',
        'leftrightarrow': '\u2194',
        'Leftrightarrow': '\u21D4',
        'LeftRightArrow': '\u2194',
        'leftrightarrows': '\u21C6',
        'leftrightharpoons': '\u21CB',
        'leftrightsquigarrow': '\u21AD',
        'LeftRightVector': '\u294E',
        'LeftTee': '\u22A3',
        'LeftTeeArrow': '\u21A4',
        'LeftTeeVector': '\u295A',
        'leftthreetimes': '\u22CB',
        'LeftTriangle': '\u22B2',
        'LeftTriangleBar': '\u29CF',
        'LeftTriangleEqual': '\u22B4',
        'LeftUpDownVector': '\u2951',
        'LeftUpTeeVector': '\u2960',
        'LeftUpVector': '\u21BF',
        'LeftUpVectorBar': '\u2958',
        'LeftVector': '\u21BC',
        'LeftVectorBar': '\u2952',
        'leg': '\u22DA',
        'lEg': '\u2A8B',
        'leq': '\u2264',
        'leqq': '\u2266',
        'leqslant': '\u2A7D',
        'les': '\u2A7D',
        'lescc': '\u2AA8',
        'lesdot': '\u2A7F',
        'lesdoto': '\u2A81',
        'lesdotor': '\u2A83',
        'lesg': '\u22DA',
        'lesges': '\u2A93',
        'lessapprox': '\u2A85',
        'lessdot': '\u22D6',
        'lesseqgtr': '\u22DA',
        'lesseqqgtr': '\u2A8B',
        'LessEqualGreater': '\u22DA',
        'LessFullEqual': '\u2266',
        'LessGreater': '\u2276',
        'lessgtr': '\u2276',
        'LessLess': '\u2AA1',
        'lesssim': '\u2272',
        'LessSlantEqual': '\u2A7D',
        'LessTilde': '\u2272',
        'lfisht': '\u297C',
        'lfloor': '\u230A',
        'lfr': '\uD835\uDD29',
        'Lfr': '\uD835\uDD0F',
        'lg': '\u2276',
        'lgE': '\u2A91',
        'lHar': '\u2962',
        'lhard': '\u21BD',
        'lharu': '\u21BC',
        'lharul': '\u296A',
        'lhblk': '\u2584',
        'ljcy': '',
        'LJcy': '',
        'll': '\u226A',
        'Ll': '\u22D8',
        'llarr': '\u21C7',
        'llcorner': '\u231E',
        'Lleftarrow': '\u21DA',
        'llhard': '\u296B',
        'lltri': '\u25FA',
        'lmidot': '',
        'Lmidot': '',
        'lmoust': '\u23B0',
        'lmoustache': '\u23B0',
        'lnap': '\u2A89',
        'lnapprox': '\u2A89',
        'lne': '\u2A87',
        'lnE': '\u2268',
        'lneq': '\u2A87',
        'lneqq': '\u2268',
        'lnsim': '\u22E6',
        'loang': '\u27EC',
        'loarr': '\u21FD',
        'lobrk': '\u27E6',
        'longleftarrow': '\u27F5',
        'Longleftarrow': '\u27F8',
        'LongLeftArrow': '\u27F5',
        'longleftrightarrow': '\u27F7',
        'Longleftrightarrow': '\u27FA',
        'LongLeftRightArrow': '\u27F7',
        'longmapsto': '\u27FC',
        'longrightarrow': '\u27F6',
        'Longrightarrow': '\u27F9',
        'LongRightArrow': '\u27F6',
        'looparrowleft': '\u21AB',
        'looparrowright': '\u21AC',
        'lopar': '\u2985',
        'lopf': '\uD835\uDD5D',
        'Lopf': '\uD835\uDD43',
        'loplus': '\u2A2D',
        'lotimes': '\u2A34',
        'lowast': '\u2217',
        'lowbar': '_',
        'LowerLeftArrow': '\u2199',
        'LowerRightArrow': '\u2198',
        'loz': '\u25CA',
        'lozenge': '\u25CA',
        'lozf': '\u29EB',
        'lpar': '(',
        'lparlt': '\u2993',
        'lrarr': '\u21C6',
        'lrcorner': '\u231F',
        'lrhar': '\u21CB',
        'lrhard': '\u296D',
        'lrm': '\u200E',
        'lrtri': '\u22BF',
        'lsaquo': '\u2039',
        'lscr': '\uD835\uDCC1',
        'Lscr': '',
        'lsh': '\u21B0',
        'Lsh': '\u21B0',
        'lsim': '\u2272',
        'lsime': '\u2A8D',
        'lsimg': '\u2A8F',
        'lsqb': '[',
        'lsquo': '\u2018',
        'lsquor': '\u201A',
        'lstrok': '',
        'Lstrok': '',
        'lt': '<',
        'Lt': '\u226A',
        'LT': '<',
        'ltcc': '\u2AA6',
        'ltcir': '\u2A79',
        'ltdot': '\u22D6',
        'lthree': '\u22CB',
        'ltimes': '\u22C9',
        'ltlarr': '\u2976',
        'ltquest': '\u2A7B',
        'ltri': '\u25C3',
        'ltrie': '\u22B4',
        'ltrif': '\u25C2',
        'ltrPar': '\u2996',
        'lurdshar': '\u294A',
        'luruhar': '\u2966',
        'lvertneqq': '\u2268',
        'lvnE': '\u2268',
        'macr': '\xAF',
        'male': '\u2642',
        'malt': '\u2720',
        'maltese': '\u2720',
        'map': '\u21A6',
        'Map': '\u2905',
        'mapsto': '\u21A6',
        'mapstodown': '\u21A7',
        'mapstoleft': '\u21A4',
        'mapstoup': '\u21A5',
        'marker': '\u25AE',
        'mcomma': '\u2A29',
        'mcy': '',
        'Mcy': '',
        'mdash': '\u2014',
        'mDDot': '\u223A',
        'measuredangle': '\u2221',
        'MediumSpace': '\u205F',
        'Mellintrf': '',
        'mfr': '\uD835\uDD2A',
        'Mfr': '\uD835\uDD10',
        'mho': '\u2127',
        'micro': '',
        'mid': '\u2223',
        'midast': '*',
        'midcir': '\u2AF0',
        'middot': '\xB7',
        'minus': '\u2212',
        'minusb': '\u229F',
        'minusd': '\u2238',
        'minusdu': '\u2A2A',
        'MinusPlus': '\u2213',
        'mlcp': '\u2ADB',
        'mldr': '\u2026',
        'mnplus': '\u2213',
        'models': '\u22A7',
        'mopf': '\uD835\uDD5E',
        'Mopf': '\uD835\uDD44',
        'mp': '\u2213',
        'mscr': '\uD835\uDCC2',
        'Mscr': '',
        'mstpos': '\u223E',
        'mu': '',
        'Mu': '',
        'multimap': '\u22B8',
        'mumap': '\u22B8',
        'nabla': '\u2207',
        'nacute': '',
        'Nacute': '',
        'nang': '\u2220',
        'nap': '\u2249',
        'napE': '\u2A70',
        'napid': '\u224B',
        'napos': '',
        'napprox': '\u2249',
        'natur': '\u266E',
        'natural': '\u266E',
        'naturals': '',
        'nbsp': '\xA0',
        'nbump': '\u224E',
        'nbumpe': '\u224F',
        'ncap': '\u2A43',
        'ncaron': '',
        'Ncaron': '',
        'ncedil': '',
        'Ncedil': '',
        'ncong': '\u2247',
        'ncongdot': '\u2A6D',
        'ncup': '\u2A42',
        'ncy': '',
        'Ncy': '',
        'ndash': '\u2013',
        'ne': '\u2260',
        'nearhk': '\u2924',
        'nearr': '\u2197',
        'neArr': '\u21D7',
        'nearrow': '\u2197',
        'nedot': '\u2250',
        'NegativeMediumSpace': '\u200B',
        'NegativeThickSpace': '\u200B',
        'NegativeThinSpace': '\u200B',
        'NegativeVeryThinSpace': '\u200B',
        'nequiv': '\u2262',
        'nesear': '\u2928',
        'nesim': '\u2242',
        'NestedGreaterGreater': '\u226B',
        'NestedLessLess': '\u226A',
        'NewLine': '\n',
        'nexist': '\u2204',
        'nexists': '\u2204',
        'nfr': '\uD835\uDD2B',
        'Nfr': '\uD835\uDD11',
        'nge': '\u2271',
        'ngE': '\u2267',
        'ngeq': '\u2271',
        'ngeqq': '\u2267',
        'ngeqslant': '\u2A7E',
        'nges': '\u2A7E',
        'nGg': '\u22D9',
        'ngsim': '\u2275',
        'ngt': '\u226F',
        'nGt': '\u226B',
        'ngtr': '\u226F',
        'nGtv': '\u226B',
        'nharr': '\u21AE',
        'nhArr': '\u21CE',
        'nhpar': '\u2AF2',
        'ni': '\u220B',
        'nis': '\u22FC',
        'nisd': '\u22FA',
        'niv': '\u220B',
        'njcy': '',
        'NJcy': '',
        'nlarr': '\u219A',
        'nlArr': '\u21CD',
        'nldr': '\u2025',
        'nle': '\u2270',
        'nlE': '\u2266',
        'nleftarrow': '\u219A',
        'nLeftarrow': '\u21CD',
        'nleftrightarrow': '\u21AE',
        'nLeftrightarrow': '\u21CE',
        'nleq': '\u2270',
        'nleqq': '\u2266',
        'nleqslant': '\u2A7D',
        'nles': '\u2A7D',
        'nless': '\u226E',
        'nLl': '\u22D8',
        'nlsim': '\u2274',
        'nlt': '\u226E',
        'nLt': '\u226A',
        'nltri': '\u22EA',
        'nltrie': '\u22EC',
        'nLtv': '\u226A',
        'nmid': '\u2224',
        'NoBreak': '\u2060',
        'NonBreakingSpace': '\xA0',
        'nopf': '\uD835\uDD5F',
        'Nopf': '',
        'not': '\xAC',
        'Not': '\u2AEC',
        'NotCongruent': '\u2262',
        'NotCupCap': '\u226D',
        'NotDoubleVerticalBar': '\u2226',
        'NotElement': '\u2209',
        'NotEqual': '\u2260',
        'NotEqualTilde': '\u2242',
        'NotExists': '\u2204',
        'NotGreater': '\u226F',
        'NotGreaterEqual': '\u2271',
        'NotGreaterFullEqual': '\u2267',
        'NotGreaterGreater': '\u226B',
        'NotGreaterLess': '\u2279',
        'NotGreaterSlantEqual': '\u2A7E',
        'NotGreaterTilde': '\u2275',
        'NotHumpDownHump': '\u224E',
        'NotHumpEqual': '\u224F',
        'notin': '\u2209',
        'notindot': '\u22F5',
        'notinE': '\u22F9',
        'notinva': '\u2209',
        'notinvb': '\u22F7',
        'notinvc': '\u22F6',
        'NotLeftTriangle': '\u22EA',
        'NotLeftTriangleBar': '\u29CF',
        'NotLeftTriangleEqual': '\u22EC',
        'NotLess': '\u226E',
        'NotLessEqual': '\u2270',
        'NotLessGreater': '\u2278',
        'NotLessLess': '\u226A',
        'NotLessSlantEqual': '\u2A7D',
        'NotLessTilde': '\u2274',
        'NotNestedGreaterGreater': '\u2AA2',
        'NotNestedLessLess': '\u2AA1',
        'notni': '\u220C',
        'notniva': '\u220C',
        'notnivb': '\u22FE',
        'notnivc': '\u22FD',
        'NotPrecedes': '\u2280',
        'NotPrecedesEqual': '\u2AAF',
        'NotPrecedesSlantEqual': '\u22E0',
        'NotReverseElement': '\u220C',
        'NotRightTriangle': '\u22EB',
        'NotRightTriangleBar': '\u29D0',
        'NotRightTriangleEqual': '\u22ED',
        'NotSquareSubset': '\u228F',
        'NotSquareSubsetEqual': '\u22E2',
        'NotSquareSuperset': '\u2290',
        'NotSquareSupersetEqual': '\u22E3',
        'NotSubset': '\u2282',
        'NotSubsetEqual': '\u2288',
        'NotSucceeds': '\u2281',
        'NotSucceedsEqual': '\u2AB0',
        'NotSucceedsSlantEqual': '\u22E1',
        'NotSucceedsTilde': '\u227F',
        'NotSuperset': '\u2283',
        'NotSupersetEqual': '\u2289',
        'NotTilde': '\u2241',
        'NotTildeEqual': '\u2244',
        'NotTildeFullEqual': '\u2247',
        'NotTildeTilde': '\u2249',
        'NotVerticalBar': '\u2224',
        'npar': '\u2226',
        'nparallel': '\u2226',
        'nparsl': '\u2AFD',
        'npart': '\u2202',
        'npolint': '\u2A14',
        'npr': '\u2280',
        'nprcue': '\u22E0',
        'npre': '\u2AAF',
        'nprec': '\u2280',
        'npreceq': '\u2AAF',
        'nrarr': '\u219B',
        'nrArr': '\u21CF',
        'nrarrc': '\u2933',
        'nrarrw': '\u219D',
        'nrightarrow': '\u219B',
        'nRightarrow': '\u21CF',
        'nrtri': '\u22EB',
        'nrtrie': '\u22ED',
        'nsc': '\u2281',
        'nsccue': '\u22E1',
        'nsce': '\u2AB0',
        'nscr': '\uD835\uDCC3',
        'Nscr': '\uD835\uDCA9',
        'nshortmid': '\u2224',
        'nshortparallel': '\u2226',
        'nsim': '\u2241',
        'nsime': '\u2244',
        'nsimeq': '\u2244',
        'nsmid': '\u2224',
        'nspar': '\u2226',
        'nsqsube': '\u22E2',
        'nsqsupe': '\u22E3',
        'nsub': '\u2284',
        'nsube': '\u2288',
        'nsubE': '\u2AC5',
        'nsubset': '\u2282',
        'nsubseteq': '\u2288',
        'nsubseteqq': '\u2AC5',
        'nsucc': '\u2281',
        'nsucceq': '\u2AB0',
        'nsup': '\u2285',
        'nsupe': '\u2289',
        'nsupE': '\u2AC6',
        'nsupset': '\u2283',
        'nsupseteq': '\u2289',
        'nsupseteqq': '\u2AC6',
        'ntgl': '\u2279',
        'ntilde': '',
        'Ntilde': '',
        'ntlg': '\u2278',
        'ntriangleleft': '\u22EA',
        'ntrianglelefteq': '\u22EC',
        'ntriangleright': '\u22EB',
        'ntrianglerighteq': '\u22ED',
        'nu': '',
        'Nu': '',
        'num': '#',
        'numero': '\u2116',
        'numsp': '\u2007',
        'nvap': '\u224D',
        'nvdash': '\u22AC',
        'nvDash': '\u22AD',
        'nVdash': '\u22AE',
        'nVDash': '\u22AF',
        'nvge': '\u2265',
        'nvgt': '>',
        'nvHarr': '\u2904',
        'nvinfin': '\u29DE',
        'nvlArr': '\u2902',
        'nvle': '\u2264',
        'nvlt': '<',
        'nvltrie': '\u22B4',
        'nvrArr': '\u2903',
        'nvrtrie': '\u22B5',
        'nvsim': '\u223C',
        'nwarhk': '\u2923',
        'nwarr': '\u2196',
        'nwArr': '\u21D6',
        'nwarrow': '\u2196',
        'nwnear': '\u2927',
        'oacute': '',
        'Oacute': '',
        'oast': '\u229B',
        'ocir': '\u229A',
        'ocirc': '',
        'Ocirc': '',
        'ocy': '',
        'Ocy': '',
        'odash': '\u229D',
        'odblac': '',
        'Odblac': '',
        'odiv': '\u2A38',
        'odot': '\u2299',
        'odsold': '\u29BC',
        'oelig': '',
        'OElig': '',
        'ofcir': '\u29BF',
        'ofr': '\uD835\uDD2C',
        'Ofr': '\uD835\uDD12',
        'ogon': '\u02DB',
        'ograve': '',
        'Ograve': '',
        'ogt': '\u29C1',
        'ohbar': '\u29B5',
        'ohm': '',
        'oint': '\u222E',
        'olarr': '\u21BA',
        'olcir': '\u29BE',
        'olcross': '\u29BB',
        'oline': '\u203E',
        'olt': '\u29C0',
        'omacr': '',
        'Omacr': '',
        'omega': '',
        'Omega': '',
        'omicron': '',
        'Omicron': '',
        'omid': '\u29B6',
        'ominus': '\u2296',
        'oopf': '\uD835\uDD60',
        'Oopf': '\uD835\uDD46',
        'opar': '\u29B7',
        'OpenCurlyDoubleQuote': '\u201C',
        'OpenCurlyQuote': '\u2018',
        'operp': '\u29B9',
        'oplus': '\u2295',
        'or': '\u2228',
        'Or': '\u2A54',
        'orarr': '\u21BB',
        'ord': '\u2A5D',
        'order': '',
        'orderof': '',
        'ordf': '',
        'ordm': '',
        'origof': '\u22B6',
        'oror': '\u2A56',
        'orslope': '\u2A57',
        'orv': '\u2A5B',
        'oS': '\u24C8',
        'oscr': '',
        'Oscr': '\uD835\uDCAA',
        'oslash': '',
        'Oslash': '',
        'osol': '\u2298',
        'otilde': '',
        'Otilde': '',
        'otimes': '\u2297',
        'Otimes': '\u2A37',
        'otimesas': '\u2A36',
        'ouml': '',
        'Ouml': '',
        'ovbar': '\u233D',
        'OverBar': '\u203E',
        'OverBrace': '\u23DE',
        'OverBracket': '\u23B4',
        'OverParenthesis': '\u23DC',
        'par': '\u2225',
        'para': '\xB6',
        'parallel': '\u2225',
        'parsim': '\u2AF3',
        'parsl': '\u2AFD',
        'part': '\u2202',
        'PartialD': '\u2202',
        'pcy': '',
        'Pcy': '',
        'percnt': '%',
        'period': '.',
        'permil': '\u2030',
        'perp': '\u22A5',
        'pertenk': '\u2031',
        'pfr': '\uD835\uDD2D',
        'Pfr': '\uD835\uDD13',
        'phi': '',
        'Phi': '',
        'phiv': '',
        'phmmat': '',
        'phone': '\u260E',
        'pi': '',
        'Pi': '',
        'pitchfork': '\u22D4',
        'piv': '',
        'planck': '',
        'planckh': '',
        'plankv': '',
        'plus': '+',
        'plusacir': '\u2A23',
        'plusb': '\u229E',
        'pluscir': '\u2A22',
        'plusdo': '\u2214',
        'plusdu': '\u2A25',
        'pluse': '\u2A72',
        'PlusMinus': '\xB1',
        'plusmn': '\xB1',
        'plussim': '\u2A26',
        'plustwo': '\u2A27',
        'pm': '\xB1',
        'Poincareplane': '',
        'pointint': '\u2A15',
        'popf': '\uD835\uDD61',
        'Popf': '',
        'pound': '\xA3',
        'pr': '\u227A',
        'Pr': '\u2ABB',
        'prap': '\u2AB7',
        'prcue': '\u227C',
        'pre': '\u2AAF',
        'prE': '\u2AB3',
        'prec': '\u227A',
        'precapprox': '\u2AB7',
        'preccurlyeq': '\u227C',
        'Precedes': '\u227A',
        'PrecedesEqual': '\u2AAF',
        'PrecedesSlantEqual': '\u227C',
        'PrecedesTilde': '\u227E',
        'preceq': '\u2AAF',
        'precnapprox': '\u2AB9',
        'precneqq': '\u2AB5',
        'precnsim': '\u22E8',
        'precsim': '\u227E',
        'prime': '\u2032',
        'Prime': '\u2033',
        'primes': '',
        'prnap': '\u2AB9',
        'prnE': '\u2AB5',
        'prnsim': '\u22E8',
        'prod': '\u220F',
        'Product': '\u220F',
        'profalar': '\u232E',
        'profline': '\u2312',
        'profsurf': '\u2313',
        'prop': '\u221D',
        'Proportion': '\u2237',
        'Proportional': '\u221D',
        'propto': '\u221D',
        'prsim': '\u227E',
        'prurel': '\u22B0',
        'pscr': '\uD835\uDCC5',
        'Pscr': '\uD835\uDCAB',
        'psi': '',
        'Psi': '',
        'puncsp': '\u2008',
        'qfr': '\uD835\uDD2E',
        'Qfr': '\uD835\uDD14',
        'qint': '\u2A0C',
        'qopf': '\uD835\uDD62',
        'Qopf': '',
        'qprime': '\u2057',
        'qscr': '\uD835\uDCC6',
        'Qscr': '\uD835\uDCAC',
        'quaternions': '',
        'quatint': '\u2A16',
        'quest': '?',
        'questeq': '\u225F',
        'quot': '"',
        'QUOT': '"',
        'rAarr': '\u21DB',
        'race': '\u223D',
        'racute': '',
        'Racute': '',
        'radic': '\u221A',
        'raemptyv': '\u29B3',
        'rang': '\u27E9',
        'Rang': '\u27EB',
        'rangd': '\u2992',
        'range': '\u29A5',
        'rangle': '\u27E9',
        'raquo': '\xBB',
        'rarr': '\u2192',
        'rArr': '\u21D2',
        'Rarr': '\u21A0',
        'rarrap': '\u2975',
        'rarrb': '\u21E5',
        'rarrbfs': '\u2920',
        'rarrc': '\u2933',
        'rarrfs': '\u291E',
        'rarrhk': '\u21AA',
        'rarrlp': '\u21AC',
        'rarrpl': '\u2945',
        'rarrsim': '\u2974',
        'rarrtl': '\u21A3',
        'Rarrtl': '\u2916',
        'rarrw': '\u219D',
        'ratail': '\u291A',
        'rAtail': '\u291C',
        'ratio': '\u2236',
        'rationals': '',
        'rbarr': '\u290D',
        'rBarr': '\u290F',
        'RBarr': '\u2910',
        'rbbrk': '\u2773',
        'rbrace': '}',
        'rbrack': ']',
        'rbrke': '\u298C',
        'rbrksld': '\u298E',
        'rbrkslu': '\u2990',
        'rcaron': '',
        'Rcaron': '',
        'rcedil': '',
        'Rcedil': '',
        'rceil': '\u2309',
        'rcub': '}',
        'rcy': '',
        'Rcy': '',
        'rdca': '\u2937',
        'rdldhar': '\u2969',
        'rdquo': '\u201D',
        'rdquor': '\u201D',
        'rdsh': '\u21B3',
        'Re': '',
        'real': '',
        'realine': '',
        'realpart': '',
        'reals': '',
        'rect': '\u25AD',
        'reg': '\xAE',
        'REG': '\xAE',
        'ReverseElement': '\u220B',
        'ReverseEquilibrium': '\u21CB',
        'ReverseUpEquilibrium': '\u296F',
        'rfisht': '\u297D',
        'rfloor': '\u230B',
        'rfr': '\uD835\uDD2F',
        'Rfr': '',
        'rHar': '\u2964',
        'rhard': '\u21C1',
        'rharu': '\u21C0',
        'rharul': '\u296C',
        'rho': '',
        'Rho': '',
        'rhov': '',
        'RightAngleBracket': '\u27E9',
        'rightarrow': '\u2192',
        'Rightarrow': '\u21D2',
        'RightArrow': '\u2192',
        'RightArrowBar': '\u21E5',
        'RightArrowLeftArrow': '\u21C4',
        'rightarrowtail': '\u21A3',
        'RightCeiling': '\u2309',
        'RightDoubleBracket': '\u27E7',
        'RightDownTeeVector': '\u295D',
        'RightDownVector': '\u21C2',
        'RightDownVectorBar': '\u2955',
        'RightFloor': '\u230B',
        'rightharpoondown': '\u21C1',
        'rightharpoonup': '\u21C0',
        'rightleftarrows': '\u21C4',
        'rightleftharpoons': '\u21CC',
        'rightrightarrows': '\u21C9',
        'rightsquigarrow': '\u219D',
        'RightTee': '\u22A2',
        'RightTeeArrow': '\u21A6',
        'RightTeeVector': '\u295B',
        'rightthreetimes': '\u22CC',
        'RightTriangle': '\u22B3',
        'RightTriangleBar': '\u29D0',
        'RightTriangleEqual': '\u22B5',
        'RightUpDownVector': '\u294F',
        'RightUpTeeVector': '\u295C',
        'RightUpVector': '\u21BE',
        'RightUpVectorBar': '\u2954',
        'RightVector': '\u21C0',
        'RightVectorBar': '\u2953',
        'ring': '\u02DA',
        'risingdotseq': '\u2253',
        'rlarr': '\u21C4',
        'rlhar': '\u21CC',
        'rlm': '\u200F',
        'rmoust': '\u23B1',
        'rmoustache': '\u23B1',
        'rnmid': '\u2AEE',
        'roang': '\u27ED',
        'roarr': '\u21FE',
        'robrk': '\u27E7',
        'ropar': '\u2986',
        'ropf': '\uD835\uDD63',
        'Ropf': '',
        'roplus': '\u2A2E',
        'rotimes': '\u2A35',
        'RoundImplies': '\u2970',
        'rpar': ')',
        'rpargt': '\u2994',
        'rppolint': '\u2A12',
        'rrarr': '\u21C9',
        'Rrightarrow': '\u21DB',
        'rsaquo': '\u203A',
        'rscr': '\uD835\uDCC7',
        'Rscr': '',
        'rsh': '\u21B1',
        'Rsh': '\u21B1',
        'rsqb': ']',
        'rsquo': '\u2019',
        'rsquor': '\u2019',
        'rthree': '\u22CC',
        'rtimes': '\u22CA',
        'rtri': '\u25B9',
        'rtrie': '\u22B5',
        'rtrif': '\u25B8',
        'rtriltri': '\u29CE',
        'RuleDelayed': '\u29F4',
        'ruluhar': '\u2968',
        'rx': '\u211E',
        'sacute': '',
        'Sacute': '',
        'sbquo': '\u201A',
        'sc': '\u227B',
        'Sc': '\u2ABC',
        'scap': '\u2AB8',
        'scaron': '',
        'Scaron': '',
        'sccue': '\u227D',
        'sce': '\u2AB0',
        'scE': '\u2AB4',
        'scedil': '',
        'Scedil': '',
        'scirc': '',
        'Scirc': '',
        'scnap': '\u2ABA',
        'scnE': '\u2AB6',
        'scnsim': '\u22E9',
        'scpolint': '\u2A13',
        'scsim': '\u227F',
        'scy': '',
        'Scy': '',
        'sdot': '\u22C5',
        'sdotb': '\u22A1',
        'sdote': '\u2A66',
        'searhk': '\u2925',
        'searr': '\u2198',
        'seArr': '\u21D8',
        'searrow': '\u2198',
        'sect': '\xA7',
        'semi': ';',
        'seswar': '\u2929',
        'setminus': '\u2216',
        'setmn': '\u2216',
        'sext': '\u2736',
        'sfr': '\uD835\uDD30',
        'Sfr': '\uD835\uDD16',
        'sfrown': '\u2322',
        'sharp': '\u266F',
        'shchcy': '',
        'SHCHcy': '',
        'shcy': '',
        'SHcy': '',
        'ShortDownArrow': '\u2193',
        'ShortLeftArrow': '\u2190',
        'shortmid': '\u2223',
        'shortparallel': '\u2225',
        'ShortRightArrow': '\u2192',
        'ShortUpArrow': '\u2191',
        'shy': '\xAD',
        'sigma': '',
        'Sigma': '',
        'sigmaf': '',
        'sigmav': '',
        'sim': '\u223C',
        'simdot': '\u2A6A',
        'sime': '\u2243',
        'simeq': '\u2243',
        'simg': '\u2A9E',
        'simgE': '\u2AA0',
        'siml': '\u2A9D',
        'simlE': '\u2A9F',
        'simne': '\u2246',
        'simplus': '\u2A24',
        'simrarr': '\u2972',
        'slarr': '\u2190',
        'SmallCircle': '\u2218',
        'smallsetminus': '\u2216',
        'smashp': '\u2A33',
        'smeparsl': '\u29E4',
        'smid': '\u2223',
        'smile': '\u2323',
        'smt': '\u2AAA',
        'smte': '\u2AAC',
        'smtes': '\u2AAC',
        'softcy': '',
        'SOFTcy': '',
        'sol': '/',
        'solb': '\u29C4',
        'solbar': '\u233F',
        'sopf': '\uD835\uDD64',
        'Sopf': '\uD835\uDD4A',
        'spades': '\u2660',
        'spadesuit': '\u2660',
        'spar': '\u2225',
        'sqcap': '\u2293',
        'sqcaps': '\u2293',
        'sqcup': '\u2294',
        'sqcups': '\u2294',
        'Sqrt': '\u221A',
        'sqsub': '\u228F',
        'sqsube': '\u2291',
        'sqsubset': '\u228F',
        'sqsubseteq': '\u2291',
        'sqsup': '\u2290',
        'sqsupe': '\u2292',
        'sqsupset': '\u2290',
        'sqsupseteq': '\u2292',
        'squ': '\u25A1',
        'square': '\u25A1',
        'Square': '\u25A1',
        'SquareIntersection': '\u2293',
        'SquareSubset': '\u228F',
        'SquareSubsetEqual': '\u2291',
        'SquareSuperset': '\u2290',
        'SquareSupersetEqual': '\u2292',
        'SquareUnion': '\u2294',
        'squarf': '\u25AA',
        'squf': '\u25AA',
        'srarr': '\u2192',
        'sscr': '\uD835\uDCC8',
        'Sscr': '\uD835\uDCAE',
        'ssetmn': '\u2216',
        'ssmile': '\u2323',
        'sstarf': '\u22C6',
        'star': '\u2606',
        'Star': '\u22C6',
        'starf': '\u2605',
        'straightepsilon': '',
        'straightphi': '',
        'strns': '\xAF',
        'sub': '\u2282',
        'Sub': '\u22D0',
        'subdot': '\u2ABD',
        'sube': '\u2286',
        'subE': '\u2AC5',
        'subedot': '\u2AC3',
        'submult': '\u2AC1',
        'subne': '\u228A',
        'subnE': '\u2ACB',
        'subplus': '\u2ABF',
        'subrarr': '\u2979',
        'subset': '\u2282',
        'Subset': '\u22D0',
        'subseteq': '\u2286',
        'subseteqq': '\u2AC5',
        'SubsetEqual': '\u2286',
        'subsetneq': '\u228A',
        'subsetneqq': '\u2ACB',
        'subsim': '\u2AC7',
        'subsub': '\u2AD5',
        'subsup': '\u2AD3',
        'succ': '\u227B',
        'succapprox': '\u2AB8',
        'succcurlyeq': '\u227D',
        'Succeeds': '\u227B',
        'SucceedsEqual': '\u2AB0',
        'SucceedsSlantEqual': '\u227D',
        'SucceedsTilde': '\u227F',
        'succeq': '\u2AB0',
        'succnapprox': '\u2ABA',
        'succneqq': '\u2AB6',
        'succnsim': '\u22E9',
        'succsim': '\u227F',
        'SuchThat': '\u220B',
        'sum': '\u2211',
        'Sum': '\u2211',
        'sung': '\u266A',
        'sup': '\u2283',
        'Sup': '\u22D1',
        'sup1': '\xB9',
        'sup2': '\xB2',
        'sup3': '\xB3',
        'supdot': '\u2ABE',
        'supdsub': '\u2AD8',
        'supe': '\u2287',
        'supE': '\u2AC6',
        'supedot': '\u2AC4',
        'Superset': '\u2283',
        'SupersetEqual': '\u2287',
        'suphsol': '\u27C9',
        'suphsub': '\u2AD7',
        'suplarr': '\u297B',
        'supmult': '\u2AC2',
        'supne': '\u228B',
        'supnE': '\u2ACC',
        'supplus': '\u2AC0',
        'supset': '\u2283',
        'Supset': '\u22D1',
        'supseteq': '\u2287',
        'supseteqq': '\u2AC6',
        'supsetneq': '\u228B',
        'supsetneqq': '\u2ACC',
        'supsim': '\u2AC8',
        'supsub': '\u2AD4',
        'supsup': '\u2AD6',
        'swarhk': '\u2926',
        'swarr': '\u2199',
        'swArr': '\u21D9',
        'swarrow': '\u2199',
        'swnwar': '\u292A',
        'szlig': '',
        'Tab': '\t',
        'target': '\u2316',
        'tau': '',
        'Tau': '',
        'tbrk': '\u23B4',
        'tcaron': '',
        'Tcaron': '',
        'tcedil': '',
        'Tcedil': '',
        'tcy': '',
        'Tcy': '',
        'tdot': '',
        'telrec': '\u2315',
        'tfr': '\uD835\uDD31',
        'Tfr': '\uD835\uDD17',
        'there4': '\u2234',
        'therefore': '\u2234',
        'Therefore': '\u2234',
        'theta': '',
        'Theta': '',
        'thetasym': '',
        'thetav': '',
        'thickapprox': '\u2248',
        'thicksim': '\u223C',
        'ThickSpace': '\u205F\u200A',
        'thinsp': '\u2009',
        'ThinSpace': '\u2009',
        'thkap': '\u2248',
        'thksim': '\u223C',
        'thorn': '',
        'THORN': '',
        'tilde': '\u02DC',
        'Tilde': '\u223C',
        'TildeEqual': '\u2243',
        'TildeFullEqual': '\u2245',
        'TildeTilde': '\u2248',
        'times': '\xD7',
        'timesb': '\u22A0',
        'timesbar': '\u2A31',
        'timesd': '\u2A30',
        'tint': '\u222D',
        'toea': '\u2928',
        'top': '\u22A4',
        'topbot': '\u2336',
        'topcir': '\u2AF1',
        'topf': '\uD835\uDD65',
        'Topf': '\uD835\uDD4B',
        'topfork': '\u2ADA',
        'tosa': '\u2929',
        'tprime': '\u2034',
        'trade': '\u2122',
        'TRADE': '\u2122',
        'triangle': '\u25B5',
        'triangledown': '\u25BF',
        'triangleleft': '\u25C3',
        'trianglelefteq': '\u22B4',
        'triangleq': '\u225C',
        'triangleright': '\u25B9',
        'trianglerighteq': '\u22B5',
        'tridot': '\u25EC',
        'trie': '\u225C',
        'triminus': '\u2A3A',
        'TripleDot': '',
        'triplus': '\u2A39',
        'trisb': '\u29CD',
        'tritime': '\u2A3B',
        'trpezium': '\u23E2',
        'tscr': '\uD835\uDCC9',
        'Tscr': '\uD835\uDCAF',
        'tscy': '',
        'TScy': '',
        'tshcy': '',
        'TSHcy': '',
        'tstrok': '',
        'Tstrok': '',
        'twixt': '\u226C',
        'twoheadleftarrow': '\u219E',
        'twoheadrightarrow': '\u21A0',
        'uacute': '',
        'Uacute': '',
        'uarr': '\u2191',
        'uArr': '\u21D1',
        'Uarr': '\u219F',
        'Uarrocir': '\u2949',
        'ubrcy': '',
        'Ubrcy': '',
        'ubreve': '',
        'Ubreve': '',
        'ucirc': '',
        'Ucirc': '',
        'ucy': '',
        'Ucy': '',
        'udarr': '\u21C5',
        'udblac': '',
        'Udblac': '',
        'udhar': '\u296E',
        'ufisht': '\u297E',
        'ufr': '\uD835\uDD32',
        'Ufr': '\uD835\uDD18',
        'ugrave': '',
        'Ugrave': '',
        'uHar': '\u2963',
        'uharl': '\u21BF',
        'uharr': '\u21BE',
        'uhblk': '\u2580',
        'ulcorn': '\u231C',
        'ulcorner': '\u231C',
        'ulcrop': '\u230F',
        'ultri': '\u25F8',
        'umacr': '',
        'Umacr': '',
        'uml': '\xA8',
        'UnderBar': '_',
        'UnderBrace': '\u23DF',
        'UnderBracket': '\u23B5',
        'UnderParenthesis': '\u23DD',
        'Union': '\u22C3',
        'UnionPlus': '\u228E',
        'uogon': '',
        'Uogon': '',
        'uopf': '\uD835\uDD66',
        'Uopf': '\uD835\uDD4C',
        'uparrow': '\u2191',
        'Uparrow': '\u21D1',
        'UpArrow': '\u2191',
        'UpArrowBar': '\u2912',
        'UpArrowDownArrow': '\u21C5',
        'updownarrow': '\u2195',
        'Updownarrow': '\u21D5',
        'UpDownArrow': '\u2195',
        'UpEquilibrium': '\u296E',
        'upharpoonleft': '\u21BF',
        'upharpoonright': '\u21BE',
        'uplus': '\u228E',
        'UpperLeftArrow': '\u2196',
        'UpperRightArrow': '\u2197',
        'upsi': '',
        'Upsi': '',
        'upsih': '',
        'upsilon': '',
        'Upsilon': '',
        'UpTee': '\u22A5',
        'UpTeeArrow': '\u21A5',
        'upuparrows': '\u21C8',
        'urcorn': '\u231D',
        'urcorner': '\u231D',
        'urcrop': '\u230E',
        'uring': '',
        'Uring': '',
        'urtri': '\u25F9',
        'uscr': '\uD835\uDCCA',
        'Uscr': '\uD835\uDCB0',
        'utdot': '\u22F0',
        'utilde': '',
        'Utilde': '',
        'utri': '\u25B5',
        'utrif': '\u25B4',
        'uuarr': '\u21C8',
        'uuml': '',
        'Uuml': '',
        'uwangle': '\u29A7',
        'vangrt': '\u299C',
        'varepsilon': '',
        'varkappa': '',
        'varnothing': '\u2205',
        'varphi': '',
        'varpi': '',
        'varpropto': '\u221D',
        'varr': '\u2195',
        'vArr': '\u21D5',
        'varrho': '',
        'varsigma': '',
        'varsubsetneq': '\u228A',
        'varsubsetneqq': '\u2ACB',
        'varsupsetneq': '\u228B',
        'varsupsetneqq': '\u2ACC',
        'vartheta': '',
        'vartriangleleft': '\u22B2',
        'vartriangleright': '\u22B3',
        'vBar': '\u2AE8',
        'Vbar': '\u2AEB',
        'vBarv': '\u2AE9',
        'vcy': '',
        'Vcy': '',
        'vdash': '\u22A2',
        'vDash': '\u22A8',
        'Vdash': '\u22A9',
        'VDash': '\u22AB',
        'Vdashl': '\u2AE6',
        'vee': '\u2228',
        'Vee': '\u22C1',
        'veebar': '\u22BB',
        'veeeq': '\u225A',
        'vellip': '\u22EE',
        'verbar': '|',
        'Verbar': '\u2016',
        'vert': '|',
        'Vert': '\u2016',
        'VerticalBar': '\u2223',
        'VerticalLine': '|',
        'VerticalSeparator': '\u2758',
        'VerticalTilde': '\u2240',
        'VeryThinSpace': '\u200A',
        'vfr': '\uD835\uDD33',
        'Vfr': '\uD835\uDD19',
        'vltri': '\u22B2',
        'vnsub': '\u2282',
        'vnsup': '\u2283',
        'vopf': '\uD835\uDD67',
        'Vopf': '\uD835\uDD4D',
        'vprop': '\u221D',
        'vrtri': '\u22B3',
        'vscr': '\uD835\uDCCB',
        'Vscr': '\uD835\uDCB1',
        'vsubne': '\u228A',
        'vsubnE': '\u2ACB',
        'vsupne': '\u228B',
        'vsupnE': '\u2ACC',
        'Vvdash': '\u22AA',
        'vzigzag': '\u299A',
        'wcirc': '',
        'Wcirc': '',
        'wedbar': '\u2A5F',
        'wedge': '\u2227',
        'Wedge': '\u22C0',
        'wedgeq': '\u2259',
        'weierp': '\u2118',
        'wfr': '\uD835\uDD34',
        'Wfr': '\uD835\uDD1A',
        'wopf': '\uD835\uDD68',
        'Wopf': '\uD835\uDD4E',
        'wp': '\u2118',
        'wr': '\u2240',
        'wreath': '\u2240',
        'wscr': '\uD835\uDCCC',
        'Wscr': '\uD835\uDCB2',
        'xcap': '\u22C2',
        'xcirc': '\u25EF',
        'xcup': '\u22C3',
        'xdtri': '\u25BD',
        'xfr': '\uD835\uDD35',
        'Xfr': '\uD835\uDD1B',
        'xharr': '\u27F7',
        'xhArr': '\u27FA',
        'xi': '',
        'Xi': '',
        'xlarr': '\u27F5',
        'xlArr': '\u27F8',
        'xmap': '\u27FC',
        'xnis': '\u22FB',
        'xodot': '\u2A00',
        'xopf': '\uD835\uDD69',
        'Xopf': '\uD835\uDD4F',
        'xoplus': '\u2A01',
        'xotime': '\u2A02',
        'xrarr': '\u27F6',
        'xrArr': '\u27F9',
        'xscr': '\uD835\uDCCD',
        'Xscr': '\uD835\uDCB3',
        'xsqcup': '\u2A06',
        'xuplus': '\u2A04',
        'xutri': '\u25B3',
        'xvee': '\u22C1',
        'xwedge': '\u22C0',
        'yacute': '',
        'Yacute': '',
        'yacy': '',
        'YAcy': '',
        'ycirc': '',
        'Ycirc': '',
        'ycy': '',
        'Ycy': '',
        'yen': '\xA5',
        'yfr': '\uD835\uDD36',
        'Yfr': '\uD835\uDD1C',
        'yicy': '',
        'YIcy': '',
        'yopf': '\uD835\uDD6A',
        'Yopf': '\uD835\uDD50',
        'yscr': '\uD835\uDCCE',
        'Yscr': '\uD835\uDCB4',
        'yucy': '',
        'YUcy': '',
        'yuml': '',
        'Yuml': '',
        'zacute': '',
        'Zacute': '',
        'zcaron': '',
        'Zcaron': '',
        'zcy': '',
        'Zcy': '',
        'zdot': '',
        'Zdot': '',
        'zeetrf': '',
        'ZeroWidthSpace': '\u200B',
        'zeta': '',
        'Zeta': '',
        'zfr': '\uD835\uDD37',
        'Zfr': '',
        'zhcy': '',
        'ZHcy': '',
        'zigrarr': '\u21DD',
        'zopf': '\uD835\uDD6B',
        'Zopf': '',
        'zscr': '\uD835\uDCCF',
        'Zscr': '\uD835\uDCB5',
        'zwj': '',
        'zwnj': ''
    };
    var decodeMapLegacy = {
        'aacute': '',
        'Aacute': '',
        'acirc': '',
        'Acirc': '',
        'acute': '\xB4',
        'aelig': '',
        'AElig': '',
        'agrave': '',
        'Agrave': '',
        'amp': '&',
        'AMP': '&',
        'aring': '',
        'Aring': '',
        'atilde': '',
        'Atilde': '',
        'auml': '',
        'Auml': '',
        'brvbar': '\xA6',
        'ccedil': '',
        'Ccedil': '',
        'cedil': '\xB8',
        'cent': '\xA2',
        'copy': '\xA9',
        'COPY': '\xA9',
        'curren': '\xA4',
        'deg': '\xB0',
        'divide': '\xF7',
        'eacute': '',
        'Eacute': '',
        'ecirc': '',
        'Ecirc': '',
        'egrave': '',
        'Egrave': '',
        'eth': '',
        'ETH': '',
        'euml': '',
        'Euml': '',
        'frac12': '\xBD',
        'frac14': '\xBC',
        'frac34': '\xBE',
        'gt': '>',
        'GT': '>',
        'iacute': '',
        'Iacute': '',
        'icirc': '',
        'Icirc': '',
        'iexcl': '\xA1',
        'igrave': '',
        'Igrave': '',
        'iquest': '\xBF',
        'iuml': '',
        'Iuml': '',
        'laquo': '\xAB',
        'lt': '<',
        'LT': '<',
        'macr': '\xAF',
        'micro': '',
        'middot': '\xB7',
        'nbsp': '\xA0',
        'not': '\xAC',
        'ntilde': '',
        'Ntilde': '',
        'oacute': '',
        'Oacute': '',
        'ocirc': '',
        'Ocirc': '',
        'ograve': '',
        'Ograve': '',
        'ordf': '',
        'ordm': '',
        'oslash': '',
        'Oslash': '',
        'otilde': '',
        'Otilde': '',
        'ouml': '',
        'Ouml': '',
        'para': '\xB6',
        'plusmn': '\xB1',
        'pound': '\xA3',
        'quot': '"',
        'QUOT': '"',
        'raquo': '\xBB',
        'reg': '\xAE',
        'REG': '\xAE',
        'sect': '\xA7',
        'shy': '\xAD',
        'sup1': '\xB9',
        'sup2': '\xB2',
        'sup3': '\xB3',
        'szlig': '',
        'thorn': '',
        'THORN': '',
        'times': '\xD7',
        'uacute': '',
        'Uacute': '',
        'ucirc': '',
        'Ucirc': '',
        'ugrave': '',
        'Ugrave': '',
        'uml': '\xA8',
        'uuml': '',
        'Uuml': '',
        'yacute': '',
        'Yacute': '',
        'yen': '\xA5',
        'yuml': ''
    };
    var decodeMapNumeric = {
        '0': '\uFFFD',
        '128': '\u20AC',
        '130': '\u201A',
        '131': '',
        '132': '\u201E',
        '133': '\u2026',
        '134': '\u2020',
        '135': '\u2021',
        '136': '',
        '137': '\u2030',
        '138': '',
        '139': '\u2039',
        '140': '',
        '142': '',
        '145': '\u2018',
        '146': '\u2019',
        '147': '\u201C',
        '148': '\u201D',
        '149': '\u2022',
        '150': '\u2013',
        '151': '\u2014',
        '152': '\u02DC',
        '153': '\u2122',
        '154': '',
        '155': '\u203A',
        '156': '',
        '158': '',
        '159': ''
    };
    var invalidReferenceCodePoints = [
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        11,
        13,
        14,
        15,
        16,
        17,
        18,
        19,
        20,
        21,
        22,
        23,
        24,
        25,
        26,
        27,
        28,
        29,
        30,
        31,
        127,
        128,
        129,
        130,
        131,
        132,
        133,
        134,
        135,
        136,
        137,
        138,
        139,
        140,
        141,
        142,
        143,
        144,
        145,
        146,
        147,
        148,
        149,
        150,
        151,
        152,
        153,
        154,
        155,
        156,
        157,
        158,
        159,
        64976,
        64977,
        64978,
        64979,
        64980,
        64981,
        64982,
        64983,
        64984,
        64985,
        64986,
        64987,
        64988,
        64989,
        64990,
        64991,
        64992,
        64993,
        64994,
        64995,
        64996,
        64997,
        64998,
        64999,
        65000,
        65001,
        65002,
        65003,
        65004,
        65005,
        65006,
        65007,
        65534,
        65535,
        131070,
        131071,
        196606,
        196607,
        262142,
        262143,
        327678,
        327679,
        393214,
        393215,
        458750,
        458751,
        524286,
        524287,
        589822,
        589823,
        655358,
        655359,
        720894,
        720895,
        786430,
        786431,
        851966,
        851967,
        917502,
        917503,
        983038,
        983039,
        1048574,
        1048575,
        1114110,
        1114111
    ];
    var stringFromCharCode = String.fromCharCode;
    var object = {};
    var hasOwnProperty = object.hasOwnProperty;
    var has = function (object, propertyName) {
        return hasOwnProperty.call(object, propertyName);
    };
    var contains = function (array, value) {
        var index = -1;
        var length = array.length;
        while (++index < length) {
            if (array[index] == value) {
                return true;
            }
        }
        return false;
    };
    var merge = function (options, defaults) {
        if (!options) {
            return defaults;
        }
        var result = {};
        var key;
        for (key in defaults) {
            result[key] = has(options, key) ? options[key] : defaults[key];
        }
        return result;
    };
    var codePointToSymbol = function (codePoint, strict) {
        var output = '';
        if (codePoint >= 55296 && codePoint <= 57343 || codePoint > 1114111) {
            if (strict) {
                parseError('character reference outside the permissible Unicode range');
            }
            return '\uFFFD';
        }
        if (has(decodeMapNumeric, codePoint)) {
            if (strict) {
                parseError('disallowed character reference');
            }
            return decodeMapNumeric[codePoint];
        }
        if (strict && contains(invalidReferenceCodePoints, codePoint)) {
            parseError('disallowed character reference');
        }
        if (codePoint > 65535) {
            codePoint -= 65536;
            output += stringFromCharCode(codePoint >>> 10 & 1023 | 55296);
            codePoint = 56320 | codePoint & 1023;
        }
        output += stringFromCharCode(codePoint);
        return output;
    };
    var hexEscape = function (codePoint) {
        return '&#x' + codePoint.toString(16).toUpperCase() + ';';
    };
    var decEscape = function (codePoint) {
        return '&#' + codePoint + ';';
    };
    var parseError = function (message) {
        throw Error('Parse error: ' + message);
    };
    var encode = function (string, options) {
        options = merge(options, encode.options);
        var strict = options.strict;
        if (strict && regexInvalidRawCodePoint.test(string)) {
            parseError('forbidden code point');
        }
        var encodeEverything = options.encodeEverything;
        var useNamedReferences = options.useNamedReferences;
        var allowUnsafeSymbols = options.allowUnsafeSymbols;
        var escapeCodePoint = options.decimal ? decEscape : hexEscape;
        var escapeBmpSymbol = function (symbol) {
            return escapeCodePoint(symbol.charCodeAt(0));
        };
        if (encodeEverything) {
            string = string.replace(regexAsciiWhitelist, function (symbol) {
                if (useNamedReferences && has(encodeMap, symbol)) {
                    return '&' + encodeMap[symbol] + ';';
                }
                return escapeBmpSymbol(symbol);
            });
            if (useNamedReferences) {
                string = string.replace(/&gt;\u20D2/g, '&nvgt;').replace(/&lt;\u20D2/g, '&nvlt;').replace(/&#x66;&#x6A;/g, '&fjlig;');
            }
            if (useNamedReferences) {
                string = string.replace(regexEncodeNonAscii, function (string) {
                    return '&' + encodeMap[string] + ';';
                });
            }
        } else if (useNamedReferences) {
            if (!allowUnsafeSymbols) {
                string = string.replace(regexEscape, function (string) {
                    return '&' + encodeMap[string] + ';';
                });
            }
            string = string.replace(/&gt;\u20D2/g, '&nvgt;').replace(/&lt;\u20D2/g, '&nvlt;');
            string = string.replace(regexEncodeNonAscii, function (string) {
                return '&' + encodeMap[string] + ';';
            });
        } else if (!allowUnsafeSymbols) {
            string = string.replace(regexEscape, escapeBmpSymbol);
        }
        return string.replace(regexAstralSymbols, function ($0) {
            var high = $0.charCodeAt(0);
            var low = $0.charCodeAt(1);
            var codePoint = (high - 55296) * 1024 + low - 56320 + 65536;
            return escapeCodePoint(codePoint);
        }).replace(regexBmpWhitelist, escapeBmpSymbol);
    };
    encode.options = {
        'allowUnsafeSymbols': false,
        'encodeEverything': false,
        'strict': false,
        'useNamedReferences': false,
        'decimal': false
    };
    var decode = function (html, options) {
        options = merge(options, decode.options);
        var strict = options.strict;
        if (strict && regexInvalidEntity.test(html)) {
            parseError('malformed character reference');
        }
        return html.replace(regexDecode, function ($0, $1, $2, $3, $4, $5, $6, $7) {
            var codePoint;
            var semicolon;
            var decDigits;
            var hexDigits;
            var reference;
            var next;
            if ($1) {
                decDigits = $1;
                semicolon = $2;
                if (strict && !semicolon) {
                    parseError('character reference was not terminated by a semicolon');
                }
                codePoint = parseInt(decDigits, 10);
                return codePointToSymbol(codePoint, strict);
            }
            if ($3) {
                hexDigits = $3;
                semicolon = $4;
                if (strict && !semicolon) {
                    parseError('character reference was not terminated by a semicolon');
                }
                codePoint = parseInt(hexDigits, 16);
                return codePointToSymbol(codePoint, strict);
            }
            if ($5) {
                reference = $5;
                if (has(decodeMap, reference)) {
                    return decodeMap[reference];
                } else {
                    if (strict) {
                        parseError('named character reference was not terminated by a semicolon');
                    }
                    return $0;
                }
            }
            reference = $6;
            next = $7;
            if (next && options.isAttributeValue) {
                if (strict && next == '=') {
                    parseError('`&` did not start a character reference');
                }
                return $0;
            } else {
                if (strict) {
                    parseError('named character reference was not terminated by a semicolon');
                }
                return decodeMapLegacy[reference] + (next || '');
            }
        });
    };
    decode.options = {
        'isAttributeValue': false,
        'strict': false
    };
    var escape = function (string) {
        return string.replace(regexEscape, function ($0) {
            return escapeMap[$0];
        });
    };
    var he = {
        'version': '1.1.1',
        'encode': encode,
        'decode': decode,
        'escape': escape,
        'unescape': decode
    };
    if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {
        define('he@1.1.1#he', function () {
            return he;
        });
    } else if (freeExports && !freeExports.nodeType) {
        if (freeModule) {
            freeModule.exports = he;
        } else {
            for (var key in he) {
                has(he, key) && (freeExports[key] = he[key]);
            }
        }
    } else {
        root.he = he;
    }
}(this));
/*can-simple-dom@1.3.4#simple-dom/html-parser*/
define('can-simple-dom@1.3.4#simple-dom/html-parser', [
    'exports',
    'he'
], function (exports, _he) {
    'use strict';
    Object.defineProperty(exports, '__esModule', { value: true });
    var _he2 = _interopRequireDefault(_he);
    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
    }
    function HTMLParser(tokenize, document, voidMap) {
        this.tokenize = tokenize;
        this.document = document;
        this.voidMap = voidMap;
        this.parentStack = [];
    }
    HTMLParser.prototype.isVoid = function (element) {
        return this.voidMap[element.nodeName] === true;
    };
    HTMLParser.prototype.pushElement = function (token) {
        var el = this.document.createElement(token.tagName);
        for (var i = 0; i < token.attributes.length; i++) {
            var attr = token.attributes[i];
            if (attr[0] !== 'href' && attr[0] !== 'src') {
                attr[1] = _he2.default.encode(attr[1]);
            }
            el.setAttribute(attr[0], attr[1]);
        }
        if (this.isVoid(el) || token.selfClosing) {
            return this.appendChild(el);
        }
        this.parentStack.push(el);
    };
    HTMLParser.prototype.popElement = function (token) {
        var el = this.parentStack.pop();
        if (el.nodeName !== token.tagName.toUpperCase()) {
            throw new Error('unbalanced tag');
        }
        this.appendChild(el);
    };
    HTMLParser.prototype.appendText = function (token) {
        var text = this.document.createTextNode(token.chars);
        this.appendChild(text);
    };
    HTMLParser.prototype.appendComment = function (token) {
        var comment = this.document.createComment(token.chars);
        this.appendChild(comment);
    };
    HTMLParser.prototype.appendChild = function (node) {
        var parentNode = this.parentStack[this.parentStack.length - 1];
        parentNode.appendChild(node);
    };
    HTMLParser.prototype.parse = function (html) {
        var fragment = this.document.createDocumentFragment();
        this.parentStack.push(fragment);
        var tokens = this.tokenize(html);
        for (var i = 0, l = tokens.length; i < l; i++) {
            var token = tokens[i];
            switch (token.type) {
            case 'StartTag':
                this.pushElement(token);
                break;
            case 'EndTag':
                this.popElement(token);
                break;
            case 'Chars':
                this.appendText(token);
                break;
            case 'Comment':
                this.appendComment(token);
                break;
            }
        }
        return this.parentStack.pop();
    };
    exports.default = HTMLParser;
});
/*can-simple-dom@1.3.4#simple-dom/html-serializer*/
define('can-simple-dom@1.3.4#simple-dom/html-serializer', ['exports'], function (exports) {
    'use strict';
    Object.defineProperty(exports, '__esModule', { value: true });
    var REG_ESCAPE_ALL = /[<>&]/g;
    var REG_ESCAPE_PRESERVE_ENTITIES = /[<>]|&(?:#?[a-zA-Z0-9]+;)?/g;
    function HTMLSerializer(voidMap) {
        this.voidMap = voidMap;
    }
    HTMLSerializer.prototype.openTag = function (element) {
        return '<' + element.nodeName.toLowerCase() + this.attributes(element.attributes) + '>';
    };
    HTMLSerializer.prototype.closeTag = function (element) {
        return '</' + element.nodeName.toLowerCase() + '>';
    };
    HTMLSerializer.prototype.isVoid = function (element) {
        return this.voidMap[element.nodeName] === true;
    };
    HTMLSerializer.prototype.attributes = function (namedNodeMap) {
        var buffer = '';
        for (var i = 0, l = namedNodeMap.length; i < l; i++) {
            buffer += this.attr(namedNodeMap[i]);
        }
        return buffer;
    };
    HTMLSerializer.prototype.escapeAttrValue = function (attrValue) {
        return attrValue.replace(/"|&(?:#?[a-zA-Z0-9]+;)?/g, function (match) {
            switch (match) {
            case '&':
                return '&amp;';
            case '"':
                return '&quot;';
            default:
                return match;
            }
        });
    };
    HTMLSerializer.prototype.attr = function (attr) {
        if (!attr.specified) {
            return '';
        }
        if (attr.value) {
            if (attr.name === 'href' || attr.name === 'src') {
                return ' ' + attr.name + '="' + attr.value + '"';
            }
            return ' ' + attr.name + '="' + this.escapeAttrValue(attr.value) + '"';
        }
        return ' ' + attr.name;
    };
    HTMLSerializer.prototype.escapeText = function (textNodeValue, escapeAll) {
        return textNodeValue.replace(escapeAll ? REG_ESCAPE_ALL : REG_ESCAPE_PRESERVE_ENTITIES, function (match) {
            switch (match) {
            case '&':
                return '&amp;';
            case '<':
                return '&lt;';
            case '>':
                return '&gt;';
            default:
                return match;
            }
        });
    };
    var metadataContentTags = {
        style: true,
        script: true,
        template: true
    };
    function isMetadataTag(elem) {
        return !!elem && metadataContentTags[elem.nodeName.toLowerCase()];
    }
    HTMLSerializer.prototype.text = function (text) {
        if (isMetadataTag(text.parentNode)) {
            return text.nodeValue;
        }
        return this.escapeText(text.nodeValue);
    };
    HTMLSerializer.prototype.comment = function (comment) {
        return '<!--' + comment.nodeValue + '-->';
    };
    HTMLSerializer.prototype.serialize = function (node) {
        var buffer = '';
        var next;
        switch (node.nodeType) {
        case 1:
            buffer += this.openTag(node);
            break;
        case 3:
            buffer += this.text(node);
            break;
        case 8:
            buffer += this.comment(node);
            break;
        default:
            break;
        }
        next = node.firstChild;
        if (next) {
            while (next) {
                buffer += this.serialize(next);
                next = next.nextSibling;
            }
        } else if (node.nodeType === 1 && node.textContent) {
            buffer += this.escapeText(node.textContent, true);
        }
        if (node.nodeType === 1 && !this.isVoid(node)) {
            buffer += this.closeTag(node);
        }
        return buffer;
    };
    exports.default = HTMLSerializer;
});
/*can-simple-dom@1.3.4#simple-dom/void-map*/
define('can-simple-dom@1.3.4#simple-dom/void-map', ['exports'], function (exports) {
    'use strict';
    Object.defineProperty(exports, '__esModule', { value: true });
    exports.default = {
        AREA: true,
        BASE: true,
        BR: true,
        COL: true,
        COMMAND: true,
        EMBED: true,
        HR: true,
        IMG: true,
        INPUT: true,
        KEYGEN: true,
        LINK: true,
        META: true,
        PARAM: true,
        SOURCE: true,
        TRACK: true,
        WBR: true
    };
});
/*can-simple-dom@1.3.4#simple-dom/dom*/
define('can-simple-dom@1.3.4#simple-dom/dom', [
    'exports',
    './document/node',
    './document/element',
    './document',
    './event',
    './html-parser',
    './html-serializer',
    './void-map'
], function (exports, _node, _element, _document, _event, _htmlParser, _htmlSerializer, _voidMap) {
    'use strict';
    Object.defineProperty(exports, '__esModule', { value: true });
    exports.createDocument = exports.voidMap = exports.HTMLSerializer = exports.HTMLParser = exports.Event = exports.Document = exports.Element = exports.Node = undefined;
    var _node2 = _interopRequireDefault(_node);
    var _element2 = _interopRequireDefault(_element);
    var _document2 = _interopRequireDefault(_document);
    var _event2 = _interopRequireDefault(_event);
    var _htmlParser2 = _interopRequireDefault(_htmlParser);
    var _htmlSerializer2 = _interopRequireDefault(_htmlSerializer);
    var _voidMap2 = _interopRequireDefault(_voidMap);
    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
    }
    function createDocument(serializer, parser) {
        var doc = new _document2.default();
        doc.__serializer = serializer;
        doc.__parser = parser;
        return doc;
    }
    exports.Node = _node2.default;
    exports.Element = _element2.default;
    exports.Document = _document2.default;
    exports.Event = _event2.default;
    exports.HTMLParser = _htmlParser2.default;
    exports.HTMLSerializer = _htmlSerializer2.default;
    exports.voidMap = _voidMap2.default;
    exports.createDocument = createDocument;
});
/*can-simple-dom@1.3.4#simple-dom*/
define('can-simple-dom@1.3.4#simple-dom', [
    'exports',
    './simple-dom/dom'
], function (exports, _dom) {
    'use strict';
    Object.defineProperty(exports, '__esModule', { value: true });
    Object.keys(_dom).forEach(function (key) {
        if (key === 'default' || key === '__esModule')
            return;
        Object.defineProperty(exports, key, {
            enumerable: true,
            get: function () {
                return _dom[key];
            }
        });
    });
    var SimpleDOM = _interopRequireWildcard(_dom);
    function _interopRequireWildcard(obj) {
        if (obj && obj.__esModule) {
            return obj;
        } else {
            var newObj = {};
            if (obj != null) {
                for (var key in obj) {
                    if (Object.prototype.hasOwnProperty.call(obj, key))
                        newObj[key] = obj[key];
                }
            }
            newObj.default = obj;
            return newObj;
        }
    }
    if (typeof window !== 'undefined') {
        window.SimpleDOM = SimpleDOM;
    }
});
/*can-log@1.0.0#can-log*/
define('can-log@1.0.0#can-log', function (require, exports, module) {
    'use strict';
    exports.warnTimeout = 5000;
    exports.logLevel = 0;
    exports.warn = function () {
        var ll = this.logLevel;
        if (ll < 2) {
            if (typeof console !== 'undefined' && console.warn) {
                this._logger('warn', Array.prototype.slice.call(arguments));
            } else if (typeof console !== 'undefined' && console.log) {
                this._logger('log', Array.prototype.slice.call(arguments));
            }
        }
    };
    exports.log = function () {
        var ll = this.logLevel;
        if (ll < 1) {
            if (typeof console !== 'undefined' && console.log) {
                this._logger('log', Array.prototype.slice.call(arguments));
            }
        }
    };
    exports.error = function () {
        var ll = this.logLevel;
        if (ll < 1) {
            if (typeof console !== 'undefined' && console.error) {
                this._logger('error', Array.prototype.slice.call(arguments));
            }
        }
    };
    exports._logger = function (type, arr) {
        try {
            console[type].apply(console, arr);
        } catch (e) {
            console[type](arr);
        }
    };
});
/*can-log@1.0.0#dev/dev*/
define('can-log@1.0.0#dev/dev', [
    'require',
    'exports',
    'module',
    '../can-log'
], function (require, exports, module) {
    'use strict';
    var canLog = require('../can-log');
    module.exports = {
        warnTimeout: 5000,
        logLevel: 0,
        stringify: function (value) {
            var flagUndefined = function flagUndefined(key, value) {
                return value === undefined ? '/* void(undefined) */' : value;
            };
            return JSON.stringify(value, flagUndefined, '  ').replace(/"\/\* void\(undefined\) \*\/"/g, 'undefined');
        },
        warn: function () {
        },
        log: function () {
        },
        error: function () {
        },
        _logger: canLog._logger
    };
});
/*can-attribute-encoder@1.0.0#can-attribute-encoder*/
define('can-attribute-encoder@1.0.0#can-attribute-encoder', [
    'require',
    'exports',
    'module',
    'can-namespace',
    'can-log/dev/dev'
], function (require, exports, module) {
    var namespace = require('can-namespace');
    var dev = require('can-log/dev/dev');
    function each(items, callback) {
        for (var i = 0; i < items.length; i++) {
            callback(items[i], i);
        }
    }
    function makeMap(str) {
        var obj = {}, items = str.split(',');
        each(items, function (name) {
            obj[name] = true;
        });
        return obj;
    }
    var caseMattersAttributes = makeMap('allowReorder,attributeName,attributeType,autoReverse,baseFrequency,baseProfile,calcMode,clipPathUnits,contentScriptType,contentStyleType,diffuseConstant,edgeMode,externalResourcesRequired,filterRes,filterUnits,glyphRef,gradientTransform,gradientUnits,kernelMatrix,kernelUnitLength,keyPoints,keySplines,keyTimes,lengthAdjust,limitingConeAngle,markerHeight,markerUnits,markerWidth,maskContentUnits,maskUnits,patternContentUnits,patternTransform,patternUnits,pointsAtX,pointsAtY,pointsAtZ,preserveAlpha,preserveAspectRatio,primitiveUnits,repeatCount,repeatDur,requiredExtensions,requiredFeatures,specularConstant,specularExponent,spreadMethod,startOffset,stdDeviation,stitchTiles,surfaceScale,systemLanguage,tableValues,textLength,viewBox,viewTarget,xChannelSelector,yChannelSelector');
    function camelCaseToSpinalCase(match, lowerCaseChar, upperCaseChar) {
        return lowerCaseChar + '-' + upperCaseChar.toLowerCase();
    }
    function startsWith(allOfIt, startsWith) {
        return allOfIt.indexOf(startsWith) === 0;
    }
    function endsWith(allOfIt, endsWith) {
        return allOfIt.length - allOfIt.indexOf(endsWith) === endsWith.length;
    }
    var regexes = {
        leftParens: /\(/g,
        rightParens: /\)/g,
        leftBrace: /\{/g,
        rightBrace: /\}/g,
        camelCase: /([a-z])([A-Z])/g,
        forwardSlash: /\//g,
        space: /\s/g,
        uppercase: /[A-Z]/g,
        uppercaseDelimiterThenChar: /:u:([a-z])/g,
        caret: /\^/g,
        dollar: /\$/g,
        at: /@/g
    };
    var delimiters = {
        prependUppercase: ':u:',
        replaceSpace: ':s:',
        replaceForwardSlash: ':f:',
        replaceLeftParens: ':lp:',
        replaceRightParens: ':rp:',
        replaceLeftBrace: ':lb:',
        replaceRightBrace: ':rb:',
        replaceCaret: ':c:',
        replaceDollar: ':d:',
        replaceAt: ':at:'
    };
    var encoder = {};
    encoder.encode = function (name) {
        var encoded = name;
        if (!caseMattersAttributes[encoded] && encoded.match(regexes.camelCase)) {
            if (startsWith(encoded, 'on:') || endsWith(encoded, ':to') || endsWith(encoded, ':from') || endsWith(encoded, ':bind')) {
                encoded = encoded.replace(regexes.uppercase, function (char) {
                    return delimiters.prependUppercase + char.toLowerCase();
                });
            } else {
                encoded = encoded.replace(regexes.camelCase, camelCaseToSpinalCase);
            }
        }
        encoded = encoded.replace(regexes.space, delimiters.replaceSpace).replace(regexes.forwardSlash, delimiters.replaceForwardSlash).replace(regexes.leftParens, delimiters.replaceLeftParens).replace(regexes.rightParens, delimiters.replaceRightParens).replace(regexes.leftBrace, delimiters.replaceLeftBrace).replace(regexes.rightBrace, delimiters.replaceRightBrace).replace(regexes.caret, delimiters.replaceCaret).replace(regexes.dollar, delimiters.replaceDollar).replace(regexes.at, delimiters.replaceAt);
        return encoded;
    };
    encoder.decode = function (name) {
        var decoded = name;
        if (!caseMattersAttributes[decoded] && decoded.match(regexes.uppercaseDelimiterThenChar)) {
            if (startsWith(decoded, 'on:') || endsWith(decoded, ':to') || endsWith(decoded, ':from') || endsWith(decoded, ':bind')) {
                decoded = decoded.replace(regexes.uppercaseDelimiterThenChar, function (match, char) {
                    return char.toUpperCase();
                });
            }
        }
        decoded = decoded.replace(delimiters.replaceLeftParens, '(').replace(delimiters.replaceRightParens, ')').replace(delimiters.replaceLeftBrace, '{').replace(delimiters.replaceRightBrace, '}').replace(delimiters.replaceForwardSlash, '/').replace(delimiters.replaceSpace, ' ').replace(delimiters.replaceCaret, '^').replace(delimiters.replaceDollar, '$').replace(delimiters.replaceAt, '@');
        return decoded;
    };
    if (namespace.encoder) {
        throw new Error('You can\'t have two versions of can-attribute-encoder, check your dependencies');
    } else {
        module.exports = namespace.encoder = encoder;
    }
});
/*can-view-parser@4.0.1#can-view-parser*/
define('can-view-parser@4.0.1#can-view-parser', [
    'require',
    'exports',
    'module',
    'can-namespace',
    'can-log/dev/dev',
    'can-attribute-encoder'
], function (require, exports, module) {
    var namespace = require('can-namespace'), dev = require('can-log/dev/dev'), encoder = require('can-attribute-encoder');
    function each(items, callback) {
        for (var i = 0; i < items.length; i++) {
            callback(items[i], i);
        }
    }
    function makeMap(str) {
        var obj = {}, items = str.split(',');
        each(items, function (name) {
            obj[name] = true;
        });
        return obj;
    }
    function handleIntermediate(intermediate, handler) {
        for (var i = 0, len = intermediate.length; i < len; i++) {
            var item = intermediate[i];
            handler[item.tokenType].apply(handler, item.args);
        }
        return intermediate;
    }
    var alphaNumeric = 'A-Za-z0-9', alphaNumericHU = '-:_' + alphaNumeric, magicStart = '{{', endTag = new RegExp('^<\\/([' + alphaNumericHU + ']+)[^>]*>'), magicMatch = new RegExp('\\{\\{(![\\s\\S]*?!|[\\s\\S]*?)\\}\\}\\}?', 'g'), space = /\s/, alphaRegex = new RegExp('[' + alphaNumeric + ']'), attributeRegexp = new RegExp('[' + alphaNumericHU + ']+s*=s*("[^"]*"|\'[^\']*\')');
    var empty = makeMap('area,base,basefont,br,col,frame,hr,img,input,isindex,link,meta,param,embed');
    var caseMattersElements = makeMap('altGlyph,altGlyphDef,altGlyphItem,animateColor,animateMotion,animateTransform,clipPath,feBlend,feColorMatrix,feComponentTransfer,feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,feDistantLight,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,foreignObject,glyphRef,linearGradient,radialGradient,textPath');
    var closeSelf = makeMap('colgroup,dd,dt,li,options,p,td,tfoot,th,thead,tr');
    var special = makeMap('script');
    var tokenTypes = 'start,end,close,attrStart,attrEnd,attrValue,chars,comment,special,done'.split(',');
    var startOppositesMap = {
        '{': '}',
        '(': ')'
    };
    var fn = function () {
    };
    var HTMLParser = function (html, handler, returnIntermediate) {
        if (typeof html === 'object') {
            return handleIntermediate(html, handler);
        }
        var intermediate = [];
        handler = handler || {};
        if (returnIntermediate) {
            each(tokenTypes, function (name) {
                var callback = handler[name] || fn;
                handler[name] = function () {
                    if (callback.apply(this, arguments) !== false) {
                        var end = arguments.length;
                        if (arguments[end - 1] === undefined) {
                            end = arguments.length - 1;
                        }
                        intermediate.push({
                            tokenType: name,
                            args: [].slice.call(arguments, 0, end)
                        });
                    }
                };
            });
        }
        function parseStartTag(tag, tagName, rest, unary) {
            tagName = caseMattersElements[tagName] ? tagName : tagName.toLowerCase();
            if (closeSelf[tagName] && stack.last() === tagName) {
                parseEndTag('', tagName);
            }
            unary = empty[tagName] || !!unary;
            handler.start(tagName, unary, lineNo);
            if (!unary) {
                stack.push(tagName);
            }
            HTMLParser.parseAttrs(rest, handler, lineNo);
            handler.end(tagName, unary, lineNo);
        }
        function parseEndTag(tag, tagName) {
            var pos;
            if (!tagName) {
                pos = 0;
            } else {
                tagName = caseMattersElements[tagName] ? tagName : tagName.toLowerCase();
                for (pos = stack.length - 1; pos >= 0; pos--) {
                    if (stack[pos] === tagName) {
                        break;
                    }
                }
            }
            if (pos >= 0) {
                for (var i = stack.length - 1; i >= pos; i--) {
                    if (handler.close) {
                        handler.close(stack[i], lineNo);
                    }
                }
                stack.length = pos;
            }
        }
        function parseMustache(mustache, inside) {
            if (handler.special) {
                handler.special(inside, lineNo);
            }
        }
        var callChars = function () {
            if (charsText) {
                if (handler.chars) {
                    handler.chars(charsText, lineNo);
                }
            }
            charsText = '';
        };
        var index, chars, match, lineNo, stack = [], last = html, charsText = '';
        stack.last = function () {
            return this[this.length - 1];
        };
        while (html) {
            chars = true;
            if (!stack.last() || !special[stack.last()]) {
                if (html.indexOf('<!--') === 0) {
                    index = html.indexOf('-->');
                    if (index >= 0) {
                        callChars();
                        if (handler.comment) {
                            handler.comment(html.substring(4, index), lineNo);
                        }
                        html = html.substring(index + 3);
                        chars = false;
                    }
                } else if (html.indexOf('</') === 0) {
                    match = html.match(endTag);
                    if (match) {
                        callChars();
                        match[0].replace(endTag, parseEndTag);
                        html = html.substring(match[0].length);
                        chars = false;
                    }
                } else if (html.indexOf('<') === 0) {
                    var res = HTMLParser.searchStartTag(html);
                    if (res) {
                        callChars();
                        parseStartTag.apply(null, res.match);
                        html = res.html;
                        chars = false;
                    }
                } else if (html.indexOf(magicStart) === 0) {
                    match = html.match(magicMatch);
                    if (match) {
                        callChars();
                        match[0].replace(magicMatch, parseMustache);
                        html = html.substring(match[0].length);
                    }
                }
                if (chars) {
                    index = findBreak(html, magicStart);
                    if (index === 0 && html === last) {
                        charsText += html.charAt(0);
                        html = html.substr(1);
                        index = findBreak(html, magicStart);
                    }
                    var text = index < 0 ? html : html.substring(0, index);
                    html = index < 0 ? '' : html.substring(index);
                    if (text) {
                        charsText += text;
                    }
                }
            } else {
                html = html.replace(new RegExp('([\\s\\S]*?)</' + stack.last() + '[^>]*>'), function (all, text) {
                    text = text.replace(/<!--([\s\S]*?)-->|<!\[CDATA\[([\s\S]*?)]]>/g, '$1$2');
                    if (handler.chars) {
                        handler.chars(text, lineNo);
                    }
                    return '';
                });
                parseEndTag('', stack.last());
            }
            if (html === last) {
                throw new Error('Parse Error: ' + html);
            }
            last = html;
        }
        callChars();
        parseEndTag();
        handler.done(lineNo);
        return intermediate;
    };
    var callAttrStart = function (state, curIndex, handler, rest, lineNo) {
        var attrName = rest.substring(typeof state.nameStart === 'number' ? state.nameStart : curIndex, curIndex), newAttrName = encoder.encode(attrName);
        state.attrStart = newAttrName;
        handler.attrStart(state.attrStart, lineNo);
        state.inName = false;
    };
    var callAttrEnd = function (state, curIndex, handler, rest, lineNo) {
        if (state.valueStart !== undefined && state.valueStart < curIndex) {
            var val = rest.substring(state.valueStart, curIndex);
            handler.attrValue(val, lineNo);
        }
        handler.attrEnd(state.attrStart, lineNo);
        state.attrStart = undefined;
        state.valueStart = undefined;
        state.inValue = false;
        state.inName = false;
        state.lookingForEq = false;
        state.inQuote = false;
        state.lookingForName = true;
    };
    var findBreak = function (str, magicStart) {
        var magicLength = magicStart.length;
        for (var i = 0, len = str.length; i < len; i++) {
            if (str[i] === '<' || str.substr(i, magicLength) === magicStart) {
                return i;
            }
        }
        return -1;
    };
    HTMLParser.parseAttrs = function (rest, handler, lineNo) {
        if (!rest) {
            return;
        }
        var i = 0;
        var curIndex;
        var state = {
            inName: false,
            nameStart: undefined,
            inValue: false,
            valueStart: undefined,
            inQuote: false,
            attrStart: undefined,
            lookingForName: true,
            lookingForValue: false,
            lookingForEq: false
        };
        while (i < rest.length) {
            curIndex = i;
            var cur = rest.charAt(i);
            i++;
            if (magicStart === rest.substr(curIndex, magicStart.length)) {
                if (state.inValue && curIndex > state.valueStart) {
                    handler.attrValue(rest.substring(state.valueStart, curIndex), lineNo);
                } else if (state.inName && state.nameStart < curIndex) {
                    callAttrStart(state, curIndex, handler, rest, lineNo);
                    callAttrEnd(state, curIndex, handler, rest, lineNo);
                } else if (state.lookingForValue) {
                    state.inValue = true;
                } else if (state.lookingForEq && state.attrStart) {
                    callAttrEnd(state, curIndex, handler, rest, lineNo);
                }
                magicMatch.lastIndex = curIndex;
                var match = magicMatch.exec(rest);
                if (match) {
                    handler.special(match[1], lineNo);
                    i = curIndex + match[0].length;
                    if (state.inValue) {
                        state.valueStart = curIndex + match[0].length;
                    }
                }
            } else if (state.inValue) {
                if (state.inQuote) {
                    if (cur === state.inQuote) {
                        callAttrEnd(state, curIndex, handler, rest, lineNo);
                    }
                } else if (space.test(cur)) {
                    callAttrEnd(state, curIndex, handler, rest, lineNo);
                }
            } else if (cur === '=' && (state.lookingForEq || state.lookingForName || state.inName)) {
                if (!state.attrStart) {
                    callAttrStart(state, curIndex, handler, rest, lineNo);
                }
                state.lookingForValue = true;
                state.lookingForEq = false;
                state.lookingForName = false;
            } else if (state.inName) {
                var started = rest[state.nameStart], otherStart, otherOpposite;
                if (startOppositesMap[started] === cur) {
                    otherStart = started === '{' ? '(' : '{';
                    otherOpposite = startOppositesMap[otherStart];
                    if (rest[curIndex + 1] === otherOpposite) {
                        callAttrStart(state, curIndex + 2, handler, rest, lineNo);
                        i++;
                    } else {
                        callAttrStart(state, curIndex + 1, handler, rest, lineNo);
                    }
                    state.lookingForEq = true;
                } else if (space.test(cur) && started !== '{' && started !== '(') {
                    callAttrStart(state, curIndex, handler, rest, lineNo);
                    state.lookingForEq = true;
                }
            } else if (state.lookingForName) {
                if (!space.test(cur)) {
                    if (state.attrStart) {
                        callAttrEnd(state, curIndex, handler, rest, lineNo);
                    }
                    state.nameStart = curIndex;
                    state.inName = true;
                }
            } else if (state.lookingForValue) {
                if (!space.test(cur)) {
                    state.lookingForValue = false;
                    state.inValue = true;
                    if (cur === '\'' || cur === '"') {
                        state.inQuote = cur;
                        state.valueStart = curIndex + 1;
                    } else {
                        state.valueStart = curIndex;
                    }
                } else if (i === rest.length) {
                    callAttrEnd(state, curIndex, handler, rest, lineNo);
                }
            }
        }
        if (state.inName) {
            callAttrStart(state, curIndex + 1, handler, rest, lineNo);
            callAttrEnd(state, curIndex + 1, handler, rest, lineNo);
        } else if (state.lookingForEq || state.lookingForValue || state.inValue) {
            callAttrEnd(state, curIndex + 1, handler, rest, lineNo);
        }
        magicMatch.lastIndex = 0;
    };
    HTMLParser.searchStartTag = function (html) {
        var closingIndex = html.indexOf('>');
        var attributeRange = attributeRegexp.exec(html.substring(1));
        var afterAttributeOffset = 1;
        while (attributeRange && closingIndex >= afterAttributeOffset + attributeRange.index) {
            afterAttributeOffset += attributeRange.index + attributeRange[0].length;
            while (closingIndex < afterAttributeOffset) {
                closingIndex += html.substring(closingIndex + 1).indexOf('>') + 1;
            }
            attributeRange = attributeRegexp.exec(html.substring(afterAttributeOffset));
        }
        if (closingIndex === -1 || !alphaRegex.test(html[1])) {
            return null;
        }
        var tagName, tagContent, match, rest = '', unary = '';
        var startTag = html.substring(0, closingIndex + 1);
        var isUnary = startTag[startTag.length - 2] === '/';
        var spaceIndex = startTag.search(space);
        if (isUnary) {
            unary = '/';
            tagContent = startTag.substring(1, startTag.length - 2).trim();
        } else {
            tagContent = startTag.substring(1, startTag.length - 1).trim();
        }
        if (spaceIndex === -1) {
            tagName = tagContent;
        } else {
            spaceIndex--;
            tagName = tagContent.substring(0, spaceIndex);
            rest = tagContent.substring(spaceIndex);
        }
        match = [
            startTag,
            tagName,
            rest,
            unary
        ];
        return {
            match: match,
            html: html.substring(startTag.length)
        };
    };
    module.exports = namespace.HTMLParser = HTMLParser;
});
/*can-vdom@4.0.0#make-parser/make-parser*/
define('can-vdom@4.0.0#make-parser/make-parser', [
    'require',
    'exports',
    'module',
    'can-view-parser',
    'can-simple-dom'
], function (require, exports, module) {
    var canParser = require('can-view-parser');
    var simpleDOM = require('can-simple-dom');
    module.exports = function (document) {
        return new simpleDOM.HTMLParser(function (string) {
            var tokens = [];
            var currentTag, currentAttr;
            canParser(string, {
                start: function (tagName, unary) {
                    currentTag = {
                        type: 'StartTag',
                        attributes: [],
                        tagName: tagName
                    };
                },
                end: function (tagName, unary) {
                    tokens.push(currentTag);
                    currentTag = undefined;
                },
                close: function (tagName) {
                    tokens.push({
                        type: 'EndTag',
                        tagName: tagName
                    });
                },
                attrStart: function (attrName) {
                    currentAttr = [
                        attrName,
                        ''
                    ];
                    currentTag.attributes.push(currentAttr);
                },
                attrEnd: function (attrName) {
                },
                attrValue: function (value) {
                    currentAttr[1] += value;
                },
                chars: function (value) {
                    tokens.push({
                        type: 'Chars',
                        chars: value
                    });
                },
                comment: function (value) {
                    tokens.push({
                        type: 'Comment',
                        chars: value
                    });
                },
                special: function (value) {
                },
                done: function () {
                }
            });
            return tokens;
        }, document, simpleDOM.voidMap);
    };
});
/*can-vdom@4.0.0#make-document/make-document*/
define('can-vdom@4.0.0#make-document/make-document', [
    'require',
    'exports',
    'module',
    'can-simple-dom',
    '../make-parser/make-parser'
], function (require, exports, module) {
    var simpleDOM = require('can-simple-dom');
    var makeParser = require('../make-parser/make-parser');
    function CanSimpleDocument() {
        simpleDOM.Document.apply(this, arguments);
        var serializer = new simpleDOM.HTMLSerializer(simpleDOM.voidMap);
        var parser = makeParser(this);
        this.__addSerializerAndParser(serializer, parser);
    }
    CanSimpleDocument.prototype = new simpleDOM.Document();
    CanSimpleDocument.prototype.constructor = CanSimpleDocument;
    module.exports = function () {
        return new CanSimpleDocument();
    };
});
/*can-dom-mutate@1.0.2#-util*/
define('can-dom-mutate@1.0.2#-util', [
    'require',
    'exports',
    'module',
    'can-globals/document/document'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        var getDocument = require('can-globals/document/document');
        var push = Array.prototype.push;
        function eliminate(array, item) {
            var index = array.indexOf(item);
            if (index >= 0) {
                array.splice(index, 1);
            }
        }
        function isInDocument(node) {
            var root = getDocument().documentElement;
            if (root === node) {
                return true;
            }
            return root.contains(node);
        }
        function isDocumentElement(node) {
            return getDocument().documentElement === node;
        }
        function isFragment(node) {
            return !!(node && node.nodeType === 11);
        }
        function getChildren(parentNode) {
            var nodes = [];
            var node = parentNode.firstChild;
            while (node) {
                nodes.push(node);
                node = node.nextSibling;
            }
            return nodes;
        }
        function getParents(node) {
            var nodes;
            if (isFragment(node)) {
                nodes = getChildren(node);
            } else {
                nodes = [node];
            }
            return nodes;
        }
        function getAllNodes(node) {
            var nodes = getParents(node);
            var cLen = nodes.length;
            for (var c = 0; c < cLen; c++) {
                var element = nodes[c];
                if (element.getElementsByTagName) {
                    var descendants = element.getElementsByTagName('*');
                    push.apply(nodes, descendants);
                }
            }
            return nodes;
        }
        function subscription(fn) {
            return function _subscription() {
                var disposal = fn.apply(this, arguments);
                var isDisposed = false;
                return function _disposal() {
                    if (isDisposed) {
                        var fnName = fn.name || fn.displayName || 'an anonymous function';
                        var message = 'Disposal function returned by ' + fnName + ' called more than once.';
                        throw new Error(message);
                    }
                    disposal.apply(this, arguments);
                    isDisposed = true;
                };
            };
        }
        module.exports = {
            eliminate: eliminate,
            isInDocument: isInDocument,
            getDocument: getDocument,
            isDocumentElement: isDocumentElement,
            isFragment: isFragment,
            getParents: getParents,
            getAllNodes: getAllNodes,
            getChildren: getChildren,
            subscription: subscription
        };
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-dom-mutate@1.0.2#can-dom-mutate*/
define('can-dom-mutate@1.0.2#can-dom-mutate', [
    'require',
    'exports',
    'module',
    'can-globals',
    'can-globals/global/global',
    'can-globals/mutation-observer/mutation-observer',
    './-util'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        'use strict';
        var globals = require('can-globals');
        var getRoot = require('can-globals/global/global');
        var getMutationObserver = require('can-globals/mutation-observer/mutation-observer');
        var setImmediate = getRoot().setImmediate || function (cb) {
            return setTimeout(cb, 0);
        };
        var util = require('./-util');
        var getDocument = util.getDocument;
        var eliminate = util.eliminate;
        var subscription = util.subscription;
        var isDocumentElement = util.isDocumentElement;
        var getAllNodes = util.getAllNodes;
        var push = Array.prototype.push;
        var slice = Array.prototype.slice;
        var domMutate;
        var dataStore = new WeakMap();
        function getRelatedData(node, key) {
            var data = dataStore.get(node);
            if (data) {
                return data[key];
            }
        }
        function setRelatedData(node, key, targetListenersMap) {
            var data = dataStore.get(node) || dataStore.set(node, {}).get(node);
            data[key] = targetListenersMap;
        }
        function deleteRelatedData(node, key) {
            var data = dataStore.get(node);
            return delete data[key];
        }
        function batch(processBatchItems, shouldDeduplicate) {
            var waitingBatch = [];
            var waitingCalls = [];
            var dispatchSet = new Set();
            var isPrimed = false;
            return function batchAdd(items, callback) {
                if (shouldDeduplicate) {
                    for (var i = 0; i < items.length; i++) {
                        var item = items[i];
                        var target = item.target;
                        if (!dispatchSet.has(target)) {
                            waitingBatch.push(item);
                            dispatchSet.add(target);
                        }
                    }
                } else {
                    push.apply(waitingBatch, items);
                }
                if (callback) {
                    waitingCalls.push(callback);
                }
                var shouldPrime = !isPrimed && waitingBatch.length > 0;
                if (shouldPrime) {
                    isPrimed = true;
                    setImmediate(function processBatch() {
                        var currentBatch = waitingBatch;
                        waitingBatch = [];
                        var currentCalls = waitingCalls;
                        waitingCalls = [];
                        if (shouldDeduplicate) {
                            dispatchSet = new Set();
                        }
                        isPrimed = false;
                        processBatchItems(currentBatch);
                        var callCount = currentCalls.length;
                        for (var c = 0; c < callCount; c++) {
                            currentCalls[c]();
                        }
                    });
                }
            };
        }
        function getDocumentListeners(target, key) {
            var doc = getDocument();
            var data = getRelatedData(doc, key);
            if (data) {
                return data.listeners;
            }
        }
        function getTargetListeners(target, key) {
            var doc = getDocument();
            var targetListenersMap = getRelatedData(doc, key);
            if (!targetListenersMap) {
                return;
            }
            return targetListenersMap.get(target);
        }
        function addTargetListener(target, key, listener) {
            var doc = getDocument();
            var targetListenersMap = getRelatedData(doc, key);
            if (!targetListenersMap) {
                targetListenersMap = new Map();
                setRelatedData(doc, key, targetListenersMap);
            }
            var targetListeners = targetListenersMap.get(target);
            if (!targetListeners) {
                targetListeners = [];
                targetListenersMap.set(target, targetListeners);
            }
            targetListeners.push(listener);
        }
        function removeTargetListener(target, key, listener) {
            var doc = getDocument();
            var targetListenersMap = getRelatedData(doc, key);
            if (!targetListenersMap) {
                return;
            }
            var targetListeners = targetListenersMap.get(target);
            if (!targetListeners) {
                return;
            }
            eliminate(targetListeners, listener);
            if (targetListeners.length === 0) {
                targetListenersMap['delete'](target);
                if (targetListenersMap.size === 0) {
                    deleteRelatedData(doc, key);
                }
            }
        }
        function fire(callbacks, arg) {
            var safeCallbacks = slice.call(callbacks, 0);
            var safeCallbackCount = safeCallbacks.length;
            for (var i = 0; i < safeCallbackCount; i++) {
                safeCallbacks[i](arg);
            }
        }
        function dispatch(listenerKey, documentDataKey) {
            return function dispatchEvents(events) {
                for (var e = 0; e < events.length; e++) {
                    var event = events[e];
                    var target = event.target;
                    var targetListeners = getTargetListeners(target, listenerKey);
                    if (targetListeners) {
                        fire(targetListeners, event);
                    }
                    if (!documentDataKey) {
                        continue;
                    }
                    var documentListeners = getDocumentListeners(target, documentDataKey);
                    if (documentListeners) {
                        fire(documentListeners, event);
                    }
                }
            };
        }
        function observeMutations(target, observerKey, config, handler) {
            var observerData = getRelatedData(target, observerKey);
            if (!observerData) {
                observerData = { observingCount: 0 };
                setRelatedData(target, observerKey, observerData);
            }
            var setupObserver = function () {
                var MutationObserver = getMutationObserver();
                if (MutationObserver) {
                    var Node = getRoot().Node;
                    var isRealNode = !!(Node && target instanceof Node);
                    if (isRealNode) {
                        var targetObserver = new MutationObserver(handler);
                        targetObserver.observe(target, config);
                        observerData.observer = targetObserver;
                    }
                } else {
                    if (observerData.observer) {
                        observerData.observer.disconnect();
                        observerData.observer = null;
                    }
                }
            };
            if (observerData.observingCount === 0) {
                globals.onKeyValue('MutationObserver', setupObserver);
                setupObserver();
            }
            observerData.observingCount++;
            return function stopObservingMutations() {
                var observerData = getRelatedData(target, observerKey);
                if (observerData) {
                    observerData.observingCount--;
                    if (observerData.observingCount <= 0) {
                        if (observerData.observer) {
                            observerData.observer.disconnect();
                        }
                        deleteRelatedData(target, observerKey);
                        globals.offKeyValue('MutationObserver', setupObserver);
                    }
                }
            };
        }
        function handleTreeMutations(mutations) {
            var mutationCount = mutations.length;
            for (var m = 0; m < mutationCount; m++) {
                var mutation = mutations[m];
                var addedNodes = mutation.addedNodes;
                var addedCount = addedNodes.length;
                for (var a = 0; a < addedCount; a++) {
                    domMutate.dispatchNodeInsertion(addedNodes[a]);
                }
                var removedNodes = mutation.removedNodes;
                var removedCount = removedNodes.length;
                for (var r = 0; r < removedCount; r++) {
                    domMutate.dispatchNodeRemoval(removedNodes[r]);
                }
            }
        }
        function handleAttributeMutations(mutations) {
            var mutationCount = mutations.length;
            for (var m = 0; m < mutationCount; m++) {
                var mutation = mutations[m];
                if (mutation.type === 'attributes') {
                    var node = mutation.target;
                    var attributeName = mutation.attributeName;
                    var oldValue = mutation.oldValue;
                    domMutate.dispatchNodeAttributeChange(node, attributeName, oldValue);
                }
            }
        }
        var treeMutationConfig = {
            subtree: true,
            childList: true
        };
        var attributeMutationConfig = {
            attributes: true,
            attributeOldValue: true
        };
        function addNodeListener(listenerKey, observerKey, isAttributes) {
            return subscription(function _addNodeListener(target, listener) {
                var stopObserving;
                if (isAttributes) {
                    stopObserving = observeMutations(target, observerKey, attributeMutationConfig, handleAttributeMutations);
                } else {
                    stopObserving = observeMutations(getDocument(), observerKey, treeMutationConfig, handleTreeMutations);
                }
                addTargetListener(target, listenerKey, listener);
                return function removeNodeListener() {
                    stopObserving();
                    removeTargetListener(target, listenerKey, listener);
                };
            });
        }
        function addGlobalListener(globalDataKey, addNodeListener) {
            return subscription(function addGlobalGroupListener(documentElement, listener) {
                if (!isDocumentElement(documentElement)) {
                    throw new Error('Global mutation listeners must pass a documentElement');
                }
                var doc = getDocument();
                var documentData = getRelatedData(doc, globalDataKey);
                if (!documentData) {
                    documentData = { listeners: [] };
                    setRelatedData(doc, globalDataKey, documentData);
                }
                var listeners = documentData.listeners;
                if (listeners.length === 0) {
                    documentData.removeListener = addNodeListener(doc, function () {
                    });
                }
                listeners.push(listener);
                return function removeGlobalGroupListener() {
                    var documentData = getRelatedData(doc, globalDataKey);
                    if (!documentData) {
                        return;
                    }
                    var listeners = documentData.listeners;
                    eliminate(listeners, listener);
                    if (listeners.length === 0) {
                        documentData.removeListener();
                        deleteRelatedData(doc, globalDataKey);
                    }
                };
            });
        }
        function toMutationEvents(nodes) {
            var events = [];
            for (var i = 0; i < nodes.length; i++) {
                events.push({ target: nodes[i] });
            }
            return events;
        }
        var domMutationPrefix = 'domMutation';
        var insertionDataKey = domMutationPrefix + 'InsertionData';
        var removalDataKey = domMutationPrefix + 'RemovalData';
        var attributeChangeDataKey = domMutationPrefix + 'AttributeChangeData';
        var documentInsertionDataKey = domMutationPrefix + 'DocumentInsertionData';
        var documentRemovalDataKey = domMutationPrefix + 'DocumentRemovalData';
        var documentAttributeChangeDataKey = domMutationPrefix + 'DocumentAttributeChangeData';
        var treeDataKey = domMutationPrefix + 'TreeData';
        var attributeDataKey = domMutationPrefix + 'AttributeData';
        var dispatchInsertion = batch(dispatch(insertionDataKey, documentInsertionDataKey), true);
        var dispatchRemoval = batch(dispatch(removalDataKey, documentRemovalDataKey), true);
        var dispatchAttributeChange = batch(dispatch(attributeChangeDataKey, documentAttributeChangeDataKey));
        var addNodeInsertionListener = addNodeListener(insertionDataKey, treeDataKey);
        var addNodeRemovalListener = addNodeListener(removalDataKey, treeDataKey);
        var addNodeAttributeChangeListener = addNodeListener(attributeChangeDataKey, attributeDataKey, true);
        var addInsertionListener = addGlobalListener(documentInsertionDataKey, addNodeInsertionListener);
        var addRemovalListener = addGlobalListener(documentRemovalDataKey, addNodeRemovalListener);
        var addAttributeChangeListener = addGlobalListener(documentAttributeChangeDataKey, addNodeAttributeChangeListener);
        domMutate = {
            dispatchNodeInsertion: function (node, callback) {
                var events = toMutationEvents(getAllNodes(node));
                dispatchInsertion(events, callback);
            },
            dispatchNodeRemoval: function (node, callback) {
                var events = toMutationEvents(getAllNodes(node));
                dispatchRemoval(events, callback);
            },
            dispatchNodeAttributeChange: function (target, attributeName, oldValue, callback) {
                dispatchAttributeChange([{
                        target: target,
                        attributeName: attributeName,
                        oldValue: oldValue
                    }], callback);
            },
            onNodeInsertion: addNodeInsertionListener,
            onNodeRemoval: addNodeRemovalListener,
            onNodeAttributeChange: addNodeAttributeChangeListener,
            onRemoval: addRemovalListener,
            onInsertion: addInsertionListener,
            onAttributeChange: addAttributeChangeListener
        };
        module.exports = domMutate;
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-dom-mutate@1.0.2#node*/
define('can-dom-mutate@1.0.2#node', [
    'require',
    'exports',
    'module',
    'can-globals',
    './can-dom-mutate',
    './-util'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        'use strict';
        var globals = require('can-globals');
        var domMutate = require('./can-dom-mutate');
        var util = require('./-util');
        var isInDocument = util.isInDocument;
        var getParents = util.getParents;
        var synthetic = {
            dispatchNodeInsertion: function (container, node) {
                if (isInDocument(node)) {
                    domMutate.dispatchNodeInsertion(node);
                }
            },
            dispatchNodeRemoval: function (container, node) {
                if (isInDocument(container) && !isInDocument(node)) {
                    domMutate.dispatchNodeRemoval(node);
                }
            }
        };
        var compat = {
            replaceChild: function (newChild, oldChild) {
                var newChildren = getParents(newChild);
                var result = this.replaceChild(newChild, oldChild);
                synthetic.dispatchNodeRemoval(this, oldChild);
                for (var i = 0; i < newChildren.length; i++) {
                    synthetic.dispatchNodeInsertion(this, newChildren[i]);
                }
                return result;
            },
            setAttribute: function (name, value) {
                var oldAttributeValue = this.getAttribute(name);
                var result = this.setAttribute(name, value);
                var newAttributeValue = this.getAttribute(name);
                if (oldAttributeValue !== newAttributeValue) {
                    domMutate.dispatchNodeAttributeChange(this, name, oldAttributeValue);
                }
                return result;
            },
            removeAttribute: function (name) {
                var oldAttributeValue = this.getAttribute(name);
                var result = this.removeAttribute(name);
                if (oldAttributeValue) {
                    domMutate.dispatchNodeAttributeChange(this, name, oldAttributeValue);
                }
                return result;
            }
        };
        var compatData = [
            [
                'appendChild',
                'Insertion'
            ],
            [
                'insertBefore',
                'Insertion'
            ],
            [
                'removeChild',
                'Removal'
            ]
        ];
        compatData.forEach(function (pair) {
            var nodeMethod = pair[0];
            var dispatchMethod = 'dispatchNode' + pair[1];
            compat[nodeMethod] = function (node) {
                var nodes = getParents(node);
                var result = this[nodeMethod].apply(this, arguments);
                for (var i = 0; i < nodes.length; i++) {
                    synthetic[dispatchMethod](this, nodes[i]);
                }
                return result;
            };
        });
        var normal = {};
        var nodeMethods = [
            'appendChild',
            'insertBefore',
            'removeChild',
            'replaceChild',
            'setAttribute',
            'removeAttribute'
        ];
        nodeMethods.forEach(function (methodName) {
            normal[methodName] = function () {
                return this[methodName].apply(this, arguments);
            };
        });
        var mutate = {};
        function setMutateStrategy(observer) {
            var strategy = observer ? normal : compat;
            for (var key in strategy) {
                mutate[key] = strategy[key];
            }
        }
        var mutationObserverKey = 'MutationObserver';
        setMutateStrategy(globals.getKeyValue(mutationObserverKey));
        globals.onKeyValue(mutationObserverKey, setMutateStrategy);
        module.exports = mutate;
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-component@4.0.1#test/helpers*/
define('can-component@4.0.1#test/helpers', [
    'require',
    'exports',
    'module',
    'can-util/dom/mutation-observer/mutation-observer',
    'can-util/dom/document/document',
    'can-vdom/make-document/make-document',
    'can-dom-mutate',
    'can-dom-mutate/node',
    'can-globals'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        var MUTATION_OBSERVER = require('can-util/dom/mutation-observer/mutation-observer');
        var DOCUMENT = require('can-util/dom/document/document');
        var makeDocument = require('can-vdom/make-document/make-document');
        var domMutate = require('can-dom-mutate');
        var domMutateNode = require('can-dom-mutate/node');
        var globals = require('can-globals');
        var helpers = {
            runTasks: function (tasks) {
                var nextTask = function () {
                    var next = tasks.shift();
                    next();
                    if (tasks.length) {
                        setTimeout(nextTask, 100);
                    } else {
                        start();
                    }
                };
                setTimeout(nextTask, 100);
            },
            makeTest: function (name, doc, mutObs, test, qUnitTest) {
                var DOC = DOCUMENT();
                var MUT_OBS = MUTATION_OBSERVER();
                QUnit.module(name, {
                    setup: function () {
                        DOCUMENT(doc);
                        MUTATION_OBSERVER(mutObs);
                        if (doc) {
                            this.document = doc;
                            this.fixture = doc.createElement('div');
                            doc.body.appendChild(this.fixture);
                        } else {
                            this.fixture = doc.getElementById('qunit-fixture');
                        }
                    },
                    teardown: function () {
                        doc.body.removeChild(this.fixture);
                        stop();
                        setTimeout(function () {
                            start();
                            DOCUMENT(DOC);
                            MUTATION_OBSERVER(MUT_OBS);
                        }, 100);
                    }
                });
                test(doc, qUnitTest);
            },
            makeTests: function (name, test) {
                helpers.makeTest(name + ' - dom', document, MUTATION_OBSERVER(), test, QUnit.test);
                helpers.makeTest(name + ' - vdom', makeDocument(), null, test, function () {
                });
            },
            afterMutation: function (cb) {
                var doc = globals.getKeyValue('document');
                var div = doc.createElement('div');
                var insertionDisposal = domMutate.onNodeInsertion(div, function () {
                    insertionDisposal();
                    doc.body.removeChild(div);
                    setTimeout(cb, 5);
                });
                setTimeout(function () {
                    domMutateNode.appendChild.call(doc.body, div);
                }, 10);
            }
        };
        module.exports = helpers;
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-assign@1.1.1#can-assign*/
define('can-assign@1.1.1#can-assign', function (require, exports, module) {
    module.exports = function (d, s) {
        for (var prop in s) {
            d[prop] = s[prop];
        }
        return d;
    };
});
/*can-util@3.11.2#js/assign/assign*/
define('can-util@3.11.2#js/assign/assign', [
    'require',
    'exports',
    'module',
    'can-assign'
], function (require, exports, module) {
    'use strict';
    module.exports = require('can-assign');
});
/*can-util@3.11.2#js/is-function/is-function*/
define('can-util@3.11.2#js/is-function/is-function', function (require, exports, module) {
    'use strict';
    var isFunction = function () {
        if (typeof document !== 'undefined' && typeof document.getElementsByTagName('body') === 'function') {
            return function (value) {
                return Object.prototype.toString.call(value) === '[object Function]';
            };
        }
        return function (value) {
            return typeof value === 'function';
        };
    }();
    module.exports = isFunction;
});
/*can-util@3.11.2#js/is-plain-object/is-plain-object*/
define('can-util@3.11.2#js/is-plain-object/is-plain-object', function (require, exports, module) {
    'use strict';
    var core_hasOwn = Object.prototype.hasOwnProperty;
    function isWindow(obj) {
        return obj !== null && obj == obj.window;
    }
    function isPlainObject(obj) {
        if (!obj || typeof obj !== 'object' || obj.nodeType || isWindow(obj) || obj.constructor && obj.constructor.shortName) {
            return false;
        }
        try {
            if (obj.constructor && !core_hasOwn.call(obj, 'constructor') && !core_hasOwn.call(obj.constructor.prototype, 'isPrototypeOf')) {
                return false;
            }
        } catch (e) {
            return false;
        }
        var key;
        for (key in obj) {
        }
        return key === undefined || core_hasOwn.call(obj, key);
    }
    module.exports = isPlainObject;
});
/*can-util@3.11.2#js/deep-assign/deep-assign*/
define('can-util@3.11.2#js/deep-assign/deep-assign', [
    'require',
    'exports',
    'module',
    '../is-function/is-function',
    '../is-plain-object/is-plain-object'
], function (require, exports, module) {
    'use strict';
    var isFunction = require('../is-function/is-function');
    var isPlainObject = require('../is-plain-object/is-plain-object');
    function deepAssign() {
        var options, name, src, copy, copyIsArray, clone, target = arguments[0] || {}, i = 1, length = arguments.length;
        if (typeof target !== 'object' && !isFunction(target)) {
            target = {};
        }
        if (length === i) {
            target = this;
            --i;
        }
        for (; i < length; i++) {
            if ((options = arguments[i]) != null) {
                for (name in options) {
                    src = target[name];
                    copy = options[name];
                    if (target === copy) {
                        continue;
                    }
                    if (copy && (isPlainObject(copy) || (copyIsArray = Array.isArray(copy)))) {
                        if (copyIsArray) {
                            copyIsArray = false;
                            clone = src && Array.isArray(src) ? src : [];
                        } else {
                            clone = src && isPlainObject(src) ? src : {};
                        }
                        target[name] = deepAssign(clone, copy);
                    } else if (copy !== undefined) {
                        target[name] = copy;
                    }
                }
            }
        }
        return target;
    }
    module.exports = deepAssign;
});
/*can-util@3.11.2#js/dev/dev*/
define('can-util@3.11.2#js/dev/dev', [
    'require',
    'exports',
    'module',
    'can-log/dev/dev'
], function (require, exports, module) {
    'use strict';
    module.exports = require('can-log/dev/dev');
});
/*can-util@3.11.2#js/is-array-like/is-array-like*/
define('can-util@3.11.2#js/is-array-like/is-array-like', function (require, exports, module) {
    'use strict';
    function isArrayLike(obj) {
        var type = typeof obj;
        if (type === 'string') {
            return true;
        } else if (type === 'number') {
            return false;
        }
        var length = obj && type !== 'boolean' && typeof obj !== 'number' && 'length' in obj && obj.length;
        return typeof obj !== 'function' && (length === 0 || typeof length === 'number' && length > 0 && length - 1 in obj);
    }
    module.exports = isArrayLike;
});
/*can-util@3.11.2#js/is-iterable/is-iterable*/
define('can-util@3.11.2#js/is-iterable/is-iterable', [
    'require',
    'exports',
    'module',
    'can-symbol'
], function (require, exports, module) {
    'use strict';
    var canSymbol = require('can-symbol');
    module.exports = function (obj) {
        return obj && !!obj[canSymbol.iterator || canSymbol.for('iterator')];
    };
});
/*can-util@3.11.2#js/each/each*/
define('can-util@3.11.2#js/each/each', [
    'require',
    'exports',
    'module',
    '../is-array-like/is-array-like',
    '../is-iterable/is-iterable',
    'can-symbol'
], function (require, exports, module) {
    'use strict';
    var isArrayLike = require('../is-array-like/is-array-like');
    var has = Object.prototype.hasOwnProperty;
    var isIterable = require('../is-iterable/is-iterable');
    var canSymbol = require('can-symbol');
    function each(elements, callback, context) {
        var i = 0, key, len, item;
        if (elements) {
            if (isArrayLike(elements)) {
                for (len = elements.length; i < len; i++) {
                    item = elements[i];
                    if (callback.call(context || item, item, i, elements) === false) {
                        break;
                    }
                }
            } else if (isIterable(elements)) {
                var iter = elements[canSymbol.iterator || canSymbol.for('iterator')]();
                var res, value;
                while (!(res = iter.next()).done) {
                    value = res.value;
                    callback.call(context || elements, Array.isArray(value) ? value[1] : value, value[0]);
                }
            } else if (typeof elements === 'object') {
                for (key in elements) {
                    if (has.call(elements, key) && callback.call(context || elements[key], elements[key], key, elements) === false) {
                        break;
                    }
                }
            }
        }
        return elements;
    }
    module.exports = each;
});
/*can-util@3.11.2#js/make-array/make-array*/
define('can-util@3.11.2#js/make-array/make-array', [
    'require',
    'exports',
    'module',
    '../each/each',
    '../is-array-like/is-array-like'
], function (require, exports, module) {
    'use strict';
    var each = require('../each/each');
    var isArrayLike = require('../is-array-like/is-array-like');
    function makeArray(element) {
        var ret = [];
        if (isArrayLike(element)) {
            each(element, function (a, i) {
                ret[i] = a;
            });
        } else if (element === 0 || element) {
            ret.push(element);
        }
        return ret;
    }
    module.exports = makeArray;
});
/*can-util@3.11.2#js/is-container/is-container*/
define('can-util@3.11.2#js/is-container/is-container', function (require, exports, module) {
    'use strict';
    module.exports = function (current) {
        return /^f|^o/.test(typeof current);
    };
});
/*can-util@3.11.2#js/get/get*/
define('can-util@3.11.2#js/get/get', [
    'require',
    'exports',
    'module',
    '../is-container/is-container'
], function (require, exports, module) {
    'use strict';
    var isContainer = require('../is-container/is-container');
    function get(obj, name) {
        var parts = typeof name !== 'undefined' ? (name + '').replace(/\[/g, '.').replace(/]/g, '').split('.') : [], length = parts.length, current, i, container;
        if (!length) {
            return obj;
        }
        current = obj;
        for (i = 0; i < length && isContainer(current); i++) {
            container = current;
            current = container[parts[i]];
        }
        return current;
    }
    module.exports = get;
});
/*can-util@3.11.2#js/is-array/is-array*/
define('can-util@3.11.2#js/is-array/is-array', [
    'require',
    'exports',
    'module',
    'can-log/dev/dev'
], function (require, exports, module) {
    'use strict';
    var dev = require('can-log/dev/dev');
    var hasWarned = false;
    module.exports = function (arr) {
        return Array.isArray(arr);
    };
});
/*can-util@3.11.2#js/string/string*/
define('can-util@3.11.2#js/string/string', [
    'require',
    'exports',
    'module',
    '../get/get',
    '../is-container/is-container',
    'can-log/dev/dev',
    '../is-array/is-array'
], function (require, exports, module) {
    'use strict';
    var get = require('../get/get');
    var isContainer = require('../is-container/is-container');
    var canDev = require('can-log/dev/dev');
    var isArray = require('../is-array/is-array');
    var strUndHash = /_|-/, strColons = /\=\=/, strWords = /([A-Z]+)([A-Z][a-z])/g, strLowUp = /([a-z\d])([A-Z])/g, strDash = /([a-z\d])([A-Z])/g, strReplacer = /\{([^\}]+)\}/g, strQuote = /"/g, strSingleQuote = /'/g, strHyphenMatch = /-+(.)?/g, strCamelMatch = /[a-z][A-Z]/g, convertBadValues = function (content) {
            var isInvalid = content === null || content === undefined || isNaN(content) && '' + content === 'NaN';
            return '' + (isInvalid ? '' : content);
        }, deleteAtPath = function (data, path) {
            var parts = path ? path.replace(/\[/g, '.').replace(/]/g, '').split('.') : [];
            var current = data;
            for (var i = 0; i < parts.length - 1; i++) {
                if (current) {
                    current = current[parts[i]];
                }
            }
            if (current) {
                delete current[parts[parts.length - 1]];
            }
        };
    var string = {
        esc: function (content) {
            return convertBadValues(content).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(strQuote, '&#34;').replace(strSingleQuote, '&#39;');
        },
        getObject: function (name, roots) {
            roots = isArray(roots) ? roots : [roots || window];
            var result, l = roots.length;
            for (var i = 0; i < l; i++) {
                result = get(roots[i], name);
                if (result) {
                    return result;
                }
            }
        },
        capitalize: function (s, cache) {
            return s.charAt(0).toUpperCase() + s.slice(1);
        },
        camelize: function (str) {
            return convertBadValues(str).replace(strHyphenMatch, function (match, chr) {
                return chr ? chr.toUpperCase() : '';
            });
        },
        hyphenate: function (str) {
            return convertBadValues(str).replace(strCamelMatch, function (str, offset) {
                return str.charAt(0) + '-' + str.charAt(1).toLowerCase();
            });
        },
        underscore: function (s) {
            return s.replace(strColons, '/').replace(strWords, '$1_$2').replace(strLowUp, '$1_$2').replace(strDash, '_').toLowerCase();
        },
        sub: function (str, data, remove) {
            var obs = [];
            str = str || '';
            obs.push(str.replace(strReplacer, function (whole, inside) {
                var ob = get(data, inside);
                if (remove === true) {
                    deleteAtPath(data, inside);
                }
                if (ob === undefined || ob === null) {
                    obs = null;
                    return '';
                }
                if (isContainer(ob) && obs) {
                    obs.push(ob);
                    return '';
                }
                return '' + ob;
            }));
            return obs === null ? obs : obs.length <= 1 ? obs[0] : obs;
        },
        replaceWith: function (str, data, replacer, shouldRemoveMatchedPaths) {
            return str.replace(strReplacer, function (whole, path) {
                var value = get(data, path);
                if (shouldRemoveMatchedPaths) {
                    deleteAtPath(data, path);
                }
                return replacer(path, value);
            });
        },
        replacer: strReplacer,
        undHash: strUndHash
    };
    module.exports = string;
});
/*can-construct@3.3.0#can-construct*/
define('can-construct@3.3.0#can-construct', [
    'require',
    'exports',
    'module',
    'can-util/js/assign/assign',
    'can-util/js/deep-assign/deep-assign',
    'can-util/js/dev/dev',
    'can-util/js/make-array/make-array',
    'can-namespace'
], function (require, exports, module) {
    'use strict';
    var assign = require('can-util/js/assign/assign');
    var deepAssign = require('can-util/js/deep-assign/deep-assign');
    var dev = require('can-util/js/dev/dev');
    var makeArray = require('can-util/js/make-array/make-array');
    var namespace = require('can-namespace');
    var initializing = 0;
    var Construct = function () {
        if (arguments.length) {
            return Construct.extend.apply(Construct, arguments);
        }
    };
    var canGetDescriptor;
    try {
        Object.getOwnPropertyDescriptor({});
        canGetDescriptor = true;
    } catch (e) {
        canGetDescriptor = false;
    }
    var getDescriptor = function (newProps, name) {
            var descriptor = Object.getOwnPropertyDescriptor(newProps, name);
            if (descriptor && (descriptor.get || descriptor.set)) {
                return descriptor;
            }
            return null;
        }, inheritGetterSetter = function (newProps, oldProps, addTo) {
            addTo = addTo || newProps;
            var descriptor;
            for (var name in newProps) {
                if (descriptor = getDescriptor(newProps, name)) {
                    this._defineProperty(addTo, oldProps, name, descriptor);
                } else {
                    Construct._overwrite(addTo, oldProps, name, newProps[name]);
                }
            }
        }, simpleInherit = function (newProps, oldProps, addTo) {
            addTo = addTo || newProps;
            for (var name in newProps) {
                Construct._overwrite(addTo, oldProps, name, newProps[name]);
            }
        };
    assign(Construct, {
        constructorExtends: true,
        newInstance: function () {
            var inst = this.instance(), args;
            if (inst.setup) {
                Object.defineProperty(inst, '__inSetup', {
                    configurable: true,
                    enumerable: false,
                    value: true,
                    writable: true
                });
                args = inst.setup.apply(inst, arguments);
                if (args instanceof Construct.ReturnValue) {
                    return args.value;
                }
                inst.__inSetup = false;
            }
            if (inst.init) {
                inst.init.apply(inst, args || arguments);
            }
            return inst;
        },
        _inherit: canGetDescriptor ? inheritGetterSetter : simpleInherit,
        _defineProperty: function (what, oldProps, propName, descriptor) {
            Object.defineProperty(what, propName, descriptor);
        },
        _overwrite: function (what, oldProps, propName, val) {
            Object.defineProperty(what, propName, {
                value: val,
                configurable: true,
                enumerable: true,
                writable: true
            });
        },
        setup: function (base) {
            this.defaults = deepAssign(true, {}, base.defaults, this.defaults);
        },
        instance: function () {
            initializing = 1;
            var inst = new this();
            initializing = 0;
            return inst;
        },
        extend: function (name, staticProperties, instanceProperties) {
            var shortName = name, klass = staticProperties, proto = instanceProperties;
            if (typeof shortName !== 'string') {
                proto = klass;
                klass = shortName;
                shortName = null;
            }
            if (!proto) {
                proto = klass;
                klass = null;
            }
            proto = proto || {};
            var _super_class = this, _super = this.prototype, Constructor, prototype;
            prototype = this.instance();
            Construct._inherit(proto, _super, prototype);
            if (shortName) {
            } else if (klass && klass.shortName) {
                shortName = klass.shortName;
            } else if (this.shortName) {
                shortName = this.shortName;
            }
            function init() {
                if (!initializing) {
                    return (!this || this.constructor !== Constructor) && arguments.length && Constructor.constructorExtends ? Constructor.extend.apply(Constructor, arguments) : Constructor.newInstance.apply(Constructor, arguments);
                }
            }
            Constructor = typeof namedCtor === 'function' ? namedCtor(constructorName, init) : function () {
                return init.apply(this, arguments);
            };
            for (var propName in _super_class) {
                if (_super_class.hasOwnProperty(propName)) {
                    Constructor[propName] = _super_class[propName];
                }
            }
            Construct._inherit(klass, _super_class, Constructor);
            assign(Constructor, {
                constructor: Constructor,
                prototype: prototype
            });
            if (shortName !== undefined) {
                if (Object.getOwnPropertyDescriptor) {
                    var desc = Object.getOwnPropertyDescriptor(Constructor, 'name');
                    if (!desc || desc.configurable) {
                        Object.defineProperty(Constructor, 'name', {
                            writable: true,
                            value: shortName,
                            configurable: true
                        });
                    }
                }
                Constructor.shortName = shortName;
            }
            Constructor.prototype.constructor = Constructor;
            var t = [_super_class].concat(makeArray(arguments)), args = Constructor.setup.apply(Constructor, t);
            if (Constructor.init) {
                Constructor.init.apply(Constructor, args || t);
            }
            return Constructor;
        },
        ReturnValue: function (value) {
            this.value = value;
        }
    });
    Construct.prototype.setup = function () {
    };
    Construct.prototype.init = function () {
    };
    module.exports = namespace.Construct = Construct;
});
/*can-queues@1.0.0#queue-state*/
define('can-queues@1.0.0#queue-state', function (require, exports, module) {
    module.exports = { lastTask: null };
});
/*can-queues@1.0.0#queue*/
define('can-queues@1.0.0#queue', [
    'require',
    'exports',
    'module',
    './queue-state',
    'can-log/dev/dev',
    'can-assign'
], function (require, exports, module) {
    var queueState = require('./queue-state');
    var canDev = require('can-log/dev/dev');
    var assign = require('can-assign');
    function noOperation() {
    }
    var Queue = function (name, callbacks) {
        this.callbacks = assign({
            onFirstTask: noOperation,
            onComplete: function () {
                queueState.lastTask = null;
            }
        }, callbacks || {});
        this.name = name;
        this.index = 0;
        this.tasks = [];
        this._log = false;
    };
    Queue.prototype.constructor = Queue;
    Queue.noop = noOperation;
    Queue.prototype.enqueue = function (fn, context, args, meta) {
        var len = this.tasks.push({
            fn: fn,
            context: context,
            args: args,
            meta: meta || {}
        });
        if (len === 1) {
            this.callbacks.onFirstTask(this);
        }
    };
    Queue.prototype.flush = function () {
        while (this.index < this.tasks.length) {
            var task = this.tasks[this.index++];
            task.fn.apply(task.context, task.args);
        }
        this.index = 0;
        this.tasks = [];
        this.callbacks.onComplete(this);
    };
    Queue.prototype.log = function () {
        this._log = arguments.length ? arguments[0] : true;
    };
    module.exports = Queue;
});
/*can-queues@1.0.0#priority-queue*/
define('can-queues@1.0.0#priority-queue', [
    'require',
    'exports',
    'module',
    './queue'
], function (require, exports, module) {
    var Queue = require('./queue');
    var PriorityQueue = function () {
        Queue.apply(this, arguments);
        this.taskMap = new Map();
        this.taskContainersByPriority = [];
        this.curPriorityIndex = Infinity;
        this.curPriorityMax = 0;
        this.isFlushing = false;
        this.tasksRemaining = 0;
    };
    PriorityQueue.prototype = Object.create(Queue.prototype);
    PriorityQueue.prototype.constructor = PriorityQueue;
    PriorityQueue.prototype.enqueue = function (fn, context, args, meta) {
        if (!this.taskMap.has(fn)) {
            this.tasksRemaining++;
            var isFirst = this.taskContainersByPriority.length === 0;
            var task = {
                fn: fn,
                context: context,
                args: args,
                meta: meta || {}
            };
            var taskContainer = this.getTaskContainerAndUpdateRange(task);
            taskContainer.tasks.push(task);
            this.taskMap.set(fn, task);
            if (isFirst) {
                this.callbacks.onFirstTask(this);
            }
        }
    };
    PriorityQueue.prototype.getTaskContainerAndUpdateRange = function (task) {
        var priority = task.meta.priority || 0;
        if (priority < this.curPriorityIndex) {
            this.curPriorityIndex = priority;
        }
        if (priority > this.curPriorityMax) {
            this.curPriorityMax = priority;
        }
        var tcByPriority = this.taskContainersByPriority;
        var taskContainer = tcByPriority[priority];
        if (!taskContainer) {
            taskContainer = tcByPriority[priority] = {
                tasks: [],
                index: 0
            };
        }
        return taskContainer;
    };
    PriorityQueue.prototype.flush = function () {
        if (this.isFlushing) {
            return;
        }
        this.isFlushing = true;
        while (true) {
            if (this.curPriorityIndex <= this.curPriorityMax) {
                var taskContainer = this.taskContainersByPriority[this.curPriorityIndex];
                if (taskContainer && taskContainer.tasks.length > taskContainer.index) {
                    var task = taskContainer.tasks[taskContainer.index++];
                    this.tasksRemaining--;
                    this.taskMap['delete'](task.fn);
                    task.fn.apply(task.context, task.args);
                } else {
                    this.curPriorityIndex++;
                }
            } else {
                this.taskMap = new Map();
                this.curPriorityIndex = Infinity;
                this.curPriorityMax = 0;
                this.taskContainersByPriority = [];
                this.isFlushing = false;
                this.callbacks.onComplete(this);
                return;
            }
        }
    };
    PriorityQueue.prototype.isEnqueued = function (fn) {
        return this.taskMap.has(fn);
    };
    PriorityQueue.prototype.flushQueuedTask = function (fn) {
        var task = this.dequeue(fn);
        if (task) {
            task.fn.apply(task.context, task.args);
        }
    };
    PriorityQueue.prototype.dequeue = function (fn) {
        var task = this.taskMap.get(fn);
        if (task) {
            var priority = task.meta.priority || 0;
            var taskContainer = this.taskContainersByPriority[priority];
            var index = taskContainer.tasks.indexOf(task, taskContainer.index);
            if (index >= 0) {
                taskContainer.tasks.splice(index, 1);
                this.tasksRemaining--;
                this.taskMap['delete'](task.fn);
                return task;
            } else {
                console.warn('Task', fn, 'has already run');
            }
        }
    };
    PriorityQueue.prototype.tasksRemainingCount = function () {
        return this.tasksRemaining;
    };
    module.exports = PriorityQueue;
});
/*can-queues@1.0.0#completion-queue*/
define('can-queues@1.0.0#completion-queue', [
    'require',
    'exports',
    'module',
    './queue'
], function (require, exports, module) {
    var Queue = require('./queue');
    var CompletionQueue = function () {
        Queue.apply(this, arguments);
        this.flushCount = 0;
    };
    CompletionQueue.prototype = Object.create(Queue.prototype);
    CompletionQueue.prototype.constructor = CompletionQueue;
    CompletionQueue.prototype.flush = function () {
        if (this.flushCount === 0) {
            this.flushCount++;
            while (this.index < this.tasks.length) {
                var task = this.tasks[this.index++];
                task.fn.apply(task.context, task.args);
            }
            this.index = 0;
            this.tasks = [];
            this.flushCount--;
            this.callbacks.onComplete(this);
        }
    };
    module.exports = CompletionQueue;
});
/*can-queues@1.0.0#can-queues*/
define('can-queues@1.0.0#can-queues', [
    'require',
    'exports',
    'module',
    'can-util/js/dev/dev',
    './queue',
    './priority-queue',
    './queue-state',
    './completion-queue',
    'can-namespace'
], function (require, exports, module) {
    var canDev = require('can-util/js/dev/dev');
    var Queue = require('./queue');
    var PriorityQueue = require('./priority-queue');
    var queueState = require('./queue-state');
    var CompletionQueue = require('./completion-queue');
    var ns = require('can-namespace');
    var batchStartCounter = 0;
    var addedTask = false;
    var isFlushing = false;
    var batchNum = 0;
    var batchData;
    var queueNames = [
        'notify',
        'derive',
        'domUI',
        'mutate'
    ];
    var NOTIFY_QUEUE, DERIVE_QUEUE, DOM_UI_QUEUE, MUTATE_QUEUE;
    NOTIFY_QUEUE = new Queue('NOTIFY', {
        onComplete: function () {
            DERIVE_QUEUE.flush();
        },
        onFirstTask: function () {
            if (!batchStartCounter) {
                NOTIFY_QUEUE.flush();
            } else {
                addedTask = true;
            }
        }
    });
    DERIVE_QUEUE = new PriorityQueue('DERIVE', {
        onComplete: function () {
            DOM_UI_QUEUE.flush();
        },
        onFirstTask: function () {
            addedTask = true;
        }
    });
    DOM_UI_QUEUE = new CompletionQueue('DOM_UI', {
        onComplete: function () {
            MUTATE_QUEUE.flush();
        },
        onFirstTask: function () {
            addedTask = true;
        }
    });
    MUTATE_QUEUE = new Queue('MUTATE', {
        onComplete: function () {
            queueState.lastTask = null;
            isFlushing = false;
        },
        onFirstTask: function () {
            addedTask = true;
        }
    });
    var queues = {
        Queue: Queue,
        PriorityQueue: PriorityQueue,
        CompletionQueue: CompletionQueue,
        notifyQueue: NOTIFY_QUEUE,
        deriveQueue: DERIVE_QUEUE,
        domUIQueue: DOM_UI_QUEUE,
        mutateQueue: MUTATE_QUEUE,
        batch: {
            start: function () {
                batchStartCounter++;
                if (batchStartCounter === 1) {
                    batchNum++;
                    batchData = { number: batchNum };
                }
            },
            stop: function () {
                batchStartCounter--;
                if (batchStartCounter === 0) {
                    if (addedTask) {
                        addedTask = false;
                        isFlushing = true;
                        NOTIFY_QUEUE.flush();
                    }
                }
            },
            isCollecting: function () {
                return batchStartCounter > 0;
            },
            number: function () {
                return batchNum;
            },
            data: function () {
                return batchData;
            }
        },
        enqueueByQueue: function enqueueByQueue(fnByQueue, context, args, makeMeta, reasonLog) {
            if (fnByQueue) {
                queues.batch.start();
                queueNames.forEach(function (queueName) {
                    var name = queueName + 'Queue';
                    var QUEUE = queues[name];
                    var tasks = fnByQueue[queueName];
                    if (tasks !== undefined) {
                        tasks.forEach(function (fn) {
                            var meta = makeMeta != null ? makeMeta(fn, context, args) : {};
                            meta.reasonLog = reasonLog;
                            QUEUE.enqueue(fn, context, args, meta);
                        });
                    }
                });
                queues.batch.stop();
            }
        },
        stack: function () {
            var current = queueState.lastTask;
            var stack = [];
            while (current) {
                stack.unshift(current);
                current = current.meta.parentTask;
            }
            return stack;
        },
        logStack: function () {
            var stack = this.stack();
            stack.forEach(function (task, i) {
                var meta = task.meta;
                if (i === 0 && meta && meta.reasonLog) {
                    canDev.log.apply(canDev, meta.reasonLog);
                }
                var log = meta && meta.log ? meta.log : [
                    task.fn.name,
                    task
                ];
                canDev.log.apply(canDev, [task.meta.stack.name + ' ran task:'].concat(log));
            });
        },
        taskCount: function () {
            console.warn('THIS IS NOT USED RIGHT?');
            return NOTIFY_QUEUE.tasks.length + DERIVE_QUEUE.tasks.length + DOM_UI_QUEUE.tasks.length + MUTATE_QUEUE.tasks.length;
        },
        flush: function () {
            NOTIFY_QUEUE.flush();
        },
        log: function () {
            NOTIFY_QUEUE.log.apply(NOTIFY_QUEUE, arguments);
            DERIVE_QUEUE.log.apply(DERIVE_QUEUE, arguments);
            DOM_UI_QUEUE.log.apply(DOM_UI_QUEUE, arguments);
            MUTATE_QUEUE.log.apply(MUTATE_QUEUE, arguments);
        }
    };
    if (ns.queues) {
        throw new Error('You can\'t have two versions of can-queues, check your dependencies');
    } else {
        module.exports = ns.queues = queues;
    }
});
/*can-key-tree@1.0.0#can-key-tree*/
define('can-key-tree@1.0.0#can-key-tree', [
    'require',
    'exports',
    'module',
    'can-reflect'
], function (require, exports, module) {
    var reflect = require('can-reflect');
    function isBuiltInPrototype(obj) {
        if (obj === Object.prototype) {
            return true;
        }
        var protoString = Object.prototype.toString.call(obj);
        var isNotObjObj = protoString !== '[object Object]';
        var isObjSomething = protoString.indexOf('[object ') !== -1;
        return isNotObjObj && isObjSomething;
    }
    function getDeepSize(root, level) {
        if (level === 0) {
            return reflect.size(root);
        } else if (reflect.size(root) === 0) {
            return 0;
        } else {
            var count = 0;
            reflect.each(root, function (value) {
                count += getDeepSize(value, level - 1);
            });
            return count;
        }
    }
    function getDeep(node, items, depth, maxDepth) {
        if (!node) {
            return;
        }
        if (maxDepth === depth) {
            if (reflect.isMoreListLikeThanMapLike(node)) {
                reflect.addValues(items, reflect.toArray(node));
            } else {
                throw new Error('can-key-tree: Map-type leaf containers are not supported yet.');
            }
        } else {
            reflect.each(node, function (value) {
                getDeep(value, items, depth + 1, maxDepth);
            });
        }
    }
    function clearDeep(node, keys, maxDepth, deleteHandler) {
        if (maxDepth === keys.length) {
            if (reflect.isMoreListLikeThanMapLike(node)) {
                var valuesToRemove = reflect.toArray(node);
                if (deleteHandler) {
                    valuesToRemove.forEach(function (value) {
                        deleteHandler.apply(null, keys.concat(value));
                    });
                }
                reflect.removeValues(node, valuesToRemove);
            } else {
                throw new Error('can-key-tree: Map-type leaf containers are not supported yet.');
            }
        } else {
            reflect.each(node, function (value, key) {
                clearDeep(value, keys.concat(key), maxDepth, deleteHandler);
                reflect.deleteKeyValue(node, key);
            });
        }
    }
    var KeyTree = function (treeStructure, callbacks) {
        this.callbacks = callbacks || {};
        this.treeStructure = treeStructure;
        var FirstConstructor = treeStructure[0];
        if (reflect.isConstructorLike(FirstConstructor)) {
            this.root = new FirstConstructor();
        } else {
            this.root = FirstConstructor;
        }
    };
    reflect.assign(KeyTree.prototype, {
        add: function (keys) {
            if (keys.length > this.treeStructure.length) {
                throw new Error('can-key-tree: Can not add path deeper than tree.');
            }
            var place = this.root;
            var rootWasEmpty = reflect.size(this.root) === 0;
            for (var i = 0; i < keys.length - 1; i++) {
                var key = keys[i];
                var childNode = reflect.getKeyValue(place, key);
                if (!childNode) {
                    var Constructor = this.treeStructure[i + 1];
                    if (isBuiltInPrototype(Constructor.prototype)) {
                        childNode = new Constructor();
                    } else {
                        childNode = new Constructor(key);
                    }
                    reflect.setKeyValue(place, key, childNode);
                }
                place = childNode;
            }
            if (reflect.isMoreListLikeThanMapLike(place)) {
                reflect.addValues(place, [keys[keys.length - 1]]);
            } else {
                throw new Error('can-key-tree: Map types are not supported yet.');
            }
            if (rootWasEmpty && this.callbacks.onFirst) {
                this.callbacks.onFirst.call(this);
            }
            return this;
        },
        getNode: function (keys) {
            var node = this.root;
            for (var i = 0; i < keys.length; i++) {
                var key = keys[i];
                node = reflect.getKeyValue(node, key);
                if (!node) {
                    return;
                }
            }
            return node;
        },
        get: function (keys) {
            var node = this.getNode(keys);
            if (this.treeStructure.length === keys.length) {
                return node;
            } else {
                var Type = this.treeStructure[this.treeStructure.length - 1];
                var items = new Type();
                getDeep(node, items, keys.length, this.treeStructure.length - 1);
                return items;
            }
        },
        delete: function (keys, deleteHandler) {
            var parentNode = this.root, path = [this.root], lastKey = keys[keys.length - 1];
            for (var i = 0; i < keys.length - 1; i++) {
                var key = keys[i];
                var childNode = reflect.getKeyValue(parentNode, key);
                if (childNode === undefined) {
                    return false;
                } else {
                    path.push(childNode);
                }
                parentNode = childNode;
            }
            if (!keys.length) {
                clearDeep(parentNode, [], this.treeStructure.length - 1, deleteHandler);
            } else if (keys.length === this.treeStructure.length) {
                if (reflect.isMoreListLikeThanMapLike(parentNode)) {
                    if (deleteHandler) {
                        deleteHandler.apply(null, keys.concat(lastKey));
                    }
                    reflect.removeValues(parentNode, [lastKey]);
                } else {
                    throw new Error('can-key-tree: Map types are not supported yet.');
                }
            } else {
                var nodeToRemove = reflect.getKeyValue(parentNode, lastKey);
                if (nodeToRemove !== undefined) {
                    clearDeep(nodeToRemove, keys, this.treeStructure.length - 1, deleteHandler);
                    reflect.deleteKeyValue(parentNode, lastKey);
                } else {
                    return false;
                }
            }
            for (i = path.length - 2; i >= 0; i--) {
                if (reflect.size(parentNode) === 0) {
                    parentNode = path[i];
                    reflect.deleteKeyValue(parentNode, keys[i]);
                } else {
                    break;
                }
            }
            if (this.callbacks.onEmpty && reflect.size(this.root) === 0) {
                this.callbacks.onEmpty.call(this);
            }
            return true;
        },
        size: function () {
            return getDeepSize(this.root, this.treeStructure.length - 1);
        }
    });
    module.exports = KeyTree;
});
/*can-dom-events@1.1.1#helpers/util*/
define('can-dom-events@1.1.1#helpers/util', [
    'require',
    'exports',
    'module',
    'can-globals/document/document',
    'can-globals/is-browser-window/is-browser-window'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        'use strict';
        var getCurrentDocument = require('can-globals/document/document');
        var isBrowserWindow = require('can-globals/is-browser-window/is-browser-window');
        function getTargetDocument(target) {
            return target.ownerDocument || getCurrentDocument();
        }
        function createEvent(target, eventData, bubbles, cancelable) {
            var doc = getTargetDocument(target);
            var event = doc.createEvent('HTMLEvents');
            var eventType;
            if (typeof eventData === 'string') {
                eventType = eventData;
            } else {
                eventType = eventData.type;
                for (var prop in eventData) {
                    if (event[prop] === undefined) {
                        event[prop] = eventData[prop];
                    }
                }
            }
            if (bubbles === undefined) {
                bubbles = true;
            }
            event.initEvent(eventType, bubbles, cancelable);
            return event;
        }
        function isDomEventTarget(obj) {
            if (!(obj && obj.nodeName)) {
                return obj === window;
            }
            var nodeType = obj.nodeType;
            return nodeType === 1 || nodeType === 9 || nodeType === 11;
        }
        function addDomContext(context, args) {
            if (isDomEventTarget(context)) {
                args = Array.prototype.slice.call(args, 0);
                args.unshift(context);
            }
            return args;
        }
        function removeDomContext(context, args) {
            if (!isDomEventTarget(context)) {
                args = Array.prototype.slice.call(args, 0);
                context = args.shift();
            }
            return {
                context: context,
                args: args
            };
        }
        var fixSyntheticEventsOnDisabled = false;
        (function () {
            if (!isBrowserWindow()) {
                return;
            }
            var testEventName = 'fix_synthetic_events_on_disabled_test';
            var input = document.createElement('input');
            input.disabled = true;
            var timer = setTimeout(function () {
                fixSyntheticEventsOnDisabled = true;
            }, 50);
            var onTest = function onTest() {
                clearTimeout(timer);
                input.removeEventListener(testEventName, onTest);
            };
            input.addEventListener(testEventName, onTest);
            try {
                var event = document.create('HTMLEvents');
                event.initEvent(testEventName, false);
                input.dispatchEvent(event);
            } catch (e) {
                onTest();
                fixSyntheticEventsOnDisabled = true;
            }
        }());
        function isDispatchingOnDisabled(element, event) {
            var eventType = event.type;
            var isInsertedOrRemoved = eventType === 'inserted' || eventType === 'removed';
            var isDisabled = !!element.disabled;
            return isInsertedOrRemoved && isDisabled;
        }
        function forceEnabledForDispatch(element, event) {
            return fixSyntheticEventsOnDisabled && isDispatchingOnDisabled(element, event);
        }
        module.exports = {
            createEvent: createEvent,
            addDomContext: addDomContext,
            removeDomContext: removeDomContext,
            isDomEventTarget: isDomEventTarget,
            getTargetDocument: getTargetDocument,
            forceEnabledForDispatch: forceEnabledForDispatch
        };
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-dom-events@1.1.1#helpers/make-event-registry*/
define('can-dom-events@1.1.1#helpers/make-event-registry', function (require, exports, module) {
    'use strict';
    function EventRegistry() {
        this._registry = {};
    }
    module.exports = function makeEventRegistry() {
        return new EventRegistry();
    };
    EventRegistry.prototype.has = function (eventType) {
        return !!this._registry[eventType];
    };
    EventRegistry.prototype.get = function (eventType) {
        return this._registry[eventType];
    };
    EventRegistry.prototype.add = function (event, eventType) {
        if (!event) {
            throw new Error('An EventDefinition must be provided');
        }
        if (typeof event.addEventListener !== 'function') {
            throw new TypeError('EventDefinition addEventListener must be a function');
        }
        if (typeof event.removeEventListener !== 'function') {
            throw new TypeError('EventDefinition removeEventListener must be a function');
        }
        eventType = eventType || event.defaultEventType;
        if (typeof eventType !== 'string') {
            throw new TypeError('Event type must be a string, not ' + eventType);
        }
        if (this.has(eventType)) {
            throw new Error('Event "' + eventType + '" is already registered');
        }
        this._registry[eventType] = event;
        var self = this;
        return function remove() {
            self._registry[eventType] = undefined;
        };
    };
});
/*can-dom-events@1.1.1#helpers/-make-delegate-event-tree*/
define('can-dom-events@1.1.1#helpers/-make-delegate-event-tree', [
    'require',
    'exports',
    'module',
    'can-key-tree',
    'can-reflect'
], function (require, exports, module) {
    var KeyTree = require('can-key-tree');
    var canReflect = require('can-reflect');
    var useCapture = function (eventType) {
        return eventType === 'focus' || eventType === 'blur';
    };
    function makeDelegator(domEvents) {
        var Delegator = function Delegator(parentKey) {
            this.element = parentKey;
            this.events = {};
            this.delegated = {};
        };
        canReflect.assignSymbols(Delegator.prototype, {
            'can.setKeyValue': function (eventType, handlersBySelector) {
                var handler = this.delegated[eventType] = function (ev) {
                    canReflect.each(handlersBySelector, function (handlers, selector) {
                        var cur = ev.target;
                        do {
                            if (cur.matches(selector)) {
                                handlers.forEach(function (handler) {
                                    handler.call(cur, ev);
                                });
                            }
                            cur = cur.parentNode;
                        } while (cur && cur !== ev.currentTarget);
                    });
                };
                this.events[eventType] = handlersBySelector;
                domEvents.addEventListener(this.element, eventType, handler, useCapture(eventType));
            },
            'can.getKeyValue': function (eventType) {
                return this.events[eventType];
            },
            'can.deleteKeyValue': function (eventType) {
                domEvents.removeEventListener(this.element, eventType, this.delegated[eventType], useCapture(eventType));
                delete this.delegated[eventType];
                delete this.events[eventType];
            },
            'can.getOwnEnumerableKeys': function () {
                return Object.keys(this.events);
            }
        });
        return Delegator;
    }
    module.exports = function makeDelegateEventTree(domEvents) {
        var Delegator = makeDelegator(domEvents);
        return new KeyTree([
            Map,
            Delegator,
            Object,
            Array
        ]);
    };
});
/*can-dom-events@1.1.1#can-dom-events*/
define('can-dom-events@1.1.1#can-dom-events', [
    'require',
    'exports',
    'module',
    'can-namespace',
    './helpers/util',
    './helpers/make-event-registry',
    './helpers/-make-delegate-event-tree'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        'use strict';
        var namespace = require('can-namespace');
        var util = require('./helpers/util');
        var makeEventRegistry = require('./helpers/make-event-registry');
        var makeDelegateEventTree = require('./helpers/-make-delegate-event-tree');
        var domEvents = {
            _eventRegistry: makeEventRegistry(),
            addEvent: function (event, eventType) {
                return this._eventRegistry.add(event, eventType);
            },
            addEventListener: function (target, eventType) {
                var hasCustomEvent = domEvents._eventRegistry.has(eventType);
                if (hasCustomEvent) {
                    var event = domEvents._eventRegistry.get(eventType);
                    return event.addEventListener.apply(domEvents, arguments);
                }
                var eventArgs = Array.prototype.slice.call(arguments, 1);
                return target.addEventListener.apply(target, eventArgs);
            },
            removeEventListener: function (target, eventType) {
                var hasCustomEvent = domEvents._eventRegistry.has(eventType);
                if (hasCustomEvent) {
                    var event = domEvents._eventRegistry.get(eventType);
                    return event.removeEventListener.apply(domEvents, arguments);
                }
                var eventArgs = Array.prototype.slice.call(arguments, 1);
                return target.removeEventListener.apply(target, eventArgs);
            },
            addDelegateListener: function (target, eventType, selector, handler) {
                domEvents._eventTree.add([
                    target,
                    eventType,
                    selector,
                    handler
                ]);
            },
            removeDelegateListener: function (target, eventType, selector, handler) {
                domEvents._eventTree.delete([
                    target,
                    eventType,
                    selector,
                    handler
                ]);
            },
            dispatch: function (target, eventData, bubbles, cancelable) {
                var event = util.createEvent(target, eventData, bubbles, cancelable);
                var enableForDispatch = util.forceEnabledForDispatch(target, event);
                if (enableForDispatch) {
                    target.disabled = false;
                }
                var ret = target.dispatchEvent(event);
                if (enableForDispatch) {
                    target.disabled = true;
                }
                return ret;
            }
        };
        domEvents._eventTree = makeDelegateEventTree(domEvents);
        module.exports = namespace.domEvents = domEvents;
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-event-queue@1.0.0#dependency-record/merge*/
define('can-event-queue@1.0.0#dependency-record/merge', [
    'require',
    'exports',
    'module',
    'can-reflect'
], function (require, exports, module) {
    var canReflect = require('can-reflect');
    var mergeValueDependencies = function mergeValueDependencies(obj, source) {
        var sourceValueDeps = source.valueDependencies;
        if (sourceValueDeps) {
            var destValueDeps = obj.valueDependencies;
            if (!destValueDeps) {
                destValueDeps = new Set();
                obj.valueDependencies = destValueDeps;
            }
            canReflect.eachIndex(sourceValueDeps, function (dep) {
                destValueDeps.add(dep);
            });
        }
    };
    var mergeKeyDependencies = function mergeKeyDependencies(obj, source) {
        var sourcekeyDeps = source.keyDependencies;
        if (sourcekeyDeps) {
            var destKeyDeps = obj.keyDependencies;
            if (!destKeyDeps) {
                destKeyDeps = new Map();
                obj.keyDependencies = destKeyDeps;
            }
            canReflect.eachKey(sourcekeyDeps, function (keys, obj) {
                var entry = destKeyDeps.get(obj);
                if (!entry) {
                    entry = new Set();
                    destKeyDeps.set(obj, entry);
                }
                canReflect.eachIndex(keys, function (key) {
                    entry.add(key);
                });
            });
        }
    };
    module.exports = function mergeDependencyRecords(object, source) {
        mergeKeyDependencies(object, source);
        mergeValueDependencies(object, source);
        return object;
    };
});
/*can-event-queue@1.0.0#map/map*/
define('can-event-queue@1.0.0#map/map', [
    'require',
    'exports',
    'module',
    'can-log/dev/dev',
    'can-queues',
    'can-reflect',
    'can-symbol',
    'can-key-tree',
    'can-dom-events',
    'can-dom-events/helpers/util',
    '../dependency-record/merge'
], function (require, exports, module) {
    var canDev = require('can-log/dev/dev');
    var queues = require('can-queues');
    var canReflect = require('can-reflect');
    var canSymbol = require('can-symbol');
    var KeyTree = require('can-key-tree');
    var domEvents = require('can-dom-events');
    var isDomEventTarget = require('can-dom-events/helpers/util').isDomEventTarget;
    var mergeDependencyRecords = require('../dependency-record/merge');
    var metaSymbol = canSymbol.for('can.meta'), dispatchBoundChangeSymbol = canSymbol.for('can.dispatchInstanceBoundChange'), dispatchInstanceOnPatchesSymbol = canSymbol.for('can.dispatchInstanceOnPatches'), onKeyValueSymbol = canSymbol.for('can.onKeyValue'), offKeyValueSymbol = canSymbol.for('can.offKeyValue'), onEventSymbol = canSymbol.for('can.onEvent'), offEventSymbol = canSymbol.for('can.offEvent'), onValueSymbol = canSymbol.for('can.onValue'), offValueSymbol = canSymbol.for('can.offValue');
    var legacyMapBindings;
    function addHandlers(obj, meta) {
        if (!meta.handlers) {
            meta.handlers = new KeyTree([
                Object,
                Object,
                Object,
                Array
            ], {
                onFirst: function () {
                    if (obj._eventSetup !== undefined) {
                        obj._eventSetup();
                    }
                    if (obj.constructor[dispatchBoundChangeSymbol]) {
                        obj.constructor[dispatchBoundChangeSymbol](obj, true);
                    }
                },
                onEmpty: function () {
                    if (obj._eventTeardown !== undefined) {
                        obj._eventTeardown();
                    }
                    if (obj.constructor[dispatchBoundChangeSymbol]) {
                        obj.constructor[dispatchBoundChangeSymbol](obj, false);
                    }
                }
            });
        }
        if (!meta.listenHandlers) {
            meta.listenHandlers = new KeyTree([
                Map,
                Map,
                Object,
                Array
            ]);
        }
    }
    var ensureMeta = function ensureMeta(obj) {
        var meta = obj[metaSymbol];
        if (!meta) {
            meta = {};
            canReflect.setKeyValue(obj, metaSymbol, meta);
        }
        addHandlers(obj, meta);
        return meta;
    };
    function stopListeningArgumentsToKeys(bindTarget, event, handler, queueName) {
        if (arguments.length && canReflect.isPrimitive(bindTarget)) {
            queueName = handler;
            handler = event;
            event = bindTarget;
            bindTarget = this.context;
        }
        if (typeof event === 'function') {
            queueName = handler;
            handler = event;
            event = undefined;
        }
        if (typeof handler === 'string') {
            queueName = handler;
            handler = undefined;
        }
        var keys = [];
        if (bindTarget) {
            keys.push(bindTarget);
            if (event || handler || queueName) {
                keys.push(event);
                if (queueName || handler) {
                    keys.push(queueName || this.defaultQueue);
                    if (handler) {
                        keys.push(handler);
                    }
                }
            }
        }
        return keys;
    }
    var props = {
        dispatch: function (event, args) {
            if (!this.__inSetup) {
                if (typeof event === 'string') {
                    event = { type: event };
                }
                var meta = ensureMeta(this);
                var handlers = meta.handlers;
                var handlersByType = event.type !== undefined && handlers.getNode([event.type]);
                var dispatchConstructorPatches = event.patches && this.constructor[dispatchInstanceOnPatchesSymbol];
                var patchesNode = event.patches !== undefined && handlers.getNode([
                    'can.patches',
                    'onKeyValue'
                ]);
                var keysNode = event.keyChanged !== undefined && handlers.getNode([
                    'can.keys',
                    'onKeyValue'
                ]);
                var batch = dispatchConstructorPatches || handlersByType || patchesNode || keysNode;
                if (batch) {
                    queues.batch.start();
                }
                if (handlersByType) {
                    if (handlersByType.onKeyValue) {
                        queues.enqueueByQueue(handlersByType.onKeyValue, this, args, event.makeMeta, event.reasonLog);
                    }
                    if (handlersByType.event) {
                        event.batchNum = queues.batch.number();
                        var eventAndArgs = [event].concat(args);
                        queues.enqueueByQueue(handlersByType.event, this, eventAndArgs, event.makeMeta, event.reasonLog);
                    }
                }
                if (keysNode) {
                    queues.enqueueByQueue(keysNode, this, [event.keyChanged], event.makeMeta, event.reasonLog);
                }
                if (patchesNode) {
                    queues.enqueueByQueue(patchesNode, this, [event.patches], event.makeMeta, event.reasonLog);
                }
                if (dispatchConstructorPatches) {
                    this.constructor[dispatchInstanceOnPatchesSymbol](this, event.patches);
                }
                if (batch) {
                    queues.batch.stop();
                }
            }
            return event;
        },
        addEventListener: function (key, handler, queueName) {
            ensureMeta(this).handlers.add([
                key,
                'event',
                queueName || 'mutate',
                handler
            ]);
            return this;
        },
        removeEventListener: function (key, handler, queueName) {
            if (key === undefined) {
                var handlers = ensureMeta(this).handlers;
                var keyHandlers = handlers.getNode([]);
                Object.keys(keyHandlers).forEach(function (key) {
                    handlers.delete([
                        key,
                        'event'
                    ]);
                });
            } else if (!handler && !queueName) {
                ensureMeta(this).handlers.delete([
                    key,
                    'event'
                ]);
            } else if (!handler) {
                ensureMeta(this).handlers.delete([
                    key,
                    'event',
                    queueName || 'mutate'
                ]);
            } else {
                ensureMeta(this).handlers.delete([
                    key,
                    'event',
                    queueName || 'mutate',
                    handler
                ]);
            }
            return this;
        },
        one: function (event, handler) {
            var one = function () {
                legacyMapBindings.off.call(this, event, one);
                return handler.apply(this, arguments);
            };
            legacyMapBindings.on.call(this, event, one);
            return this;
        },
        listenTo: function (bindTarget, event, handler, queueName) {
            if (canReflect.isPrimitive(bindTarget)) {
                queueName = handler;
                handler = event;
                event = bindTarget;
                bindTarget = this;
            }
            if (typeof event === 'function') {
                queueName = handler;
                handler = event;
                event = undefined;
            }
            ensureMeta(this).listenHandlers.add([
                bindTarget,
                event,
                queueName || 'mutate',
                handler
            ]);
            legacyMapBindings.on.call(bindTarget, event, handler, queueName || 'mutate');
            return this;
        },
        stopListening: function () {
            var keys = stopListeningArgumentsToKeys.apply({
                context: this,
                defaultQueue: 'mutate'
            }, arguments);
            var listenHandlers = ensureMeta(this).listenHandlers;
            function deleteHandler(bindTarget, event, queue, handler) {
                legacyMapBindings.off.call(bindTarget, event, handler, queue);
            }
            listenHandlers.delete(keys, deleteHandler);
            return this;
        },
        on: function (eventName, handler, queue) {
            var listenWithDOM = isDomEventTarget(this);
            if (listenWithDOM) {
                if (typeof handler === 'string') {
                    domEvents.addDelegateListener(this, eventName, handler, queue);
                } else {
                    domEvents.addEventListener(this, eventName, handler, queue);
                }
            } else {
                if ('addEventListener' in this) {
                    this.addEventListener(eventName, handler, queue);
                } else if (this[onKeyValueSymbol]) {
                    canReflect.onKeyValue(this, eventName, handler, queue);
                } else if (this[onEventSymbol]) {
                    this[onEventSymbol](eventName, handler, queue);
                } else {
                    if (!eventName && this[onValueSymbol]) {
                        canReflect.onValue(this, handler, queue);
                    } else {
                        throw new Error('can-event-queue: Unable to bind ' + eventName);
                    }
                }
            }
            return this;
        },
        off: function (eventName, handler, queue) {
            var listenWithDOM = isDomEventTarget(this);
            if (listenWithDOM) {
                if (typeof handler === 'string') {
                    domEvents.removeDelegateListener(this, eventName, handler, queue);
                } else {
                    domEvents.removeEventListener(this, eventName, handler, queue);
                }
            } else {
                if ('removeEventListener' in this) {
                    this.removeEventListener(eventName, handler, queue);
                } else if (this[offKeyValueSymbol]) {
                    canReflect.offKeyValue(this, eventName, handler, queue);
                } else if (this[offEventSymbol]) {
                    this[offEventSymbol](eventName, handler, queue);
                } else {
                    if (!eventName && this[offValueSymbol]) {
                        canReflect.offValue(this, handler, queue);
                    } else {
                        throw new Error('can-event-queue: Unable to unbind ' + eventName);
                    }
                }
            }
            return this;
        }
    };
    var symbols = {
        'can.onKeyValue': function (key, handler, queueName) {
            ensureMeta(this).handlers.add([
                key,
                'onKeyValue',
                queueName || 'mutate',
                handler
            ]);
        },
        'can.offKeyValue': function (key, handler, queueName) {
            ensureMeta(this).handlers.delete([
                key,
                'onKeyValue',
                queueName || 'mutate',
                handler
            ]);
        },
        'can.isBound': function () {
            return ensureMeta(this).handlers.size() > 0;
        },
        'can.getWhatIChange': function getWhatIChange(key) {
        },
        'can.onPatches': function (handler, queue) {
            var handlers = ensureMeta(this).handlers;
            handlers.add([
                'can.patches',
                'onKeyValue',
                queue || 'notify',
                handler
            ]);
        },
        'can.offPatches': function (handler, queue) {
            var handlers = ensureMeta(this).handlers;
            handlers.delete([
                'can.patches',
                'onKeyValue',
                queue || 'notify',
                handler
            ]);
        }
    };
    function defineNonEnumerable(obj, prop, value) {
        Object.defineProperty(obj, prop, {
            enumerable: false,
            value: value
        });
    }
    legacyMapBindings = function (obj) {
        canReflect.assignMap(obj, props);
        return canReflect.assignSymbols(obj, symbols);
    };
    defineNonEnumerable(legacyMapBindings, 'addHandlers', addHandlers);
    defineNonEnumerable(legacyMapBindings, 'stopListeningArgumentsToKeys', stopListeningArgumentsToKeys);
    props.bind = props.addEventListener;
    props.unbind = props.removeEventListener;
    canReflect.assignMap(legacyMapBindings, props);
    canReflect.assignSymbols(legacyMapBindings, symbols);
    defineNonEnumerable(legacyMapBindings, 'start', function () {
        console.warn('use can-queues.batch.start()');
        queues.batch.start();
    });
    defineNonEnumerable(legacyMapBindings, 'stop', function () {
        console.warn('use can-queues.batch.stop()');
        queues.batch.stop();
    });
    defineNonEnumerable(legacyMapBindings, 'flush', function () {
        console.warn('use can-queues.flush()');
        queues.flush();
    });
    defineNonEnumerable(legacyMapBindings, 'afterPreviousEvents', function (handler) {
        console.warn('don\'t use afterPreviousEvents');
        queues.mutateQueue.enqueue(function afterPreviousEvents() {
            queues.mutateQueue.enqueue(handler);
        });
        queues.flush();
    });
    defineNonEnumerable(legacyMapBindings, 'after', function (handler) {
        console.warn('don\'t use after');
        queues.mutateQueue.enqueue(handler);
        queues.flush();
    });
    module.exports = legacyMapBindings;
});
/*can-observation-recorder@1.0.1#can-observation-recorder*/
define('can-observation-recorder@1.0.1#can-observation-recorder', [
    'require',
    'exports',
    'module',
    'can-namespace'
], function (require, exports, module) {
    var namespace = require('can-namespace');
    var stack = [];
    var ObservationRecorder = {
        stack: stack,
        start: function () {
            var deps = {
                keyDependencies: new Map(),
                valueDependencies: new Set(),
                traps: null,
                ignore: 0
            };
            stack.push(deps);
            return deps;
        },
        stop: function () {
            return stack.pop();
        },
        add: function (obj, event) {
            var top = stack[stack.length - 1];
            if (top && top.ignore === 0) {
                if (top.traps) {
                    top.traps.push([
                        obj,
                        event
                    ]);
                } else {
                    if (event === undefined) {
                        top.valueDependencies.add(obj);
                    } else {
                        var eventSet = top.keyDependencies.get(obj);
                        if (!eventSet) {
                            eventSet = new Set();
                            top.keyDependencies.set(obj, eventSet);
                        }
                        eventSet.add(event);
                    }
                }
            }
        },
        addMany: function (observes) {
            var top = stack[stack.length - 1];
            if (top) {
                if (top.traps) {
                    top.traps.push.apply(top.traps, observes);
                } else {
                    for (var i = 0, len = observes.length; i < len; i++) {
                        this.add(observes[i][0], observes[i][1]);
                    }
                }
            }
        },
        ignore: function (fn) {
            return function () {
                if (stack.length) {
                    var top = stack[stack.length - 1];
                    top.ignore++;
                    var res = fn.apply(this, arguments);
                    top.ignore--;
                    return res;
                } else {
                    return fn.apply(this, arguments);
                }
            };
        },
        isRecording: function () {
            var len = stack.length;
            var last = len && stack[len - 1];
            return last && last.ignore === 0 && last;
        },
        makeDependenciesRecord: function () {
            return {
                traps: null,
                keyDependencies: new Map(),
                valueDependencies: new Set(),
                ignore: 0
            };
        },
        makeDependenciesRecorder: function () {
            return ObservationRecorder.makeDependenciesRecord();
        },
        trap: function () {
            if (stack.length) {
                var top = stack[stack.length - 1];
                var oldTraps = top.traps;
                var traps = top.traps = [];
                return function () {
                    top.traps = oldTraps;
                    return traps;
                };
            } else {
                return function () {
                    return [];
                };
            }
        },
        trapsCount: function () {
            if (stack.length) {
                var top = stack[stack.length - 1];
                return top.traps.length;
            } else {
                return 0;
            }
        }
    };
    if (namespace.ObservationRecorder) {
        throw new Error('You can\'t have two versions of can-observation-recorder, check your dependencies');
    } else {
        module.exports = namespace.ObservationRecorder = ObservationRecorder;
    }
});
/*can-simple-map@4.0.0#can-simple-map*/
define('can-simple-map@4.0.0#can-simple-map', [
    'require',
    'exports',
    'module',
    'can-construct',
    'can-event-queue/map/map',
    'can-queues',
    'can-util/js/each/each',
    'can-observation-recorder',
    'can-reflect',
    'can-log/dev/dev',
    'can-symbol'
], function (require, exports, module) {
    var Construct = require('can-construct');
    var eventQueue = require('can-event-queue/map/map');
    var queues = require('can-queues');
    var each = require('can-util/js/each/each');
    var ObservationRecorder = require('can-observation-recorder');
    var canReflect = require('can-reflect');
    var dev = require('can-log/dev/dev');
    var canSymbol = require('can-symbol');
    var ensureMeta = function ensureMeta(obj) {
        var metaSymbol = canSymbol.for('can.meta');
        var meta = obj[metaSymbol];
        if (!meta) {
            meta = {};
            canReflect.setKeyValue(obj, metaSymbol, meta);
        }
        return meta;
    };
    var SimpleMap = Construct.extend('SimpleMap', {
        setup: function (initialData) {
            this._data = {};
            if (initialData && typeof initialData === 'object') {
                this.attr(initialData);
            }
        },
        attr: function (prop, value) {
            var self = this;
            if (arguments.length === 0) {
                ObservationRecorder.add(this, 'can.keys');
                var data = {};
                each(this._data, function (value, prop) {
                    ObservationRecorder.add(this, prop);
                    data[prop] = value;
                }, this);
                return data;
            } else if (arguments.length > 1) {
                var had = this._data.hasOwnProperty(prop);
                var old = this._data[prop];
                this._data[prop] = value;
                if (old !== value) {
                    this.dispatch({
                        keyChanged: !had ? prop : undefined,
                        type: prop
                    }, [
                        value,
                        old
                    ]);
                }
            } else if (typeof prop === 'object') {
                queues.batch.start();
                canReflect.eachKey(prop, function (value, key) {
                    self.attr(key, value);
                });
                queues.batch.stop();
            } else {
                if (prop !== 'constructor') {
                    ObservationRecorder.add(this, prop);
                    return this._data[prop];
                }
                return this.constructor;
            }
        },
        serialize: function () {
            return canReflect.serialize(this, Map);
        },
        get: function () {
            return this.attr.apply(this, arguments);
        },
        set: function () {
            return this.attr.apply(this, arguments);
        },
        log: function (key) {
        }
    });
    eventQueue(SimpleMap.prototype);
    canReflect.assignSymbols(SimpleMap.prototype, {
        'can.isMapLike': true,
        'can.isListLike': false,
        'can.isValueLike': false,
        'can.getKeyValue': SimpleMap.prototype.get,
        'can.setKeyValue': SimpleMap.prototype.set,
        'can.deleteKeyValue': function (prop) {
            if (this._data.hasOwnProperty(prop)) {
                var old = this._data[prop];
                delete this._data[prop];
                this.dispatch({
                    keyChanged: prop,
                    type: prop
                }, [
                    undefined,
                    old
                ]);
            }
        },
        'can.getOwnEnumerableKeys': function () {
            ObservationRecorder.add(this, 'can.keys');
            return Object.keys(this._data);
        },
        'can.assignDeep': function (source) {
            queues.batch.start();
            canReflect.assignMap(this, source);
            queues.batch.stop();
        },
        'can.updateDeep': function (source) {
            queues.batch.start();
            canReflect.updateMap(this, source);
            queues.batch.stop();
        },
        'can.keyHasDependencies': function (key) {
            return false;
        },
        'can.getKeyDependencies': function (key) {
            return undefined;
        }
    });
    module.exports = SimpleMap;
});
/*can-view-nodelist@4.0.1#can-view-nodelist*/
define('can-view-nodelist@4.0.1#can-view-nodelist', [
    'require',
    'exports',
    'module',
    'can-namespace',
    'can-dom-mutate/node'
], function (require, exports, module) {
    var namespace = require('can-namespace');
    var domMutate = require('can-dom-mutate/node');
    var nodeMap = new Map(), splice = [].splice, push = [].push, itemsInChildListTree = function (list) {
            var count = 0;
            for (var i = 0, len = list.length; i < len; i++) {
                var item = list[i];
                if (item.nodeType) {
                    count++;
                } else {
                    count += itemsInChildListTree(item);
                }
            }
            return count;
        }, replacementMap = function (replacements) {
            var map = new Map();
            for (var i = 0, len = replacements.length; i < len; i++) {
                var node = nodeLists.first(replacements[i]);
                map.set(node, replacements[i]);
            }
            return map;
        }, addUnfoundAsDeepChildren = function (list, rMap) {
            rMap.forEach(function (replacement) {
                list.newDeepChildren.push(replacement);
            });
        };
    var nodeLists = {
        update: function (nodeList, newNodes) {
            var oldNodes = nodeLists.unregisterChildren(nodeList);
            var arr = [];
            for (var i = 0, ref = arr.length = newNodes.length; i < ref; i++) {
                arr[i] = newNodes[i];
            }
            newNodes = arr;
            var oldListLength = nodeList.length;
            splice.apply(nodeList, [
                0,
                oldListLength
            ].concat(newNodes));
            if (nodeList.replacements) {
                nodeLists.nestReplacements(nodeList);
                nodeList.deepChildren = nodeList.newDeepChildren;
                nodeList.newDeepChildren = [];
            } else {
                nodeLists.nestList(nodeList);
            }
            return oldNodes;
        },
        nestReplacements: function (list) {
            var index = 0, rMap = replacementMap(list.replacements), rCount = list.replacements.length;
            while (index < list.length && rCount) {
                var node = list[index], replacement = rMap.get(node);
                if (replacement) {
                    rMap['delete'](node);
                    list.splice(index, itemsInChildListTree(replacement), replacement);
                    rCount--;
                }
                index++;
            }
            if (rCount) {
                addUnfoundAsDeepChildren(list, rMap);
            }
            list.replacements = [];
        },
        nestList: function (list) {
            var index = 0;
            while (index < list.length) {
                var node = list[index], childNodeList = nodeMap.get(node);
                if (childNodeList) {
                    if (childNodeList !== list) {
                        list.splice(index, itemsInChildListTree(childNodeList), childNodeList);
                    }
                } else {
                    nodeMap.set(node, list);
                }
                index++;
            }
        },
        last: function (nodeList) {
            var last = nodeList[nodeList.length - 1];
            if (last.nodeType) {
                return last;
            } else {
                return nodeLists.last(last);
            }
        },
        first: function (nodeList) {
            var first = nodeList[0];
            if (first.nodeType) {
                return first;
            } else {
                return nodeLists.first(first);
            }
        },
        flatten: function (nodeList) {
            var items = [];
            for (var i = 0; i < nodeList.length; i++) {
                var item = nodeList[i];
                if (item.nodeType) {
                    items.push(item);
                } else {
                    items.push.apply(items, nodeLists.flatten(item));
                }
            }
            return items;
        },
        register: function (nodeList, unregistered, parent, directlyNested) {
            nodeList.unregistered = unregistered;
            nodeList.parentList = parent;
            nodeList.nesting = parent && typeof parent.nesting !== 'undefined' ? parent.nesting + 1 : 0;
            if (parent) {
                nodeList.deepChildren = [];
                nodeList.newDeepChildren = [];
                nodeList.replacements = [];
                if (parent !== true) {
                    if (directlyNested) {
                        parent.replacements.push(nodeList);
                    } else {
                        parent.newDeepChildren.push(nodeList);
                    }
                }
            } else {
                nodeLists.nestList(nodeList);
            }
            return nodeList;
        },
        unregisterChildren: function (nodeList) {
            var nodes = [];
            for (var n = 0; n < nodeList.length; n++) {
                var node = nodeList[n];
                if (node.nodeType) {
                    if (!nodeList.replacements) {
                        nodeMap['delete'](node);
                    }
                    nodes.push(node);
                } else {
                    push.apply(nodes, nodeLists.unregister(node, true));
                }
            }
            var deepChildren = nodeList.deepChildren;
            if (deepChildren) {
                for (var l = 0; l < deepChildren.length; l++) {
                    nodeLists.unregister(deepChildren[l], true);
                }
            }
            return nodes;
        },
        unregister: function (nodeList, isChild) {
            var nodes = nodeLists.unregisterChildren(nodeList, true);
            if (nodeList.unregistered) {
                var unregisteredCallback = nodeList.unregistered;
                nodeList.replacements = nodeList.unregistered = null;
                if (!isChild) {
                    var deepChildren = nodeList.parentList && nodeList.parentList.deepChildren;
                    if (deepChildren) {
                        var index = deepChildren.indexOf(nodeList);
                        if (index !== -1) {
                            deepChildren.splice(index, 1);
                        }
                    }
                }
                unregisteredCallback();
            }
            return nodes;
        },
        after: function (oldElements, newFrag) {
            var last = oldElements[oldElements.length - 1];
            if (last.nextSibling) {
                domMutate.insertBefore.call(last.parentNode, newFrag, last.nextSibling);
            } else {
                domMutate.appendChild.call(last.parentNode, newFrag);
            }
        },
        replace: function (oldElements, newFrag) {
            var selectedValue, parentNode = oldElements[0].parentNode;
            if (parentNode.nodeName.toUpperCase() === 'SELECT' && parentNode.selectedIndex >= 0) {
                selectedValue = parentNode.value;
            }
            if (oldElements.length === 1) {
                domMutate.replaceChild.call(parentNode, newFrag, oldElements[0]);
            } else {
                nodeLists.after(oldElements, newFrag);
                nodeLists.remove(oldElements);
            }
            if (selectedValue !== undefined) {
                parentNode.value = selectedValue;
            }
        },
        remove: function (elementsToBeRemoved) {
            var parent = elementsToBeRemoved[0] && elementsToBeRemoved[0].parentNode;
            for (var i = 0; i < elementsToBeRemoved.length; i++) {
                domMutate.removeChild.call(parent, elementsToBeRemoved[i]);
            }
        },
        nodeMap: nodeMap
    };
    module.exports = namespace.nodeLists = nodeLists;
});
/*can-util@3.11.2#dom/child-nodes/child-nodes*/
define('can-util@3.11.2#dom/child-nodes/child-nodes', function (require, exports, module) {
    'use strict';
    function childNodes(node) {
        var childNodes = node.childNodes;
        if ('length' in childNodes) {
            return childNodes;
        } else {
            var cur = node.firstChild;
            var nodes = [];
            while (cur) {
                nodes.push(cur);
                cur = cur.nextSibling;
            }
            return nodes;
        }
    }
    module.exports = childNodes;
});
/*can-util@3.11.2#dom/fragment/fragment*/
define('can-util@3.11.2#dom/fragment/fragment', [
    'require',
    'exports',
    'module',
    'can-globals/document/document',
    '../child-nodes/child-nodes'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        'use strict';
        var getDocument = require('can-globals/document/document'), childNodes = require('../child-nodes/child-nodes');
        var fragmentRE = /^\s*<(\w+)[^>]*>/, toString = {}.toString, fragment = function (html, name, doc) {
                if (name === undefined) {
                    name = fragmentRE.test(html) && RegExp.$1;
                }
                if (html && toString.call(html.replace) === '[object Function]') {
                    html = html.replace(/<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi, '<$1></$2>');
                }
                var container = doc.createElement('div'), temp = doc.createElement('div');
                if (name === 'tbody' || name === 'tfoot' || name === 'thead' || name === 'colgroup') {
                    temp.innerHTML = '<table>' + html + '</table>';
                    container = temp.firstChild.nodeType === 3 ? temp.lastChild : temp.firstChild;
                } else if (name === 'col') {
                    temp.innerHTML = '<table><colgroup>' + html + '</colgroup></table>';
                    container = temp.firstChild.nodeType === 3 ? temp.lastChild : temp.firstChild.firstChild;
                } else if (name === 'tr') {
                    temp.innerHTML = '<table><tbody>' + html + '</tbody></table>';
                    container = temp.firstChild.nodeType === 3 ? temp.lastChild : temp.firstChild.firstChild;
                } else if (name === 'td' || name === 'th') {
                    temp.innerHTML = '<table><tbody><tr>' + html + '</tr></tbody></table>';
                    container = temp.firstChild.nodeType === 3 ? temp.lastChild : temp.firstChild.firstChild.firstChild;
                } else if (name === 'option') {
                    temp.innerHTML = '<select>' + html + '</select>';
                    container = temp.firstChild.nodeType === 3 ? temp.lastChild : temp.firstChild;
                } else {
                    container.innerHTML = '' + html;
                }
                var tmp = {}, children = childNodes(container);
                tmp.length = children.length;
                for (var i = 0; i < children.length; i++) {
                    tmp[i] = children[i];
                }
                return [].slice.call(tmp);
            };
        var buildFragment = function (html, doc) {
            if (html && html.nodeType === 11) {
                return html;
            }
            if (!doc) {
                doc = getDocument();
            } else if (doc.length) {
                doc = doc[0];
            }
            var parts = fragment(html, undefined, doc), frag = (doc || document).createDocumentFragment();
            for (var i = 0, length = parts.length; i < length; i++) {
                frag.appendChild(parts[i]);
            }
            return frag;
        };
        module.exports = buildFragment;
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-util@3.11.2#dom/frag/frag*/
define('can-util@3.11.2#dom/frag/frag', [
    'require',
    'exports',
    'module',
    'can-globals/document/document',
    '../fragment/fragment',
    '../../js/each/each',
    '../child-nodes/child-nodes'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        'use strict';
        var getDocument = require('can-globals/document/document');
        var fragment = require('../fragment/fragment');
        var each = require('../../js/each/each');
        var childNodes = require('../child-nodes/child-nodes');
        var makeFrag = function (item, doc) {
            var document = doc || getDocument();
            var frag;
            if (!item || typeof item === 'string') {
                frag = fragment(item == null ? '' : '' + item, document);
                if (!frag.childNodes.length) {
                    frag.appendChild(document.createTextNode(''));
                }
                return frag;
            } else if (item.nodeType === 11) {
                return item;
            } else if (typeof item.nodeType === 'number') {
                frag = document.createDocumentFragment();
                frag.appendChild(item);
                return frag;
            } else if (typeof item.length === 'number') {
                frag = document.createDocumentFragment();
                each(item, function (item) {
                    frag.appendChild(makeFrag(item));
                });
                if (!childNodes(frag).length) {
                    frag.appendChild(document.createTextNode(''));
                }
                return frag;
            } else {
                frag = fragment('' + item, document);
                if (!childNodes(frag).length) {
                    frag.appendChild(document.createTextNode(''));
                }
                return frag;
            }
        };
        module.exports = makeFrag;
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-view-callbacks@4.0.0#can-view-callbacks*/
define('can-view-callbacks@4.0.0#can-view-callbacks', [
    'require',
    'exports',
    'module',
    'can-observation-recorder',
    'can-log/dev/dev',
    'can-globals/global/global',
    'can-dom-mutate/node',
    'can-namespace',
    'can-view-nodelist',
    'can-util/dom/frag/frag',
    'can-globals'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        var ObservationRecorder = require('can-observation-recorder');
        var dev = require('can-log/dev/dev');
        var getGlobal = require('can-globals/global/global');
        var domMutate = require('can-dom-mutate/node');
        var namespace = require('can-namespace');
        var nodeLists = require('can-view-nodelist');
        var makeFrag = require('can-util/dom/frag/frag');
        var globals = require('can-globals');
        var tags = {};
        var automountEnabled = function () {
            return globals.getKeyValue('document').documentElement.getAttribute('data-can-automount') !== 'false';
        };
        var renderedElements = new WeakSet();
        var renderNodeAndChildren = function (node) {
            var tagName = node.tagName && node.tagName.toLowerCase();
            var tagHandler = tags[tagName];
            var children;
            if (tagHandler && !renderedElements.has(node)) {
                tagHandler(node, {});
            }
            if (node.getElementsByTagName) {
                children = node.getElementsByTagName('*');
                for (var k = 0, child; (child = children[k]) !== undefined; k++) {
                    renderNodeAndChildren(child);
                }
            }
        };
        var mutationObserverEnabled = false;
        var globalMutationObserver;
        var enableMutationObserver = function () {
            if (mutationObserverEnabled) {
                return;
            }
            var mutationHandler = function (mutationsList) {
                var addedNodes;
                for (var i = 0, mutation; (mutation = mutationsList[i]) !== undefined; i++) {
                    if (mutation.type === 'childList') {
                        addedNodes = mutation.addedNodes;
                        for (var j = 0, addedNode; (addedNode = addedNodes[j]) !== undefined; j++) {
                            if (!renderedElements.has(addedNode)) {
                                renderNodeAndChildren(addedNode);
                            }
                        }
                    }
                }
            };
            var MutationObserver = globals.getKeyValue('MutationObserver');
            if (MutationObserver) {
                globalMutationObserver = new MutationObserver(mutationHandler);
                globalMutationObserver.observe(getGlobal().document.documentElement, {
                    childList: true,
                    subtree: true
                });
                mutationObserverEnabled = true;
            }
        };
        var renderTagsInDocument = function (tagName) {
            var nodes = getGlobal().document.getElementsByTagName(tagName);
            for (var i = 0, node; (node = nodes[i]) !== undefined; i++) {
                renderNodeAndChildren(node);
            }
        };
        var attr = function (attributeName, attrHandler) {
            if (attrHandler) {
                if (typeof attributeName === 'string') {
                    attributes[attributeName] = attrHandler;
                } else {
                    regExpAttributes.push({
                        match: attributeName,
                        handler: attrHandler
                    });
                }
            } else {
                var cb = attributes[attributeName];
                if (!cb) {
                    for (var i = 0, len = regExpAttributes.length; i < len; i++) {
                        var attrMatcher = regExpAttributes[i];
                        if (attrMatcher.match.test(attributeName)) {
                            return attrMatcher.handler;
                        }
                    }
                }
                return cb;
            }
        };
        var attributes = {}, regExpAttributes = [], automaticCustomElementCharacters = /[-\:]/;
        var defaultCallback = function () {
        };
        var tag = function (tagName, tagHandler) {
            if (tagHandler) {
                var GLOBAL = getGlobal();
                var validCustomElementName = automaticCustomElementCharacters.test(tagName), tagExists = typeof tags[tagName.toLowerCase()] !== 'undefined', customElementExists;
                if (GLOBAL.html5) {
                    GLOBAL.html5.elements += ' ' + tagName;
                    GLOBAL.html5.shivDocument();
                }
                tags[tagName.toLowerCase()] = tagHandler;
                if (automountEnabled()) {
                    var customElements = globals.getKeyValue('customElements');
                    if (customElements) {
                        customElementExists = customElements.get(tagName.toLowerCase());
                        if (validCustomElementName && !customElementExists) {
                            var CustomElement = function () {
                                return Reflect.construct(HTMLElement, [], CustomElement);
                            };
                            CustomElement.prototype.connectedCallback = function () {
                                if (!renderedElements.has(this)) {
                                    tags[tagName.toLowerCase()](this, {});
                                }
                            };
                            Object.setPrototypeOf(CustomElement.prototype, HTMLElement.prototype);
                            Object.setPrototypeOf(CustomElement, HTMLElement);
                            customElements.define(tagName, CustomElement);
                        }
                    } else {
                        enableMutationObserver();
                        renderTagsInDocument(tagName);
                    }
                } else if (mutationObserverEnabled) {
                    globalMutationObserver.disconnect();
                }
            } else {
                var cb;
                if (tagHandler === null) {
                    delete tags[tagName.toLowerCase()];
                } else {
                    cb = tags[tagName.toLowerCase()];
                }
                if (!cb && automaticCustomElementCharacters.test(tagName)) {
                    cb = defaultCallback;
                }
                return cb;
            }
        };
        var callbacks = {
            _tags: tags,
            _attributes: attributes,
            _regExpAttributes: regExpAttributes,
            defaultCallback: defaultCallback,
            tag: tag,
            attr: attr,
            tagHandler: function (el, tagName, tagData) {
                var scope = tagData.scope, helperTagCallback = scope && scope.templateContext.tags.get(tagName), tagCallback = helperTagCallback || tags[tagName], res;
                if (tagCallback) {
                    res = ObservationRecorder.ignore(tagCallback)(el, tagData);
                    renderedElements.add(el);
                } else {
                    res = scope;
                }
                if (res && tagData.subtemplate) {
                    if (scope !== res) {
                        scope = scope.add(res);
                    }
                    var nodeList = nodeLists.register([], undefined, tagData.parentNodeList || true, false);
                    nodeList.expression = '<' + el.tagName + '>';
                    var result = tagData.subtemplate(scope, tagData.options, nodeList);
                    var frag = typeof result === 'string' ? makeFrag(result) : result;
                    domMutate.appendChild.call(el, frag);
                }
            }
        };
        namespace.view = namespace.view || {};
        if (namespace.view.callbacks) {
            throw new Error('You can\'t have two versions of can-view-callbacks, check your dependencies');
        } else {
            module.exports = namespace.view.callbacks = callbacks;
        }
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-view-target@4.0.0#can-view-target*/
define('can-view-target@4.0.0#can-view-target', [
    'require',
    'exports',
    'module',
    'can-globals/document/document',
    'can-dom-mutate/node',
    'can-namespace',
    'can-globals/mutation-observer/mutation-observer'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        var getDocument = require('can-globals/document/document');
        var domMutate = require('can-dom-mutate/node');
        var namespace = require('can-namespace');
        var MUTATION_OBSERVER = require('can-globals/mutation-observer/mutation-observer');
        var processNodes = function (nodes, paths, location, document) {
                var frag = document.createDocumentFragment();
                for (var i = 0, len = nodes.length; i < len; i++) {
                    var node = nodes[i];
                    frag.appendChild(processNode(node, paths, location.concat(i), document));
                }
                return frag;
            }, keepsTextNodes = typeof document !== 'undefined' && function () {
                var testFrag = document.createDocumentFragment();
                var div = document.createElement('div');
                div.appendChild(document.createTextNode(''));
                div.appendChild(document.createTextNode(''));
                testFrag.appendChild(div);
                var cloned = testFrag.cloneNode(true);
                return cloned.firstChild.childNodes.length === 2;
            }(), clonesWork = typeof document !== 'undefined' && function () {
                var el = document.createElement('a');
                el.innerHTML = '<xyz></xyz>';
                var clone = el.cloneNode(true);
                var works = clone.innerHTML === '<xyz></xyz>';
                var MO, observer;
                if (works) {
                    el = document.createDocumentFragment();
                    el.appendChild(document.createTextNode('foo-bar'));
                    MO = MUTATION_OBSERVER();
                    if (MO) {
                        observer = new MO(function () {
                        });
                        observer.observe(document.documentElement, {
                            childList: true,
                            subtree: true
                        });
                        clone = el.cloneNode(true);
                        observer.disconnect();
                    } else {
                        clone = el.cloneNode(true);
                    }
                    return clone.childNodes.length === 1;
                }
                return works;
            }(), namespacesWork = typeof document !== 'undefined' && !!document.createElementNS;
        var cloneNode = clonesWork ? function (el) {
            return el.cloneNode(true);
        } : function (node) {
            var document = node.ownerDocument;
            var copy;
            if (node.nodeType === 1) {
                if (node.namespaceURI !== 'http://www.w3.org/1999/xhtml' && namespacesWork && document.createElementNS) {
                    copy = document.createElementNS(node.namespaceURI, node.nodeName);
                } else {
                    copy = document.createElement(node.nodeName);
                }
            } else if (node.nodeType === 3) {
                copy = document.createTextNode(node.nodeValue);
            } else if (node.nodeType === 8) {
                copy = document.createComment(node.nodeValue);
            } else if (node.nodeType === 11) {
                copy = document.createDocumentFragment();
            }
            if (node.attributes) {
                var attributes = node.attributes;
                for (var i = 0; i < attributes.length; i++) {
                    var attribute = attributes[i];
                    if (attribute && attribute.specified) {
                        domMutate.setAttribute.call(copy, attribute.nodeName || attribute.name, attribute.nodeValue || attribute.value);
                    }
                }
            }
            if (node && node.firstChild) {
                var child = node.firstChild;
                while (child) {
                    copy.appendChild(cloneNode(child));
                    child = child.nextSibling;
                }
            }
            return copy;
        };
        function processNode(node, paths, location, document) {
            var callback, loc = location, nodeType = typeof node, el, p, i, len;
            var getCallback = function () {
                if (!callback) {
                    callback = {
                        path: location,
                        callbacks: []
                    };
                    paths.push(callback);
                    loc = [];
                }
                return callback;
            };
            if (nodeType === 'object') {
                if (node.tag) {
                    if (namespacesWork && node.namespace) {
                        el = document.createElementNS(node.namespace, node.tag);
                    } else {
                        el = document.createElement(node.tag);
                    }
                    if (node.attrs) {
                        for (var attrName in node.attrs) {
                            var value = node.attrs[attrName];
                            if (typeof value === 'function') {
                                getCallback().callbacks.push({ callback: value });
                            } else {
                                domMutate.setAttribute.call(el, attrName, value);
                            }
                        }
                    }
                    if (node.attributes) {
                        for (i = 0, len = node.attributes.length; i < len; i++) {
                            getCallback().callbacks.push({ callback: node.attributes[i] });
                        }
                    }
                    if (node.children && node.children.length) {
                        if (callback) {
                            p = callback.paths = [];
                        } else {
                            p = paths;
                        }
                        el.appendChild(processNodes(node.children, p, loc, document));
                    }
                } else if (node.comment) {
                    el = document.createComment(node.comment);
                    if (node.callbacks) {
                        for (i = 0, len = node.attributes.length; i < len; i++) {
                            getCallback().callbacks.push({ callback: node.callbacks[i] });
                        }
                    }
                }
            } else if (nodeType === 'string') {
                el = document.createTextNode(node);
            } else if (nodeType === 'function') {
                if (keepsTextNodes) {
                    el = document.createTextNode('');
                    getCallback().callbacks.push({ callback: node });
                } else {
                    el = document.createComment('~');
                    getCallback().callbacks.push({
                        callback: function () {
                            var el = document.createTextNode('');
                            domMutate.replaceChild.call(this.parentNode, el, this);
                            return node.apply(el, arguments);
                        }
                    });
                }
            }
            return el;
        }
        function getCallbacks(el, pathData, elementCallbacks) {
            var path = pathData.path, callbacks = pathData.callbacks, paths = pathData.paths, child = el, pathLength = path ? path.length : 0, pathsLength = paths ? paths.length : 0;
            for (var i = 0; i < pathLength; i++) {
                child = child.childNodes.item(path[i]);
            }
            for (i = 0; i < pathsLength; i++) {
                getCallbacks(child, paths[i], elementCallbacks);
            }
            elementCallbacks.push({
                element: child,
                callbacks: callbacks
            });
        }
        function hydrateCallbacks(callbacks, args) {
            var len = callbacks.length, callbacksLength, callbackElement, callbackData;
            for (var i = 0; i < len; i++) {
                callbackData = callbacks[i];
                callbacksLength = callbackData.callbacks.length;
                callbackElement = callbackData.element;
                for (var c = 0; c < callbacksLength; c++) {
                    callbackData.callbacks[c].callback.apply(callbackElement, args);
                }
            }
        }
        function makeTarget(nodes, doc) {
            var paths = [];
            var frag = processNodes(nodes, paths, [], doc || getDocument());
            return {
                paths: paths,
                clone: frag,
                hydrate: function () {
                    var cloned = cloneNode(this.clone);
                    var args = [];
                    for (var a = 0, ref = args.length = arguments.length; a < ref; a++) {
                        args[a] = arguments[a];
                    }
                    var callbacks = [];
                    for (var i = 0; i < paths.length; i++) {
                        getCallbacks(cloned, paths[i], callbacks);
                    }
                    hydrateCallbacks(callbacks, args);
                    return cloned;
                }
            };
        }
        makeTarget.keepsTextNodes = keepsTextNodes;
        makeTarget.cloneNode = cloneNode;
        namespace.view = namespace.view || {};
        module.exports = namespace.view.target = makeTarget;
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-util@3.11.2#js/is-promise-like/is-promise-like*/
define('can-util@3.11.2#js/is-promise-like/is-promise-like', function (require, exports, module) {
    'use strict';
    module.exports = function (obj) {
        return !!obj && (typeof obj === 'object' || typeof obj === 'function') && typeof obj.then === 'function';
    };
});
/*can-reflect-promise@2.0.1#can-reflect-promise*/
define('can-reflect-promise@2.0.1#can-reflect-promise', [
    'require',
    'exports',
    'module',
    'can-reflect',
    'can-symbol',
    'can-observation-recorder',
    'can-queues',
    'can-key-tree',
    'can-log/dev/dev'
], function (require, exports, module) {
    var canReflect = require('can-reflect');
    var canSymbol = require('can-symbol');
    var ObservationRecorder = require('can-observation-recorder');
    var queues = require('can-queues');
    var KeyTree = require('can-key-tree');
    var dev = require('can-log/dev/dev');
    var getKeyValueSymbol = canSymbol.for('can.getKeyValue'), observeDataSymbol = canSymbol.for('can.meta');
    var promiseDataPrototype = {
        isPending: true,
        state: 'pending',
        isResolved: false,
        isRejected: false,
        value: undefined,
        reason: undefined
    };
    function setVirtualProp(promise, property, value) {
        var observeData = promise[observeDataSymbol];
        var old = observeData[property];
        observeData[property] = value;
        queues.enqueueByQueue(observeData.handlers.getNode([property]), promise, [
            value,
            old
        ], function () {
            return {};
        }, [
            'Promise',
            promise,
            'resolved with value',
            value,
            'and changed virtual property: ' + property
        ]);
    }
    function initPromise(promise) {
        var observeData = promise[observeDataSymbol];
        if (!observeData) {
            Object.defineProperty(promise, observeDataSymbol, {
                enumerable: false,
                configurable: false,
                writable: false,
                value: Object.create(promiseDataPrototype)
            });
            observeData = promise[observeDataSymbol];
            observeData.handlers = new KeyTree([
                Object,
                Object,
                Array
            ]);
        }
        promise.then(function (value) {
            queues.batch.start();
            setVirtualProp(promise, 'isPending', false);
            setVirtualProp(promise, 'isResolved', true);
            setVirtualProp(promise, 'value', value);
            setVirtualProp(promise, 'state', 'resolved');
            queues.batch.stop();
        }, function (reason) {
            queues.batch.start();
            setVirtualProp(promise, 'isPending', false);
            setVirtualProp(promise, 'isRejected', true);
            setVirtualProp(promise, 'reason', reason);
            setVirtualProp(promise, 'state', 'rejected');
            queues.batch.stop();
        });
    }
    function setupPromise(value) {
        var oldPromiseFn;
        var proto = 'getPrototypeOf' in Object ? Object.getPrototypeOf(value) : value.__proto__;
        if (value[getKeyValueSymbol] && value[observeDataSymbol]) {
            return;
        }
        if (proto === null || proto === Object.prototype) {
            proto = value;
            if (typeof proto.promise === 'function') {
                oldPromiseFn = proto.promise;
                proto.promise = function () {
                    var result = oldPromiseFn.call(proto);
                    setupPromise(result);
                    return result;
                };
            }
        }
        canReflect.assignSymbols(proto, {
            'can.getKeyValue': function (key) {
                if (!this[observeDataSymbol]) {
                    initPromise(this);
                }
                ObservationRecorder.add(this, key);
                switch (key) {
                case 'state':
                case 'isPending':
                case 'isResolved':
                case 'isRejected':
                case 'value':
                case 'reason':
                    return this[observeDataSymbol][key];
                default:
                    return this[key];
                }
            },
            'can.getValue': function () {
                return this[getKeyValueSymbol]('value');
            },
            'can.isValueLike': false,
            'can.onKeyValue': function (key, handler, queue) {
                if (!this[observeDataSymbol]) {
                    initPromise(this);
                }
                this[observeDataSymbol].handlers.add([
                    key,
                    queue || 'mutate',
                    handler
                ]);
            },
            'can.offKeyValue': function (key, handler, queue) {
                if (!this[observeDataSymbol]) {
                    initPromise(this);
                }
                this[observeDataSymbol].handlers.delete([
                    key,
                    queue || 'mutate',
                    handler
                ]);
            }
        });
    }
    module.exports = setupPromise;
});
/*can-stache-key@1.0.0#can-stache-key*/
define('can-stache-key@1.0.0#can-stache-key', [
    'require',
    'exports',
    'module',
    'can-observation-recorder',
    'can-log/dev/dev',
    'can-util/js/each/each',
    'can-symbol',
    'can-reflect',
    'can-util/js/is-promise-like/is-promise-like',
    'can-reflect-promise'
], function (require, exports, module) {
    var ObservationRecorder = require('can-observation-recorder');
    var dev = require('can-log/dev/dev');
    var each = require('can-util/js/each/each');
    var canSymbol = require('can-symbol');
    var canReflect = require('can-reflect');
    var isPromiseLike = require('can-util/js/is-promise-like/is-promise-like');
    var canReflectPromise = require('can-reflect-promise');
    var getValueSymbol = canSymbol.for('can.getValue');
    var setValueSymbol = canSymbol.for('can.setValue');
    var isValueLikeSymbol = canSymbol.for('can.isValueLike');
    var peek = ObservationRecorder.ignore(canReflect.getKeyValue.bind(canReflect));
    var observeReader;
    var bindName = Function.prototype.bind;
    var isAt = function (index, reads) {
        var prevRead = reads[index - 1];
        return prevRead && prevRead.at;
    };
    var readValue = function (value, index, reads, options, state, prev) {
        var usedValueReader;
        do {
            usedValueReader = false;
            for (var i = 0, len = observeReader.valueReaders.length; i < len; i++) {
                if (observeReader.valueReaders[i].test(value, index, reads, options)) {
                    value = observeReader.valueReaders[i].read(value, index, reads, options, state, prev);
                }
            }
        } while (usedValueReader);
        return value;
    };
    var specialRead = {
        index: true,
        key: true,
        event: true,
        element: true,
        viewModel: true
    };
    var checkForObservableAndNotify = function (options, state, getObserves, value, index) {
        if (options.foundObservable && !state.foundObservable) {
            if (ObservationRecorder.trapsCount()) {
                ObservationRecorder.addMany(getObserves());
                options.foundObservable(value, index);
                state.foundObservable = true;
            }
        }
    };
    observeReader = {
        read: function (parent, reads, options) {
            options = options || {};
            var state = { foundObservable: false };
            var getObserves;
            if (options.foundObservable) {
                getObserves = ObservationRecorder.trap();
            }
            var cur = readValue(parent, 0, reads, options, state), type, prev, readLength = reads.length, i = 0, last;
            checkForObservableAndNotify(options, state, getObserves, parent, 0);
            while (i < readLength) {
                prev = cur;
                for (var r = 0, readersLength = observeReader.propertyReaders.length; r < readersLength; r++) {
                    var reader = observeReader.propertyReaders[r];
                    if (reader.test(cur)) {
                        cur = reader.read(cur, reads[i], i, options, state);
                        break;
                    }
                }
                checkForObservableAndNotify(options, state, getObserves, prev, i);
                last = cur;
                i = i + 1;
                cur = readValue(cur, i, reads, options, state, prev);
                checkForObservableAndNotify(options, state, getObserves, prev, i - 1);
                type = typeof cur;
                if (i < reads.length && (cur === null || cur === undefined)) {
                    if (options.earlyExit) {
                        options.earlyExit(prev, i - 1, cur);
                    }
                    return {
                        value: undefined,
                        parent: prev
                    };
                }
            }
            if (cur === undefined) {
                if (options.earlyExit) {
                    options.earlyExit(prev, i - 1);
                }
            }
            return {
                value: cur,
                parent: prev
            };
        },
        get: function (parent, reads, options) {
            return observeReader.read(parent, observeReader.reads(reads), options || {}).value;
        },
        valueReadersMap: {},
        valueReaders: [
            {
                name: 'function',
                test: function (value) {
                    return value && canReflect.isFunctionLike(value) && !canReflect.isConstructorLike(value);
                },
                read: function (value, i, reads, options, state, prev) {
                    if (options.callMethodsOnObservables && canReflect.isObservableLike(prev) && canReflect.isMapLike(prev)) {
                        dev.warn('can-stache-key: read() called with `callMethodsOnObservables: true`.');
                        return value.apply(prev, options.args || []);
                    }
                    return options.proxyMethods !== false ? bindName.call(value, prev) : value;
                }
            },
            {
                name: 'isValueLike',
                test: function (value, i, reads, options) {
                    return value && value[getValueSymbol] && value[isValueLikeSymbol] !== false && (options.foundAt || !isAt(i, reads));
                },
                read: function (value, i, reads, options) {
                    if (options.readCompute === false && i === reads.length) {
                        return value;
                    }
                    return canReflect.getValue(value);
                },
                write: function (base, newVal) {
                    if (base[setValueSymbol]) {
                        base[setValueSymbol](newVal);
                    } else if (base.set) {
                        base.set(newVal);
                    } else {
                        base(newVal);
                    }
                }
            }
        ],
        propertyReadersMap: {},
        propertyReaders: [
            {
                name: 'map',
                test: function (value) {
                    if (isPromiseLike(value) || typeof value === 'object' && value && typeof value.then === 'function') {
                        canReflectPromise(value);
                    }
                    return canReflect.isObservableLike(value) && canReflect.isMapLike(value);
                },
                read: function (value, prop) {
                    var res = canReflect.getKeyValue(value, prop.key);
                    if (res !== undefined) {
                        return res;
                    } else {
                        return value[prop.key];
                    }
                },
                write: canReflect.setKeyValue
            },
            {
                name: 'object',
                test: function () {
                    return true;
                },
                read: function (value, prop, i, options) {
                    if (value == null) {
                        return undefined;
                    } else {
                        if (typeof value === 'object') {
                            if (prop.key in value) {
                                return value[prop.key];
                            } else if (prop.at && specialRead[prop.key] && '@' + prop.key in value) {
                                options.foundAt = true;
                                return value['@' + prop.key];
                            }
                        } else {
                            return value[prop.key];
                        }
                    }
                },
                write: function (base, prop, newVal) {
                    var propValue = base[prop];
                    if (canReflect.isMapLike(propValue) && newVal && typeof newVal === 'object') {
                        dev.warn('can-stache-key: Merging data into "' + prop + '" because its parent is non-observable');
                        canReflect.update(propValue, newVal);
                    } else if (canReflect.isValueLike(propValue) && canReflect.isObservableLike(propValue)) {
                        canReflect.setValue(propValue, newVal);
                    } else {
                        base[prop] = newVal;
                    }
                }
            }
        ],
        reads: function (keyArg) {
            var key = '' + keyArg;
            var keys = [];
            var last = 0;
            var at = false;
            if (key.charAt(0) === '@') {
                last = 1;
                at = true;
            }
            var keyToAdd = '';
            for (var i = last; i < key.length; i++) {
                var character = key.charAt(i);
                if (character === '.' || character === '@') {
                    if (key.charAt(i - 1) !== '\\') {
                        keys.push({
                            key: keyToAdd,
                            at: at
                        });
                        at = character === '@';
                        keyToAdd = '';
                    } else {
                        keyToAdd = keyToAdd.substr(0, keyToAdd.length - 1) + '.';
                    }
                } else {
                    keyToAdd += character;
                }
            }
            keys.push({
                key: keyToAdd,
                at: at
            });
            return keys;
        },
        write: function (parent, key, value, options) {
            var keys = typeof key === 'string' ? observeReader.reads(key) : key;
            var last;
            options = options || {};
            if (keys.length > 1) {
                last = keys.pop();
                parent = observeReader.read(parent, keys, options).value;
                keys.push(last);
            } else {
                last = keys[0];
            }
            var keyValue = peek(parent, last.key);
            if (observeReader.valueReadersMap.isValueLike.test(keyValue, keys.length - 1, keys, options)) {
                observeReader.valueReadersMap.isValueLike.write(keyValue, value, options);
            } else {
                if (observeReader.valueReadersMap.isValueLike.test(parent, keys.length - 1, keys, options)) {
                    parent = parent[getValueSymbol]();
                }
                if (observeReader.propertyReadersMap.map.test(parent)) {
                    observeReader.propertyReadersMap.map.write(parent, last.key, value, options);
                } else if (observeReader.propertyReadersMap.object.test(parent)) {
                    observeReader.propertyReadersMap.object.write(parent, last.key, value, options);
                    if (options.observation) {
                        options.observation.update();
                    }
                }
            }
        }
    };
    each(observeReader.propertyReaders, function (reader) {
        observeReader.propertyReadersMap[reader.name] = reader;
    });
    each(observeReader.valueReaders, function (reader) {
        observeReader.valueReadersMap[reader.name] = reader;
    });
    observeReader.set = observeReader.write;
    module.exports = observeReader;
});
/*can-view-scope@4.0.1#template-context*/
define('can-view-scope@4.0.1#template-context', [
    'require',
    'exports',
    'module',
    'can-simple-map'
], function (require, exports, module) {
    var SimpleMap = require('can-simple-map');
    var TemplateContext = function () {
        this.vars = new SimpleMap({});
        this.helpers = new SimpleMap({});
        this.partials = new SimpleMap({});
        this.tags = new SimpleMap({});
    };
    module.exports = TemplateContext;
});
/*can-define-lazy-value@1.0.1#define-lazy-value*/
define('can-define-lazy-value@1.0.1#define-lazy-value', function (require, exports, module) {
    module.exports = function defineLazyValue(obj, prop, initializer, writable) {
        Object.defineProperty(obj, prop, {
            configurable: true,
            get: function () {
                Object.defineProperty(this, prop, {
                    value: undefined,
                    writable: true
                });
                var value = initializer.call(this, obj, prop);
                Object.defineProperty(this, prop, {
                    value: value,
                    writable: !!writable
                });
                return value;
            },
            set: function (value) {
                Object.defineProperty(this, prop, {
                    value: value,
                    writable: !!writable
                });
                return value;
            }
        });
    };
});
/*can-event-queue@1.0.0#value/value*/
define('can-event-queue@1.0.0#value/value', [
    'require',
    'exports',
    'module',
    'can-queues',
    'can-key-tree',
    'can-reflect',
    'can-define-lazy-value',
    '../dependency-record/merge'
], function (require, exports, module) {
    var queues = require('can-queues');
    var KeyTree = require('can-key-tree');
    var canReflect = require('can-reflect');
    var defineLazyValue = require('can-define-lazy-value');
    var mergeDependencyRecords = require('../dependency-record/merge');
    var properties = {
        on: function (handler, queue) {
            this.handlers.add([
                queue || 'mutate',
                handler
            ]);
        },
        off: function (handler, queueName) {
            if (handler === undefined) {
                if (queueName === undefined) {
                    this.handlers.delete([]);
                } else {
                    this.handlers.delete([queueName]);
                }
            } else {
                this.handlers.delete([
                    queueName || 'mutate',
                    handler
                ]);
            }
        }
    };
    var symbols = {
        'can.onValue': properties.on,
        'can.offValue': properties.off,
        'can.dispatch': function (value, old) {
            queues.enqueueByQueue(this.handlers.getNode([]), this, [
                value,
                old
            ]);
        },
        'can.getWhatIChange': function getWhatIChange() {
        },
        'can.isBound': function isBound() {
            return this.handlers.size() > 0;
        }
    };
    function defineLazyHandlers() {
        return new KeyTree([
            Object,
            Array
        ], {
            onFirst: this.onBound !== undefined && this.onBound.bind(this),
            onEmpty: this.onUnbound !== undefined && this.onUnbound.bind(this)
        });
    }
    var mixinValueEventBindings = function (obj) {
        canReflect.assign(obj, properties);
        canReflect.assignSymbols(obj, symbols);
        defineLazyValue(obj, 'handlers', defineLazyHandlers, true);
        return obj;
    };
    mixinValueEventBindings.addHandlers = function (obj, callbacks) {
        console.warn('can-event-queue/value: Avoid using addHandlers. Add onBound and onUnbound methods instead.');
        obj.handlers = new KeyTree([
            Object,
            Array
        ], callbacks);
        return obj;
    };
    module.exports = mixinValueEventBindings;
});
/*can-observation@4.0.0#recorder-dependency-helpers*/
define('can-observation@4.0.0#recorder-dependency-helpers', [
    'require',
    'exports',
    'module',
    'can-reflect'
], function (require, exports, module) {
    var canReflect = require('can-reflect');
    function addNewKeyDependenciesIfNotInOld(event) {
        if (this.oldEventSet === undefined || this.oldEventSet['delete'](event) === false) {
            canReflect.onKeyValue(this.observable, event, this.onDependencyChange, 'notify');
        }
    }
    function addObservablesNewKeyDependenciesIfNotInOld(eventSet, observable) {
        eventSet.forEach(addNewKeyDependenciesIfNotInOld, {
            onDependencyChange: this.onDependencyChange,
            observable: observable,
            oldEventSet: this.oldDependencies.keyDependencies.get(observable)
        });
    }
    function removeKeyDependencies(event) {
        canReflect.offKeyValue(this.observable, event, this.onDependencyChange, 'notify');
    }
    function removeObservablesKeyDependencies(oldEventSet, observable) {
        oldEventSet.forEach(removeKeyDependencies, {
            onDependencyChange: this.onDependencyChange,
            observable: observable
        });
    }
    function addValueDependencies(observable) {
        if (this.oldDependencies.valueDependencies.delete(observable) === false) {
            canReflect.onValue(observable, this.onDependencyChange, 'notify');
        }
    }
    function removeValueDependencies(observable) {
        canReflect.offValue(observable, this.onDependencyChange, 'notify');
    }
    module.exports = {
        updateObservations: function (observationData) {
            observationData.newDependencies.keyDependencies.forEach(addObservablesNewKeyDependenciesIfNotInOld, observationData);
            observationData.oldDependencies.keyDependencies.forEach(removeObservablesKeyDependencies, observationData);
            observationData.newDependencies.valueDependencies.forEach(addValueDependencies, observationData);
            observationData.oldDependencies.valueDependencies.forEach(removeValueDependencies, observationData);
        },
        stopObserving: function (observationReciever, onDependencyChange) {
            observationReciever.keyDependencies.forEach(removeObservablesKeyDependencies, { onDependencyChange: onDependencyChange });
            observationReciever.valueDependencies.forEach(removeValueDependencies, { onDependencyChange: onDependencyChange });
        }
    };
});
/*can-observation@4.0.0#temporarily-bind*/
define('can-observation@4.0.0#temporarily-bind', [
    'require',
    'exports',
    'module',
    'can-reflect'
], function (require, exports, module) {
    var canReflect = require('can-reflect');
    var temporarilyBoundNoOperation = function () {
    };
    var observables;
    var unbindTemporarilyBoundValue = function () {
        for (var i = 0, len = observables.length; i < len; i++) {
            canReflect.offValue(observables[i], temporarilyBoundNoOperation);
        }
        observables = null;
    };
    function temporarilyBind(compute) {
        var computeInstance = compute.computeInstance || compute;
        canReflect.onValue(computeInstance, temporarilyBoundNoOperation);
        if (!observables) {
            observables = [];
            setTimeout(unbindTemporarilyBoundValue, 10);
        }
        observables.push(computeInstance);
    }
    module.exports = temporarilyBind;
});
/*can-observation@4.0.0#can-observation*/
define('can-observation@4.0.0#can-observation', [
    'require',
    'exports',
    'module',
    'can-namespace',
    'can-reflect',
    'can-queues',
    'can-observation-recorder',
    'can-symbol',
    'can-log/dev/dev',
    'can-event-queue/value/value',
    './recorder-dependency-helpers',
    './temporarily-bind'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        var namespace = require('can-namespace');
        var canReflect = require('can-reflect');
        var queues = require('can-queues');
        var ObservationRecorder = require('can-observation-recorder');
        var canSymbol = require('can-symbol');
        var dev = require('can-log/dev/dev');
        var valueEventBindings = require('can-event-queue/value/value');
        var recorderHelpers = require('./recorder-dependency-helpers');
        var temporarilyBind = require('./temporarily-bind');
        var dispatchSymbol = canSymbol.for('can.dispatch');
        var getChangesSymbol = canSymbol.for('can.getChangesDependencyRecord');
        var getValueDependenciesSymbol = canSymbol.for('can.getValueDependencies');
        function Observation(func, context, options) {
            this.func = func;
            this.context = context;
            this.options = options || {
                priority: 0,
                isObservable: true
            };
            this.bound = false;
            this.newDependencies = ObservationRecorder.makeDependenciesRecord();
            this.oldDependencies = null;
            var self = this;
            this.onDependencyChange = function (newVal) {
                self.dependencyChange(this, newVal);
            };
            this.update = this.update.bind(this);
        }
        valueEventBindings(Observation.prototype);
        canReflect.assign(Observation.prototype, {
            onBound: function () {
                this.bound = true;
                this.oldDependencies = this.newDependencies;
                ObservationRecorder.start();
                this.value = this.func.call(this.context);
                this.newDependencies = ObservationRecorder.stop();
                recorderHelpers.updateObservations(this);
            },
            dependencyChange: function (context, args) {
                if (this.bound === true) {
                    queues.deriveQueue.enqueue(this.update, this, [], { priority: this.options.priority });
                }
            },
            update: function () {
                if (this.bound === true) {
                    var oldValue = this.value;
                    this.oldValue = null;
                    this.onBound();
                    if (oldValue !== this.value) {
                        this[dispatchSymbol](this.value, oldValue);
                    }
                }
            },
            onUnbound: function () {
                this.bound = false;
                recorderHelpers.stopObserving(this.newDependencies, this.onDependencyChange);
                this.newDependencies = ObservationRecorder.makeDependenciesRecorder();
            },
            get: function () {
                if (this.options.isObservable && ObservationRecorder.isRecording()) {
                    ObservationRecorder.add(this);
                    if (!this.bound) {
                        Observation.temporarilyBind(this);
                    }
                }
                if (this.bound === true) {
                    if (queues.deriveQueue.tasksRemainingCount() > 0) {
                        Observation.updateChildrenAndSelf(this);
                    }
                    return this.value;
                } else {
                    return this.func.call(this.context);
                }
            },
            hasDependencies: function () {
                var newDependencies = this.newDependencies;
                return this.bound ? newDependencies.valueDependencies.size + newDependencies.keyDependencies.size > 0 : undefined;
            },
            log: function () {
            }
        });
        canReflect.assignSymbols(Observation.prototype, {
            'can.getValue': Observation.prototype.get,
            'can.isValueLike': true,
            'can.isMapLike': false,
            'can.isListLike': false,
            'can.valueHasDependencies': Observation.prototype.hasDependencies,
            'can.getValueDependencies': function () {
                if (this.bound === true) {
                    var deps = this.newDependencies, result = {};
                    if (deps.keyDependencies.size) {
                        result.keyDependencies = deps.keyDependencies;
                    }
                    if (deps.valueDependencies.size) {
                        result.valueDependencies = deps.valueDependencies;
                    }
                    return result;
                }
                return undefined;
            },
            'can.getPriority': function () {
                return this.options.priority;
            },
            'can.setPriority': function (priority) {
                this.options.priority = priority;
            }
        });
        Observation.updateChildrenAndSelf = function (observation) {
            if (observation.update !== undefined && queues.deriveQueue.isEnqueued(observation.update) === true) {
                queues.deriveQueue.flushQueuedTask(observation.update);
                return true;
            }
            if (observation[getValueDependenciesSymbol]) {
                var childHasChanged = false;
                var valueDependencies = observation[getValueDependenciesSymbol]().valueDependencies || [];
                valueDependencies.forEach(function (observable) {
                    if (Observation.updateChildrenAndSelf(observable) === true) {
                        childHasChanged = true;
                    }
                });
                return childHasChanged;
            } else {
                return false;
            }
        };
        var alias = { addAll: 'addMany' };
        [
            'add',
            'addAll',
            'ignore',
            'trap',
            'trapsCount',
            'isRecording'
        ].forEach(function (methodName) {
            Observation[methodName] = function () {
                var name = alias[methodName] ? alias[methodName] : methodName;
                console.warn('can-observation: Call ' + name + '() on can-observation-recorder.');
                return ObservationRecorder[name].apply(this, arguments);
            };
        });
        Observation.prototype.start = function () {
            console.warn('can-observation: Use .on and .off to bind.');
            return this.onBound();
        };
        Observation.prototype.stop = function () {
            console.warn('can-observation: Use .on and .off to bind.');
            return this.onUnbound();
        };
        Observation.temporarilyBind = temporarilyBind;
        module.exports = namespace.Observation = Observation;
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-cid@1.1.2#can-cid*/
define('can-cid@1.1.2#can-cid', [
    'require',
    'exports',
    'module',
    'can-namespace'
], function (require, exports, module) {
    var namespace = require('can-namespace');
    var _cid = 0;
    var domExpando = 'can' + new Date();
    var cid = function (object, name) {
        var propertyName = object.nodeName ? domExpando : '_cid';
        if (!object[propertyName]) {
            _cid++;
            object[propertyName] = (name || '') + _cid;
        }
        return object[propertyName];
    };
    cid.domExpando = domExpando;
    cid.get = function (object) {
        var type = typeof object;
        var isObject = type !== null && (type === 'object' || type === 'function');
        return isObject ? cid(object) : type + ':' + object;
    };
    if (namespace.cid) {
        throw new Error('You can\'t have two versions of can-cid, check your dependencies');
    } else {
        module.exports = namespace.cid = cid;
    }
});
/*can-cid@1.1.2#helpers*/
define('can-cid@1.1.2#helpers', function (require, exports, module) {
    module.exports = {
        each: function (obj, cb, context) {
            for (var prop in obj) {
                cb.call(context, obj[prop], prop);
            }
            return obj;
        }
    };
});
/*can-cid@1.1.2#set/set*/
define('can-cid@1.1.2#set/set', [
    'require',
    'exports',
    'module',
    '../can-cid',
    '../helpers'
], function (require, exports, module) {
    'use strict';
    var getCID = require('../can-cid').get;
    var helpers = require('../helpers');
    var CIDSet;
    if (typeof Set !== 'undefined') {
        CIDSet = Set;
    } else {
        var CIDSet = function () {
            this.values = {};
        };
        CIDSet.prototype.add = function (value) {
            this.values[getCID(value)] = value;
        };
        CIDSet.prototype['delete'] = function (key) {
            var has = getCID(key) in this.values;
            if (has) {
                delete this.values[getCID(key)];
            }
            return has;
        };
        CIDSet.prototype.forEach = function (cb, thisArg) {
            helpers.each(this.values, cb, thisArg);
        };
        CIDSet.prototype.has = function (value) {
            return getCID(value) in this.values;
        };
        CIDSet.prototype.clear = function () {
            return this.values = {};
        };
        Object.defineProperty(CIDSet.prototype, 'size', {
            get: function () {
                var size = 0;
                helpers.each(this.values, function () {
                    size++;
                });
                return size;
            }
        });
    }
    module.exports = CIDSet;
});
/*can-util@3.11.2#js/single-reference/single-reference*/
define('can-util@3.11.2#js/single-reference/single-reference', [
    'require',
    'exports',
    'module',
    'can-cid'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        var CID = require('can-cid');
        var singleReference;
        function getKeyName(key, extraKey) {
            var keyName = extraKey ? CID(key) + ':' + extraKey : CID(key);
            return keyName || key;
        }
        singleReference = {
            set: function (obj, key, value, extraKey) {
                obj[getKeyName(key, extraKey)] = value;
            },
            getAndDelete: function (obj, key, extraKey) {
                var keyName = getKeyName(key, extraKey);
                var value = obj[keyName];
                delete obj[keyName];
                return value;
            }
        };
        module.exports = singleReference;
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-view-scope@4.0.1#make-compute-like*/
define('can-view-scope@4.0.1#make-compute-like', [
    'require',
    'exports',
    'module',
    'can-util/js/single-reference/single-reference',
    'can-reflect'
], function (require, exports, module) {
    var singleReference = require('can-util/js/single-reference/single-reference');
    var canReflect = require('can-reflect');
    var Compute = function (newVal) {
        if (arguments.length) {
            return canReflect.setValue(this, newVal);
        } else {
            return canReflect.getValue(this);
        }
    };
    module.exports = function (observable) {
        var compute = Compute.bind(observable);
        compute.on = compute.bind = compute.addEventListener = function (event, handler) {
            var translationHandler = function (newVal, oldVal) {
                handler.call(compute, { type: 'change' }, newVal, oldVal);
            };
            singleReference.set(handler, this, translationHandler);
            observable.on(translationHandler);
        };
        compute.off = compute.unbind = compute.removeEventListener = function (event, handler) {
            observable.off(singleReference.getAndDelete(handler, this));
        };
        canReflect.assignSymbols(compute, {
            'can.getValue': function () {
                return canReflect.getValue(observable);
            },
            'can.setValue': function (newVal) {
                return canReflect.setValue(observable, newVal);
            },
            'can.onValue': function (handler, queue) {
                return canReflect.onValue(observable, handler, queue);
            },
            'can.offValue': function (handler, queue) {
                return canReflect.offValue(observable, handler, queue);
            },
            'can.valueHasDependencies': function () {
                return canReflect.valueHasDependencies(observable);
            },
            'can.getPriority': function () {
                return canReflect.getPriority(observable);
            },
            'can.setPriority': function (newPriority) {
                canReflect.setPriority(observable, newPriority);
            },
            'can.isValueLike': true,
            'can.isFunctionLike': false
        });
        compute.isComputed = true;
        return compute;
    };
});
/*can-reflect-dependencies@1.0.0#src/add-mutated-by*/
define('can-reflect-dependencies@1.0.0#src/add-mutated-by', [
    'require',
    'exports',
    'module',
    'can-reflect'
], function (require, exports, module) {
    var canReflect = require('can-reflect');
    var makeDependencyRecord = function makeDependencyRecord() {
        return {
            keyDependencies: new Map(),
            valueDependencies: new Set()
        };
    };
    var makeRootRecord = function makeRootRecord() {
        return {
            mutateDependenciesForKey: new Map(),
            mutateDependenciesForValue: makeDependencyRecord()
        };
    };
    module.exports = function (mutatedByMap) {
        return function addMutatedBy(mutated, key, mutator) {
            var gotKey = arguments.length === 3;
            if (arguments.length === 2) {
                mutator = key;
                key = undefined;
            }
            if (!mutator.keyDependencies && !mutator.valueDependencies) {
                mutator = { valueDependencies: new Set([mutator]) };
            }
            var root = mutatedByMap.get(mutated);
            if (!root) {
                root = makeRootRecord();
                mutatedByMap.set(mutated, root);
            }
            if (gotKey) {
                root.mutateDependenciesForKey.set(key, makeDependencyRecord());
            }
            var dependencyRecord = gotKey ? root.mutateDependenciesForKey.get(key) : root.mutateDependenciesForValue;
            if (mutator.valueDependencies) {
                canReflect.addValues(dependencyRecord.valueDependencies, mutator.valueDependencies);
            }
            if (mutator.keyDependencies) {
                canReflect.each(mutator.keyDependencies, function (keysSet, obj) {
                    var entry = dependencyRecord.keyDependencies.get(obj);
                    if (!entry) {
                        entry = new Set();
                        dependencyRecord.keyDependencies.set(obj, entry);
                    }
                    canReflect.addValues(entry, keysSet);
                });
            }
        };
    };
});
/*can-reflect-dependencies@1.0.0#src/delete-mutated-by*/
define('can-reflect-dependencies@1.0.0#src/delete-mutated-by', [
    'require',
    'exports',
    'module',
    'can-reflect'
], function (require, exports, module) {
    var canReflect = require('can-reflect');
    module.exports = function (mutatedByMap) {
        return function deleteMutatedBy(mutated, key, mutator) {
            var gotKey = arguments.length === 3;
            var root = mutatedByMap.get(mutated);
            if (arguments.length === 2) {
                mutator = key;
                key = undefined;
            }
            if (!mutator.keyDependencies && !mutator.valueDependencies) {
                mutator = { valueDependencies: new Set([mutator]) };
            }
            var dependencyRecord = gotKey ? root.mutateDependenciesForKey.get(key) : root.mutateDependenciesForValue;
            if (mutator.valueDependencies) {
                canReflect.removeValues(dependencyRecord.valueDependencies, mutator.valueDependencies);
            }
            if (mutator.keyDependencies) {
                canReflect.each(mutator.keyDependencies, function (keysSet, obj) {
                    var entry = dependencyRecord.keyDependencies.get(obj);
                    if (entry) {
                        canReflect.removeValues(entry, keysSet);
                        if (!entry.size) {
                            dependencyRecord.keyDependencies.delete(obj);
                        }
                    }
                });
            }
        };
    };
});
/*can-reflect-dependencies@1.0.0#src/is-function*/
define('can-reflect-dependencies@1.0.0#src/is-function', function (require, exports, module) {
    module.exports = function isFunction(value) {
        return typeof value === 'function';
    };
});
/*can-reflect-dependencies@1.0.0#src/get-dependency-data-of*/
define('can-reflect-dependencies@1.0.0#src/get-dependency-data-of', [
    'require',
    'exports',
    'module',
    'can-symbol',
    'can-reflect',
    './is-function'
], function (require, exports, module) {
    var canSymbol = require('can-symbol');
    var canReflect = require('can-reflect');
    var isFunction = require('./is-function');
    var getWhatIChangeSymbol = canSymbol.for('can.getWhatIChange');
    var getKeyDependenciesSymbol = canSymbol.for('can.getKeyDependencies');
    var getValueDependenciesSymbol = canSymbol.for('can.getValueDependencies');
    var getKeyDependencies = function getKeyDependencies(obj, key) {
        if (isFunction(obj[getKeyDependenciesSymbol])) {
            return canReflect.getKeyDependencies(obj, key);
        }
    };
    var getValueDependencies = function getValueDependencies(obj) {
        if (isFunction(obj[getValueDependenciesSymbol])) {
            return canReflect.getValueDependencies(obj);
        }
    };
    var getMutatedKeyDependencies = function getMutatedKeyDependencies(mutatedByMap, obj, key) {
        var root = mutatedByMap.get(obj);
        var dependencyRecord;
        if (root && root.mutateDependenciesForKey.has(key)) {
            dependencyRecord = root.mutateDependenciesForKey.get(key);
        }
        return dependencyRecord;
    };
    var getMutatedValueDependencies = function getMutatedValueDependencies(mutatedByMap, obj) {
        var result;
        var root = mutatedByMap.get(obj);
        if (root) {
            var dependencyRecord = root.mutateDependenciesForValue;
            if (dependencyRecord.keyDependencies.size) {
                result = result || {};
                result.keyDependencies = dependencyRecord.keyDependencies;
            }
            if (dependencyRecord.valueDependencies.size) {
                result = result || {};
                result.valueDependencies = dependencyRecord.valueDependencies;
            }
        }
        return result;
    };
    var getWhatIChange = function getWhatIChange(obj, key) {
        if (isFunction(obj[getWhatIChangeSymbol])) {
            var gotKey = arguments.length === 2;
            return gotKey ? canReflect.getWhatIChange(obj, key) : canReflect.getWhatIChange(obj);
        }
    };
    var isEmptyRecord = function isEmptyRecord(record) {
        return record == null || !Object.keys(record).length || record.keyDependencies && !record.keyDependencies.size && (record.valueDependencies && !record.valueDependencies.size);
    };
    var getWhatChangesMe = function getWhatChangesMe(mutatedByMap, obj, key) {
        var gotKey = arguments.length === 3;
        var mutate = gotKey ? getMutatedKeyDependencies(mutatedByMap, obj, key) : getMutatedValueDependencies(mutatedByMap, obj);
        var derive = gotKey ? getKeyDependencies(obj, key) : getValueDependencies(obj);
        if (!isEmptyRecord(mutate) || !isEmptyRecord(derive)) {
            return Object.assign({}, mutate ? { mutate: mutate } : null, derive ? { derive: derive } : null);
        }
    };
    module.exports = function (mutatedByMap) {
        return function getDependencyDataOf(obj, key) {
            var gotKey = arguments.length === 2;
            var whatChangesMe = gotKey ? getWhatChangesMe(mutatedByMap, obj, key) : getWhatChangesMe(mutatedByMap, obj);
            var whatIChange = gotKey ? getWhatIChange(obj, key) : getWhatIChange(obj);
            if (whatChangesMe || whatIChange) {
                return Object.assign({}, whatIChange ? { whatIChange: whatIChange } : null, whatChangesMe ? { whatChangesMe: whatChangesMe } : null);
            }
        };
    };
});
/*can-reflect-dependencies@1.0.0#can-reflect-dependencies*/
define('can-reflect-dependencies@1.0.0#can-reflect-dependencies', [
    'require',
    'exports',
    'module',
    './src/add-mutated-by',
    './src/delete-mutated-by',
    './src/get-dependency-data-of'
], function (require, exports, module) {
    var addMutatedBy = require('./src/add-mutated-by');
    var deleteMutatedBy = require('./src/delete-mutated-by');
    var getDependencyDataOf = require('./src/get-dependency-data-of');
    var mutatedByMap = new WeakMap();
    module.exports = {
        addMutatedBy: addMutatedBy(mutatedByMap),
        deleteMutatedBy: deleteMutatedBy(mutatedByMap),
        getDependencyDataOf: getDependencyDataOf(mutatedByMap)
    };
});
/*can-view-scope@4.0.1#scope-key-data*/
define('can-view-scope@4.0.1#scope-key-data', [
    'require',
    'exports',
    'module',
    'can-observation',
    'can-stache-key',
    'can-assign',
    'can-reflect',
    'can-symbol',
    'can-observation-recorder',
    'can-cid/set/set',
    './make-compute-like',
    'can-reflect-dependencies',
    'can-event-queue/value/value'
], function (require, exports, module) {
    'use strict';
    var Observation = require('can-observation');
    var observeReader = require('can-stache-key');
    var assign = require('can-assign');
    var canReflect = require('can-reflect');
    var canSymbol = require('can-symbol');
    var ObservationRecorder = require('can-observation-recorder');
    var CIDSet = require('can-cid/set/set');
    var makeComputeLike = require('./make-compute-like');
    var canReflectDeps = require('can-reflect-dependencies');
    var valueEventBindings = require('can-event-queue/value/value');
    var dispatchSymbol = canSymbol.for('can.dispatch');
    var peekValue = ObservationRecorder.ignore(canReflect.getValue.bind(canReflect));
    var getFastPathRoot = ObservationRecorder.ignore(function (computeData) {
        if (computeData.reads && computeData.reads.length === 1) {
            var root = computeData.root;
            if (root && root[canSymbol.for('can.getValue')]) {
                root = canReflect.getValue(root);
            }
            return root && canReflect.isObservableLike(root) && canReflect.isMapLike(root) && typeof root[computeData.reads[0].key] !== 'function' && root;
        }
        return;
    });
    var isEventObject = function (obj) {
        return obj && typeof obj.batchNum === 'number' && typeof obj.type === 'string';
    };
    var ScopeKeyData = function (scope, key, options) {
        this.startingScope = scope;
        this.key = key;
        this.read = this.read.bind(this);
        this.dispatch = this.dispatch.bind(this);
        var observation = this.observation = new Observation(this.read, this);
        this.options = assign({ observation: this.observation }, options);
        this.fastPath = undefined;
        this.root = undefined;
        this.initialValue = undefined;
        this.reads = undefined;
        this.setRoot = undefined;
        this.thisArg = undefined;
        var valueDependencies = new CIDSet();
        valueDependencies.add(observation);
        this.dependencies = { valueDependencies: valueDependencies };
    };
    valueEventBindings(ScopeKeyData.prototype);
    Object.assign(ScopeKeyData.prototype, {
        constructor: ScopeKeyData,
        dispatch: function dispatch(newVal) {
            var old = this.value;
            this.value = newVal;
            this[dispatchSymbol].call(this, this.value, old);
        },
        onBound: function onBound() {
            this.bound = true;
            canReflect.onValue(this.observation, this.dispatch, 'notify');
            var fastPathRoot = getFastPathRoot(this);
            if (fastPathRoot) {
                this.toFastPath(fastPathRoot);
            }
            this.value = peekValue(this.observation);
        },
        onUnbound: function onUnbound() {
            this.bound = false;
            canReflect.offValue(this.observation, this.dispatch, 'notify');
            this.toSlowPath();
        },
        set: function (newVal) {
            var root = this.root || this.setRoot;
            if (root) {
                observeReader.write(root, this.reads, newVal, this.options);
            } else {
                this.startingScope.set(this.key, newVal, this.options);
            }
        },
        get: function () {
            if (ObservationRecorder.isRecording()) {
                ObservationRecorder.add(this);
                if (!this.bound) {
                    Observation.temporarilyBind(this);
                }
            }
            if (this.bound === true) {
                return this.value;
            } else {
                return this.observation.get();
            }
        },
        toFastPath: function (fastPathRoot) {
            var self = this, observation = this.observation;
            this.fastPath = true;
            observation.dependencyChange = function (target, newVal) {
                if (isEventObject(newVal)) {
                    throw 'no event objects!';
                }
                if (target === fastPathRoot && typeof newVal !== 'function') {
                    this.newVal = newVal;
                } else {
                    self.toSlowPath();
                }
                return Observation.prototype.dependencyChange.apply(this, arguments);
            };
            observation.onBound = function () {
                this.value = this.newVal;
            };
        },
        toSlowPath: function () {
            this.observation.dependencyChange = Observation.prototype.dependencyChange;
            this.observation.onBound = Observation.prototype.onBound;
            this.fastPath = false;
        },
        read: function () {
            if (this.root) {
                return observeReader.read(this.root, this.reads, this.options).value;
            }
            var data = this.startingScope.read(this.key, this.options);
            this.scope = data.scope;
            this.reads = data.reads;
            this.root = data.rootObserve;
            this.setRoot = data.setRoot;
            this.thisArg = data.thisArg;
            return this.initialValue = data.value;
        },
        hasDependencies: function () {
            return canReflect.valueHasDependencies(this.observation);
        }
    });
    canReflect.assignSymbols(ScopeKeyData.prototype, {
        'can.getValue': ScopeKeyData.prototype.get,
        'can.setValue': ScopeKeyData.prototype.set,
        'can.valueHasDependencies': ScopeKeyData.prototype.hasDependencies,
        'can.getValueDependencies': function () {
            var result = this.dependencies;
            if (this.fastPath) {
                var key = this.reads[0].key;
                var fastPathRoot = getFastPathRoot(this);
                result = {
                    keyDependencies: new Map([[
                            fastPathRoot,
                            new Set([key])
                        ]])
                };
            }
            return result;
        },
        'can.getPriority': function () {
            return canReflect.getPriority(this.observation);
        },
        'can.setPriority': function (newPriority) {
            canReflect.setPriority(this.observation, newPriority);
        }
    });
    Object.defineProperty(ScopeKeyData.prototype, 'compute', {
        get: function () {
            var compute = makeComputeLike(this);
            Object.defineProperty(this, 'compute', {
                value: compute,
                writable: false,
                configurable: false
            });
            return compute;
        },
        configurable: true
    });
    module.exports = ScopeKeyData;
});
/*can-view-scope@4.0.1#compute_data*/
define('can-view-scope@4.0.1#compute_data', [
    'require',
    'exports',
    'module',
    './scope-key-data'
], function (require, exports, module) {
    'use strict';
    var ScopeKeyData = require('./scope-key-data');
    module.exports = function (scope, key, options) {
        return new ScopeKeyData(scope, key, options || { args: [] });
    };
});
/*can-stache-helpers@1.0.0#can-stache-helpers*/
define('can-stache-helpers@1.0.0#can-stache-helpers', [
    'require',
    'exports',
    'module',
    'can-namespace'
], function (require, exports, module) {
    var namespace = require('can-namespace');
    if (namespace.stacheHelpers) {
        throw new Error('You can\'t have two versions of can-stache-helpers, check your dependencies');
    } else {
        module.exports = namespace.stacheHelpers = {};
    }
});
/*can-view-scope@4.0.1#can-view-scope*/
define('can-view-scope@4.0.1#can-view-scope', [
    'require',
    'exports',
    'module',
    'can-stache-key',
    'can-observation-recorder',
    './template-context',
    './compute_data',
    'can-assign',
    'can-util/js/each/each',
    'can-namespace',
    'can-reflect',
    'can-log/dev/dev',
    'can-define-lazy-value',
    'can-stache-helpers'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        var observeReader = require('can-stache-key');
        var ObservationRecorder = require('can-observation-recorder');
        var TemplateContext = require('./template-context');
        var makeComputeData = require('./compute_data');
        var assign = require('can-assign');
        var each = require('can-util/js/each/each');
        var namespace = require('can-namespace');
        var canReflect = require('can-reflect');
        var canLog = require('can-log/dev/dev');
        var defineLazyValue = require('can-define-lazy-value');
        var stacheHelpers = require('can-stache-helpers');
        function Scope(context, parent, meta) {
            this._context = context;
            this._parent = parent;
            this._meta = meta || {};
            this.__cache = {};
        }
        assign(Scope, {
            read: observeReader.read,
            keyInfo: function (attr) {
                var info = {};
                info.isDotSlash = attr.substr(0, 2) === './';
                info.isThisDot = attr.substr(0, 5) === 'this.';
                info.isThisAt = attr.substr(0, 5) === 'this@';
                info.isInCurrentContext = info.isDotSlash || info.isThisDot || info.isThisAt;
                info.isInParentContext = attr.substr(0, 3) === '../';
                info.isCurrentContext = attr === '.' || attr === 'this';
                info.isParentContext = attr === '..';
                info.isScope = attr === 'scope';
                info.isInScope = attr.substr(0, 6) === 'scope.' || attr.substr(0, 6) === 'scope@';
                info.isContextBased = info.isInCurrentContext || info.isInParentContext || info.isCurrentContext || info.isParentContext;
                return info;
            }
        });
        assign(Scope.prototype, {
            add: function (context, meta) {
                if (context !== this._context) {
                    return new this.constructor(context, this, meta);
                } else {
                    return this;
                }
            },
            find: function (attr, options) {
                return this.get(attr, assign({ currentScopeOnly: false }, options));
            },
            read: function (attr, options) {
                options = options || {};
                if (attr === './') {
                    attr = '.';
                }
                var keyInfo = Scope.keyInfo(attr);
                if (keyInfo.isContextBased && (this._meta.notContext || this._meta.special)) {
                    return this._parent.read(attr, options);
                }
                var currentScopeOnly = 'currentScopeOnly' in options ? options.currentScopeOnly : true;
                if (keyInfo.isInCurrentContext) {
                    currentScopeOnly = true;
                    attr = keyInfo.isDotSlash ? attr.substr(2) : attr.substr(5);
                } else if ((keyInfo.isInParentContext || keyInfo.isParentContext) && this._parent) {
                    var parent = this._parent;
                    while (parent._meta.notContext || parent._meta.special) {
                        parent = parent._parent;
                    }
                    if (keyInfo.isParentContext) {
                        return observeReader.read(parent._context, [], options);
                    }
                    var parentValue = parent.read(attr.substr(3) || '.', options);
                    return assign(parentValue, { thisArg: parentValue.thisArg || parent._context });
                } else if (keyInfo.isCurrentContext) {
                    return observeReader.read(this._context, [], options);
                } else if (keyInfo.isScope) {
                    return { value: this };
                }
                var keyReads = observeReader.reads(attr);
                var readValue;
                if (keyInfo.isInScope) {
                    readValue = observeReader.read(this, keyReads.slice(1), options);
                    if (typeof readValue.value === 'undefined') {
                        readValue = this.readFromTemplateContext(attr.slice(6), options);
                    }
                    return assign(readValue, { thisArg: keyReads.length > 1 ? readValue.parent : undefined });
                }
                return this._read(keyReads, options, currentScopeOnly);
            },
            readFromSpecialContext: function (key) {
                return this._read([{
                        key: key,
                        at: false
                    }], { special: true });
            },
            readFromTemplateContext: function (key, readOptions) {
                var keyReads = observeReader.reads(key);
                return observeReader.read(this.templateContext, keyReads, readOptions);
            },
            _read: function (keyReads, options, currentScopeOnly) {
                var currentScope = this, currentContext, undefinedObserves = [], currentObserve, currentReads, setObserveDepth = -1, currentSetReads, currentSetObserve, readOptions = assign({
                        foundObservable: function (observe, nameIndex) {
                            currentObserve = observe;
                            currentReads = keyReads.slice(nameIndex);
                        },
                        earlyExit: function (parentValue, nameIndex) {
                            if (nameIndex > setObserveDepth || nameIndex === setObserveDepth && (typeof parentValue === 'object' && keyReads[nameIndex].key in parentValue)) {
                                currentSetObserve = currentObserve;
                                currentSetReads = currentReads;
                                setObserveDepth = nameIndex;
                            }
                        }
                    }, options);
                var isRecording = ObservationRecorder.isRecording();
                while (currentScope) {
                    currentContext = currentScope._context;
                    if ((!options || options.special !== true) && currentScope._meta.special) {
                        currentScope = currentScope._parent;
                        continue;
                    }
                    if (options && options.special && !currentScope._meta.special) {
                        currentScope = currentScope._parent;
                        continue;
                    }
                    if (currentContext !== null && (typeof currentContext === 'object' || typeof currentContext === 'function')) {
                        var getObserves = ObservationRecorder.trap();
                        var data = observeReader.read(currentContext, keyReads, readOptions);
                        var observes = getObserves();
                        if (data.value !== undefined) {
                            if (!observes.length && isRecording) {
                                currentObserve = data.parent;
                                currentReads = keyReads.slice(keyReads.length - 1);
                            } else {
                                ObservationRecorder.addMany(observes);
                            }
                            return {
                                scope: currentScope,
                                rootObserve: currentObserve,
                                value: data.value,
                                reads: currentReads,
                                thisArg: keyReads.length > 1 ? data.parent : undefined
                            };
                        } else {
                            undefinedObserves.push.apply(undefinedObserves, observes);
                        }
                    }
                    var parentIsNormalContext = currentScope._parent && currentScope._parent._meta && !currentScope._parent._meta.notContext && !currentScope._parent._meta.special;
                    if (currentScopeOnly && parentIsNormalContext) {
                        currentScope = null;
                    } else {
                        currentScope = currentScope._parent;
                    }
                }
                if (!(options && options.special)) {
                    var helper = this.getHelper(keyReads);
                    if (helper && helper.value) {
                        return helper;
                    }
                }
                ObservationRecorder.addMany(undefinedObserves);
                return {
                    setRoot: currentSetObserve,
                    reads: currentSetReads,
                    value: undefined
                };
            },
            getHelper: function (keyReads) {
                var helper = observeReader.read(this.templateContext.helpers, keyReads, { proxyMethods: false });
                if (!helper || !helper.value) {
                    helper = observeReader.read(stacheHelpers, keyReads, { proxyMethods: false });
                }
                return helper;
            },
            get: function (key, options) {
                options = assign({ isArgument: true }, options);
                var res = this.read(key, options);
                return res.value;
            },
            peek: ObservationRecorder.ignore(function (key, options) {
                return this.get(key, options);
            }),
            peak: ObservationRecorder.ignore(function (key, options) {
                return this.peek(key, options);
            }),
            getScope: function (tester) {
                var scope = this;
                while (scope) {
                    if (tester(scope)) {
                        return scope;
                    }
                    scope = scope._parent;
                }
            },
            getContext: function (tester) {
                var res = this.getScope(tester);
                return res && res._context;
            },
            getTemplateContext: function () {
                var lastScope;
                var templateContext = this.getScope(function (scope) {
                    lastScope = scope;
                    return scope._context instanceof TemplateContext;
                });
                if (!templateContext) {
                    templateContext = new Scope(new TemplateContext());
                    lastScope._parent = templateContext;
                }
                return templateContext;
            },
            getRoot: function () {
                var cur = this, child = this;
                while (cur._parent) {
                    child = cur;
                    cur = cur._parent;
                }
                if (cur._context instanceof TemplateContext) {
                    cur = child;
                }
                return cur._context;
            },
            getDataForScopeSet: function getDataForScopeSet(key, options) {
                var keyInfo = Scope.keyInfo(key), parent;
                if (keyInfo.isCurrentContext) {
                    return {
                        parent: this._context,
                        how: 'setValue'
                    };
                } else if (keyInfo.isInParentContext || keyInfo.isParentContext) {
                    parent = this._parent;
                    while (parent._meta.notContext) {
                        parent = parent._parent;
                    }
                    if (keyInfo.isParentContext) {
                        return {
                            parent: parent._context,
                            how: 'setValue'
                        };
                    }
                    return {
                        how: 'set',
                        parent: parent,
                        passOptions: true,
                        key: key.substr(3) || '.'
                    };
                }
                var dotIndex = key.lastIndexOf('.'), slashIndex = key.lastIndexOf('/'), contextPath, propName;
                if (slashIndex > dotIndex) {
                    contextPath = key.substring(0, slashIndex);
                    propName = key.substring(slashIndex + 1, key.length);
                } else {
                    if (dotIndex !== -1) {
                        contextPath = key.substring(0, dotIndex);
                        propName = key.substring(dotIndex + 1, key.length);
                    } else {
                        contextPath = '.';
                        propName = key;
                    }
                }
                var context = this.read(contextPath, options).value;
                if (context === undefined) {
                    return { error: 'Attempting to set a value at ' + key + ' where ' + contextPath + ' is undefined.' };
                }
                if (!canReflect.isObservableLike(context) && canReflect.isObservableLike(context[propName])) {
                    if (canReflect.isMapLike(context[propName])) {
                        return {
                            parent: context,
                            key: propName,
                            how: 'updateDeep',
                            warn: 'can-view-scope: Merging data into "' + propName + '" because its parent is non-observable'
                        };
                    } else if (canReflect.isValueLike(context[propName])) {
                        return {
                            parent: context,
                            key: propName,
                            how: 'setValue'
                        };
                    } else {
                        return {
                            parent: context,
                            how: 'write',
                            key: propName,
                            passOptions: true
                        };
                    }
                } else {
                    return {
                        parent: context,
                        how: 'write',
                        key: propName,
                        passOptions: true
                    };
                }
            },
            set: function (key, value, options) {
                options = options || {};
                var data = this.getDataForScopeSet(key, options);
                var parent = data.parent;
                if (data.warn) {
                    canLog.warn(data.warn);
                }
                switch (data.how) {
                case 'set':
                    parent.set(data.key, value, data.passOptions ? options : undefined);
                    break;
                case 'write':
                    observeReader.write(parent, data.key, value, options);
                    break;
                case 'setValue':
                    canReflect.setValue('key' in data ? parent[data.key] : parent, value);
                    break;
                case 'setKeyValue':
                    canReflect.setKeyValue(parent, data.key, value);
                    break;
                case 'updateDeep':
                    canReflect.updateDeep(parent[data.key], value);
                    break;
                }
            },
            attr: ObservationRecorder.ignore(function (key, value, options) {
                canLog.warn('can-view-scope::attr is deprecated, please use peek, get or set');
                options = assign({ isArgument: true }, options);
                if (arguments.length === 2) {
                    return this.set(key, value, options);
                } else {
                    return this.get(key, options);
                }
            }),
            computeData: function (key, options) {
                return makeComputeData(this, key, options);
            },
            compute: function (key, options) {
                return this.computeData(key, options).compute;
            },
            cloneFromRef: function () {
                var contexts = [];
                var scope = this, context, parent;
                while (scope) {
                    context = scope._context;
                    if (context instanceof TemplateContext) {
                        parent = scope._parent;
                        break;
                    }
                    contexts.unshift(context);
                    scope = scope._parent;
                }
                if (parent) {
                    each(contexts, function (context) {
                        parent = parent.add(context);
                    });
                    return parent;
                } else {
                    return this;
                }
            }
        });
        var templateContextPrimitives = [
            'filename',
            'lineNumber'
        ];
        templateContextPrimitives.forEach(function (key) {
            Object.defineProperty(Scope.prototype, key, {
                get: function () {
                    return this.readFromTemplateContext(key).value;
                },
                set: function (val) {
                    this.templateContext[key] = val;
                }
            });
        });
        defineLazyValue(Scope.prototype, 'templateContext', function () {
            return this.getTemplateContext()._context;
        });
        defineLazyValue(Scope.prototype, 'root', function () {
            return this.getRoot();
        });
        defineLazyValue(Scope.prototype, 'helpers', function () {
            return stacheHelpers;
        });
        var specialKeywords = [
            'index',
            'key',
            'element',
            'event',
            'viewModel',
            'arguments',
            'helperOptions'
        ];
        specialKeywords.forEach(function (key) {
            Object.defineProperty(Scope.prototype, key, {
                get: function () {
                    return this.readFromSpecialContext(key).value;
                }
            });
        });
        namespace.view = namespace.view || {};
        module.exports = namespace.view.Scope = Scope;
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-simple-observable@2.0.1#log*/
define('can-simple-observable@2.0.1#log', [
    'require',
    'exports',
    'module',
    'can-log/dev/dev',
    'can-reflect'
], function (require, exports, module) {
    var dev = require('can-log/dev/dev');
    var canReflect = require('can-reflect');
    function quoteString(x) {
        return typeof x === 'string' ? JSON.stringify(x) : x;
    }
    module.exports = function log() {
    };
});
/*can-simple-observable@2.0.1#can-simple-observable*/
define('can-simple-observable@2.0.1#can-simple-observable', [
    'require',
    'exports',
    'module',
    './log',
    'can-namespace',
    'can-symbol',
    'can-reflect',
    'can-observation-recorder',
    'can-event-queue/value/value'
], function (require, exports, module) {
    var log = require('./log');
    var ns = require('can-namespace');
    var canSymbol = require('can-symbol');
    var canReflect = require('can-reflect');
    var ObservationRecorder = require('can-observation-recorder');
    var valueEventBindings = require('can-event-queue/value/value');
    var dispatchSymbol = canSymbol.for('can.dispatch');
    function SimpleObservable(initialValue) {
        this.value = initialValue;
    }
    valueEventBindings(SimpleObservable.prototype);
    Object.assign(SimpleObservable.prototype, {
        log: log,
        get: function () {
            ObservationRecorder.add(this);
            return this.value;
        },
        set: function (value) {
            var old = this.value;
            this.value = value;
            this[dispatchSymbol](value, old);
        }
    });
    canReflect.assignSymbols(SimpleObservable.prototype, {
        'can.getValue': SimpleObservable.prototype.get,
        'can.setValue': SimpleObservable.prototype.set,
        'can.isMapLike': false,
        'can.valueHasDependencies': function () {
            return true;
        }
    });
    module.exports = ns.SimpleObservable = SimpleObservable;
});
/*can-simple-observable@2.0.1#settable/settable*/
define('can-simple-observable@2.0.1#settable/settable', [
    'require',
    'exports',
    'module',
    'can-reflect',
    'can-observation-recorder',
    '../can-simple-observable',
    'can-observation',
    'can-queues',
    '../log',
    'can-event-queue/value/value'
], function (require, exports, module) {
    var canReflect = require('can-reflect');
    var ObservationRecorder = require('can-observation-recorder');
    var SimpleObservable = require('../can-simple-observable');
    var Observation = require('can-observation');
    var queues = require('can-queues');
    var log = require('../log');
    var valueEventBindings = require('can-event-queue/value/value');
    var peek = ObservationRecorder.ignore(canReflect.getValue.bind(canReflect));
    function SettableObservable(fn, context, initialValue) {
        this.lastSetValue = new SimpleObservable(initialValue);
        function observe() {
            return fn.call(context, this.lastSetValue.get());
        }
        this.handler = this.handler.bind(this);
        this.observation = new Observation(observe, this);
    }
    valueEventBindings(SettableObservable.prototype);
    Object.assign(SettableObservable.prototype, {
        log: log,
        constructor: SettableObservable,
        handler: function (newVal) {
            var old = this.value;
            this.value = newVal;
            queues.enqueueByQueue(this.handlers.getNode([]), this, [
                newVal,
                old
            ], function () {
                return {};
            });
        },
        onBound: function () {
            this.bound = true;
            canReflect.onValue(this.observation, this.handler, 'notify');
            this.value = peek(this.observation);
        },
        onUnbound: function () {
            this.bound = false;
            canReflect.offValue(this.observation, this.handler, 'notify');
        },
        set: function (newVal) {
            var oldVal = this.lastSetValue.get();
            if (canReflect.isObservableLike(oldVal) && canReflect.isValueLike(oldVal) && !canReflect.isObservableLike(newVal)) {
                canReflect.setValue(oldVal, newVal);
            } else {
                if (newVal !== oldVal) {
                    this.lastSetValue.set(newVal);
                }
            }
        },
        get: function () {
            if (ObservationRecorder.isRecording()) {
                ObservationRecorder.add(this);
                if (!this.bound) {
                    Observation.temporarilyBind(this);
                }
            }
            if (this.bound === true) {
                return this.value;
            } else {
                return this.observation.get();
            }
        },
        hasDependencies: function () {
            return canReflect.valueHasDependencies(this.observation);
        },
        getValueDependencies: function () {
            return canReflect.getValueDependencies(this.observation);
        }
    });
    canReflect.assignSymbols(SettableObservable.prototype, {
        'can.getValue': SettableObservable.prototype.get,
        'can.setValue': SettableObservable.prototype.set,
        'can.isMapLike': false,
        'can.getPriority': function () {
            return canReflect.getPriority(this.observation);
        },
        'can.setPriority': function (newPriority) {
            canReflect.setPriority(this.observation, newPriority);
        },
        'can.valueHasDependencies': SettableObservable.prototype.hasDependencies,
        'can.getValueDependencies': SettableObservable.prototype.getValueDependencies
    });
    module.exports = SettableObservable;
});
/*can-stache@4.0.2#src/key-observable*/
define('can-stache@4.0.2#src/key-observable', [
    'require',
    'exports',
    'module',
    'can-simple-observable/settable/settable',
    'can-stache-key'
], function (require, exports, module) {
    var SettableObservable = require('can-simple-observable/settable/settable');
    var stacheKey = require('can-stache-key');
    function KeyObservable(root, key) {
        key = '' + key;
        this.key = key;
        this.root = root;
        SettableObservable.call(this, function () {
            return stacheKey.get(this, key);
        }, root);
    }
    KeyObservable.prototype = Object.create(SettableObservable.prototype);
    KeyObservable.prototype.set = function (newVal) {
        stacheKey.set(this.root, this.key, newVal);
    };
    module.exports = KeyObservable;
});
/*can-util@3.11.2#js/is-empty-object/is-empty-object*/
define('can-util@3.11.2#js/is-empty-object/is-empty-object', function (require, exports, module) {
    'use strict';
    module.exports = function (obj) {
        for (var prop in obj) {
            return false;
        }
        return true;
    };
});
/*can-stache@4.0.2#src/utils*/
define('can-stache@4.0.2#src/utils', [
    'require',
    'exports',
    'module',
    'can-view-scope',
    'can-observation',
    'can-observation-recorder',
    'can-stache-key',
    'can-reflect',
    './key-observable',
    'can-log/dev/dev',
    'can-util/js/is-empty-object/is-empty-object',
    'can-util/js/is-array-like/is-array-like'
], function (require, exports, module) {
    var Scope = require('can-view-scope');
    var Observation = require('can-observation');
    var ObservationRecorder = require('can-observation-recorder');
    var observationReader = require('can-stache-key');
    var canReflect = require('can-reflect');
    var KeyObservable = require('./key-observable');
    var dev = require('can-log/dev/dev');
    var isEmptyObject = require('can-util/js/is-empty-object/is-empty-object');
    var isArrayLike = require('can-util/js/is-array-like/is-array-like');
    var createNoOpRenderer = function (metadata) {
        return function noop() {
            if (metadata) {
                metadata.rendered = true;
            }
        };
    };
    module.exports = {
        isArrayLike: isArrayLike,
        emptyHandler: function () {
        },
        jsonParse: function (str) {
            if (str[0] === '\'') {
                return str.substr(1, str.length - 2);
            } else if (str === 'undefined') {
                return undefined;
            } else {
                return JSON.parse(str);
            }
        },
        mixins: {
            last: function () {
                return this.stack[this.stack.length - 1];
            },
            add: function (chars) {
                this.last().add(chars);
            },
            subSectionDepth: function () {
                return this.stack.length - 1;
            }
        },
        createRenderers: function (helperOptions, scope, nodeList, truthyRenderer, falseyRenderer, isStringOnly) {
            helperOptions.fn = truthyRenderer ? this.makeRendererConvertScopes(truthyRenderer, scope, nodeList, isStringOnly, helperOptions.metadata) : createNoOpRenderer(helperOptions.metadata);
            helperOptions.inverse = falseyRenderer ? this.makeRendererConvertScopes(falseyRenderer, scope, nodeList, isStringOnly, helperOptions.metadata) : createNoOpRenderer(helperOptions.metadata);
            helperOptions.isSection = !!(truthyRenderer || falseyRenderer);
        },
        makeRendererConvertScopes: function (renderer, parentScope, nodeList, observeObservables, metadata) {
            var rendererWithScope = function (ctx, parentNodeList) {
                if (metadata) {
                    metadata.rendered = true;
                }
                return renderer(ctx || parentScope, parentNodeList);
            };
            var convertedRenderer = function (newScope, newOptions, parentNodeList) {
                if (newScope !== undefined && !(newScope instanceof Scope)) {
                    if (parentScope) {
                        newScope = parentScope.add(newScope);
                    } else {
                        newScope = new Scope(newScope || {});
                    }
                }
                var result = rendererWithScope(newScope, parentNodeList || nodeList);
                return result;
            };
            return observeObservables ? convertedRenderer : ObservationRecorder.ignore(convertedRenderer);
        },
        getItemsStringContent: function (items, isObserveList, helperOptions) {
            var txt = '', len = observationReader.get(items, 'length'), isObservable = canReflect.isObservableLike(items);
            for (var i = 0; i < len; i++) {
                var item = isObservable ? new KeyObservable(items, i) : items[i];
                txt += helperOptions.fn(item);
            }
            return txt;
        },
        getItemsFragContent: function (items, helperOptions, scope) {
            var result = [], len = observationReader.get(items, 'length'), isObservable = canReflect.isObservableLike(items), hashExprs = helperOptions.exprData && helperOptions.exprData.hashExprs, hashOptions;
            if (!isEmptyObject(hashExprs)) {
                hashOptions = {};
                canReflect.eachKey(hashExprs, function (exprs, key) {
                    hashOptions[exprs.key] = key;
                });
            }
            for (var i = 0; i < len; i++) {
                var aliases = {};
                var item = isObservable ? new KeyObservable(items, i) : items[i];
                if (!isEmptyObject(hashOptions)) {
                    if (hashOptions.value) {
                        aliases[hashOptions.value] = item;
                    }
                    if (hashOptions.index) {
                        aliases[hashOptions.index] = i;
                    }
                }
                result.push(helperOptions.fn(scope.add(aliases, { notContext: true }).add({ index: i }, { special: true }).add(item)));
            }
            return result;
        }
    };
});
/*can-view-live@4.0.1#lib/core*/
define('can-view-live@4.0.1#lib/core', [
    'require',
    'exports',
    'module',
    'can-view-parser',
    'can-dom-mutate',
    'can-view-nodelist',
    'can-util/dom/frag/frag',
    'can-util/dom/child-nodes/child-nodes',
    'can-reflect',
    'can-reflect-dependencies'
], function (require, exports, module) {
    var parser = require('can-view-parser');
    var domMutate = require('can-dom-mutate');
    var nodeLists = require('can-view-nodelist');
    var makeFrag = require('can-util/dom/frag/frag');
    var childNodes = require('can-util/dom/child-nodes/child-nodes');
    var canReflect = require('can-reflect');
    var canReflectDeps = require('can-reflect-dependencies');
    var live = {
        setup: function (el, bind, unbind) {
            var tornDown = false, removalDisposal, data, teardown = function () {
                    if (!tornDown) {
                        tornDown = true;
                        unbind(data);
                        if (removalDisposal) {
                            removalDisposal();
                            removalDisposal = undefined;
                        }
                    }
                    return true;
                };
            data = {
                teardownCheck: function (parent) {
                    return parent ? false : teardown();
                }
            };
            removalDisposal = domMutate.onNodeRemoval(el, function () {
                if (!el.ownerDocument.contains(el)) {
                    teardown();
                }
            });
            bind(data);
            return data;
        },
        listen: function (el, compute, change, queueName) {
            return live.setup(el, function bind() {
                canReflect.onValue(compute, change, queueName || 'notify');
            }, function unbind(data) {
                canReflect.offValue(compute, change, queueName || 'notify');
                if (data.nodeList) {
                    nodeLists.unregister(data.nodeList);
                }
            });
        },
        getAttributeParts: function (newVal) {
            var attrs = {}, attr;
            parser.parseAttrs(newVal, {
                attrStart: function (name) {
                    attrs[name] = '';
                    attr = name;
                },
                attrValue: function (value) {
                    attrs[attr] += value;
                },
                attrEnd: function () {
                }
            });
            return attrs;
        },
        isNode: function (obj) {
            return obj && obj.nodeType;
        },
        addTextNodeIfNoChildren: function (frag) {
            if (!frag.firstChild) {
                frag.appendChild(frag.ownerDocument.createTextNode(''));
            }
        },
        replace: function (nodes, val, teardown) {
            var oldNodes = nodes.slice(0), frag = makeFrag(val);
            nodeLists.register(nodes, teardown);
            nodeLists.update(nodes, childNodes(frag));
            nodeLists.replace(oldNodes, frag);
            return nodes;
        },
        getParentNode: function (el, defaultParentNode) {
            return defaultParentNode && el.parentNode.nodeType === 11 ? defaultParentNode : el.parentNode;
        },
        makeString: function (txt) {
            return txt == null ? '' : '' + txt;
        }
    };
    module.exports = live;
});
/*can-view-live@4.0.1#lib/attr*/
define('can-view-live@4.0.1#lib/attr', [
    'require',
    'exports',
    'module',
    './core',
    'can-reflect',
    'can-dom-mutate/node',
    'can-queues'
], function (require, exports, module) {
    var live = require('./core');
    var canReflect = require('can-reflect');
    var domMutateNode = require('can-dom-mutate/node');
    var queues = require('can-queues');
    live.attr = function (el, attributeName, compute) {
        function liveUpdateAttr(newVal) {
            queues.domUIQueue.enqueue(domMutateNode.setAttribute, el, [
                attributeName,
                newVal
            ]);
        }
        live.listen(el, compute, liveUpdateAttr);
        domMutateNode.setAttribute.call(el, attributeName, canReflect.getValue(compute));
    };
});
/*can-view-live@4.0.1#lib/attrs*/
define('can-view-live@4.0.1#lib/attrs', [
    'require',
    'exports',
    'module',
    './core',
    'can-view-callbacks',
    'can-dom-mutate',
    'can-dom-mutate/node',
    'can-reflect',
    'can-reflect-dependencies'
], function (require, exports, module) {
    var live = require('./core');
    var viewCallbacks = require('can-view-callbacks');
    var domMutate = require('can-dom-mutate');
    var domMutateNode = require('can-dom-mutate/node');
    var canReflect = require('can-reflect');
    var canReflectDeps = require('can-reflect-dependencies');
    live.attrs = function (el, compute, scope, options) {
        if (!canReflect.isObservableLike(compute)) {
            var attrs = live.getAttributeParts(compute);
            for (var name in attrs) {
                domMutateNode.setAttribute.call(el, name, attrs[name]);
            }
            return;
        }
        var oldAttrs = {};
        function liveAttrsUpdate(newVal) {
            var newAttrs = live.getAttributeParts(newVal), name;
            for (name in newAttrs) {
                var newValue = newAttrs[name], oldValue = oldAttrs[name];
                if (newValue !== oldValue) {
                    domMutateNode.setAttribute.call(el, name, newValue);
                    var callback = viewCallbacks.attr(name);
                    if (callback) {
                        callback(el, {
                            attributeName: name,
                            scope: scope,
                            options: options
                        });
                    }
                }
                delete oldAttrs[name];
            }
            for (name in oldAttrs) {
                domMutateNode.removeAttribute.call(el, name);
            }
            oldAttrs = newAttrs;
        }
        canReflect.onValue(compute, liveAttrsUpdate, 'domUI');
        var removalDisposal;
        var teardownHandler = function () {
            canReflect.offValue(compute, liveAttrsUpdate, 'domUI');
            if (removalDisposal) {
                removalDisposal();
                removalDisposal = undefined;
            }
        };
        removalDisposal = domMutate.onNodeRemoval(el, function () {
            if (!el.ownerDocument.contains(el)) {
                teardownHandler();
            }
        });
        liveAttrsUpdate(canReflect.getValue(compute));
    };
});
/*can-view-live@4.0.1#lib/html*/
define('can-view-live@4.0.1#lib/html', [
    'require',
    'exports',
    'module',
    './core',
    'can-view-nodelist',
    'can-util/dom/frag/frag',
    'can-util/js/make-array/make-array',
    'can-util/dom/child-nodes/child-nodes',
    'can-reflect',
    'can-queues'
], function (require, exports, module) {
    var live = require('./core');
    var nodeLists = require('can-view-nodelist');
    var makeFrag = require('can-util/dom/frag/frag');
    var makeArray = require('can-util/js/make-array/make-array');
    var childNodes = require('can-util/dom/child-nodes/child-nodes');
    var canReflect = require('can-reflect');
    var queues = require('can-queues');
    live.html = function (el, compute, parentNode, nodeList) {
        var data, makeAndPut, nodes;
        var meta = { reasonLog: 'live.html replace::' + canReflect.getName(compute) };
        parentNode = live.getParentNode(el, parentNode);
        function liveHTMLUpdateHTML(newVal) {
            var attached = nodeLists.first(nodes).parentNode;
            if (attached) {
                makeAndPut(newVal, true);
            }
            var pn = nodeLists.first(nodes).parentNode;
            data.teardownCheck(pn);
        }
        data = live.listen(parentNode, compute, liveHTMLUpdateHTML);
        nodes = nodeList || [el];
        makeAndPut = function (val, useQueue) {
            var isFunction = typeof val === 'function', frag = makeFrag(isFunction ? '' : val), oldNodes = makeArray(nodes);
            live.addTextNodeIfNoChildren(frag);
            oldNodes = nodeLists.update(nodes, childNodes(frag));
            if (isFunction) {
                val(frag.firstChild);
            }
            if (useQueue === true) {
                queues.domUIQueue.enqueue(nodeLists.replace, nodeLists, [
                    oldNodes,
                    frag
                ], meta);
            } else {
                nodeLists.replace(oldNodes, frag);
            }
        };
        data.nodeList = nodes;
        if (!nodeList) {
            nodeLists.register(nodes, data.teardownCheck);
        } else {
            nodeList.unregistered = data.teardownCheck;
        }
        makeAndPut(canReflect.getValue(compute));
    };
});
/*can-view-live@4.0.1#lib/set-observable*/
define('can-view-live@4.0.1#lib/set-observable', [
    'require',
    'exports',
    'module',
    'can-simple-observable',
    'can-reflect'
], function (require, exports, module) {
    var SimpleObservable = require('can-simple-observable');
    var canReflect = require('can-reflect');
    function SetObservable(initialValue, setter) {
        this.setter = setter;
        SimpleObservable.call(this, initialValue);
    }
    SetObservable.prototype = Object.create(SimpleObservable.prototype);
    SetObservable.prototype.constructor = SetObservable;
    SetObservable.prototype.set = function (newVal) {
        this.setter(newVal);
    };
    canReflect.assignSymbols(SetObservable.prototype, { 'can.setValue': SetObservable.prototype.set });
    module.exports = SetObservable;
});
/*can-util@3.11.2#js/diff/diff*/
define('can-util@3.11.2#js/diff/diff', function (require, exports, module) {
    'use strict';
    var slice = [].slice;
    var defaultIdentity = function (a, b) {
        return a === b;
    };
    function reverseDiff(oldDiffStopIndex, newDiffStopIndex, oldList, newList, identity) {
        var oldIndex = oldList.length - 1, newIndex = newList.length - 1;
        while (oldIndex > oldDiffStopIndex && newIndex > newDiffStopIndex) {
            var oldItem = oldList[oldIndex], newItem = newList[newIndex];
            if (identity(oldItem, newItem)) {
                oldIndex--;
                newIndex--;
                continue;
            } else {
                return [{
                        index: newDiffStopIndex,
                        deleteCount: oldIndex - oldDiffStopIndex + 1,
                        insert: slice.call(newList, newDiffStopIndex, newIndex + 1)
                    }];
            }
        }
        return [{
                index: newDiffStopIndex,
                deleteCount: oldIndex - oldDiffStopIndex + 1,
                insert: slice.call(newList, newDiffStopIndex, newIndex + 1)
            }];
    }
    module.exports = exports = function (oldList, newList, identity) {
        identity = identity || defaultIdentity;
        var oldIndex = 0, newIndex = 0, oldLength = oldList.length, newLength = newList.length, patches = [];
        while (oldIndex < oldLength && newIndex < newLength) {
            var oldItem = oldList[oldIndex], newItem = newList[newIndex];
            if (identity(oldItem, newItem)) {
                oldIndex++;
                newIndex++;
                continue;
            }
            if (newIndex + 1 < newLength && identity(oldItem, newList[newIndex + 1])) {
                patches.push({
                    index: newIndex,
                    deleteCount: 0,
                    insert: [newList[newIndex]]
                });
                oldIndex++;
                newIndex += 2;
                continue;
            } else if (oldIndex + 1 < oldLength && identity(oldList[oldIndex + 1], newItem)) {
                patches.push({
                    index: newIndex,
                    deleteCount: 1,
                    insert: []
                });
                oldIndex += 2;
                newIndex++;
                continue;
            } else {
                patches.push.apply(patches, reverseDiff(oldIndex, newIndex, oldList, newList, identity));
                return patches;
            }
        }
        if (newIndex === newLength && oldIndex === oldLength) {
            return patches;
        }
        patches.push({
            index: newIndex,
            deleteCount: oldLength - oldIndex,
            insert: slice.call(newList, newIndex)
        });
        return patches;
    };
});
/*can-view-live@4.0.1#lib/patcher*/
define('can-view-live@4.0.1#lib/patcher', [
    'require',
    'exports',
    'module',
    'can-reflect',
    'can-key-tree',
    'can-symbol',
    'can-util/js/diff/diff',
    'can-queues',
    'can-symbol'
], function (require, exports, module) {
    var canReflect = require('can-reflect');
    var KeyTree = require('can-key-tree');
    var canSymbol = require('can-symbol');
    var diff = require('can-util/js/diff/diff');
    var queues = require('can-queues');
    var canSymbol = require('can-symbol');
    var onValueSymbol = canSymbol.for('can.onValue'), offValueSymbol = canSymbol.for('can.offValue');
    var onPatchesSymbol = canSymbol.for('can.onPatches');
    var offPatchesSymbol = canSymbol.for('can.offPatches');
    var Patcher = function (observableOrList, priority) {
        this.handlers = new KeyTree([
            Object,
            Array
        ], {
            onFirst: this.setup.bind(this),
            onEmpty: this.teardown.bind(this)
        });
        this.observableOrList = observableOrList;
        this.isObservableValue = canReflect.isValueLike(this.observableOrList) || canReflect.isObservableLike(this.observableOrList);
        if (this.isObservableValue) {
            this.priority = canReflect.getPriority(observableOrList);
        } else {
            this.priority = priority || 0;
        }
        this.onList = this.onList.bind(this);
        this.onPatchesNotify = this.onPatchesNotify.bind(this);
        this.onPatchesDerive = this.onPatchesDerive.bind(this);
        this.patches = [];
    };
    Patcher.prototype = {
        constructor: Patcher,
        setup: function () {
            if (this.observableOrList[onValueSymbol]) {
                canReflect.onValue(this.observableOrList, this.onList, 'notify');
                this.setupList(canReflect.getValue(this.observableOrList));
            } else {
                this.setupList(this.observableOrList);
            }
        },
        teardown: function () {
            if (this.observableOrList[offValueSymbol]) {
                canReflect.offValue(this.observableOrList, this.onList, 'notify');
            }
        },
        setupList: function (list) {
            this.currentList = list;
            if (list && list[onPatchesSymbol]) {
                list[onPatchesSymbol](this.onPatchesNotify, 'notify');
            }
        },
        onList: function onList(newList) {
            var current = this.currentList || [];
            newList = newList || [];
            if (current[offPatchesSymbol]) {
                current[offPatchesSymbol](this.onPatchesNotify, 'notify');
            }
            var patches = diff(current, newList);
            this.currentList = newList;
            this.onPatchesNotify(patches);
            if (newList[onPatchesSymbol]) {
                newList[onPatchesSymbol](this.onPatchesNotify, 'notify');
            }
        },
        onPatchesNotify: function onPatchesNotify(patches) {
            this.patches.push.apply(this.patches, patches);
            queues.deriveQueue.enqueue(this.onPatchesDerive, this, [], { priority: this.priority });
        },
        onPatchesDerive: function onPatchesDerive() {
            var patches = this.patches;
            this.patches = [];
            queues.enqueueByQueue(this.handlers.getNode([]), this.currentList, [
                patches,
                this.currentList
            ], null, [
                'Apply patches',
                patches
            ]);
        }
    };
    canReflect.assignSymbols(Patcher.prototype, {
        'can.onPatches': function (handler, queue) {
            this.handlers.add([
                queue || 'mutate',
                handler
            ]);
        },
        'can.offPatches': function (handler, queue) {
            this.handlers.delete([
                queue || 'mutate',
                handler
            ]);
        }
    });
    module.exports = Patcher;
});
/*can-view-live@4.0.1#lib/list*/
define('can-view-live@4.0.1#lib/list', [
    'require',
    'exports',
    'module',
    './core',
    'can-view-nodelist',
    'can-util/dom/frag/frag',
    'can-util/dom/child-nodes/child-nodes',
    'can-dom-mutate/node',
    'can-util/js/make-array/make-array',
    'can-util/js/each/each',
    'can-symbol',
    'can-reflect',
    'can-reflect-dependencies',
    'can-simple-observable',
    './set-observable',
    './patcher'
], function (require, exports, module) {
    var live = require('./core');
    var nodeLists = require('can-view-nodelist');
    var frag = require('can-util/dom/frag/frag');
    var childNodes = require('can-util/dom/child-nodes/child-nodes');
    var domMutateNode = require('can-dom-mutate/node');
    var makeArray = require('can-util/js/make-array/make-array');
    var each = require('can-util/js/each/each');
    var canSymbol = require('can-symbol');
    var canReflect = require('can-reflect');
    var canReflectDeps = require('can-reflect-dependencies');
    var SimpleObservable = require('can-simple-observable');
    var SetObservable = require('./set-observable');
    var Patcher = require('./patcher');
    var splice = [].splice;
    var renderAndAddToNodeLists = function (newNodeLists, parentNodeList, render, context, args) {
            var itemNodeList = [];
            if (parentNodeList) {
                nodeLists.register(itemNodeList, null, parentNodeList, true);
                itemNodeList.parentList = parentNodeList;
                itemNodeList.expression = '#each SUBEXPRESSION';
            }
            var itemHTML = render.apply(context, args.concat([itemNodeList])), itemFrag = frag(itemHTML);
            var children = makeArray(childNodes(itemFrag));
            if (parentNodeList) {
                nodeLists.update(itemNodeList, children);
                newNodeLists.push(itemNodeList);
            } else {
                newNodeLists.push(nodeLists.register(children));
            }
            return itemFrag;
        }, removeFromNodeList = function (masterNodeList, index, length) {
            var removedMappings = masterNodeList.splice(index + 1, length), itemsToRemove = [];
            each(removedMappings, function (nodeList) {
                var nodesToRemove = nodeLists.unregister(nodeList);
                [].push.apply(itemsToRemove, nodesToRemove);
            });
            return itemsToRemove;
        };
    var onPatchesSymbol = canSymbol.for('can.onPatches');
    var offPatchesSymbol = canSymbol.for('can.offPatches');
    function ListDOMPatcher(el, compute, render, context, parentNode, nodeList, falseyRender) {
        this.patcher = new Patcher(compute);
        parentNode = live.getParentNode(el, parentNode);
        this.value = compute;
        this.render = render;
        this.context = context;
        this.parentNode = parentNode;
        this.falseyRender = falseyRender;
        this.masterNodeList = nodeList || nodeLists.register([el], null, true);
        this.placeholder = el;
        this.indexMap = [];
        this.isValueLike = canReflect.isValueLike(this.value);
        this.isObservableLike = canReflect.isObservableLike(this.value);
        this.onPatches = this.onPatches.bind(this);
        var data = this.data = live.setup(parentNode, this.setupValueBinding.bind(this), this.teardownValueBinding.bind(this));
        this.masterNodeList.unregistered = function () {
            data.teardownCheck();
        };
    }
    var onPatchesSymbol = canSymbol.for('can.onPatches');
    var offPatchesSymbol = canSymbol.for('can.offPatches');
    ListDOMPatcher.prototype = {
        setupValueBinding: function () {
            this.patcher[onPatchesSymbol](this.onPatches, 'domUI');
            if (this.patcher.currentList && this.patcher.currentList.length) {
                this.onPatches([{
                        insert: this.patcher.currentList,
                        index: 0,
                        deleteCount: 0
                    }]);
            } else {
                this.addFalseyIfEmpty();
            }
        },
        teardownValueBinding: function () {
            this.patcher[offPatchesSymbol](this.onPatches, 'domUI');
            this.exit = true;
            this.remove({ length: this.patcher.currentList.length }, 0, true);
        },
        onPatches: function ListDOMPatcher_onPatches(patches) {
            if (this.exit) {
                return;
            }
            for (var i = 0, patchLen = patches.length; i < patchLen; i++) {
                var patch = patches[i];
                if (patch.type === 'move') {
                    this.move(patch.toIndex, patch.fromIndex);
                } else {
                    if (patch.deleteCount) {
                        this.remove({ length: patch.deleteCount }, patch.index, true);
                    }
                    if (patch.insert && patch.insert.length) {
                        this.add(patch.insert, patch.index);
                    }
                }
            }
        },
        add: function (items, index) {
            var frag = this.placeholder.ownerDocument.createDocumentFragment(), newNodeLists = [], newIndicies = [], masterNodeList = this.masterNodeList, render = this.render, context = this.context;
            each(items, function (item, key) {
                var itemIndex = new SimpleObservable(key + index), itemCompute = new SetObservable(item, function (newVal) {
                        canReflect.setKeyValue(this.patcher.currentList, itemIndex.get(), newVal);
                    }.bind(this)), itemFrag = renderAndAddToNodeLists(newNodeLists, masterNodeList, render, context, [
                        itemCompute,
                        itemIndex
                    ]);
                frag.appendChild(itemFrag);
                newIndicies.push(itemIndex);
            }, this);
            var masterListIndex = index + 1;
            if (!this.indexMap.length) {
                var falseyItemsToRemove = removeFromNodeList(masterNodeList, 0, masterNodeList.length - 1);
                nodeLists.remove(falseyItemsToRemove);
            }
            if (!masterNodeList[masterListIndex]) {
                nodeLists.after(masterListIndex === 1 ? [this.placeholder] : [nodeLists.last(this.masterNodeList[masterListIndex - 1])], frag);
            } else {
                var el = nodeLists.first(masterNodeList[masterListIndex]);
                domMutateNode.insertBefore.call(el.parentNode, frag, el);
            }
            splice.apply(this.masterNodeList, [
                masterListIndex,
                0
            ].concat(newNodeLists));
            splice.apply(this.indexMap, [
                index,
                0
            ].concat(newIndicies));
            for (var i = index + newIndicies.length, len = this.indexMap.length; i < len; i++) {
                this.indexMap[i].set(i);
            }
        },
        remove: function (items, index) {
            if (index < 0) {
                index = this.indexMap.length + index;
            }
            var itemsToRemove = removeFromNodeList(this.masterNodeList, index, items.length);
            var indexMap = this.indexMap;
            indexMap.splice(index, items.length);
            for (var i = index, len = indexMap.length; i < len; i++) {
                indexMap[i].set(i);
            }
            if (!this.exit) {
                this.addFalseyIfEmpty();
                nodeLists.remove(itemsToRemove);
            } else {
                nodeLists.unregister(this.masterNodeList);
            }
        },
        addFalseyIfEmpty: function () {
            if (this.falseyRender && this.indexMap.length === 0) {
                var falseyNodeLists = [];
                var falseyFrag = renderAndAddToNodeLists(falseyNodeLists, this.masterNodeList, this.falseyRender, this.currentList, [this.currentList]);
                nodeLists.after([this.masterNodeList[0]], falseyFrag);
                this.masterNodeList.push(falseyNodeLists[0]);
            }
        },
        move: function move(newIndex, currentIndex) {
            newIndex = newIndex + 1;
            currentIndex = currentIndex + 1;
            var masterNodeList = this.masterNodeList, indexMap = this.indexMap;
            var referenceNodeList = masterNodeList[newIndex];
            var movedElements = frag(nodeLists.flatten(masterNodeList[currentIndex]));
            var referenceElement;
            if (currentIndex < newIndex) {
                referenceElement = nodeLists.last(referenceNodeList).nextSibling;
            } else {
                referenceElement = nodeLists.first(referenceNodeList);
            }
            var parentNode = masterNodeList[0].parentNode;
            parentNode.insertBefore(movedElements, referenceElement);
            var temp = masterNodeList[currentIndex];
            [].splice.apply(masterNodeList, [
                currentIndex,
                1
            ]);
            [].splice.apply(masterNodeList, [
                newIndex,
                0,
                temp
            ]);
            newIndex = newIndex - 1;
            currentIndex = currentIndex - 1;
            var indexCompute = indexMap[currentIndex];
            [].splice.apply(indexMap, [
                currentIndex,
                1
            ]);
            [].splice.apply(indexMap, [
                newIndex,
                0,
                indexCompute
            ]);
            var i = Math.min(currentIndex, newIndex);
            var len = indexMap.length;
            for (i, len; i < len; i++) {
                indexMap[i].set(i);
            }
        },
        set: function (newVal, index) {
            this.remove({ length: 1 }, index, true);
            this.add([newVal], index);
        }
    };
    live.list = function (el, list, render, context, parentNode, nodeList, falseyRender) {
        if (el.nodeType !== Node.TEXT_NODE) {
            var textNode;
            if (!nodeList) {
                textNode = document.createTextNode('');
                el.parentNode.replaceChild(textNode, el);
                el = textNode;
            } else {
                textNode = document.createTextNode('');
                nodeLists.replace(nodeList, textNode);
                nodeLists.update(nodeList, [textNode]);
                el = textNode;
            }
        }
        new ListDOMPatcher(el, list, render, context, parentNode, nodeList, falseyRender);
    };
});
/*can-view-live@4.0.1#lib/text*/
define('can-view-live@4.0.1#lib/text', [
    'require',
    'exports',
    'module',
    './core',
    'can-view-nodelist',
    'can-reflect'
], function (require, exports, module) {
    var live = require('./core');
    var nodeLists = require('can-view-nodelist');
    var canReflect = require('can-reflect');
    live.text = function (el, compute, parentNode, nodeList) {
        if (el.nodeType !== Node.TEXT_NODE) {
            var textNode;
            if (!nodeList) {
                textNode = document.createTextNode('');
                el.parentNode.replaceChild(textNode, el);
                el = textNode;
            } else {
                textNode = document.createTextNode('');
                nodeLists.replace(nodeList, textNode);
                nodeLists.update(nodeList, [textNode]);
                el = textNode;
            }
        }
        var parent = live.getParentNode(el, parentNode);
        el.nodeValue = live.makeString(canReflect.getValue(compute));
        function liveTextUpdateTextNode(newVal) {
            el.nodeValue = live.makeString(newVal);
        }
        var data = live.listen(parent, compute, liveTextUpdateTextNode, 'domUI');
        if (!nodeList) {
            nodeList = nodeLists.register([el], null, true);
        }
        nodeList.unregistered = data.teardownCheck;
        data.nodeList = nodeList;
    };
});
/*can-view-live@4.0.1#can-view-live*/
define('can-view-live@4.0.1#can-view-live', [
    'require',
    'exports',
    'module',
    './lib/core',
    './lib/attr',
    './lib/attrs',
    './lib/html',
    './lib/list',
    './lib/text'
], function (require, exports, module) {
    var live = require('./lib/core');
    require('./lib/attr');
    require('./lib/attrs');
    require('./lib/html');
    require('./lib/list');
    require('./lib/text');
    module.exports = live;
});
/*can-stache@4.0.2#expressions/arg*/
define('can-stache@4.0.2#expressions/arg', function (require, exports, module) {
    var Arg = function (expression, modifiers) {
        this.expr = expression;
        this.modifiers = modifiers || {};
        this.isCompute = false;
    };
    Arg.prototype.value = function () {
        return this.expr.value.apply(this.expr, arguments);
    };
    module.exports = Arg;
});
/*can-stache@4.0.2#expressions/literal*/
define('can-stache@4.0.2#expressions/literal', function (require, exports, module) {
    var Literal = function (value) {
        this._value = value;
    };
    Literal.prototype.value = function () {
        return this._value;
    };
    module.exports = Literal;
});
/*can-simple-observable@2.0.1#setter/setter*/
define('can-simple-observable@2.0.1#setter/setter', [
    'require',
    'exports',
    'module',
    'can-reflect',
    'can-observation',
    '../settable/settable',
    'can-event-queue/value/value'
], function (require, exports, module) {
    var canReflect = require('can-reflect');
    var Observation = require('can-observation');
    var SettableObservable = require('../settable/settable');
    var valueEventBindings = require('can-event-queue/value/value');
    function SetterObservable(getter, setter) {
        this.setter = setter;
        this.observation = new Observation(getter);
        this.handler = this.handler.bind(this);
    }
    SetterObservable.prototype = Object.create(SettableObservable.prototype);
    SetterObservable.prototype.constructor = SetterObservable;
    SetterObservable.prototype.set = function (newVal) {
        this.setter(newVal);
    };
    SetterObservable.prototype.hasDependencies = function () {
        return canReflect.valueHasDependencies(this.observation);
    };
    canReflect.assignSymbols(SetterObservable.prototype, {
        'can.setValue': SetterObservable.prototype.set,
        'can.valueHasDependencies': SetterObservable.prototype.hasDependencies
    });
    module.exports = SetterObservable;
});
/*can-stache@4.0.2#src/expression-helpers*/
define('can-stache@4.0.2#src/expression-helpers', [
    'require',
    'exports',
    'module',
    '../expressions/arg',
    '../expressions/literal',
    'can-reflect',
    'can-stache-key',
    'can-symbol',
    'can-observation',
    'can-view-scope/make-compute-like',
    'can-simple-observable/setter/setter'
], function (require, exports, module) {
    var Arg = require('../expressions/arg');
    var Literal = require('../expressions/literal');
    var canReflect = require('can-reflect');
    var observeReader = require('can-stache-key');
    var canSymbol = require('can-symbol');
    var Observation = require('can-observation');
    var makeComputeLike = require('can-view-scope/make-compute-like');
    var SetterObservable = require('can-simple-observable/setter/setter');
    function getObservableValue_fromKey(key, scope, readOptions) {
        var data = scope.computeData(key, readOptions);
        Observation.temporarilyBind(data);
        return data;
    }
    function computeHasDependencies(compute) {
        return compute[canSymbol.for('can.valueHasDependencies')] ? canReflect.valueHasDependencies(compute) : compute.computeInstance.hasDependencies;
    }
    function getObservableValue_fromDynamicKey_fromObservable(key, root, helperOptions, readOptions) {
        var getKey = function () {
            return ('' + canReflect.getValue(key)).replace('.', '\\.');
        };
        var computeValue = new SetterObservable(function getDynamicKey() {
            return observeReader.get(canReflect.getValue(root), getKey());
        }, function setDynamicKey(newVal) {
            observeReader.write(canReflect.getValue(root), observeReader.reads(getKey()), newVal);
        });
        Observation.temporarilyBind(computeValue);
        return computeValue;
    }
    function convertToArgExpression(expr) {
        if (!(expr instanceof Arg) && !(expr instanceof Literal)) {
            return new Arg(expr);
        } else {
            return expr;
        }
    }
    function toComputeOrValue(value) {
        if (canReflect.isObservableLike(value)) {
            if (canReflect.isValueLike(value) && canReflect.valueHasDependencies(value) === false) {
                return canReflect.getValue(value);
            }
            if (value.compute) {
                return value.compute;
            } else {
                return makeComputeLike(value);
            }
        }
        return value;
    }
    function toCompute(value) {
        if (value) {
            if (value.isComputed) {
                return value;
            }
            if (value.compute) {
                return value.compute;
            } else {
                return makeComputeLike(value);
            }
        }
        return value;
    }
    module.exports = {
        getObservableValue_fromKey: getObservableValue_fromKey,
        computeHasDependencies: computeHasDependencies,
        getObservableValue_fromDynamicKey_fromObservable: getObservableValue_fromDynamicKey_fromObservable,
        convertToArgExpression: convertToArgExpression,
        toComputeOrValue: toComputeOrValue,
        toCompute: toCompute
    };
});
/*can-stache@4.0.2#expressions/hashes*/
define('can-stache@4.0.2#expressions/hashes', [
    'require',
    'exports',
    'module',
    'can-reflect',
    'can-observation',
    '../src/expression-helpers'
], function (require, exports, module) {
    var canReflect = require('can-reflect');
    var Observation = require('can-observation');
    var expressionHelpers = require('../src/expression-helpers');
    var Hashes = function (hashes) {
        this.hashExprs = hashes;
    };
    Hashes.prototype.value = function (scope, helperOptions) {
        var hash = {};
        for (var prop in this.hashExprs) {
            var val = expressionHelpers.convertToArgExpression(this.hashExprs[prop]), value = val.value.apply(val, arguments);
            hash[prop] = {
                call: !val.modifiers || !val.modifiers.compute,
                value: value
            };
        }
        return new Observation(function () {
            var finalHash = {};
            for (var prop in hash) {
                finalHash[prop] = hash[prop].call ? canReflect.getValue(hash[prop].value) : expressionHelpers.toComputeOrValue(hash[prop].value);
            }
            return finalHash;
        });
    };
    module.exports = Hashes;
});
/*can-stache@4.0.2#expressions/bracket*/
define('can-stache@4.0.2#expressions/bracket', [
    'require',
    'exports',
    'module',
    '../src/expression-helpers'
], function (require, exports, module) {
    var expressionHelpers = require('../src/expression-helpers');
    var Bracket = function (key, root, originalKey) {
        this.root = root;
        this.key = key;
    };
    Bracket.prototype.value = function (scope, helpers) {
        var root = this.root ? this.root.value(scope, helpers) : scope.peek('this');
        return expressionHelpers.getObservableValue_fromDynamicKey_fromObservable(this.key.value(scope, helpers), root, scope, helpers, {});
    };
    Bracket.prototype.closingTag = function () {
    };
    module.exports = Bracket;
});
/*can-stache@4.0.2#src/set-identifier*/
define('can-stache@4.0.2#src/set-identifier', function (require, exports, module) {
    module.exports = function SetIdentifier(value) {
        this.value = value;
    };
});
/*can-stache@4.0.2#expressions/call*/
define('can-stache@4.0.2#expressions/call', [
    'require',
    'exports',
    'module',
    'can-view-scope',
    './hashes',
    '../src/set-identifier',
    'can-observation',
    'can-symbol',
    'can-simple-observable/setter/setter',
    '../src/expression-helpers',
    'can-reflect',
    'can-util/js/is-empty-object/is-empty-object',
    'can-assign'
], function (require, exports, module) {
    var Scope = require('can-view-scope');
    var Hashes = require('./hashes');
    var SetIdentifier = require('../src/set-identifier');
    var Observation = require('can-observation');
    var canSymbol = require('can-symbol');
    var sourceTextSymbol = canSymbol.for('can-stache.sourceText');
    var SetterObservable = require('can-simple-observable/setter/setter');
    var expressionHelpers = require('../src/expression-helpers');
    var canReflect = require('can-reflect');
    var isEmptyObject = require('can-util/js/is-empty-object/is-empty-object');
    var assign = require('can-assign');
    var Call = function (methodExpression, argExpressions) {
        this.methodExpr = methodExpression;
        this.argExprs = argExpressions.map(expressionHelpers.convertToArgExpression);
    };
    Call.prototype.args = function (scope) {
        var hashExprs = {};
        var args = [];
        for (var i = 0, len = this.argExprs.length; i < len; i++) {
            var arg = this.argExprs[i];
            if (arg.expr instanceof Hashes) {
                assign(hashExprs, arg.expr.hashExprs);
            }
            var value = arg.value.apply(arg, arguments);
            args.push({
                call: !arg.modifiers || !arg.modifiers.compute,
                value: value
            });
        }
        return function (doNotWrapArguments) {
            var finalArgs = [];
            if (!isEmptyObject(hashExprs)) {
                finalArgs.hashExprs = hashExprs;
            }
            for (var i = 0, len = args.length; i < len; i++) {
                if (doNotWrapArguments) {
                    finalArgs[i] = args[i].value;
                } else {
                    finalArgs[i] = args[i].call ? canReflect.getValue(args[i].value) : expressionHelpers.toCompute(args[i].value);
                }
            }
            return finalArgs;
        };
    };
    Call.prototype.value = function (scope, helperOptions) {
        var callExpression = this;
        var method = this.methodExpr.value(scope, { proxyMethods: false });
        var computeFn = function (newVal) {
            var func = canReflect.getValue(method);
            if (typeof func === 'function') {
                var args = callExpression.args(scope)(func.isLiveBound);
                if (func.requiresOptionsArgument) {
                    if (args.hashExprs && helperOptions && helperOptions.exprData) {
                        helperOptions.exprData.hashExprs = args.hashExprs;
                    }
                    args.push(helperOptions);
                }
                if (arguments.length) {
                    args.unshift(new SetIdentifier(newVal));
                }
                return func.apply(method.thisArg || scope.peek('this'), args);
            }
        };
        if (helperOptions && helperOptions.doNotWrapInObservation) {
            return computeFn();
        } else {
            var computeValue = new SetterObservable(computeFn, computeFn);
            Observation.temporarilyBind(computeValue);
            return computeValue;
        }
    };
    Call.prototype.closingTag = function () {
        return this.methodExpr.key;
    };
    module.exports = Call;
});
/*can-util@3.11.2#js/base-url/base-url*/
define('can-util@3.11.2#js/base-url/base-url', [
    'require',
    'exports',
    'module',
    'can-globals/global/global',
    'can-globals/document/document'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        'use strict';
        var getGlobal = require('can-globals/global/global');
        var getDomDocument = require('can-globals/document/document');
        var setBaseUrl;
        module.exports = function (setUrl) {
            if (setUrl !== undefined) {
                setBaseUrl = setUrl;
            }
            if (setBaseUrl !== undefined) {
                return setBaseUrl;
            }
            var global = getGlobal();
            var domDocument = getDomDocument();
            if (domDocument && 'baseURI' in domDocument) {
                return domDocument.baseURI;
            } else if (global.location) {
                var href = global.location.href;
                var lastSlash = href.lastIndexOf('/');
                return lastSlash !== -1 ? href.substr(0, lastSlash) : href;
            } else if (typeof process !== 'undefined') {
                return process.cwd();
            }
        };
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-parse-uri@1.0.1#can-parse-uri*/
define('can-parse-uri@1.0.1#can-parse-uri', function (require, exports, module) {
    module.exports = function (url) {
        var m = String(url).replace(/^\s+|\s+$/g, '').match(/^([^:\/?#]+:)?(\/\/(?:[^:@]*(?::[^:@]*)?@)?(([^:\/?#]*)(?::(\d*))?))?([^?#]*)(\?[^#]*)?(#[\s\S]*)?/);
        return m ? {
            href: m[0] || '',
            protocol: m[1] || '',
            authority: m[2] || '',
            host: m[3] || '',
            hostname: m[4] || '',
            port: m[5] || '',
            pathname: m[6] || '',
            search: m[7] || '',
            hash: m[8] || ''
        } : null;
    };
});
/*can-util@3.11.2#js/join-uris/join-uris*/
define('can-util@3.11.2#js/join-uris/join-uris', [
    'require',
    'exports',
    'module',
    'can-parse-uri'
], function (require, exports, module) {
    'use strict';
    var parseURI = require('can-parse-uri');
    module.exports = function (base, href) {
        function removeDotSegments(input) {
            var output = [];
            input.replace(/^(\.\.?(\/|$))+/, '').replace(/\/(\.(\/|$))+/g, '/').replace(/\/\.\.$/, '/../').replace(/\/?[^\/]*/g, function (p) {
                if (p === '/..') {
                    output.pop();
                } else {
                    output.push(p);
                }
            });
            return output.join('').replace(/^\//, input.charAt(0) === '/' ? '/' : '');
        }
        href = parseURI(href || '');
        base = parseURI(base || '');
        return !href || !base ? null : (href.protocol || base.protocol) + (href.protocol || href.authority ? href.authority : base.authority) + removeDotSegments(href.protocol || href.authority || href.pathname.charAt(0) === '/' ? href.pathname : href.pathname ? (base.authority && !base.pathname ? '/' : '') + base.pathname.slice(0, base.pathname.lastIndexOf('/') + 1) + href.pathname : base.pathname) + (href.protocol || href.authority || href.pathname ? href.search : href.search || base.search) + href.hash;
    };
});
/*can-stache@4.0.2#helpers/-debugger*/
define('can-stache@4.0.2#helpers/-debugger', [
    'require',
    'exports',
    'module',
    'can-log'
], function (require, exports, module) {
    var canLog = require('can-log');
    function noop() {
    }
    ;
    var resolveValue = noop;
    var evaluateArgs = noop;
    var __testing = {};
    function debuggerHelper(left, right) {
        canLog.warn('Forgotten {{debugger}} helper');
    }
    debuggerHelper.requiresOptionsArgument = true;
    module.exports = {
        helper: debuggerHelper,
        evaluateArgs: evaluateArgs,
        resolveValue: resolveValue,
        __testing: __testing
    };
});
/*can-stache@4.0.2#src/truthy-observable*/
define('can-stache@4.0.2#src/truthy-observable', [
    'require',
    'exports',
    'module',
    'can-observation',
    'can-reflect'
], function (require, exports, module) {
    var Observation = require('can-observation');
    var canReflect = require('can-reflect');
    module.exports = function (observable) {
        return new Observation(function truthyObservation() {
            var val = canReflect.getValue(observable);
            return !!val;
        });
    };
});
/*can-dom-data-state@1.0.1#can-dom-data-state*/
define('can-dom-data-state@1.0.1#can-dom-data-state', [
    'require',
    'exports',
    'module',
    'can-namespace',
    'can-dom-mutate',
    'can-cid'
], function (require, exports, module) {
    'use strict';
    var namespace = require('can-namespace');
    var domMutate = require('can-dom-mutate');
    var CID = require('can-cid');
    var isEmptyObject = function (obj) {
        for (var prop in obj) {
            return false;
        }
        return true;
    };
    var data = {};
    var removedDisposalMap = {};
    var deleteNode = function () {
        var id = CID.get(this);
        var nodeDeleted = false;
        if (id && data[id]) {
            nodeDeleted = true;
            delete data[id];
        }
        if (removedDisposalMap[id]) {
            removedDisposalMap[id]();
            delete removedDisposalMap[id];
        }
        return nodeDeleted;
    };
    var setData = function (name, value) {
        var id = CID(this);
        var store = data[id] || (data[id] = {});
        if (name !== undefined) {
            store[name] = value;
            var isNode = !!(this && typeof this.nodeType === 'number');
            if (isNode && !removedDisposalMap[id]) {
                var target = this;
                removedDisposalMap[id] = domMutate.onNodeRemoval(target, function () {
                    if (!target.ownerDocument.contains(target)) {
                        setTimeout(function () {
                            deleteNode(target);
                        }, 13);
                    }
                });
            }
        }
        return store;
    };
    var domDataState = {
        _data: data,
        _removalDisposalMap: removedDisposalMap,
        getCid: function () {
            return CID.get(this);
        },
        cid: function () {
            return CID(this);
        },
        expando: CID.domExpando,
        get: function (key) {
            var id = CID.get(this), store = id && data[id];
            return key === undefined ? store : store && store[key];
        },
        set: setData,
        clean: function (prop) {
            var id = CID.get(this);
            var itemData = data[id];
            if (itemData && itemData[prop]) {
                delete itemData[prop];
            }
            if (isEmptyObject(itemData)) {
                deleteNode.call(this);
            }
        },
        delete: deleteNode
    };
    if (namespace.domDataState) {
        throw new Error('You can\'t have two versions of can-dom-data-state, check your dependencies');
    } else {
        module.exports = namespace.domDataState = domDataState;
    }
});
/*can-stache@4.0.2#helpers/core*/
define('can-stache@4.0.2#helpers/core', [
    'require',
    'exports',
    'module',
    'can-view-live',
    'can-view-nodelist',
    '../src/utils',
    'can-util/js/base-url/base-url',
    'can-util/js/join-uris/join-uris',
    'can-assign',
    'can-util/js/is-iterable/is-iterable',
    'can-log/dev/dev',
    'can-symbol',
    'can-reflect',
    'can-util/js/is-empty-object/is-empty-object',
    '../expressions/hashes',
    './-debugger',
    '../src/key-observable',
    'can-observation',
    '../src/truthy-observable',
    'can-observation-recorder',
    'can-stache-helpers',
    'can-dom-data-state'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        var live = require('can-view-live');
        var nodeLists = require('can-view-nodelist');
        var utils = require('../src/utils');
        var getBaseURL = require('can-util/js/base-url/base-url');
        var joinURIs = require('can-util/js/join-uris/join-uris');
        var assign = require('can-assign');
        var isIterable = require('can-util/js/is-iterable/is-iterable');
        var dev = require('can-log/dev/dev');
        var canSymbol = require('can-symbol');
        var canReflect = require('can-reflect');
        var isEmptyObject = require('can-util/js/is-empty-object/is-empty-object');
        var Hashes = require('../expressions/hashes');
        var debuggerHelper = require('./-debugger').helper;
        var KeyObservable = require('../src/key-observable');
        var Observation = require('can-observation');
        var TruthyObservable = require('../src/truthy-observable');
        var observationRecorder = require('can-observation-recorder');
        var helpers = require('can-stache-helpers');
        var domData = require('can-dom-data-state');
        var looksLikeOptions = function (options) {
            return options && typeof options.fn === 'function' && typeof options.inverse === 'function';
        };
        var getValueSymbol = canSymbol.for('can.getValue'), isValueLikeSymbol = canSymbol.for('can.isValueLike');
        var resolve = function (value) {
            if (value && canReflect.isValueLike(value)) {
                return canReflect.getValue(value);
            } else {
                return value;
            }
        };
        var resolveHash = function (hash) {
            var params = {};
            for (var prop in hash) {
                params[prop] = resolve(hash[prop]);
            }
            return params;
        };
        var peek = observationRecorder.ignore(resolve);
        var eachHelper = function (items) {
            var args = [].slice.call(arguments), options = args.pop(), argsLen = args.length, argExprs = options.exprData.argExprs, hashExprs = options.exprData.hashExprs, resolved = peek(items), hashOptions, aliases, key;
            if (!isEmptyObject(hashExprs)) {
                hashOptions = {};
                canReflect.eachKey(hashExprs, function (exprs, key) {
                    hashOptions[exprs.key] = key;
                });
            }
            if ((canReflect.isObservableLike(resolved) && canReflect.isListLike(resolved) || utils.isArrayLike(resolved) && canReflect.isValueLike(items)) && !options.stringOnly) {
                return function (el) {
                    var nodeList = [el];
                    nodeList.expression = 'live.list';
                    nodeLists.register(nodeList, null, options.nodeList, true);
                    nodeLists.update(options.nodeList, [el]);
                    var cb = function (item, index, parentNodeList) {
                        var aliases = {};
                        if (!isEmptyObject(hashOptions)) {
                            if (hashOptions.value) {
                                aliases[hashOptions.value] = item;
                            }
                            if (hashOptions.index) {
                                aliases[hashOptions.index] = index;
                            }
                        }
                        return options.fn(options.scope.add(aliases, { notContext: true }).add({ index: index }, { special: true }).add(item), options.options, parentNodeList);
                    };
                    live.list(el, items, cb, options.context, el.parentNode, nodeList, function (list, parentNodeList) {
                        return options.inverse(options.scope.add(list), options.options, parentNodeList);
                    });
                };
            }
            var expr = resolve(items), result;
            if (!!expr && utils.isArrayLike(expr)) {
                result = utils.getItemsFragContent(expr, options, options.scope);
                return options.stringOnly ? result.join('') : result;
            } else if (canReflect.isObservableLike(expr) && canReflect.isMapLike(expr) || expr instanceof Object) {
                result = [];
                canReflect.each(expr, function (val, key) {
                    var value = new KeyObservable(expr, key);
                    aliases = {};
                    if (!isEmptyObject(hashOptions)) {
                        if (hashOptions.value) {
                            aliases[hashOptions.value] = value;
                        }
                        if (hashOptions.key) {
                            aliases[hashOptions.key] = key;
                        }
                    }
                    result.push(options.fn(options.scope.add(aliases, { notContext: true }).add({ key: key }, { special: true }).add(value)));
                });
                return options.stringOnly ? result.join('') : result;
            }
        };
        eachHelper.isLiveBound = true;
        eachHelper.requiresOptionsArgument = true;
        var indexHelper = function (offset, options) {
            if (!options) {
                options = offset;
                offset = 0;
            }
            var index = options.scope.peek('scope.index');
            return '' + ((typeof index === 'function' ? index() : index) + offset);
        };
        indexHelper.requiresOptionsArgument = true;
        var ifHelper = function (expr, options) {
            var value;
            if (expr && canReflect.isValueLike(expr)) {
                value = canReflect.getValue(new TruthyObservable(expr));
            } else {
                value = !!resolve(expr);
            }
            if (value) {
                return options.fn(options.scope || this);
            } else {
                return options.inverse(options.scope || this);
            }
        };
        ifHelper.requiresOptionsArgument = true;
        var isHelper = function () {
            var lastValue, curValue, options = arguments[arguments.length - 1];
            if (arguments.length - 2 <= 0) {
                return options.inverse();
            }
            var args = arguments;
            var callFn = new Observation(function () {
                for (var i = 0; i < args.length - 1; i++) {
                    curValue = resolve(args[i]);
                    curValue = typeof curValue === 'function' ? curValue() : curValue;
                    if (i > 0) {
                        if (curValue !== lastValue) {
                            return false;
                        }
                    }
                    lastValue = curValue;
                }
                return true;
            });
            return callFn.get() ? options.fn() : options.inverse();
        };
        isHelper.requiresOptionsArgument = true;
        var unlessHelper = function (expr, options) {
            return ifHelper.apply(this, [
                expr,
                assign(assign({}, options), {
                    fn: options.inverse,
                    inverse: options.fn
                })
            ]);
        };
        unlessHelper.requiresOptionsArgument = true;
        var withHelper = function (expr, options) {
            var ctx = expr;
            if (!options) {
                options = expr;
                expr = true;
                ctx = options.hash;
            } else {
                expr = resolve(expr);
                if (options.hash && !isEmptyObject(options.hash)) {
                    ctx = options.scope.add(options.hash, { notContext: true }).add(ctx);
                }
            }
            return options.fn(ctx || {});
        };
        withHelper.requiresOptionsArgument = true;
        var dataHelper = function (attr) {
            var data = arguments.length === 2 ? this : arguments[1];
            return function (el) {
                domData.set.call(el, attr, data || this.context);
            };
        };
        var switchHelper = function (expression, options) {
            resolve(expression);
            var found = false;
            var caseHelper = function (value, options) {
                if (!found && resolve(expression) === resolve(value)) {
                    found = true;
                    return options.fn(options.scope.peek('this') || this);
                }
            };
            caseHelper.requiresOptionsArgument = true;
            var defaultHelper = function () {
                return !found;
            };
            canReflect.assignSymbols(defaultHelper, {
                'can.isValueLike': true,
                'can.isFunctionLike': false,
                'can.getValue': function () {
                    return this();
                }
            });
            var newScope = options.scope.add({
                case: caseHelper,
                default: defaultHelper
            }, { notContext: true });
            return options.fn(newScope, options);
        };
        switchHelper.requiresOptionsArgument = true;
        var joinBaseHelper = function (firstExpr) {
            var args = [].slice.call(arguments);
            var options = args.pop();
            var moduleReference = args.map(function (expr) {
                var value = resolve(expr);
                return typeof value === 'function' ? value() : value;
            }).join('');
            var templateModule = canReflect.getKeyValue(options.scope.templateContext.helpers, 'module');
            var parentAddress = templateModule ? templateModule.uri : undefined;
            var isRelative = moduleReference[0] === '.';
            if (isRelative && parentAddress) {
                return joinURIs(parentAddress, moduleReference);
            } else {
                var baseURL = typeof System !== 'undefined' && (System.renderingBaseURL || System.baseURL) || getBaseURL();
                if (moduleReference[0] !== '/' && baseURL[baseURL.length - 1] !== '/') {
                    baseURL += '/';
                }
                return joinURIs(baseURL, moduleReference);
            }
        };
        joinBaseHelper.requiresOptionsArgument = true;
        var builtInHelpers = {
            'debugger': debuggerHelper,
            each: eachHelper,
            eachOf: eachHelper,
            index: indexHelper,
            'if': ifHelper,
            is: isHelper,
            eq: isHelper,
            unless: unlessHelper,
            'with': withHelper,
            console: console,
            data: dataHelper,
            'switch': switchHelper,
            joinBase: joinBaseHelper
        };
        var addBuiltInHelpers = function () {
            canReflect.each(builtInHelpers, function (helper, helperName) {
                helpers[helperName] = helper;
            });
        };
        addBuiltInHelpers();
        var registerHelper = function (name, callback) {
            callback.requiresOptionsArgument = true;
            helpers[name] = callback;
        };
        var makeSimpleHelper = function (fn) {
            return function () {
                var realArgs = [];
                canReflect.eachIndex(arguments, function (val) {
                    while (val && val.isComputed) {
                        val = val();
                    }
                    realArgs.push(val);
                });
                return fn.apply(this, realArgs);
            };
        };
        module.exports = {
            registerHelper: registerHelper,
            addHelper: function (name, callback) {
                return registerHelper(name, makeSimpleHelper(callback));
            },
            addLiveHelper: function (name, callback) {
                callback.isLiveBound = true;
                return registerHelper(name, callback);
            },
            getHelper: function (name, scope) {
                var helper = scope && scope.getHelper(name);
                if (!helper) {
                    helper = helpers[name];
                }
                return helper;
            },
            resolve: resolve,
            resolveHash: resolveHash,
            looksLikeOptions: looksLikeOptions,
            __resetHelpers: function () {
                for (var helper in helpers) {
                    delete helpers[helper];
                }
                addBuiltInHelpers();
            }
        };
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-stache@4.0.2#expressions/helper*/
define('can-stache@4.0.2#expressions/helper', [
    'require',
    'exports',
    'module',
    './literal',
    './hashes',
    'can-observation',
    'can-assign',
    'can-log/dev/dev',
    'can-util/js/is-empty-object/is-empty-object',
    '../src/expression-helpers',
    '../src/utils',
    '../helpers/core',
    'can-reflect',
    'can-view-scope/scope-key-data'
], function (require, exports, module) {
    var Literal = require('./literal');
    var Hashes = require('./hashes');
    var Observation = require('can-observation');
    var assign = require('can-assign');
    var dev = require('can-log/dev/dev');
    var isEmptyObject = require('can-util/js/is-empty-object/is-empty-object');
    var expressionHelpers = require('../src/expression-helpers');
    var utils = require('../src/utils');
    var mustacheHelpers = require('../helpers/core');
    var canReflect = require('can-reflect');
    var ScopeKeyData = require('can-view-scope/scope-key-data');
    var Helper = function (methodExpression, argExpressions, hashExpressions) {
        this.methodExpr = methodExpression;
        this.argExprs = argExpressions;
        this.hashExprs = hashExpressions;
        this.mode = null;
    };
    Helper.prototype.args = function (scope) {
        var args = [];
        for (var i = 0, len = this.argExprs.length; i < len; i++) {
            var arg = this.argExprs[i];
            args.push(expressionHelpers.toComputeOrValue(arg.value.apply(arg, arguments)));
        }
        return args;
    };
    Helper.prototype.hash = function (scope) {
        var hash = {};
        for (var prop in this.hashExprs) {
            var val = this.hashExprs[prop];
            hash[prop] = expressionHelpers.toComputeOrValue(val.value.apply(val, arguments));
        }
        return hash;
    };
    Helper.prototype.value = function (scope, helperOptions) {
        var methodKey = this.methodExpr instanceof Literal ? '' + this.methodExpr._value : this.methodExpr.key, helperInstance = this, helperFn = expressionHelpers.getObservableValue_fromKey(methodKey, scope, { proxyMethods: false }), initialValue = helperFn && helperFn.initialValue, thisArg = helperFn && helperFn.thisArg;
        if (typeof initialValue === 'function') {
            helperFn = function helperFn() {
                var args = helperInstance.args(scope), helperOptionArg = assign(assign({}, helperOptions), {
                        hash: helperInstance.hash(scope),
                        exprData: helperInstance
                    });
                args.push(helperOptionArg);
                return initialValue.apply(thisArg || scope.peek('this'), args);
            };
        }
        return helperFn;
    };
    Helper.prototype.closingTag = function () {
        return this.methodExpr.key;
    };
    canReflect.assignSymbols(Helper.prototype, {
        'can.getName': function () {
            return canReflect.getName(this.constructor) + '{{' + this.sourceText() + '}}';
        }
    });
    module.exports = Helper;
});
/*can-stache@4.0.2#expressions/lookup*/
define('can-stache@4.0.2#expressions/lookup', [
    'require',
    'exports',
    'module',
    '../src/expression-helpers',
    'can-reflect',
    'can-symbol',
    'can-assign',
    'can-log/dev/dev'
], function (require, exports, module) {
    var expressionHelpers = require('../src/expression-helpers');
    var canReflect = require('can-reflect');
    var canSymbol = require('can-symbol');
    var sourceTextSymbol = canSymbol.for('can-stache.sourceText');
    var assign = require('can-assign');
    var dev = require('can-log/dev/dev');
    var Lookup = function (key, root, sourceText) {
        this.key = key;
        this.rootExpr = root;
        canReflect.setKeyValue(this, sourceTextSymbol, sourceText);
    };
    Lookup.prototype.value = function (scope, readOptions) {
        var value;
        if (this.rootExpr) {
            value = expressionHelpers.getObservableValue_fromDynamicKey_fromObservable(this.key, this.rootExpr.value(scope), scope, {}, {});
        } else {
            value = expressionHelpers.getObservableValue_fromKey(this.key, scope, readOptions);
        }
        return value;
    };
    module.exports = Lookup;
});
/*can-util@3.11.2#js/last/last*/
define('can-util@3.11.2#js/last/last', function (require, exports, module) {
    'use strict';
    module.exports = function (arr) {
        return arr && arr[arr.length - 1];
    };
});
/*can-stache@4.0.2#src/expression*/
define('can-stache@4.0.2#src/expression', [
    'require',
    'exports',
    'module',
    '../expressions/arg',
    '../expressions/literal',
    '../expressions/hashes',
    '../expressions/bracket',
    '../expressions/call',
    '../expressions/helper',
    '../expressions/lookup',
    './set-identifier',
    '../src/expression-helpers',
    './utils',
    'can-assign',
    'can-util/js/last/last',
    'can-reflect',
    'can-symbol'
], function (require, exports, module) {
    var Arg = require('../expressions/arg');
    var Literal = require('../expressions/literal');
    var Hashes = require('../expressions/hashes');
    var Bracket = require('../expressions/bracket');
    var Call = require('../expressions/call');
    var Helper = require('../expressions/helper');
    var Lookup = require('../expressions/lookup');
    var SetIdentifier = require('./set-identifier');
    var expressionHelpers = require('../src/expression-helpers');
    var utils = require('./utils');
    var assign = require('can-assign');
    var last = require('can-util/js/last/last');
    var canReflect = require('can-reflect');
    var canSymbol = require('can-symbol');
    var sourceTextSymbol = canSymbol.for('can-stache.sourceText');
    var Hash = function () {
    };
    var keyRegExp = /[\w\.\\\-_@\/\&%]+/, tokensRegExp = /('.*?'|".*?"|=|[\w\.\\\-_@\/*%\$]+|[\(\)]|,|\~|\[|\]\s*|\s*(?=\[))/g, bracketSpaceRegExp = /\]\s+/, literalRegExp = /^('.*?'|".*?"|[0-9]+\.?[0-9]*|true|false|null|undefined)$/;
    var isTokenKey = function (token) {
        return keyRegExp.test(token);
    };
    var testDot = /^[\.@]\w/;
    var isAddingToExpression = function (token) {
        return isTokenKey(token) && testDot.test(token);
    };
    var ensureChildren = function (type) {
        if (!type.children) {
            type.children = [];
        }
        return type;
    };
    var Stack = function () {
        this.root = {
            children: [],
            type: 'Root'
        };
        this.current = this.root;
        this.stack = [this.root];
    };
    assign(Stack.prototype, {
        top: function () {
            return last(this.stack);
        },
        isRootTop: function () {
            return this.top() === this.root;
        },
        popTo: function (types) {
            this.popUntil(types);
            this.pop();
        },
        pop: function () {
            if (!this.isRootTop()) {
                this.stack.pop();
            }
        },
        first: function (types) {
            var curIndex = this.stack.length - 1;
            while (curIndex > 0 && types.indexOf(this.stack[curIndex].type) === -1) {
                curIndex--;
            }
            return this.stack[curIndex];
        },
        firstParent: function (types) {
            var curIndex = this.stack.length - 2;
            while (curIndex > 0 && types.indexOf(this.stack[curIndex].type) === -1) {
                curIndex--;
            }
            return this.stack[curIndex];
        },
        popUntil: function (types) {
            while (types.indexOf(this.top().type) === -1 && !this.isRootTop()) {
                this.stack.pop();
            }
            return this.top();
        },
        addTo: function (types, type) {
            var cur = this.popUntil(types);
            ensureChildren(cur).children.push(type);
        },
        addToAndPush: function (types, type) {
            this.addTo(types, type);
            this.stack.push(type);
        },
        push: function (type) {
            this.stack.push(type);
        },
        topLastChild: function () {
            return last(this.top().children);
        },
        replaceTopLastChild: function (type) {
            var children = ensureChildren(this.top()).children;
            children.pop();
            children.push(type);
            return type;
        },
        replaceTopLastChildAndPush: function (type) {
            this.replaceTopLastChild(type);
            this.stack.push(type);
        },
        replaceTopAndPush: function (type) {
            var children;
            if (this.top() === this.root) {
                children = ensureChildren(this.top()).children;
            } else {
                this.stack.pop();
                children = ensureChildren(this.top()).children;
            }
            children.pop();
            children.push(type);
            this.stack.push(type);
            return type;
        }
    });
    var convertKeyToLookup = function (key) {
        var lastPath = key.lastIndexOf('./');
        var lastDot = key.lastIndexOf('.');
        if (lastDot > lastPath) {
            return key.substr(0, lastDot) + '@' + key.substr(lastDot + 1);
        }
        var firstNonPathCharIndex = lastPath === -1 ? 0 : lastPath + 2;
        var firstNonPathChar = key.charAt(firstNonPathCharIndex);
        if (firstNonPathChar === '.' || firstNonPathChar === '@') {
            return key.substr(0, firstNonPathCharIndex) + '@' + key.substr(firstNonPathCharIndex + 1);
        } else {
            return key.substr(0, firstNonPathCharIndex) + '@' + key.substr(firstNonPathCharIndex);
        }
    };
    var convertToAtLookup = function (ast) {
        if (ast.type === 'Lookup') {
            canReflect.setKeyValue(ast, sourceTextSymbol, ast.key);
            ast.key = convertKeyToLookup(ast.key);
        }
        return ast;
    };
    var convertToHelperIfTopIsLookup = function (stack) {
        var top = stack.top();
        if (top && top.type === 'Lookup') {
            var base = stack.stack[stack.stack.length - 2];
            if (base.type !== 'Helper' && base) {
                stack.replaceTopAndPush({
                    type: 'Helper',
                    method: top
                });
            }
        }
    };
    var expression = {
        toComputeOrValue: expressionHelpers.toComputeOrValue,
        convertKeyToLookup: convertKeyToLookup,
        Literal: Literal,
        Lookup: Lookup,
        Arg: Arg,
        Hash: Hash,
        Hashes: Hashes,
        Call: Call,
        Helper: Helper,
        Bracket: Bracket,
        SetIdentifier: SetIdentifier,
        tokenize: function (expression) {
            var tokens = [];
            (expression.trim() + ' ').replace(tokensRegExp, function (whole, arg) {
                if (bracketSpaceRegExp.test(arg)) {
                    tokens.push(arg[0]);
                    tokens.push(arg.slice(1));
                } else {
                    tokens.push(arg);
                }
            });
            return tokens;
        },
        lookupRules: {
            'default': function (ast, methodType, isArg) {
                return ast.type === 'Helper' ? Helper : Lookup;
            },
            'method': function (ast, methodType, isArg) {
                return Lookup;
            }
        },
        methodRules: {
            'default': function (ast) {
                return ast.type === 'Call' ? Call : Helper;
            },
            'call': function (ast) {
                return Call;
            }
        },
        parse: function (expressionString, options) {
            options = options || {};
            var ast = this.ast(expressionString);
            if (!options.lookupRule) {
                options.lookupRule = 'default';
            }
            if (typeof options.lookupRule === 'string') {
                options.lookupRule = expression.lookupRules[options.lookupRule];
            }
            if (!options.methodRule) {
                options.methodRule = 'default';
            }
            if (typeof options.methodRule === 'string') {
                options.methodRule = expression.methodRules[options.methodRule];
            }
            var expr = this.hydrateAst(ast, options, options.baseMethodType || 'Helper');
            return expr;
        },
        hydrateAst: function (ast, options, methodType, isArg) {
            var hashes;
            if (ast.type === 'Lookup') {
                var LookupRule = options.lookupRule(ast, methodType, isArg);
                var lookup = new LookupRule(ast.key, ast.root && this.hydrateAst(ast.root, options, methodType), ast[sourceTextSymbol]);
                return lookup;
            } else if (ast.type === 'Literal') {
                return new Literal(ast.value);
            } else if (ast.type === 'Arg') {
                return new Arg(this.hydrateAst(ast.children[0], options, methodType, isArg), { compute: true });
            } else if (ast.type === 'Hash') {
                throw new Error('');
            } else if (ast.type === 'Hashes') {
                hashes = {};
                ast.children.forEach(function (hash) {
                    hashes[hash.prop] = this.hydrateAst(hash.children[0], options, methodType, true);
                }, this);
                return new Hashes(hashes);
            } else if (ast.type === 'Call' || ast.type === 'Helper') {
                hashes = {};
                var args = [], children = ast.children, ExpressionType = options.methodRule(ast);
                if (children) {
                    for (var i = 0; i < children.length; i++) {
                        var child = children[i];
                        if (child.type === 'Hashes' && ast.type === 'Helper' && ExpressionType !== Call) {
                            child.children.forEach(function (hash) {
                                hashes[hash.prop] = this.hydrateAst(hash.children[0], options, ast.type, true);
                            }, this);
                        } else {
                            args.push(this.hydrateAst(child, options, ast.type, true));
                        }
                    }
                }
                return new ExpressionType(this.hydrateAst(ast.method, options, ast.type), args, hashes);
            } else if (ast.type === 'Bracket') {
                var originalKey;
                return new Bracket(this.hydrateAst(ast.children[0], options), ast.root ? this.hydrateAst(ast.root, options) : undefined, originalKey);
            }
        },
        ast: function (expression) {
            var tokens = this.tokenize(expression);
            return this.parseAst(tokens, { index: 0 });
        },
        parseAst: function (tokens, cursor) {
            var stack = new Stack(), top, firstParent, lastToken;
            while (cursor.index < tokens.length) {
                var token = tokens[cursor.index], nextToken = tokens[cursor.index + 1];
                cursor.index++;
                if (nextToken === '=') {
                    top = stack.top();
                    if (top && top.type === 'Lookup') {
                        firstParent = stack.firstParent([
                            'Call',
                            'Helper',
                            'Hash'
                        ]);
                        if (firstParent.type === 'Call' || firstParent.type === 'Root') {
                            stack.popUntil(['Call']);
                            top = stack.top();
                            stack.replaceTopAndPush({
                                type: 'Helper',
                                method: top.type === 'Root' ? last(top.children) : top
                            });
                        }
                    }
                    firstParent = stack.firstParent([
                        'Call',
                        'Helper',
                        'Hashes'
                    ]);
                    var hash = {
                        type: 'Hash',
                        prop: token
                    };
                    if (firstParent.type === 'Hashes') {
                        stack.addToAndPush(['Hashes'], hash);
                    } else {
                        stack.addToAndPush([
                            'Helper',
                            'Call'
                        ], {
                            type: 'Hashes',
                            children: [hash]
                        });
                        stack.push(hash);
                    }
                    cursor.index++;
                } else if (literalRegExp.test(token)) {
                    convertToHelperIfTopIsLookup(stack);
                    firstParent = stack.first([
                        'Helper',
                        'Call',
                        'Hash',
                        'Bracket'
                    ]);
                    if (firstParent.type === 'Hash' && (firstParent.children && firstParent.children.length > 0)) {
                        stack.addTo([
                            'Helper',
                            'Call',
                            'Bracket'
                        ], {
                            type: 'Literal',
                            value: utils.jsonParse(token)
                        });
                    } else if (firstParent.type === 'Bracket' && (firstParent.children && firstParent.children.length > 0)) {
                        stack.addTo([
                            'Helper',
                            'Call',
                            'Hash'
                        ], {
                            type: 'Literal',
                            value: utils.jsonParse(token)
                        });
                    } else {
                        stack.addTo([
                            'Helper',
                            'Call',
                            'Hash',
                            'Bracket'
                        ], {
                            type: 'Literal',
                            value: utils.jsonParse(token)
                        });
                    }
                } else if (keyRegExp.test(token)) {
                    lastToken = stack.topLastChild();
                    firstParent = stack.first([
                        'Helper',
                        'Call',
                        'Hash',
                        'Bracket'
                    ]);
                    if (lastToken && (lastToken.type === 'Call' || lastToken.type === 'Bracket') && isAddingToExpression(token)) {
                        stack.replaceTopLastChildAndPush({
                            type: 'Lookup',
                            root: lastToken,
                            key: token.slice(1)
                        });
                    } else if (firstParent.type === 'Bracket') {
                        if (!(firstParent.children && firstParent.children.length > 0)) {
                            stack.addToAndPush(['Bracket'], {
                                type: 'Lookup',
                                key: token
                            });
                        } else {
                            if (stack.first([
                                    'Helper',
                                    'Call',
                                    'Hash',
                                    'Arg'
                                ]).type === 'Helper' && token[0] !== '.') {
                                stack.addToAndPush(['Helper'], {
                                    type: 'Lookup',
                                    key: token
                                });
                            } else {
                                stack.replaceTopAndPush({
                                    type: 'Lookup',
                                    key: token.slice(1),
                                    root: firstParent
                                });
                            }
                        }
                    } else {
                        convertToHelperIfTopIsLookup(stack);
                        stack.addToAndPush([
                            'Helper',
                            'Call',
                            'Hash',
                            'Arg',
                            'Bracket'
                        ], {
                            type: 'Lookup',
                            key: token
                        });
                    }
                } else if (token === '~') {
                    convertToHelperIfTopIsLookup(stack);
                    stack.addToAndPush([
                        'Helper',
                        'Call',
                        'Hash'
                    ], {
                        type: 'Arg',
                        key: token
                    });
                } else if (token === '(') {
                    top = stack.top();
                    if (top.type === 'Lookup') {
                        stack.replaceTopAndPush({
                            type: 'Call',
                            method: convertToAtLookup(top)
                        });
                    } else {
                        throw new Error('Unable to understand expression ' + tokens.join(''));
                    }
                } else if (token === ')') {
                    stack.popTo(['Call']);
                } else if (token === ',') {
                    stack.popUntil(['Call']);
                } else if (token === '[') {
                    top = stack.top();
                    lastToken = stack.topLastChild();
                    if (lastToken && (lastToken.type === 'Call' || lastToken.type === 'Bracket')) {
                        stack.replaceTopAndPush({
                            type: 'Bracket',
                            root: lastToken
                        });
                    } else if (top.type === 'Lookup' || top.type === 'Bracket') {
                        var bracket = {
                            type: 'Bracket',
                            root: top
                        };
                        stack.replaceTopAndPush(bracket);
                    } else if (top.type === 'Call') {
                        stack.addToAndPush(['Call'], { type: 'Bracket' });
                    } else if (top === ' ') {
                        stack.popUntil(['Lookup']);
                        convertToHelperIfTopIsLookup(stack);
                        stack.addToAndPush([
                            'Helper',
                            'Call',
                            'Hash'
                        ], { type: 'Bracket' });
                    } else {
                        stack.replaceTopAndPush({ type: 'Bracket' });
                    }
                } else if (token === ']') {
                    stack.pop();
                } else if (token === ' ') {
                    stack.push(token);
                }
            }
            return stack.root.children[0];
        }
    };
    module.exports = expression;
});
/*can-stache@4.0.2#src/mustache_core*/
define('can-stache@4.0.2#src/mustache_core', [
    'require',
    'exports',
    'module',
    'can-view-live',
    'can-view-nodelist',
    'can-observation',
    'can-observation-recorder',
    './utils',
    './expression',
    'can-util/dom/frag/frag',
    'can-dom-mutate',
    'can-symbol',
    'can-reflect',
    'can-log/dev/dev'
], function (require, exports, module) {
    var live = require('can-view-live');
    var nodeLists = require('can-view-nodelist');
    var Observation = require('can-observation');
    var ObservationRecorder = require('can-observation-recorder');
    var utils = require('./utils');
    var expression = require('./expression');
    var frag = require('can-util/dom/frag/frag');
    var domMutate = require('can-dom-mutate');
    var canSymbol = require('can-symbol');
    var canReflect = require('can-reflect');
    var dev = require('can-log/dev/dev');
    var mustacheLineBreakRegExp = /(?:(^|\r?\n)(\s*)(\{\{([\s\S]*)\}\}\}?)([^\S\n\r]*)($|\r?\n))|(\{\{([\s\S]*)\}\}\}?)/g, mustacheWhitespaceRegExp = /(\s*)(\{\{\{?)(-?)([\s\S]*?)(-?)(\}\}\}?)(\s*)/g, k = function () {
        };
    var core = {
        expression: expression,
        makeEvaluator: function (scope, nodeList, mode, exprData, truthyRenderer, falseyRenderer, stringOnly) {
            if (mode === '^') {
                var temp = truthyRenderer;
                truthyRenderer = falseyRenderer;
                falseyRenderer = temp;
            }
            var value, helperOptions = {
                    metadata: { rendered: false },
                    stringOnly: stringOnly,
                    context: scope.peek('this'),
                    scope: scope,
                    nodeList: nodeList,
                    exprData: exprData
                };
            utils.createRenderers(helperOptions, scope, nodeList, truthyRenderer, falseyRenderer, stringOnly);
            if (exprData instanceof expression.Call) {
                value = exprData.value(scope, helperOptions);
            } else if (exprData instanceof expression.Bracket) {
                value = exprData.value(scope);
            } else if (exprData instanceof expression.Lookup) {
                value = exprData.value(scope);
            } else if (exprData instanceof expression.Helper && exprData.methodExpr instanceof expression.Bracket) {
                value = exprData.methodExpr.value(scope, helperOptions);
            } else {
                value = exprData.value(scope, helperOptions);
                if (typeof value === 'function') {
                    return value;
                }
            }
            if (!mode || helperOptions.metadata.rendered) {
                return value;
            } else if (mode === '#' || mode === '^') {
                return function () {
                    var finalValue = canReflect.getValue(value);
                    if (typeof finalValue === 'function') {
                        return finalValue;
                    } else if (typeof finalValue !== 'string' && utils.isArrayLike(finalValue)) {
                        var isObserveList = canReflect.isObservableLike(finalValue) && canReflect.isListLike(finalValue);
                        if (canReflect.getKeyValue(finalValue, 'length')) {
                            if (stringOnly) {
                                return utils.getItemsStringContent(finalValue, isObserveList, helperOptions);
                            } else {
                                return frag(utils.getItemsFragContent(finalValue, helperOptions, scope));
                            }
                        } else {
                            return helperOptions.inverse(scope);
                        }
                    } else {
                        return finalValue ? helperOptions.fn(finalValue || scope) : helperOptions.inverse(scope);
                    }
                };
            } else {
            }
        },
        makeLiveBindingPartialRenderer: function (expressionString, state) {
            expressionString = expressionString.trim();
            var exprData, partialName = expressionString.split(/\s+/).shift();
            if (partialName !== expressionString) {
                exprData = core.expression.parse(expressionString);
            }
            return function (scope, parentSectionNodeList) {
                var nodeList = [this];
                nodeList.expression = '>' + partialName;
                nodeLists.register(nodeList, null, parentSectionNodeList || true, state.directlyNested);
                var partialFrag = new Observation(function () {
                    var localPartialName = partialName;
                    if (exprData && exprData.argExprs.length === 1) {
                        var newContext = canReflect.getValue(exprData.argExprs[0].value(scope));
                        if (typeof newContext === 'undefined') {
                        } else {
                            scope = scope.add(newContext);
                        }
                    }
                    var partial = canReflect.getKeyValue(scope.templateContext.partials, localPartialName);
                    var renderer;
                    if (partial) {
                        renderer = function () {
                            return partial.render ? partial.render(scope, nodeList) : partial(scope);
                        };
                    } else {
                        var scopePartialName = scope.read(localPartialName, { isArgument: true }).value;
                        if (scopePartialName === null || !scopePartialName && localPartialName[0] === '*') {
                            return frag('');
                        }
                        if (scopePartialName) {
                            localPartialName = scopePartialName;
                        }
                        renderer = function () {
                            if (typeof localPartialName === 'function') {
                                return localPartialName(scope, {}, nodeList);
                            } else {
                                return core.getTemplateById(localPartialName)(scope, {}, nodeList);
                            }
                        };
                    }
                    var res = ObservationRecorder.ignore(renderer)();
                    return frag(res);
                });
                canReflect.setPriority(partialFrag, nodeList.nesting);
                live.html(this, partialFrag, this.parentNode, nodeList);
            };
        },
        makeStringBranchRenderer: function (mode, expressionString, state) {
            var exprData = core.expression.parse(expressionString), fullExpression = mode + expressionString;
            if (!(exprData instanceof expression.Helper) && !(exprData instanceof expression.Call)) {
                exprData = new expression.Helper(exprData, [], {});
            }
            var branchRenderer = function branchRenderer(scope, truthyRenderer, falseyRenderer) {
                var evaluator = scope.__cache[fullExpression];
                if (mode || !evaluator) {
                    evaluator = makeEvaluator(scope, null, mode, exprData, truthyRenderer, falseyRenderer, true);
                    if (!mode) {
                        scope.__cache[fullExpression] = evaluator;
                    }
                }
                var gotObservableValue = evaluator[canSymbol.for('can.onValue')], res;
                if (gotObservableValue) {
                    res = canReflect.getValue(evaluator);
                } else {
                    res = evaluator();
                }
                return res == null ? '' : '' + res;
            };
            branchRenderer.exprData = exprData;
            return branchRenderer;
        },
        makeLiveBindingBranchRenderer: function (mode, expressionString, state) {
            var exprData = core.expression.parse(expressionString);
            if (!(exprData instanceof expression.Helper) && !(exprData instanceof expression.Call) && !(exprData instanceof expression.Bracket) && !(exprData instanceof expression.Lookup)) {
                exprData = new expression.Helper(exprData, [], {});
            }
            var branchRenderer = function branchRenderer(scope, parentSectionNodeList, truthyRenderer, falseyRenderer) {
                var stringOnly = state.tag;
                var nodeList = [this];
                nodeList.expression = expressionString;
                nodeLists.register(nodeList, null, parentSectionNodeList || true, state.directlyNested);
                var evaluator = makeEvaluator(scope, nodeList, mode, exprData, truthyRenderer, falseyRenderer, stringOnly);
                var gotObservableValue = evaluator[canSymbol.for('can.onValue')];
                var observable;
                if (gotObservableValue) {
                    observable = evaluator;
                } else {
                    observable = new Observation(evaluator, null, { isObservable: false });
                }
                if (canReflect.setPriority(observable, nodeList.nesting) === false) {
                    throw new Error('can-stache unable to set priority on observable');
                }
                canReflect.onValue(observable, k);
                var value = canReflect.getValue(observable);
                if (typeof value === 'function' && !(exprData instanceof expression.Lookup)) {
                    ObservationRecorder.ignore(value)(this);
                } else if (canReflect.valueHasDependencies(observable)) {
                    if (state.attr) {
                        live.attr(this, state.attr, observable);
                    } else if (state.tag) {
                        live.attrs(this, observable);
                    } else if (state.text && typeof value !== 'object') {
                        live.text(this, observable, this.parentNode, nodeList);
                    } else {
                        live.html(this, observable, this.parentNode, nodeList);
                    }
                } else {
                    if (state.attr) {
                        domMutate.setAttribute(this, state.attr, value);
                    } else if (state.tag) {
                        live.attrs(this, value);
                    } else if (state.text && typeof value === 'string') {
                        this.nodeValue = value;
                    } else if (value != null) {
                        nodeLists.replace([this], frag(value, this.ownerDocument));
                    }
                }
                canReflect.offValue(observable, k);
            };
            branchRenderer.exprData = exprData;
            return branchRenderer;
        },
        splitModeFromExpression: function (expression, state) {
            expression = expression.trim();
            var mode = expression.charAt(0);
            if ('#/{&^>!<'.indexOf(mode) >= 0) {
                expression = expression.substr(1).trim();
            } else {
                mode = null;
            }
            if (mode === '{' && state.node) {
                mode = null;
            }
            return {
                mode: mode,
                expression: expression
            };
        },
        cleanLineEndings: function (template) {
            return template.replace(mustacheLineBreakRegExp, function (whole, returnBefore, spaceBefore, special, expression, spaceAfter, returnAfter, spaceLessSpecial, spaceLessExpression, matchIndex) {
                spaceAfter = spaceAfter || '';
                returnBefore = returnBefore || '';
                spaceBefore = spaceBefore || '';
                var modeAndExpression = splitModeFromExpression(expression || spaceLessExpression, {});
                if (spaceLessSpecial || '>{'.indexOf(modeAndExpression.mode) >= 0) {
                    return whole;
                } else if ('^#!/'.indexOf(modeAndExpression.mode) >= 0) {
                    spaceBefore = returnBefore + spaceBefore && ' ';
                    return spaceBefore + special + (matchIndex !== 0 && returnAfter.length ? returnBefore + '\n' : '');
                } else {
                    return spaceBefore + special + spaceAfter + (spaceBefore.length || matchIndex !== 0 ? returnBefore + '\n' : '');
                }
            });
        },
        cleanWhitespaceControl: function (template) {
            return template.replace(mustacheWhitespaceRegExp, function (whole, spaceBefore, bracketBefore, controlBefore, expression, controlAfter, bracketAfter, spaceAfter, matchIndex) {
                if (controlBefore === '-') {
                    spaceBefore = '';
                }
                if (controlAfter === '-') {
                    spaceAfter = '';
                }
                return spaceBefore + bracketBefore + expression + bracketAfter + spaceAfter;
            });
        },
        getTemplateById: function () {
        }
    };
    var makeEvaluator = core.makeEvaluator, splitModeFromExpression = core.splitModeFromExpression;
    module.exports = core;
});
/*can-stache@4.0.2#src/html_section*/
define('can-stache@4.0.2#src/html_section', [
    'require',
    'exports',
    'module',
    'can-view-target',
    'can-view-scope',
    'can-observation',
    'can-observation-recorder',
    'can-reflect',
    './utils',
    './mustache_core',
    'can-globals/document/document',
    'can-assign',
    'can-util/js/last/last'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        var target = require('can-view-target');
        var Scope = require('can-view-scope');
        var Observation = require('can-observation');
        var ObservationRecorder = require('can-observation-recorder');
        var canReflect = require('can-reflect');
        var utils = require('./utils');
        var mustacheCore = require('./mustache_core');
        var getDocument = require('can-globals/document/document');
        var assign = require('can-assign');
        var last = require('can-util/js/last/last');
        var decodeHTML = typeof document !== 'undefined' && function () {
            var el = getDocument().createElement('div');
            return function (html) {
                if (html.indexOf('&') === -1) {
                    return html.replace(/\r\n/g, '\n');
                }
                el.innerHTML = html;
                return el.childNodes.length === 0 ? '' : el.childNodes.item(0).nodeValue;
            };
        }();
        var HTMLSectionBuilder = function (filename) {
            if (filename) {
                this.filename = filename;
            }
            this.stack = [new HTMLSection()];
        };
        HTMLSectionBuilder.scopify = function (renderer) {
            return ObservationRecorder.ignore(function (scope, options, nodeList) {
                if (!(scope instanceof Scope)) {
                    scope = new Scope(scope || {});
                }
                if (nodeList === undefined && canReflect.isListLike(options)) {
                    nodeList = options;
                    options = undefined;
                }
                if (options && !options.helpers && !options.partials && !options.tags) {
                    options = { helpers: options };
                }
                canReflect.eachKey(options && options.helpers, function (helperValue) {
                    helperValue.requiresOptionsArgument = true;
                });
                var templateContext = scope.templateContext;
                canReflect.eachKey(options, function (optionValues, optionKey) {
                    var container = templateContext[optionKey];
                    if (container) {
                        canReflect.eachKey(optionValues, function (optionValue, optionValueKey) {
                            canReflect.setKeyValue(container, optionValueKey, optionValue);
                        });
                    }
                });
                return renderer(scope, nodeList);
            });
        };
        assign(HTMLSectionBuilder.prototype, utils.mixins);
        assign(HTMLSectionBuilder.prototype, {
            startSubSection: function (process) {
                var newSection = new HTMLSection(process);
                this.stack.push(newSection);
                return newSection;
            },
            endSubSectionAndReturnRenderer: function () {
                if (this.last().isEmpty()) {
                    this.stack.pop();
                    return null;
                } else {
                    var htmlSection = this.endSection();
                    return htmlSection.compiled.hydrate.bind(htmlSection.compiled);
                }
            },
            startSection: function (process) {
                var newSection = new HTMLSection(process);
                this.last().add(newSection.targetCallback);
                this.stack.push(newSection);
            },
            endSection: function () {
                this.last().compile();
                return this.stack.pop();
            },
            inverse: function () {
                this.last().inverse();
            },
            compile: function () {
                var compiled = this.stack.pop().compile();
                return ObservationRecorder.ignore(function (scope, nodeList) {
                    if (!(scope instanceof Scope)) {
                        scope = new Scope(scope || {});
                    }
                    return compiled.hydrate(scope, nodeList);
                });
            },
            push: function (chars) {
                this.last().push(chars);
            },
            pop: function () {
                return this.last().pop();
            },
            removeCurrentNode: function () {
                this.last().removeCurrentNode();
            }
        });
        var HTMLSection = function (process) {
            this.data = 'targetData';
            this.targetData = [];
            this.targetStack = [];
            var self = this;
            this.targetCallback = function (scope, sectionNode) {
                process.call(this, scope, sectionNode, self.compiled.hydrate.bind(self.compiled), self.inverseCompiled && self.inverseCompiled.hydrate.bind(self.inverseCompiled));
            };
        };
        assign(HTMLSection.prototype, {
            inverse: function () {
                this.inverseData = [];
                this.data = 'inverseData';
            },
            push: function (data) {
                this.add(data);
                this.targetStack.push(data);
            },
            pop: function () {
                return this.targetStack.pop();
            },
            add: function (data) {
                if (typeof data === 'string') {
                    data = decodeHTML(data);
                }
                if (this.targetStack.length) {
                    last(this.targetStack).children.push(data);
                } else {
                    this[this.data].push(data);
                }
            },
            compile: function () {
                this.compiled = target(this.targetData, getDocument());
                if (this.inverseData) {
                    this.inverseCompiled = target(this.inverseData, getDocument());
                    delete this.inverseData;
                }
                this.targetStack = this.targetData = null;
                return this.compiled;
            },
            removeCurrentNode: function () {
                var children = this.children();
                return children.pop();
            },
            children: function () {
                if (this.targetStack.length) {
                    return last(this.targetStack).children;
                } else {
                    return this[this.data];
                }
            },
            isEmpty: function () {
                return !this.targetData.length;
            }
        });
        HTMLSectionBuilder.HTMLSection = HTMLSection;
        module.exports = HTMLSectionBuilder;
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-stache@4.0.2#src/text_section*/
define('can-stache@4.0.2#src/text_section', [
    'require',
    'exports',
    'module',
    'can-view-live',
    './utils',
    'can-dom-mutate',
    'can-assign',
    'can-reflect',
    'can-observation'
], function (require, exports, module) {
    var live = require('can-view-live');
    var utils = require('./utils');
    var domMutate = require('can-dom-mutate');
    var assign = require('can-assign');
    var canReflect = require('can-reflect');
    var Observation = require('can-observation');
    var noop = function () {
    };
    var TextSectionBuilder = function () {
        this.stack = [new TextSection()];
    };
    assign(TextSectionBuilder.prototype, utils.mixins);
    assign(TextSectionBuilder.prototype, {
        startSection: function (process) {
            var subSection = new TextSection();
            this.last().add({
                process: process,
                truthy: subSection
            });
            this.stack.push(subSection);
        },
        endSection: function () {
            this.stack.pop();
        },
        inverse: function () {
            this.stack.pop();
            var falseySection = new TextSection();
            this.last().last().falsey = falseySection;
            this.stack.push(falseySection);
        },
        compile: function (state) {
            var renderer = this.stack[0].compile();
            return function (scope) {
                function textSectionRender() {
                    return renderer(scope);
                }
                var observation = new Observation(textSectionRender, null, { isObservable: false });
                canReflect.onValue(observation, noop);
                var value = canReflect.getValue(observation);
                if (canReflect.valueHasDependencies(observation)) {
                    if (state.textContentOnly) {
                        live.text(this, observation);
                    } else if (state.attr) {
                        live.attr(this, state.attr, observation);
                    } else {
                        live.attrs(this, observation, scope);
                    }
                    canReflect.offValue(observation, noop);
                } else {
                    if (state.textContentOnly) {
                        this.nodeValue = value;
                    } else if (state.attr) {
                        domMutate.setAttribute(this, state.attr, value);
                    } else {
                        live.attrs(this, value);
                    }
                }
            };
        }
    });
    var passTruthyFalsey = function (process, truthy, falsey) {
        return function (scope) {
            return process.call(this, scope, truthy, falsey);
        };
    };
    var TextSection = function () {
        this.values = [];
    };
    assign(TextSection.prototype, {
        add: function (data) {
            this.values.push(data);
        },
        last: function () {
            return this.values[this.values.length - 1];
        },
        compile: function () {
            var values = this.values, len = values.length;
            for (var i = 0; i < len; i++) {
                var value = this.values[i];
                if (typeof value === 'object') {
                    values[i] = passTruthyFalsey(value.process, value.truthy && value.truthy.compile(), value.falsey && value.falsey.compile());
                }
            }
            return function (scope) {
                var txt = '', value;
                for (var i = 0; i < len; i++) {
                    value = values[i];
                    txt += typeof value === 'string' ? value : value.call(this, scope);
                }
                return txt;
            };
        }
    });
    module.exports = TextSectionBuilder;
});
/*can-stache@4.0.2#helpers/converter*/
define('can-stache@4.0.2#helpers/converter', [
    'require',
    'exports',
    'module',
    './core',
    '../src/set-identifier',
    'can-reflect'
], function (require, exports, module) {
    var helpers = require('./core');
    var SetIdentifier = require('../src/set-identifier');
    var canReflect = require('can-reflect');
    function makeConverter(getterSetter) {
        getterSetter = getterSetter || {};
        return function (newVal, source) {
            var args = canReflect.toArray(arguments);
            if (newVal instanceof SetIdentifier) {
                return typeof getterSetter.set === 'function' ? getterSetter.set.apply(this, [newVal.value].concat(args.slice(1))) : source(newVal.value);
            } else {
                return typeof getterSetter.get === 'function' ? getterSetter.get.apply(this, args) : args[0];
            }
        };
    }
    helpers.addConverter = function (name, getterSetter) {
        var helper = makeConverter(getterSetter);
        helper.isLiveBound = true;
        helpers.registerHelper(name, helper);
    };
    helpers.registerConverter = function (name, getterSetter) {
        helpers.registerHelper(name, makeConverter(getterSetter));
    };
    module.exports = helpers;
});
/*can-stache@4.0.2#src/intermediate_and_imports*/
define('can-stache@4.0.2#src/intermediate_and_imports', [
    'require',
    'exports',
    'module',
    './mustache_core',
    'can-view-parser'
], function (require, exports, module) {
    var mustacheCore = require('./mustache_core');
    var parser = require('can-view-parser');
    module.exports = function (filename, source) {
        if (arguments.length === 1) {
            source = arguments[0];
            filename = undefined;
        }
        var template = source;
        template = mustacheCore.cleanWhitespaceControl(template);
        template = mustacheCore.cleanLineEndings(template);
        var imports = [], dynamicImports = [], ases = {}, inImport = false, inFrom = false, inAs = false, isUnary = false, importIsDynamic = false, currentAs = '', currentFrom = '';
        function processImport() {
            if (currentAs) {
                ases[currentAs] = currentFrom;
                currentAs = '';
            }
            if (importIsDynamic) {
                dynamicImports.push(currentFrom);
            } else {
                imports.push(currentFrom);
            }
        }
        var intermediate = parser(template, {
            filename: filename,
            start: function (tagName, unary) {
                if (tagName === 'can-import') {
                    isUnary = unary;
                    importIsDynamic = false;
                    inImport = true;
                } else if (tagName === 'can-dynamic-import') {
                    isUnary = unary;
                    importIsDynamic = true;
                    inImport = true;
                } else if (inImport) {
                    importIsDynamic = true;
                    inImport = false;
                }
            },
            attrStart: function (attrName) {
                if (attrName === 'from') {
                    inFrom = true;
                } else if (attrName === 'as' || attrName === 'export-as') {
                    inAs = true;
                }
            },
            attrEnd: function (attrName) {
                if (attrName === 'from') {
                    inFrom = false;
                } else if (attrName === 'as' || attrName === 'export-as') {
                    inAs = false;
                }
            },
            attrValue: function (value) {
                if (inFrom && inImport) {
                    currentFrom = value;
                } else if (inAs && inImport) {
                    currentAs = value;
                }
            },
            end: function (tagName) {
                if ((tagName === 'can-import' || tagName === 'can-dymamic-import') && isUnary) {
                    processImport();
                }
            },
            close: function (tagName) {
                if (tagName === 'can-import' || tagName === 'can-dymamic-import') {
                    processImport();
                }
            },
            chars: function (text) {
                if (text.trim().length > 0) {
                    importIsDynamic = true;
                }
            },
            special: function (text) {
                importIsDynamic = true;
            }
        }, true);
        return {
            intermediate: intermediate,
            imports: imports,
            dynamicImports: dynamicImports,
            ases: ases,
            exports: ases
        };
    };
});
/*can-util@3.11.2#js/import/import*/
define('can-util@3.11.2#js/import/import', [
    'require',
    'exports',
    'module',
    '../is-function/is-function',
    'can-globals/global/global'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        'use strict';
        var isFunction = require('../is-function/is-function');
        var global = require('can-globals/global/global')();
        module.exports = function (moduleName, parentName) {
            return new Promise(function (resolve, reject) {
                try {
                    if (typeof global.System === 'object' && isFunction(global.System['import'])) {
                        global.System['import'](moduleName, { name: parentName }).then(resolve, reject);
                    } else if (global.define && global.define.amd) {
                        global.require([moduleName], function (value) {
                            resolve(value);
                        });
                    } else if (global.require) {
                        resolve(global.require(moduleName));
                    } else {
                        if (typeof stealRequire !== 'undefined') {
                            steal.import(moduleName, { name: parentName }).then(resolve, reject);
                        } else {
                            resolve();
                        }
                    }
                } catch (err) {
                    reject(err);
                }
            });
        };
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-stache@4.0.2#can-stache*/
define('can-stache@4.0.2#can-stache', [
    'require',
    'exports',
    'module',
    'can-view-parser',
    'can-view-callbacks',
    './src/html_section',
    './src/text_section',
    './src/mustache_core',
    './helpers/core',
    './helpers/converter',
    './src/intermediate_and_imports',
    './src/utils',
    'can-attribute-encoder',
    'can-log/dev/dev',
    'can-namespace',
    'can-globals/document/document',
    'can-assign',
    'can-util/js/last/last',
    'can-util/js/import/import',
    'can-reflect',
    'can-view-target',
    'can-view-nodelist'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        var parser = require('can-view-parser');
        var viewCallbacks = require('can-view-callbacks');
        var HTMLSectionBuilder = require('./src/html_section');
        var TextSectionBuilder = require('./src/text_section');
        var mustacheCore = require('./src/mustache_core');
        var mustacheHelpers = require('./helpers/core');
        require('./helpers/converter');
        var getIntermediateAndImports = require('./src/intermediate_and_imports');
        var makeRendererConvertScopes = require('./src/utils').makeRendererConvertScopes;
        var attributeEncoder = require('can-attribute-encoder');
        var dev = require('can-log/dev/dev');
        var namespace = require('can-namespace');
        var DOCUMENT = require('can-globals/document/document');
        var assign = require('can-assign');
        var last = require('can-util/js/last/last');
        var importer = require('can-util/js/import/import');
        var canReflect = require('can-reflect');
        require('can-view-target');
        require('can-view-nodelist');
        if (!viewCallbacks.tag('content')) {
            viewCallbacks.tag('content', function (el, tagData) {
                return tagData.scope;
            });
        }
        var wrappedAttrPattern = /[{(].*[)}]/;
        var colonWrappedAttrPattern = /^on:|(:to|:from|:bind)$|.*:to:on:.*/;
        var svgNamespace = 'http://www.w3.org/2000/svg';
        var namespaces = {
                'svg': svgNamespace,
                'g': svgNamespace
            }, textContentOnlyTag = {
                style: true,
                script: true
            };
        function stache(filename, template) {
            if (arguments.length === 1) {
                template = arguments[0];
                filename = undefined;
            }
            var inlinePartials = {};
            if (typeof template === 'string') {
                template = mustacheCore.cleanWhitespaceControl(template);
                template = mustacheCore.cleanLineEndings(template);
            }
            var section = new HTMLSectionBuilder(filename), state = {
                    node: null,
                    attr: null,
                    sectionElementStack: [],
                    text: false,
                    namespaceStack: [],
                    textContentOnly: null
                }, makeRendererAndUpdateSection = function (section, mode, stache, lineNo) {
                    if (mode === '>') {
                        section.add(mustacheCore.makeLiveBindingPartialRenderer(stache, copyState({ lineNo: lineNo })));
                    } else if (mode === '/') {
                        var createdSection = section.last();
                        if (createdSection.startedWith === '<') {
                            inlinePartials[stache] = section.endSubSectionAndReturnRenderer();
                            section.removeCurrentNode();
                        } else {
                            section.endSection();
                        }
                        if (section instanceof HTMLSectionBuilder) {
                            state.sectionElementStack.pop();
                        }
                    } else if (mode === 'else') {
                        section.inverse();
                    } else {
                        var makeRenderer = section instanceof HTMLSectionBuilder ? mustacheCore.makeLiveBindingBranchRenderer : mustacheCore.makeStringBranchRenderer;
                        if (mode === '{' || mode === '&') {
                            section.add(makeRenderer(null, stache, copyState({ lineNo: lineNo })));
                        } else if (mode === '#' || mode === '^' || mode === '<') {
                            var renderer = makeRenderer(mode, stache, copyState({ lineNo: lineNo }));
                            section.startSection(renderer);
                            section.last().startedWith = mode;
                            if (section instanceof HTMLSectionBuilder) {
                                state.sectionElementStack.push({ type: 'section' });
                            }
                        } else {
                            section.add(makeRenderer(null, stache, copyState({
                                text: true,
                                lineNo: lineNo
                            })));
                        }
                    }
                }, copyState = function (overwrites) {
                    var lastElement = state.sectionElementStack[state.sectionElementStack.length - 1];
                    var cur = {
                        tag: state.node && state.node.tag,
                        attr: state.attr && state.attr.name,
                        directlyNested: state.sectionElementStack.length ? lastElement.type === 'section' || lastElement.type === 'custom' : true,
                        textContentOnly: !!state.textContentOnly
                    };
                    return overwrites ? assign(cur, overwrites) : cur;
                }, addAttributesCallback = function (node, callback) {
                    if (!node.attributes) {
                        node.attributes = [];
                    }
                    node.attributes.unshift(callback);
                };
            parser(template, {
                filename: filename,
                start: function (tagName, unary, lineNo) {
                    var matchedNamespace = namespaces[tagName];
                    if (matchedNamespace && !unary) {
                        state.namespaceStack.push(matchedNamespace);
                    }
                    state.node = {
                        tag: tagName,
                        children: [],
                        namespace: matchedNamespace || last(state.namespaceStack)
                    };
                },
                end: function (tagName, unary, lineNo) {
                    var isCustomTag = viewCallbacks.tag(tagName);
                    if (unary) {
                        section.add(state.node);
                        if (isCustomTag) {
                            addAttributesCallback(state.node, function (scope, parentNodeList) {
                                viewCallbacks.tagHandler(this, tagName, {
                                    scope: scope,
                                    subtemplate: null,
                                    templateType: 'stache',
                                    parentNodeList: parentNodeList
                                });
                            });
                        }
                    } else {
                        section.push(state.node);
                        state.sectionElementStack.push({
                            type: isCustomTag ? 'custom' : null,
                            tag: isCustomTag ? null : tagName,
                            templates: {}
                        });
                        if (isCustomTag) {
                            section.startSubSection();
                        } else if (textContentOnlyTag[tagName]) {
                            state.textContentOnly = new TextSectionBuilder();
                        }
                    }
                    state.node = null;
                },
                close: function (tagName, lineNo) {
                    var matchedNamespace = namespaces[tagName];
                    if (matchedNamespace) {
                        state.namespaceStack.pop();
                    }
                    var isCustomTag = viewCallbacks.tag(tagName), renderer;
                    if (isCustomTag) {
                        renderer = section.endSubSectionAndReturnRenderer();
                    }
                    if (textContentOnlyTag[tagName]) {
                        section.last().add(state.textContentOnly.compile(copyState()));
                        state.textContentOnly = null;
                    }
                    var oldNode = section.pop();
                    if (isCustomTag) {
                        if (tagName === 'can-template') {
                            var parent = state.sectionElementStack[state.sectionElementStack.length - 2];
                            if (renderer) {
                                parent.templates[oldNode.attrs.name] = makeRendererConvertScopes(renderer);
                            }
                            section.removeCurrentNode();
                        } else {
                            var current = state.sectionElementStack[state.sectionElementStack.length - 1];
                            addAttributesCallback(oldNode, function (scope, parentNodeList) {
                                viewCallbacks.tagHandler(this, tagName, {
                                    scope: scope,
                                    subtemplate: renderer ? makeRendererConvertScopes(renderer) : renderer,
                                    templateType: 'stache',
                                    parentNodeList: parentNodeList,
                                    templates: current.templates
                                });
                            });
                        }
                    }
                    state.sectionElementStack.pop();
                },
                attrStart: function (attrName, lineNo) {
                    if (state.node.section) {
                        state.node.section.add(attrName + '="');
                    } else {
                        state.attr = {
                            name: attrName,
                            value: ''
                        };
                    }
                },
                attrEnd: function (attrName, lineNo) {
                    if (state.node.section) {
                        state.node.section.add('" ');
                    } else {
                        if (!state.node.attrs) {
                            state.node.attrs = {};
                        }
                        state.node.attrs[state.attr.name] = state.attr.section ? state.attr.section.compile(copyState()) : state.attr.value;
                        var attrCallback = viewCallbacks.attr(attrName);
                        if (attrCallback) {
                            if (!state.node.attributes) {
                                state.node.attributes = [];
                            }
                            state.node.attributes.push(function (scope, nodeList) {
                                attrCallback(this, {
                                    attributeName: attrName,
                                    scope: scope,
                                    nodeList: nodeList
                                });
                            });
                        }
                        state.attr = null;
                    }
                },
                attrValue: function (value, lineNo) {
                    var section = state.node.section || state.attr.section;
                    if (section) {
                        section.add(value);
                    } else {
                        state.attr.value += value;
                    }
                },
                chars: function (text, lineNo) {
                    (state.textContentOnly || section).add(text);
                },
                special: function (text, lineNo) {
                    var firstAndText = mustacheCore.splitModeFromExpression(text, state), mode = firstAndText.mode, expression = firstAndText.expression;
                    if (expression === 'else') {
                        var inverseSection;
                        if (state.attr && state.attr.section) {
                            inverseSection = state.attr.section;
                        } else if (state.node && state.node.section) {
                            inverseSection = state.node.section;
                        } else {
                            inverseSection = state.textContentOnly || section;
                        }
                        inverseSection.inverse();
                        return;
                    }
                    if (mode === '!') {
                        return;
                    }
                    if (state.node && state.node.section) {
                        makeRendererAndUpdateSection(state.node.section, mode, expression, lineNo);
                        if (state.node.section.subSectionDepth() === 0) {
                            state.node.attributes.push(state.node.section.compile(copyState()));
                            delete state.node.section;
                        }
                    } else if (state.attr) {
                        if (!state.attr.section) {
                            state.attr.section = new TextSectionBuilder();
                            if (state.attr.value) {
                                state.attr.section.add(state.attr.value);
                            }
                        }
                        makeRendererAndUpdateSection(state.attr.section, mode, expression, lineNo);
                    } else if (state.node) {
                        if (!state.node.attributes) {
                            state.node.attributes = [];
                        }
                        if (!mode) {
                            state.node.attributes.push(mustacheCore.makeLiveBindingBranchRenderer(null, expression, copyState({ lineNo: lineNo })));
                        } else if (mode === '#' || mode === '^') {
                            if (!state.node.section) {
                                state.node.section = new TextSectionBuilder();
                            }
                            makeRendererAndUpdateSection(state.node.section, mode, expression, lineNo);
                        } else {
                            throw new Error(mode + ' is currently not supported within a tag.');
                        }
                    } else {
                        makeRendererAndUpdateSection(state.textContentOnly || section, mode, expression, lineNo);
                    }
                },
                comment: function (text) {
                    section.add({ comment: text });
                },
                done: function (lineNo) {
                }
            });
            var renderer = section.compile();
            var scopifiedRenderer = HTMLSectionBuilder.scopify(function (scope, nodeList) {
                var templateContext = scope.templateContext;
                canReflect.eachKey(inlinePartials, function (partial, partialName) {
                    canReflect.setKeyValue(templateContext.partials, partialName, partial);
                });
                canReflect.setKeyValue(templateContext, 'view', scopifiedRenderer);
                return renderer.apply(this, arguments);
            });
            return scopifiedRenderer;
        }
        assign(stache, mustacheHelpers);
        stache.safeString = function (text) {
            return {
                toString: function () {
                    return text;
                }
            };
        };
        stache.async = function (source) {
            var iAi = getIntermediateAndImports(source);
            var importPromises = iAi.imports.map(function (moduleName) {
                return importer(moduleName);
            });
            return Promise.all(importPromises).then(function () {
                return stache(iAi.intermediate);
            });
        };
        var templates = {};
        stache.from = mustacheCore.getTemplateById = function (id) {
            if (!templates[id]) {
                var el = DOCUMENT().getElementById(id);
                templates[id] = stache('#' + id, el.innerHTML);
            }
            return templates[id];
        };
        stache.registerPartial = function (id, partial) {
            templates[id] = typeof partial === 'string' ? stache(partial) : partial;
        };
        module.exports = namespace.stache = stache;
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-util@3.11.2#dom/class-name/class-name*/
define('can-util@3.11.2#dom/class-name/class-name', function (require, exports, module) {
    'use strict';
    var has = function (className) {
        if (this.classList) {
            return this.classList.contains(className);
        } else {
            return !!this.className.match(new RegExp('(\\s|^)' + className + '(\\s|$)'));
        }
    };
    module.exports = {
        has: has,
        add: function (className) {
            if (this.classList) {
                this.classList.add(className);
            } else if (!has.call(this, className)) {
                this.className += ' ' + className;
            }
        },
        remove: function (className) {
            if (this.classList) {
                this.classList.remove(className);
            } else if (has.call(this, className)) {
                var reg = new RegExp('(\\s|^)' + className + '(\\s|$)');
                this.className = this.className.replace(reg, ' ');
            }
        }
    };
});
/*can-control@4.0.1#can-control*/
define('can-control@4.0.1#can-control', [
    'require',
    'exports',
    'module',
    'can-construct',
    'can-namespace',
    'can-assign',
    'can-stache-key',
    'can-reflect',
    'can-observation',
    'can-event-queue/map/map',
    'can-log/dev/dev',
    'can-util/js/string/string',
    'can-util/js/get/get',
    'can-util/dom/class-name/class-name',
    'can-dom-mutate'
], function (require, exports, module) {
    var Construct = require('can-construct');
    var namespace = require('can-namespace');
    var assign = require('can-assign');
    var observeReader = require('can-stache-key');
    var canReflect = require('can-reflect');
    var Observation = require('can-observation');
    var canEvent = require('can-event-queue/map/map');
    var dev = require('can-log/dev/dev');
    var string = require('can-util/js/string/string');
    var get = require('can-util/js/get/get');
    var className = require('can-util/dom/class-name/class-name');
    var domMutate = require('can-dom-mutate');
    var processors;
    var controlData = new WeakMap();
    var bind = function (el, ev, callback, queue) {
            canEvent.on.call(el, ev, callback, queue);
            return function () {
                canEvent.off.call(el, ev, callback, queue);
            };
        }, slice = [].slice, paramReplacer = /\{([^\}]+)\}/g, delegate = function (el, selector, ev, callback) {
            canEvent.on.call(el, ev, selector, callback);
            return function () {
                canEvent.off.call(el, ev, selector, callback);
            };
        }, binder = function (el, ev, callback, selector) {
            return selector ? delegate(el, selector.trim(), ev, callback) : bind(el, ev, callback);
        }, basicProcessor;
    var Control = Construct.extend('Control', {
        setup: function () {
            Construct.setup.apply(this, arguments);
            if (Control) {
                var control = this, funcName;
                control.actions = {};
                for (funcName in control.prototype) {
                    if (control._isAction(funcName)) {
                        control.actions[funcName] = control._action(funcName);
                    }
                }
            }
        },
        _shifter: function (context, name) {
            var method = typeof name === 'string' ? context[name] : name;
            if (typeof method !== 'function') {
                method = context[method];
            }
            var Control = this;
            function controlMethod() {
                var wrapped = Control.wrapElement(this);
                context.called = name;
                return method.apply(context, [wrapped].concat(slice.call(arguments, 0)));
            }
            return controlMethod;
        },
        _isAction: function (methodName) {
            var val = this.prototype[methodName], type = typeof val;
            return methodName !== 'constructor' && (type === 'function' || type === 'string' && typeof this.prototype[val] === 'function') && !!(Control.isSpecial(methodName) || processors[methodName] || /[^\w]/.test(methodName));
        },
        _action: function (methodName, options, controlInstance) {
            var readyCompute, unableToBind;
            paramReplacer.lastIndex = 0;
            if (options || !paramReplacer.test(methodName)) {
                var controlActionData = function () {
                    var delegate;
                    var name = methodName.replace(paramReplacer, function (matched, key) {
                        var value, parent;
                        if (this._isDelegate(options, key)) {
                            delegate = this._getDelegate(options, key);
                            return '';
                        }
                        key = this._removeDelegateFromKey(key);
                        parent = this._lookup(options)[0];
                        value = observeReader.read(parent, observeReader.reads(key), { readCompute: false }).value;
                        if (value === undefined && typeof window !== 'undefined') {
                            value = get(window, key);
                        }
                        if (!parent || !(canReflect.isObservableLike(parent) && canReflect.isMapLike(parent)) && !value) {
                            unableToBind = true;
                            return null;
                        }
                        if (typeof value === 'string') {
                            return value;
                        } else {
                            delegate = value;
                            return '';
                        }
                    }.bind(this));
                    name = name.trim();
                    var parts = name.split(/\s+/g), event = parts.pop();
                    return {
                        processor: this.processors[event] || basicProcessor,
                        parts: [
                            name,
                            parts.join(' '),
                            event
                        ],
                        delegate: delegate || undefined
                    };
                };
                readyCompute = new Observation(controlActionData, this);
                if (controlInstance) {
                    var handler = function (actionData) {
                        controlInstance._bindings.control[methodName](controlInstance.element);
                        controlInstance._bindings.control[methodName] = actionData.processor(actionData.delegate || controlInstance.element, actionData.parts[2], actionData.parts[1], methodName, controlInstance);
                    };
                    canReflect.onValue(readyCompute, handler, 'mutate');
                    controlInstance._bindings.readyComputes[methodName] = {
                        compute: readyCompute,
                        handler: handler
                    };
                }
                return readyCompute.get();
            }
        },
        _lookup: function (options) {
            return [
                options,
                window
            ];
        },
        _removeDelegateFromKey: function (key) {
            return key;
        },
        _isDelegate: function (options, key) {
            return key === 'element';
        },
        _getDelegate: function (options, key) {
            return undefined;
        },
        processors: {},
        defaults: {},
        convertElement: function (element) {
            element = typeof element === 'string' ? document.querySelector(element) : element;
            return this.wrapElement(element);
        },
        wrapElement: function (el) {
            return el;
        },
        unwrapElement: function (el) {
            return el;
        },
        isSpecial: function (eventName) {
            return eventName === 'inserted' || eventName === 'removed';
        }
    }, {
        setup: function (element, options) {
            var cls = this.constructor, pluginname = cls.pluginName || cls.shortName, arr;
            if (!element) {
                throw new Error('Creating an instance of a named control without passing an element');
            }
            this.element = cls.convertElement(element);
            if (pluginname && pluginname !== 'Control') {
                className.add.call(this.element, pluginname);
            }
            arr = controlData.get(this.element);
            if (!arr) {
                arr = [];
                controlData.set(this.element, arr);
            }
            arr.push(this);
            if (canReflect.isObservableLike(options) && canReflect.isMapLike(options)) {
                for (var prop in cls.defaults) {
                    if (!options.hasOwnProperty(prop)) {
                        observeReader.set(options, prop, cls.defaults[prop]);
                    }
                }
                this.options = options;
            } else {
                this.options = assign(assign({}, cls.defaults), options);
            }
            this.on();
            return [
                this.element,
                this.options
            ];
        },
        on: function (el, selector, eventName, func) {
            if (!el) {
                this.off();
                var cls = this.constructor, bindings = this._bindings, actions = cls.actions, element = this.constructor.unwrapElement(this.element), destroyCB = Control._shifter(this, 'destroy'), funcName, ready;
                for (funcName in actions) {
                    if (actions.hasOwnProperty(funcName)) {
                        ready = actions[funcName] || cls._action(funcName, this.options, this);
                        if (ready) {
                            bindings.control[funcName] = ready.processor(ready.delegate || element, ready.parts[2], ready.parts[1], funcName, this);
                        }
                    }
                }
                var removalDisposal = domMutate.onNodeRemoval(element, function () {
                    if (!element.ownerDocument.contains(element)) {
                        destroyCB();
                    }
                });
                bindings.user.push(function () {
                    if (removalDisposal) {
                        removalDisposal();
                        removalDisposal = undefined;
                    }
                });
                return bindings.user.length;
            }
            if (typeof el === 'string') {
                func = eventName;
                eventName = selector;
                selector = el;
                el = this.element;
            }
            if (func === undefined) {
                func = eventName;
                eventName = selector;
                selector = null;
            }
            if (typeof func === 'string') {
                func = Control._shifter(this, func);
            }
            this._bindings.user.push(binder(el, eventName, func, selector));
            return this._bindings.user.length;
        },
        off: function () {
            var el = this.constructor.unwrapElement(this.element), bindings = this._bindings;
            if (bindings) {
                (bindings.user || []).forEach(function (value) {
                    value(el);
                });
                canReflect.eachKey(bindings.control || {}, function (value) {
                    value(el);
                });
                canReflect.eachKey(bindings.readyComputes || {}, function (value) {
                    canReflect.offValue(value.compute, value.handler, 'mutate');
                });
            }
            this._bindings = {
                user: [],
                control: {},
                readyComputes: {}
            };
        },
        destroy: function () {
            if (this.element === null) {
                return;
            }
            var Class = this.constructor, pluginName = Class.pluginName || Class.shortName && string.underscore(Class.shortName), controls;
            this.off();
            if (pluginName && pluginName !== 'can_control') {
                className.remove.call(this.element, pluginName);
            }
            controls = controlData.get(this.element);
            if (controls) {
                controls.splice(controls.indexOf(this), 1);
            }
            this.element = null;
        }
    });
    processors = Control.processors;
    basicProcessor = function (el, event, selector, methodName, control) {
        return binder(el, event, Control._shifter(control, methodName), selector);
    };
    [
        'beforeremove',
        'change',
        'click',
        'contextmenu',
        'dblclick',
        'keydown',
        'keyup',
        'keypress',
        'mousedown',
        'mousemove',
        'mouseout',
        'mouseover',
        'mouseup',
        'reset',
        'resize',
        'scroll',
        'select',
        'submit',
        'focusin',
        'focusout',
        'mouseenter',
        'mouseleave',
        'touchstart',
        'touchmove',
        'touchcancel',
        'touchend',
        'touchleave',
        'inserted',
        'removed',
        'dragstart',
        'dragenter',
        'dragover',
        'dragleave',
        'drag',
        'drop',
        'dragend'
    ].forEach(function (v) {
        processors[v] = basicProcessor;
    });
    module.exports = namespace.Control = Control;
});
/*can-component@4.0.1#control/control*/
define('can-component@4.0.1#control/control', [
    'require',
    'exports',
    'module',
    'can-control',
    'can-reflect'
], function (require, exports, module) {
    var Control = require('can-control');
    var canReflect = require('can-reflect');
    var paramReplacer = /\{([^\}]+)\}/g;
    var ComponentControl = Control.extend({
        _lookup: function (options) {
            return [
                options.scope,
                options,
                window
            ];
        },
        _removeDelegateFromKey: function (key) {
            return key.replace(/^(scope|^viewModel)\./, '');
        },
        _isDelegate: function (options, key) {
            return key === 'scope' || key === 'viewModel';
        },
        _getDelegate: function (options, key) {
            return options[key];
        },
        _action: function (methodName, options, controlInstance) {
            var hasObjectLookup;
            paramReplacer.lastIndex = 0;
            hasObjectLookup = paramReplacer.test(methodName);
            if (!controlInstance && hasObjectLookup) {
                return;
            } else {
                return Control._action.apply(this, arguments);
            }
        }
    }, {
        setup: function (el, options) {
            this.scope = options.scope;
            this.viewModel = options.viewModel;
            return Control.prototype.setup.call(this, el, options);
        },
        off: function () {
            if (this._bindings) {
                canReflect.eachKey(this._bindings.readyComputes || {}, function (value) {
                    canReflect.offValue(value.compute, value.handler);
                });
            }
            Control.prototype.off.apply(this, arguments);
            this._bindings.readyComputes = {};
        },
        destroy: function () {
            Control.prototype.destroy.apply(this, arguments);
            if (typeof this.options.destroy === 'function') {
                this.options.destroy.apply(this, arguments);
            }
        }
    });
    module.exports = ComponentControl;
});
/*can-view-model@4.0.0#can-view-model*/
define('can-view-model@4.0.0#can-view-model', [
    'require',
    'exports',
    'module',
    'can-simple-map',
    'can-namespace',
    'can-globals/document/document',
    'can-reflect',
    'can-symbol'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        'use strict';
        var SimpleMap = require('can-simple-map');
        var ns = require('can-namespace');
        var getDocument = require('can-globals/document/document');
        var canReflect = require('can-reflect');
        var canSymbol = require('can-symbol');
        var viewModelSymbol = canSymbol.for('can.viewModel');
        module.exports = ns.viewModel = function (el, attr, val) {
            if (typeof el === 'string') {
                el = getDocument().querySelector(el);
            } else if (canReflect.isListLike(el) && !el.nodeType) {
                el = el[0];
            }
            if (canReflect.isObservableLike(attr) && canReflect.isMapLike(attr)) {
                el[viewModelSymbol] = attr;
                return;
            }
            var scope = el[viewModelSymbol];
            if (!scope) {
                scope = new SimpleMap();
                el[viewModelSymbol] = scope;
            }
            switch (arguments.length) {
            case 0:
            case 1:
                return scope;
            case 2:
                return canReflect.getKeyValue(scope, attr);
            default:
                canReflect.setKeyValue(scope, attr, val);
                return el;
            }
        };
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-stache-bindings@4.0.5#can-event*/
define('can-stache-bindings@4.0.5#can-event', [
    'require',
    'exports',
    'module',
    'can-reflect',
    'can-dom-events',
    'can-dom-events/helpers/util'
], function (require, exports, module) {
    var canReflect = require('can-reflect');
    var domEvents = require('can-dom-events');
    var isDomEventTarget = require('can-dom-events/helpers/util').isDomEventTarget;
    var canEvent = {
        on: function on(eventName, handler, queue) {
            if (isDomEventTarget(this)) {
                domEvents.addEventListener(this, eventName, handler, queue);
            } else {
                canReflect.onKeyValue(this, eventName, handler, queue);
            }
        },
        off: function off(eventName, handler, queue) {
            if (isDomEventTarget(this)) {
                domEvents.removeEventListener(this, eventName, handler, queue);
            } else {
                canReflect.offKeyValue(this, eventName, handler, queue);
            }
        },
        one: function one(event, handler, queue) {
            var one = function () {
                canEvent.off.call(this, event, one, queue);
                return handler.apply(this, arguments);
            };
            canEvent.on.call(this, event, one, queue);
            return this;
        }
    };
    module.exports = canEvent;
});
/*can-util@3.11.2#js/set-immediate/set-immediate*/
define('can-util@3.11.2#js/set-immediate/set-immediate', [
    'require',
    'exports',
    'module',
    'can-globals/global/global'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        'use strict';
        var global = require('can-globals/global/global')();
        module.exports = global.setImmediate || function (cb) {
            return setTimeout(cb, 0);
        };
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-util@3.11.2#dom/is-of-global-document/is-of-global-document*/
define('can-util@3.11.2#dom/is-of-global-document/is-of-global-document', [
    'require',
    'exports',
    'module',
    'can-globals/document/document'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        'use strict';
        var getDocument = require('can-globals/document/document');
        module.exports = function (el) {
            return (el.ownerDocument || el) === getDocument();
        };
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-types@1.1.6#can-types*/
define('can-types@1.1.6#can-types', [
    'require',
    'exports',
    'module',
    'can-namespace',
    'can-reflect',
    'can-symbol',
    'can-log/dev/dev'
], function (require, exports, module) {
    var namespace = require('can-namespace');
    var canReflect = require('can-reflect');
    var canSymbol = require('can-symbol');
    var dev = require('can-log/dev/dev');
    var types = {
        isMapLike: function (obj) {
            return canReflect.isObservableLike(obj) && canReflect.isMapLike(obj);
        },
        isListLike: function (obj) {
            return canReflect.isObservableLike(obj) && canReflect.isListLike(obj);
        },
        isPromise: function (obj) {
            return canReflect.isPromise(obj);
        },
        isConstructor: function (func) {
            return canReflect.isConstructorLike(func);
        },
        isCallableForValue: function (obj) {
            return obj && canReflect.isFunctionLike(obj) && !canReflect.isConstructorLike(obj);
        },
        isCompute: function (obj) {
            return obj && obj.isComputed;
        },
        get iterator() {
            return canSymbol.iterator || canSymbol.for('iterator');
        },
        DefaultMap: null,
        DefaultList: null,
        queueTask: function (task) {
            var args = task[2] || [];
            task[0].apply(task[1], args);
        },
        wrapElement: function (element) {
            return element;
        },
        unwrapElement: function (element) {
            return element;
        }
    };
    if (namespace.types) {
        throw new Error('You can\'t have two versions of can-types, check your dependencies');
    } else {
        module.exports = namespace.types = types;
    }
});
/*can-stache-bindings@4.0.5#attribute-observable/attribute-behaviors*/
define('can-stache-bindings@4.0.5#attribute-observable/attribute-behaviors', [
    'require',
    'exports',
    'module',
    'can-util/js/set-immediate/set-immediate',
    'can-globals/document/document',
    'can-globals/global/global',
    'can-util/dom/is-of-global-document/is-of-global-document',
    'can-dom-data-state',
    'can-dom-events',
    'can-dom-mutate',
    'can-dom-mutate/node',
    'can-globals/mutation-observer/mutation-observer',
    'can-util/js/each/each',
    'can-types',
    'can-util/js/diff/diff'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        'use strict';
        var setImmediate = require('can-util/js/set-immediate/set-immediate');
        var getDocument = require('can-globals/document/document');
        var global = require('can-globals/global/global')();
        var isOfGlobalDocument = require('can-util/dom/is-of-global-document/is-of-global-document');
        var setData = require('can-dom-data-state');
        var domEvents = require('can-dom-events');
        var domMutate = require('can-dom-mutate');
        var domMutateNode = require('can-dom-mutate/node');
        var getMutationObserver = require('can-globals/mutation-observer/mutation-observer');
        var each = require('can-util/js/each/each');
        var types = require('can-types');
        var diff = require('can-util/js/diff/diff');
        var formElements = {
                'INPUT': true,
                'TEXTAREA': true,
                'SELECT': true
            }, toString = function (value) {
                if (value == null) {
                    return '';
                } else {
                    return '' + value;
                }
            }, isSVG = function (el) {
                return el.namespaceURI === 'http://www.w3.org/2000/svg';
            }, truthy = function () {
                return true;
            }, getSpecialTest = function (special) {
                return special && special.test || truthy;
            }, propProp = function (prop, obj) {
                obj = obj || {};
                obj.get = function () {
                    return this[prop];
                };
                obj.set = function (value) {
                    if (this[prop] !== value) {
                        this[prop] = value;
                    }
                    return value;
                };
                return obj;
            }, booleanProp = function (prop) {
                return {
                    isBoolean: true,
                    set: function (value) {
                        if (prop in this) {
                            this[prop] = value !== false;
                        } else {
                            domMutateNode.setAttribute.call(this, prop, '');
                        }
                    },
                    remove: function () {
                        this[prop] = false;
                    }
                };
            }, setupMO = function (el, callback) {
                var attrMO = setData.get.call(el, 'attrMO');
                if (!attrMO) {
                    var onMutation = function () {
                        callback.call(el);
                    };
                    var MO = getMutationObserver();
                    if (MO) {
                        var observer = new MO(onMutation);
                        observer.observe(el, {
                            childList: true,
                            subtree: true
                        });
                        setData.set.call(el, 'attrMO', observer);
                    } else {
                        setData.set.call(el, 'attrMO', true);
                        setData.set.call(el, 'canBindingCallback', { onMutation: onMutation });
                    }
                }
            }, _findOptionToSelect = function (parent, value) {
                var child = parent.firstChild;
                while (child) {
                    if (child.nodeName === 'OPTION' && value === child.value) {
                        return child;
                    }
                    if (child.nodeName === 'OPTGROUP') {
                        var groupChild = _findOptionToSelect(child, value);
                        if (groupChild) {
                            return groupChild;
                        }
                    }
                    child = child.nextSibling;
                }
            }, setChildOptions = function (el, value) {
                var option;
                if (value != null) {
                    option = _findOptionToSelect(el, value);
                }
                if (option) {
                    option.selected = true;
                } else {
                    el.selectedIndex = -1;
                }
            }, forEachOption = function (parent, fn) {
                var child = parent.firstChild;
                while (child) {
                    if (child.nodeName === 'OPTION') {
                        fn(child);
                    }
                    if (child.nodeName === 'OPTGROUP') {
                        forEachOption(child, fn);
                    }
                    child = child.nextSibling;
                }
            }, collectSelectedOptions = function (parent) {
                var selectedValues = [];
                forEachOption(parent, function (option) {
                    if (option.selected) {
                        selectedValues.push(option.value);
                    }
                });
                return selectedValues;
            }, markSelectedOptions = function (parent, values) {
                forEachOption(parent, function (option) {
                    option.selected = values.indexOf(option.value) !== -1;
                });
            }, setChildOptionsOnChange = function (select, aEL) {
                var handler = setData.get.call(select, 'attrSetChildOptions');
                if (handler) {
                    return Function.prototype;
                }
                handler = function () {
                    setChildOptions(select, select.value);
                };
                setData.set.call(select, 'attrSetChildOptions', handler);
                aEL.call(select, 'change', handler);
                return function (rEL) {
                    setData.clean.call(select, 'attrSetChildOptions');
                    rEL.call(select, 'change', handler);
                };
            };
        var specialAttributes = {
            checked: {
                get: function () {
                    return this.checked;
                },
                set: function (val) {
                    var notFalse = !!val || val === '' || arguments.length === 0;
                    this.checked = notFalse;
                    if (notFalse && this.type === 'radio') {
                        this.defaultChecked = true;
                    }
                    return val;
                },
                remove: function () {
                    this.checked = false;
                },
                test: function () {
                    return this.nodeName === 'INPUT';
                }
            },
            'class': {
                get: function () {
                    if (isSVG(this)) {
                        return this.getAttribute('class');
                    }
                    return this.className;
                },
                set: function (val) {
                    val = val || '';
                    if (isSVG(this)) {
                        domMutateNode.setAttribute.call(this, 'class', '' + val);
                    } else {
                        this.className = val;
                    }
                    return val;
                }
            },
            disabled: booleanProp('disabled'),
            focused: {
                get: function () {
                    return this === document.activeElement;
                },
                set: function (val) {
                    var cur = attr.get(this, 'focused');
                    var docEl = this.ownerDocument.documentElement;
                    var element = this;
                    function focusTask() {
                        if (val) {
                            element.focus();
                        } else {
                            element.blur();
                        }
                    }
                    if (cur !== val) {
                        if (!docEl.contains(element)) {
                            var insertionDisposal = domMutate.onNodeInsertion(element, function () {
                                insertionDisposal();
                                focusTask();
                            });
                        } else {
                            types.queueTask([
                                focusTask,
                                this,
                                []
                            ]);
                        }
                    }
                    return !!val;
                },
                addEventListener: function (eventName, handler, aEL) {
                    aEL.call(this, 'focus', handler);
                    aEL.call(this, 'blur', handler);
                    return function (rEL) {
                        rEL.call(this, 'focus', handler);
                        rEL.call(this, 'blur', handler);
                    };
                },
                test: function () {
                    return this.nodeName === 'INPUT';
                }
            },
            'for': propProp('htmlFor'),
            innertext: propProp('innerText'),
            innerhtml: propProp('innerHTML'),
            innerHTML: propProp('innerHTML', {
                addEventListener: function (eventName, handler, aEL) {
                    var handlers = [];
                    var el = this;
                    each([
                        'change',
                        'blur'
                    ], function (eventName) {
                        var localHandler = function () {
                            handler.apply(this, arguments);
                        };
                        domEvents.addEventListener(el, eventName, localHandler);
                        handlers.push([
                            eventName,
                            localHandler
                        ]);
                    });
                    return function (rEL) {
                        each(handlers, function (info) {
                            rEL.call(el, info[0], info[1]);
                        });
                    };
                }
            }),
            required: booleanProp('required'),
            readonly: booleanProp('readOnly'),
            selected: {
                get: function () {
                    return this.selected;
                },
                set: function (val) {
                    val = !!val;
                    setData.set.call(this, 'lastSetValue', val);
                    return this.selected = val;
                },
                addEventListener: function (eventName, handler, aEL) {
                    var option = this;
                    var select = this.parentNode;
                    var lastVal = option.selected;
                    var localHandler = function (changeEvent) {
                        var curVal = option.selected;
                        lastVal = setData.get.call(option, 'lastSetValue') || lastVal;
                        if (curVal !== lastVal) {
                            lastVal = curVal;
                            domEvents.dispatch(option, eventName);
                        }
                    };
                    var removeChangeHandler = setChildOptionsOnChange(select, aEL);
                    domEvents.addEventListener(select, 'change', localHandler);
                    aEL.call(option, eventName, handler);
                    return function (rEL) {
                        removeChangeHandler(rEL);
                        domEvents.removeEventListener(select, 'change', localHandler);
                        rEL.call(option, eventName, handler);
                    };
                },
                test: function () {
                    return this.nodeName === 'OPTION' && this.parentNode && this.parentNode.nodeName === 'SELECT';
                }
            },
            style: {
                set: function () {
                    var el = global.document && getDocument().createElement('div');
                    if (el && el.style && 'cssText' in el.style) {
                        return function (val) {
                            return this.style.cssText = val || '';
                        };
                    } else {
                        return function (val) {
                            return domMutateNode.setAttribute.call(this, 'style', val);
                        };
                    }
                }()
            },
            textcontent: propProp('textContent'),
            value: {
                get: function () {
                    var value = this.value;
                    if (this.nodeName === 'SELECT') {
                        if ('selectedIndex' in this && this.selectedIndex === -1) {
                            value = undefined;
                        }
                    }
                    return value;
                },
                set: function (value) {
                    var nodeName = this.nodeName.toLowerCase();
                    if (nodeName === 'input') {
                        value = toString(value);
                    }
                    if (this.value !== value || nodeName === 'option') {
                        this.value = value;
                    }
                    if (nodeName === 'input' || nodeName === 'textarea') {
                        this.defaultValue = value;
                    }
                    if (nodeName === 'select') {
                        setData.set.call(this, 'attrValueLastVal', value);
                        setChildOptions(this, value === null ? value : this.value);
                        var docEl = this.ownerDocument.documentElement;
                        if (!docEl.contains(this)) {
                            var select = this;
                            var insertionDisposal = domMutate.onNodeInsertion(select, function () {
                                insertionDisposal();
                                setChildOptions(select, value === null ? value : select.value);
                            });
                        }
                        setupMO(this, function () {
                            var value = setData.get.call(this, 'attrValueLastVal');
                            attr.set(this, 'value', value);
                            domEvents.dispatch(this, 'change');
                        });
                    }
                    return value;
                },
                test: function () {
                    return formElements[this.nodeName];
                }
            },
            values: {
                get: function () {
                    return collectSelectedOptions(this);
                },
                set: function (values) {
                    values = values || [];
                    markSelectedOptions(this, values);
                    setData.set.call(this, 'stickyValues', attr.get(this, 'values'));
                    setupMO(this, function () {
                        var previousValues = setData.get.call(this, 'stickyValues');
                        attr.set(this, 'values', previousValues);
                        var currentValues = setData.get.call(this, 'stickyValues');
                        var changes = diff(previousValues.slice().sort(), currentValues.slice().sort());
                        if (changes.length) {
                            domEvents.dispatch(this, 'values');
                        }
                    });
                    return values;
                },
                addEventListener: function (eventName, handler, aEL) {
                    var localHandler = function () {
                        domEvents.dispatch(this, 'values');
                    };
                    domEvents.addEventListener(this, 'change', localHandler);
                    aEL.call(this, eventName, handler);
                    return function (rEL) {
                        domEvents.removeEventListener(this, 'change', localHandler);
                        rEL.call(this, eventName, handler);
                    };
                }
            }
        };
        var attr = {
            findSpecialListener: function (attributeName) {
                return specialAttributes[attributeName] && specialAttributes[attributeName].addEventListener;
            },
            setAttrOrProp: function (el, attrName, val) {
                attrName = attrName.toLowerCase();
                var special = specialAttributes[attrName];
                if (special && special.isBoolean && !val) {
                    this.remove(el, attrName);
                } else {
                    this.set(el, attrName, val);
                }
            },
            set: function (el, attrName, val) {
                attrName = attrName.toLowerCase();
                var special = specialAttributes[attrName];
                var setter = special && special.set;
                var test = getSpecialTest(special);
                if (typeof setter === 'function' && test.call(el)) {
                    if (arguments.length === 2) {
                        setter.call(el);
                    } else {
                        setter.call(el, val);
                    }
                } else {
                    domMutateNode.setAttribute.call(el, attrName, val);
                }
            },
            get: function (el, attrName) {
                attrName = attrName.toLowerCase();
                var special = specialAttributes[attrName];
                var getter = special && special.get;
                var test = getSpecialTest(special);
                if (typeof getter === 'function' && test.call(el)) {
                    return getter.call(el);
                } else {
                    return el.getAttribute(attrName);
                }
            },
            remove: function (el, attrName) {
                attrName = attrName.toLowerCase();
                var special = specialAttributes[attrName];
                var setter = special && special.set;
                var remover = special && special.remove;
                var test = getSpecialTest(special);
                if (typeof remover === 'function' && test.call(el)) {
                    remover.call(el);
                } else if (typeof setter === 'function' && test.call(el)) {
                    setter.call(el, undefined);
                } else {
                    domMutateNode.removeAttribute.call(el, attrName);
                }
            }
        };
        module.exports = attr;
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-stache-bindings@4.0.5#attribute-observable/get-event-name*/
define('can-stache-bindings@4.0.5#attribute-observable/get-event-name', [
    'require',
    'exports',
    'module',
    './attribute-behaviors'
], function (require, exports, module) {
    var attr = require('./attribute-behaviors');
    var isRadioInput = function isRadioInput(el) {
        return el.nodeName.toLowerCase() === 'input' && el.type === 'radio';
    };
    var isValidProp = function isValidProp(prop, bindingData) {
        return prop === 'checked' && !bindingData.legacyBindings;
    };
    module.exports = function getEventName(el, prop, bindingData) {
        var event = 'change';
        if (isRadioInput(el) && isValidProp(prop, bindingData)) {
            event = 'can-stache-bindings-radiochange';
        }
        if (attr.findSpecialListener(prop)) {
            event = prop;
        }
        return event;
    };
});
/*can-event-dom-radiochange@2.1.0#can-event-dom-radiochange*/
define('can-event-dom-radiochange@2.1.0#can-event-dom-radiochange', [
    'require',
    'exports',
    'module',
    'can-globals/document/document',
    'can-namespace'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        'use strict';
        var getDocument = require('can-globals/document/document');
        var namespace = require('can-namespace');
        function getRoot() {
            return getDocument().documentElement;
        }
        function findParentForm(el) {
            while (el) {
                if (el.nodeName === 'FORM') {
                    break;
                }
                el = el.parentNode;
            }
            return el;
        }
        function shouldReceiveEventFromRadio(source, dest) {
            var name = source.getAttribute('name');
            return name && name === dest.getAttribute('name') && findParentForm(source) === findParentForm(dest);
        }
        function isRadioInput(el) {
            return el.nodeName === 'INPUT' && el.type === 'radio';
        }
        function attachRootListener(domEvents, eventTypeTargets) {
            var root = getRoot();
            var newListener = function (event) {
                var target = event.target;
                if (!isRadioInput(target)) {
                    return;
                }
                for (var eventType in eventTypeTargets) {
                    var newEvent = { type: eventType };
                    var listeningNodes = eventTypeTargets[eventType];
                    listeningNodes.forEach(function (el) {
                        if (shouldReceiveEventFromRadio(target, el)) {
                            domEvents.dispatch(el, newEvent, false);
                        }
                    });
                }
            };
            domEvents.addEventListener(root, 'change', newListener);
            return newListener;
        }
        function detachRootListener(domEvents, listener) {
            var root = getRoot();
            domEvents.removeEventListener(root, 'change', listener);
        }
        var radioChangeEvent = {
            defaultEventType: 'radiochange',
            addEventListener: function (target, eventType, handler) {
                if (!isRadioInput(target)) {
                    throw new Error('Listeners for ' + eventType + ' must be radio inputs');
                }
                var eventTypeTrackedRadios = radioChangeEvent._eventTypeTrackedRadios;
                if (!eventTypeTrackedRadios) {
                    eventTypeTrackedRadios = radioChangeEvent._eventTypeTrackedRadios = {};
                    if (!radioChangeEvent._rootListener) {
                        radioChangeEvent._rootListener = attachRootListener(this, eventTypeTrackedRadios);
                    }
                }
                var trackedRadios = radioChangeEvent._eventTypeTrackedRadios[eventType];
                if (!trackedRadios) {
                    trackedRadios = radioChangeEvent._eventTypeTrackedRadios[eventType] = new Set();
                }
                trackedRadios.add(target);
                target.addEventListener(eventType, handler);
            },
            removeEventListener: function (target, eventType, handler) {
                target.removeEventListener(eventType, handler);
                var eventTypeTrackedRadios = radioChangeEvent._eventTypeTrackedRadios;
                if (!eventTypeTrackedRadios) {
                    return;
                }
                var trackedRadios = eventTypeTrackedRadios[eventType];
                if (!trackedRadios) {
                    return;
                }
                trackedRadios.delete(target);
                if (trackedRadios.size === 0) {
                    delete eventTypeTrackedRadios[eventType];
                    for (var key in eventTypeTrackedRadios) {
                        if (eventTypeTrackedRadios.hasOwnProperty(key)) {
                            return;
                        }
                    }
                    delete radioChangeEvent._eventTypeTrackedRadios;
                    detachRootListener(this, radioChangeEvent._rootListener);
                    delete radioChangeEvent._rootListener;
                }
            }
        };
        module.exports = namespace.domEventRadioChange = radioChangeEvent;
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-stache-bindings@4.0.5#attribute-observable/attribute-observable*/
define('can-stache-bindings@4.0.5#attribute-observable/attribute-observable', [
    'require',
    'exports',
    'module',
    'can-queues',
    '../can-event',
    'can-reflect',
    'can-observation',
    './attribute-behaviors',
    './get-event-name',
    'can-reflect-dependencies',
    'can-observation-recorder',
    'can-simple-observable/settable/settable',
    'can-dom-events',
    'can-event-dom-radiochange'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        var queues = require('can-queues');
        var canEvent = require('../can-event');
        var canReflect = require('can-reflect');
        var Observation = require('can-observation');
        var attr = require('./attribute-behaviors');
        var getEventName = require('./get-event-name');
        var canReflectDeps = require('can-reflect-dependencies');
        var ObservationRecorder = require('can-observation-recorder');
        var SettableObservable = require('can-simple-observable/settable/settable');
        var domEvents = require('can-dom-events');
        var radioChangeEvent = require('can-event-dom-radiochange');
        var internalRadioChangeEventType = 'can-stache-bindings-radiochange';
        domEvents.addEvent(radioChangeEvent, internalRadioChangeEventType);
        var isSelect = function isSelect(el) {
            return el.nodeName.toLowerCase() === 'select';
        };
        var isMultipleSelect = function isMultipleSelect(el, prop) {
            return isSelect(el) && prop === 'value' && el.multiple;
        };
        var slice = Array.prototype.slice;
        function canUtilAEL() {
            var args = slice.call(arguments, 0);
            args.unshift(this);
            return domEvents.addEventListener.apply(null, args);
        }
        function canUtilREL() {
            var args = slice.call(arguments, 0);
            args.unshift(this);
            return domEvents.removeEventListener.apply(null, args);
        }
        function AttributeObservable(el, prop, bindingData, event) {
            this.el = el;
            this.bound = false;
            this.bindingData = bindingData;
            this.prop = isMultipleSelect(el, prop) ? 'values' : prop;
            this.event = event || getEventName(el, prop, bindingData);
            this.handler = this.handler.bind(this);
        }
        AttributeObservable.prototype = Object.create(SettableObservable.prototype);
        Object.assign(AttributeObservable.prototype, {
            constructor: AttributeObservable,
            get: function get() {
                if (ObservationRecorder.isRecording()) {
                    ObservationRecorder.add(this);
                    if (!this.bound) {
                        Observation.temporarilyBind(this);
                    }
                }
                return attr.get(this.el, this.prop);
            },
            set: function set(newVal) {
                attr.setAttrOrProp(this.el, this.prop, newVal);
                this.value = newVal;
                return newVal;
            },
            handler: function handler(newVal) {
                var old = this.value;
                this.value = attr.get(this.el, this.prop);
                if (this.value !== old) {
                    queues.enqueueByQueue(this.handlers.getNode([]), this, [
                        newVal,
                        old
                    ], function () {
                        return {};
                    });
                }
            },
            onBound: function onBound() {
                var observable = this;
                observable.bound = true;
                observable._handler = function () {
                    observable.handler(attr.get(observable.el, observable.prop));
                };
                if (observable.event === internalRadioChangeEventType) {
                    canEvent.on.call(observable.el, 'change', observable._handler);
                }
                var specialBinding = attr.findSpecialListener(observable.prop);
                if (specialBinding) {
                    observable._specialDisposal = specialBinding.call(observable.el, observable.prop, observable._handler, canUtilAEL);
                }
                canEvent.on.call(observable.el, observable.event, observable._handler);
                this.value = attr.get(this.el, this.prop);
            },
            onUnbound: function onUnbound() {
                var observable = this;
                observable.bound = false;
                if (observable.event === internalRadioChangeEventType) {
                    canEvent.off.call(observable.el, 'change', observable._handler);
                }
                if (observable._specialDisposal) {
                    observable._specialDisposal.call(observable.el, canUtilREL);
                    observable._specialDisposal = null;
                }
                canEvent.off.call(observable.el, observable.event, observable._handler);
            },
            valueHasDependencies: function valueHasDependencies() {
                return true;
            },
            getValueDependencies: function getValueDependencies() {
                return {
                    keyDependencies: new Map([[
                            this.el,
                            new Set([this.prop])
                        ]])
                };
            }
        });
        canReflect.assignSymbols(AttributeObservable.prototype, {
            'can.isMapLike': false,
            'can.getValue': AttributeObservable.prototype.get,
            'can.setValue': AttributeObservable.prototype.set,
            'can.onValue': AttributeObservable.prototype.on,
            'can.offValue': AttributeObservable.prototype.off,
            'can.valueHasDependencies': AttributeObservable.prototype.hasDependencies,
            'can.getValueDependencies': AttributeObservable.prototype.getValueDependencies
        });
        module.exports = AttributeObservable;
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-stache-bindings@4.0.5#can-stache-bindings*/
define('can-stache-bindings@4.0.5#can-stache-bindings', [
    'require',
    'exports',
    'module',
    'can-stache/src/expression',
    'can-view-callbacks',
    'can-view-model',
    'can-stache-key',
    'can-observation-recorder',
    'can-simple-observable',
    'can-util/js/assign/assign',
    'can-util/js/make-array/make-array',
    'can-util/js/each/each',
    'can-log/dev/dev',
    'can-dom-mutate',
    'can-dom-data-state',
    'can-symbol',
    'can-reflect',
    'can-reflect-dependencies',
    'can-attribute-encoder',
    'can-queues',
    'can-simple-observable/setter/setter',
    './attribute-observable/attribute-observable',
    'can-view-scope/make-compute-like',
    './can-event'
], function (require, exports, module) {
    var expression = require('can-stache/src/expression');
    var viewCallbacks = require('can-view-callbacks');
    var canViewModel = require('can-view-model');
    var observeReader = require('can-stache-key');
    var ObservationRecorder = require('can-observation-recorder');
    var SimpleObservable = require('can-simple-observable');
    var assign = require('can-util/js/assign/assign');
    var makeArray = require('can-util/js/make-array/make-array');
    var each = require('can-util/js/each/each');
    var dev = require('can-log/dev/dev');
    var domMutate = require('can-dom-mutate');
    var domData = require('can-dom-data-state');
    var canSymbol = require('can-symbol');
    var canReflect = require('can-reflect');
    var canReflectDeps = require('can-reflect-dependencies');
    var encoder = require('can-attribute-encoder');
    var queues = require('can-queues');
    var SettableObservable = require('can-simple-observable/setter/setter');
    var AttributeObservable = require('./attribute-observable/attribute-observable');
    var makeCompute = require('can-view-scope/make-compute-like');
    var canEvent = require('./can-event');
    var noop = function () {
    };
    var onMatchStr = 'on:', vmMatchStr = 'vm:', elMatchStr = 'el:', byMatchStr = ':by:', toMatchStr = ':to', fromMatchStr = ':from', bindMatchStr = ':bind', viewModelBindingStr = 'viewModel', attributeBindingStr = 'attribute', scopeBindingStr = 'scope', viewModelOrAttributeBindingStr = 'viewModelOrAttribute', getValueSymbol = canSymbol.for('can.getValue'), onValueSymbol = canSymbol.for('can.onValue'), getChangesSymbol = canSymbol.for('can.getChangesDependencyRecord');
    var throwOnlyOneTypeOfBindingError = function () {
        throw new Error('can-stache-bindings - you can not have contextual bindings ( this:from=\'value\' ) and key bindings ( prop:from=\'value\' ) on one element.');
    };
    var checkBindingState = function (bindingState, dataBinding) {
        var isSettingOnViewModel = dataBinding.bindingInfo.parentToChild && dataBinding.bindingInfo.child === viewModelBindingStr;
        if (isSettingOnViewModel) {
            var bindingName = dataBinding.bindingInfo.childName;
            var isSettingViewModel = isSettingOnViewModel && (bindingName === 'this' || bindingName === '.');
            if (isSettingViewModel) {
                if (bindingState.isSettingViewModel || bindingState.isSettingOnViewModel) {
                    throwOnlyOneTypeOfBindingError();
                } else {
                    return {
                        isSettingViewModel: true,
                        initialViewModelData: undefined
                    };
                }
            } else {
                if (bindingState.isSettingViewModel) {
                    throwOnlyOneTypeOfBindingError();
                } else {
                    return {
                        isSettingOnViewModel: true,
                        initialViewModelData: bindingState.initialViewModelData
                    };
                }
            }
        } else {
            return bindingState;
        }
    };
    var behaviors = {
        viewModel: function (el, tagData, makeViewModel, initialViewModelData, staticDataBindingsOnly) {
            var bindingsSemaphore = {}, viewModel, onCompleteBindings = [], onTeardowns = {}, bindingInfos = {}, attributeViewModelBindings = assign({}, initialViewModelData), bindingsState = {
                    isSettingOnViewModel: false,
                    isSettingViewModel: false,
                    initialViewModelData: initialViewModelData || {}
                }, hasDataBinding = false;
            each(makeArray(el.attributes), function (node) {
                var dataBinding = makeDataBinding(node, el, {
                    templateType: tagData.templateType,
                    scope: tagData.scope,
                    semaphore: bindingsSemaphore,
                    getViewModel: function () {
                        return viewModel;
                    },
                    attributeViewModelBindings: attributeViewModelBindings,
                    alreadyUpdatedChild: true,
                    nodeList: tagData.parentNodeList,
                    favorViewModel: true
                });
                if (dataBinding) {
                    bindingsState = checkBindingState(bindingsState, dataBinding);
                    hasDataBinding = true;
                    if (dataBinding.onCompleteBinding) {
                        if (dataBinding.bindingInfo.parentToChild && dataBinding.value !== undefined) {
                            if (bindingsState.isSettingViewModel) {
                                bindingsState.initialViewModelData = dataBinding.value;
                            } else {
                                bindingsState.initialViewModelData[cleanVMName(dataBinding.bindingInfo.childName, tagData.scope)] = dataBinding.value;
                            }
                        }
                        onCompleteBindings.push(dataBinding.onCompleteBinding);
                    }
                    onTeardowns[node.name] = dataBinding.onTeardown;
                }
            });
            if (staticDataBindingsOnly && !hasDataBinding) {
                return;
            }
            viewModel = makeViewModel(bindingsState.initialViewModelData, hasDataBinding);
            for (var i = 0, len = onCompleteBindings.length; i < len; i++) {
                onCompleteBindings[i]();
            }
            var attributeDisposal;
            if (!bindingsState.isSettingViewModel) {
                attributeDisposal = domMutate.onNodeAttributeChange(el, function (ev) {
                    var attrName = ev.attributeName, value = el.getAttribute(attrName);
                    if (onTeardowns[attrName]) {
                        onTeardowns[attrName]();
                    }
                    var parentBindingWasAttribute = bindingInfos[attrName] && bindingInfos[attrName].parent === attributeBindingStr;
                    if (value !== null || parentBindingWasAttribute) {
                        var dataBinding = makeDataBinding({
                            name: attrName,
                            value: value
                        }, el, {
                            templateType: tagData.templateType,
                            scope: tagData.scope,
                            semaphore: {},
                            getViewModel: function () {
                                return viewModel;
                            },
                            attributeViewModelBindings: attributeViewModelBindings,
                            initializeValues: true,
                            nodeList: tagData.parentNodeList
                        });
                        if (dataBinding) {
                            if (dataBinding.onCompleteBinding) {
                                dataBinding.onCompleteBinding();
                            }
                            bindingInfos[attrName] = dataBinding.bindingInfo;
                            onTeardowns[attrName] = dataBinding.onTeardown;
                        }
                    }
                });
            }
            return function () {
                if (attributeDisposal) {
                    attributeDisposal();
                    attributeDisposal = undefined;
                }
                for (var attrName in onTeardowns) {
                    onTeardowns[attrName]();
                }
            };
        },
        data: function (el, attrData) {
            if (domData.get.call(el, 'preventDataBindings')) {
                return;
            }
            var viewModel, getViewModel = ObservationRecorder.ignore(function () {
                    return viewModel || (viewModel = canViewModel(el));
                }), semaphore = {}, teardown;
            var dataBinding = makeDataBinding({
                name: attrData.attributeName,
                value: el.getAttribute(attrData.attributeName),
                nodeList: attrData.nodeList
            }, el, {
                templateType: attrData.templateType,
                scope: attrData.scope,
                semaphore: semaphore,
                getViewModel: getViewModel,
                syncChildWithParent: false
            });
            if (dataBinding.onCompleteBinding) {
                dataBinding.onCompleteBinding();
            }
            var attributeListener = function (ev) {
                var attrName = ev.attributeName, value = el.getAttribute(attrName);
                if (attrName === attrData.attributeName) {
                    if (teardown) {
                        teardown();
                    }
                    if (value !== null) {
                        var dataBinding = makeDataBinding({
                            name: attrName,
                            value: value
                        }, el, {
                            templateType: attrData.templateType,
                            scope: attrData.scope,
                            semaphore: semaphore,
                            getViewModel: getViewModel,
                            initializeValues: true,
                            nodeList: attrData.nodeList,
                            syncChildWithParent: false
                        });
                        if (dataBinding) {
                            if (dataBinding.onCompleteBinding) {
                                dataBinding.onCompleteBinding();
                            }
                            teardown = dataBinding.onTeardown;
                        }
                    }
                }
            };
            teardown = dataBinding.onTeardown;
            var attributeDisposal = domMutate.onNodeAttributeChange(el, attributeListener);
            var removedDisposal = domMutate.onNodeRemoval(el, function () {
                if (el.ownerDocument.contains(el)) {
                    return;
                }
                teardown();
                if (removedDisposal) {
                    removedDisposal();
                    removedDisposal = undefined;
                }
                if (attributeDisposal) {
                    attributeDisposal();
                    attributeDisposal = undefined;
                }
            });
        },
        event: function (el, data) {
            var attributeName = encoder.decode(data.attributeName), event, bindingContext;
            if (attributeName.indexOf(toMatchStr + ':') !== -1 || attributeName.indexOf(fromMatchStr + ':') !== -1 || attributeName.indexOf(bindMatchStr + ':') !== -1) {
                return this.data(el, data);
            }
            if (startsWith.call(attributeName, onMatchStr)) {
                event = attributeName.substr(onMatchStr.length);
                var viewModel = el[canSymbol.for('can.viewModel')];
                var byParent = data.scope;
                if (startsWith.call(event, elMatchStr)) {
                    event = event.substr(elMatchStr.length);
                    bindingContext = el;
                } else {
                    if (startsWith.call(event, vmMatchStr)) {
                        event = event.substr(vmMatchStr.length);
                        bindingContext = viewModel;
                        byParent = viewModel;
                    } else {
                        bindingContext = viewModel || el;
                    }
                    var byIndex = event.indexOf(byMatchStr);
                    if (byIndex >= 0) {
                        bindingContext = byParent.get(event.substr(byIndex + byMatchStr.length));
                        event = event.substr(0, byIndex);
                    }
                }
            } else {
                throw new Error('can-stache-bindings - unsupported event bindings ' + attributeName);
            }
            var handler = function (ev) {
                var attrVal = el.getAttribute(encoder.encode(attributeName));
                if (!attrVal) {
                    return;
                }
                var viewModel = canViewModel(el);
                var expr = expression.parse(attrVal, {
                    lookupRule: function () {
                        return expression.Lookup;
                    },
                    methodRule: 'call'
                });
                if (!(expr instanceof expression.Call)) {
                    throw new Error('can-stache-bindings: Event bindings must be a call expression. Make sure you have a () in ' + data.attributeName + '=' + JSON.stringify(attrVal));
                }
                var specialValues = {
                    element: el,
                    event: ev,
                    viewModel: viewModel,
                    arguments: arguments
                };
                var localScope = data.scope.add(specialValues, { special: true });
                var updateFn = function () {
                    var value = expr.value(localScope, { doNotWrapInObservation: true });
                    value = canReflect.isValueLike(value) ? canReflect.getValue(value) : value;
                    return typeof value === 'function' ? value(el) : value;
                };
                queues.batch.start();
                queues.notifyQueue.enqueue(updateFn, null, null, {});
                queues.batch.stop();
            };
            var attributesDisposal, removalDisposal;
            var attributesHandler = function (ev) {
                var isEventAttribute = ev.attributeName === attributeName;
                var isRemoved = !el.getAttribute(attributeName);
                var isEventAttributeRemoved = isEventAttribute && isRemoved;
                if (isEventAttributeRemoved) {
                    unbindEvent();
                }
            };
            var removalHandler = function () {
                if (!el.ownerDocument.contains(el)) {
                    unbindEvent();
                }
            };
            var unbindEvent = function () {
                canEvent.off.call(bindingContext, event, handler);
                if (attributesDisposal) {
                    attributesDisposal();
                    attributesDisposal = undefined;
                }
                if (removalDisposal) {
                    removalDisposal();
                    removalDisposal = undefined;
                }
            };
            canEvent.on.call(bindingContext, event, handler);
            attributesDisposal = domMutate.onNodeAttributeChange(el, attributesHandler);
            removalDisposal = domMutate.onNodeRemoval(el, removalHandler);
        }
    };
    viewCallbacks.attr(/[\w\.:]+:to$/, behaviors.data);
    viewCallbacks.attr(/[\w\.:]+:from$/, behaviors.data);
    viewCallbacks.attr(/[\w\.:]+:bind$/, behaviors.data);
    viewCallbacks.attr(/[\w\.:]+:to:on:[\w\.:]+/, behaviors.data);
    viewCallbacks.attr(/[\w\.:]+:from:on:[\w\.:]+/, behaviors.data);
    viewCallbacks.attr(/[\w\.:]+:bind:on:[\w\.:]+/, behaviors.data);
    viewCallbacks.attr(/on:[\w\.:]+/, behaviors.event);
    var getObservableFrom = {
        viewModelOrAttribute: function (el, scope, vmNameOrProp, bindingData, mustBeSettable, stickyCompute, event) {
            var viewModel = el[canSymbol.for('can.viewModel')];
            if (viewModel) {
                return this.viewModel.apply(this, arguments);
            } else {
                return this.attribute.apply(this, arguments);
            }
        },
        scope: function (el, scope, scopeProp, bindingData, mustBeSettable, stickyCompute) {
            if (!scopeProp) {
                return new SimpleObservable();
            } else {
                if (mustBeSettable) {
                    var parentExpression = expression.parse(scopeProp, { baseMethodType: 'Call' });
                    return parentExpression.value(scope);
                } else {
                    var observation = {};
                    canReflect.assignSymbols(observation, {
                        'can.getValue': function getValue() {
                        },
                        'can.valueHasDependencies': function hasValueDependencies() {
                            return false;
                        },
                        'can.setValue': function setValue(newVal) {
                            scope.set(cleanVMName(scopeProp, scope), newVal);
                        },
                        'can.getWhatIChange': function getWhatIChange() {
                            var data = scope.getDataForScopeSet(cleanVMName(scopeProp, scope));
                            return {
                                mutate: {
                                    keyDependencies: new Map([[
                                            data.parent,
                                            new Set([data.key])
                                        ]])
                                }
                            };
                        },
                        'can.getName': function getName() {
                        }
                    });
                    var data = scope.getDataForScopeSet(cleanVMName(scopeProp, scope));
                    if (data.parent && data.key) {
                        canReflectDeps.addMutatedBy(data.parent, data.key, observation);
                    }
                    return observation;
                }
            }
        },
        viewModel: function (el, scope, vmName, bindingData, mustBeSettable, stickyCompute, childEvent) {
            var setName = cleanVMName(vmName, scope);
            var isBoundToContext = vmName === '.' || vmName === 'this';
            var keysToRead = isBoundToContext ? [] : observeReader.reads(vmName);
            function getViewModelProperty() {
                var viewModel = bindingData.getViewModel();
                return observeReader.read(viewModel, keysToRead, {}).value;
            }
            var observation = new SettableObservable(getViewModelProperty, function setViewModelProperty(newVal) {
                var viewModel = bindingData.getViewModel();
                if (stickyCompute) {
                    var oldValue = canReflect.getKeyValue(viewModel, setName);
                    if (canReflect.isObservableLike(oldValue)) {
                        canReflect.setValue(oldValue, newVal);
                    } else {
                        canReflect.setKeyValue(viewModel, setName, new SimpleObservable(canReflect.getValue(stickyCompute)));
                    }
                } else {
                    if (isBoundToContext) {
                        canReflect.setValue(viewModel, newVal);
                    } else {
                        canReflect.setKeyValue(viewModel, setName, newVal);
                    }
                }
            });
            return observation;
        },
        attribute: function (el, scope, prop, bindingData, mustBeSettable, stickyCompute, event, bindingInfo) {
            return new AttributeObservable(el, prop, bindingData, event);
        }
    };
    var bind = {
        childToParent: function (el, parentObservable, childObservable, bindingsSemaphore, attrName, syncChild, bindingInfo) {
            function updateParent(newVal) {
                if (!bindingsSemaphore[attrName]) {
                    if (parentObservable && parentObservable[getValueSymbol]) {
                        var hasDependencies = canReflect.valueHasDependencies(parentObservable);
                        if (!hasDependencies || canReflect.getValue(parentObservable) !== newVal) {
                            canReflect.setValue(parentObservable, newVal);
                        }
                        if (syncChild && hasDependencies) {
                            if (canReflect.getValue(parentObservable) !== canReflect.getValue(childObservable)) {
                                bindingsSemaphore[attrName] = (bindingsSemaphore[attrName] || 0) + 1;
                                queues.batch.start();
                                canReflect.setValue(childObservable, canReflect.getValue(parentObservable));
                                queues.mutateQueue.enqueue(function decrementChildToParentSemaphore() {
                                    --bindingsSemaphore[attrName];
                                }, null, [], {});
                                queues.batch.stop();
                            }
                        }
                    } else if (canReflect.isMapLike(parentObservable)) {
                        var attrValue = el.getAttribute(attrName);
                        dev.warn('can-stache-bindings: Merging ' + attrName + ' into ' + attrValue + ' because its parent is non-observable');
                        canReflect.eachKey(parentObservable, function (prop) {
                            canReflect.deleteKeyValue(parentObservable, prop);
                        });
                        canReflect.setValue(parentObservable, newVal && newVal.serialize ? newVal.serialize() : newVal, true);
                    }
                }
            }
            if (childObservable && childObservable[getValueSymbol]) {
                canReflect.onValue(childObservable, updateParent, 'domUI');
            }
            return updateParent;
        },
        parentToChild: function (el, parentObservable, childObservable, bindingsSemaphore, attrName, bindingInfo) {
            var updateChild = function updateChild(newValue) {
                bindingsSemaphore[attrName] = (bindingsSemaphore[attrName] || 0) + 1;
                queues.batch.start();
                canReflect.setValue(childObservable, newValue);
                queues.mutateQueue.enqueue(function decrementParentToChildSemaphore() {
                    --bindingsSemaphore[attrName];
                }, null, [], {});
                queues.batch.stop();
            };
            if (parentObservable && parentObservable[getValueSymbol]) {
                canReflect.onValue(parentObservable, updateChild, 'domUI');
            }
            return updateChild;
        }
    };
    var startsWith = String.prototype.startsWith || function (text) {
        return this.indexOf(text) === 0;
    };
    function getEventName(result) {
        if (result.special.on !== undefined) {
            return result.tokens[result.special.on + 1];
        }
    }
    var bindingRules = {
        to: {
            childToParent: true,
            parentToChild: false,
            syncChildWithParent: false
        },
        from: {
            childToParent: false,
            parentToChild: true,
            syncChildWithParent: false
        },
        bind: {
            childToParent: true,
            parentToChild: true,
            syncChildWithParent: true
        }
    };
    var bindingNames = [];
    var special = {
        vm: true,
        on: true
    };
    each(bindingRules, function (value, key) {
        bindingNames.push(key);
        special[key] = true;
    });
    function tokenize(source) {
        var splitByColon = source.split(':');
        var result = {
            tokens: [],
            special: {}
        };
        splitByColon.forEach(function (token) {
            if (special[token]) {
                result.special[token] = result.tokens.push(token) - 1;
            } else {
                result.tokens.push(token);
            }
        });
        return result;
    }
    var getChildBindingStr = function (tokens, favorViewModel) {
        if (tokens.indexOf('vm') >= 0) {
            return viewModelBindingStr;
        } else if (tokens.indexOf('el') >= 0) {
            return attributeBindingStr;
        } else {
            return favorViewModel ? viewModelBindingStr : viewModelOrAttributeBindingStr;
        }
    };
    var getBindingInfo = function (node, attributeViewModelBindings, templateType, tagName, favorViewModel) {
        var bindingInfo, attributeName = encoder.decode(node.name), attributeValue = node.value || '';
        var result = tokenize(attributeName), dataBindingName, specialIndex;
        bindingNames.forEach(function (name) {
            if (result.special[name] !== undefined && result.special[name] > 0) {
                dataBindingName = name;
                specialIndex = result.special[name];
                return false;
            }
        });
        if (dataBindingName) {
            var childEventName = getEventName(result);
            var initializeValues = childEventName ? false : true;
            bindingInfo = assign({
                parent: scopeBindingStr,
                child: getChildBindingStr(result.tokens, favorViewModel),
                childName: result.tokens[specialIndex - 1],
                childEvent: childEventName,
                bindingAttributeName: attributeName,
                parentName: attributeValue,
                initializeValues: initializeValues
            }, bindingRules[dataBindingName]);
            if (attributeValue.trim().charAt(0) === '~') {
                bindingInfo.stickyParentToChild = true;
            }
            return bindingInfo;
        }
    };
    var makeDataBinding = function (node, el, bindingData) {
        var bindingInfo = getBindingInfo(node, bindingData.attributeViewModelBindings, bindingData.templateType, el.nodeName.toLowerCase(), bindingData.favorViewModel);
        if (!bindingInfo) {
            return;
        }
        bindingInfo.alreadyUpdatedChild = bindingData.alreadyUpdatedChild;
        if (bindingData.initializeValues) {
            bindingInfo.initializeValues = true;
        }
        var parentObservable = getObservableFrom[bindingInfo.parent](el, bindingData.scope, bindingInfo.parentName, bindingData, bindingInfo.parentToChild, undefined, undefined, bindingInfo), childObservable = getObservableFrom[bindingInfo.child](el, bindingData.scope, bindingInfo.childName, bindingData, bindingInfo.childToParent, bindingInfo.stickyParentToChild && parentObservable, bindingInfo.childEvent, bindingInfo), updateParent, updateChild;
        if (bindingData.nodeList) {
            if (parentObservable) {
                canReflect.setPriority(parentObservable, bindingData.nodeList.nesting + 1);
            }
            if (childObservable) {
                canReflect.setPriority(childObservable, bindingData.nodeList.nesting + 1);
            }
        }
        if (bindingInfo.parentToChild) {
            updateChild = bind.parentToChild(el, parentObservable, childObservable, bindingData.semaphore, bindingInfo.bindingAttributeName, bindingInfo);
        }
        var completeBinding = function () {
            if (bindingInfo.childToParent) {
                updateParent = bind.childToParent(el, parentObservable, childObservable, bindingData.semaphore, bindingInfo.bindingAttributeName, bindingInfo.syncChildWithParent, bindingInfo);
            } else if (bindingInfo.stickyParentToChild && childObservable[onValueSymbol]) {
                canReflect.onValue(childObservable, noop, 'mutate');
            }
            if (bindingInfo.initializeValues) {
                initializeValues(bindingInfo, childObservable, parentObservable, updateChild, updateParent);
            }
        };
        var onTeardown = function () {
            unbindUpdate(parentObservable, updateChild);
            unbindUpdate(childObservable, updateParent);
            unbindUpdate(childObservable, noop);
        };
        if (bindingInfo.child === viewModelBindingStr) {
            return {
                value: bindingInfo.stickyParentToChild ? makeCompute(parentObservable) : canReflect.getValue(parentObservable),
                onCompleteBinding: completeBinding,
                bindingInfo: bindingInfo,
                onTeardown: onTeardown
            };
        } else {
            completeBinding();
            return {
                bindingInfo: bindingInfo,
                onTeardown: onTeardown
            };
        }
    };
    var initializeValues = function (bindingInfo, childObservable, parentObservable, updateChild, updateParent) {
        var doUpdateParent = false;
        if (bindingInfo.parentToChild && !bindingInfo.childToParent) {
        } else if (!bindingInfo.parentToChild && bindingInfo.childToParent) {
            doUpdateParent = true;
        } else if (canReflect.getValue(childObservable) === undefined) {
        } else if (canReflect.getValue(parentObservable) === undefined) {
            doUpdateParent = true;
        }
        if (doUpdateParent) {
            updateParent(canReflect.getValue(childObservable));
        } else {
            if (!bindingInfo.alreadyUpdatedChild) {
                updateChild(canReflect.getValue(parentObservable));
            }
        }
    };
    var unbindUpdate = function (observable, updater) {
            if (observable && observable[getValueSymbol] && typeof updater === 'function') {
                canReflect.offValue(observable, updater, 'domUI');
            }
        }, cleanVMName = function (name, scope) {
            return name.replace(/@/g, '');
        };
    module.exports = {
        behaviors: behaviors,
        getBindingInfo: getBindingInfo
    };
});
/*can-simple-observable@2.0.1#async/async*/
define('can-simple-observable@2.0.1#async/async', [
    'require',
    'exports',
    'module',
    '../can-simple-observable',
    'can-observation',
    'can-queues',
    '../settable/settable',
    'can-reflect',
    'can-observation-recorder',
    'can-event-queue/value/value'
], function (require, exports, module) {
    var SimpleObservable = require('../can-simple-observable');
    var Observation = require('can-observation');
    var queues = require('can-queues');
    var SettableObservable = require('../settable/settable');
    var canReflect = require('can-reflect');
    var ObservationRecorder = require('can-observation-recorder');
    var valueEventBindings = require('can-event-queue/value/value');
    function AsyncObservable(fn, context, initialValue) {
        this.resolve = this.resolve.bind(this);
        this.lastSetValue = new SimpleObservable(initialValue);
        this.handler = this.handler.bind(this);
        function observe() {
            this.resolveCalled = false;
            this.inGetter = true;
            var newVal = fn.call(context, this.lastSetValue.get(), this.bound === true ? this.resolve : undefined);
            this.inGetter = false;
            if (newVal !== undefined) {
                this.resolve(newVal);
            } else if (this.resolveCalled) {
                this.resolve(this.value);
            }
            if (this.bound !== true) {
                return newVal;
            }
        }
        this.observation = new Observation(observe, this);
    }
    AsyncObservable.prototype = Object.create(SettableObservable.prototype);
    AsyncObservable.prototype.constructor = AsyncObservable;
    AsyncObservable.prototype.handler = function (newVal) {
        if (newVal !== undefined) {
            SettableObservable.prototype.handler.apply(this, arguments);
        }
    };
    var peek = ObservationRecorder.ignore(canReflect.getValue.bind(canReflect));
    AsyncObservable.prototype.onBound = function () {
        this.bound = true;
        canReflect.onValue(this.observation, this.handler, 'notify');
        if (!this.resolveCalled) {
            this.value = peek(this.observation);
        }
    };
    AsyncObservable.prototype.resolve = function resolve(newVal) {
        this.resolveCalled = true;
        var old = this.value;
        this.value = newVal;
        if (!this.inGetter) {
            queues.enqueueByQueue(this.handlers.getNode([]), this, [
                newVal,
                old
            ], null);
        }
    };
    module.exports = AsyncObservable;
});
/*can-simple-observable@2.0.1#resolver/resolver*/
define('can-simple-observable@2.0.1#resolver/resolver', [
    'require',
    'exports',
    'module',
    'can-reflect',
    'can-symbol',
    'can-observation-recorder',
    'can-observation',
    'can-queues',
    'can-event-queue/map/map',
    '../settable/settable',
    '../can-simple-observable'
], function (require, exports, module) {
    var canReflect = require('can-reflect');
    var canSymbol = require('can-symbol');
    var ObservationRecorder = require('can-observation-recorder');
    var Observation = require('can-observation');
    var queues = require('can-queues');
    var mapEventBindings = require('can-event-queue/map/map');
    var SettableObservable = require('../settable/settable');
    var SimpleObservable = require('../can-simple-observable');
    var getChangesSymbol = canSymbol.for('can.getChangesDependencyRecord');
    function ResolverObservable(resolver, context) {
        this.resolver = resolver;
        this.context = context;
        this.valueOptions = {
            resolve: this.resolve.bind(this),
            listenTo: this.listenTo.bind(this),
            stopListening: this.stopListening.bind(this),
            lastSet: new SimpleObservable(undefined)
        };
        this.update = this.update.bind(this);
        this.contextHandlers = new WeakMap();
        this.teardown = null;
        this.binder = {};
    }
    ResolverObservable.prototype = Object.create(SettableObservable.prototype);
    function deleteHandler(bindTarget, event, queue, handler) {
        mapEventBindings.off.call(bindTarget, event, handler, queue);
    }
    canReflect.assignMap(ResolverObservable.prototype, {
        constructor: ResolverObservable,
        listenTo: function (bindTarget, event, handler, queueName) {
            if (canReflect.isPrimitive(bindTarget)) {
                handler = event;
                event = bindTarget;
                bindTarget = this.context;
            }
            if (typeof event === 'function') {
                handler = event;
                event = undefined;
            }
            var resolverInstance = this;
            var contextHandler = handler.bind(this.context);
            contextHandler[getChangesSymbol] = function getChangesDependencyRecord() {
                return { valueDependencies: new Set([resolverInstance]) };
            };
            this.contextHandlers.set(handler, contextHandler);
            mapEventBindings.listenTo.call(this.binder, bindTarget, event, contextHandler, queueName || 'notify');
        },
        stopListening: function () {
            var meta = this.binder[canSymbol.for('can.meta')];
            var listenHandlers = meta && meta.listenHandlers;
            if (listenHandlers) {
                var keys = mapEventBindings.stopListeningArgumentsToKeys.call({
                    context: this.context,
                    defaultQueue: 'notify'
                });
                listenHandlers.delete(keys, deleteHandler);
            }
            return this;
        },
        resolve: function (newVal) {
            this.value = newVal;
            if (this.isBinding) {
                this.lastValue = this.value;
                return newVal;
            }
            if (this.value !== this.lastValue) {
                queues.batch.start();
                queues.deriveQueue.enqueue(this.update, this, [], {});
                queues.batch.stop();
            }
            return newVal;
        },
        update: function () {
            if (this.lastValue !== this.value) {
                var old = this.lastValue;
                this.lastValue = this.value;
                queues.enqueueByQueue(this.handlers.getNode([]), this, [
                    this.value,
                    old
                ]);
            }
        },
        onBound: function () {
            this.bound = true;
            this.isBinding = true;
            this.teardown = this.resolver.call(this.context, this.valueOptions);
            this.isBinding = false;
        },
        onUnbound: function () {
            this.bound = false;
            mapEventBindings.stopListening.call(this.binder);
            if (this.teardown != null) {
                this.teardown();
                this.teardown = null;
            }
        },
        set: function (value) {
            this.valueOptions.lastSet.set(value);
        },
        get: function () {
            if (ObservationRecorder.isRecording()) {
                ObservationRecorder.add(this);
                if (!this.bound) {
                    Observation.temporarilyBind(this);
                }
            }
            if (this.bound === true) {
                return this.value;
            } else {
                var handler = function () {
                };
                this.on(handler);
                var val = this.value;
                this.off(handler);
                return val;
            }
        },
        hasDependencies: function hasDependencies() {
            var hasDependencies = false;
            if (this.bound) {
                var meta = this.binder[canSymbol.for('can.meta')];
                var listenHandlers = meta && meta.listenHandlers;
                hasDependencies = !!listenHandlers.size();
            }
            return hasDependencies;
        },
        getValueDependencies: function getValueDependencies() {
            if (this.bound) {
                var meta = this.binder[canSymbol.for('can.meta')];
                var listenHandlers = meta && meta.listenHandlers;
                var keyDeps = new Map();
                var valueDeps = new Set();
                if (listenHandlers) {
                    canReflect.each(listenHandlers.root, function (events, obj) {
                        canReflect.each(events, function (queues, eventName) {
                            if (eventName === undefined) {
                                valueDeps.add(obj);
                            } else {
                                var entry = keyDeps.get(obj);
                                if (!entry) {
                                    entry = new Set();
                                    keyDeps.set(obj, entry);
                                }
                                entry.add(eventName);
                            }
                        });
                    });
                    if (valueDeps.size || keyDeps.size) {
                        var result = {};
                        if (keyDeps.size) {
                            result.keyDependencies = keyDeps;
                        }
                        if (valueDeps.size) {
                            result.valueDependencies = valueDeps;
                        }
                        return result;
                    }
                }
            }
        }
    });
    canReflect.assignSymbols(ResolverObservable.prototype, {
        'can.getValue': ResolverObservable.prototype.get,
        'can.setValue': ResolverObservable.prototype.set,
        'can.isMapLike': false,
        'can.getPriority': function () {
            return this.priority || 0;
        },
        'can.setPriority': function (newPriority) {
            this.priority = newPriority;
        },
        'can.valueHasDependencies': ResolverObservable.prototype.hasDependencies,
        'can.getValueDependencies': ResolverObservable.prototype.getValueDependencies
    });
    module.exports = ResolverObservable;
});
/*can-event-queue@1.0.0#type/type*/
define('can-event-queue@1.0.0#type/type', [
    'require',
    'exports',
    'module',
    'can-reflect',
    'can-symbol',
    'can-key-tree',
    'can-queues'
], function (require, exports, module) {
    var canReflect = require('can-reflect');
    var canSymbol = require('can-symbol');
    var KeyTree = require('can-key-tree');
    var queues = require('can-queues');
    var metaSymbol = canSymbol.for('can.meta');
    function addHandlers(obj, meta) {
        if (!meta.lifecycleHandlers) {
            meta.lifecycleHandlers = new KeyTree([
                Object,
                Array
            ]);
        }
        if (!meta.instancePatchesHandlers) {
            meta.instancePatchesHandlers = new KeyTree([
                Object,
                Array
            ]);
        }
    }
    function ensureMeta(obj) {
        var meta = obj[metaSymbol];
        if (!meta) {
            meta = {};
            canReflect.setKeyValue(obj, metaSymbol, meta);
        }
        addHandlers(obj, meta);
        return meta;
    }
    var props = {};
    function onOffAndDispatch(symbolName, dispatchName, handlersName) {
        props['can.on' + symbolName] = function (handler, queueName) {
            ensureMeta(this)[handlersName].add([
                queueName || 'mutate',
                handler
            ]);
        };
        props['can.off' + symbolName] = function (handler, queueName) {
            ensureMeta(this)[handlersName].delete([
                queueName || 'mutate',
                handler
            ]);
        };
        props['can.' + dispatchName] = function (instance, arg) {
            queues.enqueueByQueue(ensureMeta(this)[handlersName].getNode([]), this, [
                instance,
                arg
            ]);
        };
    }
    onOffAndDispatch('InstancePatches', 'dispatchInstanceOnPatches', 'instancePatchesHandlers');
    onOffAndDispatch('InstanceBoundChange', 'dispatchInstanceBoundChange', 'lifecycleHandlers');
    function mixinTypeBindings(obj) {
        return canReflect.assignSymbols(obj, props);
    }
    Object.defineProperty(mixinTypeBindings, 'addHandlers', {
        enumerable: false,
        value: addHandlers
    });
    module.exports = mixinTypeBindings;
});
/*can-util@3.11.2#js/defaults/defaults*/
define('can-util@3.11.2#js/defaults/defaults', function (require, exports, module) {
    'use strict';
    module.exports = function (target) {
        var length = arguments.length;
        for (var i = 1; i < length; i++) {
            for (var prop in arguments[i]) {
                if (target[prop] === undefined) {
                    target[prop] = arguments[i][prop];
                }
            }
        }
        return target;
    };
});
/*can-util@3.11.2#js/string-to-any/string-to-any*/
define('can-util@3.11.2#js/string-to-any/string-to-any', function (require, exports, module) {
    'use strict';
    module.exports = function (str) {
        switch (str) {
        case 'NaN':
        case 'Infinity':
            return +str;
        case 'null':
            return null;
        case 'undefined':
            return undefined;
        case 'true':
        case 'false':
            return str === 'true';
        default:
            var val = +str;
            if (!isNaN(val)) {
                return val;
            } else {
                return str;
            }
        }
    };
});
/*can-define@2.0.1#can-define*/
define('can-define@2.0.1#can-define', [
    'require',
    'exports',
    'module',
    'can-namespace',
    'can-symbol',
    'can-reflect',
    'can-observation',
    'can-observation-recorder',
    'can-simple-observable/async/async',
    'can-simple-observable/settable/settable',
    'can-simple-observable/resolver/resolver',
    'can-event-queue/map/map',
    'can-event-queue/type/type',
    'can-queues',
    'can-util/js/is-empty-object/is-empty-object',
    'can-util/js/assign/assign',
    'can-log/dev/dev',
    'can-util/js/is-plain-object/is-plain-object',
    'can-util/js/each/each',
    'can-util/js/defaults/defaults',
    'can-util/js/string-to-any/string-to-any',
    'can-define-lazy-value'
], function (require, exports, module) {
    'use strict';
    'format cjs';
    var ns = require('can-namespace');
    var canSymbol = require('can-symbol');
    var canReflect = require('can-reflect');
    var Observation = require('can-observation');
    var ObservationRecorder = require('can-observation-recorder');
    var AsyncObservable = require('can-simple-observable/async/async');
    var SettableObservable = require('can-simple-observable/settable/settable');
    var ResolverObservable = require('can-simple-observable/resolver/resolver');
    var eventQueue = require('can-event-queue/map/map');
    var addTypeEvents = require('can-event-queue/type/type');
    var queues = require('can-queues');
    var isEmptyObject = require('can-util/js/is-empty-object/is-empty-object');
    var assign = require('can-util/js/assign/assign');
    var canLogDev = require('can-log/dev/dev');
    var isPlainObject = require('can-util/js/is-plain-object/is-plain-object');
    var each = require('can-util/js/each/each');
    var defaults = require('can-util/js/defaults/defaults');
    var stringToAny = require('can-util/js/string-to-any/string-to-any');
    var defineLazyValue = require('can-define-lazy-value');
    var eventsProto, define, make, makeDefinition, getDefinitionsAndMethods, isDefineType, getDefinitionOrMethod;
    var peek = ObservationRecorder.ignore(canReflect.getValue.bind(canReflect));
    var Object_defineNamedPrototypeProperty = Object.defineProperty;
    var defineConfigurableAndNotEnumerable = function (obj, prop, value) {
        Object.defineProperty(obj, prop, {
            configurable: true,
            enumerable: false,
            writable: true,
            value: value
        });
    };
    var eachPropertyDescriptor = function (map, cb) {
        for (var prop in map) {
            if (map.hasOwnProperty(prop)) {
                cb.call(map, prop, Object.getOwnPropertyDescriptor(map, prop));
            }
        }
    };
    function cleanUpDefinition(prop, definition, shouldWarn) {
        if (definition.value !== undefined && (typeof definition.value !== 'function' || definition.value.length === 0)) {
            definition.default = definition.value;
            delete definition.value;
        }
        if (definition.Value !== undefined) {
            definition.Default = definition.Value;
            delete definition.Value;
        }
    }
    module.exports = define = ns.define = function (objPrototype, defines, baseDefine) {
        var prop, dataInitializers = Object.create(baseDefine ? baseDefine.dataInitializers : null), computedInitializers = Object.create(baseDefine ? baseDefine.computedInitializers : null);
        var result = getDefinitionsAndMethods(defines, baseDefine);
        result.dataInitializers = dataInitializers;
        result.computedInitializers = computedInitializers;
        each(result.definitions, function (definition, property) {
            define.property(objPrototype, property, definition, dataInitializers, computedInitializers, result.defaultDefinition);
        });
        if (objPrototype.hasOwnProperty('_data')) {
            for (prop in dataInitializers) {
                defineLazyValue(objPrototype._data, prop, dataInitializers[prop].bind(objPrototype), true);
            }
        } else {
            defineLazyValue(objPrototype, '_data', function () {
                var map = this;
                var data = {};
                for (var prop in dataInitializers) {
                    defineLazyValue(data, prop, dataInitializers[prop].bind(map), true);
                }
                return data;
            });
        }
        if (objPrototype.hasOwnProperty('_computed')) {
            for (prop in computedInitializers) {
                defineLazyValue(objPrototype._computed, prop, computedInitializers[prop].bind(objPrototype));
            }
        } else {
            defineLazyValue(objPrototype, '_computed', function () {
                var map = this;
                var data = Object.create(null);
                for (var prop in computedInitializers) {
                    defineLazyValue(data, prop, computedInitializers[prop].bind(map));
                }
                return data;
            });
        }
        for (prop in eventsProto) {
            Object.defineProperty(objPrototype, prop, {
                enumerable: false,
                value: eventsProto[prop],
                configurable: true,
                writable: true
            });
        }
        Object.defineProperty(objPrototype, '_define', {
            enumerable: false,
            value: result,
            configurable: true,
            writable: true
        });
        var iteratorSymbol = canSymbol.iterator || canSymbol.for('iterator');
        if (!objPrototype[iteratorSymbol]) {
            defineConfigurableAndNotEnumerable(objPrototype, iteratorSymbol, function () {
                return new define.Iterator(this);
            });
        }
        return result;
    };
    define.extensions = function () {
    };
    var onlyType = function (obj) {
        for (var prop in obj) {
            if (prop !== 'type') {
                return false;
            }
        }
        return true;
    };
    function isValueResolver(definition) {
        return typeof definition.value === 'function' && definition.value.length;
    }
    define.property = function (objPrototype, prop, definition, dataInitializers, computedInitializers, defaultDefinition) {
        var propertyDefinition = define.extensions.apply(this, arguments);
        if (propertyDefinition) {
            definition = makeDefinition(prop, propertyDefinition, defaultDefinition || {});
        }
        var type = definition.type;
        if (type && onlyType(definition) && type === define.types['*']) {
            Object_defineNamedPrototypeProperty(objPrototype, prop, {
                get: make.get.data(prop),
                set: make.set.events(prop, make.get.data(prop), make.set.data(prop), make.eventType.data(prop)),
                enumerable: true,
                configurable: true
            });
            return;
        }
        definition.type = type;
        var dataProperty = definition.get || isValueResolver(definition) ? 'computed' : 'data', reader = make.read[dataProperty](prop), getter = make.get[dataProperty](prop), setter = make.set[dataProperty](prop), getInitialValue;
        var typeConvert = function (val) {
            return val;
        };
        if (definition.Type) {
            typeConvert = make.set.Type(prop, definition.Type, typeConvert);
        }
        if (type) {
            typeConvert = make.set.type(prop, type, typeConvert);
        }
        var eventsSetter = make.set.events(prop, reader, setter, make.eventType[dataProperty](prop));
        if (isValueResolver(definition)) {
            computedInitializers[prop] = make.valueResolver(prop, definition, typeConvert);
        } else if (definition.default !== undefined || definition.Default !== undefined) {
            getInitialValue = ObservationRecorder.ignore(make.get.defaultValue(prop, definition, typeConvert, eventsSetter));
        }
        if (definition.get) {
            computedInitializers[prop] = make.compute(prop, definition.get, getInitialValue);
        } else if (getInitialValue) {
            dataInitializers[prop] = getInitialValue;
        }
        if (definition.get && definition.set) {
            setter = make.set.setter(prop, definition.set, make.read.lastSet(prop), setter, true);
        } else if (definition.set) {
            setter = make.set.setter(prop, definition.set, reader, eventsSetter, false);
        } else if (!definition.get) {
            setter = eventsSetter;
        } else if (definition.get.length < 1) {
            setter = function () {
            };
        }
        if (type) {
            setter = make.set.type(prop, type, setter);
        }
        if (definition.Type) {
            setter = make.set.Type(prop, definition.Type, setter);
        }
        Object_defineNamedPrototypeProperty(objPrototype, prop, {
            get: getter,
            set: setter,
            enumerable: 'serialize' in definition ? !!definition.serialize : !definition.get,
            configurable: true
        });
    };
    define.makeDefineInstanceKey = function (constructor) {
        constructor[canSymbol.for('can.defineInstanceKey')] = function (property, value) {
            var defineResult = this.prototype._define;
            if (typeof value === 'object') {
                cleanUpDefinition(property, value, false);
            }
            var definition = getDefinitionOrMethod(property, value, defineResult.defaultDefinition);
            if (definition && typeof definition === 'object') {
                define.property(constructor.prototype, property, definition, defineResult.dataInitializers, defineResult.computedInitializers, defineResult.defaultDefinition);
                defineResult.definitions[property] = definition;
            } else {
                defineResult.methods[property] = definition;
            }
        };
    };
    define.Constructor = function (defines, sealed) {
        var constructor = function (props) {
            Object.defineProperty(this, '__inSetup', {
                configurable: true,
                enumerable: false,
                value: true,
                writable: true
            });
            define.setup.call(this, props, sealed);
            this.__inSetup = false;
        };
        var result = define(constructor.prototype, defines);
        addTypeEvents(constructor);
        define.makeDefineInstanceKey(constructor, result);
        return constructor;
    };
    make = {
        computeObj: function (map, prop, observable) {
            var computeObj = {
                oldValue: undefined,
                compute: observable,
                count: 0,
                handler: function (newVal) {
                    var oldValue = computeObj.oldValue;
                    computeObj.oldValue = newVal;
                    map.dispatch({
                        type: prop,
                        target: map
                    }, [
                        newVal,
                        oldValue
                    ]);
                }
            };
            return computeObj;
        },
        valueResolver: function (prop, definition, typeConvert) {
            return function () {
                var map = this;
                var computeObj = make.computeObj(map, prop, new ResolverObservable(definition.value, map));
                return computeObj;
            };
        },
        compute: function (prop, get, defaultValueFn) {
            return function () {
                var map = this, defaultValue = defaultValueFn && defaultValueFn.call(this), observable, computeObj;
                if (get.length === 0) {
                    observable = new Observation(get, map);
                } else if (get.length === 1) {
                    observable = new SettableObservable(get, map, defaultValue);
                } else {
                    observable = new AsyncObservable(get, map, defaultValue);
                }
                computeObj = make.computeObj(map, prop, observable);
                return computeObj;
            };
        },
        set: {
            data: function (prop) {
                return function (newVal) {
                    this._data[prop] = newVal;
                };
            },
            computed: function (prop) {
                return function (val) {
                    canReflect.setValue(this._computed[prop].compute, val);
                };
            },
            events: function (prop, getCurrent, setData, eventType) {
                return function (newVal) {
                    if (this.__inSetup) {
                        setData.call(this, newVal);
                    } else {
                        var current = getCurrent.call(this);
                        if (newVal !== current) {
                            setData.call(this, newVal);
                            this.dispatch({
                                patches: [{
                                        type: 'set',
                                        key: prop,
                                        value: newVal
                                    }],
                                type: prop,
                                target: this
                            }, [
                                newVal,
                                current
                            ]);
                        }
                    }
                };
            },
            setter: function (prop, setter, getCurrent, setEvents, hasGetter) {
                return function (value) {
                    var self = this;
                    queues.batch.start();
                    var setterCalled = false, current = getCurrent.call(this), setValue = setter.call(this, value, function (value) {
                            setEvents.call(self, value);
                            setterCalled = true;
                        }, current);
                    if (setterCalled) {
                        queues.batch.stop();
                    } else {
                        if (hasGetter) {
                            if (setValue !== undefined) {
                                if (current !== setValue) {
                                    setEvents.call(this, setValue);
                                }
                                queues.batch.stop();
                            } else if (setter.length === 0) {
                                setEvents.call(this, value);
                                queues.batch.stop();
                                return;
                            } else if (setter.length === 1) {
                                queues.batch.stop();
                            } else {
                                queues.batch.stop();
                                return;
                            }
                        } else {
                            if (setValue !== undefined) {
                                setEvents.call(this, setValue);
                                queues.batch.stop();
                            } else if (setter.length === 0) {
                                setEvents.call(this, value);
                                queues.batch.stop();
                                return;
                            } else if (setter.length === 1) {
                                setEvents.call(this, undefined);
                                queues.batch.stop();
                            } else {
                                queues.batch.stop();
                                return;
                            }
                        }
                    }
                };
            },
            type: function (prop, type, set) {
                if (typeof type === 'object') {
                    return make.set.Type(prop, type, set);
                } else {
                    return function (newValue) {
                        return set.call(this, type.call(this, newValue, prop));
                    };
                }
            },
            Type: function (prop, Type, set) {
                if (Array.isArray(Type) && define.DefineList) {
                    Type = define.DefineList.extend({ '#': Type[0] });
                } else if (typeof Type === 'object') {
                    if (define.DefineMap) {
                        Type = define.DefineMap.extend(Type);
                    } else {
                        Type = define.Constructor(Type);
                    }
                }
                return function (newValue) {
                    if (newValue instanceof Type || newValue == null) {
                        return set.call(this, newValue);
                    } else {
                        return set.call(this, new Type(newValue));
                    }
                };
            }
        },
        eventType: {
            data: function (prop) {
                return function (newVal, oldVal) {
                    return oldVal !== undefined || this._data.hasOwnProperty(prop) ? 'set' : 'add';
                };
            },
            computed: function () {
                return function () {
                    return 'set';
                };
            }
        },
        read: {
            data: function (prop) {
                return function () {
                    return this._data[prop];
                };
            },
            computed: function (prop) {
                return function () {
                    return canReflect.getValue(this._computed[prop].compute);
                };
            },
            lastSet: function (prop) {
                return function () {
                    var observable = this._computed[prop].compute;
                    if (observable.lastSetValue) {
                        return canReflect.getValue(observable.lastSetValue);
                    }
                };
            }
        },
        get: {
            defaultValue: function (prop, definition, typeConvert, callSetter) {
                return function () {
                    var value = definition.default;
                    if (value !== undefined) {
                        if (typeof value === 'function') {
                            value = value.call(this);
                        }
                        value = typeConvert(value);
                    } else {
                        var Default = definition.Default;
                        if (Default) {
                            value = typeConvert(new Default());
                        }
                    }
                    if (definition.set) {
                        var VALUE;
                        var sync = true;
                        var setter = make.set.setter(prop, definition.set, function () {
                        }, function (value) {
                            if (sync) {
                                VALUE = value;
                            } else {
                                callSetter.call(this, value);
                            }
                        }, definition.get);
                        setter.call(this, value);
                        sync = false;
                        return VALUE;
                    }
                    return value;
                };
            },
            data: function (prop) {
                return function () {
                    if (!this.__inSetup) {
                        ObservationRecorder.add(this, prop);
                    }
                    return this._data[prop];
                };
            },
            computed: function (prop) {
                return function (val) {
                    var compute = this._computed[prop].compute;
                    if (ObservationRecorder.isRecording()) {
                        ObservationRecorder.add(this, prop);
                        if (!canReflect.isBound(compute)) {
                            Observation.temporarilyBind(compute);
                        }
                    }
                    return peek(compute);
                };
            }
        }
    };
    define.behaviors = [
        'get',
        'set',
        'value',
        'Value',
        'type',
        'Type',
        'serialize'
    ];
    var addBehaviorToDefinition = function (definition, behavior, value) {
        if (behavior === 'enumerable') {
            definition.serialize = !!value;
        } else if (behavior === 'type') {
            var behaviorDef = value;
            if (typeof behaviorDef === 'string') {
                behaviorDef = define.types[behaviorDef];
                if (typeof behaviorDef === 'object') {
                    assign(definition, behaviorDef);
                    behaviorDef = behaviorDef[behavior];
                }
            }
            if (typeof behaviorDef !== 'undefined') {
                definition[behavior] = behaviorDef;
            }
        } else {
            definition[behavior] = value;
        }
    };
    makeDefinition = function (prop, def, defaultDefinition) {
        var definition = {};
        each(def, function (value, behavior) {
            addBehaviorToDefinition(definition, behavior, value);
        });
        each(defaultDefinition, function (value, prop) {
            if (definition[prop] === undefined) {
                if (prop !== 'type' && prop !== 'Type') {
                    definition[prop] = value;
                }
            }
        });
        if (typeof def.type !== 'string') {
            if (!definition.type && !definition.Type) {
                defaults(definition, defaultDefinition);
            }
            if (isEmptyObject(definition)) {
                definition.type = define.types['*'];
            }
        }
        cleanUpDefinition(prop, definition, true);
        return definition;
    };
    getDefinitionOrMethod = function (prop, value, defaultDefinition) {
        var definition;
        if (typeof value === 'string') {
            definition = { type: value };
        } else if (typeof value === 'function') {
            if (canReflect.isConstructorLike(value)) {
                definition = { Type: value };
            } else if (isDefineType(value)) {
                definition = { type: value };
            }
        } else if (Array.isArray(value)) {
            definition = { Type: value };
        } else if (isPlainObject(value)) {
            definition = value;
        }
        if (definition) {
            return makeDefinition(prop, definition, defaultDefinition);
        } else {
            return value;
        }
    };
    getDefinitionsAndMethods = function (defines, baseDefines) {
        var definitions = Object.create(baseDefines ? baseDefines.definitions : null);
        var methods = {};
        var defaults = defines['*'], defaultDefinition;
        if (defaults) {
            delete defines['*'];
            defaultDefinition = getDefinitionOrMethod('*', defaults, {});
        } else {
            defaultDefinition = Object.create(null);
        }
        eachPropertyDescriptor(defines, function (prop, propertyDescriptor) {
            var value;
            if (propertyDescriptor.get || propertyDescriptor.set) {
                value = {
                    get: propertyDescriptor.get,
                    set: propertyDescriptor.set
                };
            } else {
                value = propertyDescriptor.value;
            }
            if (prop === 'constructor') {
                methods[prop] = value;
                return;
            } else {
                var result = getDefinitionOrMethod(prop, value, defaultDefinition);
                if (result && typeof result === 'object' && !isEmptyObject(result)) {
                    definitions[prop] = result;
                } else {
                    if (typeof result === 'function') {
                        methods[prop] = result;
                    }
                }
            }
        });
        if (defaults) {
            defines['*'] = defaults;
        }
        return {
            definitions: definitions,
            methods: methods,
            defaultDefinition: defaultDefinition
        };
    };
    eventsProto = eventQueue({});
    function setupComputed(instance, eventName) {
        var computedBinding = instance._computed && instance._computed[eventName];
        if (computedBinding && computedBinding.compute) {
            if (!computedBinding.count) {
                computedBinding.count = 1;
                canReflect.onValue(computedBinding.compute, computedBinding.handler, 'notify');
                computedBinding.oldValue = canReflect.getValue(computedBinding.compute);
            } else {
                computedBinding.count++;
            }
        }
    }
    function teardownComputed(instance, eventName) {
        var computedBinding = instance._computed && instance._computed[eventName];
        if (computedBinding) {
            if (computedBinding.count === 1) {
                computedBinding.count = 0;
                canReflect.offValue(computedBinding.compute, computedBinding.handler, 'notify');
            } else {
                computedBinding.count--;
            }
        }
    }
    var canMetaSymbol = canSymbol.for('can.meta');
    assign(eventsProto, {
        _eventSetup: function () {
        },
        _eventTeardown: function () {
        },
        addEventListener: function (eventName, handler, queue) {
            setupComputed(this, eventName);
            return eventQueue.addEventListener.apply(this, arguments);
        },
        removeEventListener: function (eventName, handler) {
            teardownComputed(this, eventName);
            return eventQueue.removeEventListener.apply(this, arguments);
        }
    });
    eventsProto.on = eventsProto.bind = eventsProto.addEventListener;
    eventsProto.off = eventsProto.unbind = eventsProto.removeEventListener;
    var onKeyValueSymbol = canSymbol.for('can.onKeyValue');
    var offKeyValueSymbol = canSymbol.for('can.offKeyValue');
    canReflect.assignSymbols(eventsProto, {
        'can.onKeyValue': function (key) {
            setupComputed(this, key);
            return eventQueue[onKeyValueSymbol].apply(this, arguments);
        },
        'can.offKeyValue': function (key) {
            teardownComputed(this, key);
            return eventQueue[offKeyValueSymbol].apply(this, arguments);
        }
    });
    delete eventsProto.one;
    define.setup = function (props, sealed) {
        Object.defineProperty(this, 'constructor', {
            value: this.constructor,
            enumerable: false,
            writable: false
        });
        Object.defineProperty(this, canMetaSymbol, {
            value: Object.create(null),
            enumerable: false,
            writable: false
        });
        var definitions = this._define.definitions;
        var instanceDefinitions = Object.create(null);
        var map = this;
        canReflect.eachKey(props, function (value, prop) {
            if (definitions[prop] !== undefined) {
                map[prop] = value;
            } else {
                var def = define.makeSimpleGetterSetter(prop);
                instanceDefinitions[prop] = {};
                Object_defineNamedPrototypeProperty(map, prop, def);
                map[prop] = define.types.observable(value);
            }
        });
        if (!isEmptyObject(instanceDefinitions)) {
            defineConfigurableAndNotEnumerable(this, '_instanceDefinitions', instanceDefinitions);
        }
    };
    define.replaceWith = defineLazyValue;
    define.eventsProto = eventsProto;
    define.defineConfigurableAndNotEnumerable = defineConfigurableAndNotEnumerable;
    define.make = make;
    define.getDefinitionOrMethod = getDefinitionOrMethod;
    var simpleGetterSetters = {};
    define.makeSimpleGetterSetter = function (prop) {
        if (simpleGetterSetters[prop] === undefined) {
            var setter = make.set.events(prop, make.get.data(prop), make.set.data(prop), make.eventType.data(prop));
            simpleGetterSetters[prop] = {
                get: make.get.data(prop),
                set: function (newVal) {
                    return setter.call(this, define.types.observable(newVal));
                },
                enumerable: true
            };
        }
        return simpleGetterSetters[prop];
    };
    define.Iterator = function (obj) {
        this.obj = obj;
        this.definitions = Object.keys(obj._define.definitions);
        this.instanceDefinitions = obj._instanceDefinitions ? Object.keys(obj._instanceDefinitions) : Object.keys(obj);
        this.hasGet = typeof obj.get === 'function';
    };
    define.Iterator.prototype.next = function () {
        var key;
        if (this.definitions.length) {
            key = this.definitions.shift();
            var def = this.obj._define.definitions[key];
            if (def.get) {
                return this.next();
            }
        } else if (this.instanceDefinitions.length) {
            key = this.instanceDefinitions.shift();
        } else {
            return {
                value: undefined,
                done: true
            };
        }
        return {
            value: [
                key,
                this.hasGet ? this.obj.get(key) : this.obj[key]
            ],
            done: false
        };
    };
    isDefineType = function (func) {
        return func && func.canDefineType === true;
    };
    function isObservableValue(obj) {
        return canReflect.isValueLike(obj) && canReflect.isObservableLike(obj);
    }
    define.types = {
        'date': function (str) {
            var type = typeof str;
            if (type === 'string') {
                str = Date.parse(str);
                return isNaN(str) ? null : new Date(str);
            } else if (type === 'number') {
                return new Date(str);
            } else {
                return str;
            }
        },
        'number': function (val) {
            if (val == null) {
                return val;
            }
            return +val;
        },
        'boolean': function (val) {
            if (val == null) {
                return val;
            }
            if (val === 'false' || val === '0' || !val) {
                return false;
            }
            return true;
        },
        'observable': function (newVal) {
            if (Array.isArray(newVal) && define.DefineList) {
                newVal = new define.DefineList(newVal);
            } else if (isPlainObject(newVal) && define.DefineMap) {
                newVal = new define.DefineMap(newVal);
            }
            return newVal;
        },
        'stringOrObservable': function (newVal) {
            if (Array.isArray(newVal)) {
                return new define.DefaultList(newVal);
            } else if (isPlainObject(newVal)) {
                return new define.DefaultMap(newVal);
            } else {
                return define.types.string(newVal);
            }
        },
        'htmlbool': function (val) {
            if (val === '') {
                return true;
            }
            return !!stringToAny(val);
        },
        '*': function (val) {
            return val;
        },
        'any': function (val) {
            return val;
        },
        'string': function (val) {
            if (val == null) {
                return val;
            }
            return '' + val;
        },
        'compute': {
            set: function (newValue, setVal, setErr, oldValue) {
                if (isObservableValue(newValue)) {
                    return newValue;
                }
                if (isObservableValue(oldValue)) {
                    canReflect.setValue(oldValue, newValue);
                    return oldValue;
                }
                return newValue;
            },
            get: function (value) {
                return isObservableValue(value) ? canReflect.getValue(value) : value;
            }
        }
    };
});
/*can-define@2.0.1#define-helpers/define-helpers*/
define('can-define@2.0.1#define-helpers/define-helpers', [
    'require',
    'exports',
    'module',
    'can-define',
    'can-reflect',
    'can-queues'
], function (require, exports, module) {
    var define = require('can-define');
    var canReflect = require('can-reflect');
    var queues = require('can-queues');
    var defineHelpers = {
        defineExpando: function (map, prop, value) {
            var constructorDefines = map._define.definitions;
            if (constructorDefines && constructorDefines[prop]) {
                return;
            }
            var instanceDefines = map._instanceDefinitions;
            if (!instanceDefines) {
                if (Object.isSealed(map)) {
                    return;
                }
                Object.defineProperty(map, '_instanceDefinitions', {
                    configurable: true,
                    enumerable: false,
                    value: {}
                });
                instanceDefines = map._instanceDefinitions;
            }
            if (!instanceDefines[prop]) {
                var defaultDefinition = map._define.defaultDefinition || { type: define.types.observable };
                define.property(map, prop, defaultDefinition, {}, {});
                map._data[prop] = defaultDefinition.type ? defaultDefinition.type(value) : define.types.observable(value);
                instanceDefines[prop] = defaultDefinition;
                queues.batch.start();
                map.dispatch({
                    type: 'can.keys',
                    target: map
                });
                if (map._data[prop] !== undefined) {
                    map.dispatch({
                        type: prop,
                        target: map,
                        patches: [{
                                type: 'set',
                                key: prop,
                                value: map._data[prop]
                            }]
                    }, [
                        map._data[prop],
                        undefined
                    ]);
                }
                queues.batch.stop();
                return true;
            }
        },
        reflectSerialize: function (unwrapped) {
            var constructorDefinitions = this._define.definitions;
            var defaultDefinition = this._define.defaultDefinition;
            this.forEach(function (val, name) {
                var propDef = constructorDefinitions[name];
                if (propDef && typeof propDef.serialize === 'function') {
                    val = propDef.serialize.call(this, val, name);
                } else if (defaultDefinition && typeof defaultDefinition.serialize === 'function') {
                    val = defaultDefinition.serialize.call(this, val, name);
                } else {
                    val = canReflect.serialize(val);
                }
                if (val !== undefined) {
                    unwrapped[name] = val;
                }
            }, this);
            return unwrapped;
        },
        reflectUnwrap: function (unwrapped) {
            this.forEach(function (value, key) {
                if (value !== undefined) {
                    unwrapped[key] = canReflect.unwrap(value);
                }
            });
            return unwrapped;
        }
    };
    module.exports = defineHelpers;
});
/*can-define@2.0.1#ensure-meta*/
define('can-define@2.0.1#ensure-meta', [
    'require',
    'exports',
    'module',
    'can-symbol',
    'can-reflect'
], function (require, exports, module) {
    var canSymbol = require('can-symbol');
    var canReflect = require('can-reflect');
    module.exports = function ensureMeta(obj) {
        var metaSymbol = canSymbol.for('can.meta');
        var meta = obj[metaSymbol];
        if (!meta) {
            meta = {};
            canReflect.setKeyValue(obj, metaSymbol, meta);
        }
        return meta;
    };
});
/*can-define@2.0.1#map/map*/
define('can-define@2.0.1#map/map', [
    'require',
    'exports',
    'module',
    'can-construct',
    'can-define',
    '../define-helpers/define-helpers',
    'can-observation-recorder',
    'can-namespace',
    'can-log',
    'can-log/dev/dev',
    'can-reflect',
    'can-symbol',
    'can-queues',
    '../ensure-meta',
    'can-log/dev/dev',
    'can-event-queue/type/type'
], function (require, exports, module) {
    'use strict';
    var Construct = require('can-construct');
    var define = require('can-define');
    var defineHelpers = require('../define-helpers/define-helpers');
    var ObservationRecorder = require('can-observation-recorder');
    var ns = require('can-namespace');
    var canLog = require('can-log');
    var canLogDev = require('can-log/dev/dev');
    var canReflect = require('can-reflect');
    var canSymbol = require('can-symbol');
    var queues = require('can-queues');
    var ensureMeta = require('../ensure-meta');
    var dev = require('can-log/dev/dev');
    var addTypeEvents = require('can-event-queue/type/type');
    var keysForDefinition = function (definitions) {
        var keys = [];
        for (var prop in definitions) {
            var definition = definitions[prop];
            if (typeof definition !== 'object' || ('serialize' in definition ? !!definition.serialize : !definition.get)) {
                keys.push(prop);
            }
        }
        return keys;
    };
    function assign(source) {
        queues.batch.start();
        canReflect.assignMap(this, source || {});
        queues.batch.stop();
    }
    function update(source) {
        queues.batch.start();
        canReflect.updateMap(this, source || {});
        queues.batch.stop();
    }
    function assignDeep(source) {
        queues.batch.start();
        canReflect.assignDeepMap(this, source || {});
        queues.batch.stop();
    }
    function updateDeep(source) {
        queues.batch.start();
        canReflect.updateDeepMap(this, source || {});
        queues.batch.stop();
    }
    function setKeyValue(key, value) {
        var defined = defineHelpers.defineExpando(this, key, value);
        if (!defined) {
            this[key] = value;
        }
    }
    function getKeyValue(key) {
        var value = this[key];
        if (value !== undefined || key in this || Object.isSealed(this)) {
            return value;
        } else {
            ObservationRecorder.add(this, key);
            return this[key];
        }
    }
    var DefineMap = Construct.extend('DefineMap', {
        setup: function (base) {
            var key, prototype = this.prototype;
            if (DefineMap) {
                var result = define(prototype, prototype, base.prototype._define);
                define.makeDefineInstanceKey(this, result);
                addTypeEvents(this);
                for (key in DefineMap.prototype) {
                    define.defineConfigurableAndNotEnumerable(prototype, key, prototype[key]);
                }
                this.prototype.setup = function (props) {
                    define.setup.call(this, props || {}, this.constructor.seal);
                };
            } else {
                for (key in prototype) {
                    define.defineConfigurableAndNotEnumerable(prototype, key, prototype[key]);
                }
            }
            define.defineConfigurableAndNotEnumerable(prototype, 'constructor', this);
        }
    }, {
        setup: function (props, sealed) {
            if (!this._define) {
                Object.defineProperty(this, '_define', {
                    enumerable: false,
                    value: { definitions: {} }
                });
                Object.defineProperty(this, '_data', {
                    enumerable: false,
                    value: {}
                });
            }
            define.setup.call(this, props || {}, sealed === true);
        },
        get: function (prop) {
            if (prop) {
                return getKeyValue.call(this, prop);
            } else {
                return canReflect.unwrap(this, Map);
            }
        },
        set: function (prop, value) {
            if (typeof prop === 'object') {
                if (value === true) {
                    updateDeep.call(this, prop);
                } else {
                    assignDeep.call(this, prop);
                }
            } else {
                setKeyValue.call(this, prop, value);
            }
            return this;
        },
        assignDeep: function (prop) {
            assignDeep.call(this, prop);
            return this;
        },
        updateDeep: function (prop) {
            updateDeep.call(this, prop);
            return this;
        },
        assign: function (prop) {
            assign.call(this, prop);
            return this;
        },
        update: function (prop) {
            update.call(this, prop);
            return this;
        },
        serialize: function () {
            return canReflect.serialize(this, Map);
        },
        forEach: function () {
            var forEach = function (list, cb, thisarg) {
                    return canReflect.eachKey(list, cb, thisarg);
                }, noObserve = ObservationRecorder.ignore(forEach);
            return function (cb, thisarg, observe) {
                return observe === false ? noObserve(this, cb, thisarg) : forEach(this, cb, thisarg);
            };
        }(),
        '*': { type: define.types.observable },
        log: function (key) {
        }
    });
    canReflect.assignSymbols(DefineMap.prototype, {
        'can.isMapLike': true,
        'can.isListLike': false,
        'can.isValueLike': false,
        'can.getKeyValue': getKeyValue,
        'can.setKeyValue': setKeyValue,
        'can.deleteKeyValue': function (prop) {
            this.set(prop, undefined);
            return this;
        },
        'can.getOwnEnumerableKeys': function () {
            ObservationRecorder.add(this, 'can.keys');
            return keysForDefinition(this._define.definitions).concat(keysForDefinition(this._instanceDefinitions));
        },
        'can.hasOwnKey': function (key) {
            return Object.hasOwnProperty.call(this._define.definitions, key);
        },
        'can.hasKey': function (key) {
            return !!this._define.definitions[key];
        },
        'can.assignDeep': assignDeep,
        'can.updateDeep': updateDeep,
        'can.unwrap': defineHelpers.reflectUnwrap,
        'can.serialize': defineHelpers.reflectSerialize,
        'can.keyHasDependencies': function (key) {
            return !!(this._computed && this._computed[key] && this._computed[key].compute);
        },
        'can.getKeyDependencies': function (key) {
            var ret;
            if (this._computed && this._computed[key] && this._computed[key].compute) {
                ret = {};
                ret.valueDependencies = new Set([this._computed[key].compute]);
            }
            return ret;
        }
    });
    canReflect.setKeyValue(DefineMap.prototype, canSymbol.iterator, function () {
        return new define.Iterator(this);
    });
    for (var prop in define.eventsProto) {
        DefineMap[prop] = define.eventsProto[prop];
        Object.defineProperty(DefineMap.prototype, prop, {
            enumerable: false,
            value: define.eventsProto[prop],
            writable: true
        });
    }
    var eventsProtoSymbols = 'getOwnPropertySymbols' in Object ? Object.getOwnPropertySymbols(define.eventsProto) : [
        canSymbol.for('can.onKeyValue'),
        canSymbol.for('can.offKeyValue')
    ];
    eventsProtoSymbols.forEach(function (sym) {
        Object.defineProperty(DefineMap.prototype, sym, {
            enumerable: false,
            value: define.eventsProto[sym],
            writable: true
        });
    });
    define.DefineMap = DefineMap;
    Object.defineProperty(DefineMap.prototype, 'toObject', {
        enumerable: false,
        writable: true,
        value: function () {
            canLog.warn('Use DefineMap::get instead of DefineMap::toObject');
            return this.get();
        }
    });
    module.exports = ns.DefineMap = DefineMap;
});
/*can-component@4.0.1#can-component*/
define('can-component@4.0.1#can-component', [
    'require',
    'exports',
    'module',
    './control/control',
    'can-namespace',
    'can-construct',
    'can-stache',
    'can-stache-bindings',
    'can-view-scope',
    'can-view-callbacks',
    'can-view-nodelist',
    'can-reflect',
    'can-simple-observable',
    'can-simple-map',
    'can-define/map/map',
    'can-log',
    'can-log/dev/dev',
    'can-assign',
    'can-view-model',
    'can-dom-data-state',
    'can-util/dom/child-nodes/child-nodes',
    'can-util/js/string/string',
    'can-dom-events',
    'can-dom-mutate',
    'can-dom-mutate/node',
    'can-symbol',
    'can-globals/document/document'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        var ComponentControl = require('./control/control');
        var namespace = require('can-namespace');
        var Construct = require('can-construct');
        var stache = require('can-stache');
        var stacheBindings = require('can-stache-bindings');
        var Scope = require('can-view-scope');
        var viewCallbacks = require('can-view-callbacks');
        var nodeLists = require('can-view-nodelist');
        var canReflect = require('can-reflect');
        var SimpleObservable = require('can-simple-observable');
        var SimpleMap = require('can-simple-map');
        var DefineMap = require('can-define/map/map');
        var canLog = require('can-log');
        var canDev = require('can-log/dev/dev');
        var assign = require('can-assign');
        require('can-view-model');
        var domData = require('can-dom-data-state');
        var getChildNodes = require('can-util/dom/child-nodes/child-nodes');
        var string = require('can-util/js/string/string');
        var domEvents = require('can-dom-events');
        var domMutate = require('can-dom-mutate');
        var domMutateNode = require('can-dom-mutate/node');
        var canSymbol = require('can-symbol');
        var DOCUMENT = require('can-globals/document/document');
        function addContext(el, tagData, insertionElementTagData) {
            var vm;
            domData.set.call(el, 'preventDataBindings', true);
            var teardown = stacheBindings.behaviors.viewModel(el, insertionElementTagData, function (initialData) {
                return vm = new SimpleObservable(initialData);
            }, undefined, true);
            if (!teardown) {
                return tagData;
            } else {
                return assign(assign({}, tagData), {
                    teardown: teardown,
                    scope: tagData.scope.add(vm)
                });
            }
        }
        function makeInsertionTagCallback(tagName, componentTagData, shadowTagData, leakScope, getPrimaryTemplate) {
            var options = shadowTagData.options;
            return function hookupFunction(el, insertionElementTagData) {
                var template = getPrimaryTemplate(el) || insertionElementTagData.subtemplate, renderingLightContent = template !== insertionElementTagData.subtemplate;
                if (template) {
                    delete options.tags[tagName];
                    var tagData;
                    if (renderingLightContent) {
                        if (leakScope.toLightContent) {
                            tagData = addContext(el, {
                                scope: insertionElementTagData.scope.cloneFromRef(),
                                options: insertionElementTagData.options
                            }, insertionElementTagData);
                        } else {
                            tagData = addContext(el, componentTagData, insertionElementTagData);
                        }
                    } else {
                        tagData = addContext(el, insertionElementTagData, insertionElementTagData);
                    }
                    var nodeList = nodeLists.register([el], function () {
                        if (tagData.teardown) {
                            tagData.teardown();
                        }
                    }, insertionElementTagData.parentNodeList || true, false);
                    nodeList.expression = '<can-slot name=\'' + el.getAttribute('name') + '\'/>';
                    var frag = template(tagData.scope, tagData.options, nodeList);
                    var newNodes = canReflect.toArray(getChildNodes(frag));
                    nodeLists.replace(nodeList, frag);
                    nodeLists.update(nodeList, newNodes);
                    options.tags[tagName] = hookupFunction;
                }
            };
        }
        var Component = Construct.extend({
            setup: function () {
                Construct.setup.apply(this, arguments);
                if (Component) {
                    var self = this;
                    if (this.prototype.events !== undefined && canReflect.size(this.prototype.events) !== 0) {
                        this.Control = ComponentControl.extend(this.prototype.events);
                    }
                    var protoViewModel = this.prototype.viewModel || this.prototype.scope;
                    if (protoViewModel && this.prototype.ViewModel) {
                        throw new Error('Cannot provide both a ViewModel and a viewModel property');
                    }
                    var vmName = string.capitalize(string.camelize(this.prototype.tag)) + 'VM';
                    if (this.prototype.ViewModel) {
                        if (typeof this.prototype.ViewModel === 'function') {
                            this.ViewModel = this.prototype.ViewModel;
                        } else {
                            this.ViewModel = DefineMap.extend(vmName, {}, this.prototype.ViewModel);
                        }
                    } else {
                        if (protoViewModel) {
                            if (typeof protoViewModel === 'function') {
                                if (canReflect.isObservableLike(protoViewModel.prototype) && canReflect.isMapLike(protoViewModel.prototype)) {
                                    this.ViewModel = protoViewModel;
                                } else {
                                    this.viewModelHandler = protoViewModel;
                                }
                            } else {
                                if (canReflect.isObservableLike(protoViewModel) && canReflect.isMapLike(protoViewModel)) {
                                    this.viewModelInstance = protoViewModel;
                                } else {
                                    canLog.warn('can-component: ' + this.prototype.tag + ' is extending the viewModel into a can-simple-map');
                                    this.ViewModel = SimpleMap.extend(vmName, {}, protoViewModel);
                                }
                            }
                        } else {
                            this.ViewModel = SimpleMap.extend(vmName, {}, {});
                        }
                    }
                    if (this.prototype.template) {
                        this.renderer = this.prototype.template;
                    }
                    if (this.prototype.view) {
                        this.renderer = this.prototype.view;
                    }
                    if (typeof this.renderer === 'string') {
                        this.renderer = stache(this.renderer);
                    }
                    viewCallbacks.tag(this.prototype.tag, function (el, options) {
                        new self(el, options);
                    });
                }
            }
        }, {
            setup: function (el, componentTagData) {
                var component = this;
                var teardownFunctions = [];
                var initialViewModelData = {};
                var callTeardownFunctions = function () {
                    for (var i = 0, len = teardownFunctions.length; i < len; i++) {
                        teardownFunctions[i]();
                    }
                };
                var setupBindings = !domData.get.call(el, 'preventDataBindings');
                var viewModel, frag;
                var teardownBindings;
                if (setupBindings) {
                    var setupFn = componentTagData.setupBindings || function (el, callback, data) {
                        return stacheBindings.behaviors.viewModel(el, componentTagData, callback, data);
                    };
                    teardownBindings = setupFn(el, function (initialViewModelData) {
                        var ViewModel = component.constructor.ViewModel, viewModelHandler = component.constructor.viewModelHandler, viewModelInstance = component.constructor.viewModelInstance;
                        if (viewModelHandler) {
                            var scopeResult = viewModelHandler.call(component, initialViewModelData, componentTagData.scope, el);
                            if (canReflect.isObservableLike(scopeResult) && canReflect.isMapLike(scopeResult)) {
                                viewModelInstance = scopeResult;
                            } else if (canReflect.isObservableLike(scopeResult.prototype) && canReflect.isMapLike(scopeResult.prototype)) {
                                ViewModel = scopeResult;
                            } else {
                                ViewModel = SimpleMap.extend(scopeResult);
                            }
                        }
                        if (ViewModel) {
                            viewModelInstance = new component.constructor.ViewModel(initialViewModelData);
                        }
                        viewModel = viewModelInstance;
                        return viewModelInstance;
                    }, initialViewModelData);
                } else {
                    viewModel = el[canSymbol.for('can.viewModel')];
                }
                this.viewModel = viewModel;
                el[canSymbol.for('can.viewModel')] = viewModel;
                domData.set.call(el, 'preventDataBindings', true);
                var options = {
                    helpers: {},
                    tags: {}
                };
                if (this.helpers !== undefined) {
                    canReflect.eachKey(this.helpers, function (val, prop) {
                        if (typeof val === 'function') {
                            options.helpers[prop] = val.bind(viewModel);
                        }
                    });
                }
                if (this.constructor.Control) {
                    this._control = new this.constructor.Control(el, {
                        scope: this.viewModel,
                        viewModel: this.viewModel,
                        destroy: callTeardownFunctions
                    });
                } else {
                    var removalDisposal = domMutate.onNodeRemoval(el, function () {
                        if (!el.ownerDocument.contains(el)) {
                            removalDisposal();
                            callTeardownFunctions();
                        }
                    });
                }
                var leakScope = {
                    toLightContent: this.leakScope === true,
                    intoShadowContent: this.leakScope === true
                };
                var hasShadowTemplate = !!this.constructor.renderer;
                var betweenTagsRenderer;
                var betweenTagsTagData;
                if (hasShadowTemplate) {
                    var shadowTagData;
                    if (leakScope.intoShadowContent) {
                        shadowTagData = {
                            scope: componentTagData.scope.add(this.viewModel),
                            options: options
                        };
                    } else {
                        shadowTagData = {
                            scope: new Scope(this.viewModel),
                            options: options
                        };
                    }
                    options.tags['can-slot'] = makeInsertionTagCallback('can-slot', componentTagData, shadowTagData, leakScope, function (el) {
                        var templates = componentTagData.templates;
                        if (templates) {
                            return templates[el.getAttribute('name')];
                        }
                    });
                    options.tags.content = makeInsertionTagCallback('content', componentTagData, shadowTagData, leakScope, function () {
                        return componentTagData.subtemplate;
                    });
                    betweenTagsRenderer = this.constructor.renderer;
                    betweenTagsTagData = shadowTagData;
                } else {
                    var lightTemplateTagData = {
                        scope: componentTagData.scope.add(this.viewModel, { viewModel: true }),
                        options: options
                    };
                    betweenTagsTagData = lightTemplateTagData;
                    betweenTagsRenderer = componentTagData.subtemplate || el.ownerDocument.createDocumentFragment.bind(el.ownerDocument);
                }
                var disconnectedCallback, componentInPage;
                var nodeList = nodeLists.register([], function () {
                    domEvents.dispatch(el, 'beforeremove', false);
                    if (teardownBindings) {
                        teardownBindings();
                    }
                    if (disconnectedCallback) {
                        disconnectedCallback(el);
                    }
                }, componentTagData.parentNodeList || true, false);
                nodeList.expression = '<' + this.tag + '>';
                teardownFunctions.push(function () {
                    nodeLists.unregister(nodeList);
                });
                frag = betweenTagsRenderer(betweenTagsTagData.scope, betweenTagsTagData.options, nodeList);
                domMutateNode.appendChild.call(el, frag);
                nodeLists.update(nodeList, getChildNodes(el));
                if (viewModel && viewModel.connectedCallback) {
                    componentInPage = DOCUMENT().body.contains(el);
                    if (componentInPage) {
                        disconnectedCallback = viewModel.connectedCallback(el);
                    } else {
                        var insertionDisposal = domMutate.onNodeInsertion(el, function () {
                            insertionDisposal();
                            disconnectedCallback = viewModel.connectedCallback(el);
                        });
                    }
                }
            }
        });
        module.exports = namespace.Component = Component;
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-component@4.0.1#test/component-tag-test*/
define('can-component@4.0.1#test/component-tag-test', [
    'require',
    'exports',
    'module',
    'steal-qunit',
    './helpers',
    'can-simple-map',
    'can-stache',
    'can-component',
    'can-view-model',
    'can-simple-observable/setter/setter',
    'can-simple-observable',
    'can-dom-mutate/node'
], function (require, exports, module) {
    var QUnit = require('steal-qunit');
    var helpers = require('./helpers');
    var SimpleMap = require('can-simple-map');
    var stache = require('can-stache');
    var Component = require('can-component');
    var canViewModel = require('can-view-model');
    var SetterObservable = require('can-simple-observable/setter/setter');
    var SimpleObservable = require('can-simple-observable');
    var domMutateNode = require('can-dom-mutate/node');
    var innerHTML = function (el) {
        return el && el.innerHTML;
    };
    helpers.makeTests('can-component tag', function () {
        QUnit.test('hyphen-less tag names', function () {
            Component.extend({
                tag: 'foobar',
                view: stache('<div>{{name}}</div>'),
                viewModel: function () {
                    return new SimpleMap({ name: 'Brian' });
                }
            });
            var renderer = stache('<span></span><foobar></foobar>');
            var frag = renderer();
            equal(frag.lastChild.firstChild.firstChild.nodeValue, 'Brian');
        });
    });
});
/*can-define@2.0.1#list/list*/
define('can-define@2.0.1#list/list', [
    'require',
    'exports',
    'module',
    'can-construct',
    'can-define',
    'can-queues',
    'can-event-queue/type/type',
    'can-observation-recorder',
    'can-log',
    'can-log/dev/dev',
    '../define-helpers/define-helpers',
    'can-log/dev/dev',
    '../ensure-meta',
    'can-util/js/assign/assign',
    'can-util/js/diff/diff',
    'can-util/js/each/each',
    'can-util/js/make-array/make-array',
    'can-namespace',
    'can-reflect',
    'can-symbol',
    'can-util/js/single-reference/single-reference'
], function (require, exports, module) {
    var Construct = require('can-construct');
    var define = require('can-define');
    var make = define.make;
    var queues = require('can-queues');
    var addTypeEvents = require('can-event-queue/type/type');
    var ObservationRecorder = require('can-observation-recorder');
    var canLog = require('can-log');
    var canLogDev = require('can-log/dev/dev');
    var defineHelpers = require('../define-helpers/define-helpers');
    var dev = require('can-log/dev/dev');
    var ensureMeta = require('../ensure-meta');
    var assign = require('can-util/js/assign/assign');
    var diff = require('can-util/js/diff/diff');
    var each = require('can-util/js/each/each');
    var makeArray = require('can-util/js/make-array/make-array');
    var ns = require('can-namespace');
    var canReflect = require('can-reflect');
    var canSymbol = require('can-symbol');
    var singleReference = require('can-util/js/single-reference/single-reference');
    var splice = [].splice;
    var runningNative = false;
    var identity = function (x) {
        return x;
    };
    var localOnPatchesSymbol = 'can.patches';
    var makeFilterCallback = function (props) {
        return function (item) {
            for (var prop in props) {
                if (item[prop] !== props[prop]) {
                    return false;
                }
            }
            return true;
        };
    };
    var onKeyValue = define.eventsProto[canSymbol.for('can.onKeyValue')];
    var offKeyValue = define.eventsProto[canSymbol.for('can.offKeyValue')];
    var DefineList = Construct.extend('DefineList', {
        setup: function (base) {
            if (DefineList) {
                addTypeEvents(this);
                var prototype = this.prototype;
                var result = define(prototype, prototype, base.prototype._define);
                define.makeDefineInstanceKey(this, result);
                var itemsDefinition = result.definitions['#'] || result.defaultDefinition;
                if (itemsDefinition) {
                    if (itemsDefinition.Type) {
                        this.prototype.__type = make.set.Type('*', itemsDefinition.Type, identity);
                    } else if (itemsDefinition.type) {
                        this.prototype.__type = make.set.type('*', itemsDefinition.type, identity);
                    }
                }
            }
        }
    }, {
        setup: function (items) {
            if (!this._define) {
                Object.defineProperty(this, '_define', {
                    enumerable: false,
                    value: {
                        definitions: {
                            length: { type: 'number' },
                            _length: { type: 'number' }
                        }
                    }
                });
                Object.defineProperty(this, '_data', {
                    enumerable: false,
                    value: {}
                });
            }
            define.setup.call(this, {}, false);
            Object.defineProperty(this, '_length', {
                enumerable: false,
                configurable: true,
                writable: true,
                value: 0
            });
            if (items) {
                this.splice.apply(this, [
                    0,
                    0
                ].concat(canReflect.toArray(items)));
            }
        },
        __type: define.types.observable,
        _triggerChange: function (attr, how, newVal, oldVal) {
            var index = +attr;
            if (!isNaN(index)) {
                var itemsDefinition = this._define.definitions['#'];
                var patches;
                if (how === 'add') {
                    if (itemsDefinition && typeof itemsDefinition.added === 'function') {
                        ObservationRecorder.ignore(itemsDefinition.added).call(this, newVal, index);
                    }
                    patches = [{
                            type: 'splice',
                            insert: newVal,
                            index: index,
                            deleteCount: 0
                        }];
                    this.dispatch({
                        type: how,
                        patches: patches
                    }, [
                        newVal,
                        index
                    ]);
                } else if (how === 'remove') {
                    if (itemsDefinition && typeof itemsDefinition.removed === 'function') {
                        ObservationRecorder.ignore(itemsDefinition.removed).call(this, oldVal, index);
                    }
                    patches = [{
                            type: 'splice',
                            index: index,
                            deleteCount: oldVal.length
                        }];
                    this.dispatch({
                        type: how,
                        patches: patches
                    }, [
                        oldVal,
                        index
                    ]);
                } else {
                    this.dispatch(how, [
                        newVal,
                        index
                    ]);
                }
            } else {
                this.dispatch({
                    type: '' + attr,
                    target: this
                }, [
                    newVal,
                    oldVal
                ]);
            }
        },
        get: function (index) {
            if (arguments.length) {
                if (isNaN(index)) {
                    ObservationRecorder.add(this, index);
                } else {
                    ObservationRecorder.add(this, 'length');
                }
                return this[index];
            } else {
                return canReflect.unwrap(this, Map);
            }
        },
        set: function (prop, value) {
            if (typeof prop !== 'object') {
                prop = isNaN(+prop) || prop % 1 ? prop : +prop;
                if (typeof prop === 'number') {
                    if (typeof prop === 'number' && prop > this._length - 1) {
                        var newArr = new Array(prop + 1 - this._length);
                        newArr[newArr.length - 1] = value;
                        this.push.apply(this, newArr);
                        return newArr;
                    }
                    this.splice(prop, 1, value);
                } else {
                    var defined = defineHelpers.defineExpando(this, prop, value);
                    if (!defined) {
                        this[prop] = value;
                    }
                }
            } else {
                if (canReflect.isListLike(prop)) {
                    if (value) {
                        this.replace(prop);
                    } else {
                        canReflect.assignList(this, prop);
                    }
                } else {
                    canReflect.assignMap(this, prop);
                }
            }
            return this;
        },
        assign: function (prop) {
            if (canReflect.isListLike(prop)) {
                canReflect.assignList(this, prop);
            } else {
                canReflect.assignMap(this, prop);
            }
            return this;
        },
        update: function (prop) {
            if (canReflect.isListLike(prop)) {
                canReflect.updateList(this, prop);
            } else {
                canReflect.updateMap(this, prop);
            }
            return this;
        },
        assignDeep: function (prop) {
            if (canReflect.isListLike(prop)) {
                canReflect.assignDeepList(this, prop);
            } else {
                canReflect.assignDeepMap(this, prop);
            }
            return this;
        },
        updateDeep: function (prop) {
            if (canReflect.isListLike(prop)) {
                canReflect.updateDeepList(this, prop);
            } else {
                canReflect.updateDeepMap(this, prop);
            }
            return this;
        },
        _items: function () {
            var arr = [];
            this._each(function (item) {
                arr.push(item);
            });
            return arr;
        },
        _each: function (callback) {
            for (var i = 0, len = this._length; i < len; i++) {
                callback(this[i], i);
            }
        },
        splice: function (index, howMany) {
            var args = makeArray(arguments), added = [], i, len, listIndex, allSame = args.length > 2, oldLength = this._length;
            index = index || 0;
            for (i = 0, len = args.length - 2; i < len; i++) {
                listIndex = i + 2;
                args[listIndex] = this.__type(args[listIndex], listIndex);
                added.push(args[listIndex]);
                if (this[i + index] !== args[listIndex]) {
                    allSame = false;
                }
            }
            if (allSame && this._length <= added.length) {
                return added;
            }
            if (howMany === undefined) {
                howMany = args[1] = this._length - index;
            }
            runningNative = true;
            var removed = splice.apply(this, args);
            runningNative = false;
            queues.batch.start();
            if (howMany > 0) {
                this._triggerChange('' + index, 'remove', undefined, removed);
            }
            if (args.length > 2) {
                this._triggerChange('' + index, 'add', added, removed);
            }
            this.dispatch('length', [
                this._length,
                oldLength
            ]);
            queues.batch.stop();
            return removed;
        },
        serialize: function () {
            return canReflect.serialize(this, Map);
        },
        log: function (key) {
        }
    });
    for (var prop in define.eventsProto) {
        Object.defineProperty(DefineList.prototype, prop, {
            enumerable: false,
            value: define.eventsProto[prop],
            writable: true
        });
    }
    var eventsProtoSymbols = 'getOwnPropertySymbols' in Object ? Object.getOwnPropertySymbols(define.eventsProto) : [
        canSymbol.for('can.onKeyValue'),
        canSymbol.for('can.offKeyValue')
    ];
    eventsProtoSymbols.forEach(function (sym) {
        Object.defineProperty(DefineList.prototype, sym, {
            enumerable: false,
            value: define.eventsProto[sym],
            writable: true
        });
    });
    var getArgs = function (args) {
        return args[0] && Array.isArray(args[0]) ? args[0] : makeArray(args);
    };
    each({
        push: 'length',
        unshift: 0
    }, function (where, name) {
        var orig = [][name];
        DefineList.prototype[name] = function () {
            var args = [], len = where ? this._length : 0, i = arguments.length, res, val;
            while (i--) {
                val = arguments[i];
                args[i] = this.__type(val, i);
            }
            runningNative = true;
            res = orig.apply(this, args);
            runningNative = false;
            if (!this.comparator || args.length) {
                queues.batch.start();
                this._triggerChange('' + len, 'add', args, undefined);
                this.dispatch('length', [
                    this._length,
                    len
                ]);
                queues.batch.stop();
            }
            return res;
        };
    });
    each({
        pop: 'length',
        shift: 0
    }, function (where, name) {
        var orig = [][name];
        DefineList.prototype[name] = function () {
            if (!this._length) {
                return undefined;
            }
            var args = getArgs(arguments), len = where && this._length ? this._length - 1 : 0, oldLength = this._length ? this._length : 0, res;
            runningNative = true;
            res = orig.apply(this, args);
            runningNative = false;
            queues.batch.start();
            this._triggerChange('' + len, 'remove', undefined, [res]);
            this.dispatch('length', [
                this._length,
                oldLength
            ]);
            queues.batch.stop();
            return res;
        };
    });
    each({
        'map': 3,
        'filter': 3,
        'reduce': 4,
        'reduceRight': 4,
        'every': 3,
        'some': 3
    }, function a(fnLength, fnName) {
        DefineList.prototype[fnName] = function () {
            var self = this;
            var args = [].slice.call(arguments, 0);
            var callback = args[0];
            var thisArg = args[fnLength - 1] || self;
            if (typeof callback === 'object') {
                callback = makeFilterCallback(callback);
            }
            args[0] = function () {
                var cbArgs = [].slice.call(arguments, 0);
                cbArgs[fnLength - 3] = self.get(cbArgs[fnLength - 2]);
                return callback.apply(thisArg, cbArgs);
            };
            var ret = Array.prototype[fnName].apply(this, args);
            if (fnName === 'map') {
                return new DefineList(ret);
            } else if (fnName === 'filter') {
                return new self.constructor(ret);
            } else {
                return ret;
            }
        };
    });
    assign(DefineList.prototype, {
        indexOf: function (item, fromIndex) {
            for (var i = fromIndex || 0, len = this.length; i < len; i++) {
                if (this.get(i) === item) {
                    return i;
                }
            }
            return -1;
        },
        lastIndexOf: function (item, fromIndex) {
            fromIndex = typeof fromIndex === 'undefined' ? this.length - 1 : fromIndex;
            for (var i = fromIndex; i >= 0; i--) {
                if (this.get(i) === item) {
                    return i;
                }
            }
            return -1;
        },
        join: function () {
            ObservationRecorder.add(this, 'length');
            return [].join.apply(this, arguments);
        },
        reverse: function () {
            var list = [].reverse.call(this._items());
            return this.replace(list);
        },
        slice: function () {
            ObservationRecorder.add(this, 'length');
            var temp = Array.prototype.slice.apply(this, arguments);
            return new this.constructor(temp);
        },
        concat: function () {
            var args = [];
            each(arguments, function (arg) {
                if (canReflect.isListLike(arg)) {
                    var arr = Array.isArray(arg) ? arg : makeArray(arg);
                    arr.forEach(function (innerArg) {
                        args.push(this.__type(innerArg));
                    }, this);
                } else {
                    args.push(this.__type(arg));
                }
            }, this);
            return new this.constructor(Array.prototype.concat.apply(makeArray(this), args));
        },
        forEach: function (cb, thisarg) {
            var item;
            for (var i = 0, len = this.length; i < len; i++) {
                item = this.get(i);
                if (cb.call(thisarg || item, item, i, this) === false) {
                    break;
                }
            }
            return this;
        },
        replace: function (newList) {
            var patches = diff(this, newList);
            queues.batch.start();
            for (var i = 0, len = patches.length; i < len; i++) {
                this.splice.apply(this, [
                    patches[i].index,
                    patches[i].deleteCount
                ].concat(patches[i].insert));
            }
            queues.batch.stop();
            return this;
        },
        sort: function (compareFunction) {
            var removed = Array.prototype.slice.call(this);
            Array.prototype.sort.call(this, compareFunction);
            var added = Array.prototype.slice.call(this);
            queues.batch.start();
            this.dispatch('remove', [
                removed,
                0
            ]);
            this.dispatch('add', [
                added,
                0
            ]);
            this.dispatch('length', [
                this._length,
                this._length
            ]);
            queues.batch.stop();
            return this;
        }
    });
    for (var prop in define.eventsProto) {
        DefineList[prop] = define.eventsProto[prop];
        Object.defineProperty(DefineList.prototype, prop, {
            enumerable: false,
            value: define.eventsProto[prop],
            writable: true
        });
    }
    Object.defineProperty(DefineList.prototype, 'length', {
        get: function () {
            if (!this.__inSetup) {
                ObservationRecorder.add(this, 'length');
            }
            return this._length;
        },
        set: function (newVal) {
            if (runningNative) {
                this._length = newVal;
                return;
            }
            if (newVal == null || isNaN(+newVal) || newVal === this._length) {
                return;
            }
            if (newVal > this._length - 1) {
                var newArr = new Array(newVal - this._length);
                this.push.apply(this, newArr);
            } else {
                this.splice(newVal);
            }
        },
        enumerable: true
    });
    DefineList.prototype.attr = function (prop, value) {
        canLog.warn('DefineMap::attr shouldn\'t be called');
        if (arguments.length === 0) {
            return this.get();
        } else if (prop && typeof prop === 'object') {
            return this.set.apply(this, arguments);
        } else if (arguments.length === 1) {
            return this.get(prop);
        } else {
            return this.set(prop, value);
        }
    };
    DefineList.prototype.item = function (index, value) {
        if (arguments.length === 1) {
            return this.get(index);
        } else {
            return this.set(index, value);
        }
    };
    DefineList.prototype.items = function () {
        canLog.warn('DefineList::get should should be used instead of DefineList::items');
        return this.get();
    };
    canReflect.assignSymbols(DefineList.prototype, {
        'can.isMoreListLikeThanMapLike': true,
        'can.isMapLike': true,
        'can.isListLike': true,
        'can.isValueLike': false,
        'can.getKeyValue': DefineList.prototype.get,
        'can.setKeyValue': DefineList.prototype.set,
        'can.onKeyValue': function (key, handler, queue) {
            var translationHandler;
            if (isNaN(key)) {
                return onKeyValue.apply(this, arguments);
            } else {
                translationHandler = function () {
                    handler(this[key]);
                };
                singleReference.set(handler, this, translationHandler, key);
                return onKeyValue.call(this, 'length', translationHandler, queue);
            }
        },
        'can.offKeyValue': function (key, handler, queue) {
            var translationHandler;
            if (isNaN(key)) {
                return offKeyValue.apply(this, arguments);
            } else {
                translationHandler = singleReference.getAndDelete(handler, this, key);
                return offKeyValue.call(this, 'length', translationHandler, queue);
            }
        },
        'can.deleteKeyValue': function (prop) {
            prop = isNaN(+prop) || prop % 1 ? prop : +prop;
            if (typeof prop === 'number') {
                this.splice(prop, 1);
            } else if (prop === 'length' || prop === '_length') {
                return;
            } else {
                this.set(prop, undefined);
            }
            return this;
        },
        'can.assignDeep': function (source) {
            queues.batch.start();
            canReflect.assignList(this, source);
            queues.batch.stop();
        },
        'can.updateDeep': function (source) {
            queues.batch.start();
            this.replace(source);
            queues.batch.stop();
        },
        'can.keyHasDependencies': function (key) {
            return !!(this._computed && this._computed[key] && this._computed[key].compute);
        },
        'can.getKeyDependencies': function (key) {
            var ret;
            if (this._computed && this._computed[key] && this._computed[key].compute) {
                ret = {};
                ret.valueDependencies = new Set([this._computed[key].compute]);
            }
            return ret;
        },
        'can.splice': function (index, deleteCount, insert) {
            this.splice.apply(this, [
                index,
                deleteCount
            ].concat(insert));
        },
        'can.onPatches': function (handler, queue) {
            this[canSymbol.for('can.onKeyValue')](localOnPatchesSymbol, handler, queue);
        },
        'can.offPatches': function (handler, queue) {
            this[canSymbol.for('can.offKeyValue')](localOnPatchesSymbol, handler, queue);
        }
    });
    canReflect.setKeyValue(DefineList.prototype, canSymbol.iterator, function () {
        var index = -1;
        if (typeof this._length !== 'number') {
            this._length = 0;
        }
        return {
            next: function () {
                index++;
                return {
                    value: this[index],
                    done: index >= this._length
                };
            }.bind(this)
        };
    });
    define.DefineList = DefineList;
    module.exports = ns.DefineList = DefineList;
});
/*can-observe@2.0.1#src/-symbols*/
define('can-observe@2.0.1#src/-symbols', [
    'require',
    'exports',
    'module',
    'can-symbol'
], function (require, exports, module) {
    var canSymbol = require('can-symbol');
    module.exports = {
        metaSymbol: canSymbol.for('can.meta'),
        patchesSymbol: 'can.patches',
        keysSymbol: 'can.keys'
    };
});
/*can-observe@2.0.1#src/-observable-store*/
define('can-observe@2.0.1#src/-observable-store', function (require, exports, module) {
    module.exports = {
        proxiedObjects: new WeakMap(),
        proxies: new WeakSet()
    };
});
/*can-observe@2.0.1#src/-helpers*/
define('can-observe@2.0.1#src/-helpers', [
    'require',
    'exports',
    'module',
    'can-symbol'
], function (require, exports, module) {
    var canSymbol = require('can-symbol');
    var metaSymbol = canSymbol.for('can.meta');
    var definitionsSymbol = canSymbol.for('can.typeDefinitions');
    var classTest = /^\s*class\s+/;
    var helpers = {
        assignEverything: function (d, s) {
            Object.getOwnPropertyNames(s).concat(Object.getOwnPropertySymbols(s)).forEach(function (key) {
                Object.defineProperty(d, key, Object.getOwnPropertyDescriptor(s, key));
            });
            return d;
        },
        isBuiltInButNotArrayOrPlainObject: function (obj) {
            if (Array.isArray(obj)) {
                return false;
            }
            if (typeof obj === 'function') {
                var fnCode = obj.toString();
                if (fnCode.indexOf('[native code]') > 0) {
                    return true;
                } else {
                    return false;
                }
            } else {
                var toString = Object.prototype.toString.call(obj);
                return toString !== '[object Object]' && toString.indexOf('[object ') !== -1;
            }
        },
        inheritsFromArray: function (obj) {
            var cur = obj;
            do {
                if (Array.isArray(cur)) {
                    return true;
                }
                cur = Object.getPrototypeOf(cur);
            } while (cur);
            return false;
        },
        isClass: function (obj) {
            return typeof obj === 'function' && classTest.test(obj.toString());
        },
        supportsClass: function () {
            try {
                eval('"use strict"; class A{};');
                return true;
            } catch (e) {
                return false;
            }
        }(),
        makeSimpleExtender: function (BaseType) {
            return function etend(name, staticProps, prototypeProps) {
                var Type = function () {
                    var source = this;
                    var instance = BaseType.apply(this, arguments);
                    if (source.init) {
                        instance[metaSymbol].preventSideEffects++;
                        source.init.apply(instance, arguments);
                        instance[metaSymbol].preventSideEffects--;
                    }
                    return instance;
                };
                helpers.assignEverything(Type, BaseType);
                helpers.assignEverything(Type, staticProps || {});
                Type.prototype = Object.create(BaseType.prototype);
                helpers.assignEverything(Type.prototype, prototypeProps || {});
                Type.prototype.constructor = Type;
                Type.prototype[definitionsSymbol] = Object.create(BaseType.prototype[definitionsSymbol] || null);
                return Type;
            };
        }
    };
    module.exports = helpers;
});
/*can-observe@2.0.1#src/-add-get-key-dependencies*/
define('can-observe@2.0.1#src/-add-get-key-dependencies', [
    'require',
    'exports',
    'module',
    'can-symbol'
], function (require, exports, module) {
    var canSymbol = require('can-symbol');
    var getKeyDependenciesSymbol = canSymbol.for('can.getKeyDependencies');
    var computedDefinitionsSymbol = canSymbol.for('can.computedDefinitions');
    module.exports = function addGetterKeyDependencies(obj) {
        obj[getKeyDependenciesSymbol] = function getKeyDependencies(key) {
            var computed = this[computedDefinitionsSymbol];
            if (computed) {
                var getObservation = computed[key];
                var observationData = getObservation && getObservation(this);
                if (observationData != null) {
                    return { valueDependencies: new Set([observationData.observation]) };
                }
            }
        };
        return obj;
    };
});
/*can-observe@2.0.1#src/-make-object*/
define('can-observe@2.0.1#src/-make-object', [
    'require',
    'exports',
    'module',
    'can-reflect',
    'can-observation-recorder',
    'can-event-queue/map/map',
    './-symbols',
    './-observable-store',
    './-helpers',
    './-add-get-key-dependencies'
], function (require, exports, module) {
    var canReflect = require('can-reflect');
    var ObservationRecorder = require('can-observation-recorder');
    var mapBindings = require('can-event-queue/map/map');
    var symbols = require('./-symbols');
    var observableStore = require('./-observable-store');
    var helpers = require('./-helpers');
    var addGetterKeyDependencies = require('./-add-get-key-dependencies');
    var hasOwn = Object.prototype.hasOwnProperty;
    var isSymbolLike = canReflect.isSymbolLike;
    var proxyKeys = Object.create(null);
    Object.getOwnPropertySymbols(mapBindings).forEach(function (symbol) {
        proxyKeys[symbol] = mapBindings[symbol];
    });
    addGetterKeyDependencies(proxyKeys);
    var makeObject = {
        observable: function (object, options) {
            if (options.shouldRecordObservation === undefined) {
                options.shouldRecordObservation = makeObject.shouldRecordObservationOnOwnAndMissingKeys;
            }
            var meta = {
                target: object,
                proxyKeys: options.proxyKeys !== undefined ? options.proxyKeys : Object.create(makeObject.proxyKeys()),
                options: options,
                preventSideEffects: 0
            };
            meta.proxyKeys[symbols.metaSymbol] = meta;
            meta.proxy = new Proxy(object, {
                get: makeObject.get.bind(meta),
                set: makeObject.set.bind(meta),
                ownKeys: makeObject.ownKeys.bind(meta),
                deleteProperty: makeObject.deleteProperty.bind(meta),
                meta: meta
            });
            mapBindings.addHandlers(meta.proxy, meta);
            return meta.proxy;
        },
        proxyKeys: function () {
            return proxyKeys;
        },
        get: function (target, key, receiver) {
            var proxyKey = this.proxyKeys[key];
            if (proxyKey !== undefined) {
                return proxyKey;
            }
            if (isSymbolLike(key)) {
                return target[key];
            }
            var keyInfo = makeObject.getKeyInfo(target, key, receiver, this);
            var value = keyInfo.targetValue;
            if (!keyInfo.valueIsInvariant) {
                value = makeObject.getValueFromStore(key, value, this);
            }
            if (this.options.shouldRecordObservation(keyInfo, this)) {
                ObservationRecorder.add(this.proxy, key.toString());
            }
            if (keyInfo.parentObservableGetCalledOn) {
                ObservationRecorder.add(keyInfo.parentObservableGetCalledOn, key.toString());
            }
            return value;
        },
        set: function (target, key, value, receiver) {
            if (receiver !== this.proxy) {
                return makeObject.setKey(receiver, key, value, this);
            }
            value = makeObject.getValueToSet(key, value, this);
            makeObject.setValueAndOnChange(key, value, this, function (key, value, meta, hadOwn, old) {
                mapBindings.dispatch.call(meta.proxy, {
                    type: key,
                    patches: [{
                            key: key,
                            type: hadOwn ? 'set' : 'add',
                            value: value
                        }],
                    keyChanged: !hadOwn ? key : undefined
                }, [
                    value,
                    old
                ]);
            });
            return true;
        },
        deleteProperty: function (target, key) {
            var old = this.target[key], deleteSuccessful = delete this.target[key];
            if (deleteSuccessful && this.preventSideEffects === 0 && old !== undefined) {
                mapBindings.dispatch.call(this.proxy, {
                    type: key,
                    patches: [{
                            key: key,
                            type: 'delete'
                        }],
                    keyChanged: key
                }, [
                    undefined,
                    old
                ]);
            }
            return deleteSuccessful;
        },
        ownKeys: function (target, key) {
            ObservationRecorder.add(this.proxy, symbols.keysSymbol);
            return Object.getOwnPropertyNames(this.target).concat(Object.getOwnPropertySymbols(this.target)).concat(Object.getOwnPropertySymbols(this.proxyKeys));
        },
        getKeyInfo: function (target, key, receiver, meta) {
            var descriptor = Object.getOwnPropertyDescriptor(target, key);
            var propertyInfo = {
                key: key,
                descriptor: descriptor,
                targetHasOwnKey: Boolean(descriptor),
                getCalledOnParent: receiver !== meta.proxy,
                protoHasKey: false,
                valueIsInvariant: false,
                targetValue: undefined,
                isAccessor: false
            };
            if (propertyInfo.getCalledOnParent === true) {
                propertyInfo.parentObservableGetCalledOn = observableStore.proxiedObjects.get(receiver);
            }
            if (descriptor !== undefined) {
                propertyInfo.valueIsInvariant = descriptor.writable === false;
                if (descriptor.get !== undefined) {
                    propertyInfo.targetValue = descriptor.get.call(propertyInfo.parentObservableGetCalledOn || receiver);
                    propertyInfo.isAccessor = true;
                } else {
                    propertyInfo.targetValue = descriptor.value;
                }
            } else {
                propertyInfo.targetValue = meta.target[key];
                propertyInfo.protoHasKey = propertyInfo.targetValue !== undefined ? true : key in target;
            }
            return propertyInfo;
        },
        shouldRecordObservationOnOwnAndMissingKeys: function (keyInfo, meta) {
            return meta.preventSideEffects === 0 && !keyInfo.isAccessor && (keyInfo.targetHasOwnKey || !keyInfo.protoHasKey && !Object.isSealed(meta.target));
        },
        setKey: function (receiver, key, value) {
            Object.defineProperty(receiver, key, {
                value: value,
                configurable: true,
                enumerable: true,
                writable: true
            });
            return true;
        },
        getValueToSet: function (key, value, meta) {
            if (!canReflect.isSymbolLike(key) && meta.handlers.getNode([key])) {
                return makeObject.getValueFromStore(key, value, meta);
            }
            return value;
        },
        getValueFromStore: function (key, value, meta) {
            if (!canReflect.isPrimitive(value) && !canReflect.isObservableLike(value) && !observableStore.proxies.has(value)) {
                if (observableStore.proxiedObjects.has(value)) {
                    value = observableStore.proxiedObjects.get(value);
                } else if (!helpers.isBuiltInButNotArrayOrPlainObject(value)) {
                    value = meta.options.observe(value);
                }
            }
            return value;
        },
        setValueAndOnChange: function (key, value, data, onChange) {
            var old, change;
            var hadOwn = hasOwn.call(data.target, key);
            var descriptor = Object.getOwnPropertyDescriptor(data.target, key);
            if (descriptor && descriptor.set) {
                descriptor.set.call(data.proxy, value);
            } else {
                old = data.target[key];
                change = old !== value;
                if (change) {
                    data.target[key] = value;
                    if (data.preventSideEffects === 0) {
                        onChange(key, value, data, hadOwn, old);
                    }
                }
            }
        }
    };
    module.exports = makeObject;
});
/*can-observe@2.0.1#src/-make-array*/
define('can-observe@2.0.1#src/-make-array', [
    'require',
    'exports',
    'module',
    'can-observation-recorder',
    'can-event-queue/map/map',
    'can-reflect',
    './-make-object',
    './-symbols',
    './-observable-store',
    './-helpers'
], function (require, exports, module) {
    var ObservationRecorder = require('can-observation-recorder');
    var mapBindings = require('can-event-queue/map/map');
    var canReflect = require('can-reflect');
    var makeObject = require('./-make-object');
    var symbols = require('./-symbols');
    var observableStore = require('./-observable-store');
    var helpers = require('./-helpers');
    var isInteger = Number.isInteger || function (value) {
        return typeof value === 'number' && isFinite(value) && Math.floor(value) === value;
    };
    function didLengthChangeCauseDeletions(key, value, old) {
        return key === 'length' && value < old;
    }
    var mutateMethods = {
        'push': function (arr, args) {
            return [{
                    index: arr.length - args.length,
                    deleteCount: 0,
                    insert: args,
                    type: 'splice'
                }];
        },
        'pop': function (arr) {
            return [{
                    index: arr.length,
                    deleteCount: 1,
                    insert: [],
                    type: 'splice'
                }];
        },
        'shift': function () {
            return [{
                    index: 0,
                    deleteCount: 1,
                    insert: [],
                    type: 'splice'
                }];
        },
        'unshift': function (arr, args) {
            return [{
                    index: 0,
                    deleteCount: 0,
                    insert: args,
                    type: 'splice'
                }];
        },
        'splice': function (arr, args) {
            return [{
                    index: args[0],
                    deleteCount: args[1],
                    insert: args.slice(2),
                    type: 'splice'
                }];
        },
        'sort': function (arr) {
            return [{
                    index: 0,
                    deleteCount: arr.length,
                    insert: arr,
                    type: 'splice'
                }];
        },
        'reverse': function (arr, args, old) {
            return [{
                    index: 0,
                    deleteCount: arr.length,
                    insert: arr,
                    type: 'splice'
                }];
        }
    };
    canReflect.eachKey(mutateMethods, function (makePatches, prop) {
        var protoFn = Array.prototype[prop];
        var mutateMethod = function () {
            var meta = this[symbols.metaSymbol], makeSideEffects = meta.preventSideEffects === 0, oldLength = meta.target.length;
            meta.preventSideEffects++;
            var ret = protoFn.apply(meta.target, arguments);
            var patches = makePatches(meta.target, Array.from(arguments), oldLength);
            if (makeSideEffects === true) {
                mapBindings.dispatch.call(meta.proxy, {
                    type: 'length',
                    patches: patches
                }, [
                    meta.target.length,
                    oldLength
                ]);
            }
            meta.preventSideEffects--;
            return ret;
        };
        observableStore.proxiedObjects.set(protoFn, mutateMethod);
        observableStore.proxies.add(mutateMethod);
    });
    Object.getOwnPropertyNames(Array.prototype).forEach(function (prop) {
        var protoFn = Array.prototype[prop];
        if (observableStore.proxiedObjects.has(protoFn)) {
            return;
        }
        if (prop !== 'constructor' && typeof protoFn === 'function') {
            var arrayMethod = function () {
                ObservationRecorder.add(this, symbols.patchesSymbol);
                var meta = this[symbols.metaSymbol];
                meta.preventSideEffects++;
                var ret = protoFn.apply(this, arguments);
                meta.preventSideEffects--;
                return meta.options.observe(ret);
            };
            observableStore.proxiedObjects.set(protoFn, arrayMethod);
            observableStore.proxies.add(arrayMethod);
        }
    });
    var proxyKeys = helpers.assignEverything(Object.create(null), makeObject.proxyKeys());
    var makeArray = {
        observable: function (array, options) {
            if (options.shouldRecordObservation === undefined) {
                options.shouldRecordObservation = makeObject.shouldRecordObservationOnOwnAndMissingKeys;
            }
            var meta = {
                target: array,
                proxyKeys: options.proxyKeys !== undefined ? options.proxyKeys : Object.create(makeArray.proxyKeys()),
                options: options,
                preventSideEffects: 0
            };
            meta.proxyKeys[symbols.metaSymbol] = meta;
            meta.proxy = new Proxy(array, {
                get: makeObject.get.bind(meta),
                set: makeArray.set.bind(meta),
                ownKeys: makeObject.ownKeys.bind(meta),
                deleteProperty: makeObject.deleteProperty.bind(meta),
                meta: meta
            });
            mapBindings.addHandlers(meta.proxy, meta);
            return meta.proxy;
        },
        proxyKeys: function () {
            return proxyKeys;
        },
        set: function (target, key, value, receiver) {
            if (receiver !== this.proxy) {
                return makeObject.setKey(receiver, key, value, this);
            }
            value = makeObject.getValueToSet(key, value, this);
            var startingLength = target.length;
            makeObject.setValueAndOnChange(key, value, this, function (key, value, meta, hadOwn, old) {
                var patches = [{
                        key: key,
                        type: hadOwn ? 'set' : 'add',
                        value: value
                    }];
                var numberKey = +key;
                if (isInteger(numberKey)) {
                    if (!hadOwn && numberKey > startingLength) {
                        patches.push({
                            index: startingLength,
                            deleteCount: 0,
                            insert: target.slice(startingLength),
                            type: 'splice'
                        });
                    } else {
                        patches.push.apply(patches, mutateMethods.splice(target, [
                            numberKey,
                            1,
                            value
                        ]));
                    }
                }
                if (didLengthChangeCauseDeletions(key, value, old, meta)) {
                    patches.push({
                        index: value,
                        deleteCount: old - value,
                        insert: [],
                        type: 'splice'
                    });
                }
                mapBindings.dispatch.call(meta.proxy, {
                    type: key,
                    patches: patches,
                    keyChanged: !hadOwn ? key : undefined
                }, [
                    value,
                    old
                ]);
            });
            return true;
        }
    };
    module.exports = makeArray;
});
/*can-observe@2.0.1#src/-make-function*/
define('can-observe@2.0.1#src/-make-function', [
    'require',
    'exports',
    'module',
    'can-reflect',
    './-make-object',
    './-symbols',
    './-observable-store',
    'can-event-queue/map/map',
    'can-event-queue/type/type',
    './-helpers'
], function (require, exports, module) {
    var canReflect = require('can-reflect');
    var makeObject = require('./-make-object');
    var symbols = require('./-symbols');
    var observableStore = require('./-observable-store');
    var mapBindings = require('can-event-queue/map/map');
    var typeBindings = require('can-event-queue/type/type');
    var helpers = require('./-helpers');
    var proxyKeys = helpers.assignEverything(Object.create(null), makeObject.proxyKeys());
    typeBindings(proxyKeys);
    canReflect.assignSymbols(proxyKeys, {
        'can.defineInstanceKey': function (prop, value) {
            this[symbols.metaSymbol].definitions[prop] = value;
        }
    });
    var makeFunction = {
        observable: function (object, options) {
            if (options.shouldRecordObservation === undefined) {
                options.shouldRecordObservation = makeObject.shouldRecordObservationOnOwnAndMissingKeys;
            }
            var proxyKeys = Object.create(makeFunction.proxyKeys());
            var meta = {
                target: object,
                proxyKeys: proxyKeys,
                options: options,
                definitions: {},
                isClass: helpers.isClass(object),
                preventSideEffects: 0
            };
            proxyKeys[symbols.metaSymbol] = meta;
            meta.proxy = new Proxy(object, {
                get: makeObject.get.bind(meta),
                set: makeObject.set.bind(meta),
                ownKeys: makeObject.ownKeys.bind(meta),
                deleteProperty: makeObject.deleteProperty.bind(meta),
                construct: makeFunction.construct.bind(meta),
                apply: makeFunction.apply.bind(meta),
                meta: meta
            });
            mapBindings.addHandlers(meta.proxy, meta);
            typeBindings.addHandlers(meta.proxy, meta);
            observableStore.proxiedObjects.set(object, meta.proxy);
            observableStore.proxies.add(meta.proxy);
            if (meta.target.prototype && meta.target.prototype.constructor === meta.target) {
                var prototype = meta.proxy.prototype;
                prototype.constructor = meta.proxy;
            }
            return meta.proxy;
        },
        construct: function (target, argumentsList, newTarget) {
            var instanceTarget, key;
            if (this.isClass) {
                instanceTarget = Reflect.construct(target, argumentsList, newTarget);
                for (key in this.definitions) {
                    Object.defineProperty(instanceTarget, key, this.definitions[key]);
                }
                return this.options.observe(instanceTarget);
            } else {
                instanceTarget = Object.create(this.proxy.prototype);
                for (key in this.definitions) {
                    Object.defineProperty(instanceTarget, key, this.definitions[key]);
                }
                var instance = this.options.observe(instanceTarget);
                instance[symbols.metaSymbol].preventSideEffects++;
                var res = target.apply(instance, argumentsList);
                instance[symbols.metaSymbol].preventSideEffects--;
                if (res) {
                    return res;
                } else {
                    return instance;
                }
            }
        },
        apply: function (target, thisArg, argumentsList) {
            var ret = this.target.apply(thisArg, argumentsList);
            return this.options.observe(ret);
        },
        proxyKeys: function () {
            return proxyKeys;
        }
    };
    module.exports = makeFunction;
});
/*can-observe@2.0.1#src/-make-observe*/
define('can-observe@2.0.1#src/-make-observe', [
    'require',
    'exports',
    'module',
    'can-reflect',
    './-observable-store',
    './-helpers'
], function (require, exports, module) {
    var canReflect = require('can-reflect');
    var observables = require('./-observable-store');
    var helpers = require('./-helpers');
    var makeObserve = {
        observe: function (value) {
            if (canReflect.isPrimitive(value)) {
                return value;
            }
            var observable = observables.proxiedObjects.get(value);
            if (observable) {
                return observable;
            }
            if (observables.proxies.has(value)) {
                return value;
            }
            if (helpers.isBuiltInButNotArrayOrPlainObject(value)) {
                return value;
            }
            if (typeof value === 'function') {
                observable = makeObserve.function(value);
            } else if (helpers.inheritsFromArray(value)) {
                observable = makeObserve.array(value);
            } else {
                observable = makeObserve.object(value);
            }
            observables.proxiedObjects.set(value, observable);
            observables.proxies.add(observable);
            return observable;
        },
        'object': null,
        'array': null,
        'function': null
    };
    module.exports = makeObserve;
});
/*can-observe@2.0.1#src/-memoize-getter*/
define('can-observe@2.0.1#src/-memoize-getter', [
    'require',
    'exports',
    'module',
    'can-observation',
    'can-observation-recorder',
    './-observable-store'
], function (require, exports, module) {
    var Observation = require('can-observation');
    var ObservationRecorder = require('can-observation-recorder');
    var observableStore = require('./-observable-store');
    function MemoizedGetterObservationData(instance, prop, getter) {
        this.prop = prop;
        this.instance = instance;
        this.forward = this.forward.bind(this);
        this.observation = new Observation(getter, instance, { isObservable: false });
    }
    MemoizedGetterObservationData.prototype.bind = function (observationData) {
        this.bindingCount++;
        if (this.bindingCount === 1) {
            this.observation.on(this.forward, 'notify');
        }
    };
    MemoizedGetterObservationData.prototype.unbind = function (observationData) {
        this.bindingCount--;
        if (this.bindingCount === 0) {
            this.observation.off(this.forward, 'notify');
        }
    };
    MemoizedGetterObservationData.prototype.forward = function (newValue, oldValue) {
        this.instance.dispatch({
            type: this.prop,
            target: this.instance
        }, [
            newValue,
            oldValue
        ]);
    };
    MemoizedGetterObservationData.prototype.bindingCount = 0;
    module.exports = function memoize(Type, prop, definition) {
        var instanceToObservationData = new WeakMap();
        function getObservationDataFor(instance) {
            var observationData = instanceToObservationData.get(instance);
            if (!observationData) {
                observationData = new MemoizedGetterObservationData(instance, prop, definition.get);
                instanceToObservationData.set(instance, observationData);
            }
            return observationData;
        }
        Object.defineProperty(Type, prop, {
            enumerable: definition.enumerable,
            get: function memoized() {
                var instance = observableStore.proxiedObjects.get(this) || this;
                var observationData = getObservationDataFor(instance);
                ObservationRecorder.add(instance, prop.toString());
                if (!observationData.observation.bound && ObservationRecorder.isRecording()) {
                    Observation.temporarilyBind(observationData.observation);
                }
                return observationData.observation.get();
            }
        });
        return getObservationDataFor;
    };
});
/*can-observe@2.0.1#src/-getter-helpers*/
define('can-observe@2.0.1#src/-getter-helpers', [
    'require',
    'exports',
    'module',
    'can-symbol',
    'can-event-queue/type/type',
    'can-reflect',
    './-memoize-getter',
    'can-queues',
    'can-event-queue/map/map'
], function (require, exports, module) {
    var canSymbol = require('can-symbol');
    var definitionsSymbol = canSymbol.for('can.typeDefinitions');
    var typeEventMixin = require('can-event-queue/type/type');
    var canReflect = require('can-reflect');
    var memoizeGetter = require('./-memoize-getter');
    var queues = require('can-queues');
    var eventMixin = require('can-event-queue/map/map');
    var computedDefinitionsSymbol = canSymbol.for('can.computedDefinitions');
    var metaSymbol = canSymbol.for('can.meta');
    var getterHelpers = {
        ensureTypeDefinition: function (obj) {
            var typeDefs = obj.prototype[definitionsSymbol];
            if (!typeDefs) {
                typeDefs = obj.prototype[definitionsSymbol] = Object.create(null);
            }
            return typeDefs;
        },
        shouldRecordObservationOnAllKeysExceptFunctionsOnProto: function (keyInfo, meta) {
            return meta.preventSideEffects === 0 && !keyInfo.isAccessor && (keyInfo.targetHasOwnKey || !keyInfo.protoHasKey && !Object.isSealed(meta.target) || keyInfo.protoHasKey && typeof targetValue !== 'function');
        },
        addMethodsAndSymbols: function (Type) {
            typeEventMixin(Type);
            canReflect.assignSymbols(Type, {
                'can.defineInstanceKey': function (prop, value) {
                    getterHelpers.ensureTypeDefinition(this)[prop] = value;
                },
                'can.dispatchInstanceBoundChange': function (obj, isBound) {
                    var meta = this[metaSymbol];
                    if (meta) {
                        var lifecycleHandlers = meta.lifecycleHandlers;
                        if (lifecycleHandlers) {
                            queues.enqueueByQueue(lifecycleHandlers.getNode([]), this, [
                                obj,
                                isBound
                            ]);
                        }
                    }
                }
            });
            Type.prototype.addEventListener = function (key, handler, queue) {
                var getObservation = this[computedDefinitionsSymbol][key];
                if (getObservation !== undefined) {
                    getObservation(this).bind();
                }
                return eventMixin.addEventListener.call(this, key, handler, queue);
            };
            Type.prototype.removeEventListener = function (key, handler, queue) {
                var getObservation = this[computedDefinitionsSymbol][key];
                if (getObservation !== undefined) {
                    getObservation(this).unbind();
                }
                return eventMixin.removeEventListener.call(this, key, handler, queue);
            };
        },
        setupComputedProperties: function (prototype) {
            var computed = {};
            Object.getOwnPropertyNames(prototype).forEach(function (prop) {
                var descriptor = Object.getOwnPropertyDescriptor(prototype, prop);
                if (descriptor.get !== undefined) {
                    var getObservationData = memoizeGetter(prototype, prop, descriptor);
                    computed[prop] = getObservationData;
                }
            });
            return computed;
        },
        addMemoizedGetterBindings: function (proxyKeys) {
            return canReflect.assignSymbols(proxyKeys, {
                'can.onKeyValue': function (key, handler, queue) {
                    var getObservation = this[computedDefinitionsSymbol][key];
                    if (getObservation !== undefined) {
                        getObservation(this).bind();
                    }
                    var handlers = this[metaSymbol].handlers;
                    handlers.add([
                        key,
                        'onKeyValue',
                        queue || 'notify',
                        handler
                    ]);
                },
                'can.offKeyValue': function (key, handler, queue) {
                    var getObservation = this[computedDefinitionsSymbol][key];
                    if (getObservation !== undefined) {
                        getObservation(this).unbind();
                    }
                    var handlers = this[metaSymbol].handlers;
                    handlers.delete([
                        key,
                        'onKeyValue',
                        queue || 'notify',
                        handler
                    ]);
                }
            });
        }
    };
    module.exports = getterHelpers;
});
/*can-observe@2.0.1#object/object*/
define('can-observe@2.0.1#object/object', [
    'require',
    'exports',
    'module',
    'can-reflect',
    'can-symbol',
    '../src/-make-observe',
    'can-event-queue/map/map',
    '../src/-helpers',
    '../src/-make-object',
    '../src/-observable-store',
    '../src/-getter-helpers'
], function (require, exports, module) {
    var canReflect = require('can-reflect');
    var canSymbol = require('can-symbol');
    var makeObserve = require('../src/-make-observe');
    var eventMixin = require('can-event-queue/map/map');
    var helpers = require('../src/-helpers');
    var makeObject = require('../src/-make-object');
    var observableStore = require('../src/-observable-store');
    var definitionsSymbol = canSymbol.for('can.typeDefinitions');
    var getterHelpers = require('../src/-getter-helpers');
    var computedDefinitionsSymbol = canSymbol.for('can.computedDefinitions');
    var proxyKeys = helpers.assignEverything({}, makeObject.proxyKeys());
    getterHelpers.addMemoizedGetterBindings(proxyKeys);
    var ObserveObject = function (props) {
        var prototype = Object.getPrototypeOf(this);
        if (prototype[computedDefinitionsSymbol] === undefined) {
            prototype[computedDefinitionsSymbol] = getterHelpers.setupComputedProperties(prototype);
        }
        var sourceInstance = this;
        var definitions = prototype[definitionsSymbol] || {};
        for (var key in definitions) {
            Object.defineProperty(sourceInstance, key, definitions[key]);
        }
        if (props !== undefined) {
            canReflect.assign(sourceInstance, props);
        }
        var localProxyKeys = Object.create(proxyKeys);
        localProxyKeys.constructor = this.constructor;
        var observable = makeObject.observable(sourceInstance, {
            observe: makeObserve.observe,
            proxyKeys: localProxyKeys,
            shouldRecordObservation: getterHelpers.shouldRecordObservationOnAllKeysExceptFunctionsOnProto
        });
        observableStore.proxiedObjects.set(sourceInstance, observable);
        observableStore.proxies.add(observable);
        return observable;
    };
    eventMixin(ObserveObject.prototype);
    getterHelpers.addMethodsAndSymbols(ObserveObject);
    ObserveObject.extend = helpers.makeSimpleExtender(ObserveObject);
    module.exports = ObserveObject;
});
/*can-observe@2.0.1#array/array*/
define('can-observe@2.0.1#array/array', [
    'require',
    'exports',
    'module',
    'can-symbol',
    '../src/-make-array',
    '../src/-make-observe',
    'can-event-queue/map/map',
    '../src/-helpers',
    '../src/-observable-store',
    '../src/-getter-helpers'
], function (require, exports, module) {
    var canSymbol = require('can-symbol');
    var makeArray = require('../src/-make-array');
    var makeObserve = require('../src/-make-observe');
    var eventMixin = require('can-event-queue/map/map');
    var helpers = require('../src/-helpers');
    var observableStore = require('../src/-observable-store');
    var getterHelpers = require('../src/-getter-helpers');
    var definitionsSymbol = canSymbol.for('can.typeDefinitions');
    var computedDefinitionsSymbol = canSymbol.for('can.computedDefinitions');
    var proxyKeys = helpers.assignEverything({}, makeArray.proxyKeys());
    getterHelpers.addMemoizedGetterBindings(proxyKeys);
    var ObserveArray;
    if (false) {
    } else {
        var ObserveArray = function (items) {
            var prototype = Object.getPrototypeOf(this);
            if (prototype[computedDefinitionsSymbol] === undefined) {
                prototype[computedDefinitionsSymbol] = getterHelpers.setupComputedProperties(prototype);
            }
            var instance = this;
            var definitions = prototype[definitionsSymbol] || {};
            for (var key in definitions) {
                Object.defineProperty(instance, key, definitions[key]);
            }
            this.push.apply(this, items || []);
            var localProxyKeys = Object.create(proxyKeys);
            localProxyKeys.constructor = this.constructor;
            var observable = makeArray.observable(instance, {
                observe: makeObserve.observe,
                proxyKeys: localProxyKeys,
                shouldRecordObservation: getterHelpers.shouldRecordObservationOnAllKeysExceptFunctionsOnProto
            });
            observableStore.proxiedObjects.set(instance, observable);
            observableStore.proxies.add(observable);
            return observable;
        };
        ObserveArray.prototype = Object.create(Array.prototype);
    }
    eventMixin(ObserveArray.prototype);
    getterHelpers.addMethodsAndSymbols(ObserveArray);
    ObserveArray.extend = helpers.makeSimpleExtender(ObserveArray);
    module.exports = ObserveArray;
});
/*can-observe@2.0.1#can-observe*/
define('can-observe@2.0.1#can-observe', [
    'require',
    'exports',
    'module',
    './src/-make-object',
    './src/-make-array',
    './src/-make-function',
    './src/-make-observe',
    './object/object',
    './array/array'
], function (require, exports, module) {
    var makeObject = require('./src/-make-object');
    var makeArray = require('./src/-make-array');
    var makeFunction = require('./src/-make-function');
    var makeObserve = require('./src/-make-observe');
    var ObserveObject = require('./object/object');
    var ObserveArray = require('./array/array');
    makeObserve.object = function (object) {
        return makeObject.observable(object, makeObserve);
    };
    makeObserve.array = function (array) {
        return makeArray.observable(array, makeObserve);
    };
    makeObserve.function = function (array) {
        return makeFunction.observable(array, makeObserve);
    };
    makeObserve.observe.Object = ObserveObject;
    makeObserve.observe.Array = ObserveArray;
    module.exports = makeObserve.observe;
});
/*can-component@4.0.1#test/component-viewmodel-test*/
define('can-component@4.0.1#test/component-viewmodel-test', [
    'require',
    'exports',
    'module',
    'steal-qunit',
    'can-dom-data-state',
    './helpers',
    'can-simple-map',
    'can-stache',
    'can-component',
    'can-view-model',
    'can-define/map/map',
    'can-define/list/list',
    'can-view-scope',
    'can-simple-observable/setter/setter',
    'can-simple-observable',
    'can-reflect',
    'can-symbol',
    'can-dom-events',
    'can-dom-mutate/node',
    'can-construct',
    'can-observe',
    'can-view-callbacks'
], function (require, exports, module) {
    var QUnit = require('steal-qunit');
    var canData = require('can-dom-data-state');
    var helpers = require('./helpers');
    var SimpleMap = require('can-simple-map');
    var stache = require('can-stache');
    var Component = require('can-component');
    var canViewModel = require('can-view-model');
    var DefineMap = require('can-define/map/map');
    var DefineList = require('can-define/list/list');
    var Scope = require('can-view-scope');
    var SetterObservable = require('can-simple-observable/setter/setter');
    var SimpleObservable = require('can-simple-observable');
    var canReflect = require('can-reflect');
    var canSymbol = require('can-symbol');
    var domEvents = require('can-dom-events');
    var domMutateNode = require('can-dom-mutate/node');
    var Construct = require('can-construct');
    var observe = require('can-observe');
    var tag = require('can-view-callbacks').tag;
    var innerHTML = function (el) {
        return el && el.innerHTML;
    };
    helpers.makeTests('can-component viewModels', function () {
        QUnit.test('a SimpleMap constructor as .ViewModel', function () {
            var map = new SimpleMap({ name: 'Matthew' });
            Component.extend({
                tag: 'can-map-viewmodel',
                view: stache('{{name}}'),
                ViewModel: function () {
                    return map;
                }
            });
            var renderer = stache('<can-map-viewmodel></can-map-viewmodel>');
            equal(renderer().firstChild.firstChild.nodeValue, 'Matthew');
        });
        QUnit.test('a SimpleMap as viewModel', function () {
            var me = new SimpleMap({ name: 'Justin' });
            Component.extend({
                tag: 'my-viewmodel',
                view: stache('{{name}}}'),
                viewModel: me
            });
            var renderer = stache('<my-viewmodel></my-viewmodel>');
            equal(renderer().firstChild.firstChild.nodeValue, 'Justin');
        });
        QUnit.test('a SimpleMap constructor as viewModel', function () {
            var MyMap = SimpleMap.extend({
                setup: function (props) {
                    props.name = 'Matthew';
                    return SimpleMap.prototype.setup.apply(this, arguments);
                }
            });
            Component.extend({
                tag: 'can-map-viewmodel',
                view: stache('{{name}}'),
                viewModel: MyMap
            });
            var renderer = stache('<can-map-viewmodel></can-map-viewmodel>');
            equal(renderer().firstChild.firstChild.nodeValue, 'Matthew');
        });
        QUnit.test('an object is turned into a SimpleMap as viewModel', function () {
            Component.extend({
                tag: 'can-map-viewmodel',
                view: stache('{{name}}'),
                viewModel: { name: 'Matthew' }
            });
            var renderer = stache('<can-map-viewmodel></can-map-viewmodel>');
            var fragOne = renderer();
            var vmOne = canViewModel(fragOne.firstChild);
            var fragTwo = renderer();
            vmOne.set('name', 'Wilbur');
            equal(fragOne.firstChild.firstChild.nodeValue, 'Wilbur', 'The first map changed values');
            equal(fragTwo.firstChild.firstChild.nodeValue, 'Matthew', 'The second map did not change');
        });
        test('Providing viewModel and ViewModel throws', function () {
            try {
                Component.extend({
                    tag: 'viewmodel-test',
                    view: stache('<div></div>'),
                    viewModel: {},
                    ViewModel: SimpleMap.extend({})
                });
                ok(false, 'Should have thrown because we provided both');
            } catch (er) {
                ok(true, 'It threw because we provided both viewModel and ViewModel');
            }
        });
        test('canViewModel utility', function () {
            Component({
                tag: 'my-taggy-tag',
                view: stache('<h1>hello</h1>'),
                viewModel: function () {
                    return new SimpleMap({ foo: 'bar' });
                }
            });
            var frag = stache('<my-taggy-tag id=\'x\'></my-taggy-tag>')();
            var el = frag.firstChild;
            equal(canViewModel(el), el[canSymbol.for('can.viewModel')], 'one argument grabs the viewModel object');
            equal(canViewModel(el, 'foo'), 'bar', 'two arguments fetches a value');
            canViewModel(el, 'foo', 'baz');
            equal(canViewModel(el, 'foo'), 'baz', 'Three arguments sets the value');
        });
        test('setting passed variables - two way binding', function () {
            Component.extend({
                tag: 'my-toggler',
                view: stache('{{#if visible}}<content/>{{/if}}'),
                leakScope: true,
                ViewModel: DefineMap.extend({
                    visible: { value: true },
                    show: function () {
                        this.set('visible', true);
                    },
                    hide: function () {
                        this.set('visible', false);
                    }
                })
            });
            Component.extend({
                tag: 'my-app',
                ViewModel: DefineMap.extend({
                    visible: { value: true },
                    show: function () {
                        this.set('visible', true);
                    }
                })
            });
            var renderer = stache('<my-app>' + '{{^visible}}<button on:click="show()">show</button>{{/visible}}' + '<my-toggler visible:bind="visible">' + 'content' + '<button on:click="hide()">hide</button>' + '</my-toggler>' + '</my-app>');
            var frag = renderer({});
            var myApp = frag.firstChild, buttons = myApp.getElementsByTagName('button');
            equal(buttons.length, 1, 'there is one button');
            equal(innerHTML(buttons[0]), 'hide', 'the button\'s text is hide');
            domEvents.dispatch(buttons[0], 'click');
            buttons = myApp.getElementsByTagName('button');
            equal(buttons.length, 1, 'there is one button');
            equal(innerHTML(buttons[0]), 'show', 'the button\'s text is show');
            domEvents.dispatch(buttons[0], 'click');
            buttons = myApp.getElementsByTagName('button');
            equal(buttons.length, 1, 'there is one button');
            equal(innerHTML(buttons[0]), 'hide', 'the button\'s text is hide');
        });
        test('don\'t update computes unnecessarily', function () {
            var sourceAge = new SimpleObservable(30), timesComputeIsCalled = 0;
            var age = new SetterObservable(function () {
                timesComputeIsCalled++;
                if (timesComputeIsCalled === 1) {
                    ok(true, 'reading initial value to set as years');
                } else if (timesComputeIsCalled === 3) {
                    ok(true, 'updating value to 31');
                } else {
                    ok(false, 'You\'ve called the callback ' + timesComputeIsCalled + ' times');
                }
                return sourceAge.get();
            }, function (newVal) {
                timesComputeIsCalled++;
                if (timesComputeIsCalled === 2) {
                    ok(true, 'called back another time after set to get the value');
                } else {
                    ok(false, 'You\'ve called the callback ' + timesComputeIsCalled + ' times');
                }
                sourceAge.set(newVal);
            });
            Component.extend({ tag: 'age-er' });
            var renderer = stache('<age-er years:bind=\'age\'></age-er>');
            renderer({ age: age });
            age.set(31);
        });
        test('viewModel not rebound correctly (#550)', function () {
            var nameChanges = 0;
            Component.extend({
                tag: 'viewmodel-rebinder',
                events: {
                    '{name}': function () {
                        nameChanges++;
                    }
                }
            });
            var renderer = stache('<viewmodel-rebinder></viewmodel-rebinder>');
            var frag = renderer();
            var viewModel = canViewModel(frag.firstChild);
            var n1 = new SimpleObservable(), n2 = new SimpleObservable();
            viewModel.set('name', n1);
            n1.set('updated');
            viewModel.set('name', n2);
            n2.set('updated');
            equal(nameChanges, 2);
        });
        test('id and class should work now (#694)', function () {
            Component.extend({
                tag: 'stay-classy',
                ViewModel: SimpleMap.extend({
                    setup: function (props) {
                        canReflect.assign(props, {
                            notid: 'foo',
                            notclass: 5,
                            notdataviewid: {}
                        });
                        return SimpleMap.prototype.setup.apply(this, arguments);
                    }
                })
            });
            var data = {
                idData: 'id-success',
                classData: 'class-success'
            };
            var frag = stache('<stay-classy id:bind=\'idData\'' + ' class:bind=\'classData\'></stay-classy>')(data);
            var stayClassy = frag.firstChild;
            domMutateNode.appendChild.call(this.fixture, frag);
            var viewModel = canViewModel(stayClassy);
            equal(viewModel.get('id'), 'id-success');
            equal(viewModel.get('class'), 'class-success');
        });
        test('Construct are passed normally', function () {
            var Constructed = Construct.extend({ foo: 'bar' }, {});
            Component.extend({
                tag: 'con-struct',
                view: stache('{{con.foo}}')
            });
            var stached = stache('<con-struct con:bind=\'Constructed\'></con-struct>');
            var res = stached({ Constructed: Constructed });
            equal(innerHTML(res.firstChild), 'bar');
        });
        test('Component two way binding loop (#1579)', function () {
            var changeCount = 0;
            Component.extend({
                tag: 'product-swatch-color',
                viewModel: { tag: 'product-swatch-color' }
            });
            Component.extend({
                tag: 'product-swatch',
                view: stache('<product-swatch-color variations:bind="variations"></product-swatch-color>'),
                ViewModel: DefineMap.extend({
                    variations: {
                        set: function (variations) {
                            if (changeCount > 500) {
                                return;
                            }
                            changeCount++;
                            return new DefineList(variations.get());
                        }
                    }
                })
            });
            var frag = stache('<product-swatch></product-swatch>')(), productSwatch = frag.firstChild;
            canViewModel(productSwatch).set('variations', new DefineList());
            ok(changeCount < 500, 'more than 500 events');
        });
        test('two-way binding syntax INTRODUCED in v2.3 ALLOWS a child property to initialize an undefined parent property', function () {
            var renderer = stache('<pa-rent/>');
            Component.extend({
                tag: 'pa-rent',
                view: stache('<chi-ld childProp:bind="parentProp" />')
            });
            Component.extend({
                tag: 'chi-ld',
                ViewModel: { childProp: { value: 'bar' } }
            });
            var frag = renderer({});
            var parentVM = canViewModel(frag.firstChild);
            var childVM = canViewModel(frag.firstChild.firstChild);
            equal(parentVM.get('parentProp'), 'bar', 'parentProp is bar');
            equal(childVM.get('childProp'), 'bar', 'childProp is bar');
            parentVM.set('parentProp', 'foo');
            equal(parentVM.get('parentProp'), 'foo', 'parentProp is foo');
            equal(childVM.get('childProp'), 'foo', 'childProp is foo');
            childVM.set('childProp', 'baz');
            equal(parentVM.get('parentProp'), 'baz', 'parentProp is baz');
            equal(childVM.get('childProp'), 'baz', 'childProp is baz');
        });
        test('conditional attributes (#2077)', function () {
            Component.extend({
                tag: 'some-comp',
                ViewModel: observe.Object.extend({})
            });
            var renderer = stache('<some-comp ' + '{{#if preview}}next:from=\'nextPage\'{{/if}} ' + 'swap:from=\'{{swapName}}\' ' + '{{#preview}}checked{{/preview}} ' + '></some-comp>');
            var map = new SimpleMap({
                preview: true,
                nextPage: 2,
                swapName: 'preview'
            });
            var frag = renderer(map);
            var vm = canViewModel(frag.firstChild);
            var threads = [
                function () {
                    equal(vm.next, 2, 'has binding');
                    equal(vm.swap, true, 'swap - has binding');
                    map.attr('preview', false);
                },
                function () {
                    equal(vm.swap, false, 'swap - updated binidng');
                    map.attr('nextPage', 3);
                    equal(vm.next, 2, 'not updating after binding is torn down');
                    map.attr('preview', true);
                },
                function () {
                    equal(vm.next, 3, 're-initialized with binding');
                    equal(vm.swap, true, 'swap - updated binidng');
                    map.attr('swapName', 'nextPage');
                },
                function () {
                    equal(vm.swap, 3, 'swap - updated binding key');
                    map.attr('nextPage', 4);
                    equal(vm.swap, 4, 'swap - updated binding');
                }
            ];
            stop();
            var index = 0;
            var next = function () {
                if (index < threads.length) {
                    threads[index]();
                    index++;
                    setTimeout(next, 150);
                } else {
                    start();
                }
            };
            setTimeout(next, 100);
        });
        QUnit.test('one-way - child to parent - parent that does not leak scope, but has no view', function () {
            Component.extend({
                tag: 'outer-noleak',
                ViewModel: observe.Object.extend('Outer', {}, { name: 'outer' }),
                leakScope: false
            });
            Component.extend({
                tag: 'my-child',
                ViewModel: observe.Object.extend('Inner', {}, { name: 'inner' }),
                leakScope: false
            });
            var renderer = stache('<outer-noleak><my-child this:to=\'myChild\'/></outer-noleak>');
            var frag = renderer();
            var vm = canViewModel(frag.firstChild);
            QUnit.equal(vm.myChild.name, 'inner', 'got instance');
        });
        QUnit.test('Can be called on an element using preventDataBindings (#183)', function () {
            Component.extend({
                tag: 'prevent-data-bindings',
                ViewModel: {},
                view: stache('{{value}}')
            });
            var document = this.document;
            var el = document.createElement('div');
            var callback = tag('prevent-data-bindings');
            var vm = new observe.Object({ value: 'it worked' });
            el[canSymbol.for('can.viewModel')] = vm;
            canData.set.call(el, 'preventDataBindings', true);
            callback(el, { scope: new Scope({ value: 'it did not work' }) });
            canData.set.call(el, 'preventDataBindings', false);
            QUnit.equal(el.firstChild.nodeValue, 'it worked');
        });
    });
});
/*can-component@4.0.1#test/component-viewmodel-observe-test*/
define('can-component@4.0.1#test/component-viewmodel-observe-test', [
    'require',
    'exports',
    'module',
    'steal-qunit',
    './helpers',
    'can-stache',
    'can-component',
    'can-dom-events',
    'can-dom-mutate/node',
    'can-observe'
], function (require, exports, module) {
    var QUnit = require('steal-qunit');
    var helpers = require('./helpers');
    var stache = require('can-stache');
    var Component = require('can-component');
    var domEvents = require('can-dom-events');
    var domMutateNode = require('can-dom-mutate/node');
    var observe = require('can-observe');
    var innerHTML = function (el) {
        return el && el.innerHTML;
    };
    var classSupport = function () {
        try {
            eval('"use strict"; class A{};');
            return true;
        } catch (e) {
            return false;
        }
    }();
    helpers.makeTests('can-component viewModels with observe', function () {
        QUnit.test('Basic can-observe type', function () {
            Component.extend({
                tag: 'observe-add',
                view: stache('<button on:click=\'add()\'>+1</button><span>{{count}}</span>'),
                ViewModel: observe.Object.extend('ObserveAdd', {}, {
                    count: 0,
                    add: function () {
                        this.count++;
                    }
                })
            });
            var frag = stache('<observe-add/>')();
            var buttons = frag.firstChild.getElementsByTagName('button');
            var spans = frag.firstChild.getElementsByTagName('span');
            QUnit.equal(spans[0].innerHTML, '0', 'first value');
            domEvents.dispatch(buttons[0], 'click');
            QUnit.equal(spans[0].innerHTML, '1', 'second value');
        });
        if (classSupport) {
            QUnit.test('ViewModel as observe(class)', function () {
                class Add extends observe.Object {
                    constructor(props) {
                        super(props);
                        this.count = 0;
                    }
                    add() {
                        this.count++;
                    }
                }
                Component.extend({
                    tag: 'observe-class-add',
                    view: stache('<button on:click=\'add()\'>+1</button><span>{{count}}</span>'),
                    ViewModel: Add
                });
                var frag = stache('<observe-class-add/>')();
                var buttons = frag.firstChild.getElementsByTagName('button');
                var spans = frag.firstChild.getElementsByTagName('span');
                QUnit.equal(spans[0].innerHTML, '0', 'first value');
                domEvents.dispatch(buttons[0], 'click');
                QUnit.equal(spans[0].innerHTML, '1', 'second value');
            });
            QUnit.test('connectedCallback and disconnectedCallback', 3, function () {
                QUnit.stop();
                Component.extend({
                    tag: 'connected-component',
                    view: stache('rendered'),
                    ViewModel: class extends observe.Object {
                        connectedCallback(element) {
                            QUnit.equal(element.innerHTML, 'rendered', 'rendered view');
                            QUnit.equal(element.nodeName, 'CONNECTED-COMPONENT', 'connectedCallback');
                            return function () {
                                QUnit.equal(element.nodeName, 'CONNECTED-COMPONENT', 'disconnectedCallback');
                            };
                        }
                    }
                });
                var template = stache('<connected-component/>');
                var frag = template();
                var first = frag.firstChild;
                domMutateNode.appendChild.call(this.fixture, frag);
                helpers.afterMutation(function () {
                    domMutateNode.removeChild.call(first.parentNode, first);
                    helpers.afterMutation(function () {
                        QUnit.start();
                    });
                });
            });
        }
    });
});
/*can-dom-mutate@1.0.2#dom-events*/
define('can-dom-mutate@1.0.2#dom-events', [
    'require',
    'exports',
    'module',
    'can-dom-mutate'
], function (require, exports, module) {
    'use strict';
    var domMutate = require('can-dom-mutate');
    function makeMutationEvent(defaultEventType, subscription) {
        var elementSubscriptions = new Map();
        return {
            _subscriptions: elementSubscriptions,
            defaultEventType: defaultEventType,
            addEventListener: function (target, eventType, handler) {
                var dispatch = this.dispatch;
                var data = elementSubscriptions.get(target);
                if (!data) {
                    data = {
                        removeListener: null,
                        listeners: new Set()
                    };
                    elementSubscriptions.set(target, data);
                }
                if (data.listeners.size === 0) {
                    data.removeListener = subscription(target, function (mutation) {
                        var eventData = { type: eventType };
                        for (var key in mutation) {
                            eventData[key] = mutation[key];
                        }
                        dispatch(target, eventData);
                    });
                }
                data.listeners.add(handler);
                target.addEventListener(eventType, handler);
            },
            removeEventListener: function (target, eventType, handler) {
                target.removeEventListener(eventType, handler);
                var data = elementSubscriptions.get(target);
                if (data) {
                    data.listeners['delete'](handler);
                    if (data.listeners.size === 0) {
                        data.removeListener();
                        elementSubscriptions['delete'](target);
                    }
                }
            }
        };
    }
    module.exports = {
        attributes: makeMutationEvent('attributes', domMutate.onNodeAttributeChange),
        inserted: makeMutationEvent('inserted', domMutate.onNodeInsertion),
        removed: makeMutationEvent('removed', domMutate.onNodeRemoval)
    };
});
/*can-component@4.0.1#test/component-view-test*/
define('can-component@4.0.1#test/component-view-test', [
    'require',
    'exports',
    'module',
    'steal-qunit',
    './helpers',
    'can-simple-map',
    'can-stache',
    'can-component',
    'can-dom-events',
    'can-dom-mutate/node',
    'can-dom-mutate/dom-events',
    'can-view-model',
    'can-define/map/map',
    'can-queues',
    'can-util/dom/fragment/fragment',
    'can-view-callbacks',
    'can-view-scope',
    'can-observe',
    'can-queues'
], function (require, exports, module) {
    var QUnit = require('steal-qunit');
    var helpers = require('./helpers');
    var SimpleMap = require('can-simple-map');
    var stache = require('can-stache');
    var Component = require('can-component');
    var domEvents = require('can-dom-events');
    var domMutateNode = require('can-dom-mutate/node');
    var domMutateDomEvents = require('can-dom-mutate/dom-events');
    var insertedEvent = domMutateDomEvents.inserted;
    var canViewModel = require('can-view-model');
    var DefineMap = require('can-define/map/map');
    var queues = require('can-queues');
    var getFragment = require('can-util/dom/fragment/fragment');
    var viewCallbacks = require('can-view-callbacks');
    var Scope = require('can-view-scope');
    var observe = require('can-observe');
    var innerHTML = function (el) {
        return el && el.innerHTML;
    };
    helpers.makeTests('can-component views', function (doc, runTestInOnlyDocument) {
        QUnit.test('lexical scoping', function () {
            Component.extend({
                tag: 'hello-world',
                view: stache('{{greeting}} <content>World</content>{{exclamation}}'),
                viewModel: function () {
                    return new SimpleMap({ greeting: 'Hello' });
                }
            });
            var renderer = stache('<hello-world>{{greeting}}</hello-world>');
            var frag = renderer({
                greeting: 'World',
                exclamation: '!'
            });
            var hello = frag.firstChild;
            equal(hello.innerHTML.trim(), 'Hello World');
            Component.extend({
                tag: 'hello-world-no-template',
                leakScope: false,
                viewModel: function () {
                    return new SimpleMap({ greeting: 'Hello' });
                }
            });
            renderer = stache('<hello-world-no-template>{{greeting}}</hello-world-no-template>');
            frag = renderer({
                greeting: 'World',
                exclamation: '!'
            });
            hello = frag.firstChild;
            equal(hello.innerHTML.trim(), 'Hello', 'If no view is provided to Component, treat <content> bindings as dynamic.');
        });
        QUnit.test('dynamic scoping', function () {
            Component.extend({
                tag: 'hello-world',
                leakScope: true,
                view: stache('{{greeting}} <content>World</content>{{../exclamation}}'),
                viewModel: function () {
                    return new SimpleMap({ greeting: 'Hello' });
                }
            });
            var renderer = stache('<hello-world>{{greeting}}</hello-world>');
            var frag = renderer({
                greeting: 'World',
                exclamation: '!'
            });
            var hello = frag.firstChild;
            equal(hello.innerHTML.trim(), 'Hello Hello!');
        });
        QUnit.test('hello-world and whitespace around custom elements', function () {
            Component.extend({
                tag: 'hello-world',
                view: stache('{{#if visible}}{{message}}{{else}}Click me{{/if}}'),
                viewModel: function () {
                    return new SimpleMap({
                        visible: false,
                        message: 'Hello There!'
                    });
                },
                events: {
                    click: function () {
                        this.viewModel.attr('visible', true);
                    }
                }
            });
            var renderer = stache('  <hello-world></hello-world>  ');
            var frag = renderer({});
            var helloWorld = frag.childNodes.item(1);
            domEvents.dispatch(helloWorld, 'click');
            equal(helloWorld.innerHTML, 'Hello There!');
        });
        QUnit.test('self closing content tags', function () {
            Component.extend({
                'tag': 'my-greeting',
                view: stache('<h1><content/></h1>'),
                viewModel: function () {
                    return new SimpleMap({ title: 'Component' });
                }
            });
            var renderer = stache('<my-greeting><span>{{site}} - {{title}}</span></my-greeting>');
            var frag = renderer({ site: 'CanJS' });
            equal(frag.firstChild.getElementsByTagName('span').length, 1, 'there is an h1');
        });
        QUnit.test('content extension stack overflow error', function () {
            Component({
                tag: 'outer-tag',
                view: stache('<inner-tag>inner-tag CONTENT <content/></inner-tag>')
            });
            Component({
                tag: 'inner-tag',
                view: stache('inner-tag TEMPLATE <content/>')
            });
            var renderer = stache('<outer-tag>outer-tag CONTENT</outer-tag>');
            var frag = renderer();
            equal(innerHTML(frag.firstChild.firstChild), 'inner-tag TEMPLATE inner-tag CONTENT outer-tag CONTENT');
        });
        QUnit.test('inserted event fires twice if component inside live binding block', function () {
            var undo = domEvents.addEvent(insertedEvent);
            var inited = 0, inserted = 0;
            Component.extend({
                tag: 'child-tag',
                ViewModel: SimpleMap.extend({
                    init: function () {
                        inited++;
                    }
                }),
                events: {
                    ' inserted': function () {
                        inserted++;
                    }
                }
            });
            Component.extend({
                tag: 'parent-tag',
                view: stache('{{#shown}}<child-tag></child-tag>{{/shown}}'),
                viewModel: observe.Object.extend('ParentTag', {}, { shown: false }),
                events: {
                    ' inserted': function () {
                        this.viewModel.shown = true;
                    }
                }
            });
            var frag = stache('<parent-tag id=\'pt\'></parent-tag>')({});
            domMutateNode.appendChild.call(this.fixture, frag);
            stop();
            var attempts = 0;
            function checkCount() {
                if (inserted >= 1 || attempts > 100) {
                    equal(inited, 1, 'inited');
                    equal(inserted, 1, 'inserted');
                    undo();
                    start();
                } else {
                    attempts += 1;
                    setTimeout(checkCount, 30);
                }
            }
            checkCount();
        });
        QUnit.test('Same component tag nested', function () {
            Component({
                'tag': 'my-tag',
                view: stache('<p><content/></p>')
            });
            var renderer = stache('<div><my-tag>Outter<my-tag>Inner</my-tag></my-tag></div>');
            var renderer2 = stache('<div><my-tag>3<my-tag>2<my-tag>1<my-tag>0</my-tag></my-tag></my-tag></my-tag></div>');
            var renderer3 = stache('<div><my-tag>First</my-tag><my-tag>Second</my-tag></div>');
            equal(renderer({}).firstChild.getElementsByTagName('p').length, 2, 'proper number of p tags');
            equal(renderer2({}).firstChild.getElementsByTagName('p').length, 4, 'proper number of p tags');
            equal(renderer3({}).firstChild.getElementsByTagName('p').length, 2, 'proper number of p tags');
        });
        QUnit.test('nested component within an #if is not live bound(#1025)', function () {
            Component.extend({
                tag: 'parent-component',
                view: stache('{{#if shown}}<child-component></child-component>{{/if}}'),
                viewModel: function () {
                    return new SimpleMap({ shown: false });
                }
            });
            Component.extend({
                tag: 'child-component',
                view: stache('Hello world.')
            });
            var renderer = stache('<parent-component></parent-component>');
            var frag = renderer({});
            equal(innerHTML(frag.firstChild), '', 'child component is not inserted');
            canViewModel(frag.firstChild).attr('shown', true);
            equal(innerHTML(frag.firstChild.firstChild), 'Hello world.', 'child component is inserted');
            canViewModel(frag.firstChild).attr('shown', false);
            equal(innerHTML(frag.firstChild), '', 'child component is removed');
        });
        var queues = require('can-queues');
        QUnit.test('references scopes are available to bindings nested in components (#2029)', function () {
            var renderer = stache('<export-er value:to="scope.vars.reference" />' + '<wrap-er><simple-example key:from="scope.vars.reference"/></wrap-er>');
            Component.extend({ tag: 'wrap-er' });
            Component.extend({
                tag: 'export-er',
                events: {
                    'init': function () {
                        var self = this.viewModel;
                        stop();
                        setTimeout(function () {
                            self.set('value', 100);
                            var wrapper = frag.lastChild, simpleExample = wrapper.firstChild, textNode = simpleExample.firstChild;
                            equal(textNode.nodeValue, '100', 'updated value with reference');
                            start();
                        }, 100);
                    }
                }
            });
            Component.extend({
                tag: 'simple-example',
                view: stache('{{key}}')
            });
            var frag = renderer({});
        });
        test('<content> (#2151)', function () {
            var mapInstance = new DefineMap({
                items: [
                    {
                        id: 1,
                        context: 'Item 1',
                        render: false
                    },
                    {
                        id: 2,
                        context: 'Item 2',
                        render: false
                    }
                ]
            });
            Component.extend({
                tag: 'list-items',
                view: stache('<ul>' + '{{#items}}' + '{{#if render}}' + '<li><content /></li>' + '{{/if}}' + '{{/items}}' + '</ul>'),
                viewModel: mapInstance,
                leakScope: true
            });
            Component.extend({
                tag: 'list-item',
                view: stache('{{item.context}}')
            });
            var renderer = stache('<list-items><list-item item:from=\'this\'/></list-items>');
            var frag = renderer();
            queues.batch.start();
            canViewModel(frag.firstChild).get('items').forEach(function (item, index) {
                item.set('render', true);
            });
            queues.batch.stop();
            var lis = frag.firstChild.getElementsByTagName('li');
            ok(innerHTML(lis[0]).indexOf('Item 1') >= 0, 'Item 1 written out');
            ok(innerHTML(lis[1]).indexOf('Item 2') >= 0, 'Item 2 written out');
        });
        QUnit.test('two-way - reference - with <content> tag', function () {
            Component.extend({
                tag: 'other-export',
                viewModel: function () {
                    return new SimpleMap({ name: 'OTHER-EXPORT' });
                }
            });
            Component.extend({
                tag: 'ref-export',
                view: stache('<other-export name:bind="*otherExport"/><content>{{*otherExport}}</content>')
            });
            var t1 = stache('<ref-export></ref-export>');
            var f1 = t1();
            equal(canViewModel(f1.firstChild.firstChild).get('name'), 'OTHER-EXPORT', 'viewModel set correctly');
            equal(f1.firstChild.lastChild.nodeValue, 'OTHER-EXPORT', 'content');
        });
        runTestInOnlyDocument('custom renderer can provide setupBindings', function () {
            var rendererFactory = function (tmpl) {
                var frag = getFragment(tmpl);
                return function (scope, options) {
                    scope = scope || new Scope();
                    options = options || {};
                    if (frag.firstChild.nodeName === 'CUSTOM-RENDERER') {
                        viewCallbacks.tagHandler(frag.firstChild, 'custom-renderer', {
                            scope: scope,
                            options: options,
                            templateType: 'my-renderer',
                            setupBindings: function (el, callback, data) {
                                callback({ foo: 'qux' });
                            }
                        });
                    } else {
                        var tn = frag.firstChild.firstChild;
                        tn.nodeValue = scope.read('foo').value;
                    }
                    return frag;
                };
            };
            Component.extend({
                tag: 'custom-renderer',
                view: rendererFactory('<div>{{foo}}</div>'),
                ViewModel: SimpleMap.extend({})
            });
            var renderer = rendererFactory('<custom-renderer foo=\'bar\'></custom-renderer>');
            var frag = renderer();
            var tn = frag.firstChild.firstChild.firstChild;
            equal(tn.nodeValue, 'qux', 'was bound!');
        });
        QUnit.test('view defaults to stache if set to a string', function () {
            Component.extend({
                tag: 'hello-world',
                leakScope: true,
                view: '{{greeting}} World{{../exclamation}}',
                viewModel: function () {
                    return new SimpleMap({ greeting: 'Hello' });
                }
            });
            var renderer = stache('<hello-world />');
            var frag = renderer({ exclamation: '!' });
            var hello = frag.firstChild;
            equal(hello.innerHTML.trim(), 'Hello World!');
        });
    });
});
/*can-component@4.0.1#test/component-helpers-test*/
define('can-component@4.0.1#test/component-helpers-test', [
    'require',
    'exports',
    'module',
    'steal-qunit',
    './helpers',
    'can-simple-map',
    'can-stache',
    'can-component'
], function (require, exports, module) {
    var QUnit = require('steal-qunit');
    var helpers = require('./helpers');
    var SimpleMap = require('can-simple-map');
    var stache = require('can-stache');
    var Component = require('can-component');
    var innerHTML = function (el) {
        return el && el.innerHTML;
    };
    helpers.makeTests('can-component helpers', function () {
        QUnit.test('helpers reference the correct instance (#515)', function () {
            expect(2);
            Component({
                tag: 'my-text',
                view: stache('<p>{{valueHelper()}}</p>'),
                helpers: {
                    valueHelper: function () {
                        return this.get('value');
                    }
                }
            });
            var renderer = stache('<my-text value:from="\'value1\'"></my-text><my-text value:from="\'value2\'"></my-text>');
            var frag = renderer({});
            equal(frag.firstChild.firstChild.firstChild.nodeValue, 'value1');
            equal(frag.lastChild.firstChild.firstChild.nodeValue, 'value2');
        });
    });
});
/*can-component@4.0.1#test/component-events-test*/
define('can-component@4.0.1#test/component-events-test', [
    'require',
    'exports',
    'module',
    'steal-qunit',
    './helpers',
    'can-simple-map',
    'can-stache',
    'can-component',
    'can-view-model',
    'can-simple-observable',
    'can-dom-events',
    'can-dom-mutate/node',
    'can-dom-mutate/dom-events'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        var QUnit = require('steal-qunit');
        var helpers = require('./helpers');
        var SimpleMap = require('can-simple-map');
        var stache = require('can-stache');
        var Component = require('can-component');
        var canViewModel = require('can-view-model');
        var SimpleObservable = require('can-simple-observable');
        var domEvents = require('can-dom-events');
        var domMutateNode = require('can-dom-mutate/node');
        var domMutateDomEvents = require('can-dom-mutate/dom-events');
        var insertedEvent = domMutateDomEvents.inserted;
        var removedEvent = domMutateDomEvents.removed;
        helpers.makeTests('can-component events', function () {
            test('value observables formerly (#550)', function () {
                var nameChanges = 0;
                Component.extend({
                    tag: 'viewmodel-rebinder',
                    events: {
                        '{name}': function () {
                            nameChanges++;
                        }
                    }
                });
                var renderer = stache('<viewmodel-rebinder></viewmodel-rebinder>');
                var frag = renderer();
                var viewModel = canViewModel(frag.firstChild);
                var n1 = new SimpleObservable(), n2 = new SimpleObservable();
                viewModel.set('name', n1);
                n1.set('updated');
                viewModel.set('name', n2);
                n2.set('updated');
                equal(nameChanges, 2);
            });
            test('Component events bind to window', function () {
                window.tempMap = new SimpleMap();
                Component.extend({
                    tag: 'window-events',
                    events: {
                        '{tempMap} prop': function () {
                            ok(true, 'called templated event');
                        }
                    }
                });
                var renderer = stache('<window-events></window-events>');
                renderer();
                window.tempMap.set('prop', 'value');
                window.tempMap = undefined;
                try {
                    delete window.tempMap;
                } catch (e) {
                }
            });
            QUnit.test('stache conditionally nested components calls inserted once (#967)', function () {
                expect(1);
                var undo = domEvents.addEvent(insertedEvent);
                Component.extend({
                    tag: 'can-parent-stache',
                    viewModel: function () {
                        return new SimpleMap({ shown: true });
                    },
                    view: stache('{{#if shown}}<can-child></can-child>{{/if}}')
                });
                Component.extend({
                    tag: 'can-child',
                    events: {
                        inserted: function () {
                            ok(true, 'called inserted once');
                        }
                    }
                });
                var renderer = stache('<can-parent-stache></can-parent-stache>');
                domMutateNode.appendChild.call(this.fixture, renderer());
                stop();
                setTimeout(function () {
                    undo();
                    start();
                }, 100);
            });
            QUnit.test('viewModel objects with Constructor functions as properties do not get converted (#1261)', 1, function () {
                stop();
                var HANDLER;
                var Test = SimpleMap.extend({
                    addEventListener: function (ev, handler) {
                        HANDLER = handler;
                    },
                    removeEventListener: function () {
                    }
                }, {
                    setup: function (props) {
                        props.test = 'Yeah';
                        return SimpleMap.prototype.setup.apply(this, arguments);
                    }
                });
                Component.extend({
                    tag: 'my-app',
                    viewModel: SimpleMap.extend({
                        setup: function (props) {
                            props.MyConstruct = Test;
                            return SimpleMap.prototype.setup.apply(this, arguments);
                        }
                    }),
                    events: {
                        '{MyConstruct} something': function () {
                            ok(true, 'Event got triggered');
                            start();
                        }
                    }
                });
                var frag = stache('<my-app></my-app>')();
                domMutateNode.appendChild.call(this.fixture, frag);
                HANDLER.call(Test, { type: 'something' });
            });
            QUnit.test('removing bound viewModel properties on destroy #1415', function () {
                var state = new SimpleMap({
                    product: new SimpleMap({
                        id: 1,
                        name: 'Tom'
                    })
                });
                Component.extend({
                    tag: 'destroyable-component',
                    events: {
                        destroy: function () {
                            this.viewModel.set('product', null);
                        }
                    }
                });
                var frag = stache('<destroyable-component product:bind="product"></destroyable-component>')(state);
                domMutateNode.appendChild.call(this.fixture, frag);
                domMutateNode.removeChild.call(this.fixture, this.fixture.firstChild);
                stop();
                helpers.afterMutation(function () {
                    ok(state.attr('product') == null, 'product was removed');
                    start();
                });
            });
            test('changing viewModel property rebinds {viewModel.<...>} events (#1529)', 2, function () {
                Component.extend({
                    tag: 'rebind-viewmodel',
                    events: {
                        init: function () {
                            this.viewModel.set('item', new SimpleMap({}));
                        },
                        '{scope.item} name': function () {
                            ok(true, 'Change event on scope');
                        },
                        '{viewModel.item} name': function () {
                            ok(true, 'Change event on viewModel');
                        }
                    }
                });
                var frag = stache('<rebind-viewmodel></rebind-viewmodel>')();
                var rebind = frag.firstChild;
                domMutateNode.appendChild.call(this.fixture, rebind);
                canViewModel(rebind).get('item').set('name', 'CDN');
            });
            QUnit.test('DOM trees not releasing when referencing CanMap inside CanMap in view (#1593)', function () {
                var undo = domEvents.addEvent(removedEvent);
                var baseTemplate = stache('{{#if show}}<my-outside></my-outside>{{/if}}'), show = new SimpleObservable(true), state = new SimpleMap({ inner: 1 });
                var removeCount = 0;
                Component.extend({
                    tag: 'my-inside',
                    events: {
                        removed: function () {
                            removeCount++;
                        }
                    },
                    leakScope: true
                });
                Component.extend({
                    tag: 'my-outside',
                    view: stache('{{#if ../state.inner}}<my-inside></my-inside>{{/if}}'),
                    leakScope: true
                });
                domMutateNode.appendChild.call(this.fixture, baseTemplate({
                    show: show,
                    state: state
                }));
                helpers.runTasks([
                    function () {
                        show.set(false);
                    },
                    function () {
                        state.set('inner', null);
                    },
                    function () {
                        equal(removeCount, 1, 'internal removed once');
                        show.set(true);
                    },
                    function () {
                        state.set('inner', 2);
                    },
                    function () {
                        state.set('inner', null);
                    },
                    function () {
                        equal(removeCount, 2, 'internal removed twice');
                        undo();
                    }
                ]);
                stop();
            });
        });
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-util@3.11.2#js/log/log*/
define('can-util@3.11.2#js/log/log', [
    'require',
    'exports',
    'module',
    'can-log'
], function (require, exports, module) {
    'use strict';
    module.exports = require('can-log');
});
/*can-component@4.0.1#test/example-test*/
define('can-component@4.0.1#test/example-test', [
    'require',
    'exports',
    'module',
    'steal-qunit',
    './helpers',
    'can-simple-map',
    'can-stache',
    'can-component',
    'can-define/list/list',
    'can-define/map/map',
    'can-dom-events',
    'can-view-model',
    'can-dom-mutate/node',
    'can-dom-mutate/dom-events',
    'can-util/js/log/log',
    'can-queues'
], function (require, exports, module) {
    var QUnit = require('steal-qunit');
    var helpers = require('./helpers');
    var SimpleMap = require('can-simple-map');
    var stache = require('can-stache');
    var Component = require('can-component');
    var DefineList = require('can-define/list/list');
    var DefineMap = require('can-define/map/map');
    var domEvents = require('can-dom-events');
    var canViewModel = require('can-view-model');
    var domMutateNode = require('can-dom-mutate/node');
    var domMutateDomEvents = require('can-dom-mutate/dom-events');
    var insertedEvent = domMutateDomEvents.inserted;
    var canLog = require('can-util/js/log/log');
    var queues = require('can-queues');
    var innerHTML = function (el) {
        return el && el.innerHTML;
    };
    helpers.makeTests('can-component examples', function (doc) {
        var Paginate = DefineMap.extend({
            count: { value: Infinity },
            offset: { value: 0 },
            limit: { value: 100 },
            setCount: function (newCount, success, error) {
                return newCount < 0 ? 0 : newCount;
            },
            setOffset: function (newOffset) {
                return newOffset < 0 ? 0 : Math.min(newOffset, !isNaN(this.count - 1) ? this.count - 1 : Infinity);
            },
            next: function () {
                this.set('offset', this.offset + this.limit);
            },
            prev: function () {
                this.set('offset', this.offset - this.limit);
            },
            canNext: function () {
                return this.get('offset') < this.get('count') - this.get('limit');
            },
            canPrev: function () {
                return this.get('offset') > 0;
            },
            page: function (newVal) {
                if (newVal === undefined) {
                    return Math.floor(this.get('offset') / this.get('limit')) + 1;
                } else {
                    this.set('offset', (parseInt(newVal) - 1) * this.get('limit'));
                }
            },
            pageCount: function () {
                return this.get('count') ? Math.ceil(this.get('count') / this.get('limit')) : null;
            }
        });
        test('treecombo', function () {
            var TreeComboViewModel = DefineMap.extend({
                items: { Value: DefineList },
                breadcrumb: { Value: DefineList },
                selected: { Value: DefineList },
                selectableItems: function () {
                    var breadcrumb = this.get('breadcrumb');
                    if (breadcrumb.length) {
                        return breadcrumb[breadcrumb.length - 1].children;
                    } else {
                        return this.get('items');
                    }
                },
                showChildren: function (item, ev) {
                    ev.stopPropagation();
                    this.get('breadcrumb').push(item);
                },
                emptyBreadcrumb: function () {
                    this.get('breadcrumb').update([]);
                },
                updateBreadcrumb: function (item) {
                    var breadcrumb = this.get('breadcrumb'), index = breadcrumb.indexOf(item);
                    breadcrumb.splice(index + 1, breadcrumb.length - index - 1);
                },
                toggle: function (item) {
                    var selected = this.get('selected'), index = selected.indexOf(item);
                    if (index === -1) {
                        selected.push(item);
                    } else {
                        selected.splice(index, 1);
                    }
                },
                isSelected: function (item) {
                    return this.get('selected').indexOf(item) > -1;
                }
            });
            Component.extend({
                tag: 'treecombo',
                view: stache('<ul class=\'breadcrumb\'>' + '<li on:click=\'emptyBreadcrumb()\'>{{title}}</li>' + '{{#each breadcrumb}}' + '<li on:click=\'../updateBreadcrumb(this)\'>{{title}}</li>' + '{{/each}}' + '</ul>' + '<ul class=\'options\'>' + '<content>' + '{{#selectableItems()}}' + '<li {{#../isSelected(this)}}class=\'active\'{{/../isSelected}} on:click=\'../toggle(this)\'>' + '<input type=\'checkbox\' {{#../isSelected(.)}}checked{{/../isSelected}}/>' + '{{title}}' + '{{#if children.length}}' + '<button class=\'showChildren\' on:click=\'../showChildren(this, scope.event)\'>+</button>' + '{{/if}}' + '</li>' + '{{/selectableItems}}' + '</content>' + '</ul>'),
                ViewModel: TreeComboViewModel
            });
            var renderer = stache('<treecombo items:bind=\'locations\' title:from=\'"Locations"\'></treecombo>');
            var base = new DefineMap({});
            var frag = renderer(base);
            var root = doc.createElement('div');
            root.appendChild(frag);
            var items = [
                {
                    id: 1,
                    title: 'Midwest',
                    children: [
                        {
                            id: 5,
                            title: 'Illinois',
                            children: [
                                {
                                    id: 23423,
                                    title: 'Chicago'
                                },
                                {
                                    id: 4563,
                                    title: 'Springfield'
                                },
                                {
                                    id: 4564,
                                    title: 'Naperville'
                                }
                            ]
                        },
                        {
                            id: 6,
                            title: 'Wisconsin',
                            children: [
                                {
                                    id: 232423,
                                    title: 'Milwaulkee'
                                },
                                {
                                    id: 45463,
                                    title: 'Green Bay'
                                },
                                {
                                    id: 45464,
                                    title: 'Madison'
                                }
                            ]
                        }
                    ]
                },
                {
                    id: 2,
                    title: 'East Coast',
                    children: [
                        {
                            id: 25,
                            title: 'New York',
                            children: [
                                {
                                    id: 3413,
                                    title: 'New York'
                                },
                                {
                                    id: 4613,
                                    title: 'Rochester'
                                },
                                {
                                    id: 4516,
                                    title: 'Syracuse'
                                }
                            ]
                        },
                        {
                            id: 6,
                            title: 'Pennsylvania',
                            children: [
                                {
                                    id: 2362423,
                                    title: 'Philadelphia'
                                },
                                {
                                    id: 454663,
                                    title: 'Harrisburg'
                                },
                                {
                                    id: 454664,
                                    title: 'Scranton'
                                }
                            ]
                        }
                    ]
                }
            ];
            stop();
            setTimeout(function () {
                base.set('locations', items);
                var itemsList = base.get('locations');
                var treecombo = root.firstChild, breadcrumb = treecombo.firstChild, breadcrumbLIs = function () {
                        return breadcrumb.getElementsByTagName('li');
                    }, options = treecombo.lastChild, optionsLis = function () {
                        return options.getElementsByTagName('li');
                    };
                equal(breadcrumbLIs().length, 1, 'Only the default title is shown');
                equal(breadcrumbLIs()[0].innerHTML, 'Locations', 'The correct title from the attribute is shown');
                equal(itemsList.length, optionsLis().length, 'first level items are displayed');
                domEvents.dispatch(optionsLis()[0], 'click');
                equal(optionsLis()[0].className, 'active', 'toggling something not selected adds active');
                ok(optionsLis()[0].getElementsByTagName('input')[0].checked, 'toggling something not selected checks checkbox');
                equal(canViewModel(treecombo, 'selected').length, 1, 'there is one selected item');
                equal(canViewModel(treecombo).selected[0], itemsList[0], 'the midwest is in selected');
                var selectedList = canViewModel(treecombo, 'selected');
                selectedList.pop();
                equal(optionsLis()[0].className, '', 'removing selected item in viewModel removes \'active\' class');
                domEvents.dispatch(optionsLis()[0].getElementsByTagName('button')[0], 'click');
                equal(breadcrumbLIs().length, 2, 'Only the default title is shown');
                equal(breadcrumbLIs()[1].innerHTML, 'Midwest', 'The breadcrumb has an item in it');
                ok(/Illinois/.test(optionsLis()[0].innerHTML), 'A child of the top breadcrumb is displayed');
                domEvents.dispatch(optionsLis()[0].getElementsByTagName('button')[0], 'click');
                ok(/Chicago/.test(optionsLis()[0].innerHTML), 'A child of the top breadcrumb is displayed');
                ok(!optionsLis()[0].getElementsByTagName('button').length, 'no show children button');
                domEvents.dispatch(breadcrumbLIs()[1], 'click');
                equal(innerHTML(breadcrumbLIs()[1]), 'Midwest', 'The breadcrumb has an item in it');
                ok(/Illinois/.test(innerHTML(optionsLis()[0])), 'A child of the top breadcrumb is displayed');
                domEvents.dispatch(breadcrumbLIs()[0], 'click');
                equal(breadcrumbLIs().length, 1, 'Only the default title is shown');
                equal(innerHTML(breadcrumbLIs()[0]), 'Locations', 'The correct title from the attribute is shown');
                start();
            }, 100);
        });
        test('deferred grid', function () {
            var GridViewModel = DefineMap.extend({
                items: { Value: DefineList },
                waiting: { value: true }
            });
            Component.extend({
                tag: 'grid',
                ViewModel: GridViewModel,
                view: stache('<table><tbody><content></content></tbody></table>'),
                leakScope: true,
                events: {
                    init: function () {
                        this.update();
                    },
                    '{viewModel} deferreddata': 'update',
                    update: function () {
                        var deferred = this.viewModel.get('deferreddata'), viewModel = this.viewModel;
                        if (deferred && deferred.then) {
                            this.viewModel.set('waiting', true);
                            deferred.then(function (items) {
                                viewModel.get('items').update(items);
                            });
                        } else {
                            viewModel.get('items').update(deferred);
                        }
                    },
                    '{items} length': function () {
                        this.viewModel.set('waiting', false);
                    }
                }
            });
            var SimulatedScope = DefineMap.extend({
                set: { value: 0 },
                deferredData: function () {
                    var deferred = {};
                    var promise = new Promise(function (resolve, reject) {
                        deferred.resolve = resolve;
                        deferred.reject = reject;
                    });
                    var set = this.get('set');
                    if (set === 0) {
                        setTimeout(function () {
                            deferred.resolve([{
                                    first: 'Justin',
                                    last: 'Meyer'
                                }]);
                        }, 100);
                    } else if (set === 1) {
                        setTimeout(function () {
                            deferred.resolve([{
                                    first: 'Brian',
                                    last: 'Moschel'
                                }]);
                        }, 100);
                    }
                    return promise;
                }
            });
            var viewModel = new SimulatedScope();
            var renderer = stache('<grid deferreddata:bind=\'viewModel.deferredData()\'>' + '{{#each items}}' + '<tr>' + '<td width=\'40%\'>{{first}}</td>' + '<td width=\'70%\'>{{last}}</td>' + '</tr>' + '{{/each}}' + '</grid>');
            domMutateNode.appendChild.call(this.fixture, renderer({ viewModel: viewModel }));
            var gridScope = canViewModel(this.fixture.firstChild);
            equal(gridScope.get('waiting'), true, 'The grid is initially waiting on the deferreddata to resolve');
            stop();
            var self = this;
            var waitingHandler = function () {
                gridScope.off('waiting', waitingHandler);
                setTimeout(function () {
                    var tds = self.fixture.getElementsByTagName('td');
                    equal(tds.length, 2, 'there are 2 tds');
                    gridScope.on('waiting', function (ev, newVal) {
                        if (newVal === false) {
                            setTimeout(function () {
                                tds = self.fixture.getElementsByTagName('td');
                                equal(innerHTML(tds[0]), 'Brian', 'td changed to brian');
                                start();
                            }, 100);
                        }
                    });
                    viewModel.set = 1;
                }, 100);
            };
            gridScope.on('waiting', waitingHandler);
        });
        test('nextprev', function () {
            Component.extend({
                tag: 'next-prev',
                view: stache('<a href="javascript://"' + 'class="prev {{#paginate.canPrev()}}enabled{{/paginate.canPrev}}" on:click="paginate.prev()">Prev</a>' + '<a href="javascript://"' + 'class="next {{#paginate.canNext()}}enabled{{/paginate.canNext}}" on:click="paginate.next()">Next</a>')
            });
            var paginator = new Paginate({
                limit: 20,
                offset: 0,
                count: 100
            });
            var renderer = stache('<next-prev paginate:bind=\'paginator\'></next-prev>');
            var frag = renderer({ paginator: paginator });
            var nextPrev = frag.firstChild;
            var prev = nextPrev.firstChild, next = nextPrev.lastChild;
            ok(!/enabled/.test(prev.className), 'prev is not enabled');
            ok(/enabled/.test(next.className), 'next is enabled');
            domEvents.dispatch(next, 'click');
            ok(/enabled/.test(prev.getAttribute('class')), 'prev is enabled');
        });
        test('page-count', function () {
            Component.extend({
                tag: 'page-count',
                view: stache('Page <span>{{page()}}</span>.')
            });
            var paginator = new Paginate({
                limit: 20,
                offset: 0,
                count: 100
            });
            var renderer = stache('<page-count page:from=\'paginator.page\'></page-count>');
            var frag = renderer(new SimpleMap({ paginator: paginator }));
            var span = frag.firstChild.getElementsByTagName('span')[0];
            equal(span.firstChild.nodeValue, '1');
            paginator.next();
            equal(span.firstChild.nodeValue, '2');
            paginator.next();
            equal(span.firstChild.nodeValue, '3');
        });
        if (System.env !== 'canjs-test') {
            QUnit.test('basic tabs', function () {
                var undo = domEvents.addEvent(insertedEvent);
                var TabsViewModel = DefineMap.extend({
                    active: 'any',
                    panels: { Value: DefineList },
                    addPanel: function (panel) {
                        if (this.panels.length === 0) {
                            this.makeActive(panel);
                        }
                        this.panels.push(panel);
                    },
                    removePanel: function (panel) {
                        var panels = this.panels;
                        queues.batch.start();
                        var index = panels.indexOf(panel);
                        canLog.log(index);
                        panels.splice(index, 1);
                        if (panel === this.active) {
                            if (panels.length) {
                                this.makeActive(panels[0]);
                            } else {
                                this.active = null;
                            }
                        }
                        queues.batch.stop();
                    },
                    makeActive: function (panel) {
                        this.active = panel;
                        this.panels.forEach(function (panel) {
                            panel.active = false;
                        });
                        panel.active = true;
                    },
                    isActive: function (panel) {
                        return this.active === panel;
                    }
                });
                Component.extend({
                    tag: 'tabs',
                    ViewModel: TabsViewModel,
                    view: stache('<ul>' + '{{#panels}}' + '<li {{#../isActive(this)}}class=\'active\'{{/../isActive}} on:click=\'../makeActive(this)\'>{{title}}</li>' + '{{/panels}}' + '</ul>' + '<content></content>')
                });
                Component.extend({
                    view: stache('{{#if active}}<content></content>{{/if}}'),
                    tag: 'panel',
                    ViewModel: DefineMap.extend({ active: { value: false } }),
                    events: {
                        ' inserted': function () {
                            canViewModel(this.element.parentNode).addPanel(this.viewModel);
                        },
                        ' beforeremove': function () {
                            canViewModel(this.element.parentNode).removePanel(this.viewModel);
                        }
                    }
                });
                var renderer = stache('<tabs>{{#each foodTypes}}<panel title:from=\'title\'>{{content}}</panel>{{/each}}</tabs>');
                var foodTypes = new DefineList([
                    {
                        title: 'Fruits',
                        content: 'oranges, apples'
                    },
                    {
                        title: 'Breads',
                        content: 'pasta, cereal'
                    },
                    {
                        title: 'Sweets',
                        content: 'ice cream, candy'
                    }
                ]);
                var frag = renderer({ foodTypes: foodTypes });
                domMutateNode.appendChild.call(this.fixture, frag);
                var testArea = this.fixture;
                stop();
                helpers.runTasks([
                    function () {
                        var lis = testArea.getElementsByTagName('li');
                        equal(lis.length, 3, 'three lis added');
                        foodTypes.forEach(function (type, i) {
                            equal(innerHTML(lis[i]), type.title, 'li ' + i + ' has the right content');
                        });
                        foodTypes.push({
                            title: 'Vegies',
                            content: 'carrots, kale'
                        });
                    },
                    function () {
                        var lis = testArea.getElementsByTagName('li');
                        equal(lis.length, 4, 'li added');
                        foodTypes.forEach(function (type, i) {
                            equal(innerHTML(lis[i]), type.title, 'li ' + i + ' has the right content');
                        });
                        equal(testArea.getElementsByTagName('panel').length, 4, 'panel added');
                        canLog.log('SHIFTY');
                        foodTypes.shift();
                    },
                    function () {
                        var lis = testArea.getElementsByTagName('li');
                        equal(lis.length, 3, 'removed li after shifting a foodType');
                        foodTypes.forEach(function (type, i) {
                            equal(innerHTML(lis[i]), type.title, 'li ' + i + ' has the right content');
                        });
                        var panels = testArea.getElementsByTagName('panel');
                        equal(lis[0].className, 'active', 'the first element is active');
                        equal(innerHTML(panels[0]), 'pasta, cereal', 'the first content is shown');
                        equal(innerHTML(panels[1]), '', 'the second content is removed');
                        domEvents.dispatch(lis[1], 'click');
                        lis = testArea.getElementsByTagName('li');
                        equal(lis[1].className, 'active', 'the second element is active');
                        equal(lis[0].className, '', 'the first element is not active');
                        equal(innerHTML(panels[0]), '', 'the second content is removed');
                        equal(innerHTML(panels[1]), 'ice cream, candy', 'the second content is shown');
                        undo();
                    }
                ]);
            });
        }
    });
});
/*can-component@4.0.1#test/component-slot-test*/
define('can-component@4.0.1#test/component-slot-test', [
    'require',
    'exports',
    'module',
    'can-component',
    'can-stache',
    'steal-qunit',
    'can-define/map/map',
    'can-view-model',
    'can-symbol',
    'can-queues'
], function (require, exports, module) {
    var Component = require('can-component');
    var stache = require('can-stache');
    var QUnit = require('steal-qunit');
    var DefineMap = require('can-define/map/map');
    var viewModel = require('can-view-model');
    var canSymbol = require('can-symbol');
    QUnit.module('can-components - can-slots');
    test('<can-slot> Works', function () {
        var ViewModel = DefineMap.extend({
            subject: { value: 'Hello World' },
            body: { value: 'Later Gator' }
        });
        Component.extend({
            tag: 'my-email',
            view: stache('<can-slot name="subject" />' + '<can-slot name="body" />'),
            ViewModel: ViewModel,
            leakScope: true
        });
        var renderer = stache('<my-email>' + '<can-template name="subject">' + '{{subject}}' + '</can-template>' + '<can-template name="body">' + '{{body}}' + '</can-template>' + '</my-email>');
        var testView = renderer();
        equal(testView.firstChild.childNodes[0].nodeValue, 'Hello World');
        equal(testView.firstChild.childNodes[1].nodeValue, 'Later Gator');
    });
    test('<can-slot> leakScope false acts as expected', function () {
        var ViewModel = DefineMap.extend({
            subject: { value: 'Hello World' },
            body: { value: 'Later Gator' }
        });
        Component.extend({
            tag: 'my-email',
            view: stache('<can-slot name="subject" />' + '<can-slot name="body" />'),
            ViewModel: ViewModel
        });
        var renderer = stache('<my-email>' + '<can-template name="subject">' + '{{subject}}' + '</can-template>' + '<can-template name="body">' + '{{body}}' + '</can-template>' + '</my-email>');
        var testView = renderer({
            subject: 'foo',
            body: 'bar'
        });
        equal(testView.firstChild.childNodes[0].nodeValue, 'foo');
        equal(testView.firstChild.childNodes[1].nodeValue, 'bar');
    });
    test('<can-slot> Re-use templates', function () {
        var ViewModel = DefineMap.extend({
            subject: { value: 'Hello World' },
            body: { value: 'Later Gator' }
        });
        Component.extend({
            tag: 'my-email',
            view: stache('<can-slot name="subject" />' + '<can-slot name="subject" />'),
            ViewModel: ViewModel,
            leakScope: true
        });
        var renderer = stache('<my-email>' + '<can-template name="subject">' + '{{subject}}' + '</can-template>' + '</my-email>');
        var testView = renderer();
        equal(testView.firstChild.childNodes[0].nodeValue, 'Hello World');
        equal(testView.firstChild.childNodes[1].nodeValue, 'Hello World');
    });
    test('<can-slot> Works with default content', function () {
        var ViewModel = DefineMap.extend({});
        Component.extend({
            tag: 'my-email',
            view: stache('<can-slot name="subject">' + 'Default Content' + '</can-slot>'),
            ViewModel: ViewModel
        });
        var renderer = stache('<my-email>' + '<can-template name="subject" />' + '</my-email>');
        var testView = renderer();
        equal(testView.firstChild.innerHTML, 'Default Content');
    });
    test('<can-slot> Works in a self-closing template', function () {
        var ViewModel = DefineMap.extend({});
        Component.extend({
            tag: 'my-email',
            view: stache('<can-slot name="subject">' + 'Default Content' + '</can-slot>'),
            ViewModel: ViewModel
        });
        var renderer = stache('<my-email/>');
        var testView = renderer();
        equal(testView.firstChild.innerHTML, 'Default Content');
    });
    test('<can-slot> Context one-way binding works', function () {
        var ViewModel = DefineMap.extend('MyEmailVM', { subject: { value: 'Hello World' } });
        Component.extend({
            tag: 'my-email',
            view: stache('<can-slot name="foo" this:from="subject" />'),
            ViewModel: ViewModel
        });
        var renderer = stache('<my-email>' + '<can-template name="foo"><span>{{this}}</span></can-template>' + '</my-email>');
        var frag = renderer();
        var vm = viewModel(frag.firstChild);
        equal(frag.firstChild.firstChild.innerHTML, 'Hello World');
        vm.subject = 'Later Gator';
        equal(frag.firstChild.firstChild.innerHTML, 'Later Gator');
    });
    var queues = require('can-queues');
    test('<can-slot> Context two-way binding works', function () {
        var ViewModel = DefineMap.extend('MyEmailVM', {}, { subject: { value: 'Hello World' } });
        Component.extend({
            tag: 'my-email',
            view: stache('<can-slot name="foo" this:bind="subject" />'),
            ViewModel: ViewModel
        });
        Component.extend({
            tag: 'my-subject',
            view: stache('{{subject}}'),
            ViewModel: DefineMap.extend('SubjectVM')
        });
        var renderer = stache('<my-email>' + '<can-template name="foo"><my-subject subject:bind="this" /></can-template>' + '</my-email>');
        var frag = renderer();
        var vm = viewModel(frag.firstChild);
        var childVM = viewModel(frag.firstChild.firstChild);
        equal(frag.firstChild.firstChild.innerHTML, 'Hello World');
        vm.subject = 'Later Gator';
        equal(frag.firstChild.firstChild.innerHTML, 'Later Gator');
        childVM.subject = 'After a while crocodile';
        equal(vm.subject, 'After a while crocodile');
    });
    test('<can-slot> Context child-to-parent binding works', function () {
        var ViewModel = DefineMap.extend({ subject: { value: 'Hello World' } });
        Component.extend({
            tag: 'my-email',
            view: stache('<can-slot name="foo" this:to="subject" />'),
            ViewModel: ViewModel
        });
        Component.extend({
            tag: 'my-subject',
            view: stache('{{subject}}'),
            ViewModel: DefineMap.extend({ subject: { value: 'Yo' } })
        });
        var renderer = stache('<my-email>' + '<can-template name="foo"><my-subject subject:to="this" /></can-template>' + '</my-email>');
        var frag = renderer();
        var vm = viewModel(frag.firstChild);
        var childVM = viewModel(frag.firstChild.firstChild);
        equal(frag.firstChild.firstChild.innerHTML, 'Yo');
        childVM.subject = 'bar';
        equal(frag.firstChild.firstChild.innerHTML, 'bar');
        equal(vm.subject, 'bar');
    });
    test('<can-slot> Works alongside <content>', function () {
        var ViewModel = DefineMap.extend({
            subject: { value: 'Hello World' },
            body: { value: 'Later Gator' }
        });
        Component.extend({
            tag: 'my-email',
            view: stache('<can-slot name="subject" />' + '<content />'),
            ViewModel: ViewModel,
            leakScope: true
        });
        var renderer = stache('<my-email>' + '<can-template name="subject">' + '<p>{{subject}}</p>' + '</can-template>' + '<span>Some content</span>' + '</my-email>');
        var testView = renderer();
        equal(testView.firstChild.childNodes[0].firstChild.nodeValue, 'Hello World');
        equal(testView.firstChild.childNodes[1].firstChild.nodeValue, 'Some content');
    });
    test('<can-slot> Works alongside <content> with default content', function () {
        var ViewModel = DefineMap.extend({
            subject: { value: 'Hello World' },
            body: { value: 'Later Gator' }
        });
        Component.extend({
            tag: 'my-email',
            view: stache('<can-slot name="subject" />' + '<content>Default content</content>'),
            ViewModel: ViewModel,
            leakScope: true
        });
        var renderer = stache('<my-email>' + '<can-template name="subject">' + '<p>{{subject}}</p>' + '</can-template>' + '</my-email>');
        var testView = renderer();
        equal(testView.firstChild.childNodes[0].firstChild.nodeValue, 'Hello World');
        equal(testView.firstChild.childNodes[1].nodeValue, 'Default content');
    });
    test('<can-slot> Can be used conditionally and will remove bindings', function () {
        var ViewModel = DefineMap.extend('MyEmailVM', {
            subject: { value: 'Hello World' },
            showSubject: { value: true }
        });
        Component.extend({
            tag: 'my-email',
            view: stache('{{#if showSubject}}<can-slot name="subject" this:from="subject" />{{/if}}'),
            ViewModel: ViewModel
        });
        var renderer = stache('<my-email>' + '<can-template name="subject">' + '<p>{{this}}</p>' + '</can-template>' + '</my-email>');
        var testView = renderer();
        equal(testView.firstChild.firstChild.firstChild.nodeValue, 'Hello World');
        var vm = viewModel(testView.firstChild);
        vm.showSubject = false;
        QUnit.stop();
        QUnit.equal(testView.firstChild.children.length, 0);
        setTimeout(function () {
            var handlers = vm[canSymbol.for('can.meta')].handlers;
            QUnit.equal(handlers.get(['subject']).length, 0);
            QUnit.start();
        }, 50);
    });
});
/*can-component@4.0.1#test/component-define-test*/
define('can-component@4.0.1#test/component-define-test', [
    'require',
    'exports',
    'module',
    'can-component',
    'can-stache',
    'steal-qunit',
    'can-define',
    'can-define/map/map',
    'can-view-model',
    'can-util/js/dev/dev'
], function (require, exports, module) {
    var Component = require('can-component');
    var stache = require('can-stache');
    var QUnit = require('steal-qunit');
    var define = require('can-define');
    var DefineMap = require('can-define/map/map');
    var viewModel = require('can-view-model');
    var canDev = require('can-util/js/dev/dev');
    QUnit.module('can-component with can-define');
    QUnit.test('Works with can-define', function () {
        var VM = define.Constructor({
            firstName: { type: 'string' },
            lastName: { type: 'string' },
            fullName: {
                get: function () {
                    return [
                        this.firstName,
                        this.lastName
                    ].join(' ');
                }
            }
        });
        Component.extend({
            tag: 'can-define-component',
            ViewModel: VM,
            view: stache('Name: {{fullName}}')
        });
        var frag = stache('<can-define-component firstName:from="firstName" lastName:from="lastName" />')({
            firstName: 'Chris',
            lastName: 'Gomez'
        });
        var vm = viewModel(frag.firstChild);
        QUnit.ok(vm instanceof VM, 'Constructor was called');
        QUnit.equal(vm.firstName, 'Chris', 'ViewModel was set from scope');
        QUnit.equal(vm.lastName, 'Gomez', 'ViewModel was set from scope');
        QUnit.equal(frag.firstChild.innerHTML, 'Name: Chris Gomez', 'Rendered fullName');
        vm.firstName = 'Justin';
        vm.lastName = 'Meyer';
        QUnit.equal(frag.firstChild.innerHTML, 'Name: Justin Meyer', 'Rendered fullName after change');
    });
    QUnit.test('scope method works', function () {
        Component.extend({
            tag: 'my-element',
            viewModel: function (properties, scope, element) {
                QUnit.deepEqual(properties, {
                    first: 'Justin',
                    last: 'Meyer'
                });
                return new DefineMap(properties);
            }
        });
        stache('<my-element first:from=\'firstName\' last:from=\'"Meyer"\'/>')({
            firstName: 'Justin',
            middleName: 'Barry'
        });
    });
    QUnit.test('33 - works when instantiated with an object for ViewModel', function () {
        Component.extend({
            tag: 'test-element',
            view: stache('{{someMethod()}}'),
            ViewModel: {
                someMethod: function () {
                    ok(true, 'Function got called');
                    return true;
                }
            }
        });
        var renderer = stache('<test-element>');
        renderer();
    });
    QUnit.test('helpers do not leak when leakscope is false (#77)', function () {
        var called = 0;
        Component.extend({
            tag: 'inner-el',
            view: stache('inner{{test}}'),
            leakScope: false
        });
        Component.extend({
            tag: 'outer-el',
            view: stache('outer:<inner-el>'),
            helpers: {
                test: function () {
                    called++;
                    return 'heyo';
                }
            }
        });
        var renderer = stache('<outer-el>');
        renderer();
        QUnit.equal(called, 0, 'Outer helper not called');
    });
    QUnit.test('helpers do leak when leakscope is true (#77)', function () {
        var called = 0;
        Component.extend({
            tag: 'inner-el',
            view: stache('inner{{../test()}}'),
            leakScope: true
        });
        Component.extend({
            tag: 'outer-el',
            view: stache('outer:<inner-el/>'),
            helpers: {
                test: function () {
                    called++;
                    return 'heyo';
                }
            }
        });
        var renderer = stache('<outer-el/>');
        renderer();
        QUnit.equal(called, 1, 'Outer helper called once');
    });
    if (System.env.indexOf('production') < 0) {
        QUnit.test('warn if viewModel is assigned a DefineMap (#14)', function () {
            QUnit.expect(1);
            var oldwarn = canDev.warn;
            canDev.warn = function (mesg) {
                QUnit.equal(mesg, 'can-component: Assigning a DefineMap or constructor type to the viewModel property may not be what you intended. Did you mean ViewModel instead? More info: https://canjs.com/doc/can-component.prototype.ViewModel.html', 'Warning is expected message');
            };
            var VM = DefineMap.extend({});
            Component.extend({
                tag: 'can-vm1-test-component',
                viewModel: VM
            });
            Component.extend({
                tag: 'can-vm2-test-component',
                viewModel: function () {
                }
            });
            canDev.warn = oldwarn;
        });
    }
    QUnit.test('ViewModel defaults to DefineMap if set to an Object', function () {
        Component.extend({
            tag: 'can-define-component',
            ViewModel: {
                firstName: { type: 'string' },
                lastName: { type: 'string' },
                fullName: {
                    get: function () {
                        return [
                            this.firstName,
                            this.lastName
                        ].join(' ');
                    }
                }
            },
            view: stache('Name: {{fullName}}')
        });
        var frag = stache('<can-define-component firstName:from="firstName" lastName:from="lastName" />')({
            firstName: 'Chris',
            lastName: 'Gomez'
        });
        var vm = viewModel(frag.firstChild);
        QUnit.ok(vm instanceof DefineMap, 'vm is a DefineMap');
        QUnit.equal(vm.firstName, 'Chris', 'ViewModel was set from scope');
        QUnit.equal(vm.lastName, 'Gomez', 'ViewModel was set from scope');
        QUnit.equal(frag.firstChild.innerHTML, 'Name: Chris Gomez', 'Rendered fullName');
        vm.firstName = 'Justin';
        vm.lastName = 'Meyer';
        QUnit.equal(frag.firstChild.innerHTML, 'Name: Justin Meyer', 'Rendered fullName after change');
    });
});
/*can-component@4.0.1#test/tests*/
define('can-component@4.0.1#test/tests', [
    'require',
    'exports',
    'module',
    './component-tag-test',
    './component-viewmodel-test',
    './component-viewmodel-observe-test',
    './component-view-test',
    './component-helpers-test',
    './component-events-test',
    './example-test',
    './component-slot-test',
    './component-define-test'
], function (require, exports, module) {
    require('./component-tag-test');
    require('./component-viewmodel-test');
    require('./component-viewmodel-observe-test');
    require('./component-view-test');
    require('./component-helpers-test');
    require('./component-events-test');
    require('./example-test');
    require('./component-slot-test');
    require('./component-define-test');
});
/*can-util@3.11.2#js/global/global*/
define('can-util@3.11.2#js/global/global', [
    'require',
    'exports',
    'module',
    'can-globals/global/global'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        'use strict';
        module.exports = require('can-globals/global/global');
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-test-helpers@1.1.1#lib/dev*/
define('can-test-helpers@1.1.1#lib/dev', [
    'require',
    'exports',
    'module',
    'can-log/dev/dev',
    'can-util/js/make-array/make-array',
    'can-util/js/global/global'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        var dev = require('can-log/dev/dev');
        var makeArray = require('can-util/js/make-array/make-array');
        var GLOBAL = require('can-util/js/global/global');
        function makeExpectation(type) {
            var original;
            var expectedResults = [];
            function stubbed() {
                var message = makeArray(arguments).map(function (token) {
                    if (typeof token !== 'string' && token.message) {
                        return token.message;
                    } else {
                        return token;
                    }
                }).join(' ');
                expectedResults.forEach(function (expected) {
                    var matched = typeof expected.source === 'string' ? message === expected.source : expected.source.test(message);
                    if (matched) {
                        expected.count++;
                    }
                    if (typeof expected.fn === 'function') {
                        expected.fn.call(null, message, matched);
                    }
                });
            }
            return function (expected, fn) {
                var matchData = {
                    source: expected,
                    fn: fn,
                    count: 0
                };
                expectedResults.push(matchData);
                if (!original) {
                    original = dev[type];
                    dev[type] = stubbed;
                }
                return function () {
                    expectedResults.splice(expectedResults.indexOf(matchData), 1);
                    if (original && expectedResults.length < 1) {
                        dev[type] = original;
                        original = null;
                    }
                    return matchData.count;
                };
            };
        }
        module.exports = {
            willWarn: makeExpectation('warn'),
            willError: makeExpectation('error'),
            devOnlyTest: function () {
                var global = GLOBAL();
                if (!global.System || !global.System.env || global.System.env.indexOf('production') < 0) {
                    global.test.apply(null, arguments);
                }
            }
        };
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-test-helpers@1.1.1#can-test-helpers*/
define('can-test-helpers@1.1.1#can-test-helpers', [
    'require',
    'exports',
    'module',
    'can-test-helpers/lib/dev'
], function (require, exports, module) {
    var dev = require('can-test-helpers/lib/dev');
    module.exports = { dev: dev };
});
/*can-define@2.0.1#test/test-define-only*/
define('can-define@2.0.1#test/test-define-only', [
    'require',
    'exports',
    'module',
    'steal-qunit',
    'can-define',
    'can-queues',
    'can-util/js/each/each',
    'can-symbol',
    'can-simple-observable',
    'can-test-helpers'
], function (require, exports, module) {
    var QUnit = require('steal-qunit');
    var define = require('can-define');
    var queues = require('can-queues');
    var each = require('can-util/js/each/each');
    var canSymbol = require('can-symbol');
    var SimpleObservable = require('can-simple-observable');
    var testHelpers = require('can-test-helpers');
    QUnit.module('can-define');
    QUnit.test('basics on a prototype', 5, function () {
        var Person = function (first, last) {
            this.first = first;
            this.last = last;
        };
        define(Person.prototype, {
            first: '*',
            last: '*',
            fullName: {
                get: function () {
                    return this.first + ' ' + this.last;
                }
            }
        });
        var p = new Person('Mohamed', 'Cherif');
        p.bind('fullName', function (ev, newVal, oldVal) {
            QUnit.equal(oldVal, 'Mohamed Cherif');
            QUnit.equal(newVal, 'Justin Meyer');
        });
        equal(p.fullName, 'Mohamed Cherif', 'fullName initialized right');
        p.bind('first', function (el, newVal, oldVal) {
            QUnit.equal(newVal, 'Justin', 'first new value');
            QUnit.equal(oldVal, 'Mohamed', 'first old value');
        });
        queues.batch.start();
        p.first = 'Justin';
        p.last = 'Meyer';
        queues.batch.stop();
    });
    QUnit.test('basics set', 2, function () {
        var Defined = function (prop) {
            this.prop = prop;
        };
        define(Defined.prototype, {
            prop: {
                set: function (newVal) {
                    return 'foo' + newVal;
                }
            }
        });
        var def = new Defined();
        def.prop = 'bar';
        QUnit.equal(def.prop, 'foobar', 'setter works');
        var DefinedCB = function (prop) {
            this.prop = prop;
        };
        define(DefinedCB.prototype, {
            prop: {
                set: function (newVal, setter) {
                    setter('foo' + newVal);
                }
            }
        });
        var defCallback = new DefinedCB();
        defCallback.prop = 'bar';
        QUnit.equal(defCallback.prop, 'foobar', 'setter callback works');
    });
    QUnit.test('basic Type', function () {
        var Foo = function (name) {
            this.name = name;
        };
        Foo.prototype.getName = function () {
            return this.name;
        };
        var Typer = function (foo) {
            this.foo = foo;
        };
        define(Typer.prototype, { foo: { Type: Foo } });
        var t = new Typer('Justin');
        QUnit.equal(t.foo.getName(), 'Justin', 'correctly created an instance');
        var brian = new Foo('brian');
        t.foo = brian;
        QUnit.equal(t.foo, brian, 'same instances');
    });
    QUnit.test('type converters', function () {
        var Typer = function (date, string, number, bool, htmlbool, leaveAlone) {
            this.date = date;
            this.string = string;
            this.number = number;
            this.bool = bool;
            this.htmlbool = htmlbool;
            this.leaveAlone = leaveAlone;
        };
        define(Typer.prototype, {
            date: { type: 'date' },
            string: { type: 'string' },
            number: { type: 'number' },
            bool: { type: 'boolean' },
            htmlbool: { type: 'htmlbool' },
            leaveAlone: { type: '*' }
        });
        var obj = {};
        var t = new Typer(1395896701516, 5, '5', 'false', '', obj);
        QUnit.ok(t.date instanceof Date, 'converted to date');
        QUnit.equal(t.string, '5', 'converted to string');
        QUnit.equal(t.number, 5, 'converted to number');
        QUnit.equal(t.bool, false, 'converted to boolean');
        QUnit.equal(t.htmlbool, true, 'converted to htmlbool');
        QUnit.equal(t.leaveAlone, obj, 'left as object');
        t.number = '15';
        QUnit.ok(t.number === 15, 'converted to number');
    });
    QUnit.test('basics value', function () {
        var Typer = function (prop) {
            if (prop !== undefined) {
                this.prop = prop;
            }
        };
        define(Typer.prototype, { prop: { default: 'foo' } });
        var t = new Typer();
        QUnit.equal(t.prop, 'foo', 'value is used as default value');
        var Typer2 = function (prop) {
            if (prop !== undefined) {
                this.prop = prop;
            }
        };
        define(Typer2.prototype, {
            prop: {
                default: function () {
                    return [];
                },
                type: '*'
            }
        });
        var t1 = new Typer2(), t2 = new Typer2();
        QUnit.ok(t1.prop !== t2.prop, 'different array instances');
        QUnit.ok(Array.isArray(t1.prop), 'its an array');
    });
    test('basics Value', function () {
        var Typer = function (prop) {
        };
        define(Typer.prototype, {
            prop: {
                Default: Array,
                type: '*'
            }
        });
        var t1 = new Typer(), t2 = new Typer();
        QUnit.ok(t1.prop !== t2.prop, 'different array instances');
        QUnit.ok(Array.isArray(t1.prop), 'its an array');
    });
    test('setter with no arguments and returns undefined does the default behavior, the setter is for side effects only', function () {
        var Typer = function (prop) {
        };
        define(Typer.prototype, {
            prop: {
                set: function () {
                    this.foo = 'bar';
                }
            },
            foo: '*'
        });
        var t = new Typer();
        t.prop = false;
        deepEqual({
            foo: t.foo,
            prop: t.prop
        }, {
            foo: 'bar',
            prop: false
        }, 'got the right props');
    });
    test('type happens before the set', 2, function () {
        var Typer = function () {
        };
        define(Typer.prototype, {
            prop: {
                type: 'number',
                set: function (newValue) {
                    equal(typeof newValue, 'number', 'got a number');
                    return newValue + 1;
                }
            }
        });
        var map = new Typer();
        map.prop = '5';
        equal(map.prop, 6, 'number');
    });
    test('getter and setter work', function () {
        expect(5);
        var Paginate = define.Constructor({
            limit: '*',
            offset: '*',
            page: {
                set: function (newVal) {
                    this.offset = (parseInt(newVal) - 1) * this.limit;
                },
                get: function () {
                    return Math.floor(this.offset / this.limit) + 1;
                }
            }
        });
        var p = new Paginate({
            limit: 10,
            offset: 20
        });
        equal(p.page, 3, 'page get right');
        p.bind('page', function (ev, newValue, oldValue) {
            equal(newValue, 2, 'got new value event');
            equal(oldValue, 3, 'got old value event');
        });
        p.page = 2;
        equal(p.page, 2, 'page set right');
        equal(p.offset, 10, 'page offset set');
    });
    test('getter with initial value', function () {
        var comp = new SimpleObservable(1);
        var Grabber = define.Constructor({
            vals: {
                type: '*',
                Default: Array,
                get: function (current, setVal) {
                    if (setVal) {
                        current.push(comp.get());
                    }
                    return current;
                }
            }
        });
        var g = new Grabber();
        equal(g.vals.length, 0, 'zero items in array');
    });
    test('default behaviors with "*" work for attributes', function () {
        expect(6);
        var DefaultMap = define.Constructor({
            '*': {
                type: 'number',
                set: function (newVal) {
                    ok(true, 'set called');
                    return newVal;
                }
            },
            someNumber: { default: '5' },
            number: {}
        });
        var map = new DefaultMap();
        equal(map.someNumber, '5', 'default values are not type converted anymore');
        map.someNumber = '5';
        equal(map.someNumber, 5, 'on a set, they should be type converted');
        map.number = '10';
        equal(map.number, 10, 'value of number should be converted to a number');
    });
    test('nested define', function () {
        var nailedIt = 'Nailed it';
        var Example = define.Constructor({ name: { default: nailedIt } });
        var NestedMap = define.Constructor({
            isEnabled: { default: true },
            test: { Default: Example },
            examples: {
                type: {
                    one: { Default: Example },
                    two: {
                        type: { deep: { Default: Example } },
                        Default: Object
                    }
                },
                Default: Object
            }
        });
        var nested = new NestedMap();
        equal(nested.test.name, nailedIt);
        equal(nested.examples.one.name, nailedIt);
        equal(nested.examples.two.deep.name, nailedIt);
        ok(nested.test instanceof Example);
        ok(nested.examples.one instanceof Example);
        ok(nested.examples.two.deep instanceof Example);
    });
    test('Can make an attr alias a compute (#1470)', 9, function () {
        var computeValue = new SimpleObservable(1);
        var GetMap = define.Constructor({
            value: {
                set: function (newValue, setVal, oldValue) {
                    if (newValue instanceof SimpleObservable) {
                        return newValue;
                    }
                    if (oldValue && oldValue instanceof SimpleObservable) {
                        oldValue.set(newValue);
                        return oldValue;
                    }
                    return newValue;
                },
                get: function (value) {
                    return value instanceof SimpleObservable ? value.get() : value;
                }
            }
        });
        var getMap = new GetMap();
        getMap.value = computeValue;
        equal(getMap.value, 1, 'initial value read from compute');
        var bindCallbacks = 0;
        getMap.bind('value', function (ev, newVal, oldVal) {
            switch (bindCallbacks) {
            case 0:
                equal(newVal, 2, '0 - bind called with new val');
                equal(oldVal, 1, '0 - bind called with old val');
                break;
            case 1:
                equal(newVal, 3, '1 - bind called with new val');
                equal(oldVal, 2, '1 - bind called with old val');
                break;
            case 2:
                equal(newVal, 4, '2 - bind called with new val');
                equal(oldVal, 3, '2 - bind called with old val');
                break;
            }
            bindCallbacks++;
        });
        computeValue.set(2);
        getMap.value = 3;
        equal(getMap.value, 3, 'read value is 3');
        equal(computeValue.get(), 3, 'the compute value is 3');
        var newComputeValue = new SimpleObservable(4);
        getMap.value = newComputeValue;
    });
    test('One event on getters (#1585)', function () {
        var Person = define.Constructor({
            name: '*',
            id: 'number'
        });
        var AppState = define.Constructor({
            person: {
                get: function appState_person_get(lastSetValue, resolve) {
                    if (lastSetValue) {
                        return lastSetValue;
                    } else if (this.personId) {
                        resolve(new Person({
                            name: 'Jose',
                            id: 5
                        }));
                    } else {
                        return null;
                    }
                },
                Type: Person
            },
            personId: '*'
        });
        var appState = new AppState();
        var personEvents = 0;
        appState.bind('person', function addPersonEvents(ev, person) {
            personEvents++;
        });
        equal(appState.person, null, 'no personId and no lastSetValue');
        appState.personId = 5;
        equal(appState.person.name, 'Jose', 'a personId, providing Jose');
        ok(appState.person instanceof Person, 'got a person instance');
        appState.person = { name: 'Julia' };
        ok(appState.person instanceof Person, 'got a person instance');
        equal(personEvents, 2);
    });
    test('Can read a defined property with a set/get method (#1648)', function () {
        var Map = define.Constructor({
            foo: {
                default: '',
                set: function (setVal) {
                    return setVal;
                },
                get: function (lastSetVal) {
                    return lastSetVal;
                }
            }
        });
        var map = new Map();
        equal(map.foo, '', 'Calling .foo returned the correct value');
        map.foo = 'baz';
        equal(map.foo, 'baz', 'Calling .foo returned the correct value');
    });
    test('Can bind to a defined property with a set/get method (#1648)', 3, function () {
        var Map = define.Constructor({
            foo: {
                default: '',
                set: function (setVal) {
                    return setVal;
                },
                get: function (lastSetVal) {
                    return lastSetVal;
                }
            }
        });
        var map = new Map();
        map.bind('foo', function () {
            ok(true, 'Bound function is called');
        });
        equal(map.foo, '', 'Calling .attr(\'foo\') returned the correct value');
        map.foo = 'baz';
        equal(map.foo, 'baz', 'Calling .attr(\'foo\') returned the correct value');
    });
    test('type converters handle null and undefined in expected ways (1693)', function () {
        var Typer = define.Constructor({
            date: { type: 'date' },
            string: { type: 'string' },
            number: { type: 'number' },
            'boolean': { type: 'boolean' },
            htmlbool: { type: 'htmlbool' },
            leaveAlone: { type: '*' }
        });
        var t = new Typer({
            date: undefined,
            string: undefined,
            number: undefined,
            'boolean': undefined,
            htmlbool: undefined,
            leaveAlone: undefined
        });
        equal(t.date, undefined, 'converted to date');
        equal(t.string, undefined, 'converted to string');
        equal(t.number, undefined, 'converted to number');
        equal(t.boolean, undefined, 'converted to boolean');
        equal(t.htmlbool, false, 'converted to htmlbool');
        equal(t.leaveAlone, undefined, 'left as object');
        t = new Typer({
            date: null,
            string: null,
            number: null,
            'boolean': null,
            htmlbool: null,
            leaveAlone: null
        });
        equal(t.date, null, 'converted to date');
        equal(t.string, null, 'converted to string');
        equal(t.number, null, 'converted to number');
        equal(t.boolean, null, 'converted to boolean');
        equal(t.htmlbool, false, 'converted to htmlbool');
        equal(t.leaveAlone, null, 'left as object');
    });
    test('Initial value does not call getter', function () {
        expect(0);
        var Map = define.Constructor({
            count: {
                get: function (lastVal) {
                    ok(false, 'Should not be called');
                    return lastVal;
                }
            }
        });
        new Map({ count: 100 });
    });
    test('getters produce change events', function () {
        var Map = define.Constructor({
            count: {
                get: function (lastVal) {
                    return lastVal;
                }
            }
        });
        var map = new Map();
        map.bind('count', function () {
            ok(true, 'change called');
        });
        map.count = 22;
    });
    test('Asynchronous virtual properties cause extra recomputes (#1915)', function () {
        stop();
        var ran = false;
        var VM = define.Constructor({
            foo: {
                get: function (lastVal, setVal) {
                    setTimeout(function () {
                        if (setVal) {
                            setVal(5);
                        }
                    }, 10);
                }
            },
            bar: {
                get: function () {
                    var foo = this.foo;
                    if (foo) {
                        if (ran) {
                            ok(false, 'Getter ran twice');
                        }
                        ran = true;
                        return foo * 2;
                    }
                }
            }
        });
        var vm = new VM();
        vm.bind('bar', function () {
        });
        setTimeout(function () {
            equal(vm.bar, 10);
            start();
        }, 200);
    });
    QUnit.test('Default values cannot be set (#8)', function () {
        var Person = function () {
        };
        define(Person.prototype, {
            first: {
                type: 'string',
                default: 'Chris'
            },
            last: {
                type: 'string',
                default: 'Gomez'
            },
            fullName: {
                get: function () {
                    return this.first + ' ' + this.last;
                }
            }
        });
        var p = new Person();
        QUnit.equal(p.fullName, 'Chris Gomez', 'Fullname is correct');
        p.first = 'Sara';
        QUnit.equal(p.fullName, 'Sara Gomez', 'Fullname is correct after update');
    });
    QUnit.test('default type is setable', function () {
        var Person = function () {
        };
        define(Person.prototype, {
            '*': 'string',
            first: { default: 1 },
            last: { default: 2 }
        });
        var p = new Person();
        QUnit.ok(p.first === '1', typeof p.first);
        QUnit.ok(p.last === '2', typeof p.last);
    });
    QUnit.test('expandos are added in define.setup (#25)', function () {
        var MyMap = define.Constructor({});
        var map = new MyMap({ prop: 4 });
        map.on('prop', function () {
            QUnit.ok(true, 'prop event called');
        });
        map.prop = 5;
    });
    QUnit.test('Set property with type compute', function () {
        var MyMap = define.Constructor({ computeProp: { type: 'compute' } });
        var m = new MyMap();
        m.computeProp = new SimpleObservable(0);
        equal(m.computeProp, 0, 'Property has correct value');
        m.computeProp = new SimpleObservable(1);
        equal(m.computeProp, 1, 'Property has correct value');
    });
    QUnit.test('Compute type property can have a default value', function () {
        var MyMap = define.Constructor({
            computeProp: {
                type: 'compute',
                default: function () {
                    return 0;
                }
            }
        });
        var m = new MyMap();
        equal(m.computeProp, 0, 'Property has correct value');
        m.computeProp = 1;
        equal(m.computeProp, 1, 'Property has correct value');
    });
    QUnit.test('Compute type property with compute default value triggers change events when updated', function () {
        var expected = 0;
        var c = new SimpleObservable(0);
        var MyMap = define.Constructor({
            computeProp: {
                type: 'compute',
                default: function () {
                    return c;
                }
            }
        });
        var m = new MyMap();
        c.on(function (newVal) {
            equal(newVal, expected, 'Compute fired change event');
        });
        m.on('computeProp', function (ev, newVal) {
            equal(newVal, expected, 'Map fired change event');
        });
        expected = 1;
        m.computeProp = expected;
        expected = 2;
        c.set(expected);
    });
    QUnit.test('Compute type property can have a default value that is a compute', function () {
        var c = new SimpleObservable(0);
        var MyMap = define.Constructor({
            computeProp: {
                type: 'compute',
                default: function () {
                    return c;
                }
            }
        });
        var m = new MyMap();
        equal(m.computeProp, 0, 'Property has correct value');
        c.set(1);
        equal(m.computeProp, 1, 'Property has correct value');
    });
    QUnit.test('Extensions can modify definitions', function () {
        var oldExtensions = define.extensions;
        define.behaviors.push('extended');
        define.extensions = function (objPrototype, prop, definition) {
            if (definition.extended) {
                return { default: 'extended' };
            }
        };
        var MyMap = define.Constructor({
            foo: {
                default: 'defined',
                extended: true
            },
            bar: { default: 'defined' }
        });
        var map = new MyMap();
        QUnit.equal(map.foo, 'extended', 'Value was set via extension');
        QUnit.equal(map.bar, 'defined', 'Value was set via definition');
        define.extensions = oldExtensions;
    });
    QUnit.test('Properties are enumerable', function () {
        QUnit.expect(4);
        function VM(foo) {
            this.foo = foo;
        }
        define(VM.prototype, { foo: 'string' });
        var vm = new VM('bar');
        vm.baz = 'qux';
        var i = 0;
        each(vm, function (value, key) {
            if (i === 0) {
                QUnit.equal(key, 'foo');
                QUnit.equal(value, 'bar');
            } else {
                QUnit.equal(key, 'baz');
                QUnit.equal(value, 'qux');
            }
            i++;
        });
    });
    QUnit.test('Doesn\'t override canSymbol.iterator if already on the prototype', function () {
        function MyMap() {
        }
        MyMap.prototype[canSymbol.iterator || canSymbol.for('iterator')] = function () {
            var i = 0;
            return {
                next: function () {
                    if (i === 0) {
                        i++;
                        return {
                            value: [
                                'it',
                                'worked'
                            ],
                            done: false
                        };
                    }
                    return {
                        value: undefined,
                        done: true
                    };
                }
            };
        };
        define(MyMap.prototype, { foo: 'string' });
        var map = new MyMap();
        map.foo = 'bar';
        each(map, function (value, key) {
            QUnit.equal(value, 'worked');
            QUnit.equal(key, 'it');
        });
    });
    QUnit.test('nullish values are not converted for type or Type', function (assert) {
        var Foo = function () {
        };
        var MyMap = define.Constructor({
            map: { Type: Foo },
            notype: {}
        });
        var vm = new MyMap({
            map: {},
            notype: {}
        });
        assert.ok(vm.map instanceof Foo, 'map is another type');
        assert.ok(vm.notype instanceof Object, 'notype is an Object');
        vm.map = null;
        vm.notype = null;
        assert.equal(vm.map, null, 'map is null');
        assert.equal(vm.map, null, 'notype is null');
    });
    QUnit.test('shorthand getter (#56)', function () {
        var Person = function (first, last) {
            this.first = first;
            this.last = last;
        };
        define(Person.prototype, {
            first: '*',
            last: '*',
            get fullName() {
                return this.first + ' ' + this.last;
            }
        });
        var p = new Person('Mohamed', 'Cherif');
        p.on('fullName', function (ev, newVal, oldVal) {
            QUnit.equal(oldVal, 'Mohamed Cherif');
            QUnit.equal(newVal, 'Justin Meyer');
        });
        equal(p.fullName, 'Mohamed Cherif', 'fullName initialized right');
        queues.batch.start();
        p.first = 'Justin';
        p.last = 'Meyer';
        queues.batch.stop();
    });
    QUnit.test('shorthand getter setter (#56)', function () {
        var Person = function (first, last) {
            this.first = first;
            this.last = last;
        };
        define(Person.prototype, {
            first: '*',
            last: '*',
            get fullName() {
                return this.first + ' ' + this.last;
            },
            set fullName(newVal) {
                var parts = newVal.split(' ');
                this.first = parts[0];
                this.last = parts[1];
            }
        });
        var p = new Person('Mohamed', 'Cherif');
        p.on('fullName', function (ev, newVal, oldVal) {
            QUnit.equal(oldVal, 'Mohamed Cherif');
            QUnit.equal(newVal, 'Justin Meyer');
        });
        equal(p.fullName, 'Mohamed Cherif', 'fullName initialized right');
        p.fullName = 'Justin Meyer';
    });
    QUnit.test('set and value work together (#87)', function () {
        var Type = define.Constructor({
            prop: {
                default: 2,
                set: function (num) {
                    return num * num;
                }
            }
        });
        var instance = new Type();
        QUnit.equal(instance.prop, 4, 'used setter');
    });
    QUnit.test('async setter is provided', 5, function () {
        var RESOLVE;
        var Type = define.Constructor({
            prop: {
                default: 2,
                set: function (num, resolve) {
                    resolve(num * num);
                }
            },
            prop2: {
                default: 3,
                set: function (num, resolve) {
                    RESOLVE = resolve;
                }
            }
        });
        var instance = new Type();
        QUnit.equal(instance.prop, 4, 'used async setter');
        QUnit.equal(instance.prop2, undefined, 'used async setter');
        instance.on('prop2', function (ev, newVal, oldVal) {
            QUnit.equal(newVal, 9, 'updated');
            QUnit.equal(oldVal, undefined, 'updated');
        });
        RESOLVE(9);
        QUnit.equal(instance.prop2, 9, 'used async setter updates after');
    });
    QUnit.test('setter with default value causes an infinite loop (#142)', function () {
        var A = define.Constructor({
            val: {
                default: 'hello',
                set: function (val) {
                    if (this.val) {
                    }
                    return val;
                }
            }
        });
        var a = new A();
        QUnit.equal(a.val, 'hello', 'creating an instance should not cause an inifinte loop');
    });
    QUnit.test('defined properties are configurable', function () {
        var A = define.Constructor({
            val: {
                get: function () {
                    return 'foo';
                }
            }
        });
        var dataInitializers = A.prototype._define.dataInitializers, computedInitializers = A.prototype._define.computedInitializers;
        var newDefinition = {
            get: function () {
                return 'bar';
            }
        };
        define.property(A.prototype, 'val', newDefinition, dataInitializers, computedInitializers);
        var a = new A();
        QUnit.equal(a.val, 'bar', 'It was redefined');
    });
    testHelpers.dev.devOnlyTest('Setting a value with only a get() generates a warning (#202)', function () {
        QUnit.expect(7);
        var message = 'can-define: Set value for property derivedProp ignored, as its definition has a zero-argument getter and no setter';
        var finishErrorCheck = testHelpers.dev.willWarn(message, function (actualMessage, success) {
            QUnit.equal(actualMessage, message, 'Warning is expected message');
            QUnit.ok(success);
        });
        var VM = function () {
        };
        define(VM.prototype, {
            derivedProp: {
                get: function () {
                    return 'Hello World';
                }
            }
        });
        var vm = new VM();
        vm.on('derivedProp', function () {
        });
        vm.derivedProp = 'prop is set';
        QUnit.equal(vm.derivedProp, 'Hello World', 'Getter value is preserved');
        VM.shortName = 'VM';
        QUnit.equal(finishErrorCheck(), 1);
        message = 'can-define: Set value for property derivedProp on VM ignored, as its definition has a zero-argument getter and no setter';
        finishErrorCheck = testHelpers.dev.willWarn(message, function (actualMessage, success) {
            QUnit.equal(actualMessage, message, 'Warning is expected message');
            QUnit.ok(success);
        });
        vm.derivedProp = 'prop is set';
        QUnit.equal(finishErrorCheck(), 1);
    });
    testHelpers.dev.devOnlyTest('warn on using a Constructor for small-t type definintions', function () {
        QUnit.expect(2);
        var message = 'can-define: the definition for currency uses a constructor for "type". Did you mean "Type"?';
        var finishErrorCheck = testHelpers.dev.willWarn(message);
        function Currency() {
            return this;
        }
        Currency.prototype = { symbol: 'USD' };
        function VM() {
        }
        define(VM.prototype, {
            currency: {
                type: Currency,
                default: function () {
                    return new Currency({});
                }
            }
        });
        QUnit.equal(finishErrorCheck(), 1);
        message = 'can-define: the definition for currency on VM2 uses a constructor for "type". Did you mean "Type"?';
        finishErrorCheck = testHelpers.dev.willWarn(message);
        function VM2() {
        }
        VM2.shortName = 'VM2';
        define(VM2.prototype, {
            currency: {
                type: Currency,
                default: function () {
                    return new Currency({});
                }
            }
        });
        QUnit.equal(finishErrorCheck(), 1);
    });
});
/*can-define@2.0.1#list/list-test*/
define('can-define@2.0.1#list/list-test', [
    'require',
    'exports',
    'module',
    'steal-qunit',
    'can-define/list/list',
    'can-define/map/map',
    'can-observation',
    'can-define',
    'can-reflect',
    'can-symbol',
    'can-log/dev/dev',
    'can-test-helpers/lib/dev',
    'can-util/js/assign/assign'
], function (require, exports, module) {
    'use strict';
    var QUnit = require('steal-qunit');
    var DefineList = require('can-define/list/list');
    var DefineMap = require('can-define/map/map');
    var Observation = require('can-observation');
    var define = require('can-define');
    var canReflect = require('can-reflect');
    var canSymbol = require('can-symbol');
    var dev = require('can-log/dev/dev');
    var canTestHelpers = require('can-test-helpers/lib/dev');
    var assign = require('can-util/js/assign/assign');
    QUnit.module('can-define/list/list');
    QUnit.test('List is an event emitter', function (assert) {
        var Base = DefineList.extend({});
        assert.ok(Base.on, 'Base has event methods.');
        var List = Base.extend({});
        assert.ok(List.on, 'List has event methods.');
    });
    QUnit.test('creating an instance', function () {
        var list = new DefineList([
            'a',
            'b',
            'c'
        ]);
        list.on('add', function (ev, newVals, index) {
            QUnit.deepEqual(newVals, ['d']);
            QUnit.equal(index, 3);
        });
        list.push('d');
    });
    test('list attr changes length', function () {
        var l = new DefineList([
            0,
            1,
            2
        ]);
        l.set(3, 3);
        equal(l.length, 4);
    });
    test('remove on pop', function () {
        var l = new DefineList([
            0,
            1,
            2
        ]);
        l.pop();
        equal(l.length, 2);
        deepEqual(l.get(), [
            0,
            1
        ]);
    });
    test('list splice', function () {
        var l = new DefineList([
            0,
            1,
            2,
            3
        ]);
        l.on('add', function (ev, newVals, index) {
            deepEqual(newVals, [
                'a',
                'b'
            ], 'got the right newVals');
            equal(index, 1, 'adding items');
        });
        l.on('remove', function (ev, oldVals, index) {
            deepEqual(oldVals, [
                1,
                2
            ], 'got the right oldVals');
            equal(index, 1, 'no new Vals');
        });
        l.splice(1, 2, 'a', 'b');
        deepEqual(l.get(), [
            0,
            'a',
            'b',
            3
        ], 'serialized');
    });
    test('Array accessor methods', 11, function () {
        var l = new DefineList([
                'a',
                'b',
                'c'
            ]), sliced = l.slice(2), joined = l.join(' | '), concatenated = l.concat([
                2,
                1
            ], new DefineList([0]));
        ok(sliced instanceof DefineList, 'Slice is an Observable list');
        equal(sliced.length, 1, 'Sliced off two elements');
        equal(sliced[0], 'c', 'Single element as expected');
        equal(joined, 'a | b | c', 'Joined list properly');
        ok(concatenated instanceof DefineList, 'Concatenated is an Observable list');
        deepEqual(concatenated.serialize(), [
            'a',
            'b',
            'c',
            2,
            1,
            0
        ], 'DefineList concatenated properly');
        l.forEach(function (letter, index) {
            ok(true, 'Iteration');
            if (index === 0) {
                equal(letter, 'a', 'First letter right');
            }
            if (index === 2) {
                equal(letter, 'c', 'Last letter right');
            }
        });
    });
    test('Concatenated list items Equal original', function () {
        var l = new DefineList([
                { firstProp: 'Some data' },
                { secondProp: 'Next data' }
            ]), concatenated = l.concat([
                { hello: 'World' },
                { foo: 'Bar' }
            ]);
        ok(l[0] === concatenated[0], 'They are Equal');
        ok(l[1] === concatenated[1], 'They are Equal');
    });
    test('Lists with maps concatenate properly', function () {
        var Person = DefineMap.extend();
        var People = DefineList.extend({ '#': Person });
        var Genius = Person.extend();
        var Animal = DefineMap.extend();
        var me = new Person({ name: 'John' });
        var animal = new Animal({ name: 'Tak' });
        var genius = new Genius({ name: 'Einstein' });
        var hero = { name: 'Ghandi' };
        var people = new People([]);
        var specialPeople = new People([
            genius,
            hero
        ]);
        people = people.concat([
            me,
            animal,
            specialPeople
        ], specialPeople, [
            1,
            2
        ], 3);
        ok(people.length === 8, 'List length is right');
        ok(people[0] === me, 'Map in list === vars created before concat');
        ok(people[1] instanceof Person, 'Animal got serialized to Person');
    });
    test('splice removes items in IE (#562)', function () {
        var l = new DefineList(['a']);
        l.splice(0, 1);
        ok(!l.get(0), 'all props are removed');
    });
    test('reverse triggers add/remove events (#851)', function () {
        expect(4);
        var l = new DefineList([
            1,
            2,
            3
        ]);
        l.on('add', function () {
            ok(true, 'add called');
        });
        l.on('remove', function () {
            ok(true, 'remove called');
        });
        l.on('length', function () {
            ok(true, 'length should be called');
        });
        l.reverse();
        deepEqual(l.get(), [
            3,
            2,
            1
        ], 'reversed');
    });
    QUnit.test('filter', function (assert) {
        var l = new DefineList([
            {
                id: 1,
                name: 'John'
            },
            {
                id: 2,
                name: 'Mary'
            }
        ]);
        var filtered = l.filter(function (item) {
            return item.name === 'Mary';
        });
        assert.notDeepEqual(filtered, l, 'not same object');
        assert.equal(filtered.length, 1, 'one item');
        assert.equal(filtered[0].name, 'Mary', 'filter works');
    });
    test('No Add Events if DefineList Splice adds the same items that it is removing. (#1277, #1399)', function () {
        var list = new DefineList([
            'a',
            'b'
        ]);
        list.bind('add', function () {
            ok(false, 'Add callback should not be called.');
        });
        list.bind('remove', function () {
            ok(false, 'Remove callback should not be called.');
        });
        var result = list.splice(0, 2, 'a', 'b');
        deepEqual(result, [
            'a',
            'b'
        ]);
    });
    test('add event always returns an array as the value (#998)', function () {
        var list = new DefineList([]), msg;
        list.bind('add', function (ev, newElements, index) {
            deepEqual(newElements, [4], msg);
        });
        msg = 'works on push';
        list.push(4);
        list.pop();
        msg = 'works on attr()';
        list.set(0, 4);
        list.pop();
        msg = 'works on replace()';
        list.replace([4]);
    });
    test('Setting with .set() out of bounds of length triggers add event with leading undefineds', function () {
        var list = new DefineList([1]);
        list.bind('add', function (ev, newElements, index) {
            deepEqual(newElements, [
                undefined,
                undefined,
                4
            ], 'Leading undefineds are included');
            equal(index, 1, 'Index takes into account the leading undefineds from a .set()');
        });
        list.set(3, 4);
    });
    test('No events should fire if removals happened on empty arrays', function () {
        var list = new DefineList([]), msg;
        list.bind('remove', function (ev, removed, index) {
            ok(false, msg);
        });
        msg = 'works on pop';
        list.pop();
        msg = 'works on shift';
        list.shift();
        ok(true, 'No events were fired.');
    });
    test('setting an index out of bounds does not create an array', function () {
        expect(1);
        var l = new DefineList();
        l.set('1', 'foo');
        equal(l.get('1'), 'foo');
    });
    test('splice with similar but less items works (#1606)', function () {
        var list = new DefineList([
            'aa',
            'bb',
            'cc'
        ]);
        list.splice(0, list.length, 'aa', 'cc', 'dd');
        deepEqual(list.get(), [
            'aa',
            'cc',
            'dd'
        ]);
        list.splice(0, list.length, 'aa', 'cc');
        deepEqual(list.get(), [
            'aa',
            'cc'
        ]);
    });
    test('filter returns same list type (#1744)', function () {
        var ParentList = DefineList.extend();
        var ChildList = ParentList.extend();
        var children = new ChildList([
            1,
            2,
            3
        ]);
        ok(children.filter(function () {
        }) instanceof ChildList);
    });
    test('reverse returns the same list instance (#1744)', function () {
        var ParentList = DefineList.extend();
        var ChildList = ParentList.extend();
        var children = new ChildList([
            1,
            2,
            3
        ]);
        ok(children.reverse() === children);
    });
    test('slice and join are observable by a compute (#1884)', function () {
        expect(2);
        var list = new DefineList([
            1,
            2,
            3
        ]);
        var sliced = new Observation(function () {
            return list.slice(0, 1);
        });
        canReflect.onValue(sliced, function (newVal) {
            deepEqual(newVal.get(), [2], 'got a new DefineList');
        });
        var joined = new Observation(function () {
            return list.join(',');
        });
        canReflect.onValue(joined, function (newVal) {
            equal(newVal, '2,3', 'joined is observable');
        });
        list.shift();
    });
    test('list.replace', function () {
        var firstArray = [
            {
                id: 1,
                name: 'Marshall'
            },
            {
                id: 2,
                name: 'Austin'
            },
            {
                id: 3,
                name: 'Hyrum'
            }
        ];
        var myList = new DefineList(firstArray);
        var newArray = [
            {
                id: 4,
                name: 'Aubree'
            },
            {
                id: 5,
                name: 'Leah'
            },
            {
                id: 6,
                name: 'Lily'
            }
        ];
        myList.replace(newArray);
        equal(myList.length, 3);
        equal(myList[0].name, 'Aubree');
        equal(myList[1].name, 'Leah');
        equal(myList[2].name, 'Lily', 'Can replace a List with an Array.');
        myList.replace(firstArray);
        equal(myList.length, 3);
        equal(myList[0].name, 'Marshall');
        equal(myList[1].name, 'Austin');
        equal(myList[2].name, 'Hyrum', 'Can replace a List with another List.');
    });
    test('list.map', function () {
        var myArray = [
            {
                id: 1,
                name: 'Marshall'
            },
            {
                id: 2,
                name: 'Austin'
            },
            {
                id: 3,
                name: 'Hyrum'
            }
        ];
        var myList = new DefineList(myArray);
        var newList = myList.map(function (person) {
            person.lastName = 'Thompson';
            return person;
        });
        equal(newList.length, 3);
        equal(newList[0].name, 'Marshall');
        equal(newList[0].lastName, 'Thompson');
        equal(newList[1].name, 'Austin');
        equal(newList[1].lastName, 'Thompson');
        equal(newList[2].name, 'Hyrum');
        equal(newList[2].lastName, 'Thompson');
        var ExtendedList = DefineList.extend({
            testMe: function () {
                return 'It Worked!';
            }
        });
        var myExtendedList = new ExtendedList(myArray);
        var newExtendedList = myExtendedList.map(function (person) {
            person.lastName = 'Thompson';
            return person;
        });
        try {
            newExtendedList.testMe();
        } catch (err) {
            QUnit.ok(err.message.match(/testMe/), 'Does not return the same type of list.');
        }
    });
    test('list.sort a simple list', function () {
        var myList = new DefineList([
            'Marshall',
            'Austin',
            'Hyrum'
        ]);
        myList.sort();
        equal(myList.length, 3);
        equal(myList[0], 'Austin');
        equal(myList[1], 'Hyrum');
        equal(myList[2], 'Marshall', 'Basic list was properly sorted.');
    });
    test('list.sort a list of objects', function () {
        var objList = new DefineList([
            {
                id: 1,
                name: 'Marshall'
            },
            {
                id: 2,
                name: 'Austin'
            },
            {
                id: 3,
                name: 'Hyrum'
            }
        ]);
        objList.sort(function (a, b) {
            if (a.name < b.name) {
                return -1;
            } else if (a.name > b.name) {
                return 1;
            } else {
                return 0;
            }
        });
        equal(objList.length, 3);
        equal(objList[0].name, 'Austin');
        equal(objList[1].name, 'Hyrum');
        equal(objList[2].name, 'Marshall', 'List of objects was properly sorted.');
    });
    test('list.sort a list of objects without losing reference (#137)', function () {
        var unSorted = new DefineList([
            { id: 3 },
            { id: 2 },
            { id: 1 }
        ]);
        var sorted = unSorted.slice(0).sort(function (a, b) {
            return a.id > b.id ? 1 : a.id < b.id ? -1 : 0;
        });
        equal(unSorted[0], sorted[2], 'items should be equal');
    });
    test('list defines', 6, function () {
        var Todo = function (props) {
            assign(this, props);
        };
        define(Todo.prototype, {
            completed: 'boolean',
            destroyed: { default: false }
        });
        Todo.prototype.destroy = function () {
            this.destroyed = true;
        };
        var TodoList = DefineList.extend({
            '*': Todo,
            remaining: {
                get: function () {
                    return this.filter({ completed: false });
                }
            },
            completed: {
                get: function () {
                    return this.filter({ completed: true });
                }
            },
            destroyCompleted: function () {
                this.completed.forEach(function (todo) {
                    todo.destroy();
                });
            },
            setCompletedTo: function (value) {
                this.forEach(function (todo) {
                    todo.completed = value;
                });
            }
        });
        var todos = new TodoList([
            { completed: true },
            { completed: false }
        ]);
        ok(todos.item(0) instanceof Todo, 'correct instance');
        equal(todos.completed.length, 1, 'only one todo');
        todos.on('completed', function (ev, newVal, oldVal) {
            ok(newVal instanceof TodoList, 'right type');
            equal(newVal.length, 2, 'all items');
            ok(oldVal instanceof TodoList, 'right type');
            equal(oldVal.length, 1, 'all items');
        });
        todos.setCompletedTo(true);
    });
    QUnit.test('extending the base supports overwriting _eventSetup', function () {
        var L = DefineList.extend({});
        Object.getOwnPropertyDescriptor(DefineMap.prototype, '_eventSetup');
        L.prototype.arbitraryProp = true;
        ok(true, 'set arbitraryProp');
        L.prototype._eventSetup = function () {
        };
        ok(true, 'worked');
    });
    QUnit.test('setting expandos on a DefineList', function () {
        var DL = DefineList.extend({ count: 'number' });
        var dl = new DL();
        dl.assign({
            count: 5,
            skip: 2
        });
        QUnit.equal(dl.get('count'), 5, 'read with .get defined');
        QUnit.equal(dl.count, 5, 'read with . defined');
        QUnit.equal(dl.get('skip'), 2, 'read with .get expando');
        QUnit.equal(dl.skip, 2, 'read with . expando');
        QUnit.equal(dl.get('limit'), undefined, 'read with .get undefined');
    });
    QUnit.test('passing a DefineList to DefineList (#33)', function () {
        var m = new DefineList([
            {},
            {}
        ]);
        var m2 = new DefineList(m);
        QUnit.deepEqual(m.get(), m2.get());
        QUnit.ok(m[0] === m2[0], 'index the same');
        QUnit.ok(m[1] === m2[1], 'index the same');
    });
    QUnit.test('reading and setting expandos', function () {
        var list = new DefineList();
        var countObservation = new Observation(function () {
            return list.get('count');
        }, null, function (newValue) {
            QUnit.equal(newValue, 1000, 'got new value');
        });
        countObservation.start();
        list.set('count', 1000);
        QUnit.equal(countObservation.value, 1000);
        var list2 = new DefineList();
        list2.on('count', function (ev, newVal) {
            QUnit.equal(newVal, 5);
        });
        list2.set('count', 5);
    });
    QUnit.test('extending DefineList constructor functions (#61)', function () {
        var AList = DefineList.extend('AList', {
            aProp: {},
            aMethod: function () {
            }
        });
        var BList = AList.extend('BList', {
            bProp: {},
            bMethod: function () {
            }
        });
        var CList = BList.extend('CList', {
            cProp: {},
            cMethod: function () {
            }
        });
        var list = new CList([
            {},
            {}
        ]);
        list.on('aProp', function (ev, newVal, oldVal) {
            QUnit.equal(newVal, 'PROP');
            QUnit.equal(oldVal, undefined);
        });
        list.on('bProp', function (ev, newVal, oldVal) {
            QUnit.equal(newVal, 'FOO');
            QUnit.equal(oldVal, undefined);
        });
        list.on('cProp', function (ev, newVal, oldVal) {
            QUnit.equal(newVal, 'BAR');
            QUnit.equal(oldVal, undefined);
        });
        list.aProp = 'PROP';
        list.bProp = 'FOO';
        list.cProp = 'BAR';
        QUnit.ok(list.aMethod);
        QUnit.ok(list.bMethod);
        QUnit.ok(list.cMethod);
    });
    QUnit.test('extending DefineList constructor functions more than once (#61)', function () {
        var AList = DefineList.extend('AList', {
            aProp: {},
            aMethod: function () {
            }
        });
        var BList = AList.extend('BList', {
            bProp: {},
            bMethod: function () {
            }
        });
        var CList = AList.extend('CList', {
            cProp: {},
            cMethod: function () {
            }
        });
        var list1 = new BList([
            {},
            {}
        ]);
        var list2 = new CList([
            {},
            {},
            {}
        ]);
        list1.on('aProp', function (ev, newVal, oldVal) {
            QUnit.equal(newVal, 'PROP', 'aProp newVal on list1');
            QUnit.equal(oldVal, undefined);
        });
        list1.on('bProp', function (ev, newVal, oldVal) {
            QUnit.equal(newVal, 'FOO', 'bProp newVal on list1');
            QUnit.equal(oldVal, undefined);
        });
        list2.on('aProp', function (ev, newVal, oldVal) {
            QUnit.equal(newVal, 'PROP', 'aProp newVal on list2');
            QUnit.equal(oldVal, undefined);
        });
        list2.on('cProp', function (ev, newVal, oldVal) {
            QUnit.equal(newVal, 'BAR', 'cProp newVal on list2');
            QUnit.equal(oldVal, undefined);
        });
        list1.aProp = 'PROP';
        list1.bProp = 'FOO';
        list2.aProp = 'PROP';
        list2.cProp = 'BAR';
        QUnit.ok(list1.aMethod, 'list1 aMethod');
        QUnit.ok(list1.bMethod);
        QUnit.ok(list2.aMethod);
        QUnit.ok(list2.cMethod, 'list2 cMethod');
    });
    QUnit.test('extending DefineList constructor functions - value (#61)', function () {
        var AList = DefineList.extend('AList', { aProp: { default: 1 } });
        var BList = AList.extend('BList', {});
        var CList = BList.extend('CList', {});
        var c = new CList([]);
        QUnit.equal(c.aProp, 1, 'got initial value');
    });
    QUnit.test('\'*\' inheritance works (#61)', function () {
        var Account = DefineMap.extend({
            name: 'string',
            amount: 'number',
            slug: {
                serialize: true,
                get: function () {
                    return this.name.toLowerCase().replace(/ /g, '-').replace(/[^\w-]+/g, '');
                }
            }
        });
        var BaseList = DefineList.extend({ '*': Account });
        var ExtendedList = BaseList.extend({});
        var xl = new ExtendedList([{}]);
        QUnit.ok(xl[0] instanceof Account);
    });
    QUnit.test('shorthand getter setter (#56)', function () {
        var People = DefineList.extend({
            first: '*',
            last: '*',
            get fullName() {
                return this.first + ' ' + this.last;
            },
            set fullName(newVal) {
                var parts = newVal.split(' ');
                this.first = parts[0];
                this.last = parts[1];
            }
        });
        var p = new People([]);
        p.fullName = 'Mohamed Cherif';
        p.on('fullName', function (ev, newVal, oldVal) {
            QUnit.equal(oldVal, 'Mohamed Cherif');
            QUnit.equal(newVal, 'Justin Meyer');
        });
        equal(p.fullName, 'Mohamed Cherif', 'fullName initialized right');
        p.fullName = 'Justin Meyer';
    });
    QUnit.test('added and removed are called after items are added/removed (#14)', function () {
        var Person = DefineMap.extend({
            id: 'number',
            name: 'string'
        });
        var addedFuncCalled, removedFuncCalled, theList;
        var People = DefineList.extend({
            '#': {
                added: function (items, index) {
                    addedFuncCalled = true;
                    ok(items, 'items added got passed to added');
                    ok(typeof index === 'number', 'index of items was passed to added and is a number');
                    ok(items[0].name === 'John', 'Name was correct');
                    theList = this;
                },
                removed: function (items, index) {
                    removedFuncCalled = true;
                    ok(items, 'items added got passed to removed');
                    ok(typeof index === 'number', 'index of items was passed to removed and is a number');
                    theList = this;
                },
                Type: Person
            },
            outsideProp: {
                type: 'boolean',
                default: true
            }
        });
        var people = new People([]);
        var me = new Person();
        me.name = 'John';
        me.id = '1234';
        ok(!addedFuncCalled, 'added function has not been called yet');
        people.push(me);
        ok(addedFuncCalled, 'added function was called');
        ok(theList.outsideProp === true && theList instanceof People, 'the list was passed correctly as this to added');
        theList = null;
        ok(!removedFuncCalled, 'removed function has not been called yet');
        people.splice(people.indexOf(me), 1);
        ok(removedFuncCalled, 'removed function was called');
        ok(theList.outsideProp === true && theList instanceof People, 'the list was passed correctly as this to removed');
    });
    QUnit.test('* vs # (#78)', function () {
        var MyList = DefineList.extend({
            '*': 'number',
            '#': {
                added: function () {
                    ok(true, 'called on init');
                },
                removed: function () {
                },
                type: 'string'
            }
        });
        var list = new MyList([
            1,
            2,
            3
        ]);
        QUnit.ok(list[0] === '1', 'converted to string');
        list.set('prop', '4');
        QUnit.ok(list.prop === 4, 'type converted');
    });
    QUnit.test('Array shorthand uses #', function () {
        var MyMap = DefineMap.extend({ 'numbers': ['number'] });
        var map = new MyMap({
            numbers: [
                '1',
                '2'
            ]
        });
        QUnit.ok(map.numbers[0] === 1, 'converted to number');
        map.numbers.set('prop', '4');
        QUnit.ok(map.numbers.prop === '4', 'type left alone');
    });
    QUnit.test('replace-with-self lists are diffed properly (can-view-live#10)', function () {
        var a = new DefineMap({ name: 'A' });
        var b = new DefineMap({ name: 'B' });
        var c = new DefineMap({ name: 'C' });
        var d = new DefineMap({ name: 'D' });
        expect(4);
        var list1 = new DefineList([
            a,
            b
        ]);
        list1.on('add', function (ev, newVals, where) {
            throw new Error('list1 should not add.');
        });
        list1.on('remove', function (ev, oldVals, where) {
            throw new Error('list1 should not remove.');
        });
        list1.replace([
            a,
            b
        ]);
        var list2 = new DefineList([
            a,
            b,
            c
        ]);
        list2.on('add', function (ev, newVals, where) {
            equal(newVals.length, 1, 'list2 added length');
            equal(where, 2, 'list2 added location');
        });
        list2.on('remove', function (ev, oldVals, where) {
            equal(oldVals.length, 1, 'list2 removed length');
            equal(where, 2, 'list2 removed location');
        });
        list2.replace([
            a,
            b,
            d
        ]);
    });
    QUnit.test('set >= length - triggers length event (#152)', function () {
        var l = new DefineList([
            1,
            2,
            3
        ]);
        var batchNum = null;
        l.on('add', function (e) {
            ok(true, 'add called');
            if (batchNum === null) {
                batchNum = e.batchNum;
            } else {
                equal(batchNum, e.batchNum, 'batch numbers match');
            }
        });
        l.on('remove', function (e) {
            ok(false, 'remove called');
            if (batchNum === null) {
                batchNum = e.batchNum;
            } else {
                equal(batchNum, e.batchNum, 'batch numbers match');
            }
        });
        l.on('length', function (e) {
            ok(true, 'length called');
            if (batchNum === null) {
                batchNum = e.batchNum;
            } else {
                equal(batchNum, e.batchNum, 'batch numbers match');
            }
        });
        expect(4);
        l.set(3, 5);
        deepEqual(l.get(), [
            1,
            2,
            3,
            5
        ], 'updated list');
    });
    QUnit.test('set < length - triggers length event (#150)', function () {
        var l = new DefineList([
            1,
            2,
            3
        ]);
        var batchNum = null;
        l.on('add', function (e) {
            ok(true, 'add called');
            if (batchNum === null) {
                batchNum = e.batchNum;
            } else {
                equal(batchNum, e.batchNum, 'batch numbers match');
            }
        });
        l.on('remove', function (e) {
            ok(true, 'remove called');
            if (batchNum === null) {
                batchNum = e.batchNum;
            } else {
                equal(batchNum, e.batchNum, 'batch numbers match');
            }
        });
        l.on('length', function (e) {
            ok(true, 'length called');
            if (batchNum === null) {
                batchNum = e.batchNum;
            } else {
                equal(batchNum, e.batchNum, 'batch numbers match');
            }
        });
        expect(6);
        l.set(2, 4);
        deepEqual(l.get(), [
            1,
            2,
            4
        ], 'updated list');
    });
    QUnit.test('set/splice are observable', function () {
        var list = new DefineList([
            1,
            2,
            3,
            4,
            5
        ]);
        var count = new Observation(function () {
            var count = 0;
            for (var i = 0; i < list.length; i++) {
                count += list[i] % 2 ? 1 : 0;
            }
            return count;
        });
        canReflect.onValue(count, function () {
            ok(true);
        });
        expect(3);
        list.set(3, 5);
        list.set(2, 4);
        list.splice(1, 1, 1);
    });
    QUnit.test('setting length > current (#147)', function () {
        var list = new DefineList([
            1,
            2
        ]);
        list.length = 5;
        equal(list.length, 5);
        equal(list.hasOwnProperty(0), true);
        equal(list.hasOwnProperty(1), true);
        equal(list.hasOwnProperty(2), true);
        equal(list.hasOwnProperty(3), true);
        equal(list.hasOwnProperty(4), true);
        equal(list.hasOwnProperty(5), false);
    });
    QUnit.test('setting length < current (#147)', function () {
        var list = new DefineList([
            1,
            2,
            3,
            4,
            5
        ]);
        list.length = 3;
        equal(list.length, 3);
        equal(list.hasOwnProperty(0), true);
        equal(list.hasOwnProperty(1), true);
        equal(list.hasOwnProperty(2), true);
        equal(list.hasOwnProperty(3), false);
        equal(list.hasOwnProperty(4), false);
        equal(list.hasOwnProperty(5), false);
    });
    test('every', function () {
        var l = new DefineList([
            {
                id: 1,
                name: 'Bob'
            },
            {
                id: 2,
                name: 'Bob'
            }
        ]);
        var allBobs = l.every(function (item) {
            return item.name === 'Bob';
        });
        ok(allBobs, 'Every works in true case');
        var idOne = l.every(function (item) {
            return item.id === 1;
        });
        ok(!idOne, 'Every works in false case');
        allBobs = l.every({ name: 'Bob' });
        ok(allBobs, 'Every works in true case');
        idOne = l.every({
            name: 'Bob',
            id: 1
        });
        ok(!idOne, 'Every works in false case');
    });
    test('some', function () {
        var l = new DefineList([
            {
                id: 1,
                name: 'Alice'
            },
            {
                id: 2,
                name: 'Bob'
            }
        ]);
        var allBobs = l.some(function (item) {
            return item.name === 'Bob';
        });
        ok(allBobs, 'Some works in true case');
        var idOne = l.some(function (item) {
            return item.name === 'Charlie';
        });
        ok(!idOne, 'Some works in false case');
        allBobs = l.some({ name: 'Bob' });
        ok(allBobs, 'Some works in true case');
        idOne = l.some({
            name: 'Bob',
            id: 1
        });
        ok(!idOne, 'Some works in false case');
    });
    test('lastIndexOf', function () {
        var l = new DefineList([
            {
                id: 1,
                name: 'Alice'
            },
            {
                id: 2,
                name: 'Bob'
            }
        ]);
        var bobIdx = l.lastIndexOf(l[1]);
        equal(bobIdx, 1, 'lastIndexOf found object');
        var charlieIdx = l.lastIndexOf({
            id: 3,
            name: 'Charlie'
        });
        equal(charlieIdx, -1, 'lastIndexOf not found object');
        l.push(l[1]);
        bobIdx = l.lastIndexOf(l[1]);
        equal(bobIdx, 2, 'lastIndexOf found last index of duped object');
    });
    test('reduce', function () {
        var l = new DefineList([
            {
                id: 1,
                name: 'Alice',
                score: 10
            },
            {
                id: 2,
                name: 'Bob',
                score: 20
            }
        ]);
        var totalScores = l.reduce(function (total, player) {
            return total + player.score;
        }, 0);
        equal(totalScores, 30, 'Reduce works over list');
    });
    test('reduceRight', function () {
        var l = new DefineList([
            {
                id: 1,
                name: 'Alice'
            },
            {
                id: 2,
                name: 'Bob'
            }
        ]);
        var concatenatedNames = l.reduceRight(function (string, person) {
            return string + person.name;
        }, '');
        equal(concatenatedNames, 'BobAlice', 'ReduceRight works over list');
    });
    QUnit.test('can-reflect onKeyValue', function (assert) {
        assert.expect(3);
        var list = new DefineList([
            1,
            2,
            3
        ]);
        var key = 1;
        canReflect.onKeyValue(list, key, function (newVal) {
            assert.equal(newVal, 5);
        });
        list.set(key, 5);
        canReflect.onKeyValue(list, 'length', function (newVal) {
            assert.equal(newVal, 4);
        });
        list.push(6);
    });
    test('works with can-reflect', function () {
        var a = new DefineMap({ foo: 4 });
        var b = new DefineList([
            'foo',
            'bar'
        ]);
        var c;
        QUnit.equal(canReflect.getKeyValue(b, '0'), 'foo', 'unbound value');
        QUnit.ok(!canReflect.isValueLike(b), 'isValueLike is false');
        QUnit.ok(canReflect.isObservableLike(b), 'isObservableLike is true');
        QUnit.ok(canReflect.isMapLike(b), 'isMapLike is true');
        QUnit.ok(canReflect.isListLike(b), 'isListLike is false');
        QUnit.ok(!canReflect.keyHasDependencies(b, 'length'), 'keyHasDependencies -- false');
        define(c = Object.create(b), {
            length: {
                get: function () {
                    return a.foo;
                }
            }
        });
        QUnit.ok(canReflect.getKeyDependencies(c, 'length'), 'dependencies exist');
        QUnit.ok(canReflect.getKeyDependencies(c, 'length').valueDependencies.has(c._computed.length.compute), 'dependencies returned');
    });
    QUnit.test('can-reflect setKeyValue', function () {
        var a = new DefineList([
            'a',
            'b'
        ]);
        canReflect.setKeyValue(a, 1, 'c');
        QUnit.equal(a[1], 'c', 'setKeyValue');
    });
    QUnit.test('can-reflect deleteKeyValue', function () {
        var a = new DefineList([
            'a',
            'b'
        ]);
        a.set('foo', 'bar');
        canReflect.deleteKeyValue(a, 0);
        QUnit.equal(a[1], undefined, 'last value is now undefined');
        QUnit.equal(a[0], 'b', 'last value is shifted down');
        canReflect.deleteKeyValue(a, 'foo');
        QUnit.equal(a.foo, undefined, 'value not included in serial');
        QUnit.ok(!('foo' in a.get()), 'value not included in serial');
    });
    QUnit.test('can-reflect getKeyDependencies', function () {
        var a = new DefineMap({ foo: 4 });
        var b = new DefineList([
            'foo',
            'bar'
        ]);
        var c;
        ok(!canReflect.getKeyDependencies(b, 'length'), 'No dependencies before binding');
        define(c = Object.create(b), {
            length: {
                get: function () {
                    return a.foo;
                }
            }
        });
        ok(canReflect.getKeyDependencies(c, 'length'), 'dependencies exist');
        ok(canReflect.getKeyDependencies(c, 'length').valueDependencies.has(c._computed.length.compute), 'dependencies returned');
    });
    QUnit.test('assign property', function () {
        var list = new DefineList([
            'A',
            'B'
        ]);
        list.assign({
            count: 0,
            skip: 2,
            arr: [
                '1',
                '2',
                '3'
            ]
        });
        equal(list.get('count'), 0, 'Count set properly');
        list.assign({
            count: 1000,
            arr: ['first']
        });
        deepEqual(list.get('arr'), new DefineList(['first']), 'Array is set properly');
        equal(list.get('count'), 1000, 'Count set properly');
        equal(list.get('skip'), 2, 'Skip is unchanged');
    });
    QUnit.test('update property', function () {
        var list = new DefineList([
            'A',
            'B'
        ]);
        list.update({
            count: 0,
            skip: 2
        });
        equal(list.get('count'), 0, 'Count set properly');
        list.update({ count: 1000 });
        equal(list.get('count'), 1000, 'Count set properly');
        equal(list.get('skip'), undefined, 'Skip is changed');
    });
    QUnit.test('assignDeep property', function () {
        var list = new DefineList([
            'A',
            'B'
        ]);
        list.assignDeep({
            count: 0,
            skip: 2,
            foo: {
                bar: 'zed',
                tar: 'yap'
            }
        });
        equal(list.get('count'), 0, 'Count set properly');
        list.assignDeep({
            count: 1000,
            foo: { bar: 'updated' }
        });
        equal(list.get('count'), 1000, 'Count set properly');
        equal(list.get('skip'), 2, 'Skip is unchanged');
        propEqual(list.get('foo'), {
            bar: 'updated',
            tar: 'yap'
        }, 'Foo was updated properly');
    });
    QUnit.test('updateDeep property', function () {
        var list = new DefineList([
            'A',
            'B'
        ]);
        list.updateDeep({
            count: 0,
            skip: 2,
            foo: {
                bar: 'zed',
                tar: 'yap'
            }
        });
        equal(list.get('count'), 0, 'Count set properly');
        list.updateDeep({ count: 1000 });
        equal(list.get('count'), 1000, 'Count set properly');
        equal(list.get('skip'), undefined, 'Skip is set to undefined');
        propEqual(list.get('foo'), undefined, 'Foo is set to undefined');
    });
    QUnit.test('registered symbols', function () {
        var a = new DefineMap({ 'a': 'a' });
        ok(a[canSymbol.for('can.isMapLike')], 'can.isMapLike');
        equal(a[canSymbol.for('can.getKeyValue')]('a'), 'a', 'can.getKeyValue');
        a[canSymbol.for('can.setKeyValue')]('a', 'b');
        equal(a.a, 'b', 'can.setKeyValue');
        function handler(val) {
            equal(val, 'c', 'can.onKeyValue');
        }
        a[canSymbol.for('can.onKeyValue')]('a', handler);
        a.a = 'c';
        a[canSymbol.for('can.offKeyValue')]('a', handler);
        a.a = 'd';
    });
    QUnit.test('cannot remove length', function () {
        var list = new DefineList(['a']);
        list.set('length', undefined);
        QUnit.equal(list.length, 1, 'list length is unchanged');
    });
    QUnit.test('cannot set length to a non-number', function () {
        var list = new DefineList(['a']);
        list.set('length', null);
        QUnit.equal(list.length, 1, 'list length is unchanged');
        list.set('length', 'foo');
        QUnit.equal(list.length, 1, 'list length is unchanged');
        list.set('length', {});
        QUnit.equal(list.length, 1, 'list length is unchanged');
    });
    QUnit.test('_length is not enumerable', function () {
        QUnit.ok(!Object.getOwnPropertyDescriptor(new DefineList(), '_length').enumerable, '_length is not enumerable');
    });
    QUnit.test('update with no indexed items sets length to 0', function () {
        var list = new DefineList(['a']);
        QUnit.equal(list.length, 1, 'list length is correct before update');
        list.update({ foo: 'bar' });
        QUnit.equal(list.length, 0, 'list length is correct after update');
    });
    [
        'length',
        '_length'
    ].forEach(function (prop) {
        QUnit.test('setting ' + prop + ' does not overwrite definition', function () {
            var list = new DefineList();
            list.get(prop);
            var proto = list, listDef, listDef2;
            while (!listDef && proto) {
                listDef = Object.getOwnPropertyDescriptor(proto, prop);
                proto = Object.getPrototypeOf(proto);
            }
            list.set(prop, 1);
            proto = list;
            while (!listDef2 && proto) {
                listDef2 = Object.getOwnPropertyDescriptor(proto, prop);
                proto = Object.getPrototypeOf(proto);
            }
            delete listDef2.value;
            delete listDef.value;
            QUnit.deepEqual(listDef2, listDef, 'descriptor hasn\'t changed');
        });
    });
    QUnit.test('iterator can recover from bad _length', function () {
        var list = new DefineList(['a']);
        list.set('_length', null);
        QUnit.equal(list._length, null, 'Bad value for _length');
        var iterator = list[canSymbol.iterator]();
        var iteration = iterator.next();
        QUnit.ok(iteration.done, 'Didn\'t fail');
    });
    QUnit.test('onPatches', function () {
        var list = new DefineList([
            'a',
            'b'
        ]);
        var PATCHES = [
            [{
                    deleteCount: 2,
                    index: 0,
                    type: 'splice'
                }],
            [{
                    index: 0,
                    insert: [
                        'A',
                        'B'
                    ],
                    deleteCount: 0,
                    type: 'splice'
                }]
        ];
        var calledPatches = [];
        var handler = function patchesHandler(patches) {
            calledPatches.push(patches);
        };
        list[canSymbol.for('can.onPatches')](handler, 'notify');
        list.replace([
            'A',
            'B'
        ]);
        list[canSymbol.for('can.offPatches')](handler, 'notify');
        list.replace([
            '1',
            '2'
        ]);
        QUnit.deepEqual(calledPatches, PATCHES);
    });
    canTestHelpers.devOnlyTest('can.getName symbol behavior', function (assert) {
        var getName = function (instance) {
            return instance[canSymbol.for('can.getName')]();
        };
        assert.ok('DefineList[]', getName(new DefineList()), 'should use DefineList constructor name by default');
        var MyList = DefineList.extend('MyList', {});
        assert.ok('MyList[]', getName(new MyList()), 'should use custom list name when provided');
    });
    QUnit.test('length event should include previous value', function (assert) {
        var done = assert.async();
        var list = new DefineList([]);
        var other = new DefineList(['a']);
        var changes = [];
        list.on('length', function (_, current, previous) {
            changes.push({
                current: current,
                previous: previous
            });
        });
        list.push('x');
        list.pop();
        list.push('y', 'z');
        list.splice(2, 0, 'x', 'w');
        list.splice(0, 1);
        list.sort();
        list.replace(other);
        assert.expect(1);
        setTimeout(function () {
            assert.deepEqual(changes, [
                {
                    current: 1,
                    previous: 0
                },
                {
                    current: 0,
                    previous: 1
                },
                {
                    current: 2,
                    previous: 0
                },
                {
                    current: 4,
                    previous: 2
                },
                {
                    current: 3,
                    previous: 4
                },
                {
                    current: 3,
                    previous: 3
                },
                {
                    current: 1,
                    previous: 3
                }
            ], 'should include length before mutation');
            done();
        });
    });
    canTestHelpers.devOnlyTest('log all events', function (assert) {
        var done = assert.async();
        var list = new DefineList([
            'a',
            'b',
            'c'
        ]);
        list.set('total', 100);
        list.log();
        var keys = [];
        var log = dev.log;
        dev.log = function () {
            keys.push(JSON.parse(arguments[2]));
        };
        list.push('x');
        list.pop();
        list.set('total', 50);
        assert.expect(1);
        setTimeout(function () {
            dev.log = log;
            assert.deepEqual(keys, [
                'add',
                'length',
                'remove',
                'length',
                'total'
            ], 'should log \'add\', \'remove\', \'length\' and \'propertyName\' events');
            done();
        });
    });
    canTestHelpers.devOnlyTest('log single events', function (assert) {
        var done = assert.async();
        var list = new DefineList([
            'a',
            'b',
            'c'
        ]);
        list.set('total', 100);
        list.log('length');
        var keys = [];
        var log = dev.log;
        dev.log = function () {
            keys.push(JSON.parse(arguments[2]));
        };
        list.push('x');
        list.pop();
        list.set('total', 50);
        assert.expect(1);
        setTimeout(function () {
            dev.log = log;
            assert.deepEqual(keys, [
                'length',
                'length'
            ], 'should log \'length\' event');
            done();
        });
    });
    canTestHelpers.devOnlyTest('log multiple events', function (assert) {
        var done = assert.async();
        var list = new DefineList([
            'a',
            'b',
            'c'
        ]);
        list.set('total', 100);
        list.log('add');
        list.log('total');
        var keys = [];
        var log = dev.log;
        dev.log = function () {
            keys.push(JSON.parse(arguments[2]));
        };
        list.push('x');
        list.pop();
        list.set('total', 50);
        assert.expect(1);
        setTimeout(function () {
            dev.log = log;
            assert.deepEqual(keys, [
                'add',
                'total'
            ], 'should log add and total');
            done();
        });
    });
    QUnit.test('DefineList has defineInstanceKey symbol', function () {
        var Type = DefineList.extend({});
        Type[canSymbol.for('can.defineInstanceKey')]('prop', { type: 'number' });
        var t = new Type();
        t.prop = '5';
        QUnit.equal(t.prop, 5, 'value set');
    });
});
/*can-define@2.0.1#map/map-test*/
define('can-define@2.0.1#map/map-test', [
    'require',
    'exports',
    'module',
    'steal-qunit',
    'can-define/map/map',
    'can-define',
    'can-observation',
    'can-util/js/each/each',
    'can-util/js/assign/assign',
    'can-reflect',
    'can-symbol',
    'can-util/js/is-plain-object/is-plain-object',
    'can-test-helpers/lib/dev',
    'can-define/list/list',
    'can-log/dev/dev'
], function (require, exports, module) {
    var QUnit = require('steal-qunit');
    var DefineMap = require('can-define/map/map');
    var define = require('can-define');
    var Observation = require('can-observation');
    var each = require('can-util/js/each/each');
    var assign = require('can-util/js/assign/assign');
    var canReflect = require('can-reflect');
    var canSymbol = require('can-symbol');
    var isPlainObject = require('can-util/js/is-plain-object/is-plain-object');
    var canTestHelpers = require('can-test-helpers/lib/dev');
    var DefineList = require('can-define/list/list');
    var dev = require('can-log/dev/dev');
    var sealWorks = function () {
        try {
            var o = {};
            Object.seal(o);
            o.prop = true;
            return false;
        } catch (e) {
            return true;
        }
    }();
    QUnit.module('can-define/map/map');
    QUnit.test('Map is an event emitter', function (assert) {
        var Base = DefineMap.extend({});
        assert.ok(Base.on, 'Base has event methods.');
        var Map = Base.extend({});
        assert.ok(Map.on, 'Map has event methods.');
    });
    QUnit.test('creating an instance', function () {
        var map = new DefineMap({ prop: 'foo' });
        map.on('prop', function (ev, newVal, oldVal) {
            QUnit.equal(newVal, 'BAR');
            QUnit.equal(oldVal, 'foo');
        });
        map.prop = 'BAR';
    });
    QUnit.test('creating an instance with nested prop', function () {
        var map = new DefineMap({ name: { first: 'Justin' } });
        map.name.on('first', function (ev, newVal, oldVal) {
            QUnit.equal(newVal, 'David');
            QUnit.equal(oldVal, 'Justin');
        });
        map.name.first = 'David';
    });
    QUnit.test('extending', function () {
        var MyMap = DefineMap.extend({ prop: {} });
        var map = new MyMap();
        map.on('prop', function (ev, newVal, oldVal) {
            QUnit.equal(newVal, 'BAR');
            QUnit.equal(oldVal, undefined);
        });
        map.prop = 'BAR';
    });
    QUnit.test('loop only through defined serializable props', function () {
        var MyMap = DefineMap.extend({
            propA: {},
            propB: { serialize: false },
            propC: {
                get: function () {
                    return this.propA;
                }
            }
        });
        var inst = new MyMap({
            propA: 1,
            propB: 2
        });
        QUnit.deepEqual(Object.keys(inst.get()), ['propA']);
    });
    QUnit.test('get and set can setup expandos', function () {
        var map = new DefineMap();
        var oi = new Observation(function () {
            return map.get('foo');
        });
        canReflect.onValue(oi, function (newVal) {
            QUnit.equal(newVal, 'bar', 'updated to bar');
        });
        map.set('foo', 'bar');
    });
    QUnit.test('default settings', function () {
        var MyMap = DefineMap.extend({
            '*': 'string',
            foo: {}
        });
        var m = new MyMap();
        m.set('foo', 123);
        QUnit.ok(m.get('foo') === '123');
    });
    QUnit.test('default settings on unsealed', function () {
        var MyMap = DefineMap.extend({ seal: false }, { '*': 'string' });
        var m = new MyMap();
        m.set('foo', 123);
        QUnit.ok(m.get('foo') === '123');
    });
    if (!System.isEnv('production')) {
        QUnit.test('extends sealed objects (#48)', function () {
            var Map1 = DefineMap.extend({ seal: true }, {
                name: {
                    get: function (curVal) {
                        return 'computed ' + curVal;
                    }
                }
            });
            var Map2 = Map1.extend({ seal: false }, {});
            var Map3 = Map2.extend({ seal: true }, {});
            var map1 = new Map1({ name: 'Justin' });
            try {
                map1.foo = 'bar';
                if (map1.foo) {
                    QUnit.ok(false, 'map1 not sealed');
                } else {
                    QUnit.ok(true, 'map1 sealed - silent failure');
                }
            } catch (ex) {
                QUnit.ok(true, 'map1 sealed');
            }
            QUnit.equal(map1.name, 'computed Justin', 'map1.name property is computed');
            var map2 = new Map2({ name: 'Brian' });
            try {
                map2.foo = 'bar';
                if (map2.foo) {
                    QUnit.ok(true, 'map2 not sealed');
                } else {
                    QUnit.ok(false, 'map2 sealed');
                }
            } catch (ex) {
                QUnit.ok(false, 'map2 sealed');
            }
            QUnit.equal(map2.name, 'computed Brian', 'map2.name property is computed');
            var map3 = new Map3({ name: 'Curtis' });
            try {
                map3.foo = 'bar';
                if (map3.foo) {
                    QUnit.ok(false, 'map3 not sealed');
                } else {
                    QUnit.ok(true, 'map3 sealed');
                }
            } catch (ex) {
                QUnit.ok(true, 'map3 sealed');
            }
            QUnit.equal(map3.name, 'computed Curtis', 'map3.name property is computed');
        });
    }
    QUnit.test('get with dynamically added properties', function () {
        var map = new DefineMap();
        map.set('a', 1);
        map.set('b', 2);
        QUnit.deepEqual(map.get(), {
            a: 1,
            b: 2
        });
    });
    QUnit.test('set multiple props', function () {
        var map = new DefineMap();
        map.assign({
            a: 0,
            b: 2
        });
        QUnit.deepEqual(map.get(), {
            a: 0,
            b: 2
        }, 'added props');
        map.update({ a: 2 });
        QUnit.deepEqual(map.get(), { a: 2 }, 'removed b');
        map.assign({ foo: { bar: 'VALUE' } });
        QUnit.deepEqual(map.get(), {
            foo: { bar: 'VALUE' },
            a: 2
        }, 'works nested');
    });
    QUnit.test('serialize responds to added props', function () {
        var map = new DefineMap();
        var oi = new Observation(function () {
            return map.serialize();
        });
        canReflect.onValue(oi, function (newVal) {
            QUnit.deepEqual(newVal, {
                a: 1,
                b: 2
            }, 'updated right');
        });
        map.assign({
            a: 1,
            b: 2
        });
    });
    QUnit.test('initialize an undefined property', function () {
        var MyMap = DefineMap.extend({ seal: false }, {});
        var instance = new MyMap({ foo: 'bar' });
        equal(instance.foo, 'bar');
    });
    QUnit.test('set an already initialized null property', function () {
        var map = new DefineMap({ foo: null });
        map.assign({ foo: null });
        equal(map.foo, null);
    });
    QUnit.test('creating a new key doesn\'t cause two changes', 1, function () {
        var map = new DefineMap();
        var oi = new Observation(function () {
            return map.serialize();
        });
        canReflect.onValue(oi, function (newVal) {
            QUnit.deepEqual(newVal, { a: 1 }, 'updated right');
        });
        map.set('a', 1);
    });
    QUnit.test('setting nested object', function () {
        var m = new DefineMap({});
        m.assign({ foo: {} });
        m.assign({ foo: {} });
        QUnit.deepEqual(m.get(), { foo: {} });
    });
    QUnit.test('passing a DefineMap to DefineMap (#33)', function () {
        var MyMap = DefineMap.extend({ foo: 'observable' });
        var m = new MyMap({
            foo: {},
            bar: {}
        });
        var m2 = new MyMap(m);
        QUnit.deepEqual(m.get(), m2.get());
        QUnit.ok(m.foo === m2.foo, 'defined props the same');
        QUnit.ok(m.bar === m2.bar, 'expando props the same');
    });
    QUnit.test('serialize: function works (#38)', function () {
        var Something = DefineMap.extend({});
        var MyMap = DefineMap.extend({
            somethingRef: {
                type: function (val) {
                    return new Something({ id: val });
                },
                serialize: function (val) {
                    return val.id;
                }
            },
            somethingElseRef: {
                type: function (val) {
                    return new Something({ id: val });
                },
                serialize: false
            }
        });
        var myMap = new MyMap({
            somethingRef: 2,
            somethingElseRef: 3
        });
        QUnit.ok(myMap.somethingRef instanceof Something);
        QUnit.deepEqual(myMap.serialize(), { somethingRef: 2 }, 'serialize: function and serialize: false works');
        var MyMap2 = DefineMap.extend({
            '*': {
                serialize: function (value) {
                    return '' + value;
                }
            }
        });
        var myMap2 = new MyMap2({
            foo: 1,
            bar: 2
        });
        QUnit.deepEqual(myMap2.serialize(), {
            foo: '1',
            bar: '2'
        }, 'serialize: function on default works');
    });
    QUnit.test('get will not create properties', function () {
        var method = function () {
        };
        var MyMap = DefineMap.extend({ method: method });
        var m = new MyMap();
        m.get('foo');
        QUnit.equal(m.get('method'), method);
    });
    QUnit.test('Properties are enumerable', function () {
        QUnit.expect(4);
        var VM = DefineMap.extend({ foo: 'string' });
        var vm = new VM({
            foo: 'bar',
            baz: 'qux'
        });
        var i = 0;
        each(vm, function (value, key) {
            if (i === 0) {
                QUnit.equal(key, 'foo');
                QUnit.equal(value, 'bar');
            } else {
                QUnit.equal(key, 'baz');
                QUnit.equal(value, 'qux');
            }
            i++;
        });
    });
    QUnit.test('Getters are not enumerable', function () {
        QUnit.expect(2);
        var MyMap = DefineMap.extend({
            foo: 'string',
            baz: {
                get: function () {
                    return this.foo;
                }
            }
        });
        var map = new MyMap({ foo: 'bar' });
        each(map, function (value, key) {
            QUnit.equal(key, 'foo');
            QUnit.equal(value, 'bar');
        });
    });
    QUnit.test('extending DefineMap constructor functions (#18)', function () {
        var AType = DefineMap.extend('AType', {
            aProp: {},
            aMethod: function () {
            }
        });
        var BType = AType.extend('BType', {
            bProp: {},
            bMethod: function () {
            }
        });
        var CType = BType.extend('CType', {
            cProp: {},
            cMethod: function () {
            }
        });
        var map = new CType();
        map.on('aProp', function (ev, newVal, oldVal) {
            QUnit.equal(newVal, 'PROP');
            QUnit.equal(oldVal, undefined);
        });
        map.on('bProp', function (ev, newVal, oldVal) {
            QUnit.equal(newVal, 'FOO');
            QUnit.equal(oldVal, undefined);
        });
        map.on('cProp', function (ev, newVal, oldVal) {
            QUnit.equal(newVal, 'BAR');
            QUnit.equal(oldVal, undefined);
        });
        map.aProp = 'PROP';
        map.bProp = 'FOO';
        map.cProp = 'BAR';
        QUnit.ok(map.aMethod);
        QUnit.ok(map.bMethod);
        QUnit.ok(map.cMethod);
    });
    QUnit.test('extending DefineMap constructor functions more than once (#18)', function () {
        var AType = DefineMap.extend('AType', {
            aProp: {},
            aMethod: function () {
            }
        });
        var BType = AType.extend('BType', {
            bProp: {},
            bMethod: function () {
            }
        });
        var CType = AType.extend('CType', {
            cProp: {},
            cMethod: function () {
            }
        });
        var map1 = new BType();
        var map2 = new CType();
        map1.on('aProp', function (ev, newVal, oldVal) {
            QUnit.equal(newVal, 'PROP', 'aProp newVal on map1');
            QUnit.equal(oldVal, undefined);
        });
        map1.on('bProp', function (ev, newVal, oldVal) {
            QUnit.equal(newVal, 'FOO', 'bProp newVal on map1');
            QUnit.equal(oldVal, undefined);
        });
        map2.on('aProp', function (ev, newVal, oldVal) {
            QUnit.equal(newVal, 'PROP', 'aProp newVal on map2');
            QUnit.equal(oldVal, undefined);
        });
        map2.on('cProp', function (ev, newVal, oldVal) {
            QUnit.equal(newVal, 'BAR', 'cProp newVal on map2');
            QUnit.equal(oldVal, undefined);
        });
        map1.aProp = 'PROP';
        map1.bProp = 'FOO';
        map2.aProp = 'PROP';
        map2.cProp = 'BAR';
        QUnit.ok(map1.aMethod, 'map1 aMethod');
        QUnit.ok(map1.bMethod);
        QUnit.ok(map2.aMethod);
        QUnit.ok(map2.cMethod, 'map2 cMethod');
    });
    QUnit.test('extending DefineMap constructor functions - value (#18)', function () {
        var AType = DefineMap.extend('AType', { aProp: { default: 1 } });
        var BType = AType.extend('BType', {});
        var CType = BType.extend('CType', {});
        var c = new CType();
        QUnit.equal(c.aProp, 1, 'got initial value');
    });
    QUnit.test('copying DefineMap excludes constructor', function () {
        var AType = DefineMap.extend('AType', { aProp: { default: 1 } });
        var a = new AType();
        var b = assign({}, a);
        QUnit.notEqual(a.constructor, b.constructor, 'Constructor prop not copied');
        QUnit.equal(a.aProp, b.aProp, 'Other values are unaffected');
    });
    QUnit.test('cloning from non-defined map excludes special keys on setup', function () {
        var MyType = DefineMap.extend({});
        var a = new MyType({ 'foo': 'bar' });
        var b = new DefineMap(a);
        QUnit.notEqual(a.constructor, b.constructor, 'Constructor prop not copied');
        QUnit.notEqual(a._data, b._data, '_data prop not copied');
        QUnit.equal(a.foo, b.foo, 'Other props copied');
    });
    QUnit.test('copying from .set() excludes special keys', function () {
        var MyType = DefineMap.extend({});
        var a = new MyType({
            'foo': 'bar',
            'existing': 'newVal'
        });
        var b = new DefineMap({ 'existing': 'oldVal' });
        b.assign(a);
        QUnit.notEqual(a.constructor, b.constructor, 'Constructor prop not copied');
        QUnit.notEqual(a._data, b._data, '_data prop not copied');
        QUnit.equal(a.foo, b.foo, 'NEw props copied');
    });
    QUnit.test('copying with assign() excludes special keys', function () {
        var a = {
            _data: {},
            constructor: function () {
            },
            __bindEvents: {},
            'foo': 'bar',
            'existing': 'newVal'
        };
        var b = new DefineMap({ 'existing': 'oldVal' });
        assign(b, a);
        QUnit.notEqual(a.constructor, b.constructor, 'Constructor prop not copied');
        QUnit.notEqual(a._data, b._data, '_data prop not copied');
        QUnit.equal(a.foo, b.foo, 'New props copied');
        QUnit.equal(a.existing, b.existing, 'Existing props copied');
    });
    QUnit.test('shorthand getter setter (#56)', function () {
        var Person = DefineMap.extend({
            first: '*',
            last: '*',
            get fullName() {
                return this.first + ' ' + this.last;
            },
            set fullName(newVal) {
                var parts = newVal.split(' ');
                this.first = parts[0];
                this.last = parts[1];
            }
        });
        var p = new Person({
            first: 'Mohamed',
            last: 'Cherif'
        });
        p.on('fullName', function (ev, newVal, oldVal) {
            QUnit.equal(oldVal, 'Mohamed Cherif');
            QUnit.equal(newVal, 'Justin Meyer');
        });
        equal(p.fullName, 'Mohamed Cherif', 'fullName initialized right');
        p.fullName = 'Justin Meyer';
    });
    QUnit.test('compute props can be set to null or undefined (#2372)', function () {
        var VM = DefineMap.extend({ computeProp: { type: 'compute' } });
        var vmNull = new VM({ computeProp: null });
        QUnit.equal(vmNull.get('computeProp'), null, 'computeProp is null, no error thrown');
        var vmUndef = new VM({ computeProp: undefined });
        QUnit.equal(vmUndef.get('computeProp'), undefined, 'computeProp is undefined, no error thrown');
    });
    QUnit.test('Inheriting DefineMap .set doesn\'t work if prop is on base map (#74)', function () {
        var Base = DefineMap.extend({ baseProp: 'string' });
        var Inheriting = Base.extend();
        var inherting = new Inheriting();
        inherting.set('baseProp', 'value');
        QUnit.equal(inherting.baseProp, 'value', 'set prop');
    });
    if (sealWorks && System.env.indexOf('production') < 0) {
        QUnit.test('setting not defined property', function () {
            var MyMap = DefineMap.extend({ prop: {} });
            var mymap = new MyMap();
            try {
                mymap.notdefined = 'value';
                ok(false, 'no error');
            } catch (e) {
                ok(true, 'error thrown');
            }
        });
    }
    QUnit.test('.extend errors when re-defining a property (#117)', function () {
        var A = DefineMap.extend('A', {
            foo: {
                type: 'string',
                default: 'blah'
            }
        });
        A.extend('B', {
            foo: {
                type: 'string',
                default: 'flub'
            }
        });
        var C = DefineMap.extend('C', {
            foo: {
                get: function () {
                    return 'blah';
                }
            }
        });
        C.extend('D', {
            foo: {
                get: function () {
                    return 'flub';
                }
            }
        });
        QUnit.ok(true, 'extended without errors');
    });
    QUnit.test('.value functions should not be observable', function () {
        var outer = new DefineMap({ bam: 'baz' });
        var ItemsVM = DefineMap.extend({
            item: {
                default: function () {
                    (function () {
                    }(this.zed, outer.bam));
                    return new DefineMap({ foo: 'bar' });
                }
            },
            zed: 'string'
        });
        var items = new ItemsVM();
        var count = 0;
        var itemsList = new Observation(function () {
            count++;
            return items.item;
        });
        canReflect.onValue(itemsList, function () {
        });
        items.item.foo = 'changed';
        items.zed = 'changed';
        equal(count, 1);
    });
    QUnit.test('.value values are overwritten by props in DefineMap construction', function () {
        var Foo = DefineMap.extend({ bar: { default: 'baz' } });
        var foo = new Foo({ bar: 'quux' });
        equal(foo.bar, 'quux', 'Value set properly');
    });
    QUnit.test('can-reflect reflections work with DefineMap', function () {
        var b = new DefineMap({ 'foo': 'bar' });
        var c = new (DefineMap.extend({
            'baz': {
                get: function () {
                    return b.foo;
                }
            }
        }))({
            'foo': 'bar',
            thud: 'baz'
        });
        QUnit.equal(canReflect.getKeyValue(b, 'foo'), 'bar', 'unbound value');
        var handler = function (newValue) {
            QUnit.equal(newValue, 'quux', 'observed new value');
            canReflect.offKeyValue(c, 'baz', handler);
        };
        QUnit.ok(!canReflect.isValueLike(c), 'isValueLike is false');
        QUnit.ok(canReflect.isObservableLike(c), 'isObservableLike is true');
        QUnit.ok(canReflect.isMapLike(c), 'isMapLike is true');
        QUnit.ok(!canReflect.isListLike(c), 'isListLike is false');
        QUnit.ok(!canReflect.keyHasDependencies(b, 'foo'), 'keyHasDependencies -- false');
        canReflect.onKeyValue(c, 'baz', handler);
        canReflect.onKeyValue(c, 'thud', handler);
        QUnit.ok(canReflect.keyHasDependencies(c, 'baz'), 'keyHasDependencies -- true');
        b.foo = 'quux';
        c.thud = 'quux';
        QUnit.equal(canReflect.getKeyValue(c, 'baz'), 'quux', 'bound value');
        b.foo = 'thud';
        c.baz = 'jeek';
    });
    QUnit.test('can-reflect setKeyValue', function () {
        var a = new DefineMap({ 'a': 'b' });
        canReflect.setKeyValue(a, 'a', 'c');
        QUnit.equal(a.a, 'c', 'setKeyValue');
    });
    QUnit.test('can-reflect deleteKeyValue', function () {
        var a = new DefineMap({ 'a': 'b' });
        canReflect.deleteKeyValue(a, 'a');
        QUnit.equal(a.a, undefined, 'value is now undefined');
        QUnit.ok(!('a' in a.get()), 'value not included in serial');
    });
    QUnit.test('can-reflect getKeyDependencies', function () {
        var a = new DefineMap({ 'a': 'a' });
        var b = new (DefineMap.extend({
            'a': {
                get: function () {
                    return a.a;
                }
            }
        }))();
        ok(canReflect.getKeyDependencies(b, 'a'), 'dependencies exist');
        ok(!canReflect.getKeyDependencies(b, 'b'), 'no dependencies exist for unknown value');
        ok(canReflect.getKeyDependencies(b, 'a').valueDependencies.has(b._computed.a.compute), 'dependencies returned');
    });
    QUnit.test('can-reflect assign', function () {
        var aData = { 'a': 'b' };
        var bData = { 'b': 'c' };
        var a = new DefineMap(aData);
        var b = new DefineMap(bData);
        canReflect.assign(a, b);
        QUnit.deepEqual(a.get(), assign(aData, bData), 'when called with an object, should merge into existing object');
    });
    QUnit.test('Does not attempt to redefine _data if already defined', function () {
        var Bar = DefineMap.extend({ seal: false }, { baz: { default: 'thud' } });
        var baz = new Bar();
        define(baz, {
            quux: { default: 'jeek' },
            plonk: {
                get: function () {
                    return 'waldo';
                }
            }
        }, baz._define);
        QUnit.equal(baz.quux, 'jeek', 'New definitions successful');
        QUnit.equal(baz.plonk, 'waldo', 'New computed definitions successful');
        QUnit.equal(baz.baz, 'thud', 'Old definitions still available');
    });
    if (!System.isEnv('production')) {
        QUnit.test('redefines still not allowed on sealed objects', function () {
            QUnit.expect(6);
            var Bar = DefineMap.extend({ seal: true }, { baz: { default: 'thud' } });
            var baz = new Bar();
            try {
                define(baz, { quux: { default: 'jeek' } }, baz._define);
            } catch (e) {
                QUnit.ok(/is not extensible/i.test(e.message), 'Sealed object throws on data property defines');
                QUnit.ok(!Object.getOwnPropertyDescriptor(baz, 'quux'), 'nothing set on object');
                QUnit.ok(!Object.getOwnPropertyDescriptor(baz._data, 'quux'), 'nothing set on _data');
            }
            try {
                define(baz, {
                    plonk: {
                        get: function () {
                            return 'waldo';
                        }
                    }
                }, baz._define);
            } catch (e) {
                QUnit.ok(/is not extensible/i.test(e.message), 'Sealed object throws on computed property defines');
                QUnit.ok(!Object.getOwnPropertyDescriptor(baz, 'plonk'), 'nothing set on object');
                QUnit.ok(!Object.getOwnPropertyDescriptor(baz._computed, 'plonk'), 'nothing set on _computed');
            }
        });
    }
    QUnit.test('Call .get() when a nested object has its own get method', function () {
        var Bar = DefineMap.extend({ request: '*' });
        var request = {
            prop: 22,
            get: function () {
                if (arguments.length === 0) {
                    throw new Error('This function can\'t be called with 0 arguments');
                }
            }
        };
        var obj = new Bar({ request: request });
        var data = obj.get();
        QUnit.equal(data.request.prop, 22, 'obj did get()');
    });
    QUnit.test('DefineMap short-hand Type (#221)', function () {
        var Child = DefineMap.extend('child', { other: DefineMap });
        var c = new Child();
        c.other = { prop: 'hello' };
        QUnit.ok(c.other instanceof DefineMap, 'is a DefineMap');
    });
    QUnit.test('non-Object constructor', function () {
        var Constructor = DefineMap.extend();
        QUnit.ok(!isPlainObject(new DefineMap()), 'instance of DefineMap is not a plain object');
        QUnit.ok(!isPlainObject(new Constructor()), 'instance of extended DefineMap is not a plain object');
    });
    QUnit.test('Observation bound to getter using lastSetVal updates correctly (canjs#3541)', function () {
        var MyMap = DefineMap.extend({
            foo: {
                get: function (lastSetVal) {
                    if (lastSetVal) {
                        return lastSetVal;
                    }
                }
            }
        });
        var map = new MyMap();
        var oi = new Observation(function () {
            return map.get('foo');
        });
        canReflect.onValue(oi, function (newVal) {
            QUnit.equal(newVal, 'bar', 'updated to bar');
        });
        map.set('foo', 'bar');
    });
    QUnit.test('Observation bound to async getter updates correctly (canjs#3541)', function () {
        var MyMap = DefineMap.extend({
            foo: {
                get: function (lastSetVal, resolve) {
                    if (lastSetVal) {
                        return resolve(lastSetVal);
                    }
                }
            }
        });
        var map = new MyMap();
        var oi = new Observation(function () {
            return map.get('foo');
        });
        canReflect.onValue(oi, function (newVal) {
            QUnit.equal(newVal, 'bar', 'updated to bar');
        });
        map.set('foo', 'bar');
    });
    canTestHelpers.devOnlyTest('log all property changes', function (assert) {
        var done = assert.async();
        var Person = DefineMap.extend({
            first: 'string',
            last: 'string',
            children: { Type: DefineList },
            fullName: {
                get: function () {
                    return this.first + ' ' + this.last;
                }
            }
        });
        var changed = [];
        var log = dev.log;
        dev.log = function () {
            changed.push(JSON.parse(arguments[2]));
        };
        var p = new Person();
        p.log();
        p.on('fullName', function () {
        });
        p.first = 'Manuel';
        p.last = 'Mujica';
        assert.expect(1);
        setTimeout(function () {
            dev.log = log;
            assert.deepEqual(changed, [
                'first',
                'fullName',
                'last',
                'fullName'
            ], 'should log all property changes');
            done();
        });
    });
    canTestHelpers.devOnlyTest('log single property changes', function (assert) {
        var done = assert.async();
        var Person = DefineMap.extend({
            first: 'string',
            last: 'string',
            age: 'number'
        });
        var changed = [];
        var log = dev.log;
        dev.log = function () {
            changed.push(JSON.parse(arguments[2]));
        };
        var p = new Person();
        p.log('first');
        p.first = 'John';
        p.last = 'Doe';
        p.age = 99;
        assert.expect(1);
        setTimeout(function () {
            dev.log = log;
            assert.deepEqual(changed, ['first'], 'should log \'first\' changes');
            done();
        });
    });
    canTestHelpers.devOnlyTest('log multiple property changes', function (assert) {
        var done = assert.async();
        var Person = DefineMap.extend({
            first: 'string',
            last: 'string',
            age: 'number',
            company: 'string'
        });
        var changed = [];
        var log = dev.log;
        dev.log = function () {
            changed.push(JSON.parse(arguments[2]));
        };
        var p = new Person();
        p.log('first');
        p.log('age');
        p.first = 'John';
        p.last = 'Doe';
        p.company = 'Bitovi';
        p.age = 99;
        assert.expect(1);
        setTimeout(function () {
            dev.log = log;
            assert.deepEqual(changed, [
                'first',
                'age'
            ], 'should log first and age');
            done();
        });
    });
    canTestHelpers.devOnlyTest('Setting a value with an object type generates a warning (#148)', function () {
        QUnit.expect(1);
        var message = 'can-define: The value for options is set to an object. This will be shared by all instances of the DefineMap. Use a function that returns the object instead.';
        var finishErrorCheck = canTestHelpers.willWarn(message);
        DefineMap.extend({ options: { default: {} } });
        DefineMap.extend({ options: { default: [] } });
        DefineMap.extend({
            options: {
                default: function () {
                }
            }
        });
        DefineMap.extend({ options: { default: 2 } });
        QUnit.equal(finishErrorCheck(), 2);
    });
    canTestHelpers.devOnlyTest('Setting a value to a constructor type generates a warning', function () {
        QUnit.expect(1);
        var message = 'can-define: The "value" for options is set to a constructor. Did you mean "Value" instead?';
        var finishErrorCheck = canTestHelpers.willWarn(message);
        DefineMap.extend({ options: { default: DefineMap } });
        QUnit.equal(finishErrorCheck(), 1);
    });
    canTestHelpers.devOnlyTest('can.getName symbol behavior', function (assert) {
        var getName = function (instance) {
            return instance[canSymbol.for('can.getName')]();
        };
        assert.ok('DefineMap{}', getName(new DefineMap()), 'should use DefineMap constructor name by default');
        var MyMap = DefineMap.extend('MyMap', {});
        assert.ok('MyMap{}', getName(new MyMap()), 'should use custom map name when provided');
    });
    canTestHelpers.devOnlyTest('Error on not using a constructor or string on short-hand definitions (#278)', function () {
        expect(5);
        var message = /.+ on .+ does not match a supported propDefinition. See: https:\/\/canjs.com\/doc\/can-define.types.propDefinition.html/i;
        var finishErrorCheck = canTestHelpers.willError(message, function (actual, match) {
            var rightProp = /prop0[15]/;
            QUnit.ok(rightProp.test(actual.slice(0, 6)));
            QUnit.ok(match);
        });
        DefineMap.extend('ShortName', {
            prop01: 0,
            prop02: function () {
            },
            prop03: 'string',
            prop04: DefineMap,
            prop05: 'a string that is not a type',
            prop06: [],
            get prop07() {
            },
            set prop07(newVal) {
            },
            prop08: 'boolean'
        });
        QUnit.equal(finishErrorCheck(), 2);
    });
    QUnit.test('Improper shorthand properties are not set', function () {
        var VM = DefineMap.extend({
            prop01: 0,
            prop02: function () {
            },
            prop03: 'some random string'
        });
        QUnit.equal(VM.prototype._define.methods.prop01, undefined);
        QUnit.equal(typeof VM.prototype._define.methods.prop02, 'function');
        QUnit.equal(VM.prototype._define.methods.prop03, undefined);
    });
    QUnit.test('onKeyValue sets up computed values', function () {
        var fullNameCalls = [];
        var VM = DefineMap.extend({
            first: 'string',
            last: 'string',
            get fullName() {
                fullNameCalls.push(this.first + ' ' + this.last);
                return this.first + ' ' + this.last;
            }
        });
        var vm = new VM({
            first: 'J',
            last: 'M'
        });
        canReflect.onKeyValue(vm, 'fullName', function () {
        });
        QUnit.deepEqual(fullNameCalls, ['J M']);
    });
    QUnit.test('async getters derived from other properties should have correct keyDependencies', function () {
        var VM = DefineMap.extend({
            get source() {
                return 'source value';
            },
            derived: {
                get: function (last, resolve) {
                    return resolve(this.source);
                }
            }
        });
        var vm = new VM();
        vm.on('derived', function () {
        });
        QUnit.ok(vm._computed.derived.compute.observation.newDependencies.keyDependencies.get(vm).has('source'), 'getter should depend on vm.source');
    });
    var sealDoesErrorWithPropertyName = function () {
        'use strict';
        var o = Object.seal({});
        try {
            o.foo = 'bar';
        } catch (error) {
            return error.message.indexOf('foo') !== -1;
        }
        return false;
    }();
    canTestHelpers.devOnlyTest('setting a property gives a nice error', function () {
        var VM = DefineMap.extend({});
        var vm = new VM();
        try {
            vm.set('fooxyz', 'bar');
        } catch (error) {
            if (sealDoesErrorWithPropertyName) {
                QUnit.ok(error.message.indexOf('fooxyz') !== -1, 'Set property error with property name should be thrown');
            } else {
                QUnit.ok(true, 'Set property error should be thrown');
            }
        }
    });
    canTestHelpers.devOnlyTest('can.hasKey and can.hasOwnKey (#303)', function (assert) {
        var hasKeySymbol = canSymbol.for('can.hasKey'), hasOwnKeySymbol = canSymbol.for('can.hasOwnKey');
        var Parent = DefineMap.extend({
            parentProp: 'any',
            get parentDerivedProp() {
                if (this.parentProp) {
                    return 'parentDerived';
                }
            }
        });
        var VM = Parent.extend({
            prop: 'any',
            get derivedProp() {
                if (this.prop) {
                    return 'derived';
                }
            }
        });
        var vm = new VM();
        assert.equal(vm[hasKeySymbol]('prop'), true, 'vm.hasKey(\'prop\') true');
        assert.equal(vm[hasKeySymbol]('derivedProp'), true, 'vm.hasKey(\'derivedProp\') true');
        assert.equal(vm[hasKeySymbol]('parentProp'), true, 'vm.hasKey(\'parentProp\') true');
        assert.equal(vm[hasKeySymbol]('parentDerivedProp'), true, 'vm.hasKey(\'parentDerivedProp\') true');
        assert.equal(vm[hasKeySymbol]('anotherProp'), false, 'vm.hasKey(\'anotherProp\') false');
        assert.equal(vm[hasOwnKeySymbol]('prop'), true, 'vm.hasOwnKey(\'prop\') true');
        assert.equal(vm[hasOwnKeySymbol]('derivedProp'), true, 'vm.hasOwnKey(\'derivedProp\') true');
        assert.equal(vm[hasOwnKeySymbol]('parentProp'), false, 'vm.hasOwnKey(\'parentProp\') false');
        assert.equal(vm[hasOwnKeySymbol]('parentDerivedProp'), false, 'vm.hasOwnKey(\'parentDerivedProp\') false');
        assert.equal(vm[hasOwnKeySymbol]('anotherProp'), false, 'vm.hasOwnKey(\'anotherProp\') false');
    });
    QUnit.test('value as a string breaks', function () {
        var MyMap = DefineMap.extend({ prop: { value: 'a string' } });
        var my = new MyMap();
        QUnit.equal(my.prop, 'a string', 'works');
    });
});
/*can-define@2.0.1#test/test-list-and-map*/
define('can-define@2.0.1#test/test-list-and-map', [
    'require',
    'exports',
    'module',
    'can-define/map/map',
    'can-define/list/list',
    'can-util/js/is-plain-object/is-plain-object',
    'can-observation',
    'can-reflect',
    'can-define',
    'steal-qunit'
], function (require, exports, module) {
    var DefineMap = require('can-define/map/map');
    var DefineList = require('can-define/list/list');
    var isPlainObject = require('can-util/js/is-plain-object/is-plain-object');
    var Observation = require('can-observation');
    var canReflect = require('can-reflect');
    var define = require('can-define');
    var QUnit = require('steal-qunit');
    QUnit.module('can-define: map and list combined');
    QUnit.test('basics', function () {
        var items = new DefineMap({
            people: [
                { name: 'Justin' },
                { name: 'Brian' }
            ],
            count: 1000
        });
        QUnit.ok(items.people instanceof DefineList, 'people is list');
        QUnit.ok(items.people.item(0) instanceof DefineMap, '1st object is Map');
        QUnit.ok(items.people.item(1) instanceof DefineMap, '2nd object is Map');
        QUnit.equal(items.people.item(1).name, 'Brian', '2nd object\'s name is right');
        QUnit.equal(items.count, 1000, 'count is number');
    });
    QUnit.test('basic type', function () {
        QUnit.expect(6);
        var Typer = function (arrayWithAddedItem, listWithAddedItem) {
            this.arrayWithAddedItem = arrayWithAddedItem;
            this.listWithAddedItem = listWithAddedItem;
        };
        define(Typer.prototype, {
            arrayWithAddedItem: {
                type: function (value) {
                    if (value && value.push) {
                        value.push('item');
                    }
                    return value;
                }
            },
            listWithAddedItem: {
                type: function (value) {
                    if (value && value.push) {
                        value.push('item');
                    }
                    return value;
                },
                Type: DefineList
            }
        });
        var t = new Typer();
        deepEqual(Object.keys(t), [], 'no keys');
        var array = [];
        t.arrayWithAddedItem = array;
        deepEqual(array, ['item'], 'updated array');
        QUnit.equal(t.arrayWithAddedItem, array, 'leave value as array');
        t.listWithAddedItem = [];
        QUnit.ok(t.listWithAddedItem instanceof DefineList, 'convert to CanList');
        QUnit.equal(t.listWithAddedItem[0], 'item', 'has item in it');
        var observation = new Observation(function () {
            return t.listWithAddedItem.attr('length');
        });
        canReflect.onValue(observation, function (newVal) {
            QUnit.equal(newVal, 2, 'got a length change');
        });
        t.listWithAddedItem.push('another item');
    });
    QUnit.test('serialize works', function () {
        var Person = DefineMap.extend({
            first: 'string',
            last: 'string'
        });
        var People = DefineList.extend({ '*': Person });
        var people = new People([{
                first: 'j',
                last: 'm'
            }]);
        QUnit.deepEqual(people.serialize(), [{
                first: 'j',
                last: 'm'
            }]);
    });
    QUnit.test('Extended Map with empty def converts to default Observables', function () {
        var School = DefineMap.extend({
            students: {},
            teacher: {}
        });
        var school = new School();
        school.students = [{ name: 'J' }];
        school.teacher = { name: 'M' };
        ok(school.students instanceof DefineList, 'converted to DefineList');
        ok(school.teacher instanceof DefineMap, 'converted to DefineMap');
    });
    QUnit.test('default \'observable\' type prevents Type from working (#29)', function () {
        var M = DefineMap.extend('M', { id: 'number' });
        var L = DefineList.extend('L', { '*': M });
        var MyMap = DefineMap.extend({ l: L });
        var m = new MyMap({ l: [{ id: 5 }] });
        QUnit.ok(m.l[0] instanceof M, 'is instance');
        QUnit.equal(m.l[0].id, 5, 'correct props');
    });
    QUnit.test('inline DefineList Type', function () {
        var M = DefineMap.extend('M', { id: 'number' });
        var MyMap = DefineMap.extend({ l: { Type: [M] } });
        var m = new MyMap({ l: [{ id: 5 }] });
        QUnit.ok(m.l[0] instanceof M, 'is instance');
        QUnit.equal(m.l[0].id, 5, 'correct props');
    });
    QUnit.test('recursively `get`s (#31)', function () {
        var M = DefineMap.extend('M', { id: 'number' });
        var MyMap = DefineMap.extend({ l: { Type: [M] } });
        var m = new MyMap({ l: [{ id: 5 }] });
        var res = m.get();
        QUnit.ok(Array.isArray(res.l), 'is a plain array');
        QUnit.ok(isPlainObject(res.l[0]), 'plain object');
    });
    QUnit.test('DefineList trigger deprecation warning when set with Map.set (#93)', 0, function () {
        var map = new DefineMap({ things: [{ foo: 'bar' }] });
        map.things.attr = function () {
            ok(false, 'attr should not be called');
        };
        map.assign({ things: [{ baz: 'luhrmann' }] });
    });
    test('Value generator can read other properties', function () {
        var Map = define.Constructor({
            letters: { default: 'ABC' },
            numbers: {
                default: [
                    1,
                    2,
                    3
                ]
            },
            definedLetters: { default: 'DEF' },
            definedNumbers: {
                default: [
                    4,
                    5,
                    6
                ]
            },
            generatedLetters: {
                default: function () {
                    return 'GHI';
                }
            },
            generatedNumbers: {
                default: function () {
                    return new DefineList([
                        7,
                        8,
                        9
                    ]);
                }
            },
            firstLetter: {
                default: function () {
                    return this.letters.substr(0, 1);
                }
            },
            firstNumber: {
                default: function () {
                    return this.numbers[0];
                }
            },
            middleLetter: {
                default: function () {
                    return this.definedLetters.substr(1, 1);
                }
            },
            middleNumber: {
                default: function () {
                    return this.definedNumbers[1];
                }
            },
            lastLetter: {
                default: function () {
                    return this.generatedLetters.substr(2, 1);
                }
            },
            lastNumber: {
                default: function () {
                    return this.generatedNumbers[2];
                }
            }
        });
        var map = new Map();
        var prefix = 'Was able to read dependent value from ';
        equal(map.firstLetter, 'A', prefix + 'traditional can.Map style property definition');
        equal(map.firstNumber, 1, prefix + 'traditional can.Map style property definition');
        equal(map.middleLetter, 'E', prefix + 'define plugin style default property definition');
        equal(map.middleNumber, 5, prefix + 'define plugin style default property definition');
        equal(map.lastLetter, 'I', prefix + 'define plugin style generated default property definition');
        equal(map.lastNumber, 9, prefix + 'define plugin style generated default property definition');
    });
    test('value and get (#1521)', function () {
        var MyMap = define.Constructor({
            data: {
                default: function () {
                    return new DefineList(['test']);
                }
            },
            size: {
                default: 1,
                get: function (val) {
                    var list = this.data;
                    var length = list.attr('length');
                    return val + length;
                }
            }
        });
        var map = new MyMap({});
        equal(map.size, 2);
    });
    QUnit.test('Assign value on map', function () {
        var MyConstruct = DefineMap.extend({
            list: DefineList,
            name: 'string'
        });
        var obj = new MyConstruct({
            list: [
                'data',
                'data',
                'data'
            ],
            name: 'CanJS',
            foo: {
                bar: 'bar',
                zoo: 'say'
            }
        });
        obj.assign({
            list: ['another'],
            foo: { bar: 'zed' }
        });
        QUnit.equal(obj.list.length, 1, 'list length should be 1');
        QUnit.propEqual(obj.foo, { bar: 'zed' }, 'foo.bar is set correctly');
        QUnit.equal(obj.name, 'CanJS', 'name is unchanged');
    });
    QUnit.test('Update value on a map', function () {
        var MyConstruct = DefineMap.extend({
            list: DefineList,
            name: 'string'
        });
        var obj = new MyConstruct({
            list: [
                'data',
                'data',
                'data'
            ],
            name: 'CanJS',
            foo: { bar: 'bar' }
        });
        obj.update({
            list: ['another'],
            foo: { bar: 'zed' }
        });
        QUnit.equal(obj.list.length, 1, 'list length should be 1');
        QUnit.equal(obj.foo.bar, 'zed', 'foo.bar is set correctly');
        QUnit.equal(obj.name, undefined, 'name is removed');
    });
    QUnit.test('Deep assign a map', function () {
        var MyConstruct = DefineMap.extend({
            list: DefineList,
            name: 'string'
        });
        var obj = new MyConstruct({
            list: [
                'data',
                'data',
                'data'
            ],
            name: 'Test Name'
        });
        QUnit.equal(obj.list.length, 3, 'list length should be 3');
        obj.assignDeep({ list: ['something'] });
        QUnit.equal(obj.name, 'Test Name', 'Name property is still intact');
        QUnit.equal(obj.list[0], 'something', 'the first element in the list should be updated');
    });
    QUnit.test('Deep updating a map', function () {
        var MyConstruct = DefineMap.extend({
            list: DefineList,
            name: 'string'
        });
        var obj = new MyConstruct({
            list: [
                'data',
                'data',
                'data'
            ],
            name: 'Test Name'
        });
        QUnit.equal(obj.list.length, 3, 'list length should be 3');
        obj.updateDeep({ list: ['something'] });
        QUnit.equal(obj.name, undefined, 'Name property has been reset');
        QUnit.equal(obj.list[0], 'something', 'the first element of the list should be updated');
    });
});
/*can-reflect-tests@0.2.0#observables/map-like/type/define-instance-key*/
define('can-reflect-tests@0.2.0#observables/map-like/type/define-instance-key', [
    'require',
    'exports',
    'module',
    'steal-qunit',
    'can-symbol',
    'can-reflect'
], function (require, exports, module) {
    var QUnit = require('steal-qunit');
    var canSymbol = require('can-symbol');
    var canReflect = require('can-reflect');
    module.exports = function (name, makeType) {
        QUnit.test(name + ' canReflect.defineInstanceKey', function () {
            var Type = makeType();
            Type[canSymbol.for('can.defineInstanceKey')]('prop', {
                value: 0,
                configurable: true,
                writable: true,
                enumerable: true
            });
            var t = new Type();
            QUnit.equal(canReflect.getKeyValue(t, 'prop'), 0, 'default value used');
            canReflect.setKeyValue(t, 'prop', '5');
            t.prop = '5';
            QUnit.equal(t.prop, '5', 'value set');
        });
    };
});
/*can-reflect-tests@0.2.0#observables/map-like/type/define-instance-key-enumerable*/
define('can-reflect-tests@0.2.0#observables/map-like/type/define-instance-key-enumerable', [
    'require',
    'exports',
    'module',
    'steal-qunit',
    'can-symbol',
    'can-reflect'
], function (require, exports, module) {
    var QUnit = require('steal-qunit');
    var canSymbol = require('can-symbol');
    var canReflect = require('can-reflect');
    module.exports = function (name, makeType) {
        QUnit.test(name + ' canReflect.defineInstanceKey with enumerable', function () {
            var Type = makeType();
            Type[canSymbol.for('can.defineInstanceKey')]('prop', {
                configurable: true,
                writable: true,
                enumerable: true
            });
            Type[canSymbol.for('can.defineInstanceKey')]('nonEnum', {
                enumerable: false,
                value: 0,
                configurable: true,
                writable: true
            });
            var t = new Type();
            QUnit.equal(canReflect.getKeyValue(t, 'nonEnum'), 0, 'default value used');
            canReflect.setKeyValue(t, 'prop', '5');
            t.prop = '5';
            QUnit.equal(t.prop, '5', 'value set');
            QUnit.deepEqual(canReflect.serialize(t), { prop: '5' }, 'enumerable respected');
        });
    };
});
/*can-reflect-tests@0.2.0#observables/map-like/type/on-instance-bound-change*/
define('can-reflect-tests@0.2.0#observables/map-like/type/on-instance-bound-change', [
    'require',
    'exports',
    'module',
    'steal-qunit',
    'can-symbol',
    'can-reflect'
], function (require, exports, module) {
    var QUnit = require('steal-qunit');
    var canSymbol = require('can-symbol');
    var canReflect = require('can-reflect');
    module.exports = function (name, makeType) {
        QUnit.test(name + ' canReflect.onInstanceBoundChange', function () {
            var Type = makeType();
            Type[canSymbol.for('can.defineInstanceKey')]('prop', {
                configurable: true,
                writable: true,
                enumerable: true
            });
            var calls = [];
            function handler(obj, patches) {
                calls.push([
                    obj,
                    patches
                ]);
            }
            Type[canSymbol.for('can.onInstanceBoundChange')](handler);
            var instance = new Type({ prop: 'value' });
            var bindHandler = function () {
            };
            canReflect.onKeyValue(instance, 'prop', bindHandler);
            canReflect.offKeyValue(instance, 'prop', bindHandler);
            Type[canSymbol.for('can.offInstanceBoundChange')](handler);
            canReflect.onKeyValue(instance, 'prop', bindHandler);
            canReflect.offKeyValue(instance, 'prop', bindHandler);
            QUnit.deepEqual(calls, [
                [
                    instance,
                    true
                ],
                [
                    instance,
                    false
                ]
            ]);
        });
    };
});
/*can-reflect-tests@0.2.0#observables/map-like/type/on-instance-patches*/
define('can-reflect-tests@0.2.0#observables/map-like/type/on-instance-patches', [
    'require',
    'exports',
    'module',
    'steal-qunit',
    'can-symbol',
    'can-reflect'
], function (require, exports, module) {
    var QUnit = require('steal-qunit');
    var canSymbol = require('can-symbol');
    var canReflect = require('can-reflect');
    module.exports = function (name, makeType) {
        QUnit.test(name + ' canReflect.onInstancePatches', function () {
            var Type = makeType();
            Type[canSymbol.for('can.defineInstanceKey')]('first', {
                configurable: true,
                writable: true,
                enumerable: true
            });
            Type[canSymbol.for('can.defineInstanceKey')]('last', {
                configurable: true,
                writable: true,
                enumerable: true
            });
            Type[canSymbol.for('can.defineInstanceKey')]('middle', {
                configurable: true,
                writable: true,
                enumerable: true
            });
            var calls = [];
            function handler(obj, patches) {
                calls.push([
                    obj,
                    patches
                ]);
            }
            Type[canSymbol.for('can.onInstancePatches')](handler);
            var instance = new Type({
                first: 'Justin',
                last: 'Meyer'
            });
            canReflect.setKeyValue(instance, 'first', 'Payal');
            canReflect.setKeyValue(instance, 'last', 'Shah');
            canReflect.setKeyValue(instance, 'middle', 'p');
            Type[canSymbol.for('can.offInstancePatches')](handler);
            canReflect.setKeyValue(instance, 'first', 'Ramiya');
            canReflect.setKeyValue(instance, 'last', 'Mayer');
            canReflect.setKeyValue(instance, 'middle', 'P');
            QUnit.deepEqual(calls, [
                [
                    instance,
                    [{
                            type: 'set',
                            key: 'first',
                            value: 'Payal'
                        }]
                ],
                [
                    instance,
                    [{
                            type: 'set',
                            key: 'last',
                            value: 'Shah'
                        }]
                ],
                [
                    instance,
                    [{
                            type: 'set',
                            key: 'middle',
                            value: 'p'
                        }]
                ]
            ]);
        });
    };
});
/*can-reflect-tests@0.2.0#observables/map-like/type/type*/
define('can-reflect-tests@0.2.0#observables/map-like/type/type', [
    'require',
    'exports',
    'module',
    './define-instance-key',
    './define-instance-key-enumerable',
    './on-instance-bound-change',
    './on-instance-patches'
], function (require, exports, module) {
    var defineInstanceKey = require('./define-instance-key');
    var defineInstanceKeyEnumerable = require('./define-instance-key-enumerable');
    var onInstanceBoundChange = require('./on-instance-bound-change');
    var onInstanceBatches = require('./on-instance-patches');
    module.exports = function (name, makeType) {
        defineInstanceKey(name, makeType);
        defineInstanceKeyEnumerable(name, makeType);
        onInstanceBoundChange(name, makeType);
        onInstanceBatches(name, makeType);
    };
});
/*can-reflect-tests@0.2.0#observables/list-like/type/on-instance-patches*/
define('can-reflect-tests@0.2.0#observables/list-like/type/on-instance-patches', [
    'require',
    'exports',
    'module',
    'steal-qunit',
    'can-symbol',
    'can-reflect'
], function (require, exports, module) {
    var QUnit = require('steal-qunit');
    var canSymbol = require('can-symbol');
    var canReflect = require('can-reflect');
    module.exports = function (name, makeType) {
        QUnit.test(name + ' canRelect.onInstancePatches with splice', function () {
            var Type = makeType();
            var calls = [];
            function handler(obj, patches) {
                calls.push([
                    obj,
                    patches
                ]);
            }
            Type[canSymbol.for('can.onInstancePatches')](handler);
            var list = new Type([
                1,
                2
            ]);
            list.splice(2, 0, 3);
            Type[canSymbol.for('can.offInstancePatches')](handler);
            list.splice(3, 0, 4);
            QUnit.deepEqual(calls, [[
                    list,
                    [{
                            type: 'splice',
                            index: 2,
                            deleteCount: 0,
                            insert: [3]
                        }]
                ]]);
        });
    };
});
/*can-define@2.0.1#test/test-type-events*/
define('can-define@2.0.1#test/test-type-events', [
    'require',
    'exports',
    'module',
    'steal-qunit',
    'can-define/list/list',
    'can-define/map/map',
    'can-reflect-tests/observables/map-like/type/type',
    'can-reflect-tests/observables/map-like/type/define-instance-key',
    'can-reflect-tests/observables/map-like/type/on-instance-bound-change',
    'can-reflect-tests/observables/map-like/type/on-instance-patches',
    'can-reflect-tests/observables/list-like/type/on-instance-patches'
], function (require, exports, module) {
    'use strict';
    var QUnit = require('steal-qunit');
    var DefineList = require('can-define/list/list');
    var DefineMap = require('can-define/map/map');
    QUnit.module('can-define Type events');
    require('can-reflect-tests/observables/map-like/type/type')('DefineMap', function () {
        return DefineMap.extend({ seal: false }, {});
    });
    require('can-reflect-tests/observables/map-like/type/define-instance-key')('DefineList', function () {
        return DefineList.extend();
    });
    require('can-reflect-tests/observables/map-like/type/on-instance-bound-change')('DefineList', function () {
        return DefineList.extend();
    });
    require('can-reflect-tests/observables/map-like/type/on-instance-patches')('DefineList', function () {
        return DefineList.extend();
    });
    require('can-reflect-tests/observables/list-like/type/on-instance-patches')('DefineList', function () {
        return DefineList.extend();
    });
});
/*can-define@2.0.1#test/test-value-resolve*/
define('can-define@2.0.1#test/test-value-resolve', [
    'require',
    'exports',
    'module',
    'steal-qunit',
    'can-define/list/list',
    'can-define/map/map',
    'can-reflect',
    'can-queues'
], function (require, exports, module) {
    'use strict';
    var QUnit = require('steal-qunit');
    require('can-define/list/list');
    var DefineMap = require('can-define/map/map');
    var canReflect = require('can-reflect');
    var queues = require('can-queues');
    QUnit.module('can-define value with resolve');
    QUnit.test('counter', function () {
        var Person = DefineMap.extend('Person', {
            name: 'string',
            nameChangeCount: {
                value: function (prop) {
                    var count = 0;
                    prop.resolve(count);
                    prop.listenTo('name', function () {
                        prop.resolve(++count);
                    });
                }
            }
        });
        var me = new Person();
        QUnit.equal(me.nameChangeCount, 0, 'unbound value');
        me.name = 'first';
        QUnit.equal(me.nameChangeCount, 0, 'unbound value');
        me.on('nameChangeCount', function (ev, newVal, oldVal) {
            QUnit.equal(newVal, 1, 'updated count');
            QUnit.equal(oldVal, 0, 'updated count from old value');
        });
        me.name = 'second';
        QUnit.equal(me.nameChangeCount, 1, 'bound value');
    });
    QUnit.test('fullName getter the hard way', 3, function () {
        var Person = DefineMap.extend('Person', {
            first: 'string',
            last: 'string',
            fullName: {
                value: function (prop) {
                    var first = this.first, last = this.last;
                    prop.resolve(first + ' ' + last);
                    prop.listenTo('first', function (ev, newFirst) {
                        first = newFirst;
                        prop.resolve(first + ' ' + last);
                    });
                    prop.listenTo('last', function (ev, newLast) {
                        last = newLast;
                        prop.resolve(first + ' ' + last);
                    });
                }
            }
        });
        var me = new Person({
            first: 'Justin',
            last: 'Meyer'
        });
        QUnit.equal(me.fullName, 'Justin Meyer', 'unbound value');
        var handler = function (ev, newVal, oldVal) {
            QUnit.equal(newVal, 'Ramiya Meyer', 'event newVal');
            QUnit.equal(oldVal, 'Justin Meyer', 'event oldVal');
        };
        me.on('fullName', handler);
        me.first = 'Ramiya';
        me.off('fullName', handler);
        me.last = 'Shah';
    });
    QUnit.test('list length', function () {
        var VM = DefineMap.extend('VM', {
            tasks: [],
            tasksLength: {
                value: function (prop) {
                    var tasks;
                    function checkAndResolve() {
                        if (tasks) {
                            prop.resolve(tasks.length);
                        } else {
                            prop.resolve(0);
                        }
                    }
                    function updateTask(ev, newTask, oldTask) {
                        if (oldTask) {
                            prop.stopListening(oldTask);
                        }
                        tasks = newTask;
                        if (newTask) {
                            prop.listenTo(newTask, 'length', function (ev, newVal) {
                                prop.resolve(newVal);
                            });
                        }
                        checkAndResolve();
                    }
                    prop.listenTo('tasks', updateTask);
                    updateTask(null, this.tasks, null);
                }
            }
        });
        var vm = new VM({ tasks: null });
        QUnit.equal(vm.tasksLength, 0, 'empty tasks, unbound');
        vm.tasks = [
            'chore 1',
            'chore 2'
        ];
        QUnit.equal(vm.tasksLength, 2, 'tasks, unbound');
        var lengths = [];
        vm.on('tasksLength', function (ev, newLength) {
            lengths.push(newLength);
        });
        QUnit.equal(vm.tasksLength, 2, '2 tasks, bound');
        vm.tasks.push('chore 3');
        var originalTasks = vm.tasks;
        QUnit.equal(vm.tasksLength, 3, '3 tasks, bound, after push to source');
        vm.tasks = ['one chore'];
        QUnit.equal(vm.tasksLength, 1, '1 tasks, bound, after replace array');
        QUnit.notOk(canReflect.isBound(originalTasks), 'not bound on original');
        QUnit.deepEqual(lengths, [
            3,
            1
        ], 'length changes are right');
    });
    QUnit.test('batches produce one result', 2, function () {
        var Person = DefineMap.extend('Person', {
            first: 'string',
            last: 'string',
            fullName: {
                value: function (prop) {
                    var first = this.first, last = this.last;
                    prop.resolve(first + ' ' + last);
                    prop.listenTo('first', function (ev, newFirst) {
                        first = newFirst;
                        prop.resolve(first + ' ' + last);
                    });
                    prop.listenTo('last', function (ev, newLast) {
                        last = newLast;
                        prop.resolve(first + ' ' + last);
                    });
                }
            }
        });
        var me = new Person({
            first: 'Justin',
            last: 'Meyer'
        });
        var handler = function (ev, newVal, oldVal) {
            QUnit.equal(newVal, 'Ramiya Shah', 'event newVal');
            QUnit.equal(oldVal, 'Justin Meyer', 'event oldVal');
        };
        me.on('fullName', handler);
        queues.batch.start();
        me.first = 'Ramiya';
        me.last = 'Shah';
        queues.batch.stop();
    });
    QUnit.test('location vm', function () {
        var Locator = DefineMap.extend('Locator', {
            state: 'string',
            setCity: function (city) {
                this.dispatch('citySet', city);
            },
            city: {
                value: function (prop) {
                    prop.listenTo('citySet', function (ev, city) {
                        prop.resolve(city);
                    });
                    prop.listenTo('state', function () {
                        prop.resolve(null);
                    });
                }
            }
        });
        var locator = new Locator({ state: 'IL' });
        locator.on('city', function () {
        });
        locator.setCity('Chicago');
        locator.state = 'CA';
        QUnit.equal(locator.city, null, 'changing the state sets the city');
    });
    QUnit.test('location vm with setter', function () {
        var Locator = DefineMap.extend('Locator', {
            state: 'string',
            city: {
                value: function (prop) {
                    prop.listenTo(prop.lastSet, prop.resolve);
                    prop.listenTo('state', function () {
                        prop.resolve(null);
                    });
                    prop.resolve(prop.lastSet.get());
                }
            }
        });
        var locator = new Locator({
            state: 'IL',
            city: 'Chicago'
        });
        QUnit.equal(locator.city, 'Chicago', 'init to Chicago');
        locator.on('city', function () {
        });
        locator.state = 'CA';
        QUnit.equal(locator.city, null, 'changing the state sets the city');
        locator.city = 'San Jose';
        QUnit.equal(locator.city, 'San Jose', 'changing the state sets the city');
    });
});
/*can-define@2.0.1#test/test*/
define('can-define@2.0.1#test/test', [
    'require',
    'exports',
    'module',
    './test-define-only',
    '../list/list-test',
    '../map/map-test',
    './test-list-and-map',
    './test-type-events',
    './test-value-resolve'
], function (require, exports, module) {
    require('./test-define-only');
    require('../list/list-test');
    require('../map/map-test');
    require('./test-list-and-map');
    require('./test-type-events');
    require('./test-value-resolve');
});
/*can-stache-bindings@4.0.5#test/helpers*/
define('can-stache-bindings@4.0.5#test/helpers', [
    'require',
    'exports',
    'module',
    'can-globals',
    'can-dom-events',
    'can-dom-mutate',
    'can-dom-mutate/node',
    'can-dom-data-state',
    'can-vdom/make-document/make-document'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        var globals = require('can-globals');
        var domEvents = require('can-dom-events');
        var domMutate = require('can-dom-mutate');
        var domMutateNode = require('can-dom-mutate/node');
        var domData = require('can-dom-data-state');
        var makeDocument = require('can-vdom/make-document/make-document');
        var helpers = {
            makeQUnitModule: function (name, doc, enableMO) {
                QUnit.module(name, {
                    setup: function () {
                        globals.setKeyValue('document', doc);
                        if (!enableMO) {
                            globals.setKeyValue('MutationObserver', null);
                        }
                        if (doc === document) {
                            this.fixture = document.getElementById('qunit-fixture');
                        } else {
                            this.fixture = doc.createElement('qunit-fixture');
                            doc.body.appendChild(this.fixture);
                        }
                    },
                    teardown: function () {
                        if (doc !== document) {
                            doc.body.removeChild(this.fixture);
                        }
                        stop();
                        helpers.afterMutation(function () {
                            globals.deleteKeyValue('document');
                            globals.deleteKeyValue('MutationObserver');
                            var fixture = document.getElementById('qunit-fixture');
                            while (fixture && fixture.hasChildNodes()) {
                                domData.delete.call(fixture.lastChild);
                                fixture.removeChild(fixture.lastChild);
                            }
                            start();
                        });
                    }
                });
            },
            afterMutation: function (cb) {
                var doc = globals.getKeyValue('document');
                var div = doc.createElement('div');
                var undo = domMutate.onNodeInsertion(div, function () {
                    undo();
                    doc.body.removeChild(div);
                    setTimeout(cb, 5);
                });
                setTimeout(function () {
                    domMutateNode.appendChild.call(doc.body, div);
                }, 10);
            },
            makeTests: function (name, makeTest) {
                helpers.makeQUnitModule(name + ' - dom', document, true);
                makeTest(name + ' - dom', document, true, QUnit.test);
                var doc = makeDocument();
                helpers.makeQUnitModule(name + ' - vdom', doc, false);
                makeTest(name + ' - vdom', doc, false, function () {
                });
            },
            interceptDomEvents: function (addFn, removeFn) {
                var realAddEventListener = domEvents.addEventListener;
                var realRemoveEventListener = domEvents.removeEventListener;
                domEvents.addEventListener = function (eventName) {
                    addFn.call(this, arguments);
                    return realAddEventListener.apply(this, arguments);
                };
                domEvents.removeEventListener = function (eventName) {
                    removeFn.call(this, arguments);
                    return realRemoveEventListener.apply(this, arguments);
                };
                return function undo() {
                    domEvents.addEventListener = realAddEventListener;
                    domEvents.removeEventListener = realRemoveEventListener;
                };
            }
        };
        module.exports = helpers;
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-stache-bindings@4.0.5#test/mock-component-simple-map*/
define('can-stache-bindings@4.0.5#test/mock-component-simple-map', [
    'require',
    'exports',
    'module',
    'can-stache-bindings',
    'can-simple-map',
    'can-view-callbacks',
    'can-view-nodelist',
    'can-symbol',
    'can-dom-data-state',
    'can-dom-mutate/node'
], function (require, exports, module) {
    var stacheBindings = require('can-stache-bindings');
    var CanSimpleMap = require('can-simple-map');
    var viewCallbacks = require('can-view-callbacks');
    var nodeLists = require('can-view-nodelist');
    var canSymbol = require('can-symbol');
    var domData = require('can-dom-data-state');
    var domMutateNode = require('can-dom-mutate/node');
    var MockComponent;
    module.exports = MockComponent = {
        extend: function (proto) {
            viewCallbacks.tag(proto.tag, function (el, componentTagData) {
                var viewModel;
                var teardownBindings = stacheBindings.behaviors.viewModel(el, componentTagData, function (initialViewModelData) {
                    if (typeof proto.viewModel === 'function') {
                        return viewModel = new proto.viewModel(initialViewModelData);
                    } else if (proto.viewModel instanceof CanSimpleMap) {
                        proto.viewModel.set(initialViewModelData);
                        return viewModel = proto.viewModel;
                    } else {
                        var VM = CanSimpleMap.extend(proto.viewModel);
                        return viewModel = new VM(initialViewModelData);
                    }
                }, {});
                el[canSymbol.for('can.viewModel')] = viewModel;
                domData.set.call(el, 'preventDataBindings', true);
                if (proto.template) {
                    var shadowScope = componentTagData.scope.add(viewModel);
                    domData.set.call(el, 'shadowScope', shadowScope);
                    var nodeList = nodeLists.register([], function () {
                        teardownBindings();
                    }, componentTagData.parentNodeList || true, false);
                    var frag = proto.template(shadowScope, componentTagData.options, nodeList);
                    domMutateNode.appendChild.call(el, frag);
                }
            });
        }
    };
});
/*can-stache-bindings@4.0.5#test/colon/basics-test*/
define('can-stache-bindings@4.0.5#test/colon/basics-test', [
    'require',
    'exports',
    'module',
    'steal-qunit',
    '../helpers',
    'can-stache-bindings',
    'can-stache',
    'can-simple-map',
    '../mock-component-simple-map',
    'can-test-helpers'
], function (require, exports, module) {
    var QUnit = require('steal-qunit');
    var testHelpers = require('../helpers');
    var stacheBindings = require('can-stache-bindings');
    var stache = require('can-stache');
    var SimpleMap = require('can-simple-map');
    var MockComponent = require('../mock-component-simple-map');
    var canTestHelpers = require('can-test-helpers');
    testHelpers.makeTests('can-stache-bindings - colon - basics', function (name, doc, enableMO) {
        test('basics', 5, function () {
            var viewModel = new SimpleMap({
                toChild: 'toChild',
                toParent: 'toParent',
                twoWay: 'twoWay'
            });
            MockComponent.extend({
                tag: 'basic-colon',
                viewModel: viewModel
            });
            var template = stache('<basic-colon ' + 'toChild:from=\'valueA\' toParent:to=\'valueB\' twoWay:bind=\'valueC\' ' + 'on:vmevent=\'methodD()\'' + '/>');
            var MySimpleMap = SimpleMap.extend({
                methodD: function () {
                    QUnit.ok(true, 'on:vmevent bindings work');
                }
            });
            var parent = new MySimpleMap({
                valueA: 'A',
                valueB: 'B',
                valueC: 'C'
            });
            template(parent);
            QUnit.deepEqual(parent.get(), {
                valueA: 'A',
                valueB: 'toParent',
                valueC: 'C'
            }, 'initial scope values correct');
            QUnit.deepEqual(viewModel.get(), {
                toChild: 'A',
                toParent: 'toParent',
                twoWay: 'C'
            }, 'initial VM values correct');
            parent.set({
                valueA: 'a',
                valueB: 'b',
                valueC: 'c'
            });
            QUnit.deepEqual(viewModel.get(), {
                toChild: 'a',
                toParent: 'toParent',
                twoWay: 'c'
            }, 'scope set VM values correct');
            viewModel.set({
                toChild: 'to-child',
                toParent: 'to-parent',
                twoWay: 'two-way'
            });
            QUnit.deepEqual(parent.get(), {
                valueA: 'a',
                valueB: 'to-parent',
                valueC: 'two-way'
            }, 'vm set scope values correct');
            viewModel.dispatch({ type: 'vmevent' });
        });
        test('getBindingInfo', function () {
            var info = stacheBindings.getBindingInfo({
                name: 'foo-ed:from',
                value: 'bar'
            });
            deepEqual(info, {
                parent: 'scope',
                child: 'viewModelOrAttribute',
                childEvent: undefined,
                parentToChild: true,
                childToParent: false,
                childName: 'foo-ed',
                parentName: 'bar',
                bindingAttributeName: 'foo-ed:from',
                initializeValues: true,
                syncChildWithParent: false
            }, ':from');
            info = stacheBindings.getBindingInfo({
                name: 'foo-ed:bind',
                value: 'bar'
            });
            deepEqual(info, {
                parent: 'scope',
                child: 'viewModelOrAttribute',
                childEvent: undefined,
                parentToChild: true,
                childToParent: true,
                childName: 'foo-ed',
                parentName: 'bar',
                bindingAttributeName: 'foo-ed:bind',
                initializeValues: true,
                syncChildWithParent: true
            }, ':bind');
            info = stacheBindings.getBindingInfo({
                name: 'foo-ed:to',
                value: 'bar'
            });
            deepEqual(info, {
                parent: 'scope',
                child: 'viewModelOrAttribute',
                childEvent: undefined,
                parentToChild: false,
                childToParent: true,
                childName: 'foo-ed',
                parentName: 'bar',
                bindingAttributeName: 'foo-ed:to',
                initializeValues: true,
                syncChildWithParent: false
            }, ':to');
            info = stacheBindings.getBindingInfo({
                name: 'foo-ed:from',
                value: 'bar'
            }, null, null, null, true);
            deepEqual(info, {
                parent: 'scope',
                child: 'viewModel',
                childEvent: undefined,
                parentToChild: true,
                childToParent: false,
                childName: 'foo-ed',
                parentName: 'bar',
                bindingAttributeName: 'foo-ed:from',
                initializeValues: true,
                syncChildWithParent: false
            }, ':from, favorViewModel=true');
            info = stacheBindings.getBindingInfo({
                name: 'foo-ed:bind',
                value: 'bar'
            }, null, null, null, true);
            deepEqual(info, {
                parent: 'scope',
                child: 'viewModel',
                childEvent: undefined,
                parentToChild: true,
                childToParent: true,
                childName: 'foo-ed',
                parentName: 'bar',
                bindingAttributeName: 'foo-ed:bind',
                initializeValues: true,
                syncChildWithParent: true
            }, ':bind, favorViewModel=true');
            info = stacheBindings.getBindingInfo({
                name: 'foo-ed:to',
                value: 'bar'
            }, null, null, null, true);
            deepEqual(info, {
                parent: 'scope',
                child: 'viewModel',
                childEvent: undefined,
                parentToChild: false,
                childToParent: true,
                childName: 'foo-ed',
                parentName: 'bar',
                bindingAttributeName: 'foo-ed:to',
                initializeValues: true,
                syncChildWithParent: false
            }, ':to, favorViewModel=true');
        });
        test('getBindingInfo for vm:', function () {
            var info = stacheBindings.getBindingInfo({
                name: 'vm:foo-ed:from',
                value: 'bar'
            });
            deepEqual(info, {
                parent: 'scope',
                child: 'viewModel',
                childEvent: undefined,
                parentToChild: true,
                childToParent: false,
                childName: 'foo-ed',
                parentName: 'bar',
                bindingAttributeName: 'vm:foo-ed:from',
                initializeValues: true,
                syncChildWithParent: false
            }, ':from');
            info = stacheBindings.getBindingInfo({
                name: 'vm:foo-ed:bind',
                value: 'bar'
            });
            deepEqual(info, {
                parent: 'scope',
                child: 'viewModel',
                childEvent: undefined,
                parentToChild: true,
                childToParent: true,
                childName: 'foo-ed',
                parentName: 'bar',
                bindingAttributeName: 'vm:foo-ed:bind',
                initializeValues: true,
                syncChildWithParent: true
            }, ':bind');
            info = stacheBindings.getBindingInfo({
                name: 'vm:foo-ed:to',
                value: 'bar'
            });
            deepEqual(info, {
                parent: 'scope',
                child: 'viewModel',
                childEvent: undefined,
                parentToChild: false,
                childToParent: true,
                childName: 'foo-ed',
                parentName: 'bar',
                bindingAttributeName: 'vm:foo-ed:to',
                initializeValues: true,
                syncChildWithParent: false
            }, ':to');
            info = stacheBindings.getBindingInfo({
                name: 'vm:foo-ed:from',
                value: 'bar'
            }, null, null, null, true);
            deepEqual(info, {
                parent: 'scope',
                child: 'viewModel',
                childEvent: undefined,
                parentToChild: true,
                childToParent: false,
                childName: 'foo-ed',
                parentName: 'bar',
                bindingAttributeName: 'vm:foo-ed:from',
                initializeValues: true,
                syncChildWithParent: false
            }, ':from, favorViewModel=true');
            info = stacheBindings.getBindingInfo({
                name: 'vm:foo-ed:bind',
                value: 'bar'
            }, null, null, null, true);
            deepEqual(info, {
                parent: 'scope',
                child: 'viewModel',
                childEvent: undefined,
                parentToChild: true,
                childToParent: true,
                childName: 'foo-ed',
                parentName: 'bar',
                bindingAttributeName: 'vm:foo-ed:bind',
                initializeValues: true,
                syncChildWithParent: true
            }, ':bind, favorViewModel=true');
            info = stacheBindings.getBindingInfo({
                name: 'vm:foo-ed:to',
                value: 'bar'
            }, null, null, null, true);
            deepEqual(info, {
                parent: 'scope',
                child: 'viewModel',
                childEvent: undefined,
                parentToChild: false,
                childToParent: true,
                childName: 'foo-ed',
                parentName: 'bar',
                bindingAttributeName: 'vm:foo-ed:to',
                initializeValues: true,
                syncChildWithParent: false
            }, ':to, favorViewModel=true');
        });
        test('getBindingInfo for el:', function () {
            var info = stacheBindings.getBindingInfo({
                name: 'el:foo-ed:from',
                value: 'bar'
            });
            deepEqual(info, {
                parent: 'scope',
                child: 'attribute',
                childEvent: undefined,
                parentToChild: true,
                childToParent: false,
                childName: 'foo-ed',
                parentName: 'bar',
                bindingAttributeName: 'el:foo-ed:from',
                initializeValues: true,
                syncChildWithParent: false
            }, ':from');
            info = stacheBindings.getBindingInfo({
                name: 'el:foo-ed:bind',
                value: 'bar'
            });
            deepEqual(info, {
                parent: 'scope',
                child: 'attribute',
                childEvent: undefined,
                parentToChild: true,
                childToParent: true,
                childName: 'foo-ed',
                parentName: 'bar',
                bindingAttributeName: 'el:foo-ed:bind',
                initializeValues: true,
                syncChildWithParent: true
            }, ':bind');
            info = stacheBindings.getBindingInfo({
                name: 'el:foo-ed:to',
                value: 'bar'
            });
            deepEqual(info, {
                parent: 'scope',
                child: 'attribute',
                childEvent: undefined,
                parentToChild: false,
                childToParent: true,
                childName: 'foo-ed',
                parentName: 'bar',
                bindingAttributeName: 'el:foo-ed:to',
                initializeValues: true,
                syncChildWithParent: false
            }, ':to');
            info = stacheBindings.getBindingInfo({
                name: 'el:foo-ed:from',
                value: 'bar'
            }, null, null, null, true);
            deepEqual(info, {
                parent: 'scope',
                child: 'attribute',
                childEvent: undefined,
                parentToChild: true,
                childToParent: false,
                childName: 'foo-ed',
                parentName: 'bar',
                bindingAttributeName: 'el:foo-ed:from',
                initializeValues: true,
                syncChildWithParent: false
            }, ':from, favorViewModel=true');
            info = stacheBindings.getBindingInfo({
                name: 'el:foo-ed:bind',
                value: 'bar'
            }, null, null, null, true);
            deepEqual(info, {
                parent: 'scope',
                child: 'attribute',
                childEvent: undefined,
                parentToChild: true,
                childToParent: true,
                childName: 'foo-ed',
                parentName: 'bar',
                bindingAttributeName: 'el:foo-ed:bind',
                initializeValues: true,
                syncChildWithParent: true
            }, ':bind, favorViewModel=true');
            info = stacheBindings.getBindingInfo({
                name: 'el:foo-ed:to',
                value: 'bar'
            }, null, null, null, true);
            deepEqual(info, {
                parent: 'scope',
                child: 'attribute',
                childEvent: undefined,
                parentToChild: false,
                childToParent: true,
                childName: 'foo-ed',
                parentName: 'bar',
                bindingAttributeName: 'el:foo-ed:to',
                initializeValues: true,
                syncChildWithParent: false
            }, ':to, favorViewModel=true');
        });
        QUnit.test('getBindingInfo works for value:to:on:click (#269)', function () {
            var info = stacheBindings.getBindingInfo({
                name: 'value:to:on:click',
                value: 'bar'
            });
            deepEqual(info, {
                parent: 'scope',
                child: 'viewModelOrAttribute',
                childEvent: 'click',
                parentToChild: false,
                childToParent: true,
                childName: 'value',
                parentName: 'bar',
                bindingAttributeName: 'value:to:on:click',
                initializeValues: false,
                syncChildWithParent: false
            }, 'new vm binding');
        });
        canTestHelpers.dev.devOnlyTest('warning when binding to non-existing value (#136) (#119)', function () {
            var teardown = canTestHelpers.dev.willWarn('This element does not have a viewModel. (Attempting to bind `target:vm:bind="source.bar"`)');
            var template = stache('<div target:vm:bind=\'source.bar\'/>');
            var map = new SimpleMap({ source: new SimpleMap({ foo: 'foo' }) });
            template(map);
            QUnit.equal(teardown(), 1, 'warning shown');
        });
    });
});
/*can-stache-bindings@4.0.5#test/colon/element-test*/
define('can-stache-bindings@4.0.5#test/colon/element-test', [
    'require',
    'exports',
    'module',
    'steal-qunit',
    '../helpers',
    'can-stache',
    'can-stache-bindings',
    'can-simple-map',
    'can-define/list/list',
    '../mock-component-simple-map',
    'can-view-model',
    'can-simple-observable',
    'can-symbol',
    'can-reflect',
    'can-dom-mutate',
    'can-dom-mutate/node',
    'can-dom-events',
    'can-util/js/each/each',
    'can-define/map/map'
], function (require, exports, module) {
    var QUnit = require('steal-qunit');
    var testHelpers = require('../helpers');
    var stache = require('can-stache');
    require('can-stache-bindings');
    var SimpleMap = require('can-simple-map');
    var DefineList = require('can-define/list/list');
    var MockComponent = require('../mock-component-simple-map');
    var canViewModel = require('can-view-model');
    var SimpleObservable = require('can-simple-observable');
    var canSymbol = require('can-symbol');
    var canReflect = require('can-reflect');
    var domMutate = require('can-dom-mutate');
    var domMutateNode = require('can-dom-mutate/node');
    var domEvents = require('can-dom-events');
    var canEach = require('can-util/js/each/each');
    var DefineMap = require('can-define/map/map');
    testHelpers.makeTests('can-stache-bindings - colon - element', function (name, doc, enableMO, testIfRealDocument) {
        QUnit.test('<input text> value:bind input text', function () {
            var template = stache('<input value:bind=\'age\'/>');
            var map = new SimpleMap();
            var frag = template(map);
            var ta = this.fixture;
            ta.appendChild(frag);
            var input = ta.getElementsByTagName('input')[0];
            equal(input.value, '', 'input value set correctly if key does not exist in map');
            map.set('age', '30');
            equal(input.value, '30', 'input value set correctly');
            map.set('age', '31');
            equal(input.value, '31', 'input value update correctly');
            input.value = '32';
            domEvents.dispatch(input, 'change');
            equal(map.get('age'), '32', 'updated from input');
        });
        QUnit.test('<input text> el:prop:to/:from/:bind work (#280)', function () {
            var template = stache('<input el:value:to=\'scope1\' value=\'1\'/>' + '<input el:value:from=\'scope2\' value=\'2\'/>' + '<input el:value:bind=\'scope3\' value=\'3\'/>');
            var scope = new SimpleMap({
                scope1: 'scope1',
                scope2: 'scope2',
                scope3: 'scope3'
            });
            var frag = template(scope);
            var ta = this.fixture;
            ta.appendChild(frag);
            var inputTo = ta.getElementsByTagName('input')[0];
            var inputFrom = ta.getElementsByTagName('input')[1];
            var inputBind = ta.getElementsByTagName('input')[2];
            equal(scope.attr('scope1'), '1', 'el:value:to - scope value set from attribute');
            inputTo.value = '4';
            domEvents.dispatch(inputTo, 'change');
            equal(scope.attr('scope1'), '4', 'el:value:to - scope updated when attribute changed');
            scope.attr('scope1', 'scope4');
            equal(inputTo.value, '4', 'el:value:to - attribute not updated when scope changed');
            equal(inputFrom.value, 'scope2', 'el:value:from - attribute set from scope');
            inputFrom.value = 'scope5';
            domEvents.dispatch(inputFrom, 'change');
            equal(scope.attr('scope2'), 'scope2', 'el:value:from - scope not updated when attribute changed');
            scope.attr('scope2', 'scope6');
            equal(inputFrom.value, 'scope6', 'el:value:from - attribute updated when scope changed');
            equal(inputBind.value, 'scope3', 'el:value:bind - attribute set from scope prop (parent -> child wins)');
            inputBind.value = 'scope6';
            domEvents.dispatch(inputBind, 'change');
            equal(scope.attr('scope3'), 'scope6', 'el:value:bind - scope updated when attribute changed');
            scope.attr('scope3', 'scope7');
            equal(inputBind.value, 'scope7', 'el:value:bind - attribute updated when scope changed');
        });
        if (System.env !== 'canjs-test') {
            test('<input text> dynamic attribute bindings (#2016)', function (assert) {
                var done = assert.async();
                var template = stache('<input value:bind=\'{{propName}}\'/>');
                var map = new SimpleMap({
                    propName: 'first',
                    first: 'Justin',
                    last: 'Meyer'
                });
                var frag = template(map);
                var ta = this.fixture;
                ta.appendChild(frag);
                var input = ta.getElementsByTagName('input')[0];
                testHelpers.afterMutation(function () {
                    equal(input.value, 'Justin', 'input value set correctly if key does not exist in map');
                    map.set('propName', 'last');
                    testHelpers.afterMutation(function () {
                        equal(input.value, 'Meyer', 'input value set correctly if key does not exist in map');
                        input.value = 'Lueke';
                        domEvents.dispatch(input, 'change');
                        testHelpers.afterMutation(function () {
                            equal(map.get('last'), 'Lueke', 'updated from input');
                            done();
                        });
                    });
                });
            });
        }
        test('value:bind compute rejects new value (#887)', function () {
            var template = stache('<input value:bind=\'age\'/>');
            var compute = new SimpleObservable(30);
            canReflect.assignSymbols(compute, {
                'can.setValue': function (newVal) {
                    if (isNaN(+newVal)) {
                    } else {
                        this.set(+newVal);
                    }
                }
            });
            var frag = template({ age: compute });
            var ta = this.fixture;
            ta.appendChild(frag);
            var input = ta.getElementsByTagName('input')[0];
            input.value = '30f';
            domEvents.dispatch(input, 'change');
            equal(compute.get(), 30, 'Still the old value');
            equal(input.value, '30', 'Text input has also not changed');
        });
        test('value:from works with camelCase and kebab-case properties', function () {
            var template = stache('<input value:from=\'theProp\'/>' + '<input value:from=\'the-prop\'/>');
            var map = new SimpleMap({});
            var frag = template(map);
            var ta = this.fixture;
            ta.appendChild(frag);
            var camelPropInput = ta.getElementsByTagName('input')[0];
            var kebabPropInput = ta.getElementsByTagName('input')[1];
            equal(camelPropInput.value, '', 'input bound to camelCase prop value set correctly if camelCase key does not exist in map');
            equal(kebabPropInput.value, '', 'input bound to kebab-case prop value set correctly if kebab-case key does not exist in map');
            map.attr('theProp', '30');
            equal(camelPropInput.value, '30', 'input bound to camelCase prop value set correctly when camelCase prop changes');
            equal(kebabPropInput.value, '', 'input bound to kebab-case prop value not updated when camelCase prop changes');
            map.attr('theProp', '31');
            equal(camelPropInput.value, '31', 'input bound to camelCase prop value updated correctly when camelCase prop changes');
            ok(!kebabPropInput.value, 'input bound to kebab-case prop value not updated when camelCase prop changes');
            camelPropInput.value = '32';
            domEvents.dispatch(camelPropInput, 'change');
            equal(map.attr('theProp'), '31', 'camelCase prop NOT updated when input bound to camelCase prop changes');
            ok(!map.attr('the-prop'), 'kebabCase prop NOT updated when input bound to camelCase prop changes');
            map.attr('the-prop', '33');
            equal(kebabPropInput.value, '33', 'input bound to kebab-case prop value set correctly when kebab-case prop changes');
            equal(camelPropInput.value, '32', 'input bound to camelCase prop value not updated when kebab-case prop changes');
            map.attr('the-prop', '34');
            equal(kebabPropInput.value, '34', 'input bound to kebab-case prop value updated correctly when kebab-case prop changes');
            equal(camelPropInput.value, '32', 'input bound to camelCase prop value not updated when kebab-case prop changes');
            kebabPropInput.value = '35';
            domEvents.dispatch(kebabPropInput, 'change');
            equal(map.attr('the-prop'), '34', 'kebab-case prop NOT updated from input bound to kebab-case prop');
            equal(map.attr('theProp'), '31', 'camelCase prop NOT updated from input bound to kebab-case prop');
        });
        test('value:to works with camelCase and kebab-case properties', function () {
            var template = stache('<input value:to=\'theProp\'/>' + '<input value:to=\'the-prop\'/>');
            var map = new SimpleMap({});
            var frag = template(map);
            var ta = this.fixture;
            ta.appendChild(frag);
            var camelPropInput = ta.getElementsByTagName('input')[0];
            var kebabPropInput = ta.getElementsByTagName('input')[1];
            camelPropInput.value = '32';
            domEvents.dispatch(camelPropInput, 'change');
            equal(map.attr('theProp'), '32', 'camelCaseProp updated from input bound to camelCase Prop');
            ok(!map.attr('the-prop'), 'kebabCaseProp NOT updated from input bound to camelCase Prop');
            map.attr('theProp', '30');
            equal(camelPropInput.value, '32', 'input bound to camelCase Prop value NOT updated when camelCase prop changes');
            ok(!kebabPropInput.value, 'input bound to kebabCase Prop value NOT updated when camelCase prop changes');
            kebabPropInput.value = '33';
            domEvents.dispatch(kebabPropInput, 'change');
            equal(map.attr('the-prop'), '33', 'kebabCaseProp updated from input bound to kebabCase Prop');
            equal(map.attr('theProp'), '30', 'camelCaseProp NOT updated from input bound to camelCase Prop');
            map.attr('theProp', '34');
            equal(kebabPropInput.value, '33', 'input bound to kebabCase Prop value NOT updated when kebabCase prop changes');
            equal(camelPropInput.value, '32', 'input bound to camelCase Prop value NOT updated when kebabCase prop changes');
        });
        test('value:bind works with camelCase and kebab-case properties', function () {
            var template = stache('<input value:bind=\'theProp\'/>' + '<input value:bind=\'the-prop\'/>');
            var map = new SimpleMap({});
            var frag = template(map);
            var ta = this.fixture;
            ta.appendChild(frag);
            var camelPropInput = ta.getElementsByTagName('input')[0];
            var kebabPropInput = ta.getElementsByTagName('input')[1];
            camelPropInput.value = '32';
            domEvents.dispatch(camelPropInput, 'change');
            equal(map.attr('theProp'), '32', 'camelCaseProp updated from input bound to camelCase Prop');
            ok(!map.attr('the-prop'), 'kebabCaseProp NOT updated from input bound to camelCase Prop');
            map.attr('theProp', '30');
            equal(camelPropInput.value, '30', 'input bound to camelCase Prop value updated when camelCase prop changes');
            ok(!kebabPropInput.value, 'input bound to kebabCase Prop value NOT updated when camelCase prop changes');
            kebabPropInput.value = '33';
            domEvents.dispatch(kebabPropInput, 'change');
            equal(map.attr('the-prop'), '33', 'kebabCaseProp updated from input bound to kebabCase Prop');
            equal(map.attr('theProp'), '30', 'camelCaseProp NOT updated from input bound to camelCase Prop');
            map.attr('theProp', '34');
            equal(kebabPropInput.value, '33', 'input bound to kebabCase Prop value NOT updated when kebabCase prop changes');
            equal(camelPropInput.value, '34', 'input bound to camelCase Prop value updated when kebabCase prop changes');
        });
        test('Bracket expression with dot and no explicit root and value:bind', function () {
            var template;
            var div = this.fixture;
            template = stache('<input value:bind="[\'two.hops\']" >');
            var data = new SimpleMap();
            var dom = template(data);
            div.appendChild(dom);
            var input = div.getElementsByTagName('input')[0];
            equal(input.value, '', 'input value set correctly if key does not exist in map');
            data.set('two.hops', 'slide to the left');
            equal(input.value, 'slide to the left', 'input value set correctly');
            data.set('two.hops', 'slide to the right');
            equal(input.value, 'slide to the right', 'input value update correctly');
            input.value = 'REVERSE REVERSE';
            domEvents.dispatch(input, 'change');
            equal(data.get('two.hops'), 'REVERSE REVERSE', 'updated from input');
        });
        test('Bracket expression with colon and no explicit root and value:bind', function () {
            var template;
            var div = this.fixture;
            template = stache('<input value:bind="[\'two:hops\']" >');
            var data = new SimpleMap();
            var dom = template(data);
            div.appendChild(dom);
            var input = div.getElementsByTagName('input')[0];
            equal(input.value, '', 'input value set correctly if key does not exist in map');
            data.set('two:hops', 'slide to the left');
            equal(input.value, 'slide to the left', 'input value set correctly');
            data.set('two:hops', 'slide to the right');
            equal(input.value, 'slide to the right', 'input value update correctly');
            input.value = 'REVERSE REVERSE';
            domEvents.dispatch(input, 'change');
            equal(data.get('two:hops'), 'REVERSE REVERSE', 'updated from input');
        });
        QUnit.test('el:prop:to/:from/:bind work (#280)', function () {
            var template = stache('<input el:value:to=\'scope1\' value=\'1\'/>' + '<input el:value:from=\'scope2\' value=\'2\'/>' + '<input el:value:bind=\'scope3\' value=\'3\'/>');
            var scope = new SimpleMap({
                scope1: 'scope1',
                scope2: 'scope2',
                scope3: 'scope3'
            });
            var frag = template(scope);
            var ta = this.fixture;
            ta.appendChild(frag);
            var inputTo = ta.getElementsByTagName('input')[0];
            var inputFrom = ta.getElementsByTagName('input')[1];
            var inputBind = ta.getElementsByTagName('input')[2];
            equal(scope.attr('scope1'), '1', 'el:value:to - scope value set from attribute');
            inputTo.value = '4';
            domEvents.dispatch(inputTo, 'change');
            equal(scope.attr('scope1'), '4', 'el:value:to - scope updated when attribute changed');
            scope.attr('scope1', 'scope4');
            equal(inputTo.value, '4', 'el:value:to - attribute not updated when scope changed');
            equal(inputFrom.value, 'scope2', 'el:value:from - attribute set from scope');
            inputFrom.value = 'scope5';
            domEvents.dispatch(inputFrom, 'change');
            equal(scope.attr('scope2'), 'scope2', 'el:value:from - scope not updated when attribute changed');
            scope.attr('scope2', 'scope6');
            equal(inputFrom.value, 'scope6', 'el:value:from - attribute updated when scope changed');
            equal(inputBind.value, 'scope3', 'el:value:bind - attribute set from scope prop (parent -> child wins)');
            inputBind.value = 'scope6';
            domEvents.dispatch(inputBind, 'change');
            equal(scope.attr('scope3'), 'scope6', 'el:value:bind - scope updated when attribute changed');
            scope.attr('scope3', 'scope7');
            equal(inputBind.value, 'scope7', 'el:value:bind - attribute updated when scope changed');
        });
        test('<input text> two-way - DOM - input text (#1700)', function () {
            var template = stache('<input value:bind=\'age\'/>');
            var map = new SimpleMap();
            var frag = template(map);
            var ta = this.fixture;
            ta.appendChild(frag);
            var input = ta.getElementsByTagName('input')[0];
            equal(input.value, '', 'input value set correctly if key does not exist in map');
            map.attr('age', '30');
            stop();
            testHelpers.afterMutation(function () {
                start();
                equal(input.value, '30', 'input value set correctly');
                map.attr('age', '31');
                stop();
                testHelpers.afterMutation(function () {
                    start();
                    equal(input.value, '31', 'input value update correctly');
                    input.value = '32';
                    domEvents.dispatch(input, 'change');
                    stop();
                    testHelpers.afterMutation(function () {
                        start();
                        equal(map.attr('age'), '32', 'updated from input');
                    });
                });
            });
        });
        QUnit.test('errors subproperties of undefined properties (#298)', function () {
            try {
                stache('<input value:to=\'prop.subprop\'/>')();
                ok(true, 'renderer was made without error');
            } catch (e) {
                ok(false, e.message);
            }
        });
        test('updates happen on two-way even when one binding is satisfied', function (assert) {
            var done = assert.async();
            var template = stache('<input value:bind="firstName"/>');
            var viewModel = new SimpleMap({ firstName: 'jeffrey' });
            canReflect.assignSymbols(viewModel, {
                'can.setKeyValue': function (key, val) {
                    if (val) {
                        this.set(key, val.toLowerCase());
                    }
                }
            });
            var frag = template(viewModel);
            domMutateNode.appendChild.call(this.fixture, frag);
            var input = this.fixture.firstChild;
            assert.equal(input.value, 'jeffrey', 'initial value should be "jeffrey"');
            input.value = 'JEFFREY';
            domEvents.dispatch(input, 'change');
            assert.equal(input.value, 'jeffrey', 'updated value should be "jeffrey"');
            testHelpers.afterMutation(function () {
                done();
            });
        });
        QUnit.test('updates happen on changed two-way even when one binding is satisfied', function (assert) {
            var done = assert.async();
            var template = stache('<input value:bind="{{bindValue}}"/>');
            var ViewModel = DefineMap.extend({
                firstName: {
                    set: function (newValue) {
                        if (newValue) {
                            return newValue.toLowerCase();
                        }
                    }
                },
                lastName: {
                    set: function (newValue) {
                        if (newValue) {
                            return newValue.toLowerCase();
                        }
                    }
                },
                bindValue: 'string'
            });
            var viewModel = new ViewModel({
                firstName: 'Jeffrey',
                lastName: 'King',
                bindValue: 'firstName'
            });
            var frag = template(viewModel);
            domMutateNode.appendChild.call(this.fixture, frag);
            var input = this.fixture.firstChild;
            testHelpers.afterMutation(function () {
                assert.equal(input.value, 'jeffrey');
                viewModel.bindValue = 'lastName';
                var undo = domMutate.onNodeAttributeChange(input, function () {
                    undo();
                    assert.equal(input.value, 'king');
                    input.value = 'KING';
                    domEvents.dispatch(input, 'change');
                    assert.equal(input.value, 'king');
                    done();
                }.bind(this));
            }.bind(this));
        });
        test('value:bind memory leak (#2270)', function () {
            var template = stache('<div><input value:bind="foo"></div>');
            var vm = new SimpleMap({ foo: '' });
            var frag = template(vm);
            var ta = this.fixture;
            domMutateNode.appendChild.call(ta, frag);
            QUnit.stop();
            testHelpers.afterMutation(function () {
                domMutateNode.removeChild.call(ta, ta.firstChild);
                testHelpers.afterMutation(function () {
                    var checkLifecycleBindings = function () {
                        var meta = vm[canSymbol.for('can.meta')];
                        if (meta.handlers.get([]).length === 0) {
                            QUnit.ok(true, 'no bindings');
                            start();
                        } else {
                            setTimeout(checkLifecycleBindings, 1000);
                        }
                    };
                    checkLifecycleBindings();
                });
            });
        });
        test('converters work (#2299)', function () {
            stache.registerConverter('numberToString', {
                get: function (source) {
                    return source() + '';
                },
                set: function (newVal, source) {
                    source(newVal === '' ? null : +newVal);
                }
            });
            var template = stache('<input value:bind="numberToString(~age)">');
            var map = new SimpleMap({ age: 25 });
            var frag = template(map);
            equal(frag.firstChild.value, '25');
            equal(map.get('age'), 25);
            map.set('age', 33);
            equal(frag.firstChild.value, '33');
            equal(map.get('age'), 33);
            frag.firstChild.value = '1';
            domEvents.dispatch(frag.firstChild, 'change');
            stop();
            testHelpers.afterMutation(function () {
                start();
                equal(frag.firstChild.value, '1');
                equal(map.get('age'), 1);
            });
        });
        testIfRealDocument('<input radio> checked:bind should trigger a radiochange event for radio buttons', function () {
            var template = stache([
                '<input type="radio" name="baz" checked:bind="foo"/><span>{{foo}}</span>',
                '<input type="radio" name="baz" checked:bind="bar"/><span>{{bar}}</span>'
            ].join(''));
            var data = new SimpleMap({
                foo: false,
                bar: false
            });
            var fragment = template(data);
            domMutateNode.appendChild.call(this.fixture, fragment);
            var self = this;
            function child(index) {
                return self.fixture.childNodes.item(index);
            }
            var fooRadio = child(0);
            var fooText = child(1);
            var barRadio = child(2);
            var barText = child(3);
            function text(node) {
                while (node && node.nodeType !== 3) {
                    node = node.firstChild;
                }
                return node && node.nodeValue;
            }
            fooRadio.checked = true;
            domEvents.dispatch(fooRadio, 'change');
            barRadio.checked = true;
            domEvents.dispatch(barRadio, 'change');
            equal(text(fooText), 'false', 'foo text is false');
            equal(text(barText), 'true', 'bar text is true');
            equal(data.get('foo'), false);
            equal(data.get('bar'), true);
        });
        QUnit.test('<input radio> change event handler set up when binding on radiochange (#206)', function () {
            var template = stache('<input type="radio" checked:bind="attending" />');
            var map = new SimpleMap({ attending: false });
            var frag = template(map);
            var input = frag.firstChild;
            input.checked = true;
            domEvents.dispatch(input, 'change');
            QUnit.equal(map.get('attending'), true, 'now it is true');
        });
        test('<input checkbox> one-way - DOM - with undefined (#135)', function () {
            var data = new SimpleMap({ completed: undefined }), frag = stache('<input type="checkbox" el:checked:from="completed"/>')(data);
            domMutateNode.appendChild.call(this.fixture, frag);
            var input = this.fixture.getElementsByTagName('input')[0];
            equal(input.checked, false, 'checkbox value should be false for undefined');
        });
        test('<input checkbox> two-way - DOM - with truthy and falsy values binds to checkbox (#1700)', function () {
            var data = new SimpleMap({ completed: 1 }), frag = stache('<input type="checkbox" el:checked:bind="completed"/>')(data);
            domMutateNode.appendChild.call(this.fixture, frag);
            var input = this.fixture.getElementsByTagName('input')[0];
            equal(input.checked, true, 'checkbox value bound (via attr check)');
            data.attr('completed', 0);
            stop();
            testHelpers.afterMutation(function () {
                start();
                equal(input.checked, false, 'checkbox value bound (via attr check)');
            });
        });
        test('<input checkbox> checkboxes with checked:bind bind properly (#628)', function () {
            var data = new SimpleMap({ completed: true }), frag = stache('<input type="checkbox" checked:bind="completed"/>')(data);
            domMutateNode.appendChild.call(this.fixture, frag);
            var input = this.fixture.getElementsByTagName('input')[0];
            equal(input.checked, data.get('completed'), 'checkbox value bound (via attr check)');
            data.attr('completed', false);
            equal(input.checked, data.get('completed'), 'checkbox value bound (via attr uncheck)');
            input.checked = true;
            domEvents.dispatch(input, 'change');
            equal(input.checked, true, 'checkbox value bound (via check)');
            equal(data.get('completed'), true, 'checkbox value bound (via check)');
            input.checked = false;
            domEvents.dispatch(input, 'change');
            equal(input.checked, false, 'checkbox value bound (via uncheck)');
            equal(data.get('completed'), false, 'checkbox value bound (via uncheck)');
        });
        testIfRealDocument('<select> keeps its value as <option>s change with {{#each}} (#1762)', function () {
            var template = stache('<select value:bind=\'id\'>{{#each values}}<option value=\'{{this}}\'>{{this}}</option>{{/each}}</select>');
            var values = new SimpleObservable([
                '1',
                '2',
                '3',
                '4'
            ]);
            var id = new SimpleObservable('2');
            var frag = template({
                values: values,
                id: id
            });
            stop();
            var select = frag.firstChild;
            var options = select.getElementsByTagName('option');
            testHelpers.afterMutation(function () {
                ok(options[1].selected, 'value is initially selected');
                values.set([
                    '7',
                    '2',
                    '5',
                    '4'
                ]);
                testHelpers.afterMutation(function () {
                    ok(options[1].selected, 'after changing options, value should still be selected');
                    start();
                });
            });
        });
        testIfRealDocument('<select> with undefined value selects option without value', function () {
            var template = stache('<select value:bind=\'opt\'><option>Loading...</option></select>');
            var map = new SimpleMap();
            var frag = template(map);
            var ta = this.fixture;
            ta.appendChild(frag);
            var select = ta.childNodes.item(0);
            QUnit.equal(select.selectedIndex, 0, 'Got selected index');
        });
        testIfRealDocument('<select> two-way bound values that do not match a select option set selectedIndex to -1 (#2027)', function () {
            var renderer = stache('<select el:value:bind="key"><option value="foo">foo</option><option value="bar">bar</option></select>');
            var map = new SimpleMap({});
            var frag = renderer(map);
            equal(frag.firstChild.selectedIndex, 0, 'undefined <- {($first value)}: selectedIndex = 0');
            map.attr('key', 'notfoo');
            stop();
            testHelpers.afterMutation(function () {
                start();
                equal(frag.firstChild.selectedIndex, -1, 'notfoo: selectedIndex = -1');
                map.attr('key', 'foo');
                strictEqual(frag.firstChild.selectedIndex, 0, 'foo: selectedIndex = 0');
                map.attr('key', 'notbar');
                stop();
                testHelpers.afterMutation(function () {
                    start();
                    equal(frag.firstChild.selectedIndex, -1, 'notbar: selectedIndex = -1');
                    map.attr('key', 'bar');
                    strictEqual(frag.firstChild.selectedIndex, 1, 'bar: selectedIndex = 1');
                    map.attr('key', 'bar');
                    strictEqual(frag.firstChild.selectedIndex, 1, 'bar (no change): selectedIndex = 1');
                });
            });
        });
        test('<select multiple> Multi-select empty string works(#1263)', function () {
            var data = new SimpleMap({
                isMultiple: 1,
                isSelect: 1,
                name: 'attribute_ 0',
                options: new DefineList([
                    {
                        label: 'empty',
                        value: ''
                    },
                    {
                        label: 'zero',
                        value: 0
                    },
                    {
                        label: 'one',
                        value: 1
                    },
                    {
                        label: 'two',
                        value: 2
                    },
                    {
                        label: 'three',
                        value: 3
                    },
                    {
                        label: 'four',
                        value: 4
                    }
                ]),
                value: new DefineList(['1'])
            });
            var template = stache('<select {{#if isMultiple}}multiple{{/if}} values:bind=\'value\'> ' + '{{#each options}} <option value=\'{{value}}\' >{{label}}</option>{{/each}} </select>');
            var frag = template(data);
            equal(frag.firstChild.getElementsByTagName('option')[0].selected, false, 'The first empty value is not selected');
            equal(frag.firstChild.getElementsByTagName('option')[2].selected, true, 'One is selected');
        });
        testIfRealDocument('<select multiple> applies initial value, when options rendered from array (#1414)', function () {
            var template = stache('<select values:bind=\'colors\' multiple>' + '{{#each allColors}}<option value=\'{{value}}\'>{{label}}</option>{{/each}}' + '</select>');
            var map = new SimpleMap({
                colors: new DefineList([
                    'red',
                    'green'
                ]),
                allColors: new DefineList([
                    {
                        value: 'red',
                        label: 'Red'
                    },
                    {
                        value: 'green',
                        label: 'Green'
                    },
                    {
                        value: 'blue',
                        label: 'Blue'
                    }
                ])
            });
            stop();
            var frag = template(map);
            var ta = this.fixture;
            ta.appendChild(frag);
            var select = ta.getElementsByTagName('select')[0], options = select.getElementsByTagName('option');
            testHelpers.afterMutation(function () {
                ok(options[0].selected, 'red should be set initially');
                ok(options[1].selected, 'green should be set initially');
                ok(!options[2].selected, 'blue should not be set initially');
                start();
            });
        });
        test('<select> one-way bindings keep value if options are replaced - each (#1762)', function () {
            var countries = [
                {
                    code: 'MX',
                    countryName: 'MEXICO'
                },
                {
                    code: 'US',
                    countryName: 'USA'
                }
            ];
            var data = new SimpleMap({
                countryCode: 'US',
                countries: new DefineList(countries)
            });
            var template = stache('<select el:value:from="countryCode">' + '{{#each countries}}' + '<option value="{{code}}">{{countryName}}</option>' + '{{/each}}' + '</select>');
            var frag = template(data);
            var select = frag.firstChild;
            stop();
            testHelpers.afterMutation(function () {
                data.get('countries').replace([]);
                testHelpers.afterMutation(function () {
                    data.attr('countries').replace(countries);
                    equal(data.attr('countryCode'), 'US', 'country kept as USA');
                    testHelpers.afterMutation(function () {
                        ok(select.getElementsByTagName('option')[1].selected, 'USA still selected');
                    });
                    start();
                });
            });
        });
        testIfRealDocument('<select> value:bind select single', function () {
            var template = stache('<select value:bind=\'color\'>' + '<option value=\'red\'>Red</option>' + '<option value=\'green\'>Green</option>' + '</select>');
            var map = new SimpleMap({ color: 'red' });
            var frag = template(map);
            var ta = this.fixture;
            ta.appendChild(frag);
            var inputs = ta.getElementsByTagName('select');
            equal(inputs[0].value, 'red', 'default value set');
            map.set('color', 'green');
            equal(inputs[0].value, 'green', 'alternate value set');
            canEach(ta.getElementsByTagName('option'), function (opt) {
                if (opt.value === 'red') {
                    opt.selected = 'selected';
                }
            });
            equal(map.get('color'), 'green', 'not yet updated from input');
            domEvents.dispatch(inputs[0], 'change');
            equal(map.get('color'), 'red', 'updated from input');
            canEach(ta.getElementsByTagName('option'), function (opt) {
                if (opt.value === 'green') {
                    opt.selected = 'selected';
                }
            });
            equal(map.get('color'), 'red', 'not yet updated from input');
            domEvents.dispatch(inputs[0], 'change');
            equal(map.get('color'), 'green', 'updated from input');
        });
        testIfRealDocument('<select> values:bind multiple select with a DefineList', function () {
            var template = stache('<select values:bind=\'colors\' multiple>' + '<option value=\'red\'>Red</option>' + '<option value=\'green\'>Green</option>' + '<option value=\'ultraviolet\'>Ultraviolet</option>' + '</select>');
            var list = new DefineList();
            stop();
            var frag = template({ colors: list });
            var ta = this.fixture;
            ta.appendChild(frag);
            var select = ta.getElementsByTagName('select')[0], options = select.getElementsByTagName('option');
            setTimeout(function () {
                options[0].selected = true;
                domEvents.dispatch(select, 'change');
                deepEqual(list.get(), ['red'], 'A DefineList value is set even if none existed');
                options[1].selected = true;
                domEvents.dispatch(select, 'change');
                deepEqual(list.get(), [
                    'red',
                    'green'
                ], 'Adds items to the list');
                options[0].selected = false;
                domEvents.dispatch(select, 'change');
                deepEqual(list.get(), ['green'], 'Removes items from the list');
                list.push('ultraviolet');
                options[0].selected = false;
                options[1].selected = true;
                options[2].selected = true;
                ta.removeChild(select);
                start();
            }, 1);
        });
        QUnit.test('<select> one-way bindings keep value if options are replaced (#1762)', function () {
            var countries = [
                {
                    code: 'MX',
                    countryName: 'MEXICO'
                },
                {
                    code: 'US',
                    countryName: 'USA'
                }
            ];
            var data = new SimpleMap({
                countryCode: 'US',
                countries: new DefineList(countries)
            });
            var template = stache('<select el:value:from="countryCode">' + '{{#countries}}' + '<option value="{{code}}">{{countryName}}</option>' + '{{/countries}}' + '</select>');
            var frag = template(data);
            var select = frag.firstChild;
            stop();
            testHelpers.afterMutation(function () {
                data.get('countries').replace([]);
                testHelpers.afterMutation(function () {
                    data.get('countries').replace(countries);
                    equal(data.get('countryCode'), 'US', 'country kept as USA');
                    testHelpers.afterMutation(function () {
                        ok(select.getElementsByTagName('option')[1].selected, 'USA still selected');
                    });
                    start();
                });
            });
        });
        testIfRealDocument('<select> two-way bindings update to `undefined` if options are replaced - each (#1762)', function () {
            var countries = [
                {
                    code: 'MX',
                    countryName: 'MEXICO'
                },
                {
                    code: 'US',
                    countryName: 'USA'
                }
            ];
            var data = new SimpleMap({
                countryCode: 'US',
                countries: new DefineList(countries)
            });
            var template = stache('<select el:value:bind="countryCode">' + '{{#each countries}}' + '<option value="{{code}}">{{countryName}}</option>' + '{{/each}}' + '</select>');
            template(data);
            stop();
            testHelpers.afterMutation(function () {
                data.attr('countries').replace([]);
                testHelpers.afterMutation(function () {
                    equal(data.get('countryCode'), undefined, 'countryCode set to undefined');
                    start();
                });
            });
        });
        testIfRealDocument('<select> - previously non-existing select value gets selected from a list when it is added (#1762)', function () {
            var template = stache('<select el:value:bind="{person}">' + '<option></option>' + '{{#each people}}<option value="{{.}}">{{.}}</option>{{/each}}' + '</select>' + '<input type="text" size="5" el:value:bind="person">');
            var people = new DefineList([
                'Justin',
                'Zed',
                'Tom',
                'Paula'
            ]);
            var vm = new SimpleMap({
                person: 'Brian',
                people: people
            });
            stop();
            vm.on('person', function (ev, newVal, oldVal) {
                ok(false, 'person attribute should not change');
            });
            var frag = template(vm);
            equal(vm.attr('person'), 'Brian', 'Person is still set');
            testHelpers.afterMutation(function () {
                people.push('Brian');
                testHelpers.afterMutation(function () {
                    var select = frag.firstChild;
                    ok(select.lastChild.selected, 'New child should be selected');
                    start();
                });
            });
        });
        test('<select> select bindings respond to changes immediately or during insert using bind (#2134)', function () {
            var countries = [
                {
                    code: 'MX',
                    countryName: 'MEXICO'
                },
                {
                    code: 'US',
                    countryName: 'USA'
                },
                {
                    code: 'IND',
                    countryName: 'INDIA'
                },
                {
                    code: 'RUS',
                    countryName: 'RUSSIA'
                }
            ];
            var template = stache('<select value:bind="countryCode">' + '{{#each countries}}' + '<option value="{{code}}">{{countryName}}</option>' + '{{/each}}' + '</select>');
            var data = new SimpleMap({
                countryCode: 'US',
                countries: new DefineList(countries)
            });
            var frag = template(data);
            data.set('countryCode', 'IND');
            stop();
            testHelpers.afterMutation(function () {
                start();
                equal(frag.firstChild.value, 'IND', 'got last updated value');
            });
        });
        testIfRealDocument('<select> two way bound select empty string null or undefined value (#2027)', function () {
            var template = stache('<select id=\'null-select\' value:bind=\'color-1\'>' + '<option value=\'\'>Choose</option>' + '<option value=\'red\'>Red</option>' + '<option value=\'green\'>Green</option>' + '</select>' + '<select id=\'undefined-select\' value:bind=\'color-2\'>' + '<option value=\'\'>Choose</option>' + '<option value=\'red\'>Red</option>' + '<option value=\'green\'>Green</option>' + '</select>' + '<select id=\'string-select\' value:bind=\'color-3\'>' + '<option value=\'\'>Choose</option>' + '<option value=\'red\'>Red</option>' + '<option value=\'green\'>Green</option>' + '</select>');
            var map = new SimpleMap({
                'color-1': null,
                'color-2': undefined,
                'color-3': ''
            });
            stop();
            var frag = template(map);
            domMutateNode.appendChild.call(this.fixture, frag);
            var nullInput = doc.getElementById('null-select');
            var nullInputOptions = nullInput.getElementsByTagName('option');
            var undefinedInput = doc.getElementById('undefined-select');
            var undefinedInputOptions = undefinedInput.getElementsByTagName('option');
            var stringInput = doc.getElementById('string-select');
            var stringInputOptions = stringInput.getElementsByTagName('option');
            testHelpers.afterMutation(function () {
                ok(!nullInputOptions[0].selected, 'default (null) value set');
                ok(undefinedInputOptions[0].selected, 'default (undefined) value set');
                ok(stringInputOptions[0].selected, 'default (\'\') value set');
                start();
            });
        });
        testIfRealDocument('<select> two way binding from a select\'s value to null has no selection (#2027)', function () {
            var template = stache('<select value:bind=\'key\'><option value=\'One\'>One</option></select>');
            var map = new SimpleMap({ key: null });
            var frag = template(map);
            var select = frag.childNodes.item(0);
            testHelpers.afterMutation(function () {
                equal(select.selectedIndex, -1, 'selectedIndex is 0 because no value exists on the map');
                equal(map.get('key'), null, 'The map\'s value property is set to the select\'s value');
                start();
            });
            stop();
        });
        testIfRealDocument('<select> One way binding from a select\'s value to a parent compute updates the parent with the select\'s initial value (#2027)', function () {
            var template = stache('<select value:to=\'value\'><option value=\'One\'>One</option></select>');
            var map = new SimpleMap();
            var frag = template(map);
            var select = frag.childNodes.item(0);
            testHelpers.afterMutation(function () {
                equal(select.selectedIndex, 0, 'selectedIndex is 0 because no value exists on the map');
                equal(map.attr('value'), 'One', 'The map\'s value property is set to the select\'s value');
                start();
            });
            stop();
        });
        testIfRealDocument('Bi-directional binding among sibling components, new syntax (#325)', function () {
            var demoContext = new DefineMap({ person: '' });
            var SourceComponentVM = DefineMap.extend({
                defaultPerson: { value: 'John' },
                person: {
                    set: function (val) {
                        return val || this.defaultPerson;
                    }
                }
            });
            var ClearComponentVM = DefineMap.extend({
                person: 'string',
                clearPerson: function () {
                    this.set('person', '');
                }
            });
            MockComponent.extend({
                tag: 'source-component',
                viewModel: SourceComponentVM,
                template: stache('<span>{{person}}</span><input type="text" value:bind="./person" />')
            });
            MockComponent.extend({
                tag: 'clear-button',
                viewModel: ClearComponentVM,
                template: stache('<input type="button" value="Clear" on:click="./clearPerson()" /><span>{{./person}}</span>')
            });
            var demoRenderer = stache('<span>{{./person}}</span>' + '<source-component person:bind="./person" />' + '<clear-button person:bind="./person" />');
            var frag = demoRenderer(demoContext);
            var sourceComponentVM = canViewModel(frag.childNodes[1]);
            var clearButtonVM = canViewModel(frag.childNodes[2]);
            QUnit.equal(frag.childNodes[0].childNodes[0].nodeValue, '', 'demoContext person is empty');
            QUnit.equal(frag.childNodes[1].childNodes[0].childNodes[0].nodeValue, 'John', 'source-component person is default');
            QUnit.equal(frag.childNodes[2].childNodes[1].childNodes[0].nodeValue, '', 'clear-button person is empty');
            sourceComponentVM.person = 'Bob';
            QUnit.equal(frag.childNodes[0].childNodes[0].nodeValue, 'Bob', 'demoContext person set correctly');
            QUnit.equal(frag.childNodes[1].childNodes[0].childNodes[0].nodeValue, 'Bob', 'source-component person set correctly');
            QUnit.equal(frag.childNodes[2].childNodes[1].childNodes[0].nodeValue, 'Bob', 'clear-button person set correctly');
            clearButtonVM.clearPerson();
            QUnit.equal(frag.childNodes[0].childNodes[0].nodeValue, '', 'demoContext person set correctly');
            QUnit.equal(frag.childNodes[1].childNodes[0].childNodes[0].nodeValue, 'John', 'source-component person set correctly');
            QUnit.equal(frag.childNodes[2].childNodes[1].childNodes[0].nodeValue, '', 'clear-button person set correctly');
        });
    });
});
/*can-event-dom-enter@2.1.0#can-event-dom-enter*/
define('can-event-dom-enter@2.1.0#can-event-dom-enter', [
    'require',
    'exports',
    'module',
    'can-namespace'
], function (require, exports, module) {
    'use strict';
    var namespace = require('can-namespace');
    var baseEventType = 'keyup';
    function isEnterEvent(event) {
        var hasEnterKey = event.key === 'Enter';
        var hasEnterCode = event.keyCode === 13;
        return hasEnterKey || hasEnterCode;
    }
    var enterEvent = {
        defaultEventType: 'enter',
        addEventListener: function (target, eventType, handler) {
            var keyHandler = function (event) {
                if (isEnterEvent(event)) {
                    return handler.apply(this, arguments);
                }
            };
            var handlerMap = enterEvent._eventTypeHandlerMap[eventType];
            if (!handlerMap) {
                handlerMap = enterEvent._eventTypeHandlerMap[eventType] = new Map();
            }
            handlerMap.set(handler, keyHandler);
            this.addEventListener(target, baseEventType, keyHandler);
        },
        removeEventListener: function (target, eventType, handler) {
            var handlerMap = enterEvent._eventTypeHandlerMap[eventType];
            if (handlerMap) {
                var keyHandler = handlerMap.get(handler);
                if (keyHandler) {
                    handlerMap.delete(handler);
                    if (handlerMap.size === 0) {
                        delete enterEvent._eventTypeHandlerMap[eventType];
                    }
                    this.removeEventListener(target, baseEventType, keyHandler);
                }
            }
        },
        _eventTypeHandlerMap: {}
    };
    module.exports = namespace.domEventEnter = enterEvent;
});
/*can-stache-bindings@4.0.5#test/colon/event-test*/
define('can-stache-bindings@4.0.5#test/colon/event-test', [
    'require',
    'exports',
    'module',
    'steal-qunit',
    '../helpers',
    'can-stache-bindings',
    'can-stache',
    '../mock-component-simple-map',
    'can-simple-map',
    'can-simple-observable',
    'can-view-model',
    'can-dom-data-state',
    'can-dom-mutate',
    'can-dom-mutate/node',
    'can-dom-events',
    'can-event-dom-enter'
], function (require, exports, module) {
    var QUnit = require('steal-qunit');
    var testHelpers = require('../helpers');
    require('can-stache-bindings');
    var stache = require('can-stache');
    var MockComponent = require('../mock-component-simple-map');
    var SimpleMap = require('can-simple-map');
    var SimpleObservable = require('can-simple-observable');
    var canViewModel = require('can-view-model');
    var domData = require('can-dom-data-state');
    var domMutate = require('can-dom-mutate');
    var domMutateNode = require('can-dom-mutate/node');
    var domEvents = require('can-dom-events');
    testHelpers.makeTests('can-stache-bindings - colon - event', function (name, doc, enableMO) {
        QUnit.test('on:enter', function () {
            var enterEvent = require('can-event-dom-enter');
            var undo = domEvents.addEvent(enterEvent);
            var template = stache('<input on:enter=\'update()\'/>');
            var called = 0;
            var frag = template({
                update: function () {
                    called++;
                    equal(called, 1, 'update called once');
                }
            });
            var input = frag.childNodes.item(0);
            domEvents.dispatch(input, {
                type: 'keyup',
                keyCode: 38
            });
            domEvents.dispatch(input, {
                type: 'keyup',
                keyCode: 13
            });
            undo();
        });
        QUnit.test('can call intermediate functions before calling the final function (#1474)', function (assert) {
            var ta = this.fixture;
            var done = assert.async();
            var template = stache('<div id=\'click-me\' on:click=\'does().some().thing(this)\'></div>');
            var frag = template({
                does: function () {
                    return {
                        some: function () {
                            return {
                                thing: function (context) {
                                    assert.ok(typeof context.does === 'function');
                                    done();
                                }
                            };
                        }
                    };
                }
            });
            ta.appendChild(frag);
            domEvents.dispatch(doc.getElementById('click-me'), 'click');
        });
        test('two bindings on one element call back the correct method', function () {
            expect(2);
            var template = stache('<input on:mousemove=\'first()\' on:click=\'second()\'/>');
            var callingFirst = false, callingSecond = false;
            var frag = template({
                first: function () {
                    ok(callingFirst, 'called first');
                },
                second: function () {
                    ok(callingSecond, 'called second');
                }
            });
            var input = frag.childNodes.item(0);
            callingFirst = true;
            domEvents.dispatch(input, { type: 'mousemove' });
            callingFirst = false;
            callingSecond = true;
            domEvents.dispatch(input, { type: 'click' });
        });
        test('event behavior event bindings should be removed when the bound element is', function (assert) {
            var template = stache('<div>{{#if isShowing}}<input on:el:click="onClick()"><span></span>{{/if}}</div>');
            var viewModel = new SimpleMap({ isShowing: false });
            viewModel.onClick = function () {
            };
            var bindingListenerCount = 0;
            var hasAddedBindingListener = false;
            var hasRemovedBindingListener = false;
            var fragment = template(viewModel);
            domMutateNode.appendChild.call(this.fixture, fragment);
            var isInputBindingEvent = function (element, eventName) {
                return element.nodeName === 'INPUT' && eventName === 'click';
            };
            var realAddEventListener = domEvents.addEventListener;
            var realRemoveEventListener = domEvents.removeEventListener;
            domEvents.addEventListener = function (target, eventName) {
                if (isInputBindingEvent(target, eventName)) {
                    bindingListenerCount++;
                    hasAddedBindingListener = true;
                }
                return realAddEventListener.apply(null, arguments);
            };
            domEvents.removeEventListener = function (target, eventName) {
                if (isInputBindingEvent(target, eventName)) {
                    bindingListenerCount--;
                    hasRemovedBindingListener = true;
                }
                return realRemoveEventListener.apply(null, arguments);
            };
            viewModel.set('isShowing', true);
            var span = this.fixture.firstChild.lastChild;
            var done = assert.async();
            var undo = domMutate.onNodeRemoval(span, function () {
                undo();
                domEvents.addEventListener = realAddEventListener;
                domEvents.removeEventListener = realRemoveEventListener;
                assert.ok(hasAddedBindingListener, 'An event listener should have been added for the binding');
                assert.ok(hasRemovedBindingListener, 'An event listener should have been removed for the binding');
                var message = bindingListenerCount + ' event listeners were added but not removed';
                if (removeEventListener < 0) {
                    message = 'Event listeners were removed more than necessary';
                }
                assert.equal(bindingListenerCount, 0, message);
                done();
            });
            viewModel.set('isShowing', false);
        });
        test('on:event throws an error when inside #if block (#1182)', function (assert) {
            var done = assert.async();
            var flag = new SimpleObservable(false), clickHandlerCount = 0;
            var frag = stache('<div {{#if flag}}on:click=\'foo\'{{/if}}>Click</div>')({
                flag: flag,
                foo: function () {
                    clickHandlerCount++;
                }
            });
            var fixture = this.fixture;
            var trig = function () {
                var div = fixture.getElementsByTagName('div')[0];
                domEvents.dispatch(div, { type: 'click' });
            };
            domMutateNode.appendChild.call(this.fixture, frag);
            trig();
            testHelpers.afterMutation(function () {
                equal(clickHandlerCount, 0, 'click handler not called');
                done();
            });
        });
        test('can listen to camelCase events using on:', function () {
            QUnit.stop();
            expect(1);
            var map = new SimpleMap({ someProp: 'foo' });
            map.someMethod = function () {
                QUnit.start();
                ok(true);
            };
            var template = stache('<div on:someProp:by:this=\'someMethod()\'/>');
            template(map);
            map.set('someProp', 'baz');
        });
        test('can listen to kebab-case events using on:', function () {
            QUnit.stop();
            expect(1);
            var map = new SimpleMap({ 'some-prop': 'foo' });
            map.someMethod = function () {
                QUnit.start();
                ok(true);
            };
            var template = stache('<div on:some-prop:by:this=\'someMethod()\'/>');
            template(map);
            map.set('some-prop', 'baz');
        });
        test('can bind to property on scope using :by:', function () {
            stop();
            expect(1);
            MockComponent.extend({ tag: 'view-model-able' });
            var template = stache('<view-model-able on:prop:by:obj=\'someMethod(scope.arguments)\'/>');
            var map = new SimpleMap({ obj: new SimpleMap({ prop: 'Mercury' }) });
            map.someMethod = function (args) {
                start();
                equal(args[0], 'Venus', 'method called');
            };
            template(map);
            map.get('obj').set('prop', 'Venus');
        });
        test('can bind to entire scope using :by:this', function () {
            stop();
            expect(1);
            MockComponent.extend({ tag: 'view-model-able' });
            var template = stache('<view-model-able on:prop:by:this=\'someMethod(scope.arguments[0])\'/>');
            var map = new SimpleMap({ prop: 'Mercury' });
            map.someMethod = function (newVal) {
                start();
                equal(newVal, 'Venus', 'method called');
            };
            template(map);
            map.set('prop', 'Venus');
        });
        test('can bind to viewModel using on:vm:prop', function () {
            stop();
            expect(1);
            var map = new SimpleMap({ prop: 'Mercury' });
            var MySimpleMap = SimpleMap.extend({
                someMethod: function (newVal) {
                    start();
                    equal(newVal, 'Venus', 'method called');
                }
            });
            var parent = new MySimpleMap();
            MockComponent.extend({
                tag: 'view-model-able',
                viewModel: map
            });
            var template = stache('<view-model-able on:vm:prop=\'someMethod(scope.arguments[0])\'/>');
            template(parent);
            map.attr('prop', 'Venus');
        });
        test('can bind to element using on:el:prop', function () {
            stop();
            expect(1);
            var map = new SimpleMap({ prop: 'Mercury' });
            var MySimpleMap = SimpleMap.extend({
                someMethod: function () {
                    start();
                    ok(true, 'method called');
                }
            });
            var parent = new MySimpleMap();
            MockComponent.extend({
                tag: 'view-model-able',
                viewModel: map
            });
            var template = stache('<view-model-able on:el:prop=\'someMethod()\'/>');
            var frag = template(parent);
            var element = frag.firstChild;
            domEvents.dispatch(element, 'prop');
        });
        test('call expressions work (#208)', function () {
            expect(2);
            stache.registerHelper('addTwo', function (arg) {
                return arg + 2;
            });
            stache.registerHelper('helperWithArgs', function (arg) {
                QUnit.equal(arg, 3, 'got the helper');
                ok(true, 'helper called');
            });
            var template = stache('<p on:click=\'helperWithArgs(addTwo(arg))\'></p>');
            var frag = template({ arg: 1 });
            this.fixture.appendChild(frag);
            var p0 = this.fixture.getElementsByTagName('p')[0];
            domEvents.dispatch(p0, 'click');
        });
        QUnit.test('events should bind when using a plain object', function () {
            var flip = false;
            var template = stache('<div {{#if test}}on:foo="flip()"{{/if}}>Test</div>');
            var frag = template({
                flip: function () {
                    flip = true;
                },
                test: true
            });
            domEvents.dispatch(frag.firstChild, 'foo');
            QUnit.ok(flip, 'Plain object method successfully called');
        });
        QUnit.test('scope.arguments gives the event arguments', function () {
            var template = stache('<button on:click=\'doSomething(scope.event, scope.arguments)\'>Default Args</button>');
            var MyMap = SimpleMap.extend({
                doSomething: function (ev, args) {
                    equal(args[0], ev, 'default arg is ev');
                }
            });
            var frag = template(new MyMap());
            var button = frag.firstChild;
            domEvents.dispatch(button, 'click');
        });
        test('special values get called', function (assert) {
            assert.expect(2);
            var done = assert.async();
            var vm = new (SimpleMap.extend('RefSyntaxVM', {
                method: function () {
                    assert.ok(true, 'method called');
                    done();
                }
            }))();
            vm._refSyntaxFlag = true;
            MockComponent.extend({
                tag: 'ref-syntax',
                template: stache('<input on:change="scope.set(\'*foo\', scope.element.value)">'),
                viewModel: vm
            });
            var template = stache('<ref-syntax on:el:baz-event="scope.viewModel.method()"></ref-syntax>');
            var frag = template({});
            domMutateNode.appendChild.call(this.fixture, frag);
            testHelpers.afterMutation(function () {
                var input = doc.getElementsByTagName('input')[0];
                input.value = 'bar';
                domEvents.dispatch(input, 'change');
                var scope = domData.get.call(this.fixture.firstChild).shadowScope;
                assert.equal(scope.get('*foo'), 'bar', 'Reference attribute set');
                var refElement = doc.getElementsByTagName('ref-syntax')[0];
                domEvents.dispatch(refElement, 'baz-event');
            }.bind(this));
        });
        QUnit.test('viewModel binding', function () {
            MockComponent.extend({
                tag: 'viewmodel-binding',
                viewModel: {
                    makeMyEvent: function () {
                        this.dispatch('myevent');
                    }
                }
            });
            var frag = stache('<viewmodel-binding on:myevent=\'doSomething()\'/>')({
                doSomething: function () {
                    ok(true, 'called!');
                }
            });
            canViewModel(frag.firstChild).makeMyEvent();
        });
    });
});
/*can-stache-bindings@4.0.5#test/colon/view-model-test*/
define('can-stache-bindings@4.0.5#test/colon/view-model-test', [
    'require',
    'exports',
    'module',
    'steal-qunit',
    '../helpers',
    'can-stache-bindings',
    'can-stache',
    'can-simple-map',
    '../mock-component-simple-map',
    'can-dom-events',
    'can-dom-mutate',
    'can-dom-mutate/node',
    'can-define/map/map',
    'can-view-callbacks',
    'can-view-model',
    'can-symbol',
    'can-reflect',
    'can-queues',
    'can-test-helpers'
], function (require, exports, module) {
    var QUnit = require('steal-qunit');
    var testHelpers = require('../helpers');
    require('can-stache-bindings');
    var stache = require('can-stache');
    var SimpleMap = require('can-simple-map');
    var MockComponent = require('../mock-component-simple-map');
    var domEvents = require('can-dom-events');
    var domMutate = require('can-dom-mutate');
    var domMutateNode = require('can-dom-mutate/node');
    var DefineMap = require('can-define/map/map');
    var viewCallbacks = require('can-view-callbacks');
    var canViewModel = require('can-view-model');
    var canSymbol = require('can-symbol');
    var canReflect = require('can-reflect');
    var queues = require('can-queues');
    var canTestHelpers = require('can-test-helpers');
    testHelpers.makeTests('can-stache-bindings - colon - ViewModel', function (name, doc, enableMO) {
        QUnit.test('on:el:click works inside {{#if}} on element with a viewModel (#279)', function () {
            var map = new SimpleMap({});
            var MySimpleMap = SimpleMap.extend({
                show: true,
                method: function () {
                    ok(true, 'method called');
                }
            });
            var parent = new MySimpleMap();
            MockComponent.extend({
                tag: 'view-model-able',
                viewModel: map
            });
            var template = stache('<view-model-able {{#if show}} on:el:click=\'method()\' {{/if}} />');
            var frag = template(parent);
            var el = frag.firstChild;
            domEvents.dispatch(el, 'click');
        });
        QUnit.test('vm:prop:to/:from/:bind work (#280)', function () {
            var vm1 = new SimpleMap({ value: 'vm1' });
            var vm2 = new SimpleMap({ value: 'vm2' });
            var vm3 = new SimpleMap({ value: 'vm3' });
            MockComponent.extend({
                tag: 'comp-1',
                viewModel: vm1
            });
            MockComponent.extend({
                tag: 'comp-2',
                viewModel: vm2
            });
            MockComponent.extend({
                tag: 'comp-3',
                viewModel: vm3
            });
            var template = stache('<comp-1 vm:value:to=\'scope1\'/>' + '<comp-2 vm:value:from=\'scope2\'/>' + '<comp-3 vm:value:bind=\'scope3\'/>');
            var scope = new SimpleMap({
                scope1: 'scope1',
                scope2: 'scope2',
                scope3: 'scope3'
            });
            template(scope);
            equal(scope.attr('scope1'), 'vm1', 'vm:value:to - scope value set from vm');
            vm1.attr('value', 'vm4');
            equal(scope.attr('scope1'), 'vm4', 'vm:value:to - scope updated when vm changes');
            scope.attr('scope1', 'scope4');
            equal(vm1.attr('value'), 'vm4', 'vm:value:to - vm not updated when scope changes');
            equal(vm2.attr('value'), 'scope2', 'vm:value:from - vm value set from scope');
            scope.attr('scope2', 'scope5');
            equal(vm2.attr('value'), 'scope5', 'vm:value:from - vm updated when scope changes');
            vm2.attr('value', 'vm5');
            equal(scope.attr('scope2'), 'scope5', 'vm:value:from - scope not updated when vm changes');
            equal(vm3.attr('value'), 'scope3', 'vm:value:bind - vm value set from scope');
            scope.attr('scope3', 'scope6');
            equal(vm3.attr('value'), 'scope6', 'vm:value:bind - vm updated when scope changes');
            vm3.attr('value', 'vm6');
            equal(scope.attr('scope3'), 'vm6', 'vm:value:bind - scope updated when vm changes');
        });
        canTestHelpers.dev.devOnlyTest('Warning happens when changing the map that a to-parent binding points to.', function () {
            var tagName = 'merge-warn-test';
            delete viewCallbacks._tags[tagName];
            expect(2);
            var step1 = { 'baz': 'quux' };
            var overwrite = { 'plonk': 'waldo' };
            var teardown = canTestHelpers.dev.willWarn('can-stache-key: Merging data into "bar" because its parent is non-observable');
            var viewModel;
            MockComponent.extend({
                tag: tagName,
                viewModel: function () {
                    return viewModel = new SimpleMap({ 'foo': new SimpleMap({}) });
                }
            });
            var template = stache('<merge-warn-test foo:bind=\'bar\'/>');
            var data = { bar: new SimpleMap(step1) };
            this.fixture.appendChild(template(data));
            viewModel.set('foo', overwrite);
            deepEqual(data.bar.get(), { 'plonk': 'waldo' }, 'sanity check: parent binding set (default map -> default map)');
            QUnit.equal(teardown(), 1, 'warning shown');
        });
        QUnit.test('changing a scope property calls registered stache helper\'s returned function', function () {
            expect(1);
            stop();
            var scope = new SimpleMap({ test: 'testval' });
            MockComponent.extend({
                tag: 'test-component',
                viewModel: scope,
                template: stache('<span>Hello world</span>')
            });
            stache.registerHelper('propChangeEventStacheHelper', function () {
                return function () {
                    start();
                    ok(true, 'helper\'s returned function called');
                };
            });
            var template = stache('<test-component on:test="propChangeEventStacheHelper()" />');
            template({});
            scope.set('test', 'changed');
        });
        test('one-way pass computes to components with ~', function (assert) {
            expect(6);
            MockComponent.extend({ tag: 'foo-bar' });
            var baseVm = new SimpleMap({ foo: 'bar' });
            this.fixture.appendChild(stache('<foo-bar compute:from="~foo"></foo-bar>')(baseVm));
            var vm = canViewModel(this.fixture.firstChild);
            ok(vm.get('compute')[canSymbol.for('can.getValue')], 'observable returned');
            equal(vm.get('compute')(), 'bar', 'Compute has correct value');
            canReflect.onValue(vm.get('compute'), function () {
                ok(true, 'Change handler called');
            });
            baseVm.set('foo', 'quux');
            equal(vm.get('compute')(), 'quux', 'Compute updates');
            vm.get('compute')('xyzzy');
            equal(baseVm.get('foo'), 'xyzzy', 'Compute does update the other direction');
        });
        test('Child bindings updated before parent (#2252)', function () {
            var template = stache('{{#eq page \'view\'}}<child-binder page:from=\'page\' title:from=\'title\'/>{{/eq}}');
            MockComponent.extend({
                tag: 'child-binder',
                template: stache('<span/>'),
                viewModel: function (props) {
                    var map = new SimpleMap(props);
                    canReflect.assignSymbols(map, {
                        'can.setKeyValue': function (key, value) {
                            if (key === 'page') {
                                equal(value, 'view', 'value should not be edit');
                            } else {
                                QUnit.equal(key, 'title', 'title was set, we are trapping right');
                            }
                            this.set(key, value);
                        }
                    });
                    return map;
                }
            });
            var data = new SimpleMap({ page: 'view' });
            template(data);
            data.set('title', 'foo');
            queues.batch.start();
            data.set('page', 'edit');
            queues.batch.stop();
        });
        test('backtrack path in to-parent bindings (#2132)', function () {
            MockComponent.extend({
                tag: 'parent-export',
                viewModel: { value: 'VALUE' }
            });
            var template = stache('{{#innerMap}}<parent-export value:to=\'../parentValue\'/>{{/innerMap}}');
            var data = new SimpleMap({ innerMap: new SimpleMap({}) });
            template(data);
            equal(data.get('parentValue'), 'VALUE', 'set on correct context');
            equal(data.get('innerMap').get('parentValue'), undefined, 'nothing on innerMap');
        });
        test('function reference to child binding (#2116)', function () {
            expect(2);
            var template = stache('<foo-bar vm:child:from="parent"></foo-bar>');
            MockComponent.extend({
                tag: 'foo-bar',
                viewModel: {}
            });
            var VM = SimpleMap.extend({});
            var vm = new VM({});
            var frag = template(vm);
            vm.attr('parent', function () {
                ok(false, 'should not be called');
            });
            equal(typeof canViewModel(frag.firstChild).attr('child'), 'function', 'to child binding');
            template = stache('<foo-bar vm:method:to="vmMethod"></foo-bar>');
            vm = new VM({});
            frag = template(vm);
            canViewModel(frag.firstChild).attr('method', function () {
                ok(false, 'method should not be called');
            });
            equal(typeof vm.get('vmMethod'), 'function', 'parent export function');
        });
        test('setter only gets called once (#2117)', function () {
            expect(1);
            var VM = SimpleMap.extend({
                attr: function (prop, val) {
                    if (prop === 'bar') {
                        equal(val, 'BAR');
                    }
                    return SimpleMap.prototype.attr.apply(this, arguments);
                }
            });
            MockComponent.extend({
                tag: 'foo-bar',
                viewModel: VM
            });
            var template = stache('<foo-bar vm:bar:from="bar"/>');
            template(new SimpleMap({ bar: 'BAR' }));
        });
        test('function reference to child (#2116)', function () {
            expect(2);
            var template = stache('<foo-bar vm:child:from="parent"></foo-bar>');
            MockComponent.extend({
                tag: 'foo-bar',
                viewModel: {
                    method: function () {
                        ok(false, 'should not be called');
                    }
                }
            });
            var VM = SimpleMap.extend({
                parent: function () {
                    ok(false, 'should not be called');
                }
            });
            var vm = new VM({});
            var frag = template(vm);
            equal(typeof canViewModel(frag.firstChild).attr('child'), 'function', 'to child binding');
            template = stache('<foo-bar vm:method:to="vmMethod"></foo-bar>');
            vm = new VM({});
            template(vm);
            ok(typeof vm.attr('vmMethod') === 'function', 'parent export function');
        });
        test('exporting methods (#2051)', function () {
            expect(2);
            MockComponent.extend({
                tag: 'foo-bar',
                viewModel: {
                    method: function () {
                        ok(true, 'foo called');
                        return 5;
                    }
                }
            });
            var template = stache('<foo-bar method:to=\'scope.vars.refKey\'></foo-bar>{{scope.vars.refKey()}}');
            var frag = template({});
            equal(frag.lastChild.nodeValue, '5');
        });
        test('one way - child to parent - importing viewModel hyphenatedProp:to="test"', function () {
            MockComponent.extend({
                tag: 'import-prop-scope',
                template: stache('Hello {{userName}}'),
                viewModel: {
                    userName: 'David',
                    age: 7,
                    updateName: function () {
                        this.set('userName', 'Justin');
                    }
                }
            });
            MockComponent.extend({
                tag: 'import-prop-parent',
                template: stache('<import-prop-scope vm:userName:to="test" vm:this:to="childComponent"></import-prop-scope>' + '<div>Imported: {{test}}</div>')
            });
            var template = stache('<import-prop-parent></import-prop-parent>');
            var frag = template({});
            var importPropParent = frag.firstChild;
            var importPropScope = importPropParent.getElementsByTagName('import-prop-scope')[0];
            canViewModel(importPropScope).updateName();
            var importPropParentViewModel = canViewModel(importPropParent);
            equal(importPropParentViewModel.get('test'), 'Justin', 'got hyphenated prop');
            equal(importPropParentViewModel.get('childComponent'), canViewModel(importPropScope), 'got view model');
        });
        test('one way - child to parent - importing viewModel prop:to="test"', function () {
            MockComponent.extend({
                tag: 'import-prop-scope',
                template: stache('Hello {{name}}'),
                viewModel: {
                    name: 'David',
                    age: 7
                }
            });
            MockComponent.extend({
                tag: 'import-prop-parent',
                template: stache('<import-prop-scope vm:name:to="test"></import-prop-scope>' + '<div>Imported: {{test}}</div>')
            });
            var template = stache('<import-prop-parent></import-prop-parent>');
            var frag = template({});
            equal(frag.childNodes.item(0).childNodes.item(1).innerHTML, 'Imported: David', '{name} component scope imported into variable');
        });
        test('one-way - child to parent - viewModel', function () {
            MockComponent.extend({
                tag: 'view-model-able',
                viewModel: function () {
                    return new SimpleMap({ viewModelProp: 'Mercury' });
                }
            });
            var template = stache('<view-model-able vm:viewModelProp:to=\'scopeProp\'/>');
            var map = new SimpleMap({ scopeProp: 'Venus' });
            var frag = template(map);
            var viewModel = canViewModel(frag.firstChild);
            equal(viewModel.get('viewModelProp'), 'Mercury', 'initial value kept');
            equal(map.get('scopeProp'), 'Mercury', 'initial value set on parent');
            viewModel.set('viewModelProp', 'Earth');
            equal(map.get('scopeProp'), 'Earth', 'binding from child to parent');
            map.set('scopeProp', 'Mars');
            equal(viewModel.get('viewModelProp'), 'Earth', 'no binding from parent to child');
        });
        test('one-way - parent to child - viewModel', function () {
            var template = stache('<div vm:viewModelProp:from=\'scopeProp\'/>');
            var map = new SimpleMap({ scopeProp: 'Venus' });
            var frag = template(map);
            var viewModel = canViewModel(frag.firstChild);
            equal(viewModel.attr('viewModelProp'), 'Venus', 'initial value set');
            viewModel.attr('viewModelProp', 'Earth');
            equal(map.attr('scopeProp'), 'Venus', 'no binding from child to parent');
            map.attr('scopeProp', 'Mars');
            equal(viewModel.attr('viewModelProp'), 'Mars', 'binding from parent to child');
        });
        test('two-way - reference - child:bind="scope.vars.ref" (#1700)', function () {
            var data = new SimpleMap({ person: new SimpleMap({ name: new SimpleMap({}) }) });
            MockComponent.extend({
                tag: 'reference-export',
                viewModel: function () {
                    return new SimpleMap({ tag: 'reference-export' });
                }
            });
            MockComponent.extend({
                tag: 'ref-import',
                viewModel: function () {
                    return new SimpleMap({ tag: 'ref-import' });
                }
            });
            var template = stache('<reference-export name:bind=\'scope.vars.refName\'/>' + '<ref-import name:bind=\'scope.vars.refName\'/> {{helperToGetScope()}}');
            var scope;
            var frag = template(data, {
                helperToGetScope: function (options) {
                    scope = options.scope;
                }
            });
            var refExport = canViewModel(frag.firstChild);
            var refImport = canViewModel(frag.firstChild.nextSibling);
            refExport.set('name', 'v1');
            equal(scope.peek('scope.vars.refName'), 'v1', 'reference scope updated');
            equal(refImport.get('name'), 'v1', 'updated ref-import');
            refImport.set('name', 'v2');
            equal(refExport.get('name'), 'v2', 'updated ref-export');
            equal(scope.peek('scope.vars.refName'), 'v2', 'actually put in refs scope');
        });
        test('one-way - DOM - parent value undefined (#189)', function () {
            MockComponent.extend({
                tag: 'toggle-button',
                viewModel: function () {
                    var vm = new SimpleMap({ value: false });
                    vm.toggle = function () {
                        this.set('value', !this.get('value'));
                    };
                    return vm;
                },
                template: stache('<button type="button" on:el:click="toggle()">{{value}}</button>')
            });
            var template = stache('<toggle-button vm:value:bind="./does-not-exist" />');
            var fragment = template({});
            domMutateNode.appendChild.call(this.fixture, fragment);
            var button = this.fixture.getElementsByTagName('button')[0];
            function text(node) {
                while (node && node.nodeType !== 3) {
                    node = node.firstChild;
                }
                return node && node.nodeValue;
            }
            equal(text(button), 'false', 'Initial value is "false"');
            domEvents.dispatch(button, 'click');
            equal(text(button), 'true', 'Value is "true" after first click');
            domEvents.dispatch(button, 'click');
            equal(text(button), 'false', 'Value is "false" after second click');
        });
        test('two way - viewModel (#1700)', function () {
            var template = stache('<div vm:viewModelProp:bind=\'scopeProp\'/>');
            var map = new SimpleMap({ scopeProp: 'Hello' });
            var scopeMapSetCalled = 0;
            var origMapSetKeyValue = map[canSymbol.for('can.setKeyValue')];
            map[canSymbol.for('can.setKeyValue')] = function (attrName, value) {
                if (typeof attrName === 'string' && arguments.length > 1) {
                    scopeMapSetCalled++;
                }
                return origMapSetKeyValue.apply(this, arguments);
            };
            var frag = template(map);
            var viewModel = canViewModel(frag.firstChild);
            equal(scopeMapSetCalled, 0, 'set is not called on scope map');
            equal(viewModel.get('viewModelProp'), 'Hello', 'initial value set');
            viewModel = canViewModel(frag.firstChild);
            var viewModelSetCalled = 1;
            var origViewModelSet = viewModel[canSymbol.for('can.setKeyValue')];
            viewModel[canSymbol.for('can.setKeyValue')] = function (attrName) {
                if (typeof attrName === 'string' && arguments.length > 1) {
                    viewModelSetCalled++;
                }
                return origViewModelSet.apply(this, arguments);
            };
            viewModel.set('viewModelProp', 'HELLO');
            equal(map.get('scopeProp'), 'HELLO', 'binding from child to parent');
            equal(scopeMapSetCalled, 1, 'set is called on scope map');
            equal(viewModelSetCalled, 2, 'set is called viewModel');
            map.set('scopeProp', 'WORLD');
            equal(viewModel.get('viewModelProp'), 'WORLD', 'binding from parent to child');
            equal(scopeMapSetCalled, 1, 'can.setKey is not called again on scope map');
            equal(viewModelSetCalled, 3, 'set is called again on viewModel');
        });
        test('standard attributes should not set viewModel props', function () {
            MockComponent.extend({
                tag: 'test-elem',
                viewModel: SimpleMap
            });
            var template = stache('<test-elem foo="bar"/>');
            var frag = template(new SimpleMap({ bar: true }));
            var vm = canViewModel(frag.firstChild);
            equal(vm.get('foo'), undefined);
        });
        test('set string on the viewModel', function () {
            expect(2);
            var ViewModel = DefineMap.extend({
                foo: {
                    type: 'string',
                    set: function (val) {
                        equal(val, 'bar');
                    }
                },
                baz: {
                    type: 'string',
                    set: function (val) {
                        equal(val, 'qux');
                    }
                }
            });
            MockComponent.extend({
                tag: 'test-elem',
                viewModel: ViewModel
            });
            var template = stache('<test-elem foo:from="\'bar\'" baz:from="\'qux\'"/>');
            template();
        });
        test('viewModel behavior event bindings should be removed when the bound element is', function (assert) {
            MockComponent.extend({
                tag: 'view-model-binder',
                viewModel: {},
                template: stache('<span />')
            });
            var done = assert.async();
            var onNodeAttributeChange = domMutate.onNodeAttributeChange;
            var attributeChangeCount = 0;
            var isAttributeChangeTracked = false;
            var isTarget = function (target) {
                return target.nodeName === 'VIEW-MODEL-BINDER';
            };
            domMutate.onNodeAttributeChange = function (node) {
                if (!isTarget(node)) {
                    return onNodeAttributeChange.apply(null, arguments);
                }
                attributeChangeCount++;
                isAttributeChangeTracked = true;
                var disposal = onNodeAttributeChange.apply(null, arguments);
                return function () {
                    attributeChangeCount--;
                    return disposal();
                };
            };
            var viewModel = new SimpleMap({
                isShowing: true,
                bar: 'baz'
            });
            var template = stache('<div>{{#if isShowing}}<view-model-binder foo:bind="bar"/><hr/>{{/if}}</div>');
            var fragment = template(viewModel);
            domMutateNode.appendChild.call(this.fixture, fragment);
            var hr = this.fixture.firstChild.lastChild;
            var removalDisposal = domMutate.onNodeRemoval(hr, function () {
                removalDisposal();
                domMutate.onNodeAttributeChange = onNodeAttributeChange;
                assert.ok(isAttributeChangeTracked, 'Attribute foo:bind="bar" should be tracked');
                assert.equal(attributeChangeCount, 0, 'all attribute listeners should be disposed');
                done();
            });
            viewModel.attr('isShowing', false);
        });
        canTestHelpers.dev.devOnlyTest('warning displayed when using @', function () {
            expect(3);
            var teardown = canTestHelpers.dev.willWarn('myTemplate.stache:1: functions are no longer called by default so @ is unnecessary in \'@scope.vars.refKey\'.');
            MockComponent.extend({
                tag: 'foo-bar',
                viewModel: {
                    method: function () {
                        ok(true, 'foo called');
                        return 5;
                    }
                }
            });
            var template = stache('myTemplate.stache', '<foo-bar method:to=\'@scope.vars.refKey\'></foo-bar>{{scope.vars.refKey()}}');
            var frag = template({});
            equal(frag.lastChild.nodeValue, '5');
            equal(teardown(), 2, 'warnings displayed for read and write');
        });
    });
});
/*can-stache-bindings@4.0.5#test/colon/hybrid-test*/
define('can-stache-bindings@4.0.5#test/colon/hybrid-test', [
    'require',
    'exports',
    'module',
    'steal-qunit',
    '../helpers',
    'can-stache-bindings',
    'can-stache',
    'can-simple-map',
    'can-dom-events'
], function (require, exports, module) {
    var QUnit = require('steal-qunit');
    var testHelpers = require('../helpers');
    require('can-stache-bindings');
    var stache = require('can-stache');
    var SimpleMap = require('can-simple-map');
    var domEvents = require('can-dom-events');
    testHelpers.makeTests('can-stache-bindings - colon - hybrids', function (name, doc, enableMO) {
        test('value:to:on:click and on:click:value:to work (#269)', function () {
            var template = stache('<input value:to:on:click=\'theProp\'/>' + '<input on:click:value:to=\'theProp\'/>');
            var map = new SimpleMap({});
            var frag = template(map);
            var ta = this.fixture;
            ta.appendChild(frag);
            var bindFirstInput = ta.getElementsByTagName('input')[0];
            bindFirstInput.value = '22';
            domEvents.dispatch(bindFirstInput, 'click');
            QUnit.equal(map.get('theProp'), '22');
            var eventFirstInput = ta.getElementsByTagName('input')[1];
            eventFirstInput.value = '23';
            domEvents.dispatch(eventFirstInput, 'click');
            QUnit.equal(map.get('theProp'), '23');
        });
        QUnit.test('on:input:value:to works (#289)', function () {
            var scope = new SimpleMap({ myProp: '' });
            var renderer = stache('<input type=\'text\' value=\'hai\' on:input:value:to=\'myProp\' />');
            var view = renderer(scope);
            var ta = this.fixture;
            ta.appendChild(view);
            var inputTo = ta.getElementsByTagName('input')[0];
            inputTo.value = 'wurld';
            domEvents.dispatch(inputTo, 'input');
            equal(scope.get('myProp'), 'wurld', 'Got the value on the scope');
        });
        QUnit.test('on:input:value:to does not initialize values (#289)', function () {
            try {
                stache('<input on:input:value:to=\'*editing.licensePlate\'/>')();
                ok(true, 'renderer was made without error');
            } catch (e) {
                ok(false, e.message);
            }
        });
    });
});
/*can-stache-bindings@4.0.5#test/colon/dependencies-test*/
define('can-stache-bindings@4.0.5#test/colon/dependencies-test', [
    'require',
    'exports',
    'module',
    '@steal',
    'steal-qunit',
    'can-simple-map',
    'can-view-model',
    'can-reflect-dependencies',
    'can-stache',
    'can-stache-bindings'
], function (require, exports, module) {
    var steal = require('@steal');
    var QUnit = require('steal-qunit');
    var SimpleMap = require('can-simple-map');
    var canViewModel = require('can-view-model');
    var canReflectDeps = require('can-reflect-dependencies');
    var stache = require('can-stache');
    require('can-stache-bindings');
    QUnit.module('bindings dependencies', {
        beforeEach: function () {
            this.fixture = document.getElementById('qunit-fixture');
        },
        afterEach: function () {
            document.getElementById('qunit-fixture').innerHTML = '';
        }
    });
    var devOnlyTest = steal.isEnv('production') ? QUnit.skip : QUnit.test;
    devOnlyTest('parent to child dependencies', function (assert) {
        var template = stache('<input value:from="age">');
        var map = new SimpleMap();
        var frag = template(map);
        var ta = this.fixture;
        ta.appendChild(frag);
        var input = ta.getElementsByTagName('input')[0];
        var inputDeps = canReflectDeps.getDependencyDataOf(input, 'value').whatChangesMe;
        assert.ok(inputDeps.mutate.valueDependencies.size, 'the input should have mutation dependencies');
        var attributeObservation = Array.from(inputDeps.mutate.valueDependencies)[0];
        var attributeObservationDeps = canReflectDeps.getDependencyDataOf(attributeObservation).whatChangesMe;
        assert.ok(attributeObservationDeps.derive.keyDependencies.get(input).has('value'), 'the input\'s \'value\' attribute should be a dependency of the attribute observation');
        assert.ok(attributeObservationDeps.mutate.valueDependencies.size, 'the attribute observation should have mutation dependencies');
        var scopeKeyData = Array.from(attributeObservationDeps.mutate.valueDependencies)[0];
        var scopeKeyDataDeps = canReflectDeps.getDependencyDataOf(scopeKeyData).whatChangesMe;
        assert.ok(!scopeKeyDataDeps.mutate, 'the attribute observation should NOT be a dependency of scopeKeyData');
    });
    devOnlyTest('parent to child - map', function (assert) {
        var template = stache('<input value:from="age">');
        var map = new SimpleMap({ age: 10 });
        var frag = template(map);
        var ta = this.fixture;
        ta.appendChild(frag);
        var ageDeps = canReflectDeps.getDependencyDataOf(map, 'age').whatChangesMe;
        assert.ok(ageDeps.mutate.valueDependencies.size, 'map.age should have mutation dependencies');
        var scopeKeyData = Array.from(ageDeps.mutate.valueDependencies)[0];
        var scopeKeyDataDeps = canReflectDeps.getDependencyDataOf(scopeKeyData).whatIChange;
        assert.ok(scopeKeyDataDeps.mutate.valueDependencies.size, 'the scopeKeyData should have [whatIChange] mutation dependencies');
        var attributeObservable = Array.from(scopeKeyDataDeps.mutate.valueDependencies)[0];
        assert.equal(attributeObservable.constructor.name, 'AttributeObservable', 'scopeKeyData affects the AttributeObservable instance');
    });
    devOnlyTest('child to parent dependencies', function (assert) {
        var template = stache('<input value:to="age">');
        var scope = new SimpleMap({ age: 10 });
        var frag = template(scope);
        var ta = this.fixture;
        ta.appendChild(frag);
        var input = ta.getElementsByTagName('input')[0];
        var inputDeps = canReflectDeps.getDependencyDataOf(input, 'value').whatChangesMe;
        assert.ok(inputDeps.mutate.valueDependencies.size, 'the input should have mutation dependencies');
        var attributeObservation = Array.from(inputDeps.mutate.valueDependencies)[0];
        var attributeObservationDeps = canReflectDeps.getDependencyDataOf(attributeObservation);
        assert.ok(attributeObservationDeps.whatChangesMe.derive.keyDependencies.get(input).has('value'), 'the input\'s \'value\' attribute should be a dependency of the attribute observation');
        assert.ok(attributeObservationDeps.whatIChange.mutate.valueDependencies.size, 'The attribute observable changes ScopeObservable');
        var scopeObservable = Array.from(attributeObservationDeps.whatIChange.mutate.valueDependencies)[0];
        var scopeObservableDeps = canReflectDeps.getDependencyDataOf(scopeObservable).whatIChange.mutate;
        assert.ok(scopeObservableDeps.keyDependencies.get(scope).has('age'), 'The scope observable changes the scope\'s \'age\' property');
    });
    devOnlyTest('attribute cross binding dependencies', function (assert) {
        var template = stache('<input value:bind="age">');
        var scope = new SimpleMap({ age: 8 });
        var frag = template(scope);
        var ta = this.fixture;
        ta.appendChild(frag);
        var input = ta.getElementsByTagName('input')[0];
        var inputDeps = canReflectDeps.getDependencyDataOf(input, 'value').whatChangesMe;
        assert.ok(inputDeps.mutate.valueDependencies.size, 'the input should have mutation dependencies');
        var attributeObservation = Array.from(inputDeps.mutate.valueDependencies)[0];
        var attributeObservationDeps = canReflectDeps.getDependencyDataOf(attributeObservation).whatChangesMe;
        assert.ok(attributeObservationDeps.derive.keyDependencies.get(input).has('value'), 'the input\'s \'value\' attribute should be a dependency of the attribute observation');
        assert.ok(attributeObservationDeps.mutate.valueDependencies.size, 'the attribute observation should have mutation dependencies');
        var scopeKeyData = Array.from(attributeObservationDeps.mutate.valueDependencies)[0];
        var scopeKeyDataDeps = canReflectDeps.getDependencyDataOf(scopeKeyData).whatChangesMe;
        assert.ok(scopeKeyDataDeps.mutate.valueDependencies.has(attributeObservation), 'the attribute observation should be a dependency of scopeKeyData');
    });
    devOnlyTest('view model parent to child binding', function (assert) {
        var template = stache('<div id="comp" vm:viewModelProp:from="scopeProp"></div>');
        var map = new SimpleMap({ scopeProp: 'Venus' });
        var ta = this.fixture;
        ta.appendChild(template(map));
        var vm = canViewModel(ta.getElementsByTagName('div')[0]);
        var vmDeps = canReflectDeps.getDependencyDataOf(vm, 'viewModelProp').whatChangesMe;
        assert.ok(vmDeps.mutate.valueDependencies.size, 'The viewmodel property should have value dependencies');
        var settableObservable = Array.from(vmDeps.mutate.valueDependencies)[0];
        var settableObservableDeps = canReflectDeps.getDependencyDataOf(settableObservable).whatChangesMe;
        assert.ok(settableObservableDeps.mutate.valueDependencies.size, 'The settable observable should have value dependencies');
        var scopeKeyData = Array.from(settableObservableDeps.mutate.valueDependencies)[0];
        var scopeKeyDataDeps = canReflectDeps.getDependencyDataOf(scopeKeyData).whatChangesMe;
        assert.ok(scopeKeyDataDeps.derive.keyDependencies.get(map).has('scopeProp'), 'The ScopeKeyData is bound to map.scopeProp');
    });
    devOnlyTest('view model child to parent binding', function (assert) {
        var template = stache('<div id="comp" vm:viewModelProp:to="scopeProp"></div>');
        var map = new SimpleMap({ scopeProp: 'Venus' });
        var ta = this.fixture;
        ta.appendChild(template(map));
        var vm = canViewModel(ta.getElementsByTagName('div')[0]);
        var vmDeps = canReflectDeps.getDependencyDataOf(vm, 'viewModelProp').whatChangesMe;
        assert.ok(vmDeps.mutate.valueDependencies.size, 'The viewmodel property should have value dependencies');
        var settableObservable = Array.from(vmDeps.mutate.valueDependencies)[0];
        var settableObservableDeps = canReflectDeps.getDependencyDataOf(settableObservable).whatIChange;
        assert.ok(settableObservableDeps.mutate.valueDependencies.size, 'The settable observable should have value dependencies');
        var scopeObs = Array.from(settableObservableDeps.mutate.valueDependencies)[0];
        var scopeObsDeps = canReflectDeps.getDependencyDataOf(scopeObs).whatIChange;
        assert.ok(scopeObsDeps.mutate.keyDependencies.get(map).has('scopeProp'), 'The ObservableFromScope is bound to map.scopeProp');
    });
});
/*can-stache-bindings@4.0.5#test/colon/tests*/
define('can-stache-bindings@4.0.5#test/colon/tests', [
    'require',
    'exports',
    'module',
    './basics-test',
    './element-test',
    './event-test',
    './view-model-test',
    './hybrid-test',
    './dependencies-test'
], function (require, exports, module) {
    require('./basics-test');
    require('./element-test');
    require('./event-test');
    require('./view-model-test');
    require('./hybrid-test');
    require('./dependencies-test');
});
/*can-stache-bindings@4.0.5#test/data/tests*/
define('can-stache-bindings@4.0.5#test/data/tests', [
    'require',
    'exports',
    'module',
    'steal-qunit',
    '../helpers',
    'can-stache-bindings',
    'can-stache',
    'can-simple-map',
    'can-dom-mutate',
    'can-dom-mutate/node'
], function (require, exports, module) {
    var QUnit = require('steal-qunit');
    var testHelpers = require('../helpers');
    require('can-stache-bindings');
    var stache = require('can-stache');
    var SimpleMap = require('can-simple-map');
    var domMutate = require('can-dom-mutate');
    var domMutateNode = require('can-dom-mutate/node');
    testHelpers.makeTests('can-stache-bindings - data', function (name, doc, enableMO, testIfRealDocument) {
        QUnit.test('event bindings should be removed when the bound element is', function (assert) {
            var done = assert.async();
            var template = stache('<div>{{#if isShowing}}<span foo:from="bar"></span><hr/>{{/if}}</div>');
            var viewModel = new SimpleMap({
                isShowing: true,
                bar: 'baz'
            });
            var isTarget = function (target) {
                return target.nodeName === 'SPAN';
            };
            var attributeChangeCount = 0;
            var isAttributeChangeTracked = false;
            var onNodeAttributeChange = domMutate.onNodeAttributeChange;
            domMutate.onNodeAttributeChange = function (node) {
                if (!isTarget(node)) {
                    return onNodeAttributeChange.apply(null, arguments);
                }
                attributeChangeCount++;
                isAttributeChangeTracked = true;
                var disposal = onNodeAttributeChange.apply(null, arguments);
                return function () {
                    attributeChangeCount--;
                    return disposal();
                };
            };
            var removalCount = 0;
            var isRemovalTracked = false;
            var onNodeRemoval = domMutate.onNodeRemoval;
            domMutate.onNodeRemoval = function (node) {
                if (!isTarget(node)) {
                    return onNodeRemoval.apply(null, arguments);
                }
                removalCount++;
                isRemovalTracked = true;
                var disposal = onNodeRemoval.apply(null, arguments);
                return function () {
                    removalCount--;
                    return disposal();
                };
            };
            var fragment = template(viewModel);
            domMutateNode.appendChild.call(this.fixture, fragment);
            var hr = this.fixture.firstChild.lastChild;
            var removalDisposal = domMutate.onNodeRemoval(hr, function () {
                removalDisposal();
                domMutate.onNodeAttributeChange = onNodeAttributeChange;
                assert.ok(isAttributeChangeTracked, 'Attribute foo:from="bar" should be tracked');
                assert.equal(attributeChangeCount, 0, 'all attribute listeners should be disposed');
                domMutate.onNodeRemoval = onNodeRemoval;
                assert.ok(isRemovalTracked, 'Element span should be tracked');
                assert.equal(removalCount, 0, 'all removal listeners should be disposed');
                done();
            });
            viewModel.attr('isShowing', false);
        });
    });
});
/*can-stache-bindings@4.0.5#attribute-observable/attribute-observable-test*/
define('can-stache-bindings@4.0.5#attribute-observable/attribute-observable-test', [
    'require',
    'exports',
    'module',
    'can-reflect',
    '../test/helpers',
    'can-dom-events',
    './attribute-observable'
], function (require, exports, module) {
    var canReflect = require('can-reflect');
    var testHelpers = require('../test/helpers');
    var domEvents = require('can-dom-events');
    var AttributeObservable = require('./attribute-observable');
    testHelpers.makeTests('AttributeObservable', function (name, doc, enableMO, testIfRealDocument) {
        testIfRealDocument('onBound/onUnbound works correctly', function (assert) {
            var done = assert.async(2);
            var input = document.createElement('input');
            var ta = this.fixture;
            ta.appendChild(input);
            var obs = new AttributeObservable(input, 'value', {});
            assert.equal(canReflect.getValue(obs), '', 'correct default value');
            var handler = obs.handler;
            obs.handler = function overrideHandler() {
                handler.apply(obs, arguments);
                done();
            };
            var onValue = function onValue(newVal) {
                assert.equal(newVal, 'newVal', 'calls handlers correctly');
                done();
            };
            canReflect.onValue(obs, onValue);
            input.value = 'newVal';
            domEvents.dispatch(input, 'change');
            canReflect.offValue(obs, onValue);
            domEvents.dispatch(input, 'change');
        });
        testIfRealDocument('it listens to change event by default', function (assert) {
            var done = assert.async();
            var input = document.createElement('input');
            var ta = this.fixture;
            ta.appendChild(input);
            var obs = new AttributeObservable(input, 'value', {});
            assert.equal(canReflect.getValue(obs), '', 'correct default value');
            canReflect.onValue(obs, function (newVal) {
                assert.equal(newVal, 'newVal', 'calls handlers correctly');
                done();
            });
            input.value = 'newVal';
            domEvents.dispatch(input, 'change');
        });
        testIfRealDocument('able to read normal attributes', function (assert) {
            var div = document.createElement('div');
            div.setAttribute('foo', 'bar');
            var ta = this.fixture;
            ta.appendChild(div);
            var obs = new AttributeObservable(div, 'foo', {});
            assert.equal(canReflect.getValue(obs), 'bar', 'correct default value');
        });
    });
});
/*can-stache-bindings@4.0.5#test/tests*/
define('can-stache-bindings@4.0.5#test/tests', [
    'require',
    'exports',
    'module',
    './colon/tests',
    './data/tests',
    '../attribute-observable/attribute-observable-test'
], function (require, exports, module) {
    require('./colon/tests');
    require('./data/tests');
    require('../attribute-observable/attribute-observable-test');
});
/*can-set@1.5.1#src/helpers*/
define('can-set@1.5.1#src/helpers', [
    'require',
    'exports',
    'module',
    'can-util/js/assign/assign',
    'can-util/js/each/each',
    'can-util/js/last/last'
], function (require, exports, module) {
    var assign = require('can-util/js/assign/assign');
    var each = require('can-util/js/each/each');
    var last = require('can-util/js/last/last');
    var IgnoreType = function () {
    };
    var helpers;
    module.exports = helpers = {
        eachInUnique: function (a, acb, b, bcb, defaultReturn) {
            var bCopy = assign({}, b), res;
            for (var prop in a) {
                res = acb(a[prop], b[prop], a, b, prop);
                if (res !== undefined) {
                    return res;
                }
                delete bCopy[prop];
            }
            for (prop in bCopy) {
                res = bcb(undefined, b[prop], a, b, prop);
                if (res !== undefined) {
                    return res;
                }
            }
            return defaultReturn;
        },
        doubleLoop: function (arr, callbacks) {
            if (typeof callbacks === 'function') {
                callbacks = { iterate: callbacks };
            }
            var i = 0;
            while (i < arr.length) {
                if (callbacks.start) {
                    callbacks.start(arr[i]);
                }
                var j = i + 1;
                while (j < arr.length) {
                    if (callbacks.iterate(arr[j], j, arr[i], i) === false) {
                        arr.splice(j, 1);
                    } else {
                        j++;
                    }
                }
                if (callbacks.end) {
                    callbacks.end(arr[i]);
                }
                i++;
            }
        },
        identityMap: function (arr) {
            var map = {};
            each(arr, function (value) {
                map[value] = 1;
            });
            return map;
        },
        arrayUnionIntersectionDifference: function (arr1, arr2) {
            var map = {};
            var intersection = [];
            var union = [];
            var difference = arr1.slice(0);
            each(arr1, function (value) {
                map[value] = true;
                union.push(value);
            });
            each(arr2, function (value) {
                if (map[value]) {
                    intersection.push(value);
                    var index = helpers.indexOf.call(difference, value);
                    if (index !== -1) {
                        difference.splice(index, 1);
                    }
                } else {
                    union.push(value);
                }
            });
            return {
                intersection: intersection,
                union: union,
                difference: difference
            };
        },
        arraySame: function (arr1, arr2) {
            if (arr1.length !== arr2.length) {
                return false;
            }
            var map = helpers.identityMap(arr1);
            for (var i = 0; i < arr2.length; i++) {
                var val = map[arr2[i]];
                if (!val) {
                    return false;
                } else if (val > 1) {
                    return false;
                } else {
                    map[arr2[i]]++;
                }
            }
            return true;
        },
        indexOf: Array.prototype.indexOf || function (item) {
            for (var i = 0, thisLen = this.length; i < thisLen; i++) {
                if (this[i] === item) {
                    return i;
                }
            }
            return -1;
        },
        map: Array.prototype.map || function (cb) {
            var out = [];
            for (var i = 0, len = this.length; i < len; i++) {
                out.push(cb(this[i], i, this));
            }
            return out;
        },
        filter: Array.prototype.filter || function (cb) {
            var out = [];
            for (var i = 0, len = this.length; i < len; i++) {
                if (cb(this[i], i, this)) {
                    out.push(this[i]);
                }
            }
            return out;
        },
        ignoreType: new IgnoreType(),
        firstProp: function (set) {
            for (var prop in set) {
                return prop;
            }
        },
        index: function (compare, items, props) {
            if (!items || !items.length) {
                return undefined;
            }
            if (compare(props, items[0]) === -1) {
                return 0;
            } else if (compare(props, last(items)) === 1) {
                return items.length;
            }
            var low = 0, high = items.length;
            while (low < high) {
                var mid = low + high >>> 1, item = items[mid], computed = compare(props, item);
                if (computed === -1) {
                    high = mid;
                } else {
                    low = mid + 1;
                }
            }
            return high;
        },
        defaultSort: function (sortPropValue, item1, item2) {
            var parts = sortPropValue.split(' ');
            var sortProp = parts[0];
            var item1Value = item1[sortProp];
            var item2Value = item2[sortProp];
            var temp;
            var desc = parts[1] || '';
            desc = desc.toLowerCase() === 'desc';
            if (desc) {
                temp = item1Value;
                item1Value = item2Value;
                item2Value = temp;
            }
            if (item1Value < item2Value) {
                return -1;
            }
            if (item1Value > item2Value) {
                return 1;
            }
            return 0;
        }
    };
});
/*can-set@1.5.1#src/clause*/
define('can-set@1.5.1#src/clause', [
    'require',
    'exports',
    'module',
    'can-util/js/assign/assign',
    'can-util/js/each/each'
], function (require, exports, module) {
    var assign = require('can-util/js/assign/assign');
    var each = require('can-util/js/each/each');
    var clause = {};
    module.exports = clause;
    clause.TYPES = [
        'where',
        'order',
        'paginate',
        'id'
    ];
    each(clause.TYPES, function (type) {
        var className = type.charAt(0).toUpperCase() + type.substr(1);
        clause[className] = function (compare) {
            assign(this, compare);
        };
        clause[className].type = type;
    });
});
/*can-set@1.5.1#src/compare*/
define('can-set@1.5.1#src/compare', [
    'require',
    'exports',
    'module',
    './helpers',
    'can-util/js/assign/assign',
    'can-util/js/each/each',
    'can-util/js/make-array/make-array'
], function (require, exports, module) {
    var h = require('./helpers');
    var assign = require('can-util/js/assign/assign');
    var each = require('can-util/js/each/each');
    var makeArray = require('can-util/js/make-array/make-array');
    var compareHelpers;
    var loop = function (a, b, aParent, bParent, prop, compares, options) {
        var checks = options.checks;
        for (var i = 0; i < checks.length; i++) {
            var res = checks[i](a, b, aParent, bParent, prop, compares || {}, options);
            if (res !== undefined) {
                return res;
            }
        }
        return options['default'];
    };
    var addIntersectedPropertyToResult = function (a, b, aParent, bParent, prop, compares, options) {
        var subsetCheck;
        if (!(prop in aParent)) {
            subsetCheck = 'subsetB';
        } else if (prop in bParent) {
            return false;
        }
        if (!(prop in bParent)) {
            subsetCheck = 'subsetA';
        }
        if (subsetCheck === 'subsetB') {
            options.result[prop] = b;
        } else {
            options.result[prop] = a;
        }
        return undefined;
    };
    var addToResult = function (fn, name) {
        return function (a, b, aParent, bParent, prop, compares, options) {
            var res = fn.apply(this, arguments);
            if (res === true) {
                if (prop !== undefined && !(prop in options.result)) {
                    options.result[prop] = a;
                }
                return true;
            } else {
                return res;
            }
        };
    };
    var addResultsToNewObject = function (fn, name) {
        return function (a, b, aParent, bParent, prop, compares, options) {
            var existingResult = options.result;
            options.result = {};
            var res = fn.apply(this, arguments);
            if (res) {
                if (prop !== undefined) {
                    existingResult[prop] = options.result;
                } else {
                    assign(existingResult, options.result);
                }
            }
            options.result = existingResult;
            return res;
        };
    };
    module.exports = compareHelpers = {
        equal: function (a, b, aParent, bParent, prop, compares, options) {
            options.checks = [
                compareHelpers.equalComparesType,
                compareHelpers.equalBasicTypes,
                compareHelpers.equalArrayLike,
                compareHelpers.equalObject
            ];
            options['default'] = false;
            return loop(a, b, aParent, bParent, prop, compares, options);
        },
        equalComparesType: function (a, b, aParent, bParent, prop, compares, options) {
            if (typeof compares === 'function') {
                var compareResult = compares(a, b, aParent, bParent, prop, options);
                if (typeof compareResult === 'boolean') {
                    return compareResult;
                } else if (compareResult && typeof compareResult === 'object') {
                    if ('intersection' in compareResult && !('difference' in compareResult)) {
                        var reverseResult = compares(b, a, bParent, aParent, prop, options);
                        return 'intersection' in reverseResult && !('difference' in reverseResult);
                    }
                    return false;
                }
                return compareResult;
            }
        },
        equalBasicTypes: function (a, b, aParent, bParent, prop, compares, options) {
            if (a === null || b === null) {
                return a === b;
            }
            if (a instanceof Date && b instanceof Date) {
                return a.getTime() === b.getTime();
            }
            if (options.deep === -1) {
                return typeof a === 'object' || a === b;
            }
            if (typeof a !== typeof b || Array.isArray(a) !== Array.isArray(b)) {
                return false;
            }
            if (a === b) {
                return true;
            }
        },
        equalArrayLike: function (a, b, aParent, bParent, prop, compares, options) {
            if (Array.isArray(a) && Array.isArray(b)) {
                if (a.length !== b.length) {
                    return false;
                }
                for (var i = 0; i < a.length; i++) {
                    var compare = compares[i] === undefined ? compares['*'] : compares[i];
                    if (!loop(a[i], b[i], a, b, i, compare, options)) {
                        return false;
                    }
                }
                return true;
            }
        },
        equalObject: function (a, b, aParent, bParent, parentProp, compares, options) {
            var aType = typeof a;
            if (aType === 'object' || aType === 'function') {
                var bCopy = assign({}, b);
                if (options.deep === false) {
                    options.deep = -1;
                }
                for (var prop in a) {
                    var compare = compares[prop] === undefined ? compares['*'] : compares[prop];
                    if (!loop(a[prop], b[prop], a, b, prop, compare, options)) {
                        return false;
                    }
                    delete bCopy[prop];
                }
                for (prop in bCopy) {
                    if (compares[prop] === undefined || !loop(undefined, b[prop], a, b, prop, compares[prop], options)) {
                        return false;
                    }
                }
                return true;
            }
        },
        subset: function (a, b, aParent, bParent, prop, compares, options) {
            options.checks = [
                compareHelpers.subsetComparesType,
                compareHelpers.equalBasicTypes,
                compareHelpers.equalArrayLike,
                compareHelpers.subsetObject
            ];
            options.getSubsets = [];
            options['default'] = false;
            return loop(a, b, aParent, bParent, prop, compares, options);
        },
        subsetObject: function (a, b, aParent, bParent, parentProp, compares, options) {
            var aType = typeof a;
            if (aType === 'object' || aType === 'function') {
                return h.eachInUnique(a, function (a, b, aParent, bParent, prop) {
                    var compare = compares[prop] === undefined ? compares['*'] : compares[prop];
                    if (!loop(a, b, aParent, bParent, prop, compare, options) && prop in bParent) {
                        return false;
                    }
                }, b, function (a, b, aParent, bParent, prop) {
                    var compare = compares[prop] === undefined ? compares['*'] : compares[prop];
                    if (!loop(a, b, aParent, bParent, prop, compare, options)) {
                        return false;
                    }
                }, true);
            }
        },
        subsetComparesType: function (a, b, aParent, bParent, prop, compares, options) {
            if (typeof compares === 'function') {
                var compareResult = compares(a, b, aParent, bParent, prop, options);
                if (typeof compareResult === 'boolean') {
                    return compareResult;
                } else if (compareResult && typeof compareResult === 'object') {
                    if (compareResult.getSubset) {
                        if (h.indexOf.call(options.getSubsets, compareResult.getSubset) === -1) {
                            options.getSubsets.push(compareResult.getSubset);
                        }
                    }
                    if (compareResult.intersection === h.ignoreType || compareResult.difference === h.ignoreType) {
                        return true;
                    }
                    if ('intersection' in compareResult && !('difference' in compareResult)) {
                        var reverseResult = compares(b, a, bParent, aParent, prop, options);
                        return 'intersection' in reverseResult;
                    }
                    return false;
                }
                return compareResult;
            }
        },
        properSupersetObject: function (a, b, aParent, bParent, parentProp, compares, options) {
            var bType = typeof b;
            var hasAdditionalProp = false;
            if (bType === 'object' || bType === 'function') {
                var aCopy = assign({}, a);
                if (options.deep === false) {
                    options.deep = -1;
                }
                for (var prop in b) {
                    var compare = compares[prop] === undefined ? compares['*'] : compares[prop];
                    var compareResult = loop(a[prop], b[prop], a, b, prop, compare, options);
                    if (compareResult === h.ignoreType) {
                    } else if (!(prop in a) || options.performedDifference) {
                        hasAdditionalProp = true;
                    } else if (!compareResult) {
                        return false;
                    }
                    delete aCopy[prop];
                }
                for (prop in aCopy) {
                    if (compares[prop] === undefined || !loop(a[prop], undefined, a, b, prop, compares[prop], options)) {
                        return false;
                    }
                }
                return hasAdditionalProp;
            }
        },
        properSubsetComparesType: function (a, b, aParent, bParent, prop, compares, options) {
            if (typeof compares === 'function') {
                var compareResult = compares(a, b, aParent, bParent, prop, options);
                if (typeof compareResult === 'boolean') {
                    return compareResult;
                } else if (compareResult && typeof compareResult === 'object') {
                    if ('intersection' in compareResult && !('difference' in compareResult)) {
                        var reverseResult = compares(b, a, bParent, aParent, prop, options);
                        return 'intersection' in reverseResult && 'difference' in reverseResult;
                    }
                    return false;
                }
                return compareResult;
            }
        },
        difference: function (a, b, aParent, bParent, prop, compares, options) {
            options.result = {};
            options.performedDifference = 0;
            options.checks = [
                compareHelpers.differenceComparesType,
                addToResult(compareHelpers.equalBasicTypes, 'equalBasicTypes'),
                addToResult(compareHelpers.equalArrayLike, 'equalArrayLike'),
                addToResult(compareHelpers.properSupersetObject, 'properSubsetObject')
            ];
            options['default'] = true;
            var res = loop(a, b, aParent, bParent, prop, compares, options);
            if (res === true && options.performedDifference) {
                return options.result;
            }
            return res;
        },
        differenceComparesType: function (a, b, aParent, bParent, prop, compares, options) {
            if (typeof compares === 'function') {
                var compareResult = compares(a, b, aParent, bParent, prop, options);
                if (typeof compareResult === 'boolean') {
                    if (compareResult === true) {
                        options.result[prop] = a;
                        return true;
                    } else {
                        return compareResult;
                    }
                } else if (compareResult && typeof compareResult === 'object') {
                    if ('difference' in compareResult) {
                        if (compareResult.difference === h.ignoreType) {
                            return h.ignoreType;
                        } else if (compareResult.difference != null) {
                            options.result[prop] = compareResult.difference;
                            options.performedDifference++;
                            return true;
                        } else {
                            return true;
                        }
                    } else {
                        if (compareHelpers.equalComparesType.apply(this, arguments)) {
                            options.performedDifference++;
                            options.result[prop] = compareResult.union;
                        } else {
                            return false;
                        }
                    }
                }
            }
        },
        union: function (a, b, aParent, bParent, prop, compares, options) {
            options.result = {};
            options.performedUnion = 0;
            options.checks = [
                compareHelpers.unionComparesType,
                addToResult(compareHelpers.equalBasicTypes, 'equalBasicTypes'),
                addToResult(compareHelpers.unionArrayLike, 'unionArrayLike'),
                addResultsToNewObject(compareHelpers.unionObject, 'unionObject')
            ];
            options.getUnions = [];
            options['default'] = false;
            var res = loop(a, b, aParent, bParent, prop, compares, options);
            if (res === true) {
                return options.result;
            }
            return false;
        },
        unionComparesType: function (a, b, aParent, bParent, prop, compares, options) {
            if (typeof compares === 'function') {
                var compareResult = compares(a, b, aParent, bParent, prop, options);
                if (typeof compareResult === 'boolean') {
                    if (compareResult === true) {
                        options.result[prop] = a;
                        return true;
                    } else {
                        return compareResult;
                    }
                } else if (compareResult && typeof compareResult === 'object') {
                    if (compareResult.getUnion) {
                        if (h.indexOf.call(options.getUnions, compareResult.getUnion) === -1) {
                            options.getUnions.push(compareResult.getUnion);
                        }
                    }
                    if ('union' in compareResult) {
                        if (compareResult.union === h.ignoreType) {
                            return compareResult.union;
                        }
                        if (compareResult.union !== undefined) {
                            options.result[prop] = compareResult.union;
                        }
                        options.performedUnion++;
                        return true;
                    }
                }
            }
        },
        unionObject: function (a, b, aParent, bParent, prop, compares, options) {
            var subsetCompare = function (a, b, aParent, bParent, prop) {
                var compare = compares[prop] === undefined ? compares['*'] : compares[prop];
                if (!loop(a, b, aParent, bParent, prop, compare, options)) {
                    var subsetCheck;
                    if (!(prop in aParent)) {
                        subsetCheck = 'subsetB';
                    }
                    if (!(prop in bParent)) {
                        subsetCheck = 'subsetA';
                    }
                    if (subsetCheck) {
                        if (!options.subset) {
                            options.subset = subsetCheck;
                        }
                        return options.subset === subsetCheck ? undefined : false;
                    }
                    return false;
                }
            };
            var aType = typeof a;
            if (aType === 'object' || aType === 'function') {
                return h.eachInUnique(a, subsetCompare, b, subsetCompare, true);
            }
        },
        unionArrayLike: function (a, b, aParent, bParent, prop, compares, options) {
            if (Array.isArray(a) && Array.isArray(b)) {
                var combined = makeArray(a).concat(makeArray(b));
                h.doubleLoop(combined, function (item, j, cur, i) {
                    var res = !compareHelpers.equal(cur, item, aParent, bParent, undefined, compares['*'], { 'default': false });
                    return res;
                });
                options.result[prop] = combined;
                return true;
            }
        },
        count: function (a, b, aParent, bParent, prop, compares, options) {
            options.checks = [
                compareHelpers.countComparesType,
                compareHelpers.equalBasicTypes,
                compareHelpers.equalArrayLike,
                compareHelpers.loopObject
            ];
            options['default'] = false;
            loop(a, b, aParent, bParent, prop, compares, options);
            if (typeof options.count === 'number') {
                return options.count;
            }
            return Infinity;
        },
        countComparesType: function (a, b, aParent, bParent, prop, compares, options) {
            if (typeof compares === 'function') {
                var compareResult = compares(a, b, aParent, bParent, prop, options);
                if (typeof compareResult === 'boolean') {
                    return true;
                } else if (compareResult && typeof compareResult === 'object') {
                    if (typeof compareResult.count === 'number') {
                        if (!('count' in options) || compareResult.count === options.count) {
                            options.count = compareResult.count;
                        } else {
                            options.count = Infinity;
                        }
                    }
                    return true;
                }
            }
        },
        loopObject: function (a, b, aParent, bParent, prop, compares, options) {
            var aType = typeof a;
            if (aType === 'object' || aType === 'function') {
                each(a, function (aValue, prop) {
                    var compare = compares[prop] === undefined ? compares['*'] : compares[prop];
                    loop(aValue, b[prop], a, b, prop, compare, options);
                });
                return true;
            }
        },
        intersection: function (a, b, aParent, bParent, prop, compares, options) {
            options.result = {};
            options.performedIntersection = 0;
            options.checks = [
                compareHelpers.intersectionComparesType,
                addToResult(compareHelpers.equalBasicTypes, 'equalBasicTypes'),
                addToResult(compareHelpers.intersectionArrayLike, 'intersectionArrayLike'),
                addResultsToNewObject(compareHelpers.intersectionObject)
            ];
            options['default'] = false;
            var res = loop(a, b, aParent, bParent, prop, compares, options);
            if (res === true) {
                return options.result;
            }
            return false;
        },
        intersectionComparesType: function (a, b, aParent, bParent, prop, compares, options) {
            if (typeof compares === 'function') {
                var compareResult = compares(a, b, aParent, bParent, prop, options);
                if (typeof compareResult === 'boolean') {
                    if (compareResult === true) {
                        options.result[prop] = a;
                        return true;
                    } else {
                        return compareResult;
                    }
                } else if (compareResult && typeof compareResult === 'object') {
                    if ('intersection' in compareResult) {
                        if (compareResult.intersection !== undefined) {
                            options.result[prop] = compareResult.intersection;
                        }
                        options.performedIntersection++;
                        return true;
                    }
                }
            }
        },
        intersectionObject: function (a, b, aParent, bParent, prop, compares, options) {
            var subsetCompare = function (a, b, aParent, bParent, prop) {
                var compare = compares[prop] === undefined ? compares['*'] : compares[prop];
                if (!loop(a, b, aParent, bParent, prop, compare, options)) {
                    return addIntersectedPropertyToResult(a, b, aParent, bParent, prop, compares, options);
                }
            };
            var aType = typeof a;
            if (aType === 'object' || aType === 'function') {
                return h.eachInUnique(a, subsetCompare, b, subsetCompare, true);
            }
        },
        intersectionArrayLike: function (a, b, aParent, bParent, prop, compares, options) {
            if (Array.isArray(a) && Array.isArray(b)) {
                var intersection = [];
                each(makeArray(a), function (cur) {
                    for (var i = 0; i < b.length; i++) {
                        if (compareHelpers.equal(cur, b[i], aParent, bParent, undefined, compares['*'], { 'default': false })) {
                            intersection.push(cur);
                            break;
                        }
                    }
                });
                options.result[prop] = intersection;
                return true;
            }
        }
    };
});
/*can-set@1.5.1#src/get*/
define('can-set@1.5.1#src/get', [
    'require',
    'exports',
    'module',
    './compare',
    './helpers',
    'can-util/js/each/each'
], function (require, exports, module) {
    var compare = require('./compare');
    var h = require('./helpers');
    var each = require('can-util/js/each/each');
    var filterData = function (data, clause, props) {
        return h.filter.call(data, function (item) {
            var isSubset = compare.subset(item, clause, undefined, undefined, undefined, props, {});
            return isSubset;
        });
    };
    module.exports = {
        subsetData: function (a, b, bData, algebra) {
            var aClauseProps = algebra.getClauseProperties(a);
            var bClauseProps = algebra.getClauseProperties(b);
            var options = {};
            var aData = filterData(bData, aClauseProps.where, algebra.clauses.where);
            if (aData.length && (aClauseProps.enabled.order || bClauseProps.enabled.order)) {
                options = {};
                var propName = h.firstProp(aClauseProps.order), compareOrder = algebra.clauses.order[propName];
                aData = aData.sort(function (aItem, bItem) {
                    return compareOrder(a[propName], aItem, bItem);
                });
            }
            if (aData.length && (aClauseProps.enabled.paginate || bClauseProps.enabled.paginate)) {
                options = {};
                compare.subset(aClauseProps.paginate, bClauseProps.paginate, undefined, undefined, undefined, algebra.clauses.paginate, options);
                each(options.getSubsets, function (filter) {
                    aData = filter(a, b, aData, algebra, options);
                });
            }
            return aData;
        }
    };
});
/*can-set@1.5.1#src/set-core*/
define('can-set@1.5.1#src/set-core', [
    'require',
    'exports',
    'module',
    './helpers',
    './clause',
    './compare',
    './get',
    'can-assign',
    'can-util/js/each/each',
    'can-util/js/make-array/make-array',
    'can-util/js/is-empty-object/is-empty-object',
    'can-util/js/get/get'
], function (require, exports, module) {
    var h = require('./helpers');
    var clause = require('./clause');
    var compare = require('./compare');
    var get = require('./get');
    var assign = require('can-assign');
    var each = require('can-util/js/each/each');
    var makeArray = require('can-util/js/make-array/make-array');
    var isEmptyObject = require('can-util/js/is-empty-object/is-empty-object');
    var getProp = require('can-util/js/get/get');
    function concatUnique(aItems, bItems, algebra) {
        var idTree = {};
        var aSet;
        if (typeof Set !== 'undefined') {
            aSet = new Set();
        }
        aItems.forEach(function (item) {
            var keyNode = idTree;
            if (aSet) {
                aSet.add(item);
            }
            each(algebra.clauses.id, function (prop) {
                var propVal = getProp(item, prop);
                if (keyNode && typeof propVal !== 'undefined') {
                    keyNode = keyNode[propVal] = keyNode[propVal] || {};
                } else {
                    keyNode = undefined;
                }
            });
        });
        return aItems.concat(bItems.filter(function (item) {
            var keyNode = idTree;
            if (aSet && aSet.has(item)) {
                return false;
            }
            if (!aSet && aItems.indexOf(item) > -1) {
                return false;
            }
            each(algebra.clauses.id, function (prop) {
                keyNode = keyNode && keyNode[getProp(item, prop)];
            });
            return keyNode === idTree || !keyNode;
        }));
    }
    function Translate(clause, options) {
        if (typeof options === 'string') {
            var path = options;
            options = {
                fromSet: function (set, setRemainder) {
                    return set[path] || {};
                },
                toSet: function (set, wheres) {
                    set[path] = wheres;
                    return set;
                }
            };
        }
        this.clause = clause;
        assign(this, options);
    }
    var Algebra = function () {
        var clauses = this.clauses = {
            where: {},
            order: {},
            paginate: {},
            id: {}
        };
        this.translators = {
            where: new Translate('where', {
                fromSet: function (set, setRemainder) {
                    return setRemainder;
                },
                toSet: function (set, wheres) {
                    return assign(set, wheres);
                }
            })
        };
        var self = this;
        each(arguments, function (arg) {
            if (arg) {
                if (arg instanceof Translate) {
                    self.translators[arg.clause] = arg;
                } else {
                    assign(clauses[arg.constructor.type || 'where'], arg);
                }
            }
        });
    };
    Algebra.make = function (compare, count) {
        if (compare instanceof Algebra) {
            return compare;
        } else {
            return new Algebra(compare, count);
        }
    };
    assign(Algebra.prototype, {
        getClauseProperties: function (set, options) {
            options = options || {};
            var setClone = assign({}, set);
            var clauses = this.clauses;
            var checkClauses = [
                'order',
                'paginate',
                'id'
            ];
            var clauseProps = {
                enabled: {
                    where: true,
                    order: false,
                    paginate: false,
                    id: false
                }
            };
            if (options.omitClauses) {
                checkClauses = h.arrayUnionIntersectionDifference(checkClauses, options.omitClauses).difference;
            }
            each(checkClauses, function (clauseName) {
                var valuesForClause = {};
                var prop;
                for (prop in clauses[clauseName]) {
                    if (prop in setClone) {
                        valuesForClause[prop] = setClone[prop];
                        if (clauseName !== 'id') {
                            delete setClone[prop];
                        }
                    }
                }
                clauseProps[clauseName] = valuesForClause;
                clauseProps.enabled[clauseName] = !isEmptyObject(valuesForClause);
            });
            clauseProps.where = options.isProperties ? setClone : this.translators.where.fromSet(set, setClone);
            return clauseProps;
        },
        getDifferentClauseTypes: function (aClauses, bClauses) {
            var self = this;
            var differentTypes = [];
            each(clause.TYPES, function (type) {
                if (!self.evaluateOperator(compare.equal, aClauses[type], bClauses[type], { isProperties: true }, { isProperties: true })) {
                    differentTypes.push(type);
                }
            });
            return differentTypes;
        },
        updateSet: function (set, clause, result, useSet) {
            if (result && typeof result === 'object' && useSet !== false) {
                if (this.translators[clause]) {
                    set = this.translators.where.toSet(set, result);
                } else {
                    set = assign(set, result);
                }
                return true;
            } else if (result) {
                return useSet === undefined ? undefined : false;
            } else {
                return false;
            }
        },
        evaluateOperator: function (operator, a, b, aOptions, bOptions, evaluateOptions) {
            aOptions = aOptions || {};
            bOptions = bOptions || {};
            evaluateOptions = assign({
                evaluateWhere: operator,
                evaluatePaginate: operator,
                evaluateOrder: operator,
                shouldEvaluatePaginate: function (aClauseProps, bClauseProps) {
                    return aClauseProps.enabled.paginate || bClauseProps.enabled.paginate;
                },
                shouldEvaluateOrder: function (aClauseProps, bClauseProps) {
                    return aClauseProps.enabled.order && compare.equal(aClauseProps.order, bClauseProps.order, undefined, undefined, undefined, {}, {});
                }
            }, evaluateOptions || {});
            var aClauseProps = this.getClauseProperties(a, aOptions), bClauseProps = this.getClauseProperties(b, bOptions), set = {}, useSet;
            var result = evaluateOptions.evaluateWhere(aClauseProps.where, bClauseProps.where, undefined, undefined, undefined, this.clauses.where, {});
            useSet = this.updateSet(set, 'where', result, useSet);
            if (result && evaluateOptions.shouldEvaluatePaginate(aClauseProps, bClauseProps)) {
                if (evaluateOptions.shouldEvaluateOrder(aClauseProps, bClauseProps)) {
                    result = evaluateOptions.evaluateOrder(aClauseProps.order, bClauseProps.order, undefined, undefined, undefined, {}, {});
                    useSet = this.updateSet(set, 'order', result, useSet);
                }
                if (result) {
                    result = evaluateOptions.evaluatePaginate(aClauseProps.paginate, bClauseProps.paginate, undefined, undefined, undefined, this.clauses.paginate, {});
                    useSet = this.updateSet(set, 'paginate', result, useSet);
                }
            } else if (result && evaluateOptions.shouldEvaluateOrder(aClauseProps, bClauseProps)) {
                result = operator(aClauseProps.order, bClauseProps.order, undefined, undefined, undefined, {}, {});
                useSet = this.updateSet(set, 'order', result, useSet);
            }
            return result && useSet ? set : result;
        },
        equal: function (a, b) {
            return this.evaluateOperator(compare.equal, a, b);
        },
        subset: function (a, b) {
            var aClauseProps = this.getClauseProperties(a);
            var bClauseProps = this.getClauseProperties(b);
            var compatibleSort = true;
            var result;
            if (bClauseProps.enabled.paginate && (aClauseProps.enabled.order || bClauseProps.enabled.order)) {
                compatibleSort = compare.equal(aClauseProps.order, bClauseProps.order, undefined, undefined, undefined, {}, {});
            }
            if (!compatibleSort) {
                result = false;
            } else {
                result = this.evaluateOperator(compare.subset, a, b);
            }
            return result;
        },
        properSubset: function (a, b) {
            return this.subset(a, b) && !this.equal(a, b);
        },
        difference: function (a, b) {
            var aClauseProps = this.getClauseProperties(a);
            var bClauseProps = this.getClauseProperties(b);
            var differentClauses = this.getDifferentClauseTypes(aClauseProps, bClauseProps);
            var clause, result;
            if (differentClauses.length > 2) {
                result = false;
            } else if (differentClauses.length === 2 && (differentClauses[0] !== 'where' || differentClauses[1] !== 'id')) {
                result = false;
            } else {
                switch (clause = differentClauses[0]) {
                case undefined:
                case 'order': {
                        result = false;
                        break;
                    }
                case 'paginate':
                case 'where': {
                        result = compare.difference(aClauseProps[clause], bClauseProps[clause], undefined, undefined, undefined, this.clauses[clause], {});
                        if (typeof result === 'object') {
                            if (this.translators[clause]) {
                                result = this.translators[clause].toSet({}, result);
                            }
                            assign(result, aClauseProps.order);
                            if (clause === 'paginate') {
                                assign(result, aClauseProps.where);
                            } else if (differentClauses[1] === 'id') {
                                result = compare.difference(aClauseProps.id, bClauseProps.id, undefined, undefined, undefined, this.clauses.id, {});
                            }
                        }
                        break;
                    }
                }
            }
            return result;
        },
        union: function (a, b) {
            return this.evaluateOperator(compare.union, a, b);
        },
        intersection: function (a, b) {
            return this.evaluateOperator(compare.intersection, a, b);
        },
        count: function (set) {
            return this.evaluateOperator(compare.count, set, {});
        },
        has: function (set, props) {
            var result = this.evaluateOperator(compare.subset, props, set, { isProperties: true }, undefined, {
                shouldEvaluatePaginate: function () {
                    return false;
                }
            });
            return result;
        },
        index: function (set, items, item) {
            var aClauseProps = this.getClauseProperties(set);
            var propName = h.firstProp(aClauseProps.order), compare, orderValue;
            if (propName) {
                compare = this.clauses.order[propName];
                orderValue = set[propName];
                return h.index(function (itemA, itemB) {
                    return compare(orderValue, itemA, itemB);
                }, items, item);
            }
            propName = h.firstProp(this.clauses.id);
            if (propName) {
                compare = h.defaultSort;
                orderValue = propName;
                return h.index(function (itemA, itemB) {
                    return compare(orderValue, itemA, itemB);
                }, items, item);
            }
            return;
        },
        getSubset: function (a, b, bData) {
            var aClauseProps = this.getClauseProperties(a);
            var bClauseProps = this.getClauseProperties(b);
            var isSubset = this.subset(assign({}, aClauseProps.where, aClauseProps.paginate), assign({}, bClauseProps.where, bClauseProps.paginate));
            if (isSubset) {
                return get.subsetData(a, b, bData, this);
            }
        },
        getUnion: function (a, b, aItems, bItems) {
            var aClauseProps = this.getClauseProperties(a);
            var bClauseProps = this.getClauseProperties(b);
            var algebra = this;
            var options;
            if (this.subset(a, b)) {
                return bItems;
            } else if (this.subset(b, a)) {
                return aItems;
            }
            var combined;
            if (aClauseProps.enabled.paginate || bClauseProps.enabled.paginate) {
                options = {};
                var isUnion = compare.union(aClauseProps.paginate, bClauseProps.paginate, undefined, undefined, undefined, this.clauses.paginate, options);
                if (!isUnion) {
                    return;
                } else {
                    each(options.getUnions, function (filter) {
                        var items = filter(a, b, aItems, bItems, algebra, options);
                        aItems = items[0];
                        bItems = items[1];
                    });
                    combined = concatUnique(aItems, bItems, this);
                }
            } else {
                combined = concatUnique(aItems, bItems, this);
            }
            if (combined.length && aClauseProps.enabled.order && compare.equal(aClauseProps.order, bClauseProps.order, undefined, undefined, undefined, {}, {})) {
                options = {};
                var propName = h.firstProp(aClauseProps.order), compareOrder = algebra.clauses.order[propName];
                combined = combined.sort(function (aItem, bItem) {
                    return compareOrder(a[propName], aItem, bItem);
                });
            }
            return combined;
        },
        id: function (props) {
            var keys = Object.keys(this.clauses.id);
            if (keys.length === 1) {
                return props[keys[0]];
            } else {
                var id = {};
                keys.forEach(function (key) {
                    id[key] = props[key];
                });
                return JSON.stringify(id);
            }
        }
    });
    var callOnAlgebra = function (methodName, algebraArgNumber) {
        return function () {
            var args = makeArray(arguments).slice(0, algebraArgNumber);
            var algebra = Algebra.make(arguments[algebraArgNumber]);
            return algebra[methodName].apply(algebra, args);
        };
    };
    module.exports = {
        Algebra: Algebra,
        Translate: Translate,
        difference: callOnAlgebra('difference', 2),
        equal: callOnAlgebra('equal', 2),
        subset: callOnAlgebra('subset', 2),
        properSubset: callOnAlgebra('properSubset', 2),
        union: callOnAlgebra('union', 2),
        intersection: callOnAlgebra('intersection', 2),
        count: callOnAlgebra('count', 1),
        has: callOnAlgebra('has', 2),
        index: callOnAlgebra('index', 3),
        getSubset: callOnAlgebra('getSubset', 3),
        getUnion: callOnAlgebra('getUnion', 4)
    };
});
/*can-set@1.5.1#src/set-core_test*/
define('can-set@1.5.1#src/set-core_test', [
    'require',
    'exports',
    'module',
    'steal-qunit',
    './set-core'
], function (require, exports, module) {
    require('steal-qunit');
    var set = require('./set-core');
    var ignoreProp = function () {
        return true;
    };
    QUnit.module('can-set core');
    test('set.equal', function () {
        var res, now;
        res = set.equal({ type: 'FOLDER' }, {
            type: 'FOLDER',
            count: 5
        }, { count: ignoreProp });
        ok(res, 'count ignored');
        res = set.equal({ type: 'folder' }, { type: 'FOLDER' }, {
            type: function (a, b) {
                return ('' + a).toLowerCase() === ('' + b).toLowerCase();
            }
        });
        ok(res, 'folder case ignored');
        res = set.equal({ foo: null }, { foo: new Date() });
        ok(!res, 'nulls and Dates are not considered the same. (#773)');
        res = set.equal({ foo: null }, { foo: {} });
        ok(!res, 'nulls and empty objects are not considered the same. (#773)');
        now = new Date();
        res = set.equal({ foo: now }, { foo: new Date(now.getTime()) });
        ok(res, 'date objects with same time values are considered the same. (#35)');
    });
    test('set.subset', function () {
        var res;
        res = set.subset({ type: 'FOLDER' }, { type: 'FOLDER' });
        ok(res, 'equal sets');
        res = set.subset({
            type: 'FOLDER',
            parentId: 5
        }, { type: 'FOLDER' });
        ok(res, 'sub set');
        res = set.subset({ type: 'FOLDER' }, {
            type: 'FOLDER',
            parentId: 5
        });
        ok(!res, 'wrong way');
        res = set.subset({
            type: 'FOLDER',
            parentId: 7
        }, {
            type: 'FOLDER',
            parentId: 5
        });
        ok(!res, 'different values');
        res = set.subset({
            type: 'FOLDER',
            count: 5
        }, { type: 'FOLDER' }, { count: ignoreProp });
        ok(res, 'count ignored');
        res = set.subset({
            type: 'FOLDER',
            kind: 'tree'
        }, {
            type: 'FOLDER',
            foo: true,
            bar: true
        }, {
            foo: ignoreProp,
            bar: ignoreProp
        });
        ok(res, 'understands a subset');
        res = set.subset({
            type: 'FOLDER',
            foo: true,
            bar: true
        }, {
            type: 'FOLDER',
            kind: 'tree'
        }, {
            foo: ignoreProp,
            bar: ignoreProp,
            kind: ignoreProp
        });
        ok(res, 'ignores nulls');
    });
    test('set.properSubset', function () {
        equal(set.properSubset({ foo: 'bar' }, {}), true);
        equal(set.properSubset({}, {}), false);
        equal(set.properSubset({}, { foo: 'bar' }), false);
    });
    test('set.difference', function () {
        var res = set.difference({}, { completed: true });
        ok(res === true, 'diff should be true');
        res = set.difference({ completed: true }, { completed: true });
        equal(res, false);
        res = set.difference({ completed: true }, {});
        equal(res, false);
        res = set.difference({ completed: true }, { userId: 5 });
        equal(res, false);
    });
    test('set.difference({ function })', function () {
        var res = set.difference({
            colors: [
                'red',
                'blue'
            ]
        }, { colors: ['blue'] }, {
            colors: function () {
                return {
                    difference: ['red'],
                    intersection: ['blue']
                };
            }
        });
        deepEqual(res, { colors: ['red'] });
    });
    test('set.union', function () {
        var res = set.union({}, { completed: true });
        deepEqual(res, {}, 'set / subset');
        res = set.union({ completed: true }, {});
        deepEqual(res, {}, 'subset / set');
        res = set.union({ foo: 'bar' }, { foo: 'bar' });
        deepEqual(res, { foo: 'bar' }, 'equal');
        res = set.union({ foo: 'bar' }, { foo: 'zed' });
        ok(!res, 'values not equal');
        res = set.union({ foo: 'bar' }, { name: 'A' });
        ok(!res, 'values not equal');
        res = set.union({
            sort: {
                name: {
                    first: 'Rick',
                    last: 'Flair'
                },
                type: 'split'
            }
        }, {
            sort: {
                name: {
                    first: 'Rick',
                    last: 'Flair'
                },
                type: 'split'
            }
        });
        deepEqual(res, {
            sort: {
                name: {
                    first: 'Rick',
                    last: 'Flair'
                },
                type: 'split'
            }
        }, 'correctly unifies nested objects');
    });
    test('set.union Array', function () {
        var res = set.union({
            foo: [
                'a',
                'b'
            ]
        }, {
            foo: [
                'a',
                'c'
            ]
        });
        deepEqual(res, {
            foo: [
                'a',
                'b',
                'c'
            ]
        }, 'set / subset');
    });
    test('set.count', function () {
        ok(set.count({}) === Infinity, 'defaults to infinity');
        ok(set.count({ foo: 'bar' }, {}) === Infinity, 'defaults to infinity');
        equal(set.count({ foo: 'bar' }, {
            foo: function () {
                return { count: 100 };
            }
        }), 100, 'works with a single value');
    });
    test('set.intersection', function () {
        var res = set.intersection({}, { completed: true });
        deepEqual(res, { completed: true }, 'set / subset');
        res = set.intersection({ completed: true }, {});
        deepEqual(res, { completed: true }, 'subset / set');
        res = set.intersection({ foo: 'bar' }, { foo: 'bar' });
        deepEqual(res, { foo: 'bar' }, 'equal');
        res = set.intersection({ foo: 'bar' }, { foo: 'zed' });
        ok(!res, 'values not equal');
        res = set.intersection({ foo: 'bar' }, { completed: true });
        deepEqual(res, {
            foo: 'bar',
            completed: true
        }, 'intersection should combine definitions');
        res = set.intersection({
            name: {
                title: 'Ravishing',
                last: 'Rude'
            },
            type: 'split'
        }, { name: { first: 'Rick' } });
        deepEqual(res, {
            name: {
                title: 'Ravishing',
                first: 'Rick',
                last: 'Rude'
            },
            type: 'split'
        }, 'intersects nested objects');
    });
    test('set.intersection Array', function () {
        var res = set.intersection({
            foo: [
                'a',
                'b'
            ]
        }, {
            foo: [
                'a',
                'c'
            ]
        });
        deepEqual(res, { foo: ['a'] }, 'intersection');
    });
    test('set.has', function () {
        var res;
        res = set.has({ type: 'FOLDER' }, { type: 'FOLDER' });
        ok(res, 'equal sets');
        res = set.has({ type: 'FOLDER' }, {
            type: 'FOLDER',
            parentId: 5
        });
        ok(res, 'sub set');
        res = set.has({
            type: 'FOLDER',
            parentId: 5
        }, { type: 'FOLDER' });
        ok(!res, 'wrong way');
        res = set.has({
            type: 'FOLDER',
            parentId: 7
        }, {
            type: 'FOLDER',
            parentId: 5
        });
        ok(!res, 'different values');
        res = set.has({ type: 'FOLDER' }, {
            type: 'FOLDER',
            count: 5
        }, { count: ignoreProp });
        ok(res, 'count ignored');
        res = set.has({
            type: 'FOLDER',
            foo: true,
            bar: true
        }, {
            type: 'FOLDER',
            kind: 'tree'
        }, {
            foo: ignoreProp,
            bar: ignoreProp
        });
        ok(res, 'understands a subset');
        res = set.has({
            type: 'FOLDER',
            kind: 'tree'
        }, {
            type: 'FOLDER',
            foo: true,
            bar: true
        }, {
            foo: ignoreProp,
            bar: ignoreProp,
            kind: ignoreProp
        });
        ok(res, 'ignores nulls');
        var algebra = new set.Algebra(set.props.id('invoice_number'), set.props.id('product_code'));
        res = algebra.has({ invoice_number: 5 }, {
            invoice_number: 6,
            product_code: 10,
            product_name: 'Soap'
        });
        ok(res === false, 'understands compound ids subset exclusion');
        res = algebra.has({ invoice_number: 5 }, {
            invoice_number: 5,
            product_code: 10,
            product_name: 'Soap'
        });
        ok(res, 'understands compound id subset inclusion');
    });
    test('set.index', function () {
        var index = set.index({ sort: 'name' }, [
            {
                id: 1,
                name: 'g'
            },
            {
                id: 2,
                name: 'j'
            },
            {
                id: 3,
                name: 'm'
            },
            {
                id: 4,
                name: 's'
            }
        ], { name: 'k' });
        equal(index, undefined, 'no value if nothing is set');
        var algebra = new set.Algebra(set.props.id('id'));
        index = algebra.index({ sort: 'name' }, [
            {
                id: 1,
                name: 'g'
            },
            {
                id: 2,
                name: 'j'
            },
            {
                id: 3,
                name: 'm'
            },
            {
                id: 4,
                name: 's'
            }
        ], {
            id: 0,
            name: 'k'
        });
        equal(index, 0);
    });
    test('algebra.id', function () {
        var algebra = new set.Algebra(set.props.id('_id'));
        QUnit.equal(algebra.id({ _id: 5 }), 5, 'only one id, returns value');
        algebra = new set.Algebra(set.props.id('studentId'), set.props.id('classId'));
        QUnit.equal(algebra.id({
            studentId: 6,
            classId: '7',
            foo: 'bar'
        }), JSON.stringify({
            studentId: 6,
            classId: '7'
        }), 'only one id, returns set as JSON');
    });
    test('set.has algebra with pagination', function () {
        var algebra = new set.Algebra(set.props.offsetLimit('$skip', '$limit'));
        var setA = {
            $limit: 5,
            $skip: 0
        };
        var props = { name: 'My Portfolio' };
        ok(algebra.has(setA, props));
    });
});
/*can-set@1.5.1#src/set-core-nested_test*/
define('can-set@1.5.1#src/set-core-nested_test', [
    'require',
    'exports',
    'module',
    'steal-qunit',
    './set-core'
], function (require, exports, module) {
    QUnit.module('can/set core - nested');
    require('steal-qunit');
    var set = require('./set-core');
    var ignoreProp = function () {
        return true;
    };
    QUnit.module('can-set core - nested where');
    test('set.equal', function () {
        var algebra = new set.Algebra(new set.Translate('where', '$where'), {
            count: ignoreProp,
            type: function (a, b) {
                return ('' + a).toLowerCase() === ('' + b).toLowerCase();
            }
        });
        var res;
        res = algebra.equal({ $where: { type: 'FOLDER' } }, {
            $where: {
                type: 'FOLDER',
                count: 5
            }
        });
        ok(res, 'count ignored');
        res = algebra.equal({ $where: { type: 'folder' } }, { $where: { type: 'FOLDER' } });
        ok(res, 'folder case ignored');
    });
    test('set.subset', function () {
        var algebra = new set.Algebra(new set.Translate('where', '$where'), {
            count: ignoreProp,
            type: function (a, b) {
                return ('' + a).toLowerCase() === ('' + b).toLowerCase();
            },
            foo: ignoreProp,
            bar: ignoreProp,
            kind: ignoreProp
        });
        var res;
        res = algebra.subset({ $where: { type: 'FOLDER' } }, { $where: { type: 'FOLDER' } });
        ok(res, 'equal sets');
        res = algebra.subset({
            $where: {
                type: 'FOLDER',
                parentId: 5
            }
        }, { $where: { type: 'FOLDER' } });
        ok(res, 'sub set');
        res = algebra.subset({ $where: { type: 'FOLDER' } }, {
            $where: {
                type: 'FOLDER',
                parentId: 5
            }
        });
        ok(!res, 'wrong way');
        res = algebra.subset({
            $where: {
                type: 'FOLDER',
                parentId: 7
            }
        }, {
            $where: {
                type: 'FOLDER',
                parentId: 5
            }
        });
        ok(!res, 'different values');
        res = algebra.subset({
            $where: {
                type: 'FOLDER',
                count: 5
            }
        }, { $where: { type: 'FOLDER' } });
        ok(res, 'count ignored');
        res = algebra.subset({
            $where: {
                type: 'FOLDER',
                category: 'tree'
            }
        }, {
            $where: {
                type: 'FOLDER',
                foo: true,
                bar: true
            }
        });
        ok(res, 'understands a subset');
        res = algebra.subset({
            $where: {
                type: 'FOLDER',
                foo: true,
                bar: true
            }
        }, {
            $where: {
                type: 'FOLDER',
                kind: 'tree'
            }
        });
        ok(res, 'ignores nulls');
    });
    test('set.properSubset', function () {
        var algebra = new set.Algebra(new set.Translate('where', '$where'));
        equal(algebra.properSubset({ $where: { foo: 'bar' } }, { $where: {} }), true);
        equal(algebra.properSubset({ $where: {} }, { $where: {} }), false);
        equal(algebra.properSubset({ $where: {} }, { $where: { foo: 'bar' } }), false);
    });
    test('set.difference', function () {
        var algebra = new set.Algebra(new set.Translate('where', '$where'));
        var res = algebra.difference({ $where: {} }, { $where: { completed: true } });
        ok(res === true, 'diff should be true');
        res = algebra.difference({ $where: { completed: true } }, { $where: { completed: true } });
        equal(res, false);
        res = algebra.difference({ $where: { completed: true } }, { $where: {} });
        equal(res, false);
        res = algebra.difference({ $where: { completed: true } }, { $where: { userId: 5 } });
        equal(res, false);
    });
    test('set.difference({ function })', function () {
        var algebra = new set.Algebra(new set.Translate('where', '$where'), {
            colors: function () {
                return {
                    difference: ['red'],
                    intersection: ['blue']
                };
            }
        });
        var res = algebra.difference({
            $where: {
                colors: [
                    'red',
                    'blue'
                ]
            }
        }, { $where: { colors: ['blue'] } });
        deepEqual(res, { $where: { colors: ['red'] } });
    });
    test('set.union', function () {
        var algebra = new set.Algebra(new set.Translate('where', '$where'));
        var res = algebra.union({ $where: {} }, { $where: { completed: true } });
        deepEqual(res, { $where: {} }, 'set / subset');
        res = algebra.union({ $where: { completed: true } }, { $where: {} });
        deepEqual(res, { $where: {} }, 'subset / set');
        res = algebra.union({ $where: { foo: 'bar' } }, { $where: { foo: 'bar' } });
        deepEqual(res, { $where: { foo: 'bar' } }, 'equal');
        res = algebra.union({ $where: { foo: 'bar' } }, { $where: { foo: 'zed' } });
        ok(!res, 'values not equal');
        res = algebra.union({ $where: { foo: 'bar' } }, { $where: { name: 'A' } });
        ok(!res, 'values not equal');
    });
    test('set.union Array', function () {
        var algebra = new set.Algebra(new set.Translate('where', '$where'));
        var res = algebra.union({
            $where: {
                foo: [
                    'a',
                    'b'
                ]
            }
        }, {
            $where: {
                foo: [
                    'a',
                    'c'
                ]
            }
        });
        deepEqual(res, {
            $where: {
                foo: [
                    'a',
                    'b',
                    'c'
                ]
            }
        }, 'set / subset');
    });
    test('set.count', function () {
        var algebra = new set.Algebra(new set.Translate('where', '$where'), {
            foo: function () {
                return { count: 100 };
            }
        });
        ok(algebra.count({ $where: {} }) === Infinity, 'defaults to infinity');
        ok(algebra.count({ $where: { bar: 'foo' } }) === Infinity, 'defaults to infinity');
        equal(algebra.count({ $where: { foo: 'bar' } }), 100, 'works with a single value');
    });
    test('set.intersection', function () {
        var algebra = new set.Algebra(new set.Translate('where', '$where'));
        var res = algebra.intersection({ $where: {} }, { $where: { completed: true } });
        deepEqual(res, { $where: { completed: true } }, 'set / subset');
        res = algebra.intersection({ $where: { completed: true } }, { $where: {} });
        deepEqual(res, { $where: { completed: true } }, 'subset / set');
        res = algebra.intersection({ $where: { foo: 'bar' } }, { $where: { foo: 'bar' } });
        deepEqual(res, { $where: { foo: 'bar' } }, 'equal');
        res = algebra.intersection({ $where: { foo: 'bar' } }, { $where: { foo: 'zed' } });
        ok(!res, 'values not equal');
        res = algebra.intersection({ $where: { foo: 'bar' } }, { $where: { completed: true } });
        deepEqual(res, {
            $where: {
                foo: 'bar',
                completed: true
            }
        }, 'intersection should combine definitions');
    });
    test('set.intersection Array', function () {
        var algebra = new set.Algebra(new set.Translate('where', '$where'));
        var res = algebra.intersection({
            $where: {
                foo: [
                    'a',
                    'b'
                ]
            }
        }, {
            $where: {
                foo: [
                    'a',
                    'c'
                ]
            }
        });
        deepEqual(res, { $where: { foo: ['a'] } }, 'intersection');
    });
    test('set.has', function () {
        var algebra = new set.Algebra(new set.Translate('where', '$where'), {
            count: ignoreProp,
            type: function (a, b) {
                return ('' + a).toLowerCase() === ('' + b).toLowerCase();
            },
            foo: ignoreProp,
            bar: ignoreProp,
            kind: ignoreProp
        });
        ok(algebra.has({ $where: { someId: 5 } }, {
            someId: 5,
            name: 'foo'
        }), 'contains');
        var res;
        res = algebra.has({ $where: { type: 'FOLDER' } }, { type: 'FOLDER' });
        ok(res, 'equal sets');
        res = algebra.has({
            $where: {
                type: 'FOLDER',
                parentId: 5
            }
        }, { type: 'FOLDER' });
        equal(res, false, 'doesnt match');
        res = algebra.has({ $where: { type: 'FOLDER' } }, {
            type: 'FOLDER',
            parentId: 5
        });
        ok(true, 'is a subset');
        res = algebra.has({
            $where: {
                type: 'FOLDER',
                parentId: 7
            }
        }, {
            type: 'FOLDER',
            parentId: 5
        });
        ok(!res, 'different values');
        res = algebra.has({
            $where: {
                type: 'FOLDER',
                count: 5
            }
        }, { type: 'FOLDER' }, { count: ignoreProp });
        ok(res, 'count ignored');
        res = algebra.has({
            $where: {
                type: 'FOLDER',
                kind: 'tree'
            }
        }, {
            type: 'FOLDER',
            foo: true,
            bar: true
        });
        ok(res, 'understands a subset');
        res = algebra.has({
            $where: {
                type: 'FOLDER',
                foo: true,
                bar: true
            }
        }, {
            type: 'FOLDER',
            kind: 'tree'
        });
        ok(res, 'ignores nulls');
    });
});
/*can-set@1.5.1#src/props*/
define('can-set@1.5.1#src/props', [
    'require',
    'exports',
    'module',
    './helpers',
    './clause',
    'can-util/js/each/each'
], function (require, exports, module) {
    var h = require('./helpers');
    var clause = require('./clause');
    var each = require('can-util/js/each/each');
    var within = function (value, range) {
        return value >= range[0] && value <= range[1];
    };
    var numericProperties = function (setA, setB, property1, property2) {
        return {
            sAv1: +setA[property1],
            sAv2: +setA[property2],
            sBv1: +setB[property1],
            sBv2: +setB[property2]
        };
    };
    var diff = function (setA, setB, property1, property2) {
        var numProps = numericProperties(setA, setB, property1, property2);
        var sAv1 = numProps.sAv1, sAv2 = numProps.sAv2, sBv1 = numProps.sBv1, sBv2 = numProps.sBv2, count = sAv2 - sAv1 + 1;
        var after = {
            difference: [
                sBv2 + 1,
                sAv2
            ],
            intersection: [
                sAv1,
                sBv2
            ],
            union: [
                sBv1,
                sAv2
            ],
            count: count,
            meta: 'after'
        };
        var before = {
            difference: [
                sAv1,
                sBv1 - 1
            ],
            intersection: [
                sBv1,
                sAv2
            ],
            union: [
                sAv1,
                sBv2
            ],
            count: count,
            meta: 'before'
        };
        if (sAv1 === sBv1 && sAv2 === sBv2) {
            return {
                intersection: [
                    sAv1,
                    sAv2
                ],
                union: [
                    sAv1,
                    sAv2
                ],
                count: count,
                meta: 'equal'
            };
        } else if (sAv1 === sBv1 && sBv2 < sAv2) {
            return after;
        } else if (sAv2 === sBv2 && sBv1 > sAv1) {
            return before;
        } else if (within(sAv1, [
                sBv1,
                sBv2
            ]) && within(sAv2, [
                sBv1,
                sBv2
            ])) {
            return {
                intersection: [
                    sAv1,
                    sAv2
                ],
                union: [
                    sBv1,
                    sBv2
                ],
                count: count,
                meta: 'subset'
            };
        } else if (within(sBv1, [
                sAv1,
                sAv2
            ]) && within(sBv2, [
                sAv1,
                sAv2
            ])) {
            return {
                intersection: [
                    sBv1,
                    sBv2
                ],
                difference: [
                    null,
                    null
                ],
                union: [
                    sAv1,
                    sAv2
                ],
                count: count,
                meta: 'superset'
            };
        } else if (sAv1 < sBv1 && within(sAv2, [
                sBv1,
                sBv2
            ])) {
            return before;
        } else if (sBv1 < sAv1 && within(sBv2, [
                sAv1,
                sAv2
            ])) {
            return after;
        } else if (sAv2 === sBv1 - 1) {
            return {
                difference: [
                    sAv1,
                    sAv2
                ],
                union: [
                    sAv1,
                    sBv2
                ],
                count: count,
                meta: 'disjoint-before'
            };
        } else if (sBv2 === sAv1 - 1) {
            return {
                difference: [
                    sAv1,
                    sAv2
                ],
                union: [
                    sBv1,
                    sAv2
                ],
                count: count,
                meta: 'disjoint-after'
            };
        }
        if (!isNaN(count)) {
            return {
                count: count,
                meta: 'disjoint'
            };
        }
    };
    var cleanUp = function (value, enumData) {
        if (!value) {
            return enumData;
        }
        if (!Array.isArray(value)) {
            value = [value];
        }
        if (!value.length) {
            return enumData;
        }
        return value;
    };
    var stringConvert = {
        '0': false,
        'false': false,
        'null': undefined,
        'undefined': undefined
    };
    var convertToBoolean = function (value) {
        if (typeof value === 'string') {
            return value.toLowerCase() in stringConvert ? stringConvert[value.toLowerCase()] : true;
        }
        return value;
    };
    var props = {
        'enum': function (prop, enumData) {
            var compares = new clause.Where({});
            compares[prop] = function (vA, vB, A, B) {
                vA = cleanUp(vA, enumData);
                vB = cleanUp(vB, enumData);
                var data = h.arrayUnionIntersectionDifference(vA, vB);
                if (!data.difference.length) {
                    delete data.difference;
                }
                each(data, function (value, prop) {
                    if (Array.isArray(value)) {
                        if (h.arraySame(enumData, value)) {
                            data[prop] = undefined;
                        } else if (value.length === 1) {
                            data[prop] = value[0];
                        }
                    }
                });
                return data;
            };
            return compares;
        },
        paginate: function (propStart, propEnd, translateToStartEnd, reverseTranslate) {
            var compares = {};
            var makeResult = function (result, index) {
                var res = {};
                each([
                    'intersection',
                    'difference',
                    'union'
                ], function (prop) {
                    if (result[prop]) {
                        var set = {
                            start: result[prop][0],
                            end: result[prop][1]
                        };
                        res[prop] = reverseTranslate(set)[index === 0 ? propStart : propEnd];
                    }
                });
                if (result.count) {
                    res.count = result.count;
                }
                return res;
            };
            compares[propStart] = function (vA, vB, A, B) {
                if (vA === undefined) {
                    return;
                }
                var res = diff(translateToStartEnd(A), translateToStartEnd(B), 'start', 'end');
                var result = makeResult(res, 0);
                result.getSubset = function (a, b, bItems, algebra, options) {
                    return bItems;
                };
                result.getUnion = function (a, b, aItems, bItems, algebra, options) {
                    return [
                        aItems,
                        bItems
                    ];
                };
                return result;
            };
            compares[propEnd] = function (vA, vB, A, B) {
                if (vA === undefined) {
                    return;
                }
                var data = diff(translateToStartEnd(A), translateToStartEnd(B), 'start', 'end');
                var res = makeResult(data, 1);
                res.getSubset = function (a, b, bItems, algebra, options) {
                    var tA = translateToStartEnd(a);
                    var tB = translateToStartEnd(b);
                    var numProps = numericProperties(tA, tB, 'start', 'end');
                    var aStartValue = numProps.sAv1, aEndValue = numProps.sAv2;
                    var bStartValue = numProps.sBv1;
                    if (!('end' in tB) || !('end' in tA)) {
                        return bItems.slice(aStartValue, aEndValue + 1);
                    }
                    return bItems.slice(aStartValue - bStartValue, aEndValue - bStartValue + 1);
                };
                res.getUnion = function (a, b, aItems, bItems, algebra, options) {
                    var tA = translateToStartEnd(a);
                    var tB = translateToStartEnd(b);
                    if (data.meta.indexOf('after') >= 0) {
                        if (data.intersection) {
                            bItems = bItems.slice(0, data.intersection[0] - +tB.start);
                        }
                        return [
                            bItems,
                            aItems
                        ];
                    }
                    if (data.intersection) {
                        aItems = aItems.slice(0, data.intersection[0] - +tA.start);
                    }
                    return [
                        aItems,
                        bItems
                    ];
                };
                return res;
            };
            return new clause.Paginate(compares);
        },
        'boolean': function (propertyName) {
            var compares = new clause.Where({});
            compares[propertyName] = function (propA, propB) {
                propA = convertToBoolean(propA);
                propB = convertToBoolean(propB);
                var notA = !propA, notB = !propB;
                if (propA === notB && propB === notA) {
                    return {
                        difference: !propB,
                        union: undefined
                    };
                } else if (propA === undefined) {
                    return {
                        difference: !propB,
                        intersection: propB,
                        union: undefined
                    };
                } else if (propA === propB) {
                    return true;
                }
            };
            return compares;
        },
        'sort': function (prop, sortFunc) {
            if (!sortFunc) {
                sortFunc = h.defaultSort;
            }
            var compares = {};
            compares[prop] = sortFunc;
            return new clause.Order(compares);
        },
        'id': function (prop) {
            var compares = {};
            compares[prop] = prop;
            return new clause.Id(compares);
        }
    };
    var assignExcept = function (d, s, props) {
        for (var prop in s) {
            if (!props[prop]) {
                d[prop] = s[prop];
            }
        }
        return d;
    };
    var translateToOffsetLimit = function (set, offsetProp, limitProp) {
        var newSet = assignExcept({}, set, {
            start: 1,
            end: 1
        });
        if ('start' in set) {
            newSet[offsetProp] = set.start;
        }
        if ('end' in set) {
            newSet[limitProp] = set.end - set.start + 1;
        }
        return newSet;
    };
    var translateToStartEnd = function (set, offsetProp, limitProp) {
        var except = {};
        except[offsetProp] = except[limitProp] = 1;
        var newSet = assignExcept({}, set, except);
        if (offsetProp in set) {
            newSet.start = parseInt(set[offsetProp], 10);
        }
        if (limitProp in set) {
            newSet.end = newSet.start + parseInt(set[limitProp]) - 1;
        }
        return newSet;
    };
    props.offsetLimit = function (offsetProp, limitProp) {
        offsetProp = offsetProp || 'offset';
        limitProp = limitProp || 'limit';
        return props.paginate(offsetProp, limitProp, function (set) {
            return translateToStartEnd(set, offsetProp, limitProp);
        }, function (set) {
            return translateToOffsetLimit(set, offsetProp, limitProp);
        });
    };
    props.rangeInclusive = function (startIndexProperty, endIndexProperty) {
        startIndexProperty = startIndexProperty || 'start';
        endIndexProperty = endIndexProperty || 'end';
        return props.paginate(startIndexProperty, endIndexProperty, function (set) {
            var except = {};
            except[startIndexProperty] = except[endIndexProperty] = 1;
            var newSet = assignExcept({}, set, except);
            if (startIndexProperty in set) {
                newSet.start = set[startIndexProperty];
            }
            if (endIndexProperty in set) {
                newSet.end = set[endIndexProperty];
            }
            return newSet;
        }, function (set) {
            var except = {
                start: 1,
                end: 1
            };
            var newSet = assignExcept({}, set, except);
            newSet[startIndexProperty] = set.start;
            newSet[endIndexProperty] = set.end;
            return newSet;
        });
    };
    var nestedLookup = function (obj, propNameArray) {
        if (obj === undefined) {
            return undefined;
        }
        if (propNameArray.length === 1) {
            return obj[propNameArray[0]];
        } else {
            return nestedLookup(obj[propNameArray[0]], propNameArray.slice(1));
        }
    };
    props.dotNotation = function (dotProperty) {
        var compares = new clause.Where({});
        compares[dotProperty] = function (aVal, bVal, a, b, propertyName) {
            if (aVal === undefined) {
                aVal = nestedLookup(a, propertyName.split('.'));
            }
            if (bVal === undefined) {
                bVal = nestedLookup(b, propertyName.split('.'));
            }
            return aVal === bVal;
        };
        return compares;
    };
    module.exports = props;
});
/*can-set@1.5.1#src/prop_tests/sort_test*/
define('can-set@1.5.1#src/prop_tests/sort_test', [
    'require',
    'exports',
    'module',
    'steal-qunit',
    '../set-core',
    '../props',
    'can-util/js/each/each'
], function (require, exports, module) {
    var QUnit = require('steal-qunit');
    var set = require('../set-core'), props = require('../props');
    var each = require('can-util/js/each/each');
    QUnit.module('can-set props.sort');
    test('set.difference', function () {
        var prop = props.sort('sort');
        var res = set.difference({ sort: 'foo' }, { completed: true }, prop);
        ok(res === true, 'diff should be true');
        res = set.difference({ completed: true }, {
            completed: true,
            sort: 'foo'
        }, prop);
        equal(res, false, 'the same except for sort');
        res = set.difference({ completed: true }, { sort: 'foo' }, prop);
        equal(res, false);
        res = set.difference({ completed: true }, {
            foo: 'bar',
            sort: 'foo'
        }, prop);
        equal(res, false);
    });
    test('set.difference({ function })', function () {
        var algebra = new set.Algebra(props.sort('sort'), {
            colors: function () {
                return {
                    difference: ['red'],
                    intersection: ['blue']
                };
            }
        });
        var res = algebra.difference({
            colors: [
                'red',
                'blue'
            ],
            sort: 'colors'
        }, { colors: ['blue'] });
        deepEqual(res, {
            colors: ['red'],
            sort: 'colors'
        });
    });
    test('set.union', function () {
        var prop = props.sort('sort');
        var res = set.union({ sort: 'name' }, { completed: true }, prop);
        deepEqual(res, {}, 'set / subset sort left');
        res = set.union({}, {
            completed: true,
            sort: 'name'
        }, prop);
        deepEqual(res, {}, 'set / subset sort right');
        res = set.union({ sort: 'name' }, {
            completed: true,
            sort: 'namer'
        }, prop);
        deepEqual(res, {}, 'set / subset both sorts');
        res = set.union({ completed: true }, { sort: 'foo' }, prop);
        deepEqual(res, {}, 'subset / set');
        res = set.union({
            foo: 'bar',
            sort: 'foo'
        }, { foo: 'bar' }, prop);
        deepEqual(res, { foo: 'bar' }, 'equal');
        res = set.union({ foo: 'bar' }, {
            foo: 'zed',
            sort: 'foo'
        }, prop);
        ok(!res, 'values not equal');
        res = set.union({
            foo: 'bar',
            sort: 'foo'
        }, { name: 'A' }, prop);
        ok(!res, 'values not equal');
    });
    test('set.union Array', function () {
        var prop = props.sort('sort');
        var res = set.union({
            foo: [
                'a',
                'b'
            ],
            sort: 'foo'
        }, {
            foo: [
                'a',
                'c'
            ]
        }, prop);
        deepEqual(res, {
            foo: [
                'a',
                'b',
                'c'
            ]
        }, 'set / subset');
    });
    test('set.count', function () {
        ok(set.count({ sort: 'name' }) === Infinity, 'defaults to infinity');
        ok(set.count({
            foo: 'bar',
            sort: 'foo'
        }, {}) === Infinity, 'defaults to infinity');
        equal(set.count({
            foo: 'bar',
            sort: 'foo'
        }, {
            foo: function () {
                return { count: 100 };
            }
        }), 100, 'works with a single value');
    });
    test('set.intersection', function () {
        var prop = props.sort('sort');
        var res = set.intersection({}, { sort: 'name' }, prop);
        deepEqual(res, {}, 'no sort if only one is sorted');
        res = set.intersection({ sort: 'name' }, { sort: 'name' }, prop);
        deepEqual(res, { sort: 'name' }, '');
        res = set.intersection({ type: 'new' }, {
            sort: 'name',
            userId: 5
        }, prop);
        deepEqual(res, {
            type: 'new',
            userId: 5
        }, '');
        res = set.intersection({
            type: 'new',
            sort: 'age'
        }, {
            sort: 'name',
            userId: 5
        }, prop);
        deepEqual(res, {
            type: 'new',
            userId: 5
        }, '');
    });
    test('set.intersection Array', function () {
        var prop = props.sort('sort');
        var res = set.intersection({
            foo: [
                'a',
                'b'
            ],
            sort: 'foo'
        }, {
            foo: [
                'a',
                'c'
            ]
        }, prop);
        deepEqual(res, { foo: ['a'] }, 'intersection');
    });
    test('set.subset', function () {
        var ignoreProp = function () {
            return true;
        };
        var algebra = new set.Algebra(props.sort('sort'), {
            foo: ignoreProp,
            bar: ignoreProp,
            kind: ignoreProp,
            count: ignoreProp
        });
        ok(algebra.subset({
            type: 'FOLDER',
            sort: 'thing'
        }, { type: 'FOLDER' }), 'equal sets with sort on the left');
        ok(algebra.subset({ type: 'FOLDER' }, {
            type: 'FOLDER',
            sort: 'thing'
        }), 'equal sets with sort on the right');
        ok(algebra.subset({
            type: 'FOLDER',
            parentId: 5,
            sort: 'thing'
        }, { type: 'FOLDER' }), 'sub set with sort on the left');
        ok(algebra.subset({
            type: 'FOLDER',
            parentId: 5
        }, {
            type: 'FOLDER',
            sort: 'thing'
        }), 'sub set with sort on the right');
        ok(!algebra.subset({
            type: 'FOLDER',
            sort: 'thing'
        }, {
            type: 'FOLDER',
            parentId: 5
        }), 'wrong way with sort on the left');
        ok(!algebra.subset({ type: 'FOLDER' }, {
            type: 'FOLDER',
            parentId: 5,
            sort: 'thing'
        }), 'wrong way with sort on the right');
        ok(!algebra.subset({
            type: 'FOLDER',
            parentId: 7,
            sort: 'thing'
        }, {
            type: 'FOLDER',
            parentId: 5
        }), 'different values with sort on the left');
        ok(!algebra.subset({
            type: 'FOLDER',
            parentId: 7
        }, {
            type: 'FOLDER',
            parentId: 5,
            sort: 'thing'
        }), 'different values with sort on the right');
    });
    test('set.subset with range', function () {
        var algebra = new set.Algebra(props.sort('sort'), props.rangeInclusive('start', 'end'));
        var addSort = function (set, value) {
            set.sort = value;
        };
        var sort = {
            left: function (setA, setB) {
                addSort(setA, 'prop');
            },
            right: function (setA, setB) {
                addSort(setB, 'prop');
            },
            same: function (setA, setB) {
                addSort(setA, 'prop');
                addSort(setB, 'prop');
            },
            different: function (setA, setB) {
                addSort(setA, 'propA');
                addSort(setB, 'propB');
            }
        };
        var addRange = function (set, start, end) {
            set.start = start;
            set.end = end;
        };
        var range = {
            left: function (setA, setB) {
                addRange(setA, 0, 9);
            },
            right: function (setA, setB) {
                addRange(setB, 0, 9);
            },
            same: function (setA, setB) {
                addRange(setA, 0, 9);
                addRange(setB, 0, 9);
            },
            superLeft: function (setA, setB) {
                addRange(setA, 0, 9);
                addRange(setB, 3, 7);
            },
            superRight: function (setA, setB) {
                addRange(setB, 0, 9);
                addRange(setA, 3, 7);
            }
        };
        var sets = {
            same: function (setA, setB) {
            },
            superLeft: function (setA, setB) {
                setB.type = 'apples';
            },
            superRight: function (setA, setB) {
                setA.type = 'apples';
            }
        };
        var make = function () {
            var setA = {}, setB = {};
            each(arguments, function (method) {
                method(setA, setB);
            });
            return {
                left: setA,
                right: setB
            };
        };
        var assertSubset = function (methods, result) {
            var sets = make.apply(null, methods);
            equal(algebra.subset(sets.left, sets.right), result, JSON.stringify(sets.left) + ' \u2282 ' + JSON.stringify(sets.right) + ' = ' + result);
        };
        assertSubset([
            sets.superRight,
            range.right,
            sort.right
        ], false);
        assertSubset([
            sets.same,
            range.same,
            sort.different
        ], false);
        assertSubset([
            sets.same,
            range.same,
            sort.same
        ], true);
        assertSubset([
            sets.same,
            range.superRight,
            sort.left
        ], false);
        assertSubset([
            sets.same,
            range.superRight,
            sort.same
        ], true);
    });
    test('set.index', function () {
        var algebra = new set.Algebra(props.sort('sort'));
        var index = algebra.index({ sort: 'name' }, [
            {
                id: 1,
                name: 'g'
            },
            {
                id: 2,
                name: 'j'
            },
            {
                id: 3,
                name: 'm'
            },
            {
                id: 4,
                name: 's'
            }
        ], { name: 'k' });
        equal(index, 2);
    });
    test('set.getSubset (#14)', function () {
        var algebra = new set.Algebra(props.sort('sort'));
        var subset = algebra.getSubset({ sort: 'name' }, {}, [
            {
                id: 1,
                name: 's'
            },
            {
                id: 2,
                name: 'j'
            },
            {
                id: 3,
                name: 'm'
            },
            {
                id: 4,
                name: 'g'
            }
        ]);
        deepEqual(subset, [
            {
                id: 4,
                name: 'g'
            },
            {
                id: 2,
                name: 'j'
            },
            {
                id: 3,
                name: 'm'
            },
            {
                id: 1,
                name: 's'
            }
        ]);
    });
    test('set.getUnion', function () {
        var algebra = new set.Algebra(props.sort('sort'), props.boolean('complete'));
        var union = algebra.getUnion({
            sort: 'name',
            complete: true
        }, {
            sort: 'name',
            complete: false
        }, [
            {
                id: 4,
                name: 'g',
                complete: true
            },
            {
                id: 3,
                name: 'm',
                complete: true
            }
        ], [
            {
                id: 2,
                name: 'j',
                complete: false
            },
            {
                id: 1,
                name: 's',
                complete: false
            }
        ]);
        deepEqual(union, [
            {
                id: 4,
                name: 'g',
                complete: true
            },
            {
                id: 2,
                name: 'j',
                complete: false
            },
            {
                id: 3,
                name: 'm',
                complete: true
            },
            {
                id: 1,
                name: 's',
                complete: false
            }
        ]);
    });
    test('set.union keeps sort', function () {
        var algebra = new set.Algebra(props.sort('sort'), props.boolean('complete'));
        var union = algebra.union({
            sort: 'name',
            complete: true
        }, {
            sort: 'name',
            complete: false
        });
        deepEqual(union, { sort: 'name' });
    });
    test('paginated and sorted is subset (#17)', function () {
        var algebra = new set.Algebra(props.sort('sort'), props.rangeInclusive('start', 'end'));
        var res = algebra.subset({
            start: 0,
            end: 100,
            sort: 'name'
        }, {
            start: 0,
            end: 100,
            sort: 'name'
        });
        equal(res, true, 'parent:paginate+order child:paginate+order (same set)');
        res = algebra.subset({
            start: 0,
            end: 100,
            sort: 'name'
        }, {
            start: 0,
            end: 100,
            sort: 'age'
        });
        equal(res, false, 'parent:paginate+order child:paginate+order (different order)');
        res = algebra.subset({
            start: 0,
            end: 100,
            sort: 'name'
        }, { sort: 'name' });
        equal(res, true, 'parent:order child:paginate+order');
        res = algebra.subset({ sort: 'name' }, { sort: 'name' });
        equal(res, true, 'parent:order child:order (same)');
        res = algebra.subset({ sort: 'name' }, { sort: 'age' });
        equal(res, true, 'parent:order child:order (different)');
        res = algebra.subset({
            start: 0,
            end: 100
        }, { sort: 'name' });
        equal(res, true, 'parent:order child:paginate');
        res = algebra.subset({
            start: 0,
            end: 100,
            sort: 'age'
        }, { sort: 'name' });
        equal(res, true, 'parent:order child:paginate+order');
        res = algebra.subset({
            start: 0,
            end: 100,
            sort: 'name'
        }, {
            start: 0,
            end: 100
        });
        equal(res, false, 'parent:paginate child:paginate+order');
        res = algebra.subset({ sort: 'name' }, {
            start: 0,
            end: 100
        });
        equal(res, false, 'parent:paginate child:order (same)');
        res = algebra.subset({
            start: 0,
            end: 100,
            sort: 'name'
        }, {});
        equal(res, true, 'parent:-- child:paginate+order');
        res = algebra.subset({
            start: 10,
            end: 90,
            sort: 'name'
        }, {
            start: 0,
            end: 100,
            sort: 'name'
        });
        equal(res, true, 'child in smaller range, same sort');
        res = algebra.subset({
            start: 10,
            end: 90,
            sort: 'name'
        }, {
            start: 0,
            end: 100,
            sort: 'age'
        });
        equal(res, false, 'child in smaller range, but different sort');
    });
});
/*can-set@1.5.1#src/prop_tests/rangeInclusive_test*/
define('can-set@1.5.1#src/prop_tests/rangeInclusive_test', [
    'require',
    'exports',
    'module',
    'steal-qunit',
    '../set-core',
    '../props'
], function (require, exports, module) {
    var QUnit = require('steal-qunit');
    var set = require('../set-core'), props = require('../props');
    QUnit.module('can-set props.rangeInclusive');
    test('rangeInclusive set.equal', function () {
        ok(set.equal({
            start: 0,
            end: 100
        }, {
            start: 0,
            end: 100
        }, props.rangeInclusive('start', 'end')), 'they are equal');
        ok(!set.equal({
            start: 0,
            end: 100
        }, {
            start: 0,
            end: 101
        }, props.rangeInclusive('start', 'end')), 'they are not equal');
        ok(!set.equal({
            start: 0,
            end: 100
        }, {
            start: 1,
            end: 100
        }, props.rangeInclusive('start', 'end')), 'they are not equal');
    });
    test('rangeInclusive set.subset', function () {
        ok(set.subset({
            start: 0,
            end: 100
        }, {
            start: 0,
            end: 100
        }, props.rangeInclusive('start', 'end')), 'self is a subset');
        ok(set.subset({
            start: 0,
            end: 100
        }, {
            start: 0,
            end: 101
        }, props.rangeInclusive('start', 'end')), 'end extends past subset');
        ok(!set.subset({
            start: 0,
            end: 101
        }, {
            start: 0,
            end: 100
        }, props.rangeInclusive('start', 'end')), 'non-subset extends past end');
        ok(set.subset({
            start: 1,
            end: 100
        }, {
            start: 0,
            end: 100
        }, props.rangeInclusive('start', 'end')), 'start extends before subset');
        ok(!set.subset({
            start: 0,
            end: 100
        }, {
            start: 1,
            end: 100
        }, props.rangeInclusive('start', 'end')), 'non-subset extends before start');
    });
    test('rangeInclusive set.difference', function () {
        var prop = props.rangeInclusive('start', 'end');
        var res = set.difference({
            start: 0,
            end: 99
        }, {
            start: 50,
            end: 101
        }, prop);
        deepEqual(res, {
            start: 0,
            end: 49
        }, 'got a diff');
        res = set.difference({}, {
            start: 0,
            end: 10
        }, prop);
        equal(res, true, 'universal set');
        res = set.difference({
            start: 0,
            end: 49
        }, {
            start: 50,
            end: 101
        }, prop);
        deepEqual(res, {
            start: 0,
            end: 49
        }, 'side by side');
        res = set.difference({
            start: 0,
            end: 49
        }, {
            start: 0,
            end: 20
        }, prop);
        deepEqual(res, {
            start: 21,
            end: 49
        }, 'first set extends past second');
        res = set.difference({
            start: 0,
            end: 49
        }, {
            start: 20,
            end: 49
        }, prop);
        deepEqual(res, {
            start: 0,
            end: 19
        }, 'first set starts before second');
    });
    test('rangeInclusive set.union', function () {
        var prop = props.rangeInclusive('start', 'end');
        var res = set.union({
            start: 0,
            end: 99
        }, {
            start: 50,
            end: 101
        }, prop);
        deepEqual(res, {
            start: 0,
            end: 101
        }, 'got a union');
        res = set.union({}, {
            start: 0,
            end: 10
        }, prop);
        deepEqual(res, {}, 'universal set');
        res = set.union({
            start: 100,
            end: 199
        }, {
            start: 200,
            end: 299
        }, prop);
        deepEqual(res, {
            start: 100,
            end: 299
        }, 'no intersection');
        res = set.union({
            start: 200,
            end: 299
        }, {
            start: 100,
            end: 199
        }, prop);
        deepEqual(res, {
            start: 100,
            end: 299
        }, 'no intersection with either argument order');
        res = set.union({
            start: 200,
            end: 299
        }, {
            start: 100,
            end: 209
        }, prop);
        deepEqual(res, {
            start: 100,
            end: 299
        }, 'sets can intersect');
        res = set.union({
            start: 100,
            end: 209
        }, {
            start: 200,
            end: 299
        }, prop);
        deepEqual(res, {
            start: 100,
            end: 299
        }, 'sets can intersect with either argument order');
        res = set.union({
            start: 100,
            end: 299
        }, {
            start: 103,
            end: 209
        }, prop);
        deepEqual(res, {
            start: 100,
            end: 299
        }, 'first set contains second');
        res = set.union({
            start: 100,
            end: 299
        }, {
            start: 103,
            end: 209
        }, prop);
        deepEqual(res, {
            start: 100,
            end: 299
        }, 'second set contains first');
        res = set.union({
            start: 100,
            end: 299
        }, {
            start: 100,
            end: 299
        }, prop);
        deepEqual(res, {
            start: 100,
            end: 299
        }, 'union of identical sets is the same as those sets');
    });
    test('rangeInclusive set.count', function () {
        var prop = props.rangeInclusive('start', 'end');
        var res = set.count({
            start: 0,
            end: 99
        }, prop);
        equal(res, 100, 'count is right');
    });
    test('rangeInclusive set.intersection', function () {
        var prop = props.rangeInclusive('start', 'end');
        var res = set.intersection({
            start: 0,
            end: 99
        }, {
            start: 50,
            end: 101
        }, prop);
        deepEqual(res, {
            start: 50,
            end: 99
        }, 'got a intersection');
    });
    test('rangeInclusive with string numbers (#17)', function () {
        var algebra = new set.Algebra(props.rangeInclusive('start', 'end'));
        ok(algebra.subset({
            start: '1',
            end: '100'
        }, {
            start: '0',
            end: '100'
        }), '.subset');
        var res = algebra.getSubset({
            start: '2',
            end: '3'
        }, {
            start: '1',
            end: '4'
        }, [
            { id: 1 },
            { id: 2 },
            { id: 3 },
            { id: 4 }
        ]);
        deepEqual(res, [
            { id: 2 },
            { id: 3 }
        ], '.getSubset');
        res = algebra.getUnion({
            start: '2',
            end: '3'
        }, {
            start: '1',
            end: '4'
        }, [
            { id: 2 },
            { id: 3 }
        ], [
            { id: 1 },
            { id: 2 },
            { id: 3 },
            { id: 4 }
        ]);
        deepEqual(res, [
            { id: 1 },
            { id: 2 },
            { id: 3 },
            { id: 4 }
        ], '.getUnion');
    });
});
/*can-set@1.5.1#src/prop_tests/offsetLimit_test*/
define('can-set@1.5.1#src/prop_tests/offsetLimit_test', [
    'require',
    'exports',
    'module',
    'steal-qunit',
    '../set-core',
    '../props'
], function (require, exports, module) {
    var QUnit = require('steal-qunit');
    var set = require('../set-core'), props = require('../props');
    QUnit.module('can-set props.limitOffset');
    test('offsetLimit set.equal', function () {
        ok(set.equal({
            offset: 0,
            limit: 99
        }, {
            offset: 0,
            limit: 99
        }, props.offsetLimit('offset', 'limit')), 'they are equal');
        ok(!set.equal({
            offset: 0,
            limit: 100
        }, {
            offset: 0,
            limit: 101
        }, props.offsetLimit('offset', 'limit')), 'they are not equal');
        ok(!set.equal({
            offset: 0,
            limit: 100
        }, {
            offset: 1,
            limit: 100
        }, props.offsetLimit('offset', 'limit')), 'they are not equal');
    });
    test('offsetLimit set.union', function () {
        var prop = props.offsetLimit('offset', 'limit');
        var res = set.union({
            offset: 0,
            limit: 100
        }, {
            offset: 50,
            limit: 52
        }, prop);
        deepEqual(res, {
            offset: 0,
            limit: 102
        }, 'got a union');
        res = set.union({}, {
            offset: 0,
            limit: 10
        }, prop);
        deepEqual(res, {}, 'universal set');
        res = set.union({
            offset: 100,
            limit: 100
        }, {
            offset: 200,
            limit: 100
        }, prop);
        deepEqual(res, {
            offset: 100,
            limit: 200
        }, 'no intersection');
        res = set.union({
            offset: 200,
            limit: 100
        }, {
            offset: 100,
            limit: 100
        }, prop);
        deepEqual(res, {
            offset: 100,
            limit: 200
        }, 'no intersection with either argument order');
        res = set.union({
            offset: 100,
            limit: 110
        }, {
            offset: 200,
            limit: 100
        }, prop);
        deepEqual(res, {
            offset: 100,
            limit: 200
        }, 'sets can intersect with either argument order');
    });
    test('rangeInclusive set.count', function () {
        var prop = props.offsetLimit('offset', 'limit');
        var res = set.count({
            offset: 0,
            limit: 100
        }, prop);
        equal(res, 100, 'count is right');
    });
    test('rangeInclusive set.intersection', function () {
        var prop = props.offsetLimit('offset', 'limit');
        var res = set.intersection({
            offset: 0,
            limit: 100
        }, {
            offset: 50,
            limit: 52
        }, prop);
        deepEqual(res, {
            offset: 50,
            limit: 50
        }, 'got a intersection');
    });
});
/*can-set@1.5.1#src/prop_tests/boolean_test*/
define('can-set@1.5.1#src/prop_tests/boolean_test', [
    'require',
    'exports',
    'module',
    'steal-qunit',
    '../set-core',
    '../props'
], function (require, exports, module) {
    var QUnit = require('steal-qunit');
    var set = require('../set-core'), props = require('../props');
    QUnit.module('can-set props.boolean');
    test('boolean set.difference', function () {
        var prop = props.boolean('completed');
        var res = set.difference({}, { completed: true }, prop);
        deepEqual(res, { completed: false }, 'inverse of true');
        res = set.difference({}, { completed: false }, prop);
        deepEqual(res, { completed: true }, 'inverse of false');
    });
    test('boolean set.union', function () {
        var prop = props.boolean('completed');
        var res = set.union({ completed: false }, { completed: true }, prop);
        deepEqual(res, {}, 'union of true and false is entire boolean set');
    });
    test('boolean set.intersection', function () {
        var prop = props.boolean('completed');
        var res = set.intersection({ foo: 'bar' }, { completed: true }, prop);
        deepEqual(res, {
            foo: 'bar',
            completed: true
        }, 'intersection is false (#4)');
    });
    test('strings false and true are treated as booleans', function () {
        var prop = props.boolean('completed');
        var res = set.subset({}, { completed: 'true' }, prop);
        ok(!res, '{} and \'true\' not a subset');
        res = set.subset({}, { completed: 'false' }, prop);
        ok(!res, '{} and \'false\' not a subset');
        res = set.subset({ completed: 'true' }, {}, prop);
        ok(res, 'subset');
        res = set.subset({ completed: 'false' }, {}, prop);
        ok(res, 'subset');
        res = set.union({ completed: 'false' }, { completed: 'true' }, prop);
        deepEqual(res, {}, 'union of true and false is entire boolean set');
        res = set.equal({ completed: false }, { completed: 'false' }, prop);
        ok(res, 'false and \'false\'');
    });
});
/*can-set@1.5.1#src/prop_tests/enum_test*/
define('can-set@1.5.1#src/prop_tests/enum_test', [
    'require',
    'exports',
    'module',
    'steal-qunit',
    '../set-core',
    '../props'
], function (require, exports, module) {
    var QUnit = require('steal-qunit');
    var set = require('../set-core'), props = require('../props');
    QUnit.module('can-set props.enum');
    test('enum set.intersection', function () {
        var prop = props['enum']('type', [
            'new',
            'prep',
            'deliver',
            'delivered'
        ]);
        var res = set.intersection({}, { type: 'new' }, prop);
        deepEqual(res, { type: 'new' }, 'single enum intersected with universal set is idempotent');
        res = set.intersection({}, {
            type: [
                'new',
                'prep'
            ]
        }, prop);
        deepEqual(res, {
            type: [
                'new',
                'prep'
            ]
        }, 'array enum intersected with unversal set is idempotent');
        res = set.intersection({ type: ['prep'] }, {
            type: [
                'new',
                'prep'
            ]
        }, prop);
        deepEqual(res, { type: 'prep' }, 'items v items intersection');
        res = set.intersection({ type: [] }, {
            type: [
                'new',
                'prep'
            ]
        }, prop);
        deepEqual(res, {
            type: [
                'new',
                'prep'
            ]
        }, 'empty v array intersection');
        res = set.intersection({ type: 'new' }, {}, prop);
        deepEqual(res, { type: 'new' }, 'single v all');
    });
    test('enum set.difference', function () {
        var prop = props['enum']('type', [
            'new',
            'prep',
            'deliver',
            'delivered'
        ]);
        var res = set.difference({}, { type: 'new' }, prop);
        deepEqual(res, {
            type: [
                'prep',
                'deliver',
                'delivered'
            ]
        }, 'difference from universal set');
        res = set.difference({}, {
            type: [
                'new',
                'prep'
            ]
        }, prop);
        deepEqual(res, {
            type: [
                'deliver',
                'delivered'
            ]
        }, 'difference from universal set');
        res = set.difference({ type: ['prep'] }, {
            type: [
                'new',
                'prep'
            ]
        }, prop);
        deepEqual(res, false, 'difference from a superset');
        res = set.difference({ type: [] }, {
            type: [
                'new',
                'prep'
            ]
        }, prop);
        deepEqual(res, {
            type: [
                'deliver',
                'delivered'
            ]
        }, 'empty enum definition is same as universal set');
        res = set.difference({ type: 'new' }, {}, prop);
        deepEqual(res, false, 'all');
    });
    test('enum set.union', function () {
        var prop = props['enum']('type', [
            'new',
            'prep',
            'deliver',
            'delivered'
        ]);
        var res = set.union({}, { type: 'new' }, prop);
        deepEqual(res, {}, 'all');
        res = set.union({}, {
            type: [
                'new',
                'prep'
            ]
        }, prop);
        deepEqual(res, {}, 'intersection');
        res = set.union({ type: ['prep'] }, {
            type: [
                'new',
                'prep'
            ]
        }, prop);
        deepEqual(res, {
            type: [
                'prep',
                'new'
            ]
        }, 'union of a superset is superset');
        res = set.union({ type: [] }, {
            type: [
                'new',
                'prep'
            ]
        }, prop);
        deepEqual(res, {}, 'intersection');
        res = set.union({ type: 'new' }, {}, prop);
        deepEqual(res, {}, 'all');
        res = set.union({
            type: [
                'deliver',
                'delivered'
            ]
        }, {
            type: [
                'new',
                'prep'
            ]
        }, prop);
        deepEqual(res, {}, 'intersection');
    });
    test('enum set.equal', function () {
        var prop = props['enum']('type', [
            'new',
            'prep',
            'deliver',
            'delivered'
        ]);
        var res = set.equal({}, { type: 'new' }, prop);
        deepEqual(res, false, 'proper subset is not the universal set');
        res = set.equal({}, {
            type: [
                'new',
                'prep',
                'deliver',
                'delivered'
            ]
        }, prop);
        deepEqual(res, true, 'subset of all possible enums is the same as universal set');
        res = set.equal({ type: ['prep'] }, { type: ['prep'] }, prop);
        deepEqual(res, true, 'identical sets with single array enum are equal');
        res = set.equal({ type: 'prep' }, { type: 'prep' }, prop);
        deepEqual(res, true, 'identical sets with single property enum are equal');
        res = set.equal({ type: 'new' }, { type: 'prep' }, prop);
        deepEqual(res, false, 'two sets with different enum properties are not equal');
    });
    test('enum set.subset', function () {
        var prop = props['enum']('type', [
            'new',
            'prep',
            'deliver',
            'delivered'
        ]);
        var res = set.subset({}, { type: 'new' }, prop);
        deepEqual(res, false, 'universal set is not a subset');
        res = set.subset({ type: 'new' }, {}, prop);
        deepEqual(res, true, 'any single enum is a subset of universal set');
        res = set.subset({}, {
            type: [
                'new',
                'prep',
                'deliver',
                'delivered'
            ]
        }, prop);
        deepEqual(res, true, 'enum set matching definition of universal set is a subset of universal set');
        res = set.subset({ type: ['prep'] }, { type: ['prep'] }, prop);
        deepEqual(res, true, 'any list of possible enums are subset of universal set');
        res = set.subset({ type: 'prep' }, { type: 'prep' }, prop);
        deepEqual(res, true, 'intersection');
        res = set.subset({ type: 'new' }, { type: 'prep' }, prop);
        deepEqual(res, false, 'all');
        res = set.subset({ type: 'prep' }, {
            type: [
                'new',
                'prep',
                'deliver',
                'delivered'
            ]
        }, prop);
        deepEqual(res, true, 'intersection');
    });
});
/*can-set@1.5.1#src/prop_tests/dotNotation_test*/
define('can-set@1.5.1#src/prop_tests/dotNotation_test', [
    'require',
    'exports',
    'module',
    'steal-qunit',
    '../set-core',
    '../props'
], function (require, exports, module) {
    var QUnit = require('steal-qunit');
    var set = require('../set-core'), props = require('../props');
    QUnit.module('can-set props.dotNotation');
    test('dotNotation set membership', function () {
        var prop = props.dotNotation('n.p'), alg = new set.Algebra(prop), res = alg.has({ 'n.p': 'IL' }, { n: { p: 'IL' } });
        ok(res, 'object with nested property is member of set using dotNotation');
        res = alg.has({ 'n.p': 'IL' }, { n: { p: 'MI' } });
        ok(res === false, 'object with nested property not a member of set using dotNotation');
        prop = props.dotNotation('n.p.s');
        alg = new set.Algebra(prop);
        res = alg.has({ 'n.p.s': 'IL' }, { n: { p: { s: 'IL' } } });
        ok(res, 'object with deep nested property is member of set using dotNotation');
    });
    test('dotNotation set equality', function () {
        var prop = props.dotNotation('n.p'), alg = new set.Algebra(prop), set1 = { 'n.p': 'IL' }, set2 = { 'n.p': 'IL' }, set3 = { 'n.p': 'MI' }, set4 = { n: { p: 'MI' } };
        ok(alg.equal(set1, set2) && alg.equal(set2, set1), 'sets with dotNotation properties are equivalent');
        ok(alg.equal(set1, set3) === false, 'sets with dotNotation properties are not equivalent');
        ok(alg.equal(set4, set3) === false, 'sets with dotNotation properties are equivalent to sets with nested properties');
    });
    test('dotNotation set subset', function () {
        var alg = new set.Algebra(props.dotNotation('address.state'), props.dotNotation('address.city')), set1 = { 'address.state': 'IL' }, set2 = {
                'address.state': 'IL',
                'address.city': 'Chicago'
            }, set3 = {
                address: {
                    state: 'IL',
                    city: 'Chicago'
                }
            };
        ok(alg.subset(set2, set1), 'sets with dotNotation property is a subset of another dotNotation set');
        ok(alg.subset(set3, set1), 'sets with nested property notation is a subset of a dotNotation set');
        ok(alg.subset(set1, {}), 'sets with dotNotation properties are subsets of the universal set');
        ok(alg.subset({}, set1) === false, 'the universal set is not a subset of a set with dotNotation');
    });
});
/*can-set@1.5.1#src/prop_tests/id_test*/
define('can-set@1.5.1#src/prop_tests/id_test', [
    'require',
    'exports',
    'module',
    'steal-qunit',
    '../set-core',
    '../props'
], function (require, exports, module) {
    var QUnit = require('steal-qunit');
    var set = require('../set-core'), props = require('../props');
    QUnit.module('can-set props.id');
    test('id set.difference', function () {
        var idProps = props.id('color');
        var res;
        res = set.difference({ color: 'red' }, { color: 'blue' }, idProps);
        deepEqual(res, false, 'id changes always false');
        res = set.difference({ color: 'red' }, {}, idProps);
        deepEqual(res, false, 'id removal always false');
        res = set.difference({}, { color: 'blue' }, idProps);
        deepEqual(res, true, 'id addition always true');
    });
    test('id set.difference with where', function () {
        var algebra = new set.Algebra(props.id('color'), props.enum('type', [
            'light',
            'dark'
        ]));
        var res;
        res = set.difference({
            color: 'red',
            type: [
                'light',
                'dark'
            ]
        }, {
            color: 'blue',
            type: 'light'
        }, algebra);
        deepEqual(res, false, 'id changes always false');
        res = set.difference({
            color: 'red',
            type: [
                'light',
                'dark'
            ]
        }, { type: 'light' }, algebra);
        deepEqual(res, false, 'id removal always false');
        res = set.difference({
            type: [
                'light',
                'dark'
            ]
        }, {
            type: 'light',
            color: 'blue'
        }, algebra);
        deepEqual(res, true, 'id addition always true');
        res = set.difference({
            type: [
                'light',
                'dark'
            ]
        }, { type: 'light' }, algebra);
        deepEqual(res, { type: 'dark' }, 'no id clause, fall back to where');
        res = set.difference({
            color: 'red',
            type: [
                'light',
                'dark'
            ]
        }, {
            color: 'red',
            type: 'light'
        }, algebra);
        deepEqual(res, {
            color: 'red',
            type: 'dark'
        }, 'no id change, fall back to where');
    });
});
/*can-set@1.5.1#src/props_test*/
define('can-set@1.5.1#src/props_test', [
    'require',
    'exports',
    'module',
    'steal-qunit',
    './prop_tests/sort_test',
    './prop_tests/rangeInclusive_test',
    './prop_tests/offsetLimit_test',
    './prop_tests/boolean_test',
    './prop_tests/enum_test',
    './prop_tests/dotNotation_test',
    './prop_tests/id_test'
], function (require, exports, module) {
    var QUnit = require('steal-qunit');
    QUnit.module('can-set props');
    require('./prop_tests/sort_test');
    require('./prop_tests/rangeInclusive_test');
    require('./prop_tests/offsetLimit_test');
    require('./prop_tests/boolean_test');
    require('./prop_tests/enum_test');
    require('./prop_tests/dotNotation_test');
    require('./prop_tests/id_test');
});
/*can-set@1.5.1#src/set*/
define('can-set@1.5.1#src/set', [
    'require',
    'exports',
    'module',
    './set-core',
    'can-namespace',
    './props',
    './clause',
    './helpers'
], function (require, exports, module) {
    var set = require('./set-core');
    var ns = require('can-namespace');
    var props = require('./props');
    var clause = require('./clause');
    set.comparators = props;
    set.props = props;
    set.helpers = require('./helpers');
    set.clause = clause;
    module.exports = ns.set = set;
});
/*can-set@1.5.1#src/get_test*/
define('can-set@1.5.1#src/get_test', [
    'require',
    'exports',
    'module',
    './set',
    'steal-qunit',
    './props',
    './helpers',
    'can-assign'
], function (require, exports, module) {
    var set = require('./set');
    var QUnit = require('steal-qunit');
    var props = require('./props');
    var h = require('./helpers');
    var assign = require('can-assign');
    QUnit.module('can-set get');
    var getId = function (d) {
        return d.id;
    };
    var items = [
        {
            id: 0,
            note: 'C',
            type: 'eh'
        },
        {
            id: 1,
            note: 'D',
            type: 'critical'
        },
        {
            id: 2,
            note: 'E',
            type: 'critical'
        },
        {
            id: 3,
            note: 'F',
            type: 'eh'
        },
        {
            id: 4,
            note: 'G',
            type: 'critical'
        },
        {
            id: 5,
            note: 'A'
        },
        {
            id: 6,
            note: 'B',
            type: 'critical'
        },
        {
            id: 7,
            note: 'C',
            type: 'critical'
        }
    ];
    test('getSubset against non ranged set', function () {
        var res = set.getSubset({
            type: 'critical',
            start: 1,
            end: 3
        }, {}, items, props.rangeInclusive('start', 'end'));
        deepEqual(res && h.map.call(res, getId), [
            2,
            4,
            6
        ]);
    });
    test('getSubset ordered ascending and paginated', function () {
        var algebra = new set.Algebra(props.sort('sort'), props.rangeInclusive('start', 'end'));
        var res = set.getSubset({
            type: 'critical',
            start: 1,
            end: 3,
            sort: 'note AsC'
        }, {}, items, algebra);
        deepEqual(res && h.map.call(res, getId), [
            7,
            1,
            2
        ]);
    });
    test('getSubset ordered descending and paginated', function () {
        var algebra = new set.Algebra(props.sort('sort'), props.rangeInclusive('start', 'end'));
        var res = set.getSubset({
            type: 'critical',
            start: 1,
            end: 3,
            sort: 'note deSc'
        }, {}, items, algebra);
        deepEqual(res && h.map.call(res, getId), [
            2,
            1,
            7
        ]);
    });
    test('getSubset against paginated set', function () {
        var res = set.getSubset({
            type: 'critical',
            start: 21,
            end: 23
        }, {
            type: 'critical',
            start: 20,
            end: 27
        }, items, props.rangeInclusive('start', 'end'));
        deepEqual(res && h.map.call(res, getId), [
            2,
            4,
            6
        ]);
    });
    test('getSubset returns undefined against incompatible set', function () {
        var res = set.getSubset({ note: 'C' }, { type: 'critical' }, items);
        strictEqual(res, undefined);
    });
    test('getUnion basics', function () {
        var union = set.getUnion({}, { foo: 'bar' }, items, items.slice(0, 3));
        deepEqual(union, items);
    });
    test('getUnion against ranged sets', function () {
        var union = set.getUnion({
            start: 10,
            end: 13
        }, {
            start: 14,
            end: 17
        }, items.slice(0, 4), items.slice(4, 8), props.rangeInclusive('start', 'end'));
        deepEqual(union, items);
        union = set.getUnion({
            start: 14,
            end: 17
        }, {
            start: 10,
            end: 13
        }, items.slice(4, 8), items.slice(0, 4), props.rangeInclusive('start', 'end'));
        deepEqual(union, items, 'disjoint after');
    });
    test('getUnion against overlapping ranged sets', function () {
        var union = set.getUnion({
            start: 10,
            end: 14
        }, {
            start: 13,
            end: 17
        }, items.slice(0, 5), items.slice(3, 8), props.rangeInclusive('start', 'end'));
        deepEqual(union, items);
        union = set.getUnion({
            start: 10,
            end: 11
        }, {
            start: 11,
            end: 17
        }, items.slice(0, 2), items.slice(1, 8), props.rangeInclusive('start', 'end'));
        deepEqual(union, items);
        union = set.getUnion({
            start: 11,
            end: 17
        }, {
            start: 10,
            end: 11
        }, items.slice(1, 8), items.slice(0, 2), props.rangeInclusive('start', 'end'));
        deepEqual(union, items);
    });
    test('getUnion filters for uniqueness', function () {
        var aItems = items.filter(function (a) {
            return a.type === 'critical';
        });
        var bItems = items.filter(function (b) {
            return b.note === 'C';
        });
        var unionItems = aItems.concat([bItems[0]]);
        var union = set.getUnion({ type: 'critical' }, { note: 'C' }, aItems, bItems, props.id('id'));
        deepEqual(union, unionItems);
        union = set.getUnion({ type: 'critical' }, { note: 'C' }, aItems, bItems, {});
        deepEqual(union, unionItems);
        bItems = bItems.map(function (b) {
            return assign({}, b);
        });
        union = set.getUnion({ type: 'critical' }, { note: 'C' }, aItems, bItems, props.id('id'));
        deepEqual(union, unionItems);
    });
    test('getSubset passed same object works (#3)', function () {
        var algebra = new set.Algebra(props.rangeInclusive('start', 'end'));
        var setObj = {
            start: 1,
            end: 2
        };
        var items = algebra.getSubset(setObj, setObj, [{ id: 1 }]);
        deepEqual(items, [{ id: 1 }]);
    });
});
/*can-set@1.5.1#src/set_test*/
define('can-set@1.5.1#src/set_test', [
    'require',
    'exports',
    'module',
    'steal-qunit',
    './set'
], function (require, exports, module) {
    require('steal-qunit');
    var set = require('./set');
    QUnit.module('can-set');
    test('set.Algebra constructors', function () {
        var algebra = new set.Algebra(set.props.rangeInclusive('start', 'end'), set.props.boolean('completed'), set.props['enum']('type', [
            'new',
            'prep',
            'deliver',
            'delivered'
        ]));
        var res = algebra.subset({ type: ['new'] }, {
            type: [
                'new',
                'prep'
            ]
        });
        deepEqual(res, true, 'enum');
    });
    test('set.clause', function () {
        QUnit.ok(set.clause);
    });
});
/*can-set@1.5.1#test/test*/
define('can-set@1.5.1#test/test', [
    'require',
    'exports',
    'module',
    '../src/set-core_test',
    '../src/set-core-nested_test',
    '../src/props_test',
    '../src/get_test',
    '../src/set_test'
], function (require, exports, module) {
    require('../src/set-core_test');
    require('../src/set-core-nested_test');
    require('../src/props_test');
    require('../src/get_test');
    require('../src/set_test');
});
/*can-param@1.0.2#can-param*/
define('can-param@1.0.2#can-param', [
    'require',
    'exports',
    'module',
    'can-namespace'
], function (require, exports, module) {
    var namespace = require('can-namespace');
    function buildParam(prefix, obj, add) {
        if (Array.isArray(obj)) {
            for (var i = 0, l = obj.length; i < l; ++i) {
                add(prefix + '[]', obj[i]);
            }
        } else if (obj && typeof obj === 'object') {
            for (var name in obj) {
                buildParam(prefix + '[' + name + ']', obj[name], add);
            }
        } else {
            add(prefix, obj);
        }
    }
    module.exports = namespace.param = function param(object) {
        var pairs = [], add = function (key, value) {
                pairs.push(encodeURIComponent(key) + '=' + encodeURIComponent(value));
            };
        for (var name in object) {
            buildParam(name, object[name], add);
        }
        return pairs.join('&').replace(/%20/g, '+');
    };
});
/*can-ajax@1.1.4#can-ajax*/
define('can-ajax@1.1.4#can-ajax', [
    'require',
    'exports',
    'module',
    'can-globals/global/global',
    'can-reflect',
    'can-namespace',
    'can-parse-uri',
    'can-param'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        'use strict';
        var Global = require('can-globals/global/global');
        var canReflect = require('can-reflect');
        var namespace = require('can-namespace');
        var parseURI = require('can-parse-uri');
        var param = require('can-param');
        var xhrs = [
                function () {
                    return new XMLHttpRequest();
                },
                function () {
                    return new ActiveXObject('Microsoft.XMLHTTP');
                },
                function () {
                    return new ActiveXObject('MSXML2.XMLHTTP.3.0');
                },
                function () {
                    return new ActiveXObject('MSXML2.XMLHTTP');
                }
            ], _xhrf = null;
        var originUrl = parseURI(Global().location.href);
        var globalSettings = {};
        var makeXhr = function () {
            if (_xhrf != null) {
                return _xhrf();
            }
            for (var i = 0, l = xhrs.length; i < l; i++) {
                try {
                    var f = xhrs[i], req = f();
                    if (req != null) {
                        _xhrf = f;
                        return req;
                    }
                } catch (e) {
                    continue;
                }
            }
            return function () {
            };
        };
        var contentTypes = {
            json: 'application/json',
            form: 'application/x-www-form-urlencoded'
        };
        var _xhrResp = function (xhr, options) {
            switch (options.dataType || xhr.getResponseHeader('Content-Type').split(';')[0]) {
            case 'text/xml':
            case 'xml':
                return xhr.responseXML;
            case 'text/json':
            case 'application/json':
            case 'text/javascript':
            case 'application/javascript':
            case 'application/x-javascript':
            case 'json':
                return xhr.responseText && JSON.parse(xhr.responseText);
            default:
                return xhr.responseText;
            }
        };
        function ajax(o) {
            var xhr = makeXhr(), timer, n = 0;
            var deferred = {};
            var promise = new Promise(function (resolve, reject) {
                deferred.resolve = resolve;
                deferred.reject = reject;
            });
            var requestUrl;
            promise.abort = function () {
                xhr.abort();
            };
            o = [
                {
                    userAgent: 'XMLHttpRequest',
                    lang: 'en',
                    type: 'GET',
                    data: null,
                    dataType: 'json'
                },
                globalSettings,
                o
            ].reduce(function (a, b, i) {
                return canReflect.assignDeep(a, b);
            });
            if (!o.contentType) {
                o.contentType = o.type.toUpperCase() === 'GET' ? contentTypes.form : contentTypes.json;
            }
            if (o.crossDomain == null) {
                try {
                    requestUrl = parseURI(o.url);
                    o.crossDomain = !!(requestUrl.protocol && requestUrl.protocol !== originUrl.protocol || requestUrl.host && requestUrl.host !== originUrl.host);
                } catch (e) {
                    o.crossDomain = true;
                }
            }
            if (o.timeout) {
                timer = setTimeout(function () {
                    xhr.abort();
                    if (o.timeoutFn) {
                        o.timeoutFn(o.url);
                    }
                }, o.timeout);
            }
            xhr.onreadystatechange = function () {
                try {
                    if (xhr.readyState === 4) {
                        if (timer) {
                            clearTimeout(timer);
                        }
                        if (xhr.status < 300) {
                            if (o.success) {
                                o.success(_xhrResp(xhr, o));
                            }
                        } else if (o.error) {
                            o.error(xhr, xhr.status, xhr.statusText);
                        }
                        if (o.complete) {
                            o.complete(xhr, xhr.statusText);
                        }
                        if (xhr.status >= 200 && xhr.status < 300) {
                            deferred.resolve(_xhrResp(xhr, o));
                        } else {
                            deferred.reject(xhr);
                        }
                    } else if (o.progress) {
                        o.progress(++n);
                    }
                } catch (e) {
                    deferred.reject(e);
                }
            };
            var url = o.url, data = null, type = o.type.toUpperCase();
            var isJsonContentType = o.contentType === contentTypes.json;
            var isPost = type === 'POST' || type === 'PUT';
            if (!isPost && o.data) {
                url += '?' + (isJsonContentType ? JSON.stringify(o.data) : param(o.data));
            }
            xhr.open(type, url);
            var isSimpleCors = o.crossDomain && [
                'GET',
                'POST',
                'HEAD'
            ].indexOf(type) !== -1;
            if (isPost) {
                data = isJsonContentType && !isSimpleCors ? typeof o.data === 'object' ? JSON.stringify(o.data) : o.data : param(o.data);
                var setContentType = isJsonContentType && !isSimpleCors ? 'application/json' : 'application/x-www-form-urlencoded';
                xhr.setRequestHeader('Content-Type', setContentType);
            } else {
                xhr.setRequestHeader('Content-Type', o.contentType);
            }
            if (!isSimpleCors) {
                xhr.setRequestHeader('X-Requested-With', 'XMLHttpRequest');
            }
            if (o.xhrFields) {
                for (var f in o.xhrFields) {
                    xhr[f] = o.xhrFields[f];
                }
            }
            xhr.send(data);
            return promise;
        }
        module.exports = namespace.ajax = ajax;
        module.exports.ajaxSetup = function (o) {
            globalSettings = o || {};
        };
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-make-map@1.0.1#can-make-map*/
define('can-make-map@1.0.1#can-make-map', function (require, exports, module) {
    function makeMap(str) {
        var obj = {}, items = str.split(',');
        items.forEach(function (name) {
            obj[name] = true;
        });
        return obj;
    }
    module.exports = makeMap;
});
/*qunitjs@2.4.1#qunit/qunit*/
(function (global$1) {
    'use strict';
    global$1 = 'default' in global$1 ? global$1['default'] : global$1;
    var window = global$1.window;
    var self$1 = global$1.self;
    var console = global$1.console;
    var setTimeout = global$1.setTimeout;
    var clearTimeout = global$1.clearTimeout;
    var document = window && window.document;
    var navigator = window && window.navigator;
    var localSessionStorage = function () {
        var x = 'qunit-test-string';
        try {
            global$1.sessionStorage.setItem(x, x);
            global$1.sessionStorage.removeItem(x);
            return global$1.sessionStorage;
        } catch (e) {
            return undefined;
        }
    }();
    var _typeof = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? function (obj) {
        return typeof obj;
    } : function (obj) {
        return obj && typeof Symbol === 'function' && obj.constructor === Symbol && obj !== Symbol.prototype ? 'symbol' : typeof obj;
    };
    var classCallCheck = function (instance, Constructor) {
        if (!(instance instanceof Constructor)) {
            throw new TypeError('Cannot call a class as a function');
        }
    };
    var createClass = function () {
        function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ('value' in descriptor)
                    descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
            }
        }
        return function (Constructor, protoProps, staticProps) {
            if (protoProps)
                defineProperties(Constructor.prototype, protoProps);
            if (staticProps)
                defineProperties(Constructor, staticProps);
            return Constructor;
        };
    }();
    var toConsumableArray = function (arr) {
        if (Array.isArray(arr)) {
            for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++)
                arr2[i] = arr[i];
            return arr2;
        } else {
            return Array.from(arr);
        }
    };
    var toString = Object.prototype.toString;
    var hasOwn = Object.prototype.hasOwnProperty;
    var now = Date.now || function () {
        return new Date().getTime();
    };
    var defined = {
        document: window && window.document !== undefined,
        setTimeout: setTimeout !== undefined
    };
    function diff(a, b) {
        var i, j, result = a.slice();
        for (i = 0; i < result.length; i++) {
            for (j = 0; j < b.length; j++) {
                if (result[i] === b[j]) {
                    result.splice(i, 1);
                    i--;
                    break;
                }
            }
        }
        return result;
    }
    function inArray(elem, array) {
        return array.indexOf(elem) !== -1;
    }
    function objectValues(obj) {
        var key, val, vals = is('array', obj) ? [] : {};
        for (key in obj) {
            if (hasOwn.call(obj, key)) {
                val = obj[key];
                vals[key] = val === Object(val) ? objectValues(val) : val;
            }
        }
        return vals;
    }
    function extend(a, b, undefOnly) {
        for (var prop in b) {
            if (hasOwn.call(b, prop)) {
                if (b[prop] === undefined) {
                    delete a[prop];
                } else if (!(undefOnly && typeof a[prop] !== 'undefined')) {
                    a[prop] = b[prop];
                }
            }
        }
        return a;
    }
    function objectType(obj) {
        if (typeof obj === 'undefined') {
            return 'undefined';
        }
        if (obj === null) {
            return 'null';
        }
        var match = toString.call(obj).match(/^\[object\s(.*)\]$/), type = match && match[1];
        switch (type) {
        case 'Number':
            if (isNaN(obj)) {
                return 'nan';
            }
            return 'number';
        case 'String':
        case 'Boolean':
        case 'Array':
        case 'Set':
        case 'Map':
        case 'Date':
        case 'RegExp':
        case 'Function':
        case 'Symbol':
            return type.toLowerCase();
        default:
            return typeof obj === 'undefined' ? 'undefined' : _typeof(obj);
        }
    }
    function is(type, obj) {
        return objectType(obj) === type;
    }
    function generateHash(module, testName) {
        var str = module + '\x1C' + testName;
        var hash = 0;
        for (var i = 0; i < str.length; i++) {
            hash = (hash << 5) - hash + str.charCodeAt(i);
            hash |= 0;
        }
        var hex = (4294967296 + hash).toString(16);
        if (hex.length < 8) {
            hex = '0000000' + hex;
        }
        return hex.slice(-8);
    }
    var equiv = function () {
        var pairs = [];
        var getProto = Object.getPrototypeOf || function (obj) {
            return obj.__proto__;
        };
        function useStrictEquality(a, b) {
            if ((typeof a === 'undefined' ? 'undefined' : _typeof(a)) === 'object') {
                a = a.valueOf();
            }
            if ((typeof b === 'undefined' ? 'undefined' : _typeof(b)) === 'object') {
                b = b.valueOf();
            }
            return a === b;
        }
        function compareConstructors(a, b) {
            var protoA = getProto(a);
            var protoB = getProto(b);
            if (a.constructor === b.constructor) {
                return true;
            }
            if (protoA && protoA.constructor === null) {
                protoA = null;
            }
            if (protoB && protoB.constructor === null) {
                protoB = null;
            }
            if (protoA === null && protoB === Object.prototype || protoB === null && protoA === Object.prototype) {
                return true;
            }
            return false;
        }
        function getRegExpFlags(regexp) {
            return 'flags' in regexp ? regexp.flags : regexp.toString().match(/[gimuy]*$/)[0];
        }
        function isContainer(val) {
            return [
                'object',
                'array',
                'map',
                'set'
            ].indexOf(objectType(val)) !== -1;
        }
        function breadthFirstCompareChild(a, b) {
            if (a === b) {
                return true;
            }
            if (!isContainer(a)) {
                return typeEquiv(a, b);
            }
            if (pairs.every(function (pair) {
                    return pair.a !== a || pair.b !== b;
                })) {
                pairs.push({
                    a: a,
                    b: b
                });
            }
            return true;
        }
        var callbacks = {
            'string': useStrictEquality,
            'boolean': useStrictEquality,
            'number': useStrictEquality,
            'null': useStrictEquality,
            'undefined': useStrictEquality,
            'symbol': useStrictEquality,
            'date': useStrictEquality,
            'nan': function nan() {
                return true;
            },
            'regexp': function regexp(a, b) {
                return a.source === b.source && getRegExpFlags(a) === getRegExpFlags(b);
            },
            'function': function _function() {
                return false;
            },
            'array': function array(a, b) {
                var i, len;
                len = a.length;
                if (len !== b.length) {
                    return false;
                }
                for (i = 0; i < len; i++) {
                    if (!breadthFirstCompareChild(a[i], b[i])) {
                        return false;
                    }
                }
                return true;
            },
            'set': function set$$1(a, b) {
                var innerEq, outerEq = true;
                if (a.size !== b.size) {
                    return false;
                }
                a.forEach(function (aVal) {
                    if (!outerEq) {
                        return;
                    }
                    innerEq = false;
                    b.forEach(function (bVal) {
                        var parentPairs;
                        if (innerEq) {
                            return;
                        }
                        parentPairs = pairs;
                        if (innerEquiv(bVal, aVal)) {
                            innerEq = true;
                        }
                        pairs = parentPairs;
                    });
                    if (!innerEq) {
                        outerEq = false;
                    }
                });
                return outerEq;
            },
            'map': function map(a, b) {
                var innerEq, outerEq = true;
                if (a.size !== b.size) {
                    return false;
                }
                a.forEach(function (aVal, aKey) {
                    if (!outerEq) {
                        return;
                    }
                    innerEq = false;
                    b.forEach(function (bVal, bKey) {
                        var parentPairs;
                        if (innerEq) {
                            return;
                        }
                        parentPairs = pairs;
                        if (innerEquiv([
                                bVal,
                                bKey
                            ], [
                                aVal,
                                aKey
                            ])) {
                            innerEq = true;
                        }
                        pairs = parentPairs;
                    });
                    if (!innerEq) {
                        outerEq = false;
                    }
                });
                return outerEq;
            },
            'object': function object(a, b) {
                var i, aProperties = [], bProperties = [];
                if (compareConstructors(a, b) === false) {
                    return false;
                }
                for (i in a) {
                    aProperties.push(i);
                    if (a.constructor !== Object && typeof a.constructor !== 'undefined' && typeof a[i] === 'function' && typeof b[i] === 'function' && a[i].toString() === b[i].toString()) {
                        continue;
                    }
                    if (!breadthFirstCompareChild(a[i], b[i])) {
                        return false;
                    }
                }
                for (i in b) {
                    bProperties.push(i);
                }
                return typeEquiv(aProperties.sort(), bProperties.sort());
            }
        };
        function typeEquiv(a, b) {
            var type = objectType(a);
            return objectType(b) === type && callbacks[type](a, b);
        }
        function innerEquiv(a, b) {
            var i, pair;
            if (arguments.length < 2) {
                return true;
            }
            pairs = [{
                    a: a,
                    b: b
                }];
            for (i = 0; i < pairs.length; i++) {
                pair = pairs[i];
                if (pair.a !== pair.b && !typeEquiv(pair.a, pair.b)) {
                    return false;
                }
            }
            return arguments.length === 2 || innerEquiv.apply(this, [].slice.call(arguments, 1));
        }
        return function () {
            var result = innerEquiv.apply(undefined, arguments);
            pairs.length = 0;
            return result;
        };
    }();
    var config = {
        queue: [],
        blocking: true,
        reorder: true,
        altertitle: true,
        collapse: true,
        scrolltop: true,
        maxDepth: 5,
        requireExpects: false,
        urlConfig: [],
        modules: [],
        currentModule: {
            name: '',
            tests: [],
            childModules: [],
            testsRun: 0,
            unskippedTestsRun: 0,
            hooks: {
                before: [],
                beforeEach: [],
                afterEach: [],
                after: []
            }
        },
        callbacks: {},
        storage: localSessionStorage
    };
    var globalConfig = window && window.QUnit && window.QUnit.config;
    if (window && window.QUnit && !window.QUnit.version) {
        extend(config, globalConfig);
    }
    config.modules.push(config.currentModule);
    var dump = function () {
        function quote(str) {
            return '"' + str.toString().replace(/\\/g, '\\\\').replace(/"/g, '\\"') + '"';
        }
        function literal(o) {
            return o + '';
        }
        function join(pre, arr, post) {
            var s = dump.separator(), base = dump.indent(), inner = dump.indent(1);
            if (arr.join) {
                arr = arr.join(',' + s + inner);
            }
            if (!arr) {
                return pre + post;
            }
            return [
                pre,
                inner + arr,
                base + post
            ].join(s);
        }
        function array(arr, stack) {
            var i = arr.length, ret = new Array(i);
            if (dump.maxDepth && dump.depth > dump.maxDepth) {
                return '[object Array]';
            }
            this.up();
            while (i--) {
                ret[i] = this.parse(arr[i], undefined, stack);
            }
            this.down();
            return join('[', ret, ']');
        }
        function isArray(obj) {
            return toString.call(obj) === '[object Array]' || typeof obj.length === 'number' && obj.item !== undefined && (obj.length ? obj.item(0) === obj[0] : obj.item(0) === null && obj[0] === undefined);
        }
        var reName = /^function (\w+)/, dump = {
                parse: function parse(obj, objType, stack) {
                    stack = stack || [];
                    var res, parser, parserType, objIndex = stack.indexOf(obj);
                    if (objIndex !== -1) {
                        return 'recursion(' + (objIndex - stack.length) + ')';
                    }
                    objType = objType || this.typeOf(obj);
                    parser = this.parsers[objType];
                    parserType = typeof parser === 'undefined' ? 'undefined' : _typeof(parser);
                    if (parserType === 'function') {
                        stack.push(obj);
                        res = parser.call(this, obj, stack);
                        stack.pop();
                        return res;
                    }
                    return parserType === 'string' ? parser : this.parsers.error;
                },
                typeOf: function typeOf(obj) {
                    var type;
                    if (obj === null) {
                        type = 'null';
                    } else if (typeof obj === 'undefined') {
                        type = 'undefined';
                    } else if (is('regexp', obj)) {
                        type = 'regexp';
                    } else if (is('date', obj)) {
                        type = 'date';
                    } else if (is('function', obj)) {
                        type = 'function';
                    } else if (obj.setInterval !== undefined && obj.document !== undefined && obj.nodeType === undefined) {
                        type = 'window';
                    } else if (obj.nodeType === 9) {
                        type = 'document';
                    } else if (obj.nodeType) {
                        type = 'node';
                    } else if (isArray(obj)) {
                        type = 'array';
                    } else if (obj.constructor === Error.prototype.constructor) {
                        type = 'error';
                    } else {
                        type = typeof obj === 'undefined' ? 'undefined' : _typeof(obj);
                    }
                    return type;
                },
                separator: function separator() {
                    if (this.multiline) {
                        return this.HTML ? '<br />' : '\n';
                    } else {
                        return this.HTML ? '&#160;' : ' ';
                    }
                },
                indent: function indent(extra) {
                    if (!this.multiline) {
                        return '';
                    }
                    var chr = this.indentChar;
                    if (this.HTML) {
                        chr = chr.replace(/\t/g, '   ').replace(/ /g, '&#160;');
                    }
                    return new Array(this.depth + (extra || 0)).join(chr);
                },
                up: function up(a) {
                    this.depth += a || 1;
                },
                down: function down(a) {
                    this.depth -= a || 1;
                },
                setParser: function setParser(name, parser) {
                    this.parsers[name] = parser;
                },
                quote: quote,
                literal: literal,
                join: join,
                depth: 1,
                maxDepth: config.maxDepth,
                parsers: {
                    window: '[Window]',
                    document: '[Document]',
                    error: function error(_error) {
                        return 'Error("' + _error.message + '")';
                    },
                    unknown: '[Unknown]',
                    'null': 'null',
                    'undefined': 'undefined',
                    'function': function _function(fn) {
                        var ret = 'function', name = 'name' in fn ? fn.name : (reName.exec(fn) || [])[1];
                        if (name) {
                            ret += ' ' + name;
                        }
                        ret += '(';
                        ret = [
                            ret,
                            dump.parse(fn, 'functionArgs'),
                            '){'
                        ].join('');
                        return join(ret, dump.parse(fn, 'functionCode'), '}');
                    },
                    array: array,
                    nodelist: array,
                    'arguments': array,
                    object: function object(map, stack) {
                        var keys, key, val, i, nonEnumerableProperties, ret = [];
                        if (dump.maxDepth && dump.depth > dump.maxDepth) {
                            return '[object Object]';
                        }
                        dump.up();
                        keys = [];
                        for (key in map) {
                            keys.push(key);
                        }
                        nonEnumerableProperties = [
                            'message',
                            'name'
                        ];
                        for (i in nonEnumerableProperties) {
                            key = nonEnumerableProperties[i];
                            if (key in map && !inArray(key, keys)) {
                                keys.push(key);
                            }
                        }
                        keys.sort();
                        for (i = 0; i < keys.length; i++) {
                            key = keys[i];
                            val = map[key];
                            ret.push(dump.parse(key, 'key') + ': ' + dump.parse(val, undefined, stack));
                        }
                        dump.down();
                        return join('{', ret, '}');
                    },
                    node: function node(_node) {
                        var len, i, val, open = dump.HTML ? '&lt;' : '<', close = dump.HTML ? '&gt;' : '>', tag = _node.nodeName.toLowerCase(), ret = open + tag, attrs = _node.attributes;
                        if (attrs) {
                            for (i = 0, len = attrs.length; i < len; i++) {
                                val = attrs[i].nodeValue;
                                if (val && val !== 'inherit') {
                                    ret += ' ' + attrs[i].nodeName + '=' + dump.parse(val, 'attribute');
                                }
                            }
                        }
                        ret += close;
                        if (_node.nodeType === 3 || _node.nodeType === 4) {
                            ret += _node.nodeValue;
                        }
                        return ret + open + '/' + tag + close;
                    },
                    functionArgs: function functionArgs(fn) {
                        var args, l = fn.length;
                        if (!l) {
                            return '';
                        }
                        args = new Array(l);
                        while (l--) {
                            args[l] = String.fromCharCode(97 + l);
                        }
                        return ' ' + args.join(', ') + ' ';
                    },
                    key: quote,
                    functionCode: '[code]',
                    attribute: quote,
                    string: quote,
                    date: quote,
                    regexp: literal,
                    number: literal,
                    'boolean': literal,
                    symbol: function symbol(sym) {
                        return sym.toString();
                    }
                },
                HTML: false,
                indentChar: '  ',
                multiline: true
            };
        return dump;
    }();
    var LISTENERS = Object.create(null);
    var SUPPORTED_EVENTS = [
        'runStart',
        'suiteStart',
        'testStart',
        'assertion',
        'testEnd',
        'suiteEnd',
        'runEnd'
    ];
    function emit(eventName, data) {
        if (objectType(eventName) !== 'string') {
            throw new TypeError('eventName must be a string when emitting an event');
        }
        var originalCallbacks = LISTENERS[eventName];
        var callbacks = originalCallbacks ? [].concat(toConsumableArray(originalCallbacks)) : [];
        for (var i = 0; i < callbacks.length; i++) {
            callbacks[i](data);
        }
    }
    function on(eventName, callback) {
        if (objectType(eventName) !== 'string') {
            throw new TypeError('eventName must be a string when registering a listener');
        } else if (!inArray(eventName, SUPPORTED_EVENTS)) {
            var events = SUPPORTED_EVENTS.join(', ');
            throw new Error('"' + eventName + '" is not a valid event; must be one of: ' + events + '.');
        } else if (objectType(callback) !== 'function') {
            throw new TypeError('callback must be a function when registering a listener');
        }
        if (!LISTENERS[eventName]) {
            LISTENERS[eventName] = [];
        }
        if (!inArray(callback, LISTENERS[eventName])) {
            LISTENERS[eventName].push(callback);
        }
    }
    function registerLoggingCallbacks(obj) {
        var i, l, key, callbackNames = [
                'begin',
                'done',
                'log',
                'testStart',
                'testDone',
                'moduleStart',
                'moduleDone'
            ];
        function registerLoggingCallback(key) {
            var loggingCallback = function loggingCallback(callback) {
                if (objectType(callback) !== 'function') {
                    throw new Error('QUnit logging methods require a callback function as their first parameters.');
                }
                config.callbacks[key].push(callback);
            };
            return loggingCallback;
        }
        for (i = 0, l = callbackNames.length; i < l; i++) {
            key = callbackNames[i];
            if (objectType(config.callbacks[key]) === 'undefined') {
                config.callbacks[key] = [];
            }
            obj[key] = registerLoggingCallback(key);
        }
    }
    function runLoggingCallbacks(key, args) {
        var i, l, callbacks;
        callbacks = config.callbacks[key];
        for (i = 0, l = callbacks.length; i < l; i++) {
            callbacks[i](args);
        }
    }
    var fileName = (sourceFromStacktrace(0) || '').replace(/(:\d+)+\)?/, '').replace(/.+\//, '');
    function extractStacktrace(e, offset) {
        offset = offset === undefined ? 4 : offset;
        var stack, include, i;
        if (e && e.stack) {
            stack = e.stack.split('\n');
            if (/^error$/i.test(stack[0])) {
                stack.shift();
            }
            if (fileName) {
                include = [];
                for (i = offset; i < stack.length; i++) {
                    if (stack[i].indexOf(fileName) !== -1) {
                        break;
                    }
                    include.push(stack[i]);
                }
                if (include.length) {
                    return include.join('\n');
                }
            }
            return stack[offset];
        }
    }
    function sourceFromStacktrace(offset) {
        var error = new Error();
        if (!error.stack) {
            try {
                throw error;
            } catch (err) {
                error = err;
            }
        }
        return extractStacktrace(error, offset);
    }
    var priorityCount = 0;
    var unitSampler = void 0;
    function advance() {
        var start = now();
        config.depth = (config.depth || 0) + 1;
        while (config.queue.length && !config.blocking) {
            var elapsedTime = now() - start;
            if (!defined.setTimeout || config.updateRate <= 0 || elapsedTime < config.updateRate) {
                if (priorityCount > 0) {
                    priorityCount--;
                }
                config.queue.shift()();
            } else {
                setTimeout(advance, 13);
                break;
            }
        }
        config.depth--;
        if (!config.blocking && !config.queue.length && config.depth === 0) {
            done();
        }
    }
    function addToQueueImmediate(callback) {
        if (objectType(callback) === 'array') {
            while (callback.length) {
                addToQueueImmediate(callback.pop());
            }
            return;
        }
        config.queue.unshift(callback);
        priorityCount++;
    }
    function addToQueue(callback, prioritize, seed) {
        if (prioritize) {
            config.queue.splice(priorityCount++, 0, callback);
        } else if (seed) {
            if (!unitSampler) {
                unitSampler = unitSamplerGenerator(seed);
            }
            var index = Math.floor(unitSampler() * (config.queue.length - priorityCount + 1));
            config.queue.splice(priorityCount + index, 0, callback);
        } else {
            config.queue.push(callback);
        }
    }
    function unitSamplerGenerator(seed) {
        var sample = parseInt(generateHash(seed), 16) || -1;
        return function () {
            sample ^= sample << 13;
            sample ^= sample >>> 17;
            sample ^= sample << 5;
            if (sample < 0) {
                sample += 4294967296;
            }
            return sample / 4294967296;
        };
    }
    function done() {
        var storage = config.storage;
        ProcessingQueue.finished = true;
        var runtime = now() - config.started;
        var passed = config.stats.all - config.stats.bad;
        emit('runEnd', globalSuite.end(true));
        runLoggingCallbacks('done', {
            passed: passed,
            failed: config.stats.bad,
            total: config.stats.all,
            runtime: runtime
        });
        if (storage && config.stats.bad === 0) {
            for (var i = storage.length - 1; i >= 0; i--) {
                var key = storage.key(i);
                if (key.indexOf('qunit-test-') === 0) {
                    storage.removeItem(key);
                }
            }
        }
    }
    var ProcessingQueue = {
        finished: false,
        add: addToQueue,
        addImmediate: addToQueueImmediate,
        advance: advance
    };
    var TestReport = function () {
        function TestReport(name, suite, options) {
            classCallCheck(this, TestReport);
            this.name = name;
            this.suiteName = suite.name;
            this.fullName = suite.fullName.concat(name);
            this.runtime = 0;
            this.assertions = [];
            this.skipped = !!options.skip;
            this.todo = !!options.todo;
            this.valid = options.valid;
            this._startTime = 0;
            this._endTime = 0;
            suite.pushTest(this);
        }
        createClass(TestReport, [
            {
                key: 'start',
                value: function start(recordTime) {
                    if (recordTime) {
                        this._startTime = Date.now();
                    }
                    return {
                        name: this.name,
                        suiteName: this.suiteName,
                        fullName: this.fullName.slice()
                    };
                }
            },
            {
                key: 'end',
                value: function end(recordTime) {
                    if (recordTime) {
                        this._endTime = Date.now();
                    }
                    return extend(this.start(), {
                        runtime: this.getRuntime(),
                        status: this.getStatus(),
                        errors: this.getFailedAssertions(),
                        assertions: this.getAssertions()
                    });
                }
            },
            {
                key: 'pushAssertion',
                value: function pushAssertion(assertion) {
                    this.assertions.push(assertion);
                }
            },
            {
                key: 'getRuntime',
                value: function getRuntime() {
                    return this._endTime - this._startTime;
                }
            },
            {
                key: 'getStatus',
                value: function getStatus() {
                    if (this.skipped) {
                        return 'skipped';
                    }
                    var testPassed = this.getFailedAssertions().length > 0 ? this.todo : !this.todo;
                    if (!testPassed) {
                        return 'failed';
                    } else if (this.todo) {
                        return 'todo';
                    } else {
                        return 'passed';
                    }
                }
            },
            {
                key: 'getFailedAssertions',
                value: function getFailedAssertions() {
                    return this.assertions.filter(function (assertion) {
                        return !assertion.passed;
                    });
                }
            },
            {
                key: 'getAssertions',
                value: function getAssertions() {
                    return this.assertions.slice();
                }
            },
            {
                key: 'slimAssertions',
                value: function slimAssertions() {
                    this.assertions = this.assertions.map(function (assertion) {
                        delete assertion.actual;
                        delete assertion.expected;
                        return assertion;
                    });
                }
            }
        ]);
        return TestReport;
    }();
    var focused$1 = false;
    function Test(settings) {
        var i, l;
        ++Test.count;
        this.expected = null;
        this.assertions = [];
        this.semaphore = 0;
        this.module = config.currentModule;
        this.stack = sourceFromStacktrace(3);
        this.steps = [];
        this.timeout = undefined;
        if (this.module.skip) {
            settings.skip = true;
            settings.todo = false;
        } else if (this.module.todo && !settings.skip) {
            settings.todo = true;
        }
        extend(this, settings);
        this.testReport = new TestReport(settings.testName, this.module.suiteReport, {
            todo: settings.todo,
            skip: settings.skip,
            valid: this.valid()
        });
        for (i = 0, l = this.module.tests; i < l.length; i++) {
            if (this.module.tests[i].name === this.testName) {
                this.testName += ' ';
            }
        }
        this.testId = generateHash(this.module.name, this.testName);
        this.module.tests.push({
            name: this.testName,
            testId: this.testId,
            skip: !!settings.skip
        });
        if (settings.skip) {
            this.callback = function () {
            };
            this.async = false;
            this.expected = 0;
        } else {
            if (typeof this.callback !== 'function') {
                var method = this.todo ? 'todo' : 'test';
                throw new TypeError('You must provide a function as a test callback to QUnit.' + method + '("' + settings.testName + '")');
            }
            this.assert = new Assert(this);
        }
    }
    Test.count = 0;
    function getNotStartedModules(startModule) {
        var module = startModule, modules = [];
        while (module && module.testsRun === 0) {
            modules.push(module);
            module = module.parentModule;
        }
        return modules;
    }
    Test.prototype = {
        before: function before() {
            var i, startModule, module = this.module, notStartedModules = getNotStartedModules(module);
            for (i = notStartedModules.length - 1; i >= 0; i--) {
                startModule = notStartedModules[i];
                startModule.stats = {
                    all: 0,
                    bad: 0,
                    started: now()
                };
                emit('suiteStart', startModule.suiteReport.start(true));
                runLoggingCallbacks('moduleStart', {
                    name: startModule.name,
                    tests: startModule.tests
                });
            }
            config.current = this;
            this.testEnvironment = extend({}, module.testEnvironment);
            this.started = now();
            emit('testStart', this.testReport.start(true));
            runLoggingCallbacks('testStart', {
                name: this.testName,
                module: module.name,
                testId: this.testId,
                previousFailure: this.previousFailure
            });
            if (!config.pollution) {
                saveGlobal();
            }
        },
        run: function run() {
            var promise;
            config.current = this;
            this.callbackStarted = now();
            if (config.notrycatch) {
                runTest(this);
                return;
            }
            try {
                runTest(this);
            } catch (e) {
                this.pushFailure('Died on test #' + (this.assertions.length + 1) + ' ' + this.stack + ': ' + (e.message || e), extractStacktrace(e, 0));
                saveGlobal();
                if (config.blocking) {
                    internalRecover(this);
                }
            }
            function runTest(test) {
                promise = test.callback.call(test.testEnvironment, test.assert);
                test.resolvePromise(promise);
                if (test.timeout === 0 && test.semaphore !== 0) {
                    pushFailure('Test did not finish synchronously even though assert.timeout( 0 ) was used.', sourceFromStacktrace(2));
                }
            }
        },
        after: function after() {
            checkPollution();
        },
        queueHook: function queueHook(hook, hookName, hookOwner) {
            var _this = this;
            var callHook = function callHook() {
                var promise = hook.call(_this.testEnvironment, _this.assert);
                _this.resolvePromise(promise, hookName);
            };
            var runHook = function runHook() {
                if (hookName === 'before') {
                    if (hookOwner.unskippedTestsRun !== 0) {
                        return;
                    }
                    _this.preserveEnvironment = true;
                }
                if (hookName === 'after' && hookOwner.unskippedTestsRun !== numberOfUnskippedTests(hookOwner) - 1 && config.queue.length > 2) {
                    return;
                }
                config.current = _this;
                if (config.notrycatch) {
                    callHook();
                    return;
                }
                try {
                    callHook();
                } catch (error) {
                    _this.pushFailure(hookName + ' failed on ' + _this.testName + ': ' + (error.message || error), extractStacktrace(error, 0));
                }
            };
            return runHook;
        },
        hooks: function hooks(handler) {
            var hooks = [];
            function processHooks(test, module) {
                if (module.parentModule) {
                    processHooks(test, module.parentModule);
                }
                if (module.hooks[handler].length) {
                    for (var i = 0; i < module.hooks[handler].length; i++) {
                        hooks.push(test.queueHook(module.hooks[handler][i], handler, module));
                    }
                }
            }
            if (!this.skip) {
                processHooks(this, this.module);
            }
            return hooks;
        },
        finish: function finish() {
            config.current = this;
            if (config.requireExpects && this.expected === null) {
                this.pushFailure('Expected number of assertions to be defined, but expect() was ' + 'not called.', this.stack);
            } else if (this.expected !== null && this.expected !== this.assertions.length) {
                this.pushFailure('Expected ' + this.expected + ' assertions, but ' + this.assertions.length + ' were run', this.stack);
            } else if (this.expected === null && !this.assertions.length) {
                this.pushFailure('Expected at least one assertion, but none were run - call ' + 'expect(0) to accept zero assertions.', this.stack);
            }
            var i, module = this.module, moduleName = module.name, testName = this.testName, skipped = !!this.skip, todo = !!this.todo, bad = 0, storage = config.storage;
            this.runtime = now() - this.started;
            config.stats.all += this.assertions.length;
            module.stats.all += this.assertions.length;
            for (i = 0; i < this.assertions.length; i++) {
                if (!this.assertions[i].result) {
                    bad++;
                    config.stats.bad++;
                    module.stats.bad++;
                }
            }
            notifyTestsRan(module, skipped);
            if (storage) {
                if (bad) {
                    storage.setItem('qunit-test-' + moduleName + '-' + testName, bad);
                } else {
                    storage.removeItem('qunit-test-' + moduleName + '-' + testName);
                }
            }
            emit('testEnd', this.testReport.end(true));
            this.testReport.slimAssertions();
            runLoggingCallbacks('testDone', {
                name: testName,
                module: moduleName,
                skipped: skipped,
                todo: todo,
                failed: bad,
                passed: this.assertions.length - bad,
                total: this.assertions.length,
                runtime: skipped ? 0 : this.runtime,
                assertions: this.assertions,
                testId: this.testId,
                source: this.stack
            });
            if (module.testsRun === numberOfTests(module)) {
                logSuiteEnd(module);
                var parent = module.parentModule;
                while (parent && parent.testsRun === numberOfTests(parent)) {
                    logSuiteEnd(parent);
                    parent = parent.parentModule;
                }
            }
            config.current = undefined;
            function logSuiteEnd(module) {
                emit('suiteEnd', module.suiteReport.end(true));
                runLoggingCallbacks('moduleDone', {
                    name: module.name,
                    tests: module.tests,
                    failed: module.stats.bad,
                    passed: module.stats.all - module.stats.bad,
                    total: module.stats.all,
                    runtime: now() - module.stats.started
                });
            }
        },
        preserveTestEnvironment: function preserveTestEnvironment() {
            if (this.preserveEnvironment) {
                this.module.testEnvironment = this.testEnvironment;
                this.testEnvironment = extend({}, this.module.testEnvironment);
            }
        },
        queue: function queue() {
            var test = this;
            if (!this.valid()) {
                return;
            }
            function runTest() {
                ProcessingQueue.addImmediate([
                    function () {
                        test.before();
                    },
                    test.hooks('before'),
                    function () {
                        test.preserveTestEnvironment();
                    },
                    test.hooks('beforeEach'),
                    function () {
                        test.run();
                    },
                    test.hooks('afterEach').reverse(),
                    test.hooks('after').reverse(),
                    function () {
                        test.after();
                    },
                    function () {
                        test.finish();
                    }
                ]);
            }
            var previousFailCount = config.storage && +config.storage.getItem('qunit-test-' + this.module.name + '-' + this.testName);
            var prioritize = config.reorder && !!previousFailCount;
            this.previousFailure = !!previousFailCount;
            ProcessingQueue.add(runTest, prioritize, config.seed);
            if (ProcessingQueue.finished) {
                ProcessingQueue.advance();
            }
        },
        pushResult: function pushResult(resultInfo) {
            if (this !== config.current) {
                throw new Error('Assertion occured after test had finished.');
            }
            var source, details = {
                    module: this.module.name,
                    name: this.testName,
                    result: resultInfo.result,
                    message: resultInfo.message,
                    actual: resultInfo.actual,
                    testId: this.testId,
                    negative: resultInfo.negative || false,
                    runtime: now() - this.started,
                    todo: !!this.todo
                };
            if (hasOwn.call(resultInfo, 'expected')) {
                details.expected = resultInfo.expected;
            }
            if (!resultInfo.result) {
                source = resultInfo.source || sourceFromStacktrace();
                if (source) {
                    details.source = source;
                }
            }
            this.logAssertion(details);
            this.assertions.push({
                result: !!resultInfo.result,
                message: resultInfo.message
            });
        },
        pushFailure: function pushFailure(message, source, actual) {
            if (!(this instanceof Test)) {
                throw new Error('pushFailure() assertion outside test context, was ' + sourceFromStacktrace(2));
            }
            this.pushResult({
                result: false,
                message: message || 'error',
                actual: actual || null,
                source: source
            });
        },
        logAssertion: function logAssertion(details) {
            runLoggingCallbacks('log', details);
            var assertion = {
                passed: details.result,
                actual: details.actual,
                expected: details.expected,
                message: details.message,
                stack: details.source,
                todo: details.todo
            };
            this.testReport.pushAssertion(assertion);
            emit('assertion', assertion);
        },
        resolvePromise: function resolvePromise(promise, phase) {
            var then, resume, message, test = this;
            if (promise != null) {
                then = promise.then;
                if (objectType(then) === 'function') {
                    resume = internalStop(test);
                    then.call(promise, function () {
                        resume();
                    }, function (error) {
                        message = 'Promise rejected ' + (!phase ? 'during' : phase.replace(/Each$/, '')) + ' "' + test.testName + '": ' + (error && error.message || error);
                        test.pushFailure(message, extractStacktrace(error, 0));
                        saveGlobal();
                        resume();
                    });
                }
            }
        },
        valid: function valid() {
            var filter = config.filter, regexFilter = /^(!?)\/([\w\W]*)\/(i?$)/.exec(filter), module = config.module && config.module.toLowerCase(), fullName = this.module.name + ': ' + this.testName;
            function moduleChainNameMatch(testModule) {
                var testModuleName = testModule.name ? testModule.name.toLowerCase() : null;
                if (testModuleName === module) {
                    return true;
                } else if (testModule.parentModule) {
                    return moduleChainNameMatch(testModule.parentModule);
                } else {
                    return false;
                }
            }
            function moduleChainIdMatch(testModule) {
                return inArray(testModule.moduleId, config.moduleId) || testModule.parentModule && moduleChainIdMatch(testModule.parentModule);
            }
            if (this.callback && this.callback.validTest) {
                return true;
            }
            if (config.moduleId && config.moduleId.length > 0 && !moduleChainIdMatch(this.module)) {
                return false;
            }
            if (config.testId && config.testId.length > 0 && !inArray(this.testId, config.testId)) {
                return false;
            }
            if (module && !moduleChainNameMatch(this.module)) {
                return false;
            }
            if (!filter) {
                return true;
            }
            return regexFilter ? this.regexFilter(!!regexFilter[1], regexFilter[2], regexFilter[3], fullName) : this.stringFilter(filter, fullName);
        },
        regexFilter: function regexFilter(exclude, pattern, flags, fullName) {
            var regex = new RegExp(pattern, flags);
            var match = regex.test(fullName);
            return match !== exclude;
        },
        stringFilter: function stringFilter(filter, fullName) {
            filter = filter.toLowerCase();
            fullName = fullName.toLowerCase();
            var include = filter.charAt(0) !== '!';
            if (!include) {
                filter = filter.slice(1);
            }
            if (fullName.indexOf(filter) !== -1) {
                return include;
            }
            return !include;
        }
    };
    function pushFailure() {
        if (!config.current) {
            throw new Error('pushFailure() assertion outside test context, in ' + sourceFromStacktrace(2));
        }
        var currentTest = config.current;
        return currentTest.pushFailure.apply(currentTest, arguments);
    }
    function saveGlobal() {
        config.pollution = [];
        if (config.noglobals) {
            for (var key in global$1) {
                if (hasOwn.call(global$1, key)) {
                    if (/^qunit-test-output/.test(key)) {
                        continue;
                    }
                    config.pollution.push(key);
                }
            }
        }
    }
    function checkPollution() {
        var newGlobals, deletedGlobals, old = config.pollution;
        saveGlobal();
        newGlobals = diff(config.pollution, old);
        if (newGlobals.length > 0) {
            pushFailure('Introduced global variable(s): ' + newGlobals.join(', '));
        }
        deletedGlobals = diff(old, config.pollution);
        if (deletedGlobals.length > 0) {
            pushFailure('Deleted global variable(s): ' + deletedGlobals.join(', '));
        }
    }
    function test(testName, callback) {
        if (focused$1) {
            return;
        }
        var newTest = new Test({
            testName: testName,
            callback: callback
        });
        newTest.queue();
    }
    function todo(testName, callback) {
        if (focused$1) {
            return;
        }
        var newTest = new Test({
            testName: testName,
            callback: callback,
            todo: true
        });
        newTest.queue();
    }
    function skip(testName) {
        if (focused$1) {
            return;
        }
        var test = new Test({
            testName: testName,
            skip: true
        });
        test.queue();
    }
    function only(testName, callback) {
        if (focused$1) {
            return;
        }
        config.queue.length = 0;
        focused$1 = true;
        var newTest = new Test({
            testName: testName,
            callback: callback
        });
        newTest.queue();
    }
    function internalStop(test) {
        test.semaphore += 1;
        config.blocking = true;
        if (defined.setTimeout) {
            var timeoutDuration = void 0;
            if (typeof test.timeout === 'number') {
                timeoutDuration = test.timeout;
            } else if (typeof config.testTimeout === 'number') {
                timeoutDuration = config.testTimeout;
            }
            if (typeof timeoutDuration === 'number' && timeoutDuration > 0) {
                clearTimeout(config.timeout);
                config.timeout = setTimeout(function () {
                    pushFailure('Test took longer than ' + timeoutDuration + 'ms; test timed out.', sourceFromStacktrace(2));
                    internalRecover(test);
                }, timeoutDuration);
            }
        }
        var released = false;
        return function resume() {
            if (released) {
                return;
            }
            released = true;
            test.semaphore -= 1;
            internalStart(test);
        };
    }
    function internalRecover(test) {
        test.semaphore = 0;
        internalStart(test);
    }
    function internalStart(test) {
        if (isNaN(test.semaphore)) {
            test.semaphore = 0;
            pushFailure('Invalid value on test.semaphore', sourceFromStacktrace(2));
            return;
        }
        if (test.semaphore > 0) {
            return;
        }
        if (test.semaphore < 0) {
            test.semaphore = 0;
            pushFailure('Tried to restart test while already started (test\'s semaphore was 0 already)', sourceFromStacktrace(2));
            return;
        }
        if (defined.setTimeout) {
            if (config.timeout) {
                clearTimeout(config.timeout);
            }
            config.timeout = setTimeout(function () {
                if (test.semaphore > 0) {
                    return;
                }
                if (config.timeout) {
                    clearTimeout(config.timeout);
                }
                begin();
            }, 13);
        } else {
            begin();
        }
    }
    function collectTests(module) {
        var tests = [].concat(module.tests);
        var modules = [].concat(toConsumableArray(module.childModules));
        while (modules.length) {
            var nextModule = modules.shift();
            tests.push.apply(tests, nextModule.tests);
            modules.push.apply(modules, toConsumableArray(nextModule.childModules));
        }
        return tests;
    }
    function numberOfTests(module) {
        return collectTests(module).length;
    }
    function numberOfUnskippedTests(module) {
        return collectTests(module).filter(function (test) {
            return !test.skip;
        }).length;
    }
    function notifyTestsRan(module, skipped) {
        module.testsRun++;
        if (!skipped) {
            module.unskippedTestsRun++;
        }
        while (module = module.parentModule) {
            module.testsRun++;
            if (!skipped) {
                module.unskippedTestsRun++;
            }
        }
    }
    function consoleProxy(method) {
        return function () {
            if (console) {
                console[method].apply(console, arguments);
            }
        };
    }
    var Logger = { warn: consoleProxy('warn') };
    var Assert = function () {
        function Assert(testContext) {
            classCallCheck(this, Assert);
            this.test = testContext;
        }
        createClass(Assert, [
            {
                key: 'timeout',
                value: function timeout(duration) {
                    if (typeof duration !== 'number') {
                        throw new Error('You must pass a number as the duration to assert.timeout');
                    }
                    this.test.timeout = duration;
                }
            },
            {
                key: 'step',
                value: function step(message) {
                    var result = !!message;
                    this.test.steps.push(message);
                    return this.pushResult({
                        result: result,
                        message: message || 'You must provide a message to assert.step'
                    });
                }
            },
            {
                key: 'verifySteps',
                value: function verifySteps(steps, message) {
                    this.deepEqual(this.test.steps, steps, message);
                }
            },
            {
                key: 'expect',
                value: function expect(asserts) {
                    if (arguments.length === 1) {
                        this.test.expected = asserts;
                    } else {
                        return this.test.expected;
                    }
                }
            },
            {
                key: 'async',
                value: function async(count) {
                    var test$$1 = this.test;
                    var popped = false, acceptCallCount = count;
                    if (typeof acceptCallCount === 'undefined') {
                        acceptCallCount = 1;
                    }
                    var resume = internalStop(test$$1);
                    return function done() {
                        if (config.current !== test$$1) {
                            throw Error('assert.async callback called after test finished.');
                        }
                        if (popped) {
                            test$$1.pushFailure('Too many calls to the `assert.async` callback', sourceFromStacktrace(2));
                            return;
                        }
                        acceptCallCount -= 1;
                        if (acceptCallCount > 0) {
                            return;
                        }
                        popped = true;
                        resume();
                    };
                }
            },
            {
                key: 'push',
                value: function push(result, actual, expected, message, negative) {
                    Logger.warn('assert.push is deprecated and will be removed in QUnit 3.0.' + ' Please use assert.pushResult instead (https://api.qunitjs.com/assert/pushResult).');
                    var currentAssert = this instanceof Assert ? this : config.current.assert;
                    return currentAssert.pushResult({
                        result: result,
                        actual: actual,
                        expected: expected,
                        message: message,
                        negative: negative
                    });
                }
            },
            {
                key: 'pushResult',
                value: function pushResult(resultInfo) {
                    var assert = this;
                    var currentTest = assert instanceof Assert && assert.test || config.current;
                    if (!currentTest) {
                        throw new Error('assertion outside test context, in ' + sourceFromStacktrace(2));
                    }
                    if (!(assert instanceof Assert)) {
                        assert = currentTest.assert;
                    }
                    return assert.test.pushResult(resultInfo);
                }
            },
            {
                key: 'ok',
                value: function ok(result, message) {
                    if (!message) {
                        message = result ? 'okay' : 'failed, expected argument to be truthy, was: ' + dump.parse(result);
                    }
                    this.pushResult({
                        result: !!result,
                        actual: result,
                        expected: true,
                        message: message
                    });
                }
            },
            {
                key: 'notOk',
                value: function notOk(result, message) {
                    if (!message) {
                        message = !result ? 'okay' : 'failed, expected argument to be falsy, was: ' + dump.parse(result);
                    }
                    this.pushResult({
                        result: !result,
                        actual: result,
                        expected: false,
                        message: message
                    });
                }
            },
            {
                key: 'equal',
                value: function equal(actual, expected, message) {
                    var result = expected == actual;
                    this.pushResult({
                        result: result,
                        actual: actual,
                        expected: expected,
                        message: message
                    });
                }
            },
            {
                key: 'notEqual',
                value: function notEqual(actual, expected, message) {
                    var result = expected != actual;
                    this.pushResult({
                        result: result,
                        actual: actual,
                        expected: expected,
                        message: message,
                        negative: true
                    });
                }
            },
            {
                key: 'propEqual',
                value: function propEqual(actual, expected, message) {
                    actual = objectValues(actual);
                    expected = objectValues(expected);
                    this.pushResult({
                        result: equiv(actual, expected),
                        actual: actual,
                        expected: expected,
                        message: message
                    });
                }
            },
            {
                key: 'notPropEqual',
                value: function notPropEqual(actual, expected, message) {
                    actual = objectValues(actual);
                    expected = objectValues(expected);
                    this.pushResult({
                        result: !equiv(actual, expected),
                        actual: actual,
                        expected: expected,
                        message: message,
                        negative: true
                    });
                }
            },
            {
                key: 'deepEqual',
                value: function deepEqual(actual, expected, message) {
                    this.pushResult({
                        result: equiv(actual, expected),
                        actual: actual,
                        expected: expected,
                        message: message
                    });
                }
            },
            {
                key: 'notDeepEqual',
                value: function notDeepEqual(actual, expected, message) {
                    this.pushResult({
                        result: !equiv(actual, expected),
                        actual: actual,
                        expected: expected,
                        message: message,
                        negative: true
                    });
                }
            },
            {
                key: 'strictEqual',
                value: function strictEqual(actual, expected, message) {
                    this.pushResult({
                        result: expected === actual,
                        actual: actual,
                        expected: expected,
                        message: message
                    });
                }
            },
            {
                key: 'notStrictEqual',
                value: function notStrictEqual(actual, expected, message) {
                    this.pushResult({
                        result: expected !== actual,
                        actual: actual,
                        expected: expected,
                        message: message,
                        negative: true
                    });
                }
            },
            {
                key: 'throws',
                value: function throws(block, expected, message) {
                    var actual = void 0, result = false;
                    var currentTest = this instanceof Assert && this.test || config.current;
                    if (objectType(expected) === 'string') {
                        if (message == null) {
                            message = expected;
                            expected = null;
                        } else {
                            throw new Error('throws/raises does not accept a string value for the expected argument.\n' + 'Use a non-string object value (e.g. regExp) instead if it\'s necessary.');
                        }
                    }
                    currentTest.ignoreGlobalErrors = true;
                    try {
                        block.call(currentTest.testEnvironment);
                    } catch (e) {
                        actual = e;
                    }
                    currentTest.ignoreGlobalErrors = false;
                    if (actual) {
                        var expectedType = objectType(expected);
                        if (!expected) {
                            result = true;
                            expected = null;
                        } else if (expectedType === 'regexp') {
                            result = expected.test(errorString(actual));
                        } else if (expectedType === 'function' && actual instanceof expected) {
                            result = true;
                        } else if (expectedType === 'object') {
                            result = actual instanceof expected.constructor && actual.name === expected.name && actual.message === expected.message;
                        } else if (expectedType === 'function' && expected.call({}, actual) === true) {
                            expected = null;
                            result = true;
                        }
                    }
                    currentTest.assert.pushResult({
                        result: result,
                        actual: actual,
                        expected: expected,
                        message: message
                    });
                }
            }
        ]);
        return Assert;
    }();
    Assert.prototype.raises = Assert.prototype['throws'];
    function errorString(error) {
        var resultErrorString = error.toString();
        if (resultErrorString.substring(0, 7) === '[object') {
            var name = error.name ? error.name.toString() : 'Error';
            var message = error.message ? error.message.toString() : '';
            if (name && message) {
                return name + ': ' + message;
            } else if (name) {
                return name;
            } else if (message) {
                return message;
            } else {
                return 'Error';
            }
        } else {
            return resultErrorString;
        }
    }
    function exportQUnit(QUnit) {
        if (defined.document) {
            if (window.QUnit && window.QUnit.version) {
                throw new Error('QUnit has already been defined.');
            }
            window.QUnit = QUnit;
        }
        if (typeof module !== 'undefined' && module && module.exports) {
            module.exports = QUnit;
            module.exports.QUnit = QUnit;
        }
        if (typeof exports !== 'undefined' && exports) {
            exports.QUnit = QUnit;
        }
        if (typeof define === 'function' && define.amd) {
            define('qunitjs@2.4.1#qunit/qunit', function () {
                return QUnit;
            });
            QUnit.config.autostart = false;
        }
        if (self$1 && self$1.WorkerGlobalScope && self$1 instanceof self$1.WorkerGlobalScope) {
            self$1.QUnit = QUnit;
        }
    }
    var SuiteReport = function () {
        function SuiteReport(name, parentSuite) {
            classCallCheck(this, SuiteReport);
            this.name = name;
            this.fullName = parentSuite ? parentSuite.fullName.concat(name) : [];
            this.tests = [];
            this.childSuites = [];
            if (parentSuite) {
                parentSuite.pushChildSuite(this);
            }
        }
        createClass(SuiteReport, [
            {
                key: 'start',
                value: function start(recordTime) {
                    if (recordTime) {
                        this._startTime = Date.now();
                    }
                    return {
                        name: this.name,
                        fullName: this.fullName.slice(),
                        tests: this.tests.map(function (test) {
                            return test.start();
                        }),
                        childSuites: this.childSuites.map(function (suite) {
                            return suite.start();
                        }),
                        testCounts: { total: this.getTestCounts().total }
                    };
                }
            },
            {
                key: 'end',
                value: function end(recordTime) {
                    if (recordTime) {
                        this._endTime = Date.now();
                    }
                    return {
                        name: this.name,
                        fullName: this.fullName.slice(),
                        tests: this.tests.map(function (test) {
                            return test.end();
                        }),
                        childSuites: this.childSuites.map(function (suite) {
                            return suite.end();
                        }),
                        testCounts: this.getTestCounts(),
                        runtime: this.getRuntime(),
                        status: this.getStatus()
                    };
                }
            },
            {
                key: 'pushChildSuite',
                value: function pushChildSuite(suite) {
                    this.childSuites.push(suite);
                }
            },
            {
                key: 'pushTest',
                value: function pushTest(test) {
                    this.tests.push(test);
                }
            },
            {
                key: 'getRuntime',
                value: function getRuntime() {
                    return this._endTime - this._startTime;
                }
            },
            {
                key: 'getTestCounts',
                value: function getTestCounts() {
                    var counts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
                        passed: 0,
                        failed: 0,
                        skipped: 0,
                        todo: 0,
                        total: 0
                    };
                    counts = this.tests.reduce(function (counts, test) {
                        if (test.valid) {
                            counts[test.getStatus()]++;
                            counts.total++;
                        }
                        return counts;
                    }, counts);
                    return this.childSuites.reduce(function (counts, suite) {
                        return suite.getTestCounts(counts);
                    }, counts);
                }
            },
            {
                key: 'getStatus',
                value: function getStatus() {
                    var _getTestCounts = this.getTestCounts(), total = _getTestCounts.total, failed = _getTestCounts.failed, skipped = _getTestCounts.skipped, todo = _getTestCounts.todo;
                    if (failed) {
                        return 'failed';
                    } else {
                        if (skipped === total) {
                            return 'skipped';
                        } else if (todo === total) {
                            return 'todo';
                        } else {
                            return 'passed';
                        }
                    }
                }
            }
        ]);
        return SuiteReport;
    }();
    function onError(error) {
        for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            args[_key - 1] = arguments[_key];
        }
        if (config.current) {
            if (config.current.ignoreGlobalErrors) {
                return true;
            }
            pushFailure.apply(undefined, [
                error.message,
                error.fileName + ':' + error.lineNumber
            ].concat(args));
        } else {
            test('global failure', extend(function () {
                pushFailure.apply(undefined, [
                    error.message,
                    error.fileName + ':' + error.lineNumber
                ].concat(args));
            }, { validTest: true }));
        }
        return false;
    }
    var focused = false;
    var QUnit = {};
    var globalSuite = new SuiteReport();
    config.currentModule.suiteReport = globalSuite;
    var moduleStack = [];
    var globalStartCalled = false;
    var runStarted = false;
    QUnit.isLocal = !(defined.document && window.location.protocol !== 'file:');
    QUnit.version = '2.4.1';
    function createModule(name, testEnvironment, modifiers) {
        var parentModule = moduleStack.length ? moduleStack.slice(-1)[0] : null;
        var moduleName = parentModule !== null ? [
            parentModule.name,
            name
        ].join(' > ') : name;
        var parentSuite = parentModule ? parentModule.suiteReport : globalSuite;
        var skip$$1 = parentModule !== null && parentModule.skip || modifiers.skip;
        var todo$$1 = parentModule !== null && parentModule.todo || modifiers.todo;
        var module = {
            name: moduleName,
            parentModule: parentModule,
            tests: [],
            moduleId: generateHash(moduleName),
            testsRun: 0,
            unskippedTestsRun: 0,
            childModules: [],
            suiteReport: new SuiteReport(name, parentSuite),
            skip: skip$$1,
            todo: skip$$1 ? false : todo$$1
        };
        var env = {};
        if (parentModule) {
            parentModule.childModules.push(module);
            extend(env, parentModule.testEnvironment);
        }
        extend(env, testEnvironment);
        module.testEnvironment = env;
        config.modules.push(module);
        return module;
    }
    function processModule(name, options, executeNow) {
        var modifiers = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
        var module = createModule(name, options, modifiers);
        var testEnvironment = module.testEnvironment;
        var hooks = module.hooks = {};
        setHookFromEnvironment(hooks, testEnvironment, 'before');
        setHookFromEnvironment(hooks, testEnvironment, 'beforeEach');
        setHookFromEnvironment(hooks, testEnvironment, 'afterEach');
        setHookFromEnvironment(hooks, testEnvironment, 'after');
        function setHookFromEnvironment(hooks, environment, name) {
            var potentialHook = environment[name];
            hooks[name] = typeof potentialHook === 'function' ? [potentialHook] : [];
            delete environment[name];
        }
        var moduleFns = {
            before: setHookFunction(module, 'before'),
            beforeEach: setHookFunction(module, 'beforeEach'),
            afterEach: setHookFunction(module, 'afterEach'),
            after: setHookFunction(module, 'after')
        };
        var currentModule = config.currentModule;
        if (objectType(executeNow) === 'function') {
            moduleStack.push(module);
            config.currentModule = module;
            executeNow.call(module.testEnvironment, moduleFns);
            moduleStack.pop();
            module = module.parentModule || currentModule;
        }
        config.currentModule = module;
    }
    function module$1(name, options, executeNow) {
        if (focused) {
            return;
        }
        if (arguments.length === 2) {
            if (objectType(options) === 'function') {
                executeNow = options;
                options = undefined;
            }
        }
        processModule(name, options, executeNow);
    }
    module$1.only = function () {
        if (focused) {
            return;
        }
        config.modules.length = 0;
        config.queue.length = 0;
        module$1.apply(undefined, arguments);
        focused = true;
    };
    module$1.skip = function (name, options, executeNow) {
        if (focused) {
            return;
        }
        if (arguments.length === 2) {
            if (objectType(options) === 'function') {
                executeNow = options;
                options = undefined;
            }
        }
        processModule(name, options, executeNow, { skip: true });
    };
    module$1.todo = function (name, options, executeNow) {
        if (focused) {
            return;
        }
        if (arguments.length === 2) {
            if (objectType(options) === 'function') {
                executeNow = options;
                options = undefined;
            }
        }
        processModule(name, options, executeNow, { todo: true });
    };
    extend(QUnit, {
        on: on,
        module: module$1,
        test: test,
        todo: todo,
        skip: skip,
        only: only,
        start: function start(count) {
            var globalStartAlreadyCalled = globalStartCalled;
            if (!config.current) {
                globalStartCalled = true;
                if (runStarted) {
                    throw new Error('Called start() while test already started running');
                } else if (globalStartAlreadyCalled || count > 1) {
                    throw new Error('Called start() outside of a test context too many times');
                } else if (config.autostart) {
                    throw new Error('Called start() outside of a test context when ' + 'QUnit.config.autostart was true');
                } else if (!config.pageLoaded) {
                    config.autostart = true;
                    if (!defined.document) {
                        QUnit.load();
                    }
                    return;
                }
            } else {
                throw new Error('QUnit.start cannot be called inside a test context.');
            }
            scheduleBegin();
        },
        config: config,
        is: is,
        objectType: objectType,
        extend: extend,
        load: function load() {
            config.pageLoaded = true;
            extend(config, {
                stats: {
                    all: 0,
                    bad: 0
                },
                started: 0,
                updateRate: 1000,
                autostart: true,
                filter: ''
            }, true);
            if (!runStarted) {
                config.blocking = false;
                if (config.autostart) {
                    scheduleBegin();
                }
            }
        },
        stack: function stack(offset) {
            offset = (offset || 0) + 2;
            return sourceFromStacktrace(offset);
        },
        onError: onError
    });
    QUnit.pushFailure = pushFailure;
    QUnit.assert = Assert.prototype;
    QUnit.equiv = equiv;
    QUnit.dump = dump;
    registerLoggingCallbacks(QUnit);
    function scheduleBegin() {
        runStarted = true;
        if (defined.setTimeout) {
            setTimeout(function () {
                begin();
            }, 13);
        } else {
            begin();
        }
    }
    function begin() {
        var i, l, modulesLog = [];
        if (!config.started) {
            config.started = now();
            if (config.modules[0].name === '' && config.modules[0].tests.length === 0) {
                config.modules.shift();
            }
            for (i = 0, l = config.modules.length; i < l; i++) {
                modulesLog.push({
                    name: config.modules[i].name,
                    tests: config.modules[i].tests
                });
            }
            emit('runStart', globalSuite.start(true));
            runLoggingCallbacks('begin', {
                totalTests: Test.count,
                modules: modulesLog
            });
        }
        config.blocking = false;
        ProcessingQueue.advance();
    }
    function setHookFunction(module, hookName) {
        return function setHook(callback) {
            module.hooks[hookName].push(callback);
        };
    }
    exportQUnit(QUnit);
    (function () {
        if (typeof window === 'undefined' || typeof document === 'undefined') {
            return;
        }
        var config = QUnit.config, hasOwn = Object.prototype.hasOwnProperty;
        function storeFixture() {
            if (hasOwn.call(config, 'fixture')) {
                return;
            }
            var fixture = document.getElementById('qunit-fixture');
            if (fixture) {
                config.fixture = fixture.innerHTML;
            }
        }
        QUnit.begin(storeFixture);
        function resetFixture() {
            if (config.fixture == null) {
                return;
            }
            var fixture = document.getElementById('qunit-fixture');
            if (fixture) {
                fixture.innerHTML = config.fixture;
            }
        }
        QUnit.testStart(resetFixture);
    }());
    (function () {
        var location = typeof window !== 'undefined' && window.location;
        if (!location) {
            return;
        }
        var urlParams = getUrlParams();
        QUnit.urlParams = urlParams;
        QUnit.config.moduleId = [].concat(urlParams.moduleId || []);
        QUnit.config.testId = [].concat(urlParams.testId || []);
        QUnit.config.module = urlParams.module;
        QUnit.config.filter = urlParams.filter;
        if (urlParams.seed === true) {
            QUnit.config.seed = Math.random().toString(36).slice(2);
        } else if (urlParams.seed) {
            QUnit.config.seed = urlParams.seed;
        }
        QUnit.config.urlConfig.push({
            id: 'hidepassed',
            label: 'Hide passed tests',
            tooltip: 'Only show tests and assertions that fail. Stored as query-strings.'
        }, {
            id: 'noglobals',
            label: 'Check for Globals',
            tooltip: 'Enabling this will test if any test introduces new properties on the ' + 'global object (`window` in Browsers). Stored as query-strings.'
        }, {
            id: 'notrycatch',
            label: 'No try-catch',
            tooltip: 'Enabling this will run tests outside of a try-catch block. Makes debugging ' + 'exceptions in IE reasonable. Stored as query-strings.'
        });
        QUnit.begin(function () {
            var i, option, urlConfig = QUnit.config.urlConfig;
            for (i = 0; i < urlConfig.length; i++) {
                option = QUnit.config.urlConfig[i];
                if (typeof option !== 'string') {
                    option = option.id;
                }
                if (QUnit.config[option] === undefined) {
                    QUnit.config[option] = urlParams[option];
                }
            }
        });
        function getUrlParams() {
            var i, param, name, value;
            var urlParams = Object.create(null);
            var params = location.search.slice(1).split('&');
            var length = params.length;
            for (i = 0; i < length; i++) {
                if (params[i]) {
                    param = params[i].split('=');
                    name = decodeQueryParam(param[0]);
                    value = param.length === 1 || decodeQueryParam(param.slice(1).join('='));
                    if (name in urlParams) {
                        urlParams[name] = [].concat(urlParams[name], value);
                    } else {
                        urlParams[name] = value;
                    }
                }
            }
            return urlParams;
        }
        function decodeQueryParam(param) {
            return decodeURIComponent(param.replace(/\+/g, '%20'));
        }
    }());
    var stats = {
        passedTests: 0,
        failedTests: 0,
        skippedTests: 0,
        todoTests: 0
    };
    function escapeText(s) {
        if (!s) {
            return '';
        }
        s = s + '';
        return s.replace(/['"<>&]/g, function (s) {
            switch (s) {
            case '\'':
                return '&#039;';
            case '"':
                return '&quot;';
            case '<':
                return '&lt;';
            case '>':
                return '&gt;';
            case '&':
                return '&amp;';
            }
        });
    }
    (function () {
        if (typeof window === 'undefined' || !window.document) {
            return;
        }
        var config = QUnit.config, document$$1 = window.document, collapseNext = false, hasOwn = Object.prototype.hasOwnProperty, unfilteredUrl = setUrl({
                filter: undefined,
                module: undefined,
                moduleId: undefined,
                testId: undefined
            }), modulesList = [];
        function addEvent(elem, type, fn) {
            elem.addEventListener(type, fn, false);
        }
        function removeEvent(elem, type, fn) {
            elem.removeEventListener(type, fn, false);
        }
        function addEvents(elems, type, fn) {
            var i = elems.length;
            while (i--) {
                addEvent(elems[i], type, fn);
            }
        }
        function hasClass(elem, name) {
            return (' ' + elem.className + ' ').indexOf(' ' + name + ' ') >= 0;
        }
        function addClass(elem, name) {
            if (!hasClass(elem, name)) {
                elem.className += (elem.className ? ' ' : '') + name;
            }
        }
        function toggleClass(elem, name, force) {
            if (force || typeof force === 'undefined' && !hasClass(elem, name)) {
                addClass(elem, name);
            } else {
                removeClass(elem, name);
            }
        }
        function removeClass(elem, name) {
            var set = ' ' + elem.className + ' ';
            while (set.indexOf(' ' + name + ' ') >= 0) {
                set = set.replace(' ' + name + ' ', ' ');
            }
            elem.className = typeof set.trim === 'function' ? set.trim() : set.replace(/^\s+|\s+$/g, '');
        }
        function id(name) {
            return document$$1.getElementById && document$$1.getElementById(name);
        }
        function abortTests() {
            var abortButton = id('qunit-abort-tests-button');
            if (abortButton) {
                abortButton.disabled = true;
                abortButton.innerHTML = 'Aborting...';
            }
            QUnit.config.queue.length = 0;
            return false;
        }
        function interceptNavigation(ev) {
            applyUrlParams();
            if (ev && ev.preventDefault) {
                ev.preventDefault();
            }
            return false;
        }
        function getUrlConfigHtml() {
            var i, j, val, escaped, escapedTooltip, selection = false, urlConfig = config.urlConfig, urlConfigHtml = '';
            for (i = 0; i < urlConfig.length; i++) {
                val = config.urlConfig[i];
                if (typeof val === 'string') {
                    val = {
                        id: val,
                        label: val
                    };
                }
                escaped = escapeText(val.id);
                escapedTooltip = escapeText(val.tooltip);
                if (!val.value || typeof val.value === 'string') {
                    urlConfigHtml += '<label for=\'qunit-urlconfig-' + escaped + '\' title=\'' + escapedTooltip + '\'><input id=\'qunit-urlconfig-' + escaped + '\' name=\'' + escaped + '\' type=\'checkbox\'' + (val.value ? ' value=\'' + escapeText(val.value) + '\'' : '') + (config[val.id] ? ' checked=\'checked\'' : '') + ' title=\'' + escapedTooltip + '\' />' + escapeText(val.label) + '</label>';
                } else {
                    urlConfigHtml += '<label for=\'qunit-urlconfig-' + escaped + '\' title=\'' + escapedTooltip + '\'>' + val.label + ': </label><select id=\'qunit-urlconfig-' + escaped + '\' name=\'' + escaped + '\' title=\'' + escapedTooltip + '\'><option></option>';
                    if (QUnit.is('array', val.value)) {
                        for (j = 0; j < val.value.length; j++) {
                            escaped = escapeText(val.value[j]);
                            urlConfigHtml += '<option value=\'' + escaped + '\'' + (config[val.id] === val.value[j] ? (selection = true) && ' selected=\'selected\'' : '') + '>' + escaped + '</option>';
                        }
                    } else {
                        for (j in val.value) {
                            if (hasOwn.call(val.value, j)) {
                                urlConfigHtml += '<option value=\'' + escapeText(j) + '\'' + (config[val.id] === j ? (selection = true) && ' selected=\'selected\'' : '') + '>' + escapeText(val.value[j]) + '</option>';
                            }
                        }
                    }
                    if (config[val.id] && !selection) {
                        escaped = escapeText(config[val.id]);
                        urlConfigHtml += '<option value=\'' + escaped + '\' selected=\'selected\' disabled=\'disabled\'>' + escaped + '</option>';
                    }
                    urlConfigHtml += '</select>';
                }
            }
            return urlConfigHtml;
        }
        function toolbarChanged() {
            var updatedUrl, value, tests, field = this, params = {};
            if ('selectedIndex' in field) {
                value = field.options[field.selectedIndex].value || undefined;
            } else {
                value = field.checked ? field.defaultValue || true : undefined;
            }
            params[field.name] = value;
            updatedUrl = setUrl(params);
            if ('hidepassed' === field.name && 'replaceState' in window.history) {
                QUnit.urlParams[field.name] = value;
                config[field.name] = value || false;
                tests = id('qunit-tests');
                if (tests) {
                    toggleClass(tests, 'hidepass', value || false);
                }
                window.history.replaceState(null, '', updatedUrl);
            } else {
                window.location = updatedUrl;
            }
        }
        function setUrl(params) {
            var key, arrValue, i, querystring = '?', location = window.location;
            params = QUnit.extend(QUnit.extend({}, QUnit.urlParams), params);
            for (key in params) {
                if (hasOwn.call(params, key) && params[key] !== undefined) {
                    arrValue = [].concat(params[key]);
                    for (i = 0; i < arrValue.length; i++) {
                        querystring += encodeURIComponent(key);
                        if (arrValue[i] !== true) {
                            querystring += '=' + encodeURIComponent(arrValue[i]);
                        }
                        querystring += '&';
                    }
                }
            }
            return location.protocol + '//' + location.host + location.pathname + querystring.slice(0, -1);
        }
        function applyUrlParams() {
            var i, selectedModules = [], modulesList = id('qunit-modulefilter-dropdown-list').getElementsByTagName('input'), filter = id('qunit-filter-input').value;
            for (i = 0; i < modulesList.length; i++) {
                if (modulesList[i].checked) {
                    selectedModules.push(modulesList[i].value);
                }
            }
            window.location = setUrl({
                filter: filter === '' ? undefined : filter,
                moduleId: selectedModules.length === 0 ? undefined : selectedModules,
                module: undefined,
                testId: undefined
            });
        }
        function toolbarUrlConfigContainer() {
            var urlConfigContainer = document$$1.createElement('span');
            urlConfigContainer.innerHTML = getUrlConfigHtml();
            addClass(urlConfigContainer, 'qunit-url-config');
            addEvents(urlConfigContainer.getElementsByTagName('input'), 'change', toolbarChanged);
            addEvents(urlConfigContainer.getElementsByTagName('select'), 'change', toolbarChanged);
            return urlConfigContainer;
        }
        function abortTestsButton() {
            var button = document$$1.createElement('button');
            button.id = 'qunit-abort-tests-button';
            button.innerHTML = 'Abort';
            addEvent(button, 'click', abortTests);
            return button;
        }
        function toolbarLooseFilter() {
            var filter = document$$1.createElement('form'), label = document$$1.createElement('label'), input = document$$1.createElement('input'), button = document$$1.createElement('button');
            addClass(filter, 'qunit-filter');
            label.innerHTML = 'Filter: ';
            input.type = 'text';
            input.value = config.filter || '';
            input.name = 'filter';
            input.id = 'qunit-filter-input';
            button.innerHTML = 'Go';
            label.appendChild(input);
            filter.appendChild(label);
            filter.appendChild(document$$1.createTextNode(' '));
            filter.appendChild(button);
            addEvent(filter, 'submit', interceptNavigation);
            return filter;
        }
        function moduleListHtml() {
            var i, checked, html = '';
            for (i = 0; i < config.modules.length; i++) {
                if (config.modules[i].name !== '') {
                    checked = config.moduleId.indexOf(config.modules[i].moduleId) > -1;
                    html += '<li><label class=\'clickable' + (checked ? ' checked' : '') + '\'><input type=\'checkbox\' ' + 'value=\'' + config.modules[i].moduleId + '\'' + (checked ? ' checked=\'checked\'' : '') + ' />' + escapeText(config.modules[i].name) + '</label></li>';
                }
            }
            return html;
        }
        function toolbarModuleFilter() {
            var allCheckbox, commit, reset, moduleFilter = document$$1.createElement('form'), label = document$$1.createElement('label'), moduleSearch = document$$1.createElement('input'), dropDown = document$$1.createElement('div'), actions = document$$1.createElement('span'), dropDownList = document$$1.createElement('ul'), dirty = false;
            moduleSearch.id = 'qunit-modulefilter-search';
            addEvent(moduleSearch, 'input', searchInput);
            addEvent(moduleSearch, 'input', searchFocus);
            addEvent(moduleSearch, 'focus', searchFocus);
            addEvent(moduleSearch, 'click', searchFocus);
            label.id = 'qunit-modulefilter-search-container';
            label.innerHTML = 'Module: ';
            label.appendChild(moduleSearch);
            actions.id = 'qunit-modulefilter-actions';
            actions.innerHTML = '<button style=\'display:none\'>Apply</button>' + '<button type=\'reset\' style=\'display:none\'>Reset</button>' + '<label class=\'clickable' + (config.moduleId.length ? '' : ' checked') + '\'><input type=\'checkbox\'' + (config.moduleId.length ? '' : ' checked=\'checked\'') + '>All modules</label>';
            allCheckbox = actions.lastChild.firstChild;
            commit = actions.firstChild;
            reset = commit.nextSibling;
            addEvent(commit, 'click', applyUrlParams);
            dropDownList.id = 'qunit-modulefilter-dropdown-list';
            dropDownList.innerHTML = moduleListHtml();
            dropDown.id = 'qunit-modulefilter-dropdown';
            dropDown.style.display = 'none';
            dropDown.appendChild(actions);
            dropDown.appendChild(dropDownList);
            addEvent(dropDown, 'change', selectionChange);
            selectionChange();
            moduleFilter.id = 'qunit-modulefilter';
            moduleFilter.appendChild(label);
            moduleFilter.appendChild(dropDown);
            addEvent(moduleFilter, 'submit', interceptNavigation);
            addEvent(moduleFilter, 'reset', function () {
                window.setTimeout(selectionChange);
            });
            function searchFocus() {
                if (dropDown.style.display !== 'none') {
                    return;
                }
                dropDown.style.display = 'block';
                addEvent(document$$1, 'click', hideHandler);
                addEvent(document$$1, 'keydown', hideHandler);
                function hideHandler(e) {
                    var inContainer = moduleFilter.contains(e.target);
                    if (e.keyCode === 27 || !inContainer) {
                        if (e.keyCode === 27 && inContainer) {
                            moduleSearch.focus();
                        }
                        dropDown.style.display = 'none';
                        removeEvent(document$$1, 'click', hideHandler);
                        removeEvent(document$$1, 'keydown', hideHandler);
                        moduleSearch.value = '';
                        searchInput();
                    }
                }
            }
            function searchInput() {
                var i, item, searchText = moduleSearch.value.toLowerCase(), listItems = dropDownList.children;
                for (i = 0; i < listItems.length; i++) {
                    item = listItems[i];
                    if (!searchText || item.textContent.toLowerCase().indexOf(searchText) > -1) {
                        item.style.display = '';
                    } else {
                        item.style.display = 'none';
                    }
                }
            }
            function selectionChange(evt) {
                var i, item, checkbox = evt && evt.target || allCheckbox, modulesList = dropDownList.getElementsByTagName('input'), selectedNames = [];
                toggleClass(checkbox.parentNode, 'checked', checkbox.checked);
                dirty = false;
                if (checkbox.checked && checkbox !== allCheckbox) {
                    allCheckbox.checked = false;
                    removeClass(allCheckbox.parentNode, 'checked');
                }
                for (i = 0; i < modulesList.length; i++) {
                    item = modulesList[i];
                    if (!evt) {
                        toggleClass(item.parentNode, 'checked', item.checked);
                    } else if (checkbox === allCheckbox && checkbox.checked) {
                        item.checked = false;
                        removeClass(item.parentNode, 'checked');
                    }
                    dirty = dirty || item.checked !== item.defaultChecked;
                    if (item.checked) {
                        selectedNames.push(item.parentNode.textContent);
                    }
                }
                commit.style.display = reset.style.display = dirty ? '' : 'none';
                moduleSearch.placeholder = selectedNames.join(', ') || allCheckbox.parentNode.textContent;
                moduleSearch.title = 'Type to filter list. Current selection:\n' + (selectedNames.join('\n') || allCheckbox.parentNode.textContent);
            }
            return moduleFilter;
        }
        function appendToolbar() {
            var toolbar = id('qunit-testrunner-toolbar');
            if (toolbar) {
                toolbar.appendChild(toolbarUrlConfigContainer());
                toolbar.appendChild(toolbarModuleFilter());
                toolbar.appendChild(toolbarLooseFilter());
                toolbar.appendChild(document$$1.createElement('div')).className = 'clearfix';
            }
        }
        function appendHeader() {
            var header = id('qunit-header');
            if (header) {
                header.innerHTML = '<a href=\'' + escapeText(unfilteredUrl) + '\'>' + header.innerHTML + '</a> ';
            }
        }
        function appendBanner() {
            var banner = id('qunit-banner');
            if (banner) {
                banner.className = '';
            }
        }
        function appendTestResults() {
            var tests = id('qunit-tests'), result = id('qunit-testresult'), controls;
            if (result) {
                result.parentNode.removeChild(result);
            }
            if (tests) {
                tests.innerHTML = '';
                result = document$$1.createElement('p');
                result.id = 'qunit-testresult';
                result.className = 'result';
                tests.parentNode.insertBefore(result, tests);
                result.innerHTML = '<div id="qunit-testresult-display">Running...<br />&#160;</div>' + '<div id="qunit-testresult-controls"></div>' + '<div class="clearfix"></div>';
                controls = id('qunit-testresult-controls');
            }
            if (controls) {
                controls.appendChild(abortTestsButton());
            }
        }
        function appendFilteredTest() {
            var testId = QUnit.config.testId;
            if (!testId || testId.length <= 0) {
                return '';
            }
            return '<div id=\'qunit-filteredTest\'>Rerunning selected tests: ' + escapeText(testId.join(', ')) + ' <a id=\'qunit-clearFilter\' href=\'' + escapeText(unfilteredUrl) + '\'>Run all tests</a></div>';
        }
        function appendUserAgent() {
            var userAgent = id('qunit-userAgent');
            if (userAgent) {
                userAgent.innerHTML = '';
                userAgent.appendChild(document$$1.createTextNode('QUnit ' + QUnit.version + '; ' + navigator.userAgent));
            }
        }
        function appendInterface() {
            var qunit = id('qunit');
            if (qunit) {
                qunit.innerHTML = '<h1 id=\'qunit-header\'>' + escapeText(document$$1.title) + '</h1>' + '<h2 id=\'qunit-banner\'></h2>' + '<div id=\'qunit-testrunner-toolbar\'></div>' + appendFilteredTest() + '<h2 id=\'qunit-userAgent\'></h2>' + '<ol id=\'qunit-tests\'></ol>';
            }
            appendHeader();
            appendBanner();
            appendTestResults();
            appendUserAgent();
            appendToolbar();
        }
        function appendTestsList(modules) {
            var i, l, x, z, test, moduleObj;
            for (i = 0, l = modules.length; i < l; i++) {
                moduleObj = modules[i];
                for (x = 0, z = moduleObj.tests.length; x < z; x++) {
                    test = moduleObj.tests[x];
                    appendTest(test.name, test.testId, moduleObj.name);
                }
            }
        }
        function appendTest(name, testId, moduleName) {
            var title, rerunTrigger, testBlock, assertList, tests = id('qunit-tests');
            if (!tests) {
                return;
            }
            title = document$$1.createElement('strong');
            title.innerHTML = getNameHtml(name, moduleName);
            rerunTrigger = document$$1.createElement('a');
            rerunTrigger.innerHTML = 'Rerun';
            rerunTrigger.href = setUrl({ testId: testId });
            testBlock = document$$1.createElement('li');
            testBlock.appendChild(title);
            testBlock.appendChild(rerunTrigger);
            testBlock.id = 'qunit-test-output-' + testId;
            assertList = document$$1.createElement('ol');
            assertList.className = 'qunit-assert-list';
            testBlock.appendChild(assertList);
            tests.appendChild(testBlock);
        }
        QUnit.begin(function (details) {
            var i, moduleObj, tests;
            for (i = 0; i < details.modules.length; i++) {
                moduleObj = details.modules[i];
                if (moduleObj.name) {
                    modulesList.push(moduleObj.name);
                }
            }
            modulesList.sort(function (a, b) {
                return a.localeCompare(b);
            });
            appendInterface();
            appendTestsList(details.modules);
            tests = id('qunit-tests');
            if (tests && config.hidepassed) {
                addClass(tests, 'hidepass');
            }
        });
        QUnit.done(function (details) {
            var banner = id('qunit-banner'), tests = id('qunit-tests'), abortButton = id('qunit-abort-tests-button'), totalTests = stats.passedTests + stats.skippedTests + stats.todoTests + stats.failedTests, html = [
                    totalTests,
                    ' tests completed in ',
                    details.runtime,
                    ' milliseconds, with ',
                    stats.failedTests,
                    ' failed, ',
                    stats.skippedTests,
                    ' skipped, and ',
                    stats.todoTests,
                    ' todo.<br />',
                    '<span class=\'passed\'>',
                    details.passed,
                    '</span> assertions of <span class=\'total\'>',
                    details.total,
                    '</span> passed, <span class=\'failed\'>',
                    details.failed,
                    '</span> failed.'
                ].join(''), test, assertLi, assertList;
            if (abortButton && abortButton.disabled) {
                html = 'Tests aborted after ' + details.runtime + ' milliseconds.';
                for (var i = 0; i < tests.children.length; i++) {
                    test = tests.children[i];
                    if (test.className === '' || test.className === 'running') {
                        test.className = 'aborted';
                        assertList = test.getElementsByTagName('ol')[0];
                        assertLi = document$$1.createElement('li');
                        assertLi.className = 'fail';
                        assertLi.innerHTML = 'Test aborted.';
                        assertList.appendChild(assertLi);
                    }
                }
            }
            if (banner && (!abortButton || abortButton.disabled === false)) {
                banner.className = stats.failedTests ? 'qunit-fail' : 'qunit-pass';
            }
            if (abortButton) {
                abortButton.parentNode.removeChild(abortButton);
            }
            if (tests) {
                id('qunit-testresult-display').innerHTML = html;
            }
            if (config.altertitle && document$$1.title) {
                document$$1.title = [
                    stats.failedTests ? '\u2716' : '\u2714',
                    document$$1.title.replace(/^[\u2714\u2716] /i, '')
                ].join(' ');
            }
            if (config.scrolltop && window.scrollTo) {
                window.scrollTo(0, 0);
            }
        });
        function getNameHtml(name, module) {
            var nameHtml = '';
            if (module) {
                nameHtml = '<span class=\'module-name\'>' + escapeText(module) + '</span>: ';
            }
            nameHtml += '<span class=\'test-name\'>' + escapeText(name) + '</span>';
            return nameHtml;
        }
        QUnit.testStart(function (details) {
            var running, testBlock, bad;
            testBlock = id('qunit-test-output-' + details.testId);
            if (testBlock) {
                testBlock.className = 'running';
            } else {
                appendTest(details.name, details.testId, details.module);
            }
            running = id('qunit-testresult-display');
            if (running) {
                bad = QUnit.config.reorder && details.previousFailure;
                running.innerHTML = [
                    bad ? 'Rerunning previously failed test: <br />' : 'Running: <br />',
                    getNameHtml(details.name, details.module)
                ].join('');
            }
        });
        function stripHtml(string) {
            return string.replace(/<\/?[^>]+(>|$)/g, '').replace(/\&quot;/g, '').replace(/\s+/g, '');
        }
        QUnit.log(function (details) {
            var assertList, assertLi, message, expected, actual, diff, showDiff = false, testItem = id('qunit-test-output-' + details.testId);
            if (!testItem) {
                return;
            }
            message = escapeText(details.message) || (details.result ? 'okay' : 'failed');
            message = '<span class=\'test-message\'>' + message + '</span>';
            message += '<span class=\'runtime\'>@ ' + details.runtime + ' ms</span>';
            if (!details.result && hasOwn.call(details, 'expected')) {
                if (details.negative) {
                    expected = 'NOT ' + QUnit.dump.parse(details.expected);
                } else {
                    expected = QUnit.dump.parse(details.expected);
                }
                actual = QUnit.dump.parse(details.actual);
                message += '<table><tr class=\'test-expected\'><th>Expected: </th><td><pre>' + escapeText(expected) + '</pre></td></tr>';
                if (actual !== expected) {
                    message += '<tr class=\'test-actual\'><th>Result: </th><td><pre>' + escapeText(actual) + '</pre></td></tr>';
                    if (typeof details.actual === 'number' && typeof details.expected === 'number') {
                        if (!isNaN(details.actual) && !isNaN(details.expected)) {
                            showDiff = true;
                            diff = details.actual - details.expected;
                            diff = (diff > 0 ? '+' : '') + diff;
                        }
                    } else if (typeof details.actual !== 'boolean' && typeof details.expected !== 'boolean') {
                        diff = QUnit.diff(expected, actual);
                        showDiff = stripHtml(diff).length !== stripHtml(expected).length + stripHtml(actual).length;
                    }
                    if (showDiff) {
                        message += '<tr class=\'test-diff\'><th>Diff: </th><td><pre>' + diff + '</pre></td></tr>';
                    }
                } else if (expected.indexOf('[object Array]') !== -1 || expected.indexOf('[object Object]') !== -1) {
                    message += '<tr class=\'test-message\'><th>Message: </th><td>' + 'Diff suppressed as the depth of object is more than current max depth (' + QUnit.config.maxDepth + ').<p>Hint: Use <code>QUnit.dump.maxDepth</code> to ' + ' run with a higher max depth or <a href=\'' + escapeText(setUrl({ maxDepth: -1 })) + '\'>' + 'Rerun</a> without max depth.</p></td></tr>';
                } else {
                    message += '<tr class=\'test-message\'><th>Message: </th><td>' + 'Diff suppressed as the expected and actual results have an equivalent' + ' serialization</td></tr>';
                }
                if (details.source) {
                    message += '<tr class=\'test-source\'><th>Source: </th><td><pre>' + escapeText(details.source) + '</pre></td></tr>';
                }
                message += '</table>';
            } else if (!details.result && details.source) {
                message += '<table>' + '<tr class=\'test-source\'><th>Source: </th><td><pre>' + escapeText(details.source) + '</pre></td></tr>' + '</table>';
            }
            assertList = testItem.getElementsByTagName('ol')[0];
            assertLi = document$$1.createElement('li');
            assertLi.className = details.result ? 'pass' : 'fail';
            assertLi.innerHTML = message;
            assertList.appendChild(assertLi);
        });
        QUnit.testDone(function (details) {
            var testTitle, time, testItem, assertList, good, bad, testCounts, skipped, sourceName, tests = id('qunit-tests');
            if (!tests) {
                return;
            }
            testItem = id('qunit-test-output-' + details.testId);
            assertList = testItem.getElementsByTagName('ol')[0];
            good = details.passed;
            bad = details.failed;
            var testPassed = details.failed > 0 ? details.todo : !details.todo;
            if (testPassed) {
                addClass(assertList, 'qunit-collapsed');
            } else if (config.collapse) {
                if (!collapseNext) {
                    collapseNext = true;
                } else {
                    addClass(assertList, 'qunit-collapsed');
                }
            }
            testTitle = testItem.firstChild;
            testCounts = bad ? '<b class=\'failed\'>' + bad + '</b>, ' + '<b class=\'passed\'>' + good + '</b>, ' : '';
            testTitle.innerHTML += ' <b class=\'counts\'>(' + testCounts + details.assertions.length + ')</b>';
            if (details.skipped) {
                stats.skippedTests++;
                testItem.className = 'skipped';
                skipped = document$$1.createElement('em');
                skipped.className = 'qunit-skipped-label';
                skipped.innerHTML = 'skipped';
                testItem.insertBefore(skipped, testTitle);
            } else {
                addEvent(testTitle, 'click', function () {
                    toggleClass(assertList, 'qunit-collapsed');
                });
                testItem.className = testPassed ? 'pass' : 'fail';
                if (details.todo) {
                    var todoLabel = document$$1.createElement('em');
                    todoLabel.className = 'qunit-todo-label';
                    todoLabel.innerHTML = 'todo';
                    testItem.className += ' todo';
                    testItem.insertBefore(todoLabel, testTitle);
                }
                time = document$$1.createElement('span');
                time.className = 'runtime';
                time.innerHTML = details.runtime + ' ms';
                testItem.insertBefore(time, assertList);
                if (!testPassed) {
                    stats.failedTests++;
                } else if (details.todo) {
                    stats.todoTests++;
                } else {
                    stats.passedTests++;
                }
            }
            if (details.source) {
                sourceName = document$$1.createElement('p');
                sourceName.innerHTML = '<strong>Source: </strong>' + details.source;
                addClass(sourceName, 'qunit-source');
                if (testPassed) {
                    addClass(sourceName, 'qunit-collapsed');
                }
                addEvent(testTitle, 'click', function () {
                    toggleClass(sourceName, 'qunit-collapsed');
                });
                testItem.appendChild(sourceName);
            }
        });
        var notPhantom = function (p) {
            return !(p && p.version && p.version.major > 0);
        }(window.phantom);
        if (notPhantom && document$$1.readyState === 'complete') {
            QUnit.load();
        } else {
            addEvent(window, 'load', QUnit.load);
        }
        var originalWindowOnError = window.onerror;
        window.onerror = function (message, fileName, lineNumber) {
            var ret = false;
            if (originalWindowOnError) {
                for (var _len = arguments.length, args = Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {
                    args[_key - 3] = arguments[_key];
                }
                ret = originalWindowOnError.call.apply(originalWindowOnError, [
                    this,
                    message,
                    fileName,
                    lineNumber
                ].concat(args));
            }
            if (ret !== true) {
                var error = {
                    message: message,
                    fileName: fileName,
                    lineNumber: lineNumber
                };
                ret = QUnit.onError(error);
            }
            return ret;
        };
    }());
    QUnit.diff = function () {
        function DiffMatchPatch() {
        }
        var DIFF_DELETE = -1, DIFF_INSERT = 1, DIFF_EQUAL = 0;
        DiffMatchPatch.prototype.DiffMain = function (text1, text2, optChecklines) {
            var deadline, checklines, commonlength, commonprefix, commonsuffix, diffs;
            deadline = new Date().getTime() + 1000;
            if (text1 === null || text2 === null) {
                throw new Error('Null input. (DiffMain)');
            }
            if (text1 === text2) {
                if (text1) {
                    return [[
                            DIFF_EQUAL,
                            text1
                        ]];
                }
                return [];
            }
            if (typeof optChecklines === 'undefined') {
                optChecklines = true;
            }
            checklines = optChecklines;
            commonlength = this.diffCommonPrefix(text1, text2);
            commonprefix = text1.substring(0, commonlength);
            text1 = text1.substring(commonlength);
            text2 = text2.substring(commonlength);
            commonlength = this.diffCommonSuffix(text1, text2);
            commonsuffix = text1.substring(text1.length - commonlength);
            text1 = text1.substring(0, text1.length - commonlength);
            text2 = text2.substring(0, text2.length - commonlength);
            diffs = this.diffCompute(text1, text2, checklines, deadline);
            if (commonprefix) {
                diffs.unshift([
                    DIFF_EQUAL,
                    commonprefix
                ]);
            }
            if (commonsuffix) {
                diffs.push([
                    DIFF_EQUAL,
                    commonsuffix
                ]);
            }
            this.diffCleanupMerge(diffs);
            return diffs;
        };
        DiffMatchPatch.prototype.diffCleanupEfficiency = function (diffs) {
            var changes, equalities, equalitiesLength, lastequality, pointer, preIns, preDel, postIns, postDel;
            changes = false;
            equalities = [];
            equalitiesLength = 0;
            lastequality = null;
            pointer = 0;
            preIns = false;
            preDel = false;
            postIns = false;
            postDel = false;
            while (pointer < diffs.length) {
                if (diffs[pointer][0] === DIFF_EQUAL) {
                    if (diffs[pointer][1].length < 4 && (postIns || postDel)) {
                        equalities[equalitiesLength++] = pointer;
                        preIns = postIns;
                        preDel = postDel;
                        lastequality = diffs[pointer][1];
                    } else {
                        equalitiesLength = 0;
                        lastequality = null;
                    }
                    postIns = postDel = false;
                } else {
                    if (diffs[pointer][0] === DIFF_DELETE) {
                        postDel = true;
                    } else {
                        postIns = true;
                    }
                    if (lastequality && (preIns && preDel && postIns && postDel || lastequality.length < 2 && preIns + preDel + postIns + postDel === 3)) {
                        diffs.splice(equalities[equalitiesLength - 1], 0, [
                            DIFF_DELETE,
                            lastequality
                        ]);
                        diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT;
                        equalitiesLength--;
                        lastequality = null;
                        if (preIns && preDel) {
                            postIns = postDel = true;
                            equalitiesLength = 0;
                        } else {
                            equalitiesLength--;
                            pointer = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1;
                            postIns = postDel = false;
                        }
                        changes = true;
                    }
                }
                pointer++;
            }
            if (changes) {
                this.diffCleanupMerge(diffs);
            }
        };
        DiffMatchPatch.prototype.diffPrettyHtml = function (diffs) {
            var op, data, x, html = [];
            for (x = 0; x < diffs.length; x++) {
                op = diffs[x][0];
                data = diffs[x][1];
                switch (op) {
                case DIFF_INSERT:
                    html[x] = '<ins>' + escapeText(data) + '</ins>';
                    break;
                case DIFF_DELETE:
                    html[x] = '<del>' + escapeText(data) + '</del>';
                    break;
                case DIFF_EQUAL:
                    html[x] = '<span>' + escapeText(data) + '</span>';
                    break;
                }
            }
            return html.join('');
        };
        DiffMatchPatch.prototype.diffCommonPrefix = function (text1, text2) {
            var pointermid, pointermax, pointermin, pointerstart;
            if (!text1 || !text2 || text1.charAt(0) !== text2.charAt(0)) {
                return 0;
            }
            pointermin = 0;
            pointermax = Math.min(text1.length, text2.length);
            pointermid = pointermax;
            pointerstart = 0;
            while (pointermin < pointermid) {
                if (text1.substring(pointerstart, pointermid) === text2.substring(pointerstart, pointermid)) {
                    pointermin = pointermid;
                    pointerstart = pointermin;
                } else {
                    pointermax = pointermid;
                }
                pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
            }
            return pointermid;
        };
        DiffMatchPatch.prototype.diffCommonSuffix = function (text1, text2) {
            var pointermid, pointermax, pointermin, pointerend;
            if (!text1 || !text2 || text1.charAt(text1.length - 1) !== text2.charAt(text2.length - 1)) {
                return 0;
            }
            pointermin = 0;
            pointermax = Math.min(text1.length, text2.length);
            pointermid = pointermax;
            pointerend = 0;
            while (pointermin < pointermid) {
                if (text1.substring(text1.length - pointermid, text1.length - pointerend) === text2.substring(text2.length - pointermid, text2.length - pointerend)) {
                    pointermin = pointermid;
                    pointerend = pointermin;
                } else {
                    pointermax = pointermid;
                }
                pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
            }
            return pointermid;
        };
        DiffMatchPatch.prototype.diffCompute = function (text1, text2, checklines, deadline) {
            var diffs, longtext, shorttext, i, hm, text1A, text2A, text1B, text2B, midCommon, diffsA, diffsB;
            if (!text1) {
                return [[
                        DIFF_INSERT,
                        text2
                    ]];
            }
            if (!text2) {
                return [[
                        DIFF_DELETE,
                        text1
                    ]];
            }
            longtext = text1.length > text2.length ? text1 : text2;
            shorttext = text1.length > text2.length ? text2 : text1;
            i = longtext.indexOf(shorttext);
            if (i !== -1) {
                diffs = [
                    [
                        DIFF_INSERT,
                        longtext.substring(0, i)
                    ],
                    [
                        DIFF_EQUAL,
                        shorttext
                    ],
                    [
                        DIFF_INSERT,
                        longtext.substring(i + shorttext.length)
                    ]
                ];
                if (text1.length > text2.length) {
                    diffs[0][0] = diffs[2][0] = DIFF_DELETE;
                }
                return diffs;
            }
            if (shorttext.length === 1) {
                return [
                    [
                        DIFF_DELETE,
                        text1
                    ],
                    [
                        DIFF_INSERT,
                        text2
                    ]
                ];
            }
            hm = this.diffHalfMatch(text1, text2);
            if (hm) {
                text1A = hm[0];
                text1B = hm[1];
                text2A = hm[2];
                text2B = hm[3];
                midCommon = hm[4];
                diffsA = this.DiffMain(text1A, text2A, checklines, deadline);
                diffsB = this.DiffMain(text1B, text2B, checklines, deadline);
                return diffsA.concat([[
                        DIFF_EQUAL,
                        midCommon
                    ]], diffsB);
            }
            if (checklines && text1.length > 100 && text2.length > 100) {
                return this.diffLineMode(text1, text2, deadline);
            }
            return this.diffBisect(text1, text2, deadline);
        };
        DiffMatchPatch.prototype.diffHalfMatch = function (text1, text2) {
            var longtext, shorttext, dmp, text1A, text2B, text2A, text1B, midCommon, hm1, hm2, hm;
            longtext = text1.length > text2.length ? text1 : text2;
            shorttext = text1.length > text2.length ? text2 : text1;
            if (longtext.length < 4 || shorttext.length * 2 < longtext.length) {
                return null;
            }
            dmp = this;
            function diffHalfMatchI(longtext, shorttext, i) {
                var seed, j, bestCommon, prefixLength, suffixLength, bestLongtextA, bestLongtextB, bestShorttextA, bestShorttextB;
                seed = longtext.substring(i, i + Math.floor(longtext.length / 4));
                j = -1;
                bestCommon = '';
                while ((j = shorttext.indexOf(seed, j + 1)) !== -1) {
                    prefixLength = dmp.diffCommonPrefix(longtext.substring(i), shorttext.substring(j));
                    suffixLength = dmp.diffCommonSuffix(longtext.substring(0, i), shorttext.substring(0, j));
                    if (bestCommon.length < suffixLength + prefixLength) {
                        bestCommon = shorttext.substring(j - suffixLength, j) + shorttext.substring(j, j + prefixLength);
                        bestLongtextA = longtext.substring(0, i - suffixLength);
                        bestLongtextB = longtext.substring(i + prefixLength);
                        bestShorttextA = shorttext.substring(0, j - suffixLength);
                        bestShorttextB = shorttext.substring(j + prefixLength);
                    }
                }
                if (bestCommon.length * 2 >= longtext.length) {
                    return [
                        bestLongtextA,
                        bestLongtextB,
                        bestShorttextA,
                        bestShorttextB,
                        bestCommon
                    ];
                } else {
                    return null;
                }
            }
            hm1 = diffHalfMatchI(longtext, shorttext, Math.ceil(longtext.length / 4));
            hm2 = diffHalfMatchI(longtext, shorttext, Math.ceil(longtext.length / 2));
            if (!hm1 && !hm2) {
                return null;
            } else if (!hm2) {
                hm = hm1;
            } else if (!hm1) {
                hm = hm2;
            } else {
                hm = hm1[4].length > hm2[4].length ? hm1 : hm2;
            }
            if (text1.length > text2.length) {
                text1A = hm[0];
                text1B = hm[1];
                text2A = hm[2];
                text2B = hm[3];
            } else {
                text2A = hm[0];
                text2B = hm[1];
                text1A = hm[2];
                text1B = hm[3];
            }
            midCommon = hm[4];
            return [
                text1A,
                text1B,
                text2A,
                text2B,
                midCommon
            ];
        };
        DiffMatchPatch.prototype.diffLineMode = function (text1, text2, deadline) {
            var a, diffs, linearray, pointer, countInsert, countDelete, textInsert, textDelete, j;
            a = this.diffLinesToChars(text1, text2);
            text1 = a.chars1;
            text2 = a.chars2;
            linearray = a.lineArray;
            diffs = this.DiffMain(text1, text2, false, deadline);
            this.diffCharsToLines(diffs, linearray);
            this.diffCleanupSemantic(diffs);
            diffs.push([
                DIFF_EQUAL,
                ''
            ]);
            pointer = 0;
            countDelete = 0;
            countInsert = 0;
            textDelete = '';
            textInsert = '';
            while (pointer < diffs.length) {
                switch (diffs[pointer][0]) {
                case DIFF_INSERT:
                    countInsert++;
                    textInsert += diffs[pointer][1];
                    break;
                case DIFF_DELETE:
                    countDelete++;
                    textDelete += diffs[pointer][1];
                    break;
                case DIFF_EQUAL:
                    if (countDelete >= 1 && countInsert >= 1) {
                        diffs.splice(pointer - countDelete - countInsert, countDelete + countInsert);
                        pointer = pointer - countDelete - countInsert;
                        a = this.DiffMain(textDelete, textInsert, false, deadline);
                        for (j = a.length - 1; j >= 0; j--) {
                            diffs.splice(pointer, 0, a[j]);
                        }
                        pointer = pointer + a.length;
                    }
                    countInsert = 0;
                    countDelete = 0;
                    textDelete = '';
                    textInsert = '';
                    break;
                }
                pointer++;
            }
            diffs.pop();
            return diffs;
        };
        DiffMatchPatch.prototype.diffBisect = function (text1, text2, deadline) {
            var text1Length, text2Length, maxD, vOffset, vLength, v1, v2, x, delta, front, k1start, k1end, k2start, k2end, k2Offset, k1Offset, x1, x2, y1, y2, d, k1, k2;
            text1Length = text1.length;
            text2Length = text2.length;
            maxD = Math.ceil((text1Length + text2Length) / 2);
            vOffset = maxD;
            vLength = 2 * maxD;
            v1 = new Array(vLength);
            v2 = new Array(vLength);
            for (x = 0; x < vLength; x++) {
                v1[x] = -1;
                v2[x] = -1;
            }
            v1[vOffset + 1] = 0;
            v2[vOffset + 1] = 0;
            delta = text1Length - text2Length;
            front = delta % 2 !== 0;
            k1start = 0;
            k1end = 0;
            k2start = 0;
            k2end = 0;
            for (d = 0; d < maxD; d++) {
                if (new Date().getTime() > deadline) {
                    break;
                }
                for (k1 = -d + k1start; k1 <= d - k1end; k1 += 2) {
                    k1Offset = vOffset + k1;
                    if (k1 === -d || k1 !== d && v1[k1Offset - 1] < v1[k1Offset + 1]) {
                        x1 = v1[k1Offset + 1];
                    } else {
                        x1 = v1[k1Offset - 1] + 1;
                    }
                    y1 = x1 - k1;
                    while (x1 < text1Length && y1 < text2Length && text1.charAt(x1) === text2.charAt(y1)) {
                        x1++;
                        y1++;
                    }
                    v1[k1Offset] = x1;
                    if (x1 > text1Length) {
                        k1end += 2;
                    } else if (y1 > text2Length) {
                        k1start += 2;
                    } else if (front) {
                        k2Offset = vOffset + delta - k1;
                        if (k2Offset >= 0 && k2Offset < vLength && v2[k2Offset] !== -1) {
                            x2 = text1Length - v2[k2Offset];
                            if (x1 >= x2) {
                                return this.diffBisectSplit(text1, text2, x1, y1, deadline);
                            }
                        }
                    }
                }
                for (k2 = -d + k2start; k2 <= d - k2end; k2 += 2) {
                    k2Offset = vOffset + k2;
                    if (k2 === -d || k2 !== d && v2[k2Offset - 1] < v2[k2Offset + 1]) {
                        x2 = v2[k2Offset + 1];
                    } else {
                        x2 = v2[k2Offset - 1] + 1;
                    }
                    y2 = x2 - k2;
                    while (x2 < text1Length && y2 < text2Length && text1.charAt(text1Length - x2 - 1) === text2.charAt(text2Length - y2 - 1)) {
                        x2++;
                        y2++;
                    }
                    v2[k2Offset] = x2;
                    if (x2 > text1Length) {
                        k2end += 2;
                    } else if (y2 > text2Length) {
                        k2start += 2;
                    } else if (!front) {
                        k1Offset = vOffset + delta - k2;
                        if (k1Offset >= 0 && k1Offset < vLength && v1[k1Offset] !== -1) {
                            x1 = v1[k1Offset];
                            y1 = vOffset + x1 - k1Offset;
                            x2 = text1Length - x2;
                            if (x1 >= x2) {
                                return this.diffBisectSplit(text1, text2, x1, y1, deadline);
                            }
                        }
                    }
                }
            }
            return [
                [
                    DIFF_DELETE,
                    text1
                ],
                [
                    DIFF_INSERT,
                    text2
                ]
            ];
        };
        DiffMatchPatch.prototype.diffBisectSplit = function (text1, text2, x, y, deadline) {
            var text1a, text1b, text2a, text2b, diffs, diffsb;
            text1a = text1.substring(0, x);
            text2a = text2.substring(0, y);
            text1b = text1.substring(x);
            text2b = text2.substring(y);
            diffs = this.DiffMain(text1a, text2a, false, deadline);
            diffsb = this.DiffMain(text1b, text2b, false, deadline);
            return diffs.concat(diffsb);
        };
        DiffMatchPatch.prototype.diffCleanupSemantic = function (diffs) {
            var changes, equalities, equalitiesLength, lastequality, pointer, lengthInsertions2, lengthDeletions2, lengthInsertions1, lengthDeletions1, deletion, insertion, overlapLength1, overlapLength2;
            changes = false;
            equalities = [];
            equalitiesLength = 0;
            lastequality = null;
            pointer = 0;
            lengthInsertions1 = 0;
            lengthDeletions1 = 0;
            lengthInsertions2 = 0;
            lengthDeletions2 = 0;
            while (pointer < diffs.length) {
                if (diffs[pointer][0] === DIFF_EQUAL) {
                    equalities[equalitiesLength++] = pointer;
                    lengthInsertions1 = lengthInsertions2;
                    lengthDeletions1 = lengthDeletions2;
                    lengthInsertions2 = 0;
                    lengthDeletions2 = 0;
                    lastequality = diffs[pointer][1];
                } else {
                    if (diffs[pointer][0] === DIFF_INSERT) {
                        lengthInsertions2 += diffs[pointer][1].length;
                    } else {
                        lengthDeletions2 += diffs[pointer][1].length;
                    }
                    if (lastequality && lastequality.length <= Math.max(lengthInsertions1, lengthDeletions1) && lastequality.length <= Math.max(lengthInsertions2, lengthDeletions2)) {
                        diffs.splice(equalities[equalitiesLength - 1], 0, [
                            DIFF_DELETE,
                            lastequality
                        ]);
                        diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT;
                        equalitiesLength--;
                        equalitiesLength--;
                        pointer = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1;
                        lengthInsertions1 = 0;
                        lengthDeletions1 = 0;
                        lengthInsertions2 = 0;
                        lengthDeletions2 = 0;
                        lastequality = null;
                        changes = true;
                    }
                }
                pointer++;
            }
            if (changes) {
                this.diffCleanupMerge(diffs);
            }
            pointer = 1;
            while (pointer < diffs.length) {
                if (diffs[pointer - 1][0] === DIFF_DELETE && diffs[pointer][0] === DIFF_INSERT) {
                    deletion = diffs[pointer - 1][1];
                    insertion = diffs[pointer][1];
                    overlapLength1 = this.diffCommonOverlap(deletion, insertion);
                    overlapLength2 = this.diffCommonOverlap(insertion, deletion);
                    if (overlapLength1 >= overlapLength2) {
                        if (overlapLength1 >= deletion.length / 2 || overlapLength1 >= insertion.length / 2) {
                            diffs.splice(pointer, 0, [
                                DIFF_EQUAL,
                                insertion.substring(0, overlapLength1)
                            ]);
                            diffs[pointer - 1][1] = deletion.substring(0, deletion.length - overlapLength1);
                            diffs[pointer + 1][1] = insertion.substring(overlapLength1);
                            pointer++;
                        }
                    } else {
                        if (overlapLength2 >= deletion.length / 2 || overlapLength2 >= insertion.length / 2) {
                            diffs.splice(pointer, 0, [
                                DIFF_EQUAL,
                                deletion.substring(0, overlapLength2)
                            ]);
                            diffs[pointer - 1][0] = DIFF_INSERT;
                            diffs[pointer - 1][1] = insertion.substring(0, insertion.length - overlapLength2);
                            diffs[pointer + 1][0] = DIFF_DELETE;
                            diffs[pointer + 1][1] = deletion.substring(overlapLength2);
                            pointer++;
                        }
                    }
                    pointer++;
                }
                pointer++;
            }
        };
        DiffMatchPatch.prototype.diffCommonOverlap = function (text1, text2) {
            var text1Length, text2Length, textLength, best, length, pattern, found;
            text1Length = text1.length;
            text2Length = text2.length;
            if (text1Length === 0 || text2Length === 0) {
                return 0;
            }
            if (text1Length > text2Length) {
                text1 = text1.substring(text1Length - text2Length);
            } else if (text1Length < text2Length) {
                text2 = text2.substring(0, text1Length);
            }
            textLength = Math.min(text1Length, text2Length);
            if (text1 === text2) {
                return textLength;
            }
            best = 0;
            length = 1;
            while (true) {
                pattern = text1.substring(textLength - length);
                found = text2.indexOf(pattern);
                if (found === -1) {
                    return best;
                }
                length += found;
                if (found === 0 || text1.substring(textLength - length) === text2.substring(0, length)) {
                    best = length;
                    length++;
                }
            }
        };
        DiffMatchPatch.prototype.diffLinesToChars = function (text1, text2) {
            var lineArray, lineHash, chars1, chars2;
            lineArray = [];
            lineHash = {};
            lineArray[0] = '';
            function diffLinesToCharsMunge(text) {
                var chars, lineStart, lineEnd, lineArrayLength, line;
                chars = '';
                lineStart = 0;
                lineEnd = -1;
                lineArrayLength = lineArray.length;
                while (lineEnd < text.length - 1) {
                    lineEnd = text.indexOf('\n', lineStart);
                    if (lineEnd === -1) {
                        lineEnd = text.length - 1;
                    }
                    line = text.substring(lineStart, lineEnd + 1);
                    lineStart = lineEnd + 1;
                    var lineHashExists = lineHash.hasOwnProperty ? lineHash.hasOwnProperty(line) : lineHash[line] !== undefined;
                    if (lineHashExists) {
                        chars += String.fromCharCode(lineHash[line]);
                    } else {
                        chars += String.fromCharCode(lineArrayLength);
                        lineHash[line] = lineArrayLength;
                        lineArray[lineArrayLength++] = line;
                    }
                }
                return chars;
            }
            chars1 = diffLinesToCharsMunge(text1);
            chars2 = diffLinesToCharsMunge(text2);
            return {
                chars1: chars1,
                chars2: chars2,
                lineArray: lineArray
            };
        };
        DiffMatchPatch.prototype.diffCharsToLines = function (diffs, lineArray) {
            var x, chars, text, y;
            for (x = 0; x < diffs.length; x++) {
                chars = diffs[x][1];
                text = [];
                for (y = 0; y < chars.length; y++) {
                    text[y] = lineArray[chars.charCodeAt(y)];
                }
                diffs[x][1] = text.join('');
            }
        };
        DiffMatchPatch.prototype.diffCleanupMerge = function (diffs) {
            var pointer, countDelete, countInsert, textInsert, textDelete, commonlength, changes, diffPointer, position;
            diffs.push([
                DIFF_EQUAL,
                ''
            ]);
            pointer = 0;
            countDelete = 0;
            countInsert = 0;
            textDelete = '';
            textInsert = '';
            while (pointer < diffs.length) {
                switch (diffs[pointer][0]) {
                case DIFF_INSERT:
                    countInsert++;
                    textInsert += diffs[pointer][1];
                    pointer++;
                    break;
                case DIFF_DELETE:
                    countDelete++;
                    textDelete += diffs[pointer][1];
                    pointer++;
                    break;
                case DIFF_EQUAL:
                    if (countDelete + countInsert > 1) {
                        if (countDelete !== 0 && countInsert !== 0) {
                            commonlength = this.diffCommonPrefix(textInsert, textDelete);
                            if (commonlength !== 0) {
                                if (pointer - countDelete - countInsert > 0 && diffs[pointer - countDelete - countInsert - 1][0] === DIFF_EQUAL) {
                                    diffs[pointer - countDelete - countInsert - 1][1] += textInsert.substring(0, commonlength);
                                } else {
                                    diffs.splice(0, 0, [
                                        DIFF_EQUAL,
                                        textInsert.substring(0, commonlength)
                                    ]);
                                    pointer++;
                                }
                                textInsert = textInsert.substring(commonlength);
                                textDelete = textDelete.substring(commonlength);
                            }
                            commonlength = this.diffCommonSuffix(textInsert, textDelete);
                            if (commonlength !== 0) {
                                diffs[pointer][1] = textInsert.substring(textInsert.length - commonlength) + diffs[pointer][1];
                                textInsert = textInsert.substring(0, textInsert.length - commonlength);
                                textDelete = textDelete.substring(0, textDelete.length - commonlength);
                            }
                        }
                        if (countDelete === 0) {
                            diffs.splice(pointer - countInsert, countDelete + countInsert, [
                                DIFF_INSERT,
                                textInsert
                            ]);
                        } else if (countInsert === 0) {
                            diffs.splice(pointer - countDelete, countDelete + countInsert, [
                                DIFF_DELETE,
                                textDelete
                            ]);
                        } else {
                            diffs.splice(pointer - countDelete - countInsert, countDelete + countInsert, [
                                DIFF_DELETE,
                                textDelete
                            ], [
                                DIFF_INSERT,
                                textInsert
                            ]);
                        }
                        pointer = pointer - countDelete - countInsert + (countDelete ? 1 : 0) + (countInsert ? 1 : 0) + 1;
                    } else if (pointer !== 0 && diffs[pointer - 1][0] === DIFF_EQUAL) {
                        diffs[pointer - 1][1] += diffs[pointer][1];
                        diffs.splice(pointer, 1);
                    } else {
                        pointer++;
                    }
                    countInsert = 0;
                    countDelete = 0;
                    textDelete = '';
                    textInsert = '';
                    break;
                }
            }
            if (diffs[diffs.length - 1][1] === '') {
                diffs.pop();
            }
            changes = false;
            pointer = 1;
            while (pointer < diffs.length - 1) {
                if (diffs[pointer - 1][0] === DIFF_EQUAL && diffs[pointer + 1][0] === DIFF_EQUAL) {
                    diffPointer = diffs[pointer][1];
                    position = diffPointer.substring(diffPointer.length - diffs[pointer - 1][1].length);
                    if (position === diffs[pointer - 1][1]) {
                        diffs[pointer][1] = diffs[pointer - 1][1] + diffs[pointer][1].substring(0, diffs[pointer][1].length - diffs[pointer - 1][1].length);
                        diffs[pointer + 1][1] = diffs[pointer - 1][1] + diffs[pointer + 1][1];
                        diffs.splice(pointer - 1, 1);
                        changes = true;
                    } else if (diffPointer.substring(0, diffs[pointer + 1][1].length) === diffs[pointer + 1][1]) {
                        diffs[pointer - 1][1] += diffs[pointer + 1][1];
                        diffs[pointer][1] = diffs[pointer][1].substring(diffs[pointer + 1][1].length) + diffs[pointer + 1][1];
                        diffs.splice(pointer + 1, 1);
                        changes = true;
                    }
                }
                pointer++;
            }
            if (changes) {
                this.diffCleanupMerge(diffs);
            }
        };
        return function (o, n) {
            var diff, output, text;
            diff = new DiffMatchPatch();
            output = diff.DiffMain(o, n);
            diff.diffCleanupEfficiency(output);
            text = diff.diffPrettyHtml(output);
            return text;
        };
    }();
}(function () {
    return this;
}()));
/*can-ajax@1.1.4#test/qunit*/
define('can-ajax@1.1.4#test/qunit', [
    'require',
    'exports',
    'module',
    'qunitjs',
    'steal-qunit'
], function (require, exports, module) {
    'use strict';
    var testType = typeof process !== 'undefined' && process.env.TEST;
    var isMochaQUnitUI = testType === 'mocha';
    var isQunit = testType === 'qunit';
    if (isMochaQUnitUI) {
        QUnit.assert.async = function () {
            QUnit.stop();
            return function done(error) {
                if (error) {
                    return QUnit.ok(false, '' + error);
                }
                QUnit.start();
            };
        };
        QUnit.test = test;
        module.exports = QUnit;
    } else if (isQunit) {
        module.exports = require('qunitjs');
    } else {
        module.exports = require('steal-qunit');
    }
});
/*can-ajax@1.1.4#test/helpers*/
define('can-ajax@1.1.4#test/helpers', [
    'require',
    'exports',
    'module',
    'can-globals/global/global'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        'use strict';
        var getGlobal = require('can-globals/global/global');
        function isProduction() {
            var root = getGlobal();
            if (root.System) {
                return root.System.env.indexOf('production') !== -1;
            }
            if (root.process) {
                var nodeEnv = root.process.env.NODE_ENV;
                return nodeEnv === 'production' || nodeEnv === 'window-production';
            }
            return false;
        }
        function isServer() {
            var root = getGlobal();
            var testType = root.process && root.process.env.TEST;
            return testType === 'qunit';
        }
        module.exports = {
            isProduction: isProduction,
            isServer: isServer
        };
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-ajax@1.1.4#can-ajax-test*/
define('can-ajax@1.1.4#can-ajax-test', [
    'require',
    'exports',
    'module',
    './can-ajax',
    'can-namespace',
    'can-make-map',
    'can-globals/global/global',
    'can-parse-uri',
    './test/qunit',
    './test/helpers'
], function (require, exports, module) {
    (function (global, __dirname, require, exports, module) {
        'use strict';
        var ajax = require('./can-ajax');
        var namespace = require('can-namespace');
        var makeMap = require('can-make-map');
        var GLOBAL = require('can-globals/global/global');
        var parseURI = require('can-parse-uri');
        var QUnit = require('./test/qunit');
        var helpers = require('./test/helpers');
        var isMainCanTest = typeof System === 'object' && System.env !== 'canjs-test';
        var hasLocalServer = !helpers.isServer() && !helpers.isProduction();
        QUnit.module('can-ajax');
        var makeFixture = function (XHR) {
            var oldXhr = window.XMLHttpRequest || window.ActiveXObject;
            if (window.XMLHttpRequest) {
                window.XMLHttpRequest = XHR;
            } else if (window.ActiveXObject) {
                window.ActiveXObject = XHR;
            }
            return function restoreXHR() {
                if (window.XMLHttpRequest) {
                    window.XMLHttpRequest = oldXhr;
                } else if (window.ActiveXObject) {
                    window.ActiveXObject = oldXhr;
                }
            };
        };
        var makePredicateContains = function (str) {
            var obj = makeMap(str);
            return function (val) {
                return obj[val];
            };
        };
        if (hasLocalServer) {
            QUnit.test('basic get request', function (assert) {
                var done = assert.async();
                ajax({
                    type: 'get',
                    url: __dirname + '/can-ajax-test-result.json'
                }).then(function (resp) {
                    assert.equal(resp.message, 'VALUE');
                    done();
                });
            });
        }
        QUnit.test('added to namespace (#99)', function (assert) {
            assert.equal(namespace.ajax, ajax);
        });
        if (hasLocalServer) {
            QUnit.test('GET requests with dataType parse JSON (#106)', function (assert) {
                var done = assert.async();
                ajax({
                    type: 'get',
                    url: __dirname + '/can-ajax-test-result.txt',
                    dataType: 'json'
                }).then(function (resp) {
                    assert.equal(resp.message, 'VALUE');
                    done();
                });
            });
        }
        QUnit.test('ignores case of type parameter for a post request (#100)', function (assert) {
            var done = assert.async();
            var requestHeaders = { CONTENT_TYPE: 'Content-Type' }, restore = makeFixture(function () {
                    this.open = function (type, url) {
                    };
                    this.send = function () {
                        this.readyState = 4;
                        this.status = 200;
                        this.onreadystatechange();
                    };
                    this.setRequestHeader = function (header, value) {
                        if (header === requestHeaders.CONTENT_TYPE) {
                            var o = {};
                            o[header] = value;
                            this.responseText = JSON.stringify(o);
                        }
                    };
                });
            ajax({
                type: 'post',
                url: 'http://anotherdomain.com/foo',
                data: { bar: 'qux' }
            }).then(function (value) {
                assert.equal(value[requestHeaders.CONTENT_TYPE], 'application/x-www-form-urlencoded');
            }, function (reason) {
                assert.notOk(reason, 'request failed with reason = ', reason);
            }).then(function () {
                restore();
                done();
            });
        });
        QUnit.test('url encodes GET requests when no contentType', function (assert) {
            var done = assert.async();
            var restore = makeFixture(function () {
                var o = {};
                this.open = function (type, url) {
                    o.url = url;
                };
                this.send = function (data) {
                    o.data = data;
                    this.readyState = 4;
                    this.status = 200;
                    this.responseText = JSON.stringify(o);
                    this.onreadystatechange();
                };
                this.setRequestHeader = function (header, value) {
                    if (header === 'Content-Type') {
                        o[header] = value;
                    }
                };
            });
            ajax({
                type: 'get',
                url: 'http://anotherdomain.com/foo',
                data: { foo: 'bar' }
            }).then(function (value) {
                assert.equal(value['Content-Type'], 'application/x-www-form-urlencoded');
                assert.equal(value.data, undefined, 'No data provided because it\'s a GET');
                assert.equal(value.url, 'http://anotherdomain.com/foo?foo=bar');
            }, function (reason) {
                assert.notOk(reason, 'request failed with reason = ', reason);
            }).then(function () {
                restore();
                done();
            });
        });
        QUnit.test('Stringifies GET requests when contentType=application/json', function (assert) {
            var done = assert.async();
            var restore = makeFixture(function () {
                var o = {};
                this.open = function (type, url) {
                    o.url = url;
                };
                this.send = function (data) {
                    o.data = data;
                    this.readyState = 4;
                    this.status = 200;
                    this.responseText = JSON.stringify(o);
                    this.onreadystatechange();
                };
                this.setRequestHeader = function (header, value) {
                    if (header === 'Content-Type') {
                        o[header] = value;
                    }
                };
            });
            ajax({
                type: 'get',
                url: 'http://anotherdomain.com/foo',
                data: { foo: 'bar' },
                contentType: 'application/json'
            }).then(function (value) {
                assert.equal(value['Content-Type'], 'application/json');
                assert.equal(value.data, undefined, 'No data provided because it\'s a GET');
                assert.equal(value.url, 'http://anotherdomain.com/foo?{"foo":"bar"}');
            }, function (reason) {
                assert.notOk(reason, 'request failed with reason = ', reason);
            }).then(function () {
                restore();
                done();
            });
        });
        QUnit.test('Stringifies POST requests when there is no contentType', function (assert) {
            var done = assert.async();
            var restore = makeFixture(function () {
                var o = {};
                this.open = function (type, url) {
                    o.url = url;
                };
                this.send = function (data) {
                    o.data = data;
                    this.readyState = 4;
                    this.status = 200;
                    this.responseText = JSON.stringify(o);
                    this.onreadystatechange();
                };
                this.setRequestHeader = function (header, value) {
                    if (header === 'Content-Type') {
                        o[header] = value;
                    }
                };
            });
            var origin = parseURI(GLOBAL().location.href);
            var url = origin.protocol + origin.authority + '/foo';
            ajax({
                type: 'post',
                url: url,
                data: { foo: 'bar' }
            }).then(function (value) {
                assert.equal(value['Content-Type'], 'application/json');
                assert.equal(value.data, '{"foo":"bar"}', 'Data was stringified');
                assert.equal(value.url, url);
            }, function (reason) {
                assert.notOk(reason, 'request failed with reason = ', reason);
            }).then(function () {
                restore();
                done();
            });
        });
        QUnit.test('url encodes POST requests when contentType=application/x-www-form-urlencoded', function (assert) {
            var done = assert.async();
            var restore = makeFixture(function () {
                var o = {};
                this.open = function (type, url) {
                    o.url = url;
                };
                this.send = function (data) {
                    o.data = data;
                    this.readyState = 4;
                    this.status = 200;
                    this.responseText = JSON.stringify(o);
                    this.onreadystatechange();
                };
                this.setRequestHeader = function (header, value) {
                    if (header === 'Content-Type') {
                        o[header] = value;
                    }
                };
            });
            ajax({
                type: 'post',
                url: 'http://anotherdomain.com/foo',
                data: { foo: 'bar' },
                contentType: 'application/x-www-form-urlencoded'
            }).then(function (value) {
                assert.equal(value['Content-Type'], 'application/x-www-form-urlencoded');
                assert.equal(value.data, 'foo=bar', 'Data was url encoded');
                assert.equal(value.url, 'http://anotherdomain.com/foo');
            }, function (reason) {
                assert.notOk(reason, 'request failed with reason = ', reason);
            }).then(function () {
                restore();
                done();
            });
        });
        if (typeof XDomainRequest === 'undefined') {
            if (!helpers.isServer()) {
                QUnit.test('cross domain post request should change data to form data (#90)', function (assert) {
                    var done = assert.async();
                    ajax({
                        type: 'POST',
                        url: 'http://httpbin.org/post',
                        data: { 'message': 'VALUE' },
                        dataType: 'application/json'
                    }).then(function (resp) {
                        assert.equal(resp.form.message, 'VALUE');
                        done();
                    });
                });
            }
            QUnit.test('GET CORS should be a simple request - without a preflight (#187)', function (assert) {
                var done = assert.async();
                var isSimpleRequest = true, restore;
                var isSimpleMethod = makePredicateContains('GET,POST,HEAD');
                var isSimpleHeader = makePredicateContains('Accept,Accept-Language,Content-Language,Content-Type,DPR,Downlink,Save-Data,Viewport-Width,Width');
                var isSimpleContentType = makePredicateContains('application/x-www-form-urlencoded,multipart/form-data,text/plain');
                restore = makeFixture(function () {
                    this.open = function (type, url) {
                        if (!isSimpleMethod(type)) {
                            isSimpleRequest = false;
                        }
                    };
                    var response = {};
                    this.send = function () {
                        this.responseText = JSON.stringify(response);
                        this.readyState = 4;
                        this.status = 200;
                        this.onreadystatechange();
                    };
                    this.setRequestHeader = function (header, value) {
                        if (header === 'Content-Type' && !isSimpleContentType(value)) {
                            isSimpleRequest = false;
                        }
                        if (isSimpleRequest && !isSimpleHeader(header)) {
                            isSimpleRequest = false;
                        }
                        response[header] = value;
                    };
                });
                ajax({
                    url: 'http://query.yahooapis.com/v1/public/yql',
                    data: {
                        q: 'select * from geo.places where text="sunnyvale, ca"',
                        format: 'json'
                    }
                }).then(function (response) {
                    assert.ok(isSimpleRequest, 'CORS GET is simple');
                    restore();
                    done();
                }, function (err) {
                    assert.ok(false, 'Should be resolved');
                    restore();
                    done();
                });
            });
        }
        if (isMainCanTest && hasLocalServer) {
            QUnit.test('abort', function (assert) {
                var done = assert.async();
                var promise = ajax({
                    type: 'get',
                    url: __dirname + '/can-ajax-test-result.json'
                });
                promise.catch(function (xhr) {
                    if (xhr instanceof Error) {
                        assert.equal(xhr.message, 'Could not complete the operation due to error c00c023f.');
                        done();
                    } else {
                        setTimeout(function () {
                            assert.equal(xhr.readyState, 0, 'aborts the promise');
                            done();
                        }, 50);
                    }
                });
                promise.abort();
            });
        }
        QUnit.test('crossDomain is true for relative requests', function (assert) {
            var done = assert.async();
            var headers = {}, restore = makeFixture(function () {
                    this.open = function (type, url) {
                    };
                    this.send = function () {
                        this.readyState = 4;
                        this.status = 200;
                        this.responseText = JSON.stringify({ great: 'success' });
                        this.onreadystatechange();
                    };
                    this.setRequestHeader = function (header, value) {
                        headers[header] = value;
                    };
                });
            ajax({
                type: 'post',
                url: '/foo',
                data: { bar: 'qux' },
                dataType: 'json'
            }).then(function (value) {
                assert.deepEqual(headers, {
                    'Content-Type': 'application/json',
                    'X-Requested-With': 'XMLHttpRequest'
                });
            }, function (reason) {
                assert.notOk(reason, 'request failed with reason = ', reason);
            }).then(function () {
                restore();
                done();
            });
        });
        QUnit.test('handles 204 No Content responses when expecting JSON', function (assert) {
            var done = assert.async();
            var headers = {}, restore = makeFixture(function () {
                    this.open = function (type, url) {
                    };
                    this.send = function () {
                        this.readyState = 4;
                        this.status = 204;
                        this.responseText = '';
                        this.onreadystatechange();
                    };
                    this.setRequestHeader = function (header, value) {
                        headers[header] = value;
                    };
                });
            ajax({
                type: 'delete',
                url: '/foo',
                data: { id: 'qux' },
                dataType: 'json'
            }).then(function () {
                assert.deepEqual(headers, {
                    'Content-Type': 'application/json',
                    'X-Requested-With': 'XMLHttpRequest'
                });
            }, function (reason) {
                assert.notOk(reason, 'request failed with reason = ', reason);
            }).then(function () {
                restore();
                done();
            });
        });
        if (hasLocalServer) {
            QUnit.test('correctly serializes null and undefined values (#177)', function (assert) {
                var done = assert.async();
                ajax({
                    type: 'get',
                    url: __dirname + '/can-ajax-test-result.txt',
                    data: { foo: null }
                }).then(function (resp) {
                    assert.equal(resp.message, 'VALUE');
                    done();
                });
            });
        }
    }(function () {
        return this;
    }(), '/', require, exports, module));
});
/*can-assign@1.1.1#can-assign-test*/
define('can-assign@1.1.1#can-assign-test', [
    'require',
    'exports',
    'module',
    './can-assign',
    'steal-qunit'
], function (require, exports, module) {
    var assign = require('./can-assign');
    var QUnit = require('steal-qunit');
    QUnit.module('can-assign');
    QUnit.test('Assign all properties to an object', function () {
        var a = {
            a: 1,
            b: 2,
            d: 3
        };
        var b = {
            a: 1,
            b: 3,
            c: 2
        };
        var expected = {
            a: 1,
            b: 3,
            c: 2,
            d: 3
        };
        var actual = assign(a, b);
        for (var prop in actual) {
            equal(expected[prop], actual[prop]);
        }
    });
});
/*can-construct@3.3.0#can-construct_test*/
define('can-construct@3.3.0#can-construct_test', [
    'require',
    'exports',
    'module',
    'steal-qunit',
    'can-construct',
    'can-util/js/dev/',
    'can-util/js/make-array/'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        QUnit = require('steal-qunit');
        var Construct = require('can-construct');
        var dev = require('can-util/js/dev/');
        var makeArray = require('can-util/js/make-array/');
        QUnit.module('can-construct', {
            setup: function () {
                var Animal = this.Animal = Construct.extend({
                    count: 0,
                    test: function () {
                        return this.match ? true : false;
                    }
                }, {
                    init: function () {
                        this.constructor.count++;
                        this.eyes = false;
                    }
                });
                var Dog = this.Dog = this.Animal.extend({ match: /abc/ }, {
                    init: function () {
                        Animal.prototype.init.apply(this, arguments);
                    },
                    talk: function () {
                        return 'Woof';
                    }
                });
                this.Ajax = this.Dog.extend({ count: 0 }, {
                    init: function (hairs) {
                        Dog.prototype.init.apply(this, arguments);
                        this.hairs = hairs;
                        this.setEyes();
                    },
                    setEyes: function () {
                        this.eyes = true;
                    }
                });
            }
        });
        test('inherit', function () {
            var Base = Construct({});
            ok(new Base() instanceof Construct);
            var Inherit = Base({});
            ok(new Inherit() instanceof Base);
        });
        test('Creating', function () {
            new this.Dog();
            var a1 = new this.Animal();
            new this.Animal();
            var ajax = new this.Ajax(1000);
            equal(2, this.Animal.count, 'right number of animals');
            equal(1, this.Dog.count, 'right number of animals');
            ok(this.Dog.match, 'right number of animals');
            ok(!this.Animal.match, 'right number of animals');
            ok(this.Dog.test(), 'right number of animals');
            ok(!this.Animal.test(), 'right number of animals');
            equal(1, this.Ajax.count, 'right number of animals');
            equal(2, this.Animal.count, 'right number of animals');
            equal(true, ajax.eyes, 'right number of animals');
            equal(1000, ajax.hairs, 'right number of animals');
            ok(a1 instanceof this.Animal);
            ok(a1 instanceof Construct);
        });
        test('new instance', function () {
            var d = this.Ajax.newInstance(6);
            equal(6, d.hairs);
        });
        test('namespaces', function () {
            var fb = Construct.extend('Bar');
            ok(!window.Bar, 'not added to global namespace');
            if (Object.getOwnPropertyDescriptor) {
                equal(fb.name, 'Bar', 'name is right');
            }
            equal(fb.shortName, 'Bar', 'short name is right');
        });
        test('setups', function () {
            var order = 0, staticSetup, staticSetupArgs, staticInit, staticInitArgs, protoSetup, protoInitArgs, protoInit, staticProps = {
                    setup: function () {
                        staticSetup = ++order;
                        staticSetupArgs = arguments;
                        return ['something'];
                    },
                    init: function () {
                        staticInit = ++order;
                        staticInitArgs = arguments;
                    }
                }, protoProps = {
                    setup: function (name) {
                        protoSetup = ++order;
                        return ['Ford: ' + name];
                    },
                    init: function () {
                        protoInit = ++order;
                        protoInitArgs = arguments;
                    }
                };
            var Car = Construct.extend('Car', staticProps, protoProps);
            new Car('geo');
            equal(staticSetup, 1);
            equal(staticInit, 2);
            equal(protoSetup, 3);
            equal(protoInit, 4);
            deepEqual(makeArray(staticInitArgs), ['something']);
            deepEqual(makeArray(protoInitArgs), ['Ford: geo']);
            deepEqual(makeArray(staticSetupArgs), [
                Construct,
                'Car',
                staticProps,
                protoProps
            ], 'static construct');
            Car.extend('Truck');
            equal(staticSetup, 5, 'Static setup is called if overwriting');
        });
        test('Creating without extend', function () {
            var Bar = Construct('Bar', {
                ok: function () {
                    ok(true, 'ok called');
                }
            });
            new Bar().ok();
            var Foo = Bar('Foo', {
                dude: function () {
                    ok(true, 'dude called');
                }
            });
            new Foo().dude(true);
        });
        test('setup called with original arguments', function () {
            var o2 = {};
            var o1 = {
                setup: function (base, arg1, arg2) {
                    equal(o1, arg1, 'first argument is correct');
                    equal(o2, arg2, 'second argument is correct');
                }
            };
            Construct.extend(o1, o2);
        });
        test('legacy namespace strings (A.B.C) accepted', function () {
            var Type = Construct.extend('Foo.Bar.Baz');
            var expectedValue = ~steal.config('env').indexOf('production') ? '' : 'Foo_Bar_Baz';
            ok(new Type() instanceof Construct, 'No unexpected behavior in the prototype chain');
            if (Function.prototype.name) {
                equal(Type.name, expectedValue, 'Name becomes underscored');
            }
        });
        test('reserved words accepted', function () {
            var Type = Construct.extend('const');
            var expectedValue = ~steal.config('env').indexOf('production') ? '' : 'Const';
            ok(new Type() instanceof Construct, 'No unexpected behavior in the prototype chain');
            if (Function.prototype.name) {
                equal(Type.name, expectedValue, 'Name becomes capitalized');
            }
        });
        test('basic injection attacks thwarted', function () {
            var rootToken = typeof window === 'undefined' ? 'global' : 'window';
            var rootObject = typeof window === 'undefined' ? global : window;
            var expando = 'foo' + Math.random().toString(10).slice(2);
            var MalignantType;
            try {
                MalignantType = Construct.extend('(){};' + rootToken + '.' + expando + '=\'bar\';var f=function');
            } catch (e) {
            } finally {
                equal(rootObject[expando], undefined, 'Injected code doesn\'t run');
            }
            delete rootObject[expando];
            try {
                MalignantType = Construct.extend('(){},' + rootToken + '.' + expando + '=\'baz\',function');
            } catch (e) {
            } finally {
                equal(rootObject[expando], undefined, 'Injected code doesn\'t run');
            }
        });
        QUnit.test('setters not invoked on extension (#28)', function () {
            var extending = true;
            var Base = Construct.extend('Base', {
                set something(value) {
                    QUnit.ok(!extending, 'called when not extending');
                },
                get something() {
                }
            });
            Base.extend('Extended', { something: 'value' });
            extending = false;
            new Base().something = 'foo';
        });
        QUnit.test('return alternative value simple', function () {
            var Alternative = function () {
            };
            var Base = Construct.extend({
                setup: function () {
                    return new Construct.ReturnValue(new Alternative());
                }
            });
            QUnit.ok(new Base() instanceof Alternative, 'Should create an instance of Alternative');
        });
        QUnit.test('return alternative value on setup (full case)', function () {
            var Student = function (name, school) {
                this.name = name;
                this.school = school;
                this.isStudent = true;
            };
            var Person = Construct.extend({
                setup: function (opts) {
                    if (opts.age >= 16) {
                        return new Construct.ReturnValue(new Student(opts.name, opts.school));
                    }
                    opts.isStudent = false;
                    return [opts];
                },
                init: function (params) {
                    this.age = params.age;
                    this.name = params.name;
                    this.isStudent = params.isStudent;
                }
            });
            QUnit.equal(new Person({ age: 12 }).isStudent, false, 'Age 12 cannot be a student');
            QUnit.equal(new Person({ age: 30 }).isStudent, true, 'Age 20 can be a student');
            QUnit.ok(new Person({ age: 30 }) instanceof Student, 'Should return an instance of Student');
        });
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-construct-super@3.1.4#can-construct-super*/
define('can-construct-super@3.1.4#can-construct-super', [
    'require',
    'exports',
    'module',
    'can-util/js/is-function/is-function',
    'can-util/js/each/each',
    'can-construct'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        var canIsFunction = require('can-util/js/is-function/is-function');
        var canEach = require('can-util/js/each/each');
        var Construct = require('can-construct');
        var hasOwnProperty = Object.prototype.hasOwnProperty;
        var isFunction = canIsFunction, fnTest = /xyz/.test(function () {
                return this.xyz;
            }) ? /\b_super\b/ : /.*/, getset = [
                'get',
                'set'
            ], getSuper = function (base, name, fn) {
                return function () {
                    var hasExistingValue = false;
                    var existingValue;
                    var prototype = getPrototypeOf(this);
                    var existingPrototypeValue = prototype._super;
                    if (hasOwnProperty.call(this, '_super')) {
                        hasExistingValue = true;
                        existingValue = this._super;
                        delete this._super;
                    }
                    prototype._super = base[name];
                    var ret = fn.apply(this, arguments);
                    prototype._super = existingPrototypeValue;
                    if (hasExistingValue) {
                        this._super = existingValue;
                    }
                    return ret;
                };
            };
        Construct._defineProperty = function (addTo, base, name, descriptor) {
            var _super = Object.getOwnPropertyDescriptor(base, name);
            if (_super) {
                canEach(getset, function (method) {
                    if (isFunction(_super[method]) && isFunction(descriptor[method])) {
                        descriptor[method] = getSuper(_super, method, descriptor[method]);
                    } else if (!isFunction(descriptor[method])) {
                        descriptor[method] = _super[method];
                    }
                });
            }
            Object.defineProperty(addTo, name, descriptor);
        };
        var getPrototypeOf = Object.getPrototypeOf || function (obj) {
            return obj.__proto__;
        };
        var getPropertyDescriptor = Object.getPropertyDescriptor || function (subject, name) {
            if (name in subject) {
                var pd = Object.getOwnPropertyDescriptor(subject, name);
                var proto = getPrototypeOf(subject);
                while (pd === undefined && proto !== null) {
                    pd = Object.getOwnPropertyDescriptor(proto, name);
                    proto = getPrototypeOf(proto);
                }
                return pd;
            }
        };
        Construct._overwrite = function (addTo, base, name, val) {
            var baseDescriptor = getPropertyDescriptor(base, name);
            var baseValue = baseDescriptor && baseDescriptor.value;
            Object.defineProperty(addTo, name, {
                value: isFunction(val) && isFunction(baseValue) && fnTest.test(val) ? getSuper(base, name, val) : val,
                configurable: true,
                enumerable: true,
                writable: true
            });
        };
        module.exports = Construct;
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-construct-super@3.1.4#test/can-construct-super_test*/
define('can-construct-super@3.1.4#test/can-construct-super_test', [
    'require',
    'exports',
    'module',
    'can-construct-super',
    'steal-qunit'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        var Construct = require('can-construct-super');
        var QUnit = require('steal-qunit');
        QUnit.module('can-construct-super');
        test('prototype super', function () {
            var A = Construct.extend({
                init: function (arg) {
                    this.arg = arg + 1;
                },
                add: function (num) {
                    return this.arg + num;
                }
            });
            var B = A({
                init: function (arg) {
                    this._super(arg + 2);
                },
                add: function (arg) {
                    return this._super(arg + 1);
                }
            });
            var b = new B(1);
            equal(b.arg, 4);
            equal(b.add(2), 7);
        });
        test('static super', function () {
            var First = Construct.extend({
                raise: function (num) {
                    return num;
                }
            }, {});
            var Second = First.extend({
                raise: function (num) {
                    return this._super(num) * num;
                }
            }, {});
            equal(Second.raise(2), 4);
        });
        test('findAll super', function () {
            var Parent = Construct.extend({
                findAll: function () {
                    equal(this.shortName, 'child');
                    return Promise.resolve();
                },
                shortName: 'parent'
            }, {});
            var Child = Parent.extend({
                findAll: function () {
                    return this._super();
                },
                shortName: 'child'
            }, {});
            stop();
            expect(1);
            Child.findAll({});
            start();
        });
        if (Object.getOwnPropertyDescriptor) {
            test('_super supports getters and setters', function () {
                var Person = Construct.extend({
                    get age() {
                        return 42;
                    },
                    set name(value) {
                        this._name = value;
                    },
                    get name() {
                        return this._name;
                    }
                });
                var OtherPerson = Person.extend({
                    get age() {
                        return this._super() + 8;
                    },
                    set name(value) {
                        this._super(value + '_super');
                    }
                });
                var test = new OtherPerson();
                test.base = 2;
                equal(test.age, 50, 'Getter and _super works');
                test.name = 'David';
                equal(test.name, 'David_super', 'Setter ran');
            });
        }
        QUnit.test('setters not invoked on extension (#9)', function () {
            var extending = true;
            var Base = Construct.extend('Base', {
                set something(value) {
                    QUnit.ok(!extending, 'set not called when not extending');
                },
                get something() {
                    QUnit.ok(!extending, 'get not called when not extending');
                }
            });
            Base.extend('Extended', { something: 'value' });
            extending = false;
            new Base().something = 'foo';
        });
        QUnit.test('_super isn\'t always available (#11)', function () {
            var Parent = Construct.extend({});
            var Child = Parent.extend({
                init: function () {
                    this._super();
                    ok(true);
                }
            });
            new Child();
        });
        QUnit.test('_super should work for sealed instances', function () {
            var A = Construct.extend({
                init: function (arg) {
                    this.arg = arg + 1;
                },
                add: function (num) {
                    return this.arg + num;
                }
            });
            var B = A({
                init: function (arg) {
                    this._super(arg + 2);
                },
                add: function (arg) {
                    return this._super(arg + 1);
                }
            });
            var b = new B(1);
            Object.seal(b);
            equal(b.arg, 4, 'should instantiate properly');
            equal(b.add(2), 7, 'should call methods properly');
        });
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-control@4.0.1#can-control_test*/
define('can-control@4.0.1#can-control_test', [
    'require',
    'exports',
    'module',
    'can-control',
    'steal-qunit',
    'can-util/dom/fragment/fragment',
    'can-util/js/dev/dev',
    'can-dom-events',
    'can-util/dom/class-name/class-name',
    'can-dom-mutate/node',
    'can-simple-map',
    'can-define/map/',
    'can-simple-observable'
], function (require, exports, module) {
    var Control = require('can-control');
    var QUnit = require('steal-qunit');
    var fragment = require('can-util/dom/fragment/fragment');
    var dev = require('can-util/js/dev/dev');
    var domEvents = require('can-dom-events');
    var className = require('can-util/dom/class-name/class-name');
    var domMutateNode = require('can-dom-mutate/node');
    var SimpleMap = require('can-simple-map');
    var DefineMap = require('can-define/map/');
    var SimpleObservable = require('can-simple-observable');
    QUnit.module('can-control', {
        setup: function () {
            this.fixture = document.getElementById('qunit-fixture');
        }
    });
    test('parameterized actions', function () {
        var called = false, WeirderBind = Control.extend({
                '{parameterized}': function () {
                    called = true;
                }
            }), a;
        this.fixture.appendChild(fragment('<div id=\'crazy\'></div>'));
        a = document.getElementById('crazy');
        new WeirderBind(a, { parameterized: 'sillyEvent' });
        domEvents.dispatch(a, 'sillyEvent');
        ok(called, 'heard the trigger');
    });
    test('windowresize', function () {
        var called = false, WindowBind = Control.extend('', {
                '{window} resize': function () {
                    called = true;
                }
            });
        this.fixture.appendChild(fragment('<div id=\'weird\'>'));
        new WindowBind('#weird');
        domEvents.dispatch(window, 'resize');
        ok(called, 'got window resize event');
    });
    test('on', 9, function () {
        var called = false, DelegateTest = Control.extend({
                click: function () {
                }
            }), Tester = Control.extend({
                init: function (el, ops) {
                    this.on(window, 'click', function (ev) {
                        ok(true, 'Got window click event');
                    });
                    this.on(window, 'click', 'clicked');
                    this.on('click', function () {
                        ok(true, 'Directly clicked element');
                    });
                    this.on('click', 'clicked');
                },
                clicked: function (context) {
                    ok(true, 'Controller action delegated click triggered, too');
                }
            }), div = document.createElement('div');
        this.fixture.appendChild(div);
        var rb = new Tester(div);
        this.fixture.appendChild(fragment('<div id=\'els\'><span id=\'elspan\'><a href=\'javascript://\' id=\'elsa\'>click me</a></span></div>'));
        var dt = new DelegateTest('#els');
        dt.on(document.querySelector('#els span'), 'a', 'click', function () {
            called = true;
        });
        domEvents.dispatch(document.querySelector('#els a'), 'click');
        ok(called, 'delegate works');
        domMutateNode.removeChild.call(this.fixture, document.querySelector('#els'));
        domEvents.dispatch(div, 'click');
        domEvents.dispatch(window, 'click');
        rb.destroy();
    });
    test('inherit', function () {
        var called = false, Parent = Control.extend({
                click: function () {
                    called = true;
                }
            }), Child = Parent.extend({});
        this.fixture.appendChild(fragment('<div id=\'els\'><span id=\'elspan\'><a href=\'#\' id=\'elsa\'>click me</a></span></div>'));
        new Child('#els');
        domEvents.dispatch(document.querySelector('#els'), 'click');
        ok(called, 'inherited the click method');
    });
    test('space makes event', 1, function () {
        var Dot = Control.extend({
            ' foo': function () {
                ok(true, 'called');
            }
        });
        this.fixture.appendChild(fragment('<div id=\'els\'><span id=\'elspan\'><a href=\'#\' id=\'elsa\'>click me</a></span></div>'));
        new Dot('#els');
        domEvents.dispatch(document.querySelector('#els'), 'foo');
    });
    test('custom events with hyphens work', 1, function () {
        this.fixture.appendChild(fragment('<div id=\'customEvent\'><span></span></div>'));
        var FooBar = Control.extend({
            'span custom-event': function () {
                ok(true, 'Custom event was fired.');
            }
        });
        new FooBar('#customEvent');
        domEvents.dispatch(document.querySelector('#customEvent span'), 'custom-event');
    });
    test('inherit defaults', function () {
        var BASE = Control.extend({ defaults: { foo: 'bar' } }, {});
        var INHERIT = BASE.extend({ defaults: { newProp: 'newVal' } }, {});
        ok(INHERIT.defaults.foo === 'bar', 'Class must inherit defaults from the parent class');
        ok(INHERIT.defaults.newProp === 'newVal', 'Class must have own defaults');
        var inst = new INHERIT(document.createElement('div'), {});
        ok(inst.options.foo === 'bar', 'Instance must inherit defaults from the parent class');
        ok(inst.options.newProp === 'newVal', 'Instance must have defaults of it`s class');
    });
    test('on rebinding', 2, function () {
        var first = true;
        var Rebinder = Control.extend({
            '{item} foo': function (item, ev) {
                if (first) {
                    equal(item.get('id'), 1, 'first item');
                    first = false;
                } else {
                    equal(item.get('id'), 2, 'first item');
                }
            }
        });
        var item1 = new SimpleMap({ id: 1 }), item2 = new SimpleMap({ id: 2 }), rb = new Rebinder(document.createElement('div'), { item: item1 });
        item1.dispatch('foo');
        rb.options = { item: item2 };
        rb.on();
        item2.dispatch('foo');
    });
    test('actions provide method names', function () {
        var item1 = new SimpleMap({});
        var item2 = new SimpleMap({});
        var Tester = Control.extend({
            '{item1} foo': 'food',
            '{item2} bar': 'food',
            food: function (item, ev, data) {
                ok(true, 'food called');
                ok(item === item1 || item === item2, 'called with an item');
            }
        });
        new Tester(document.createElement('div'), {
            item1: item1,
            item2: item2
        });
        item1.dispatch('foo');
        item2.dispatch('bar');
    });
    test('Don\'t bind if there are undefined values in templates', function () {
        var C = Control.extend({}, {
            '{noExistStuff} proc': function () {
            }
        });
        var c = new C(document.createElement('div'));
        equal(c._bindings.user.length, 1, 'There is only one binding');
        var C2 = Control.extend({
            '{noExistStuff} click': function () {
                ok(false, 'should not fall through to click handler');
            }
        });
        var div = document.createElement('div');
        new C2(div, {});
        domEvents.dispatch(div, 'click');
    });
    test('Multiple calls to destroy', 2, function () {
        var C = Control.extend({
                destroy: function () {
                    ok(true);
                    Control.prototype.destroy.call(this);
                }
            }), div = document.createElement('div'), c = new C(div);
        c.destroy();
        c.destroy();
    });
    test('drag and drop events', function () {
        expect(7);
        var DragDrop = Control.extend('', {
            ' dragstart': function () {
                ok(true, 'dragstart called');
            },
            ' dragenter': function () {
                ok(true, 'dragenter called');
            },
            ' dragover': function () {
                ok(true, 'dragover called');
            },
            ' dragleave': function () {
                ok(true, 'dragleave called');
            },
            ' drag': function () {
                ok(true, 'drag called');
            },
            ' drop': function () {
                ok(true, 'drop called');
            },
            ' dragend': function () {
                ok(true, 'dragend called');
            }
        });
        this.fixture.appendChild(fragment('<div id="draggable"/>'));
        new DragDrop('#draggable');
        var draggable = document.getElementById('draggable');
        domEvents.dispatch(draggable, 'dragstart');
        domEvents.dispatch(draggable, 'dragenter');
        domEvents.dispatch(draggable, 'dragover');
        domEvents.dispatch(draggable, 'dragleave');
        domEvents.dispatch(draggable, 'drag');
        domEvents.dispatch(draggable, 'drop');
        domEvents.dispatch(draggable, 'dragend');
    });
    test('beforeremove event', function () {
        expect(1);
        var Foo = Control.extend('', {
            'beforeremove': function () {
                ok(true, 'beforeremove called');
            }
        });
        var el = fragment('<div id="foo"/>');
        new Foo(el);
        domEvents.dispatch(el, 'beforeremove');
    });
    if (System.env.indexOf('production') < 0) {
        test('Control is logging information in dev mode', function () {
            expect(2);
            var oldlog = dev.log;
            var oldwarn = dev.warn;
            dev.log = function (text) {
                equal(text, 'can-control: No property found for handling {dummy} change', 'Text logged as expected');
            };
            var C = Control.extend({
                '{dummy} change': function () {
                }
            });
            var instance = new C(document.createElement('div'));
            dev.warn = function (text) {
                equal(text, 'can-control: Control already destroyed', 'control destroyed warning');
            };
            instance.destroy();
            instance.destroy();
            dev.warn = oldwarn;
            dev.log = oldlog;
        });
    }
    test('event handlers should rebind when target is replaced', function () {
        var nameChanges = 0;
        var MyControl = Control.extend('MyControl', {
            '{person.name} first': function () {
                nameChanges++;
            },
            name: function (name) {
                this.options.person.set('name', name);
            }
        });
        var c = new MyControl(document.createElement('div'), { person: new SimpleMap({ name: new SimpleMap({ first: 'Kevin' }) }) });
        c.options.person.get('name').set('first', 'Tracy');
        c.name(new SimpleMap({ first: 'Kim' }));
        c.options.person.get('name').get('first', 'Max');
        equal(nameChanges, 2);
    });
    test('{element} event handling', function () {
        expect(3);
        stop();
        var MyControl = Control.extend({
            '{element} click': function (element) {
                if (element === this.element) {
                    ok(true, '`{element} click` should catch clicking on the element');
                } else {
                    ok(true, '`{element} click` should catch clicking on a child of the element');
                }
            },
            '{element} p click': function () {
                ok(true, '`{element} p click` works');
                start();
            }
        });
        var div = document.createElement('div');
        var p = document.createElement('p');
        div.appendChild(p);
        new MyControl(div, { foo: 'bar' });
        domEvents.dispatch(div, 'click');
        domEvents.dispatch(p, 'click');
    });
    test('Passing a Map as options works', function () {
        expect(2);
        stop();
        var MyControl = Control.extend({ defaults: { testEndEvent: 'mouseleave' } }, {
            '{element} {eventType}': function () {
                ok(true, 'catches handler from options');
            },
            '{element} {testEndEvent}': function () {
                ok(true, 'catches handler from defaults');
                start();
            }
        });
        var map = new SimpleMap({ eventType: 'click' });
        var div = document.createElement('div');
        new MyControl(div, map);
        map.attr('eventType', 'mouseenter');
        domEvents.dispatch(div, 'mouseenter');
        domEvents.dispatch(div, 'mouseleave');
    });
    test('Passing a DefineMap as options works', function () {
        expect(2);
        stop();
        var MyControl = Control.extend({ defaults: { testEndEvent: 'mouseleave' } }, {
            '{element} {eventType}': function () {
                ok(true, 'catches handler from options');
            },
            '{element} {testEndEvent}': function () {
                ok(true, 'catches handler from defaults');
                start();
            }
        });
        var MyMap = DefineMap.extend({
            eventType: 'string',
            testEndEvent: 'string'
        });
        var map = new MyMap();
        map.eventType = 'click';
        var div = document.createElement('div');
        new MyControl(div, map);
        map.eventType = 'mousenter';
        domEvents.dispatch(div, 'mousenter');
        domEvents.dispatch(div, 'mouseleave');
    });
    test('Creating an instance of a named control without passing an element', function () {
        var MyControl = Control.extend('MyControl');
        try {
            new MyControl();
        } catch (e) {
            ok(true, 'Caught an exception');
        }
    });
    test('Creating an instance of a named control passing a selector', function () {
        this.fixture.appendChild(fragment('<div id=\'my-control\'>d</div>'));
        var MyControl = Control.extend('MyControl');
        var myControlInstance = new MyControl('#my-control');
        ok(className.has.call(myControlInstance.element, 'MyControl'), 'Element has the correct class name');
    });
    QUnit.test('can watch SimpleObservable', function () {
        var MyControl = Control.extend({
            '{simple}': function (simple, newVal) {
                QUnit.equal(newVal, 6);
            }
        });
        var div = document.createElement('div');
        var simple = new SimpleObservable(5);
        new MyControl(div, { simple: simple });
        simple.set(6);
    });
});
/*can-define-lazy-value@1.0.1#define-lazy-value-test*/
define('can-define-lazy-value@1.0.1#define-lazy-value-test', [
    'steal-qunit',
    './define-lazy-value'
], function (_stealQunit, _defineLazyValue) {
    'use strict';
    var _stealQunit2 = _interopRequireDefault(_stealQunit);
    var _defineLazyValue2 = _interopRequireDefault(_defineLazyValue);
    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
    }
    _stealQunit2.default.module('can-define-lazy-value');
    _stealQunit2.default.test('docs', function () {
        var _id = 1;
        function getId() {
            return _id++;
        }
        function MyObj(name) {
            this.name = name;
        }
        (0, _defineLazyValue2.default)(MyObj.prototype, 'id', getId);
        var obj1 = new MyObj('obj1');
        var obj2 = new MyObj('obj2');
        _stealQunit2.default.equal(obj2.id, 1, 'first object read should get id 1');
        _stealQunit2.default.equal(obj1.id, 2, 'second object read should get id 2');
        try {
            obj1.id = 3;
        } catch (e) {
            _stealQunit2.default.ok(true, 'obj1.id should not be writable by default');
        }
        (0, _defineLazyValue2.default)(MyObj.prototype, 'id', getId, true);
        var obj3 = new MyObj('obj3');
        _stealQunit2.default.equal(obj3.id, 3, 'obj3 should have id');
        obj3.id = 4;
        _stealQunit2.default.equal(obj3.id, 4, 'obj3.id should be writeable');
    });
});
/*can-deparam@1.0.3#can-deparam*/
define('can-deparam@1.0.3#can-deparam', [
    'require',
    'exports',
    'module',
    'can-namespace'
], function (require, exports, module) {
    var namespace = require('can-namespace');
    var digitTest = /^\d+$/, keyBreaker = /([^\[\]]+)|(\[\])/g, paramTest = /([^?#]*)(#.*)?$/, entityRegex = /%([^0-9a-f][0-9a-f]|[0-9a-f][^0-9a-f]|[^0-9a-f][^0-9a-f])/i, prep = function (str) {
            str = str.replace(/\+/g, ' ');
            try {
                return decodeURIComponent(str);
            } catch (e) {
                return decodeURIComponent(str.replace(entityRegex, function (match, hex) {
                    return '%25' + hex;
                }));
            }
        };
    module.exports = namespace.deparam = function (params) {
        var data = {}, pairs, lastPart;
        if (params && paramTest.test(params)) {
            pairs = params.split('&');
            pairs.forEach(function (pair) {
                var parts = pair.split('='), key = prep(parts.shift()), value = prep(parts.join('=')), current = data;
                if (key) {
                    parts = key.match(keyBreaker);
                    for (var j = 0, l = parts.length - 1; j < l; j++) {
                        if (!current[parts[j]]) {
                            current[parts[j]] = digitTest.test(parts[j + 1]) || parts[j + 1] === '[]' ? [] : {};
                        }
                        current = current[parts[j]];
                    }
                    lastPart = parts.pop();
                    if (lastPart === '[]') {
                        current.push(value);
                    } else {
                        current[lastPart] = value;
                    }
                }
            });
        }
        return data;
    };
});
/*can-deparam@1.0.3#can-deparam-test*/
define('can-deparam@1.0.3#can-deparam-test', [
    'require',
    'exports',
    'module',
    './can-deparam',
    'steal-qunit'
], function (require, exports, module) {
    var deparam = require('./can-deparam');
    var QUnit = require('steal-qunit');
    QUnit.module('can/util/string/deparam');
    test('Nested deparam', function () {
        var data = deparam('a[b]=1&a[c]=2');
        equal(data.a.b, 1);
        equal(data.a.c, 2);
        data = deparam('a[]=1&a[]=2');
        equal(data.a[0], 1);
        equal(data.a[1], 2);
        data = deparam('a[b][]=1&a[b][]=2');
        equal(data.a.b[0], 1);
        equal(data.a.b[1], 2);
        data = deparam('a[0]=1&a[1]=2');
        equal(data.a[0], 1);
        equal(data.a[1], 2);
    });
    test('Remaining ampersand', function () {
        var data = deparam('a[b]=1&a[c]=2&');
        deepEqual(data, {
            a: {
                b: '1',
                c: '2'
            }
        });
    });
    test('Invalid encoding', function () {
        var data = deparam('foo=%0g');
        deepEqual(data, { foo: '%0g' });
    });
});
/*can-dom-events@1.1.1#helpers/make-event-registry-test*/
define('can-dom-events@1.1.1#helpers/make-event-registry-test', [
    'require',
    'exports',
    'module',
    'steal-qunit',
    './make-event-registry'
], function (require, exports, module) {
    var unit = require('steal-qunit');
    var makeEventRegistry = require('./make-event-registry');
    unit.module('make-event-registry');
    unit.test('add should register the event with the given eventType', function (assert) {
        var eventType = 'boi';
        var registry = makeEventRegistry();
        var exampleEvent = {
            defaultEventType: 'cake',
            addEventListener: function () {
            },
            removeEventListener: function () {
            }
        };
        registry.add(exampleEvent, eventType);
        assert.equal(registry.has(eventType), true, 'event should be registered at "' + eventType + '"');
    });
    unit.test('add should use the event\'s defaultEventType unless eventType is provided', function (assert) {
        var eventType = 'boi';
        var registry = makeEventRegistry();
        var exampleEvent = {
            defaultEventType: eventType,
            addEventListener: function () {
            },
            removeEventListener: function () {
            }
        };
        registry.add(exampleEvent);
        assert.equal(registry.has(eventType), true, 'event should be registered at "' + eventType + '"');
    });
    unit.test('has should return whether an event is registered', function (assert) {
        var eventType = 'boi';
        var exampleEvent = {
            defaultEventType: eventType,
            addEventListener: function () {
            },
            removeEventListener: function () {
            }
        };
        var registry = makeEventRegistry();
        assert.equal(registry.has(eventType), false, 'initial registry should not have the event');
        var remove = registry.add(exampleEvent);
        assert.equal(registry.has(eventType), true, 'updated registry should have the event');
        remove();
        assert.equal(registry.has(eventType), false, 'empty registry should not have the event');
    });
    unit.test('get should return the register event', function (assert) {
        var eventType = 'boi';
        var exampleEvent = {
            defaultEventType: eventType,
            addEventListener: function () {
            },
            removeEventListener: function () {
            }
        };
        var registry = makeEventRegistry();
        assert.equal(registry.get(eventType), undefined, 'initial registry should not have the event');
        var remove = registry.add(exampleEvent);
        assert.equal(registry.get(eventType), exampleEvent, 'updated registry should have the event');
        remove();
        assert.equal(registry.get(eventType), undefined, 'empty registry should not have the event');
    });
});
/*can-dom-events@1.1.1#helpers/add-event-compat*/
define('can-dom-events@1.1.1#helpers/add-event-compat', [
    'require',
    'exports',
    'module',
    './util'
], function (require, exports, module) {
    'use strict';
    var util = require('./util');
    var addDomContext = util.addDomContext;
    var removeDomContext = util.removeDomContext;
    function isDomEvents(obj) {
        return !!(obj && obj.addEventListener && obj.removeEventListener && obj.dispatch);
    }
    function isNewEvents(obj) {
        return typeof obj.addEvent === 'function';
    }
    module.exports = function addEventCompat(domEvents, customEvent, customEventType) {
        if (!isDomEvents(domEvents)) {
            throw new Error('addEventCompat() must be passed can-dom-events or can-util/dom/events/events');
        }
        customEventType = customEventType || customEvent.defaultEventType;
        if (isNewEvents(domEvents)) {
            return domEvents.addEvent(customEvent, customEventType);
        }
        var registry = domEvents._compatRegistry;
        if (!registry) {
            registry = domEvents._compatRegistry = {};
        }
        if (registry[customEventType]) {
            return function noopRemoveOverride() {
            };
        }
        registry[customEventType] = customEvent;
        var newEvents = {
            addEventListener: function () {
                var data = removeDomContext(this, arguments);
                return domEvents.addEventListener.apply(data.context, data.args);
            },
            removeEventListener: function () {
                var data = removeDomContext(this, arguments);
                return domEvents.removeEventListener.apply(data.context, data.args);
            },
            dispatch: function () {
                var data = removeDomContext(this, arguments);
                var eventData = data.args[0];
                var eventArgs = typeof eventData === 'object' ? eventData.args : [];
                data.args.splice(1, 0, eventArgs);
                return domEvents.dispatch.apply(data.context, data.args);
            }
        };
        var isOverriding = true;
        var oldAddEventListener = domEvents.addEventListener;
        var addEventListener = domEvents.addEventListener = function addEventListener(eventName) {
            if (isOverriding && eventName === customEventType) {
                var args = addDomContext(this, arguments);
                customEvent.addEventListener.apply(newEvents, args);
            }
            return oldAddEventListener.apply(this, arguments);
        };
        var oldRemoveEventListener = domEvents.removeEventListener;
        var removeEventListener = domEvents.removeEventListener = function removeEventListener(eventName) {
            if (isOverriding && eventName === customEventType) {
                var args = addDomContext(this, arguments);
                customEvent.removeEventListener.apply(newEvents, args);
            }
            return oldRemoveEventListener.apply(this, arguments);
        };
        return function removeOverride() {
            isOverriding = false;
            registry[customEventType] = null;
            if (domEvents.addEventListener === addEventListener) {
                domEvents.addEventListener = oldAddEventListener;
            }
            if (domEvents.removeEventListener === removeEventListener) {
                domEvents.removeEventListener = oldRemoveEventListener;
            }
        };
    };
});
/*can-dom-events@1.1.1#helpers/add-event-compat-test*/
define('can-dom-events@1.1.1#helpers/add-event-compat-test', [
    'require',
    'exports',
    'module',
    'steal-qunit',
    './add-event-compat',
    '../can-dom-events'
], function (require, exports, module) {
    var unit = require('steal-qunit');
    var addEvent = require('./add-event-compat');
    var domEvents = require('../can-dom-events');
    var oldDomEventsMock = function (addSpy, removeSpy) {
        return {
            addEventListener: function () {
                addSpy(this, arguments);
                this.addEventListener.apply(this, arguments);
            },
            removeEventListener: function () {
                removeSpy(this, arguments);
                this.removeEventListener.apply(this, arguments);
            },
            dispatch: function () {
            }
        };
    };
    unit.module('add-event-compat');
    var mockEvent = function (addSpy, removeSpy) {
        return {
            defaultEventType: 'boi',
            addEventListener: function (target, eventName, handler) {
                addSpy(this, arguments);
                this.addEventListener(target, 'boi2', handler);
            },
            removeEventListener: function (target, eventName, handler) {
                removeSpy(this, arguments);
                this.removeEventListener(target, 'boi2', handler);
            }
        };
    };
    unit.test('should work with the can-dom-events', function (assert) {
        assert.expect(1 + 2 * 4);
        var input = document.createElement('input');
        var handler = function () {
            assert.ok(true, 'handler should be called');
        };
        var customEventType = 'boi3';
        var hookSpy = function (context, args) {
            assert.equal(context, domEvents, 'real domEvents should be context');
            var target = args[0];
            var eventType = args[1];
            var callback = args[2];
            assert.equal(target, input, 'input should be the target');
            assert.equal(eventType, customEventType, 'event type should match custom event type');
            assert.equal(callback, handler, 'callback should be the passed handler');
        };
        var event = mockEvent(hookSpy, hookSpy);
        var removeEvent = addEvent(domEvents, event, customEventType);
        domEvents.addEventListener(input, customEventType, handler);
        domEvents.dispatch(input, 'boi2');
        domEvents.removeEventListener(input, customEventType, handler);
        removeEvent();
    });
    unit.test('should work with the can-dom-events (no custom event type)', function (assert) {
        assert.expect(1 + 2 * 4);
        var input = document.createElement('input');
        var handler = function () {
            assert.ok(true, 'handler should be called');
        };
        var customEventType = 'boi';
        var hookSpy = function (context, args) {
            assert.equal(context, domEvents, 'real domEvents should be context');
            var target = args[0];
            var eventType = args[1];
            var callback = args[2];
            assert.equal(target, input, 'input should be the target');
            assert.equal(eventType, customEventType, 'event type should match custom event type');
            assert.equal(callback, handler, 'callback should be the passed handler');
        };
        var event = mockEvent(hookSpy, hookSpy);
        var removeEvent = addEvent(domEvents, event);
        domEvents.addEventListener(input, customEventType, handler);
        domEvents.dispatch(input, 'boi2');
        domEvents.removeEventListener(input, customEventType, handler);
        removeEvent();
    });
    unit.test('should work with the can-util/dom/events', function (assert) {
        assert.expect(1 + 2 * (2 + 3));
        var input = document.createElement('input');
        var handler = function () {
            assert.ok(true, 'handler should be called');
        };
        var customEventType = 'boi3';
        var eventsSpy = function (context, args) {
            var target = context;
            var eventType = args[0];
            var callback = args[1];
            if (eventType === customEventType) {
                assert.equal(target, input, 'input should be the target');
                assert.equal(callback, handler, 'callback should be the passed handler');
            }
        };
        var oldEvents = oldDomEventsMock(eventsSpy, eventsSpy);
        var hookSpy = function (context, args) {
            var target = args[0];
            var eventType = args[1];
            var callback = args[2];
            assert.equal(target, input, 'input should be the target');
            assert.equal(eventType, customEventType, 'event type should match custom event type');
            assert.equal(callback, handler, 'callback should be the passed handler');
        };
        var event = mockEvent(hookSpy, hookSpy);
        var removeEvent = addEvent(oldEvents, event, customEventType);
        oldEvents.addEventListener.call(input, customEventType, handler);
        domEvents.dispatch(input, 'boi2');
        oldEvents.removeEventListener.call(input, customEventType, handler);
        removeEvent();
    });
    unit.test('should work with the can-util/dom/events (no custom event type)', function (assert) {
        assert.expect(1 + 2 * (2 + 3));
        var input = document.createElement('input');
        var handler = function () {
            assert.ok(true, 'handler should be called');
        };
        var customEventType = 'boi';
        var eventsSpy = function (context, args) {
            var target = context;
            var eventType = args[0];
            var callback = args[1];
            if (eventType === customEventType) {
                assert.equal(target, input, 'input should be the target');
                assert.equal(callback, handler, 'callback should be the passed handler');
            }
        };
        var oldEvents = oldDomEventsMock(eventsSpy, eventsSpy);
        var hookSpy = function (context, args) {
            var target = args[0];
            var eventType = args[1];
            var callback = args[2];
            assert.equal(target, input, 'input should be the target');
            assert.equal(eventType, customEventType, 'event type should match custom event type');
            assert.equal(callback, handler, 'callback should be the passed handler');
        };
        var event = mockEvent(hookSpy, hookSpy);
        var removeEvent = addEvent(oldEvents, event);
        oldEvents.addEventListener.call(input, customEventType, handler);
        domEvents.dispatch(input, 'boi2');
        oldEvents.removeEventListener.call(input, customEventType, handler);
        removeEvent();
    });
    unit.test('should not override can-util/dom/events twice for the same eventType', function (assert) {
        var done = assert.async();
        var input = document.createElement('input');
        var event = {
            addEventListener: function (target, eventType, handler) {
                target.addEventListener(eventType, handler);
            },
            removeEventListener: function (target, eventType, handler) {
                target.removeEventListener(eventType, handler);
            }
        };
        var eventsSpy = function () {
        };
        var oldEvents = oldDomEventsMock(eventsSpy, eventsSpy);
        var removeEvent1 = addEvent(oldEvents, event, 'foo');
        var removeEvent2 = addEvent(oldEvents, event, 'foo');
        var handler = function () {
            removeEvent1();
            removeEvent2();
            assert.ok(true, 'This handler should only be called once');
            done();
        };
        oldEvents.addEventListener.call(input, 'foo', handler);
        domEvents.dispatch(input, 'foo');
        oldEvents.removeEventListener.call(input, 'foo', handler);
    });
});
/*jquery@3.3.1#dist/jquery*/
(function (global, factory) {
    'use strict';
    if (typeof module === 'object' && typeof module.exports === 'object') {
        module.exports = global.document ? factory(global, true) : function (w) {
            if (!w.document) {
                throw new Error('jQuery requires a window with a document');
            }
            return factory(w);
        };
    } else {
        factory(global);
    }
}(typeof window !== 'undefined' ? window : this, function (window, noGlobal) {
    'use strict';
    var arr = [];
    var document = window.document;
    var getProto = Object.getPrototypeOf;
    var slice = arr.slice;
    var concat = arr.concat;
    var push = arr.push;
    var indexOf = arr.indexOf;
    var class2type = {};
    var toString = class2type.toString;
    var hasOwn = class2type.hasOwnProperty;
    var fnToString = hasOwn.toString;
    var ObjectFunctionString = fnToString.call(Object);
    var support = {};
    var isFunction = function isFunction(obj) {
        return typeof obj === 'function' && typeof obj.nodeType !== 'number';
    };
    var isWindow = function isWindow(obj) {
        return obj != null && obj === obj.window;
    };
    var preservedScriptAttributes = {
        type: true,
        src: true,
        noModule: true
    };
    function DOMEval(code, doc, node) {
        doc = doc || document;
        var i, script = doc.createElement('script');
        script.text = code;
        if (node) {
            for (i in preservedScriptAttributes) {
                if (node[i]) {
                    script[i] = node[i];
                }
            }
        }
        doc.head.appendChild(script).parentNode.removeChild(script);
    }
    function toType(obj) {
        if (obj == null) {
            return obj + '';
        }
        return typeof obj === 'object' || typeof obj === 'function' ? class2type[toString.call(obj)] || 'object' : typeof obj;
    }
    var version = '3.3.1', jQuery = function (selector, context) {
            return new jQuery.fn.init(selector, context);
        }, rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g;
    jQuery.fn = jQuery.prototype = {
        jquery: version,
        constructor: jQuery,
        length: 0,
        toArray: function () {
            return slice.call(this);
        },
        get: function (num) {
            if (num == null) {
                return slice.call(this);
            }
            return num < 0 ? this[num + this.length] : this[num];
        },
        pushStack: function (elems) {
            var ret = jQuery.merge(this.constructor(), elems);
            ret.prevObject = this;
            return ret;
        },
        each: function (callback) {
            return jQuery.each(this, callback);
        },
        map: function (callback) {
            return this.pushStack(jQuery.map(this, function (elem, i) {
                return callback.call(elem, i, elem);
            }));
        },
        slice: function () {
            return this.pushStack(slice.apply(this, arguments));
        },
        first: function () {
            return this.eq(0);
        },
        last: function () {
            return this.eq(-1);
        },
        eq: function (i) {
            var len = this.length, j = +i + (i < 0 ? len : 0);
            return this.pushStack(j >= 0 && j < len ? [this[j]] : []);
        },
        end: function () {
            return this.prevObject || this.constructor();
        },
        push: push,
        sort: arr.sort,
        splice: arr.splice
    };
    jQuery.extend = jQuery.fn.extend = function () {
        var options, name, src, copy, copyIsArray, clone, target = arguments[0] || {}, i = 1, length = arguments.length, deep = false;
        if (typeof target === 'boolean') {
            deep = target;
            target = arguments[i] || {};
            i++;
        }
        if (typeof target !== 'object' && !isFunction(target)) {
            target = {};
        }
        if (i === length) {
            target = this;
            i--;
        }
        for (; i < length; i++) {
            if ((options = arguments[i]) != null) {
                for (name in options) {
                    src = target[name];
                    copy = options[name];
                    if (target === copy) {
                        continue;
                    }
                    if (deep && copy && (jQuery.isPlainObject(copy) || (copyIsArray = Array.isArray(copy)))) {
                        if (copyIsArray) {
                            copyIsArray = false;
                            clone = src && Array.isArray(src) ? src : [];
                        } else {
                            clone = src && jQuery.isPlainObject(src) ? src : {};
                        }
                        target[name] = jQuery.extend(deep, clone, copy);
                    } else if (copy !== undefined) {
                        target[name] = copy;
                    }
                }
            }
        }
        return target;
    };
    jQuery.extend({
        expando: 'jQuery' + (version + Math.random()).replace(/\D/g, ''),
        isReady: true,
        error: function (msg) {
            throw new Error(msg);
        },
        noop: function () {
        },
        isPlainObject: function (obj) {
            var proto, Ctor;
            if (!obj || toString.call(obj) !== '[object Object]') {
                return false;
            }
            proto = getProto(obj);
            if (!proto) {
                return true;
            }
            Ctor = hasOwn.call(proto, 'constructor') && proto.constructor;
            return typeof Ctor === 'function' && fnToString.call(Ctor) === ObjectFunctionString;
        },
        isEmptyObject: function (obj) {
            var name;
            for (name in obj) {
                return false;
            }
            return true;
        },
        globalEval: function (code) {
            DOMEval(code);
        },
        each: function (obj, callback) {
            var length, i = 0;
            if (isArrayLike(obj)) {
                length = obj.length;
                for (; i < length; i++) {
                    if (callback.call(obj[i], i, obj[i]) === false) {
                        break;
                    }
                }
            } else {
                for (i in obj) {
                    if (callback.call(obj[i], i, obj[i]) === false) {
                        break;
                    }
                }
            }
            return obj;
        },
        trim: function (text) {
            return text == null ? '' : (text + '').replace(rtrim, '');
        },
        makeArray: function (arr, results) {
            var ret = results || [];
            if (arr != null) {
                if (isArrayLike(Object(arr))) {
                    jQuery.merge(ret, typeof arr === 'string' ? [arr] : arr);
                } else {
                    push.call(ret, arr);
                }
            }
            return ret;
        },
        inArray: function (elem, arr, i) {
            return arr == null ? -1 : indexOf.call(arr, elem, i);
        },
        merge: function (first, second) {
            var len = +second.length, j = 0, i = first.length;
            for (; j < len; j++) {
                first[i++] = second[j];
            }
            first.length = i;
            return first;
        },
        grep: function (elems, callback, invert) {
            var callbackInverse, matches = [], i = 0, length = elems.length, callbackExpect = !invert;
            for (; i < length; i++) {
                callbackInverse = !callback(elems[i], i);
                if (callbackInverse !== callbackExpect) {
                    matches.push(elems[i]);
                }
            }
            return matches;
        },
        map: function (elems, callback, arg) {
            var length, value, i = 0, ret = [];
            if (isArrayLike(elems)) {
                length = elems.length;
                for (; i < length; i++) {
                    value = callback(elems[i], i, arg);
                    if (value != null) {
                        ret.push(value);
                    }
                }
            } else {
                for (i in elems) {
                    value = callback(elems[i], i, arg);
                    if (value != null) {
                        ret.push(value);
                    }
                }
            }
            return concat.apply([], ret);
        },
        guid: 1,
        support: support
    });
    if (typeof Symbol === 'function') {
        jQuery.fn[Symbol.iterator] = arr[Symbol.iterator];
    }
    jQuery.each('Boolean Number String Function Array Date RegExp Object Error Symbol'.split(' '), function (i, name) {
        class2type['[object ' + name + ']'] = name.toLowerCase();
    });
    function isArrayLike(obj) {
        var length = !!obj && 'length' in obj && obj.length, type = toType(obj);
        if (isFunction(obj) || isWindow(obj)) {
            return false;
        }
        return type === 'array' || length === 0 || typeof length === 'number' && length > 0 && length - 1 in obj;
    }
    var Sizzle = function (window) {
        var i, support, Expr, getText, isXML, tokenize, compile, select, outermostContext, sortInput, hasDuplicate, setDocument, document, docElem, documentIsHTML, rbuggyQSA, rbuggyMatches, matches, contains, expando = 'sizzle' + 1 * new Date(), preferredDoc = window.document, dirruns = 0, done = 0, classCache = createCache(), tokenCache = createCache(), compilerCache = createCache(), sortOrder = function (a, b) {
                if (a === b) {
                    hasDuplicate = true;
                }
                return 0;
            }, hasOwn = {}.hasOwnProperty, arr = [], pop = arr.pop, push_native = arr.push, push = arr.push, slice = arr.slice, indexOf = function (list, elem) {
                var i = 0, len = list.length;
                for (; i < len; i++) {
                    if (list[i] === elem) {
                        return i;
                    }
                }
                return -1;
            }, booleans = 'checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped', whitespace = '[\\x20\\t\\r\\n\\f]', identifier = '(?:\\\\.|[\\w-]|[^\0-\\xa0])+', attributes = '\\[' + whitespace + '*(' + identifier + ')(?:' + whitespace + '*([*^$|!~]?=)' + whitespace + '*(?:\'((?:\\\\.|[^\\\\\'])*)\'|"((?:\\\\.|[^\\\\"])*)"|(' + identifier + '))|)' + whitespace + '*\\]', pseudos = ':(' + identifier + ')(?:\\((' + '(\'((?:\\\\.|[^\\\\\'])*)\'|"((?:\\\\.|[^\\\\"])*)")|' + '((?:\\\\.|[^\\\\()[\\]]|' + attributes + ')*)|' + '.*' + ')\\)|)', rwhitespace = new RegExp(whitespace + '+', 'g'), rtrim = new RegExp('^' + whitespace + '+|((?:^|[^\\\\])(?:\\\\.)*)' + whitespace + '+$', 'g'), rcomma = new RegExp('^' + whitespace + '*,' + whitespace + '*'), rcombinators = new RegExp('^' + whitespace + '*([>+~]|' + whitespace + ')' + whitespace + '*'), rattributeQuotes = new RegExp('=' + whitespace + '*([^\\]\'"]*?)' + whitespace + '*\\]', 'g'), rpseudo = new RegExp(pseudos), ridentifier = new RegExp('^' + identifier + '$'), matchExpr = {
                'ID': new RegExp('^#(' + identifier + ')'),
                'CLASS': new RegExp('^\\.(' + identifier + ')'),
                'TAG': new RegExp('^(' + identifier + '|[*])'),
                'ATTR': new RegExp('^' + attributes),
                'PSEUDO': new RegExp('^' + pseudos),
                'CHILD': new RegExp('^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(' + whitespace + '*(even|odd|(([+-]|)(\\d*)n|)' + whitespace + '*(?:([+-]|)' + whitespace + '*(\\d+)|))' + whitespace + '*\\)|)', 'i'),
                'bool': new RegExp('^(?:' + booleans + ')$', 'i'),
                'needsContext': new RegExp('^' + whitespace + '*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(' + whitespace + '*((?:-\\d)?\\d*)' + whitespace + '*\\)|)(?=[^-]|$)', 'i')
            }, rinputs = /^(?:input|select|textarea|button)$/i, rheader = /^h\d$/i, rnative = /^[^{]+\{\s*\[native \w/, rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/, rsibling = /[+~]/, runescape = new RegExp('\\\\([\\da-f]{1,6}' + whitespace + '?|(' + whitespace + ')|.)', 'ig'), funescape = function (_, escaped, escapedWhitespace) {
                var high = '0x' + escaped - 65536;
                return high !== high || escapedWhitespace ? escaped : high < 0 ? String.fromCharCode(high + 65536) : String.fromCharCode(high >> 10 | 55296, high & 1023 | 56320);
            }, rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g, fcssescape = function (ch, asCodePoint) {
                if (asCodePoint) {
                    if (ch === '\0') {
                        return '\uFFFD';
                    }
                    return ch.slice(0, -1) + '\\' + ch.charCodeAt(ch.length - 1).toString(16) + ' ';
                }
                return '\\' + ch;
            }, unloadHandler = function () {
                setDocument();
            }, disabledAncestor = addCombinator(function (elem) {
                return elem.disabled === true && ('form' in elem || 'label' in elem);
            }, {
                dir: 'parentNode',
                next: 'legend'
            });
        try {
            push.apply(arr = slice.call(preferredDoc.childNodes), preferredDoc.childNodes);
            arr[preferredDoc.childNodes.length].nodeType;
        } catch (e) {
            push = {
                apply: arr.length ? function (target, els) {
                    push_native.apply(target, slice.call(els));
                } : function (target, els) {
                    var j = target.length, i = 0;
                    while (target[j++] = els[i++]) {
                    }
                    target.length = j - 1;
                }
            };
        }
        function Sizzle(selector, context, results, seed) {
            var m, i, elem, nid, match, groups, newSelector, newContext = context && context.ownerDocument, nodeType = context ? context.nodeType : 9;
            results = results || [];
            if (typeof selector !== 'string' || !selector || nodeType !== 1 && nodeType !== 9 && nodeType !== 11) {
                return results;
            }
            if (!seed) {
                if ((context ? context.ownerDocument || context : preferredDoc) !== document) {
                    setDocument(context);
                }
                context = context || document;
                if (documentIsHTML) {
                    if (nodeType !== 11 && (match = rquickExpr.exec(selector))) {
                        if (m = match[1]) {
                            if (nodeType === 9) {
                                if (elem = context.getElementById(m)) {
                                    if (elem.id === m) {
                                        results.push(elem);
                                        return results;
                                    }
                                } else {
                                    return results;
                                }
                            } else {
                                if (newContext && (elem = newContext.getElementById(m)) && contains(context, elem) && elem.id === m) {
                                    results.push(elem);
                                    return results;
                                }
                            }
                        } else if (match[2]) {
                            push.apply(results, context.getElementsByTagName(selector));
                            return results;
                        } else if ((m = match[3]) && support.getElementsByClassName && context.getElementsByClassName) {
                            push.apply(results, context.getElementsByClassName(m));
                            return results;
                        }
                    }
                    if (support.qsa && !compilerCache[selector + ' '] && (!rbuggyQSA || !rbuggyQSA.test(selector))) {
                        if (nodeType !== 1) {
                            newContext = context;
                            newSelector = selector;
                        } else if (context.nodeName.toLowerCase() !== 'object') {
                            if (nid = context.getAttribute('id')) {
                                nid = nid.replace(rcssescape, fcssescape);
                            } else {
                                context.setAttribute('id', nid = expando);
                            }
                            groups = tokenize(selector);
                            i = groups.length;
                            while (i--) {
                                groups[i] = '#' + nid + ' ' + toSelector(groups[i]);
                            }
                            newSelector = groups.join(',');
                            newContext = rsibling.test(selector) && testContext(context.parentNode) || context;
                        }
                        if (newSelector) {
                            try {
                                push.apply(results, newContext.querySelectorAll(newSelector));
                                return results;
                            } catch (qsaError) {
                            } finally {
                                if (nid === expando) {
                                    context.removeAttribute('id');
                                }
                            }
                        }
                    }
                }
            }
            return select(selector.replace(rtrim, '$1'), context, results, seed);
        }
        function createCache() {
            var keys = [];
            function cache(key, value) {
                if (keys.push(key + ' ') > Expr.cacheLength) {
                    delete cache[keys.shift()];
                }
                return cache[key + ' '] = value;
            }
            return cache;
        }
        function markFunction(fn) {
            fn[expando] = true;
            return fn;
        }
        function assert(fn) {
            var el = document.createElement('fieldset');
            try {
                return !!fn(el);
            } catch (e) {
                return false;
            } finally {
                if (el.parentNode) {
                    el.parentNode.removeChild(el);
                }
                el = null;
            }
        }
        function addHandle(attrs, handler) {
            var arr = attrs.split('|'), i = arr.length;
            while (i--) {
                Expr.attrHandle[arr[i]] = handler;
            }
        }
        function siblingCheck(a, b) {
            var cur = b && a, diff = cur && a.nodeType === 1 && b.nodeType === 1 && a.sourceIndex - b.sourceIndex;
            if (diff) {
                return diff;
            }
            if (cur) {
                while (cur = cur.nextSibling) {
                    if (cur === b) {
                        return -1;
                    }
                }
            }
            return a ? 1 : -1;
        }
        function createInputPseudo(type) {
            return function (elem) {
                var name = elem.nodeName.toLowerCase();
                return name === 'input' && elem.type === type;
            };
        }
        function createButtonPseudo(type) {
            return function (elem) {
                var name = elem.nodeName.toLowerCase();
                return (name === 'input' || name === 'button') && elem.type === type;
            };
        }
        function createDisabledPseudo(disabled) {
            return function (elem) {
                if ('form' in elem) {
                    if (elem.parentNode && elem.disabled === false) {
                        if ('label' in elem) {
                            if ('label' in elem.parentNode) {
                                return elem.parentNode.disabled === disabled;
                            } else {
                                return elem.disabled === disabled;
                            }
                        }
                        return elem.isDisabled === disabled || elem.isDisabled !== !disabled && disabledAncestor(elem) === disabled;
                    }
                    return elem.disabled === disabled;
                } else if ('label' in elem) {
                    return elem.disabled === disabled;
                }
                return false;
            };
        }
        function createPositionalPseudo(fn) {
            return markFunction(function (argument) {
                argument = +argument;
                return markFunction(function (seed, matches) {
                    var j, matchIndexes = fn([], seed.length, argument), i = matchIndexes.length;
                    while (i--) {
                        if (seed[j = matchIndexes[i]]) {
                            seed[j] = !(matches[j] = seed[j]);
                        }
                    }
                });
            });
        }
        function testContext(context) {
            return context && typeof context.getElementsByTagName !== 'undefined' && context;
        }
        support = Sizzle.support = {};
        isXML = Sizzle.isXML = function (elem) {
            var documentElement = elem && (elem.ownerDocument || elem).documentElement;
            return documentElement ? documentElement.nodeName !== 'HTML' : false;
        };
        setDocument = Sizzle.setDocument = function (node) {
            var hasCompare, subWindow, doc = node ? node.ownerDocument || node : preferredDoc;
            if (doc === document || doc.nodeType !== 9 || !doc.documentElement) {
                return document;
            }
            document = doc;
            docElem = document.documentElement;
            documentIsHTML = !isXML(document);
            if (preferredDoc !== document && (subWindow = document.defaultView) && subWindow.top !== subWindow) {
                if (subWindow.addEventListener) {
                    subWindow.addEventListener('unload', unloadHandler, false);
                } else if (subWindow.attachEvent) {
                    subWindow.attachEvent('onunload', unloadHandler);
                }
            }
            support.attributes = assert(function (el) {
                el.className = 'i';
                return !el.getAttribute('className');
            });
            support.getElementsByTagName = assert(function (el) {
                el.appendChild(document.createComment(''));
                return !el.getElementsByTagName('*').length;
            });
            support.getElementsByClassName = rnative.test(document.getElementsByClassName);
            support.getById = assert(function (el) {
                docElem.appendChild(el).id = expando;
                return !document.getElementsByName || !document.getElementsByName(expando).length;
            });
            if (support.getById) {
                Expr.filter['ID'] = function (id) {
                    var attrId = id.replace(runescape, funescape);
                    return function (elem) {
                        return elem.getAttribute('id') === attrId;
                    };
                };
                Expr.find['ID'] = function (id, context) {
                    if (typeof context.getElementById !== 'undefined' && documentIsHTML) {
                        var elem = context.getElementById(id);
                        return elem ? [elem] : [];
                    }
                };
            } else {
                Expr.filter['ID'] = function (id) {
                    var attrId = id.replace(runescape, funescape);
                    return function (elem) {
                        var node = typeof elem.getAttributeNode !== 'undefined' && elem.getAttributeNode('id');
                        return node && node.value === attrId;
                    };
                };
                Expr.find['ID'] = function (id, context) {
                    if (typeof context.getElementById !== 'undefined' && documentIsHTML) {
                        var node, i, elems, elem = context.getElementById(id);
                        if (elem) {
                            node = elem.getAttributeNode('id');
                            if (node && node.value === id) {
                                return [elem];
                            }
                            elems = context.getElementsByName(id);
                            i = 0;
                            while (elem = elems[i++]) {
                                node = elem.getAttributeNode('id');
                                if (node && node.value === id) {
                                    return [elem];
                                }
                            }
                        }
                        return [];
                    }
                };
            }
            Expr.find['TAG'] = support.getElementsByTagName ? function (tag, context) {
                if (typeof context.getElementsByTagName !== 'undefined') {
                    return context.getElementsByTagName(tag);
                } else if (support.qsa) {
                    return context.querySelectorAll(tag);
                }
            } : function (tag, context) {
                var elem, tmp = [], i = 0, results = context.getElementsByTagName(tag);
                if (tag === '*') {
                    while (elem = results[i++]) {
                        if (elem.nodeType === 1) {
                            tmp.push(elem);
                        }
                    }
                    return tmp;
                }
                return results;
            };
            Expr.find['CLASS'] = support.getElementsByClassName && function (className, context) {
                if (typeof context.getElementsByClassName !== 'undefined' && documentIsHTML) {
                    return context.getElementsByClassName(className);
                }
            };
            rbuggyMatches = [];
            rbuggyQSA = [];
            if (support.qsa = rnative.test(document.querySelectorAll)) {
                assert(function (el) {
                    docElem.appendChild(el).innerHTML = '<a id=\'' + expando + '\'></a>' + '<select id=\'' + expando + '-\r\\\' msallowcapture=\'\'>' + '<option selected=\'\'></option></select>';
                    if (el.querySelectorAll('[msallowcapture^=\'\']').length) {
                        rbuggyQSA.push('[*^$]=' + whitespace + '*(?:\'\'|"")');
                    }
                    if (!el.querySelectorAll('[selected]').length) {
                        rbuggyQSA.push('\\[' + whitespace + '*(?:value|' + booleans + ')');
                    }
                    if (!el.querySelectorAll('[id~=' + expando + '-]').length) {
                        rbuggyQSA.push('~=');
                    }
                    if (!el.querySelectorAll(':checked').length) {
                        rbuggyQSA.push(':checked');
                    }
                    if (!el.querySelectorAll('a#' + expando + '+*').length) {
                        rbuggyQSA.push('.#.+[+~]');
                    }
                });
                assert(function (el) {
                    el.innerHTML = '<a href=\'\' disabled=\'disabled\'></a>' + '<select disabled=\'disabled\'><option/></select>';
                    var input = document.createElement('input');
                    input.setAttribute('type', 'hidden');
                    el.appendChild(input).setAttribute('name', 'D');
                    if (el.querySelectorAll('[name=d]').length) {
                        rbuggyQSA.push('name' + whitespace + '*[*^$|!~]?=');
                    }
                    if (el.querySelectorAll(':enabled').length !== 2) {
                        rbuggyQSA.push(':enabled', ':disabled');
                    }
                    docElem.appendChild(el).disabled = true;
                    if (el.querySelectorAll(':disabled').length !== 2) {
                        rbuggyQSA.push(':enabled', ':disabled');
                    }
                    el.querySelectorAll('*,:x');
                    rbuggyQSA.push(',.*:');
                });
            }
            if (support.matchesSelector = rnative.test(matches = docElem.matches || docElem.webkitMatchesSelector || docElem.mozMatchesSelector || docElem.oMatchesSelector || docElem.msMatchesSelector)) {
                assert(function (el) {
                    support.disconnectedMatch = matches.call(el, '*');
                    matches.call(el, '[s!=\'\']:x');
                    rbuggyMatches.push('!=', pseudos);
                });
            }
            rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join('|'));
            rbuggyMatches = rbuggyMatches.length && new RegExp(rbuggyMatches.join('|'));
            hasCompare = rnative.test(docElem.compareDocumentPosition);
            contains = hasCompare || rnative.test(docElem.contains) ? function (a, b) {
                var adown = a.nodeType === 9 ? a.documentElement : a, bup = b && b.parentNode;
                return a === bup || !!(bup && bup.nodeType === 1 && (adown.contains ? adown.contains(bup) : a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16));
            } : function (a, b) {
                if (b) {
                    while (b = b.parentNode) {
                        if (b === a) {
                            return true;
                        }
                    }
                }
                return false;
            };
            sortOrder = hasCompare ? function (a, b) {
                if (a === b) {
                    hasDuplicate = true;
                    return 0;
                }
                var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
                if (compare) {
                    return compare;
                }
                compare = (a.ownerDocument || a) === (b.ownerDocument || b) ? a.compareDocumentPosition(b) : 1;
                if (compare & 1 || !support.sortDetached && b.compareDocumentPosition(a) === compare) {
                    if (a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a)) {
                        return -1;
                    }
                    if (b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b)) {
                        return 1;
                    }
                    return sortInput ? indexOf(sortInput, a) - indexOf(sortInput, b) : 0;
                }
                return compare & 4 ? -1 : 1;
            } : function (a, b) {
                if (a === b) {
                    hasDuplicate = true;
                    return 0;
                }
                var cur, i = 0, aup = a.parentNode, bup = b.parentNode, ap = [a], bp = [b];
                if (!aup || !bup) {
                    return a === document ? -1 : b === document ? 1 : aup ? -1 : bup ? 1 : sortInput ? indexOf(sortInput, a) - indexOf(sortInput, b) : 0;
                } else if (aup === bup) {
                    return siblingCheck(a, b);
                }
                cur = a;
                while (cur = cur.parentNode) {
                    ap.unshift(cur);
                }
                cur = b;
                while (cur = cur.parentNode) {
                    bp.unshift(cur);
                }
                while (ap[i] === bp[i]) {
                    i++;
                }
                return i ? siblingCheck(ap[i], bp[i]) : ap[i] === preferredDoc ? -1 : bp[i] === preferredDoc ? 1 : 0;
            };
            return document;
        };
        Sizzle.matches = function (expr, elements) {
            return Sizzle(expr, null, null, elements);
        };
        Sizzle.matchesSelector = function (elem, expr) {
            if ((elem.ownerDocument || elem) !== document) {
                setDocument(elem);
            }
            expr = expr.replace(rattributeQuotes, '=\'$1\']');
            if (support.matchesSelector && documentIsHTML && !compilerCache[expr + ' '] && (!rbuggyMatches || !rbuggyMatches.test(expr)) && (!rbuggyQSA || !rbuggyQSA.test(expr))) {
                try {
                    var ret = matches.call(elem, expr);
                    if (ret || support.disconnectedMatch || elem.document && elem.document.nodeType !== 11) {
                        return ret;
                    }
                } catch (e) {
                }
            }
            return Sizzle(expr, document, null, [elem]).length > 0;
        };
        Sizzle.contains = function (context, elem) {
            if ((context.ownerDocument || context) !== document) {
                setDocument(context);
            }
            return contains(context, elem);
        };
        Sizzle.attr = function (elem, name) {
            if ((elem.ownerDocument || elem) !== document) {
                setDocument(elem);
            }
            var fn = Expr.attrHandle[name.toLowerCase()], val = fn && hasOwn.call(Expr.attrHandle, name.toLowerCase()) ? fn(elem, name, !documentIsHTML) : undefined;
            return val !== undefined ? val : support.attributes || !documentIsHTML ? elem.getAttribute(name) : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;
        };
        Sizzle.escape = function (sel) {
            return (sel + '').replace(rcssescape, fcssescape);
        };
        Sizzle.error = function (msg) {
            throw new Error('Syntax error, unrecognized expression: ' + msg);
        };
        Sizzle.uniqueSort = function (results) {
            var elem, duplicates = [], j = 0, i = 0;
            hasDuplicate = !support.detectDuplicates;
            sortInput = !support.sortStable && results.slice(0);
            results.sort(sortOrder);
            if (hasDuplicate) {
                while (elem = results[i++]) {
                    if (elem === results[i]) {
                        j = duplicates.push(i);
                    }
                }
                while (j--) {
                    results.splice(duplicates[j], 1);
                }
            }
            sortInput = null;
            return results;
        };
        getText = Sizzle.getText = function (elem) {
            var node, ret = '', i = 0, nodeType = elem.nodeType;
            if (!nodeType) {
                while (node = elem[i++]) {
                    ret += getText(node);
                }
            } else if (nodeType === 1 || nodeType === 9 || nodeType === 11) {
                if (typeof elem.textContent === 'string') {
                    return elem.textContent;
                } else {
                    for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
                        ret += getText(elem);
                    }
                }
            } else if (nodeType === 3 || nodeType === 4) {
                return elem.nodeValue;
            }
            return ret;
        };
        Expr = Sizzle.selectors = {
            cacheLength: 50,
            createPseudo: markFunction,
            match: matchExpr,
            attrHandle: {},
            find: {},
            relative: {
                '>': {
                    dir: 'parentNode',
                    first: true
                },
                ' ': { dir: 'parentNode' },
                '+': {
                    dir: 'previousSibling',
                    first: true
                },
                '~': { dir: 'previousSibling' }
            },
            preFilter: {
                'ATTR': function (match) {
                    match[1] = match[1].replace(runescape, funescape);
                    match[3] = (match[3] || match[4] || match[5] || '').replace(runescape, funescape);
                    if (match[2] === '~=') {
                        match[3] = ' ' + match[3] + ' ';
                    }
                    return match.slice(0, 4);
                },
                'CHILD': function (match) {
                    match[1] = match[1].toLowerCase();
                    if (match[1].slice(0, 3) === 'nth') {
                        if (!match[3]) {
                            Sizzle.error(match[0]);
                        }
                        match[4] = +(match[4] ? match[5] + (match[6] || 1) : 2 * (match[3] === 'even' || match[3] === 'odd'));
                        match[5] = +(match[7] + match[8] || match[3] === 'odd');
                    } else if (match[3]) {
                        Sizzle.error(match[0]);
                    }
                    return match;
                },
                'PSEUDO': function (match) {
                    var excess, unquoted = !match[6] && match[2];
                    if (matchExpr['CHILD'].test(match[0])) {
                        return null;
                    }
                    if (match[3]) {
                        match[2] = match[4] || match[5] || '';
                    } else if (unquoted && rpseudo.test(unquoted) && (excess = tokenize(unquoted, true)) && (excess = unquoted.indexOf(')', unquoted.length - excess) - unquoted.length)) {
                        match[0] = match[0].slice(0, excess);
                        match[2] = unquoted.slice(0, excess);
                    }
                    return match.slice(0, 3);
                }
            },
            filter: {
                'TAG': function (nodeNameSelector) {
                    var nodeName = nodeNameSelector.replace(runescape, funescape).toLowerCase();
                    return nodeNameSelector === '*' ? function () {
                        return true;
                    } : function (elem) {
                        return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
                    };
                },
                'CLASS': function (className) {
                    var pattern = classCache[className + ' '];
                    return pattern || (pattern = new RegExp('(^|' + whitespace + ')' + className + '(' + whitespace + '|$)')) && classCache(className, function (elem) {
                        return pattern.test(typeof elem.className === 'string' && elem.className || typeof elem.getAttribute !== 'undefined' && elem.getAttribute('class') || '');
                    });
                },
                'ATTR': function (name, operator, check) {
                    return function (elem) {
                        var result = Sizzle.attr(elem, name);
                        if (result == null) {
                            return operator === '!=';
                        }
                        if (!operator) {
                            return true;
                        }
                        result += '';
                        return operator === '=' ? result === check : operator === '!=' ? result !== check : operator === '^=' ? check && result.indexOf(check) === 0 : operator === '*=' ? check && result.indexOf(check) > -1 : operator === '$=' ? check && result.slice(-check.length) === check : operator === '~=' ? (' ' + result.replace(rwhitespace, ' ') + ' ').indexOf(check) > -1 : operator === '|=' ? result === check || result.slice(0, check.length + 1) === check + '-' : false;
                    };
                },
                'CHILD': function (type, what, argument, first, last) {
                    var simple = type.slice(0, 3) !== 'nth', forward = type.slice(-4) !== 'last', ofType = what === 'of-type';
                    return first === 1 && last === 0 ? function (elem) {
                        return !!elem.parentNode;
                    } : function (elem, context, xml) {
                        var cache, uniqueCache, outerCache, node, nodeIndex, start, dir = simple !== forward ? 'nextSibling' : 'previousSibling', parent = elem.parentNode, name = ofType && elem.nodeName.toLowerCase(), useCache = !xml && !ofType, diff = false;
                        if (parent) {
                            if (simple) {
                                while (dir) {
                                    node = elem;
                                    while (node = node[dir]) {
                                        if (ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) {
                                            return false;
                                        }
                                    }
                                    start = dir = type === 'only' && !start && 'nextSibling';
                                }
                                return true;
                            }
                            start = [forward ? parent.firstChild : parent.lastChild];
                            if (forward && useCache) {
                                node = parent;
                                outerCache = node[expando] || (node[expando] = {});
                                uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});
                                cache = uniqueCache[type] || [];
                                nodeIndex = cache[0] === dirruns && cache[1];
                                diff = nodeIndex && cache[2];
                                node = nodeIndex && parent.childNodes[nodeIndex];
                                while (node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop()) {
                                    if (node.nodeType === 1 && ++diff && node === elem) {
                                        uniqueCache[type] = [
                                            dirruns,
                                            nodeIndex,
                                            diff
                                        ];
                                        break;
                                    }
                                }
                            } else {
                                if (useCache) {
                                    node = elem;
                                    outerCache = node[expando] || (node[expando] = {});
                                    uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});
                                    cache = uniqueCache[type] || [];
                                    nodeIndex = cache[0] === dirruns && cache[1];
                                    diff = nodeIndex;
                                }
                                if (diff === false) {
                                    while (node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop()) {
                                        if ((ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) && ++diff) {
                                            if (useCache) {
                                                outerCache = node[expando] || (node[expando] = {});
                                                uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});
                                                uniqueCache[type] = [
                                                    dirruns,
                                                    diff
                                                ];
                                            }
                                            if (node === elem) {
                                                break;
                                            }
                                        }
                                    }
                                }
                            }
                            diff -= last;
                            return diff === first || diff % first === 0 && diff / first >= 0;
                        }
                    };
                },
                'PSEUDO': function (pseudo, argument) {
                    var args, fn = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] || Sizzle.error('unsupported pseudo: ' + pseudo);
                    if (fn[expando]) {
                        return fn(argument);
                    }
                    if (fn.length > 1) {
                        args = [
                            pseudo,
                            pseudo,
                            '',
                            argument
                        ];
                        return Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ? markFunction(function (seed, matches) {
                            var idx, matched = fn(seed, argument), i = matched.length;
                            while (i--) {
                                idx = indexOf(seed, matched[i]);
                                seed[idx] = !(matches[idx] = matched[i]);
                            }
                        }) : function (elem) {
                            return fn(elem, 0, args);
                        };
                    }
                    return fn;
                }
            },
            pseudos: {
                'not': markFunction(function (selector) {
                    var input = [], results = [], matcher = compile(selector.replace(rtrim, '$1'));
                    return matcher[expando] ? markFunction(function (seed, matches, context, xml) {
                        var elem, unmatched = matcher(seed, null, xml, []), i = seed.length;
                        while (i--) {
                            if (elem = unmatched[i]) {
                                seed[i] = !(matches[i] = elem);
                            }
                        }
                    }) : function (elem, context, xml) {
                        input[0] = elem;
                        matcher(input, null, xml, results);
                        input[0] = null;
                        return !results.pop();
                    };
                }),
                'has': markFunction(function (selector) {
                    return function (elem) {
                        return Sizzle(selector, elem).length > 0;
                    };
                }),
                'contains': markFunction(function (text) {
                    text = text.replace(runescape, funescape);
                    return function (elem) {
                        return (elem.textContent || elem.innerText || getText(elem)).indexOf(text) > -1;
                    };
                }),
                'lang': markFunction(function (lang) {
                    if (!ridentifier.test(lang || '')) {
                        Sizzle.error('unsupported lang: ' + lang);
                    }
                    lang = lang.replace(runescape, funescape).toLowerCase();
                    return function (elem) {
                        var elemLang;
                        do {
                            if (elemLang = documentIsHTML ? elem.lang : elem.getAttribute('xml:lang') || elem.getAttribute('lang')) {
                                elemLang = elemLang.toLowerCase();
                                return elemLang === lang || elemLang.indexOf(lang + '-') === 0;
                            }
                        } while ((elem = elem.parentNode) && elem.nodeType === 1);
                        return false;
                    };
                }),
                'target': function (elem) {
                    var hash = window.location && window.location.hash;
                    return hash && hash.slice(1) === elem.id;
                },
                'root': function (elem) {
                    return elem === docElem;
                },
                'focus': function (elem) {
                    return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
                },
                'enabled': createDisabledPseudo(false),
                'disabled': createDisabledPseudo(true),
                'checked': function (elem) {
                    var nodeName = elem.nodeName.toLowerCase();
                    return nodeName === 'input' && !!elem.checked || nodeName === 'option' && !!elem.selected;
                },
                'selected': function (elem) {
                    if (elem.parentNode) {
                        elem.parentNode.selectedIndex;
                    }
                    return elem.selected === true;
                },
                'empty': function (elem) {
                    for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
                        if (elem.nodeType < 6) {
                            return false;
                        }
                    }
                    return true;
                },
                'parent': function (elem) {
                    return !Expr.pseudos['empty'](elem);
                },
                'header': function (elem) {
                    return rheader.test(elem.nodeName);
                },
                'input': function (elem) {
                    return rinputs.test(elem.nodeName);
                },
                'button': function (elem) {
                    var name = elem.nodeName.toLowerCase();
                    return name === 'input' && elem.type === 'button' || name === 'button';
                },
                'text': function (elem) {
                    var attr;
                    return elem.nodeName.toLowerCase() === 'input' && elem.type === 'text' && ((attr = elem.getAttribute('type')) == null || attr.toLowerCase() === 'text');
                },
                'first': createPositionalPseudo(function () {
                    return [0];
                }),
                'last': createPositionalPseudo(function (matchIndexes, length) {
                    return [length - 1];
                }),
                'eq': createPositionalPseudo(function (matchIndexes, length, argument) {
                    return [argument < 0 ? argument + length : argument];
                }),
                'even': createPositionalPseudo(function (matchIndexes, length) {
                    var i = 0;
                    for (; i < length; i += 2) {
                        matchIndexes.push(i);
                    }
                    return matchIndexes;
                }),
                'odd': createPositionalPseudo(function (matchIndexes, length) {
                    var i = 1;
                    for (; i < length; i += 2) {
                        matchIndexes.push(i);
                    }
                    return matchIndexes;
                }),
                'lt': createPositionalPseudo(function (matchIndexes, length, argument) {
                    var i = argument < 0 ? argument + length : argument;
                    for (; --i >= 0;) {
                        matchIndexes.push(i);
                    }
                    return matchIndexes;
                }),
                'gt': createPositionalPseudo(function (matchIndexes, length, argument) {
                    var i = argument < 0 ? argument + length : argument;
                    for (; ++i < length;) {
                        matchIndexes.push(i);
                    }
                    return matchIndexes;
                })
            }
        };
        Expr.pseudos['nth'] = Expr.pseudos['eq'];
        for (i in {
                radio: true,
                checkbox: true,
                file: true,
                password: true,
                image: true
            }) {
            Expr.pseudos[i] = createInputPseudo(i);
        }
        for (i in {
                submit: true,
                reset: true
            }) {
            Expr.pseudos[i] = createButtonPseudo(i);
        }
        function setFilters() {
        }
        setFilters.prototype = Expr.filters = Expr.pseudos;
        Expr.setFilters = new setFilters();
        tokenize = Sizzle.tokenize = function (selector, parseOnly) {
            var matched, match, tokens, type, soFar, groups, preFilters, cached = tokenCache[selector + ' '];
            if (cached) {
                return parseOnly ? 0 : cached.slice(0);
            }
            soFar = selector;
            groups = [];
            preFilters = Expr.preFilter;
            while (soFar) {
                if (!matched || (match = rcomma.exec(soFar))) {
                    if (match) {
                        soFar = soFar.slice(match[0].length) || soFar;
                    }
                    groups.push(tokens = []);
                }
                matched = false;
                if (match = rcombinators.exec(soFar)) {
                    matched = match.shift();
                    tokens.push({
                        value: matched,
                        type: match[0].replace(rtrim, ' ')
                    });
                    soFar = soFar.slice(matched.length);
                }
                for (type in Expr.filter) {
                    if ((match = matchExpr[type].exec(soFar)) && (!preFilters[type] || (match = preFilters[type](match)))) {
                        matched = match.shift();
                        tokens.push({
                            value: matched,
                            type: type,
                            matches: match
                        });
                        soFar = soFar.slice(matched.length);
                    }
                }
                if (!matched) {
                    break;
                }
            }
            return parseOnly ? soFar.length : soFar ? Sizzle.error(selector) : tokenCache(selector, groups).slice(0);
        };
        function toSelector(tokens) {
            var i = 0, len = tokens.length, selector = '';
            for (; i < len; i++) {
                selector += tokens[i].value;
            }
            return selector;
        }
        function addCombinator(matcher, combinator, base) {
            var dir = combinator.dir, skip = combinator.next, key = skip || dir, checkNonElements = base && key === 'parentNode', doneName = done++;
            return combinator.first ? function (elem, context, xml) {
                while (elem = elem[dir]) {
                    if (elem.nodeType === 1 || checkNonElements) {
                        return matcher(elem, context, xml);
                    }
                }
                return false;
            } : function (elem, context, xml) {
                var oldCache, uniqueCache, outerCache, newCache = [
                        dirruns,
                        doneName
                    ];
                if (xml) {
                    while (elem = elem[dir]) {
                        if (elem.nodeType === 1 || checkNonElements) {
                            if (matcher(elem, context, xml)) {
                                return true;
                            }
                        }
                    }
                } else {
                    while (elem = elem[dir]) {
                        if (elem.nodeType === 1 || checkNonElements) {
                            outerCache = elem[expando] || (elem[expando] = {});
                            uniqueCache = outerCache[elem.uniqueID] || (outerCache[elem.uniqueID] = {});
                            if (skip && skip === elem.nodeName.toLowerCase()) {
                                elem = elem[dir] || elem;
                            } else if ((oldCache = uniqueCache[key]) && oldCache[0] === dirruns && oldCache[1] === doneName) {
                                return newCache[2] = oldCache[2];
                            } else {
                                uniqueCache[key] = newCache;
                                if (newCache[2] = matcher(elem, context, xml)) {
                                    return true;
                                }
                            }
                        }
                    }
                }
                return false;
            };
        }
        function elementMatcher(matchers) {
            return matchers.length > 1 ? function (elem, context, xml) {
                var i = matchers.length;
                while (i--) {
                    if (!matchers[i](elem, context, xml)) {
                        return false;
                    }
                }
                return true;
            } : matchers[0];
        }
        function multipleContexts(selector, contexts, results) {
            var i = 0, len = contexts.length;
            for (; i < len; i++) {
                Sizzle(selector, contexts[i], results);
            }
            return results;
        }
        function condense(unmatched, map, filter, context, xml) {
            var elem, newUnmatched = [], i = 0, len = unmatched.length, mapped = map != null;
            for (; i < len; i++) {
                if (elem = unmatched[i]) {
                    if (!filter || filter(elem, context, xml)) {
                        newUnmatched.push(elem);
                        if (mapped) {
                            map.push(i);
                        }
                    }
                }
            }
            return newUnmatched;
        }
        function setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {
            if (postFilter && !postFilter[expando]) {
                postFilter = setMatcher(postFilter);
            }
            if (postFinder && !postFinder[expando]) {
                postFinder = setMatcher(postFinder, postSelector);
            }
            return markFunction(function (seed, results, context, xml) {
                var temp, i, elem, preMap = [], postMap = [], preexisting = results.length, elems = seed || multipleContexts(selector || '*', context.nodeType ? [context] : context, []), matcherIn = preFilter && (seed || !selector) ? condense(elems, preMap, preFilter, context, xml) : elems, matcherOut = matcher ? postFinder || (seed ? preFilter : preexisting || postFilter) ? [] : results : matcherIn;
                if (matcher) {
                    matcher(matcherIn, matcherOut, context, xml);
                }
                if (postFilter) {
                    temp = condense(matcherOut, postMap);
                    postFilter(temp, [], context, xml);
                    i = temp.length;
                    while (i--) {
                        if (elem = temp[i]) {
                            matcherOut[postMap[i]] = !(matcherIn[postMap[i]] = elem);
                        }
                    }
                }
                if (seed) {
                    if (postFinder || preFilter) {
                        if (postFinder) {
                            temp = [];
                            i = matcherOut.length;
                            while (i--) {
                                if (elem = matcherOut[i]) {
                                    temp.push(matcherIn[i] = elem);
                                }
                            }
                            postFinder(null, matcherOut = [], temp, xml);
                        }
                        i = matcherOut.length;
                        while (i--) {
                            if ((elem = matcherOut[i]) && (temp = postFinder ? indexOf(seed, elem) : preMap[i]) > -1) {
                                seed[temp] = !(results[temp] = elem);
                            }
                        }
                    }
                } else {
                    matcherOut = condense(matcherOut === results ? matcherOut.splice(preexisting, matcherOut.length) : matcherOut);
                    if (postFinder) {
                        postFinder(null, results, matcherOut, xml);
                    } else {
                        push.apply(results, matcherOut);
                    }
                }
            });
        }
        function matcherFromTokens(tokens) {
            var checkContext, matcher, j, len = tokens.length, leadingRelative = Expr.relative[tokens[0].type], implicitRelative = leadingRelative || Expr.relative[' '], i = leadingRelative ? 1 : 0, matchContext = addCombinator(function (elem) {
                    return elem === checkContext;
                }, implicitRelative, true), matchAnyContext = addCombinator(function (elem) {
                    return indexOf(checkContext, elem) > -1;
                }, implicitRelative, true), matchers = [function (elem, context, xml) {
                        var ret = !leadingRelative && (xml || context !== outermostContext) || ((checkContext = context).nodeType ? matchContext(elem, context, xml) : matchAnyContext(elem, context, xml));
                        checkContext = null;
                        return ret;
                    }];
            for (; i < len; i++) {
                if (matcher = Expr.relative[tokens[i].type]) {
                    matchers = [addCombinator(elementMatcher(matchers), matcher)];
                } else {
                    matcher = Expr.filter[tokens[i].type].apply(null, tokens[i].matches);
                    if (matcher[expando]) {
                        j = ++i;
                        for (; j < len; j++) {
                            if (Expr.relative[tokens[j].type]) {
                                break;
                            }
                        }
                        return setMatcher(i > 1 && elementMatcher(matchers), i > 1 && toSelector(tokens.slice(0, i - 1).concat({ value: tokens[i - 2].type === ' ' ? '*' : '' })).replace(rtrim, '$1'), matcher, i < j && matcherFromTokens(tokens.slice(i, j)), j < len && matcherFromTokens(tokens = tokens.slice(j)), j < len && toSelector(tokens));
                    }
                    matchers.push(matcher);
                }
            }
            return elementMatcher(matchers);
        }
        function matcherFromGroupMatchers(elementMatchers, setMatchers) {
            var bySet = setMatchers.length > 0, byElement = elementMatchers.length > 0, superMatcher = function (seed, context, xml, results, outermost) {
                    var elem, j, matcher, matchedCount = 0, i = '0', unmatched = seed && [], setMatched = [], contextBackup = outermostContext, elems = seed || byElement && Expr.find['TAG']('*', outermost), dirrunsUnique = dirruns += contextBackup == null ? 1 : Math.random() || 0.1, len = elems.length;
                    if (outermost) {
                        outermostContext = context === document || context || outermost;
                    }
                    for (; i !== len && (elem = elems[i]) != null; i++) {
                        if (byElement && elem) {
                            j = 0;
                            if (!context && elem.ownerDocument !== document) {
                                setDocument(elem);
                                xml = !documentIsHTML;
                            }
                            while (matcher = elementMatchers[j++]) {
                                if (matcher(elem, context || document, xml)) {
                                    results.push(elem);
                                    break;
                                }
                            }
                            if (outermost) {
                                dirruns = dirrunsUnique;
                            }
                        }
                        if (bySet) {
                            if (elem = !matcher && elem) {
                                matchedCount--;
                            }
                            if (seed) {
                                unmatched.push(elem);
                            }
                        }
                    }
                    matchedCount += i;
                    if (bySet && i !== matchedCount) {
                        j = 0;
                        while (matcher = setMatchers[j++]) {
                            matcher(unmatched, setMatched, context, xml);
                        }
                        if (seed) {
                            if (matchedCount > 0) {
                                while (i--) {
                                    if (!(unmatched[i] || setMatched[i])) {
                                        setMatched[i] = pop.call(results);
                                    }
                                }
                            }
                            setMatched = condense(setMatched);
                        }
                        push.apply(results, setMatched);
                        if (outermost && !seed && setMatched.length > 0 && matchedCount + setMatchers.length > 1) {
                            Sizzle.uniqueSort(results);
                        }
                    }
                    if (outermost) {
                        dirruns = dirrunsUnique;
                        outermostContext = contextBackup;
                    }
                    return unmatched;
                };
            return bySet ? markFunction(superMatcher) : superMatcher;
        }
        compile = Sizzle.compile = function (selector, match) {
            var i, setMatchers = [], elementMatchers = [], cached = compilerCache[selector + ' '];
            if (!cached) {
                if (!match) {
                    match = tokenize(selector);
                }
                i = match.length;
                while (i--) {
                    cached = matcherFromTokens(match[i]);
                    if (cached[expando]) {
                        setMatchers.push(cached);
                    } else {
                        elementMatchers.push(cached);
                    }
                }
                cached = compilerCache(selector, matcherFromGroupMatchers(elementMatchers, setMatchers));
                cached.selector = selector;
            }
            return cached;
        };
        select = Sizzle.select = function (selector, context, results, seed) {
            var i, tokens, token, type, find, compiled = typeof selector === 'function' && selector, match = !seed && tokenize(selector = compiled.selector || selector);
            results = results || [];
            if (match.length === 1) {
                tokens = match[0] = match[0].slice(0);
                if (tokens.length > 2 && (token = tokens[0]).type === 'ID' && context.nodeType === 9 && documentIsHTML && Expr.relative[tokens[1].type]) {
                    context = (Expr.find['ID'](token.matches[0].replace(runescape, funescape), context) || [])[0];
                    if (!context) {
                        return results;
                    } else if (compiled) {
                        context = context.parentNode;
                    }
                    selector = selector.slice(tokens.shift().value.length);
                }
                i = matchExpr['needsContext'].test(selector) ? 0 : tokens.length;
                while (i--) {
                    token = tokens[i];
                    if (Expr.relative[type = token.type]) {
                        break;
                    }
                    if (find = Expr.find[type]) {
                        if (seed = find(token.matches[0].replace(runescape, funescape), rsibling.test(tokens[0].type) && testContext(context.parentNode) || context)) {
                            tokens.splice(i, 1);
                            selector = seed.length && toSelector(tokens);
                            if (!selector) {
                                push.apply(results, seed);
                                return results;
                            }
                            break;
                        }
                    }
                }
            }
            (compiled || compile(selector, match))(seed, context, !documentIsHTML, results, !context || rsibling.test(selector) && testContext(context.parentNode) || context);
            return results;
        };
        support.sortStable = expando.split('').sort(sortOrder).join('') === expando;
        support.detectDuplicates = !!hasDuplicate;
        setDocument();
        support.sortDetached = assert(function (el) {
            return el.compareDocumentPosition(document.createElement('fieldset')) & 1;
        });
        if (!assert(function (el) {
                el.innerHTML = '<a href=\'#\'></a>';
                return el.firstChild.getAttribute('href') === '#';
            })) {
            addHandle('type|href|height|width', function (elem, name, isXML) {
                if (!isXML) {
                    return elem.getAttribute(name, name.toLowerCase() === 'type' ? 1 : 2);
                }
            });
        }
        if (!support.attributes || !assert(function (el) {
                el.innerHTML = '<input/>';
                el.firstChild.setAttribute('value', '');
                return el.firstChild.getAttribute('value') === '';
            })) {
            addHandle('value', function (elem, name, isXML) {
                if (!isXML && elem.nodeName.toLowerCase() === 'input') {
                    return elem.defaultValue;
                }
            });
        }
        if (!assert(function (el) {
                return el.getAttribute('disabled') == null;
            })) {
            addHandle(booleans, function (elem, name, isXML) {
                var val;
                if (!isXML) {
                    return elem[name] === true ? name.toLowerCase() : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;
                }
            });
        }
        return Sizzle;
    }(window);
    jQuery.find = Sizzle;
    jQuery.expr = Sizzle.selectors;
    jQuery.expr[':'] = jQuery.expr.pseudos;
    jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;
    jQuery.text = Sizzle.getText;
    jQuery.isXMLDoc = Sizzle.isXML;
    jQuery.contains = Sizzle.contains;
    jQuery.escapeSelector = Sizzle.escape;
    var dir = function (elem, dir, until) {
        var matched = [], truncate = until !== undefined;
        while ((elem = elem[dir]) && elem.nodeType !== 9) {
            if (elem.nodeType === 1) {
                if (truncate && jQuery(elem).is(until)) {
                    break;
                }
                matched.push(elem);
            }
        }
        return matched;
    };
    var siblings = function (n, elem) {
        var matched = [];
        for (; n; n = n.nextSibling) {
            if (n.nodeType === 1 && n !== elem) {
                matched.push(n);
            }
        }
        return matched;
    };
    var rneedsContext = jQuery.expr.match.needsContext;
    function nodeName(elem, name) {
        return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
    }
    ;
    var rsingleTag = /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i;
    function winnow(elements, qualifier, not) {
        if (isFunction(qualifier)) {
            return jQuery.grep(elements, function (elem, i) {
                return !!qualifier.call(elem, i, elem) !== not;
            });
        }
        if (qualifier.nodeType) {
            return jQuery.grep(elements, function (elem) {
                return elem === qualifier !== not;
            });
        }
        if (typeof qualifier !== 'string') {
            return jQuery.grep(elements, function (elem) {
                return indexOf.call(qualifier, elem) > -1 !== not;
            });
        }
        return jQuery.filter(qualifier, elements, not);
    }
    jQuery.filter = function (expr, elems, not) {
        var elem = elems[0];
        if (not) {
            expr = ':not(' + expr + ')';
        }
        if (elems.length === 1 && elem.nodeType === 1) {
            return jQuery.find.matchesSelector(elem, expr) ? [elem] : [];
        }
        return jQuery.find.matches(expr, jQuery.grep(elems, function (elem) {
            return elem.nodeType === 1;
        }));
    };
    jQuery.fn.extend({
        find: function (selector) {
            var i, ret, len = this.length, self = this;
            if (typeof selector !== 'string') {
                return this.pushStack(jQuery(selector).filter(function () {
                    for (i = 0; i < len; i++) {
                        if (jQuery.contains(self[i], this)) {
                            return true;
                        }
                    }
                }));
            }
            ret = this.pushStack([]);
            for (i = 0; i < len; i++) {
                jQuery.find(selector, self[i], ret);
            }
            return len > 1 ? jQuery.uniqueSort(ret) : ret;
        },
        filter: function (selector) {
            return this.pushStack(winnow(this, selector || [], false));
        },
        not: function (selector) {
            return this.pushStack(winnow(this, selector || [], true));
        },
        is: function (selector) {
            return !!winnow(this, typeof selector === 'string' && rneedsContext.test(selector) ? jQuery(selector) : selector || [], false).length;
        }
    });
    var rootjQuery, rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/, init = jQuery.fn.init = function (selector, context, root) {
            var match, elem;
            if (!selector) {
                return this;
            }
            root = root || rootjQuery;
            if (typeof selector === 'string') {
                if (selector[0] === '<' && selector[selector.length - 1] === '>' && selector.length >= 3) {
                    match = [
                        null,
                        selector,
                        null
                    ];
                } else {
                    match = rquickExpr.exec(selector);
                }
                if (match && (match[1] || !context)) {
                    if (match[1]) {
                        context = context instanceof jQuery ? context[0] : context;
                        jQuery.merge(this, jQuery.parseHTML(match[1], context && context.nodeType ? context.ownerDocument || context : document, true));
                        if (rsingleTag.test(match[1]) && jQuery.isPlainObject(context)) {
                            for (match in context) {
                                if (isFunction(this[match])) {
                                    this[match](context[match]);
                                } else {
                                    this.attr(match, context[match]);
                                }
                            }
                        }
                        return this;
                    } else {
                        elem = document.getElementById(match[2]);
                        if (elem) {
                            this[0] = elem;
                            this.length = 1;
                        }
                        return this;
                    }
                } else if (!context || context.jquery) {
                    return (context || root).find(selector);
                } else {
                    return this.constructor(context).find(selector);
                }
            } else if (selector.nodeType) {
                this[0] = selector;
                this.length = 1;
                return this;
            } else if (isFunction(selector)) {
                return root.ready !== undefined ? root.ready(selector) : selector(jQuery);
            }
            return jQuery.makeArray(selector, this);
        };
    init.prototype = jQuery.fn;
    rootjQuery = jQuery(document);
    var rparentsprev = /^(?:parents|prev(?:Until|All))/, guaranteedUnique = {
            children: true,
            contents: true,
            next: true,
            prev: true
        };
    jQuery.fn.extend({
        has: function (target) {
            var targets = jQuery(target, this), l = targets.length;
            return this.filter(function () {
                var i = 0;
                for (; i < l; i++) {
                    if (jQuery.contains(this, targets[i])) {
                        return true;
                    }
                }
            });
        },
        closest: function (selectors, context) {
            var cur, i = 0, l = this.length, matched = [], targets = typeof selectors !== 'string' && jQuery(selectors);
            if (!rneedsContext.test(selectors)) {
                for (; i < l; i++) {
                    for (cur = this[i]; cur && cur !== context; cur = cur.parentNode) {
                        if (cur.nodeType < 11 && (targets ? targets.index(cur) > -1 : cur.nodeType === 1 && jQuery.find.matchesSelector(cur, selectors))) {
                            matched.push(cur);
                            break;
                        }
                    }
                }
            }
            return this.pushStack(matched.length > 1 ? jQuery.uniqueSort(matched) : matched);
        },
        index: function (elem) {
            if (!elem) {
                return this[0] && this[0].parentNode ? this.first().prevAll().length : -1;
            }
            if (typeof elem === 'string') {
                return indexOf.call(jQuery(elem), this[0]);
            }
            return indexOf.call(this, elem.jquery ? elem[0] : elem);
        },
        add: function (selector, context) {
            return this.pushStack(jQuery.uniqueSort(jQuery.merge(this.get(), jQuery(selector, context))));
        },
        addBack: function (selector) {
            return this.add(selector == null ? this.prevObject : this.prevObject.filter(selector));
        }
    });
    function sibling(cur, dir) {
        while ((cur = cur[dir]) && cur.nodeType !== 1) {
        }
        return cur;
    }
    jQuery.each({
        parent: function (elem) {
            var parent = elem.parentNode;
            return parent && parent.nodeType !== 11 ? parent : null;
        },
        parents: function (elem) {
            return dir(elem, 'parentNode');
        },
        parentsUntil: function (elem, i, until) {
            return dir(elem, 'parentNode', until);
        },
        next: function (elem) {
            return sibling(elem, 'nextSibling');
        },
        prev: function (elem) {
            return sibling(elem, 'previousSibling');
        },
        nextAll: function (elem) {
            return dir(elem, 'nextSibling');
        },
        prevAll: function (elem) {
            return dir(elem, 'previousSibling');
        },
        nextUntil: function (elem, i, until) {
            return dir(elem, 'nextSibling', until);
        },
        prevUntil: function (elem, i, until) {
            return dir(elem, 'previousSibling', until);
        },
        siblings: function (elem) {
            return siblings((elem.parentNode || {}).firstChild, elem);
        },
        children: function (elem) {
            return siblings(elem.firstChild);
        },
        contents: function (elem) {
            if (nodeName(elem, 'iframe')) {
                return elem.contentDocument;
            }
            if (nodeName(elem, 'template')) {
                elem = elem.content || elem;
            }
            return jQuery.merge([], elem.childNodes);
        }
    }, function (name, fn) {
        jQuery.fn[name] = function (until, selector) {
            var matched = jQuery.map(this, fn, until);
            if (name.slice(-5) !== 'Until') {
                selector = until;
            }
            if (selector && typeof selector === 'string') {
                matched = jQuery.filter(selector, matched);
            }
            if (this.length > 1) {
                if (!guaranteedUnique[name]) {
                    jQuery.uniqueSort(matched);
                }
                if (rparentsprev.test(name)) {
                    matched.reverse();
                }
            }
            return this.pushStack(matched);
        };
    });
    var rnothtmlwhite = /[^\x20\t\r\n\f]+/g;
    function createOptions(options) {
        var object = {};
        jQuery.each(options.match(rnothtmlwhite) || [], function (_, flag) {
            object[flag] = true;
        });
        return object;
    }
    jQuery.Callbacks = function (options) {
        options = typeof options === 'string' ? createOptions(options) : jQuery.extend({}, options);
        var firing, memory, fired, locked, list = [], queue = [], firingIndex = -1, fire = function () {
                locked = locked || options.once;
                fired = firing = true;
                for (; queue.length; firingIndex = -1) {
                    memory = queue.shift();
                    while (++firingIndex < list.length) {
                        if (list[firingIndex].apply(memory[0], memory[1]) === false && options.stopOnFalse) {
                            firingIndex = list.length;
                            memory = false;
                        }
                    }
                }
                if (!options.memory) {
                    memory = false;
                }
                firing = false;
                if (locked) {
                    if (memory) {
                        list = [];
                    } else {
                        list = '';
                    }
                }
            }, self = {
                add: function () {
                    if (list) {
                        if (memory && !firing) {
                            firingIndex = list.length - 1;
                            queue.push(memory);
                        }
                        (function add(args) {
                            jQuery.each(args, function (_, arg) {
                                if (isFunction(arg)) {
                                    if (!options.unique || !self.has(arg)) {
                                        list.push(arg);
                                    }
                                } else if (arg && arg.length && toType(arg) !== 'string') {
                                    add(arg);
                                }
                            });
                        }(arguments));
                        if (memory && !firing) {
                            fire();
                        }
                    }
                    return this;
                },
                remove: function () {
                    jQuery.each(arguments, function (_, arg) {
                        var index;
                        while ((index = jQuery.inArray(arg, list, index)) > -1) {
                            list.splice(index, 1);
                            if (index <= firingIndex) {
                                firingIndex--;
                            }
                        }
                    });
                    return this;
                },
                has: function (fn) {
                    return fn ? jQuery.inArray(fn, list) > -1 : list.length > 0;
                },
                empty: function () {
                    if (list) {
                        list = [];
                    }
                    return this;
                },
                disable: function () {
                    locked = queue = [];
                    list = memory = '';
                    return this;
                },
                disabled: function () {
                    return !list;
                },
                lock: function () {
                    locked = queue = [];
                    if (!memory && !firing) {
                        list = memory = '';
                    }
                    return this;
                },
                locked: function () {
                    return !!locked;
                },
                fireWith: function (context, args) {
                    if (!locked) {
                        args = args || [];
                        args = [
                            context,
                            args.slice ? args.slice() : args
                        ];
                        queue.push(args);
                        if (!firing) {
                            fire();
                        }
                    }
                    return this;
                },
                fire: function () {
                    self.fireWith(this, arguments);
                    return this;
                },
                fired: function () {
                    return !!fired;
                }
            };
        return self;
    };
    function Identity(v) {
        return v;
    }
    function Thrower(ex) {
        throw ex;
    }
    function adoptValue(value, resolve, reject, noValue) {
        var method;
        try {
            if (value && isFunction(method = value.promise)) {
                method.call(value).done(resolve).fail(reject);
            } else if (value && isFunction(method = value.then)) {
                method.call(value, resolve, reject);
            } else {
                resolve.apply(undefined, [value].slice(noValue));
            }
        } catch (value) {
            reject.apply(undefined, [value]);
        }
    }
    jQuery.extend({
        Deferred: function (func) {
            var tuples = [
                    [
                        'notify',
                        'progress',
                        jQuery.Callbacks('memory'),
                        jQuery.Callbacks('memory'),
                        2
                    ],
                    [
                        'resolve',
                        'done',
                        jQuery.Callbacks('once memory'),
                        jQuery.Callbacks('once memory'),
                        0,
                        'resolved'
                    ],
                    [
                        'reject',
                        'fail',
                        jQuery.Callbacks('once memory'),
                        jQuery.Callbacks('once memory'),
                        1,
                        'rejected'
                    ]
                ], state = 'pending', promise = {
                    state: function () {
                        return state;
                    },
                    always: function () {
                        deferred.done(arguments).fail(arguments);
                        return this;
                    },
                    'catch': function (fn) {
                        return promise.then(null, fn);
                    },
                    pipe: function () {
                        var fns = arguments;
                        return jQuery.Deferred(function (newDefer) {
                            jQuery.each(tuples, function (i, tuple) {
                                var fn = isFunction(fns[tuple[4]]) && fns[tuple[4]];
                                deferred[tuple[1]](function () {
                                    var returned = fn && fn.apply(this, arguments);
                                    if (returned && isFunction(returned.promise)) {
                                        returned.promise().progress(newDefer.notify).done(newDefer.resolve).fail(newDefer.reject);
                                    } else {
                                        newDefer[tuple[0] + 'With'](this, fn ? [returned] : arguments);
                                    }
                                });
                            });
                            fns = null;
                        }).promise();
                    },
                    then: function (onFulfilled, onRejected, onProgress) {
                        var maxDepth = 0;
                        function resolve(depth, deferred, handler, special) {
                            return function () {
                                var that = this, args = arguments, mightThrow = function () {
                                        var returned, then;
                                        if (depth < maxDepth) {
                                            return;
                                        }
                                        returned = handler.apply(that, args);
                                        if (returned === deferred.promise()) {
                                            throw new TypeError('Thenable self-resolution');
                                        }
                                        then = returned && (typeof returned === 'object' || typeof returned === 'function') && returned.then;
                                        if (isFunction(then)) {
                                            if (special) {
                                                then.call(returned, resolve(maxDepth, deferred, Identity, special), resolve(maxDepth, deferred, Thrower, special));
                                            } else {
                                                maxDepth++;
                                                then.call(returned, resolve(maxDepth, deferred, Identity, special), resolve(maxDepth, deferred, Thrower, special), resolve(maxDepth, deferred, Identity, deferred.notifyWith));
                                            }
                                        } else {
                                            if (handler !== Identity) {
                                                that = undefined;
                                                args = [returned];
                                            }
                                            (special || deferred.resolveWith)(that, args);
                                        }
                                    }, process = special ? mightThrow : function () {
                                        try {
                                            mightThrow();
                                        } catch (e) {
                                            if (jQuery.Deferred.exceptionHook) {
                                                jQuery.Deferred.exceptionHook(e, process.stackTrace);
                                            }
                                            if (depth + 1 >= maxDepth) {
                                                if (handler !== Thrower) {
                                                    that = undefined;
                                                    args = [e];
                                                }
                                                deferred.rejectWith(that, args);
                                            }
                                        }
                                    };
                                if (depth) {
                                    process();
                                } else {
                                    if (jQuery.Deferred.getStackHook) {
                                        process.stackTrace = jQuery.Deferred.getStackHook();
                                    }
                                    window.setTimeout(process);
                                }
                            };
                        }
                        return jQuery.Deferred(function (newDefer) {
                            tuples[0][3].add(resolve(0, newDefer, isFunction(onProgress) ? onProgress : Identity, newDefer.notifyWith));
                            tuples[1][3].add(resolve(0, newDefer, isFunction(onFulfilled) ? onFulfilled : Identity));
                            tuples[2][3].add(resolve(0, newDefer, isFunction(onRejected) ? onRejected : Thrower));
                        }).promise();
                    },
                    promise: function (obj) {
                        return obj != null ? jQuery.extend(obj, promise) : promise;
                    }
                }, deferred = {};
            jQuery.each(tuples, function (i, tuple) {
                var list = tuple[2], stateString = tuple[5];
                promise[tuple[1]] = list.add;
                if (stateString) {
                    list.add(function () {
                        state = stateString;
                    }, tuples[3 - i][2].disable, tuples[3 - i][3].disable, tuples[0][2].lock, tuples[0][3].lock);
                }
                list.add(tuple[3].fire);
                deferred[tuple[0]] = function () {
                    deferred[tuple[0] + 'With'](this === deferred ? undefined : this, arguments);
                    return this;
                };
                deferred[tuple[0] + 'With'] = list.fireWith;
            });
            promise.promise(deferred);
            if (func) {
                func.call(deferred, deferred);
            }
            return deferred;
        },
        when: function (singleValue) {
            var remaining = arguments.length, i = remaining, resolveContexts = Array(i), resolveValues = slice.call(arguments), master = jQuery.Deferred(), updateFunc = function (i) {
                    return function (value) {
                        resolveContexts[i] = this;
                        resolveValues[i] = arguments.length > 1 ? slice.call(arguments) : value;
                        if (!--remaining) {
                            master.resolveWith(resolveContexts, resolveValues);
                        }
                    };
                };
            if (remaining <= 1) {
                adoptValue(singleValue, master.done(updateFunc(i)).resolve, master.reject, !remaining);
                if (master.state() === 'pending' || isFunction(resolveValues[i] && resolveValues[i].then)) {
                    return master.then();
                }
            }
            while (i--) {
                adoptValue(resolveValues[i], updateFunc(i), master.reject);
            }
            return master.promise();
        }
    });
    var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;
    jQuery.Deferred.exceptionHook = function (error, stack) {
        if (window.console && window.console.warn && error && rerrorNames.test(error.name)) {
            window.console.warn('jQuery.Deferred exception: ' + error.message, error.stack, stack);
        }
    };
    jQuery.readyException = function (error) {
        window.setTimeout(function () {
            throw error;
        });
    };
    var readyList = jQuery.Deferred();
    jQuery.fn.ready = function (fn) {
        readyList.then(fn).catch(function (error) {
            jQuery.readyException(error);
        });
        return this;
    };
    jQuery.extend({
        isReady: false,
        readyWait: 1,
        ready: function (wait) {
            if (wait === true ? --jQuery.readyWait : jQuery.isReady) {
                return;
            }
            jQuery.isReady = true;
            if (wait !== true && --jQuery.readyWait > 0) {
                return;
            }
            readyList.resolveWith(document, [jQuery]);
        }
    });
    jQuery.ready.then = readyList.then;
    function completed() {
        document.removeEventListener('DOMContentLoaded', completed);
        window.removeEventListener('load', completed);
        jQuery.ready();
    }
    if (document.readyState === 'complete' || document.readyState !== 'loading' && !document.documentElement.doScroll) {
        window.setTimeout(jQuery.ready);
    } else {
        document.addEventListener('DOMContentLoaded', completed);
        window.addEventListener('load', completed);
    }
    var access = function (elems, fn, key, value, chainable, emptyGet, raw) {
        var i = 0, len = elems.length, bulk = key == null;
        if (toType(key) === 'object') {
            chainable = true;
            for (i in key) {
                access(elems, fn, i, key[i], true, emptyGet, raw);
            }
        } else if (value !== undefined) {
            chainable = true;
            if (!isFunction(value)) {
                raw = true;
            }
            if (bulk) {
                if (raw) {
                    fn.call(elems, value);
                    fn = null;
                } else {
                    bulk = fn;
                    fn = function (elem, key, value) {
                        return bulk.call(jQuery(elem), value);
                    };
                }
            }
            if (fn) {
                for (; i < len; i++) {
                    fn(elems[i], key, raw ? value : value.call(elems[i], i, fn(elems[i], key)));
                }
            }
        }
        if (chainable) {
            return elems;
        }
        if (bulk) {
            return fn.call(elems);
        }
        return len ? fn(elems[0], key) : emptyGet;
    };
    var rmsPrefix = /^-ms-/, rdashAlpha = /-([a-z])/g;
    function fcamelCase(all, letter) {
        return letter.toUpperCase();
    }
    function camelCase(string) {
        return string.replace(rmsPrefix, 'ms-').replace(rdashAlpha, fcamelCase);
    }
    var acceptData = function (owner) {
        return owner.nodeType === 1 || owner.nodeType === 9 || !+owner.nodeType;
    };
    function Data() {
        this.expando = jQuery.expando + Data.uid++;
    }
    Data.uid = 1;
    Data.prototype = {
        cache: function (owner) {
            var value = owner[this.expando];
            if (!value) {
                value = {};
                if (acceptData(owner)) {
                    if (owner.nodeType) {
                        owner[this.expando] = value;
                    } else {
                        Object.defineProperty(owner, this.expando, {
                            value: value,
                            configurable: true
                        });
                    }
                }
            }
            return value;
        },
        set: function (owner, data, value) {
            var prop, cache = this.cache(owner);
            if (typeof data === 'string') {
                cache[camelCase(data)] = value;
            } else {
                for (prop in data) {
                    cache[camelCase(prop)] = data[prop];
                }
            }
            return cache;
        },
        get: function (owner, key) {
            return key === undefined ? this.cache(owner) : owner[this.expando] && owner[this.expando][camelCase(key)];
        },
        access: function (owner, key, value) {
            if (key === undefined || key && typeof key === 'string' && value === undefined) {
                return this.get(owner, key);
            }
            this.set(owner, key, value);
            return value !== undefined ? value : key;
        },
        remove: function (owner, key) {
            var i, cache = owner[this.expando];
            if (cache === undefined) {
                return;
            }
            if (key !== undefined) {
                if (Array.isArray(key)) {
                    key = key.map(camelCase);
                } else {
                    key = camelCase(key);
                    key = key in cache ? [key] : key.match(rnothtmlwhite) || [];
                }
                i = key.length;
                while (i--) {
                    delete cache[key[i]];
                }
            }
            if (key === undefined || jQuery.isEmptyObject(cache)) {
                if (owner.nodeType) {
                    owner[this.expando] = undefined;
                } else {
                    delete owner[this.expando];
                }
            }
        },
        hasData: function (owner) {
            var cache = owner[this.expando];
            return cache !== undefined && !jQuery.isEmptyObject(cache);
        }
    };
    var dataPriv = new Data();
    var dataUser = new Data();
    var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/, rmultiDash = /[A-Z]/g;
    function getData(data) {
        if (data === 'true') {
            return true;
        }
        if (data === 'false') {
            return false;
        }
        if (data === 'null') {
            return null;
        }
        if (data === +data + '') {
            return +data;
        }
        if (rbrace.test(data)) {
            return JSON.parse(data);
        }
        return data;
    }
    function dataAttr(elem, key, data) {
        var name;
        if (data === undefined && elem.nodeType === 1) {
            name = 'data-' + key.replace(rmultiDash, '-$&').toLowerCase();
            data = elem.getAttribute(name);
            if (typeof data === 'string') {
                try {
                    data = getData(data);
                } catch (e) {
                }
                dataUser.set(elem, key, data);
            } else {
                data = undefined;
            }
        }
        return data;
    }
    jQuery.extend({
        hasData: function (elem) {
            return dataUser.hasData(elem) || dataPriv.hasData(elem);
        },
        data: function (elem, name, data) {
            return dataUser.access(elem, name, data);
        },
        removeData: function (elem, name) {
            dataUser.remove(elem, name);
        },
        _data: function (elem, name, data) {
            return dataPriv.access(elem, name, data);
        },
        _removeData: function (elem, name) {
            dataPriv.remove(elem, name);
        }
    });
    jQuery.fn.extend({
        data: function (key, value) {
            var i, name, data, elem = this[0], attrs = elem && elem.attributes;
            if (key === undefined) {
                if (this.length) {
                    data = dataUser.get(elem);
                    if (elem.nodeType === 1 && !dataPriv.get(elem, 'hasDataAttrs')) {
                        i = attrs.length;
                        while (i--) {
                            if (attrs[i]) {
                                name = attrs[i].name;
                                if (name.indexOf('data-') === 0) {
                                    name = camelCase(name.slice(5));
                                    dataAttr(elem, name, data[name]);
                                }
                            }
                        }
                        dataPriv.set(elem, 'hasDataAttrs', true);
                    }
                }
                return data;
            }
            if (typeof key === 'object') {
                return this.each(function () {
                    dataUser.set(this, key);
                });
            }
            return access(this, function (value) {
                var data;
                if (elem && value === undefined) {
                    data = dataUser.get(elem, key);
                    if (data !== undefined) {
                        return data;
                    }
                    data = dataAttr(elem, key);
                    if (data !== undefined) {
                        return data;
                    }
                    return;
                }
                this.each(function () {
                    dataUser.set(this, key, value);
                });
            }, null, value, arguments.length > 1, null, true);
        },
        removeData: function (key) {
            return this.each(function () {
                dataUser.remove(this, key);
            });
        }
    });
    jQuery.extend({
        queue: function (elem, type, data) {
            var queue;
            if (elem) {
                type = (type || 'fx') + 'queue';
                queue = dataPriv.get(elem, type);
                if (data) {
                    if (!queue || Array.isArray(data)) {
                        queue = dataPriv.access(elem, type, jQuery.makeArray(data));
                    } else {
                        queue.push(data);
                    }
                }
                return queue || [];
            }
        },
        dequeue: function (elem, type) {
            type = type || 'fx';
            var queue = jQuery.queue(elem, type), startLength = queue.length, fn = queue.shift(), hooks = jQuery._queueHooks(elem, type), next = function () {
                    jQuery.dequeue(elem, type);
                };
            if (fn === 'inprogress') {
                fn = queue.shift();
                startLength--;
            }
            if (fn) {
                if (type === 'fx') {
                    queue.unshift('inprogress');
                }
                delete hooks.stop;
                fn.call(elem, next, hooks);
            }
            if (!startLength && hooks) {
                hooks.empty.fire();
            }
        },
        _queueHooks: function (elem, type) {
            var key = type + 'queueHooks';
            return dataPriv.get(elem, key) || dataPriv.access(elem, key, {
                empty: jQuery.Callbacks('once memory').add(function () {
                    dataPriv.remove(elem, [
                        type + 'queue',
                        key
                    ]);
                })
            });
        }
    });
    jQuery.fn.extend({
        queue: function (type, data) {
            var setter = 2;
            if (typeof type !== 'string') {
                data = type;
                type = 'fx';
                setter--;
            }
            if (arguments.length < setter) {
                return jQuery.queue(this[0], type);
            }
            return data === undefined ? this : this.each(function () {
                var queue = jQuery.queue(this, type, data);
                jQuery._queueHooks(this, type);
                if (type === 'fx' && queue[0] !== 'inprogress') {
                    jQuery.dequeue(this, type);
                }
            });
        },
        dequeue: function (type) {
            return this.each(function () {
                jQuery.dequeue(this, type);
            });
        },
        clearQueue: function (type) {
            return this.queue(type || 'fx', []);
        },
        promise: function (type, obj) {
            var tmp, count = 1, defer = jQuery.Deferred(), elements = this, i = this.length, resolve = function () {
                    if (!--count) {
                        defer.resolveWith(elements, [elements]);
                    }
                };
            if (typeof type !== 'string') {
                obj = type;
                type = undefined;
            }
            type = type || 'fx';
            while (i--) {
                tmp = dataPriv.get(elements[i], type + 'queueHooks');
                if (tmp && tmp.empty) {
                    count++;
                    tmp.empty.add(resolve);
                }
            }
            resolve();
            return defer.promise(obj);
        }
    });
    var pnum = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source;
    var rcssNum = new RegExp('^(?:([+-])=|)(' + pnum + ')([a-z%]*)$', 'i');
    var cssExpand = [
        'Top',
        'Right',
        'Bottom',
        'Left'
    ];
    var isHiddenWithinTree = function (elem, el) {
        elem = el || elem;
        return elem.style.display === 'none' || elem.style.display === '' && jQuery.contains(elem.ownerDocument, elem) && jQuery.css(elem, 'display') === 'none';
    };
    var swap = function (elem, options, callback, args) {
        var ret, name, old = {};
        for (name in options) {
            old[name] = elem.style[name];
            elem.style[name] = options[name];
        }
        ret = callback.apply(elem, args || []);
        for (name in options) {
            elem.style[name] = old[name];
        }
        return ret;
    };
    function adjustCSS(elem, prop, valueParts, tween) {
        var adjusted, scale, maxIterations = 20, currentValue = tween ? function () {
                return tween.cur();
            } : function () {
                return jQuery.css(elem, prop, '');
            }, initial = currentValue(), unit = valueParts && valueParts[3] || (jQuery.cssNumber[prop] ? '' : 'px'), initialInUnit = (jQuery.cssNumber[prop] || unit !== 'px' && +initial) && rcssNum.exec(jQuery.css(elem, prop));
        if (initialInUnit && initialInUnit[3] !== unit) {
            initial = initial / 2;
            unit = unit || initialInUnit[3];
            initialInUnit = +initial || 1;
            while (maxIterations--) {
                jQuery.style(elem, prop, initialInUnit + unit);
                if ((1 - scale) * (1 - (scale = currentValue() / initial || 0.5)) <= 0) {
                    maxIterations = 0;
                }
                initialInUnit = initialInUnit / scale;
            }
            initialInUnit = initialInUnit * 2;
            jQuery.style(elem, prop, initialInUnit + unit);
            valueParts = valueParts || [];
        }
        if (valueParts) {
            initialInUnit = +initialInUnit || +initial || 0;
            adjusted = valueParts[1] ? initialInUnit + (valueParts[1] + 1) * valueParts[2] : +valueParts[2];
            if (tween) {
                tween.unit = unit;
                tween.start = initialInUnit;
                tween.end = adjusted;
            }
        }
        return adjusted;
    }
    var defaultDisplayMap = {};
    function getDefaultDisplay(elem) {
        var temp, doc = elem.ownerDocument, nodeName = elem.nodeName, display = defaultDisplayMap[nodeName];
        if (display) {
            return display;
        }
        temp = doc.body.appendChild(doc.createElement(nodeName));
        display = jQuery.css(temp, 'display');
        temp.parentNode.removeChild(temp);
        if (display === 'none') {
            display = 'block';
        }
        defaultDisplayMap[nodeName] = display;
        return display;
    }
    function showHide(elements, show) {
        var display, elem, values = [], index = 0, length = elements.length;
        for (; index < length; index++) {
            elem = elements[index];
            if (!elem.style) {
                continue;
            }
            display = elem.style.display;
            if (show) {
                if (display === 'none') {
                    values[index] = dataPriv.get(elem, 'display') || null;
                    if (!values[index]) {
                        elem.style.display = '';
                    }
                }
                if (elem.style.display === '' && isHiddenWithinTree(elem)) {
                    values[index] = getDefaultDisplay(elem);
                }
            } else {
                if (display !== 'none') {
                    values[index] = 'none';
                    dataPriv.set(elem, 'display', display);
                }
            }
        }
        for (index = 0; index < length; index++) {
            if (values[index] != null) {
                elements[index].style.display = values[index];
            }
        }
        return elements;
    }
    jQuery.fn.extend({
        show: function () {
            return showHide(this, true);
        },
        hide: function () {
            return showHide(this);
        },
        toggle: function (state) {
            if (typeof state === 'boolean') {
                return state ? this.show() : this.hide();
            }
            return this.each(function () {
                if (isHiddenWithinTree(this)) {
                    jQuery(this).show();
                } else {
                    jQuery(this).hide();
                }
            });
        }
    });
    var rcheckableType = /^(?:checkbox|radio)$/i;
    var rtagName = /<([a-z][^\/\0>\x20\t\r\n\f]+)/i;
    var rscriptType = /^$|^module$|\/(?:java|ecma)script/i;
    var wrapMap = {
        option: [
            1,
            '<select multiple=\'multiple\'>',
            '</select>'
        ],
        thead: [
            1,
            '<table>',
            '</table>'
        ],
        col: [
            2,
            '<table><colgroup>',
            '</colgroup></table>'
        ],
        tr: [
            2,
            '<table><tbody>',
            '</tbody></table>'
        ],
        td: [
            3,
            '<table><tbody><tr>',
            '</tr></tbody></table>'
        ],
        _default: [
            0,
            '',
            ''
        ]
    };
    wrapMap.optgroup = wrapMap.option;
    wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
    wrapMap.th = wrapMap.td;
    function getAll(context, tag) {
        var ret;
        if (typeof context.getElementsByTagName !== 'undefined') {
            ret = context.getElementsByTagName(tag || '*');
        } else if (typeof context.querySelectorAll !== 'undefined') {
            ret = context.querySelectorAll(tag || '*');
        } else {
            ret = [];
        }
        if (tag === undefined || tag && nodeName(context, tag)) {
            return jQuery.merge([context], ret);
        }
        return ret;
    }
    function setGlobalEval(elems, refElements) {
        var i = 0, l = elems.length;
        for (; i < l; i++) {
            dataPriv.set(elems[i], 'globalEval', !refElements || dataPriv.get(refElements[i], 'globalEval'));
        }
    }
    var rhtml = /<|&#?\w+;/;
    function buildFragment(elems, context, scripts, selection, ignored) {
        var elem, tmp, tag, wrap, contains, j, fragment = context.createDocumentFragment(), nodes = [], i = 0, l = elems.length;
        for (; i < l; i++) {
            elem = elems[i];
            if (elem || elem === 0) {
                if (toType(elem) === 'object') {
                    jQuery.merge(nodes, elem.nodeType ? [elem] : elem);
                } else if (!rhtml.test(elem)) {
                    nodes.push(context.createTextNode(elem));
                } else {
                    tmp = tmp || fragment.appendChild(context.createElement('div'));
                    tag = (rtagName.exec(elem) || [
                        '',
                        ''
                    ])[1].toLowerCase();
                    wrap = wrapMap[tag] || wrapMap._default;
                    tmp.innerHTML = wrap[1] + jQuery.htmlPrefilter(elem) + wrap[2];
                    j = wrap[0];
                    while (j--) {
                        tmp = tmp.lastChild;
                    }
                    jQuery.merge(nodes, tmp.childNodes);
                    tmp = fragment.firstChild;
                    tmp.textContent = '';
                }
            }
        }
        fragment.textContent = '';
        i = 0;
        while (elem = nodes[i++]) {
            if (selection && jQuery.inArray(elem, selection) > -1) {
                if (ignored) {
                    ignored.push(elem);
                }
                continue;
            }
            contains = jQuery.contains(elem.ownerDocument, elem);
            tmp = getAll(fragment.appendChild(elem), 'script');
            if (contains) {
                setGlobalEval(tmp);
            }
            if (scripts) {
                j = 0;
                while (elem = tmp[j++]) {
                    if (rscriptType.test(elem.type || '')) {
                        scripts.push(elem);
                    }
                }
            }
        }
        return fragment;
    }
    (function () {
        var fragment = document.createDocumentFragment(), div = fragment.appendChild(document.createElement('div')), input = document.createElement('input');
        input.setAttribute('type', 'radio');
        input.setAttribute('checked', 'checked');
        input.setAttribute('name', 't');
        div.appendChild(input);
        support.checkClone = div.cloneNode(true).cloneNode(true).lastChild.checked;
        div.innerHTML = '<textarea>x</textarea>';
        support.noCloneChecked = !!div.cloneNode(true).lastChild.defaultValue;
    }());
    var documentElement = document.documentElement;
    var rkeyEvent = /^key/, rmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/, rtypenamespace = /^([^.]*)(?:\.(.+)|)/;
    function returnTrue() {
        return true;
    }
    function returnFalse() {
        return false;
    }
    function safeActiveElement() {
        try {
            return document.activeElement;
        } catch (err) {
        }
    }
    function on(elem, types, selector, data, fn, one) {
        var origFn, type;
        if (typeof types === 'object') {
            if (typeof selector !== 'string') {
                data = data || selector;
                selector = undefined;
            }
            for (type in types) {
                on(elem, type, selector, data, types[type], one);
            }
            return elem;
        }
        if (data == null && fn == null) {
            fn = selector;
            data = selector = undefined;
        } else if (fn == null) {
            if (typeof selector === 'string') {
                fn = data;
                data = undefined;
            } else {
                fn = data;
                data = selector;
                selector = undefined;
            }
        }
        if (fn === false) {
            fn = returnFalse;
        } else if (!fn) {
            return elem;
        }
        if (one === 1) {
            origFn = fn;
            fn = function (event) {
                jQuery().off(event);
                return origFn.apply(this, arguments);
            };
            fn.guid = origFn.guid || (origFn.guid = jQuery.guid++);
        }
        return elem.each(function () {
            jQuery.event.add(this, types, fn, data, selector);
        });
    }
    jQuery.event = {
        global: {},
        add: function (elem, types, handler, data, selector) {
            var handleObjIn, eventHandle, tmp, events, t, handleObj, special, handlers, type, namespaces, origType, elemData = dataPriv.get(elem);
            if (!elemData) {
                return;
            }
            if (handler.handler) {
                handleObjIn = handler;
                handler = handleObjIn.handler;
                selector = handleObjIn.selector;
            }
            if (selector) {
                jQuery.find.matchesSelector(documentElement, selector);
            }
            if (!handler.guid) {
                handler.guid = jQuery.guid++;
            }
            if (!(events = elemData.events)) {
                events = elemData.events = {};
            }
            if (!(eventHandle = elemData.handle)) {
                eventHandle = elemData.handle = function (e) {
                    return typeof jQuery !== 'undefined' && jQuery.event.triggered !== e.type ? jQuery.event.dispatch.apply(elem, arguments) : undefined;
                };
            }
            types = (types || '').match(rnothtmlwhite) || [''];
            t = types.length;
            while (t--) {
                tmp = rtypenamespace.exec(types[t]) || [];
                type = origType = tmp[1];
                namespaces = (tmp[2] || '').split('.').sort();
                if (!type) {
                    continue;
                }
                special = jQuery.event.special[type] || {};
                type = (selector ? special.delegateType : special.bindType) || type;
                special = jQuery.event.special[type] || {};
                handleObj = jQuery.extend({
                    type: type,
                    origType: origType,
                    data: data,
                    handler: handler,
                    guid: handler.guid,
                    selector: selector,
                    needsContext: selector && jQuery.expr.match.needsContext.test(selector),
                    namespace: namespaces.join('.')
                }, handleObjIn);
                if (!(handlers = events[type])) {
                    handlers = events[type] = [];
                    handlers.delegateCount = 0;
                    if (!special.setup || special.setup.call(elem, data, namespaces, eventHandle) === false) {
                        if (elem.addEventListener) {
                            elem.addEventListener(type, eventHandle);
                        }
                    }
                }
                if (special.add) {
                    special.add.call(elem, handleObj);
                    if (!handleObj.handler.guid) {
                        handleObj.handler.guid = handler.guid;
                    }
                }
                if (selector) {
                    handlers.splice(handlers.delegateCount++, 0, handleObj);
                } else {
                    handlers.push(handleObj);
                }
                jQuery.event.global[type] = true;
            }
        },
        remove: function (elem, types, handler, selector, mappedTypes) {
            var j, origCount, tmp, events, t, handleObj, special, handlers, type, namespaces, origType, elemData = dataPriv.hasData(elem) && dataPriv.get(elem);
            if (!elemData || !(events = elemData.events)) {
                return;
            }
            types = (types || '').match(rnothtmlwhite) || [''];
            t = types.length;
            while (t--) {
                tmp = rtypenamespace.exec(types[t]) || [];
                type = origType = tmp[1];
                namespaces = (tmp[2] || '').split('.').sort();
                if (!type) {
                    for (type in events) {
                        jQuery.event.remove(elem, type + types[t], handler, selector, true);
                    }
                    continue;
                }
                special = jQuery.event.special[type] || {};
                type = (selector ? special.delegateType : special.bindType) || type;
                handlers = events[type] || [];
                tmp = tmp[2] && new RegExp('(^|\\.)' + namespaces.join('\\.(?:.*\\.|)') + '(\\.|$)');
                origCount = j = handlers.length;
                while (j--) {
                    handleObj = handlers[j];
                    if ((mappedTypes || origType === handleObj.origType) && (!handler || handler.guid === handleObj.guid) && (!tmp || tmp.test(handleObj.namespace)) && (!selector || selector === handleObj.selector || selector === '**' && handleObj.selector)) {
                        handlers.splice(j, 1);
                        if (handleObj.selector) {
                            handlers.delegateCount--;
                        }
                        if (special.remove) {
                            special.remove.call(elem, handleObj);
                        }
                    }
                }
                if (origCount && !handlers.length) {
                    if (!special.teardown || special.teardown.call(elem, namespaces, elemData.handle) === false) {
                        jQuery.removeEvent(elem, type, elemData.handle);
                    }
                    delete events[type];
                }
            }
            if (jQuery.isEmptyObject(events)) {
                dataPriv.remove(elem, 'handle events');
            }
        },
        dispatch: function (nativeEvent) {
            var event = jQuery.event.fix(nativeEvent);
            var i, j, ret, matched, handleObj, handlerQueue, args = new Array(arguments.length), handlers = (dataPriv.get(this, 'events') || {})[event.type] || [], special = jQuery.event.special[event.type] || {};
            args[0] = event;
            for (i = 1; i < arguments.length; i++) {
                args[i] = arguments[i];
            }
            event.delegateTarget = this;
            if (special.preDispatch && special.preDispatch.call(this, event) === false) {
                return;
            }
            handlerQueue = jQuery.event.handlers.call(this, event, handlers);
            i = 0;
            while ((matched = handlerQueue[i++]) && !event.isPropagationStopped()) {
                event.currentTarget = matched.elem;
                j = 0;
                while ((handleObj = matched.handlers[j++]) && !event.isImmediatePropagationStopped()) {
                    if (!event.rnamespace || event.rnamespace.test(handleObj.namespace)) {
                        event.handleObj = handleObj;
                        event.data = handleObj.data;
                        ret = ((jQuery.event.special[handleObj.origType] || {}).handle || handleObj.handler).apply(matched.elem, args);
                        if (ret !== undefined) {
                            if ((event.result = ret) === false) {
                                event.preventDefault();
                                event.stopPropagation();
                            }
                        }
                    }
                }
            }
            if (special.postDispatch) {
                special.postDispatch.call(this, event);
            }
            return event.result;
        },
        handlers: function (event, handlers) {
            var i, handleObj, sel, matchedHandlers, matchedSelectors, handlerQueue = [], delegateCount = handlers.delegateCount, cur = event.target;
            if (delegateCount && cur.nodeType && !(event.type === 'click' && event.button >= 1)) {
                for (; cur !== this; cur = cur.parentNode || this) {
                    if (cur.nodeType === 1 && !(event.type === 'click' && cur.disabled === true)) {
                        matchedHandlers = [];
                        matchedSelectors = {};
                        for (i = 0; i < delegateCount; i++) {
                            handleObj = handlers[i];
                            sel = handleObj.selector + ' ';
                            if (matchedSelectors[sel] === undefined) {
                                matchedSelectors[sel] = handleObj.needsContext ? jQuery(sel, this).index(cur) > -1 : jQuery.find(sel, this, null, [cur]).length;
                            }
                            if (matchedSelectors[sel]) {
                                matchedHandlers.push(handleObj);
                            }
                        }
                        if (matchedHandlers.length) {
                            handlerQueue.push({
                                elem: cur,
                                handlers: matchedHandlers
                            });
                        }
                    }
                }
            }
            cur = this;
            if (delegateCount < handlers.length) {
                handlerQueue.push({
                    elem: cur,
                    handlers: handlers.slice(delegateCount)
                });
            }
            return handlerQueue;
        },
        addProp: function (name, hook) {
            Object.defineProperty(jQuery.Event.prototype, name, {
                enumerable: true,
                configurable: true,
                get: isFunction(hook) ? function () {
                    if (this.originalEvent) {
                        return hook(this.originalEvent);
                    }
                } : function () {
                    if (this.originalEvent) {
                        return this.originalEvent[name];
                    }
                },
                set: function (value) {
                    Object.defineProperty(this, name, {
                        enumerable: true,
                        configurable: true,
                        writable: true,
                        value: value
                    });
                }
            });
        },
        fix: function (originalEvent) {
            return originalEvent[jQuery.expando] ? originalEvent : new jQuery.Event(originalEvent);
        },
        special: {
            load: { noBubble: true },
            focus: {
                trigger: function () {
                    if (this !== safeActiveElement() && this.focus) {
                        this.focus();
                        return false;
                    }
                },
                delegateType: 'focusin'
            },
            blur: {
                trigger: function () {
                    if (this === safeActiveElement() && this.blur) {
                        this.blur();
                        return false;
                    }
                },
                delegateType: 'focusout'
            },
            click: {
                trigger: function () {
                    if (this.type === 'checkbox' && this.click && nodeName(this, 'input')) {
                        this.click();
                        return false;
                    }
                },
                _default: function (event) {
                    return nodeName(event.target, 'a');
                }
            },
            beforeunload: {
                postDispatch: function (event) {
                    if (event.result !== undefined && event.originalEvent) {
                        event.originalEvent.returnValue = event.result;
                    }
                }
            }
        }
    };
    jQuery.removeEvent = function (elem, type, handle) {
        if (elem.removeEventListener) {
            elem.removeEventListener(type, handle);
        }
    };
    jQuery.Event = function (src, props) {
        if (!(this instanceof jQuery.Event)) {
            return new jQuery.Event(src, props);
        }
        if (src && src.type) {
            this.originalEvent = src;
            this.type = src.type;
            this.isDefaultPrevented = src.defaultPrevented || src.defaultPrevented === undefined && src.returnValue === false ? returnTrue : returnFalse;
            this.target = src.target && src.target.nodeType === 3 ? src.target.parentNode : src.target;
            this.currentTarget = src.currentTarget;
            this.relatedTarget = src.relatedTarget;
        } else {
            this.type = src;
        }
        if (props) {
            jQuery.extend(this, props);
        }
        this.timeStamp = src && src.timeStamp || Date.now();
        this[jQuery.expando] = true;
    };
    jQuery.Event.prototype = {
        constructor: jQuery.Event,
        isDefaultPrevented: returnFalse,
        isPropagationStopped: returnFalse,
        isImmediatePropagationStopped: returnFalse,
        isSimulated: false,
        preventDefault: function () {
            var e = this.originalEvent;
            this.isDefaultPrevented = returnTrue;
            if (e && !this.isSimulated) {
                e.preventDefault();
            }
        },
        stopPropagation: function () {
            var e = this.originalEvent;
            this.isPropagationStopped = returnTrue;
            if (e && !this.isSimulated) {
                e.stopPropagation();
            }
        },
        stopImmediatePropagation: function () {
            var e = this.originalEvent;
            this.isImmediatePropagationStopped = returnTrue;
            if (e && !this.isSimulated) {
                e.stopImmediatePropagation();
            }
            this.stopPropagation();
        }
    };
    jQuery.each({
        altKey: true,
        bubbles: true,
        cancelable: true,
        changedTouches: true,
        ctrlKey: true,
        detail: true,
        eventPhase: true,
        metaKey: true,
        pageX: true,
        pageY: true,
        shiftKey: true,
        view: true,
        'char': true,
        charCode: true,
        key: true,
        keyCode: true,
        button: true,
        buttons: true,
        clientX: true,
        clientY: true,
        offsetX: true,
        offsetY: true,
        pointerId: true,
        pointerType: true,
        screenX: true,
        screenY: true,
        targetTouches: true,
        toElement: true,
        touches: true,
        which: function (event) {
            var button = event.button;
            if (event.which == null && rkeyEvent.test(event.type)) {
                return event.charCode != null ? event.charCode : event.keyCode;
            }
            if (!event.which && button !== undefined && rmouseEvent.test(event.type)) {
                if (button & 1) {
                    return 1;
                }
                if (button & 2) {
                    return 3;
                }
                if (button & 4) {
                    return 2;
                }
                return 0;
            }
            return event.which;
        }
    }, jQuery.event.addProp);
    jQuery.each({
        mouseenter: 'mouseover',
        mouseleave: 'mouseout',
        pointerenter: 'pointerover',
        pointerleave: 'pointerout'
    }, function (orig, fix) {
        jQuery.event.special[orig] = {
            delegateType: fix,
            bindType: fix,
            handle: function (event) {
                var ret, target = this, related = event.relatedTarget, handleObj = event.handleObj;
                if (!related || related !== target && !jQuery.contains(target, related)) {
                    event.type = handleObj.origType;
                    ret = handleObj.handler.apply(this, arguments);
                    event.type = fix;
                }
                return ret;
            }
        };
    });
    jQuery.fn.extend({
        on: function (types, selector, data, fn) {
            return on(this, types, selector, data, fn);
        },
        one: function (types, selector, data, fn) {
            return on(this, types, selector, data, fn, 1);
        },
        off: function (types, selector, fn) {
            var handleObj, type;
            if (types && types.preventDefault && types.handleObj) {
                handleObj = types.handleObj;
                jQuery(types.delegateTarget).off(handleObj.namespace ? handleObj.origType + '.' + handleObj.namespace : handleObj.origType, handleObj.selector, handleObj.handler);
                return this;
            }
            if (typeof types === 'object') {
                for (type in types) {
                    this.off(type, selector, types[type]);
                }
                return this;
            }
            if (selector === false || typeof selector === 'function') {
                fn = selector;
                selector = undefined;
            }
            if (fn === false) {
                fn = returnFalse;
            }
            return this.each(function () {
                jQuery.event.remove(this, types, fn, selector);
            });
        }
    });
    var rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\/\0>\x20\t\r\n\f]*)[^>]*)\/>/gi, rnoInnerhtml = /<script|<style|<link/i, rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i, rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;
    function manipulationTarget(elem, content) {
        if (nodeName(elem, 'table') && nodeName(content.nodeType !== 11 ? content : content.firstChild, 'tr')) {
            return jQuery(elem).children('tbody')[0] || elem;
        }
        return elem;
    }
    function disableScript(elem) {
        elem.type = (elem.getAttribute('type') !== null) + '/' + elem.type;
        return elem;
    }
    function restoreScript(elem) {
        if ((elem.type || '').slice(0, 5) === 'true/') {
            elem.type = elem.type.slice(5);
        } else {
            elem.removeAttribute('type');
        }
        return elem;
    }
    function cloneCopyEvent(src, dest) {
        var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;
        if (dest.nodeType !== 1) {
            return;
        }
        if (dataPriv.hasData(src)) {
            pdataOld = dataPriv.access(src);
            pdataCur = dataPriv.set(dest, pdataOld);
            events = pdataOld.events;
            if (events) {
                delete pdataCur.handle;
                pdataCur.events = {};
                for (type in events) {
                    for (i = 0, l = events[type].length; i < l; i++) {
                        jQuery.event.add(dest, type, events[type][i]);
                    }
                }
            }
        }
        if (dataUser.hasData(src)) {
            udataOld = dataUser.access(src);
            udataCur = jQuery.extend({}, udataOld);
            dataUser.set(dest, udataCur);
        }
    }
    function fixInput(src, dest) {
        var nodeName = dest.nodeName.toLowerCase();
        if (nodeName === 'input' && rcheckableType.test(src.type)) {
            dest.checked = src.checked;
        } else if (nodeName === 'input' || nodeName === 'textarea') {
            dest.defaultValue = src.defaultValue;
        }
    }
    function domManip(collection, args, callback, ignored) {
        args = concat.apply([], args);
        var fragment, first, scripts, hasScripts, node, doc, i = 0, l = collection.length, iNoClone = l - 1, value = args[0], valueIsFunction = isFunction(value);
        if (valueIsFunction || l > 1 && typeof value === 'string' && !support.checkClone && rchecked.test(value)) {
            return collection.each(function (index) {
                var self = collection.eq(index);
                if (valueIsFunction) {
                    args[0] = value.call(this, index, self.html());
                }
                domManip(self, args, callback, ignored);
            });
        }
        if (l) {
            fragment = buildFragment(args, collection[0].ownerDocument, false, collection, ignored);
            first = fragment.firstChild;
            if (fragment.childNodes.length === 1) {
                fragment = first;
            }
            if (first || ignored) {
                scripts = jQuery.map(getAll(fragment, 'script'), disableScript);
                hasScripts = scripts.length;
                for (; i < l; i++) {
                    node = fragment;
                    if (i !== iNoClone) {
                        node = jQuery.clone(node, true, true);
                        if (hasScripts) {
                            jQuery.merge(scripts, getAll(node, 'script'));
                        }
                    }
                    callback.call(collection[i], node, i);
                }
                if (hasScripts) {
                    doc = scripts[scripts.length - 1].ownerDocument;
                    jQuery.map(scripts, restoreScript);
                    for (i = 0; i < hasScripts; i++) {
                        node = scripts[i];
                        if (rscriptType.test(node.type || '') && !dataPriv.access(node, 'globalEval') && jQuery.contains(doc, node)) {
                            if (node.src && (node.type || '').toLowerCase() !== 'module') {
                                if (jQuery._evalUrl) {
                                    jQuery._evalUrl(node.src);
                                }
                            } else {
                                DOMEval(node.textContent.replace(rcleanScript, ''), doc, node);
                            }
                        }
                    }
                }
            }
        }
        return collection;
    }
    function remove(elem, selector, keepData) {
        var node, nodes = selector ? jQuery.filter(selector, elem) : elem, i = 0;
        for (; (node = nodes[i]) != null; i++) {
            if (!keepData && node.nodeType === 1) {
                jQuery.cleanData(getAll(node));
            }
            if (node.parentNode) {
                if (keepData && jQuery.contains(node.ownerDocument, node)) {
                    setGlobalEval(getAll(node, 'script'));
                }
                node.parentNode.removeChild(node);
            }
        }
        return elem;
    }
    jQuery.extend({
        htmlPrefilter: function (html) {
            return html.replace(rxhtmlTag, '<$1></$2>');
        },
        clone: function (elem, dataAndEvents, deepDataAndEvents) {
            var i, l, srcElements, destElements, clone = elem.cloneNode(true), inPage = jQuery.contains(elem.ownerDocument, elem);
            if (!support.noCloneChecked && (elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem)) {
                destElements = getAll(clone);
                srcElements = getAll(elem);
                for (i = 0, l = srcElements.length; i < l; i++) {
                    fixInput(srcElements[i], destElements[i]);
                }
            }
            if (dataAndEvents) {
                if (deepDataAndEvents) {
                    srcElements = srcElements || getAll(elem);
                    destElements = destElements || getAll(clone);
                    for (i = 0, l = srcElements.length; i < l; i++) {
                        cloneCopyEvent(srcElements[i], destElements[i]);
                    }
                } else {
                    cloneCopyEvent(elem, clone);
                }
            }
            destElements = getAll(clone, 'script');
            if (destElements.length > 0) {
                setGlobalEval(destElements, !inPage && getAll(elem, 'script'));
            }
            return clone;
        },
        cleanData: function (elems) {
            var data, elem, type, special = jQuery.event.special, i = 0;
            for (; (elem = elems[i]) !== undefined; i++) {
                if (acceptData(elem)) {
                    if (data = elem[dataPriv.expando]) {
                        if (data.events) {
                            for (type in data.events) {
                                if (special[type]) {
                                    jQuery.event.remove(elem, type);
                                } else {
                                    jQuery.removeEvent(elem, type, data.handle);
                                }
                            }
                        }
                        elem[dataPriv.expando] = undefined;
                    }
                    if (elem[dataUser.expando]) {
                        elem[dataUser.expando] = undefined;
                    }
                }
            }
        }
    });
    jQuery.fn.extend({
        detach: function (selector) {
            return remove(this, selector, true);
        },
        remove: function (selector) {
            return remove(this, selector);
        },
        text: function (value) {
            return access(this, function (value) {
                return value === undefined ? jQuery.text(this) : this.empty().each(function () {
                    if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
                        this.textContent = value;
                    }
                });
            }, null, value, arguments.length);
        },
        append: function () {
            return domManip(this, arguments, function (elem) {
                if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
                    var target = manipulationTarget(this, elem);
                    target.appendChild(elem);
                }
            });
        },
        prepend: function () {
            return domManip(this, arguments, function (elem) {
                if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
                    var target = manipulationTarget(this, elem);
                    target.insertBefore(elem, target.firstChild);
                }
            });
        },
        before: function () {
            return domManip(this, arguments, function (elem) {
                if (this.parentNode) {
                    this.parentNode.insertBefore(elem, this);
                }
            });
        },
        after: function () {
            return domManip(this, arguments, function (elem) {
                if (this.parentNode) {
                    this.parentNode.insertBefore(elem, this.nextSibling);
                }
            });
        },
        empty: function () {
            var elem, i = 0;
            for (; (elem = this[i]) != null; i++) {
                if (elem.nodeType === 1) {
                    jQuery.cleanData(getAll(elem, false));
                    elem.textContent = '';
                }
            }
            return this;
        },
        clone: function (dataAndEvents, deepDataAndEvents) {
            dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
            deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;
            return this.map(function () {
                return jQuery.clone(this, dataAndEvents, deepDataAndEvents);
            });
        },
        html: function (value) {
            return access(this, function (value) {
                var elem = this[0] || {}, i = 0, l = this.length;
                if (value === undefined && elem.nodeType === 1) {
                    return elem.innerHTML;
                }
                if (typeof value === 'string' && !rnoInnerhtml.test(value) && !wrapMap[(rtagName.exec(value) || [
                        '',
                        ''
                    ])[1].toLowerCase()]) {
                    value = jQuery.htmlPrefilter(value);
                    try {
                        for (; i < l; i++) {
                            elem = this[i] || {};
                            if (elem.nodeType === 1) {
                                jQuery.cleanData(getAll(elem, false));
                                elem.innerHTML = value;
                            }
                        }
                        elem = 0;
                    } catch (e) {
                    }
                }
                if (elem) {
                    this.empty().append(value);
                }
            }, null, value, arguments.length);
        },
        replaceWith: function () {
            var ignored = [];
            return domManip(this, arguments, function (elem) {
                var parent = this.parentNode;
                if (jQuery.inArray(this, ignored) < 0) {
                    jQuery.cleanData(getAll(this));
                    if (parent) {
                        parent.replaceChild(elem, this);
                    }
                }
            }, ignored);
        }
    });
    jQuery.each({
        appendTo: 'append',
        prependTo: 'prepend',
        insertBefore: 'before',
        insertAfter: 'after',
        replaceAll: 'replaceWith'
    }, function (name, original) {
        jQuery.fn[name] = function (selector) {
            var elems, ret = [], insert = jQuery(selector), last = insert.length - 1, i = 0;
            for (; i <= last; i++) {
                elems = i === last ? this : this.clone(true);
                jQuery(insert[i])[original](elems);
                push.apply(ret, elems.get());
            }
            return this.pushStack(ret);
        };
    });
    var rnumnonpx = new RegExp('^(' + pnum + ')(?!px)[a-z%]+$', 'i');
    var getStyles = function (elem) {
        var view = elem.ownerDocument.defaultView;
        if (!view || !view.opener) {
            view = window;
        }
        return view.getComputedStyle(elem);
    };
    var rboxStyle = new RegExp(cssExpand.join('|'), 'i');
    (function () {
        function computeStyleTests() {
            if (!div) {
                return;
            }
            container.style.cssText = 'position:absolute;left:-11111px;width:60px;' + 'margin-top:1px;padding:0;border:0';
            div.style.cssText = 'position:relative;display:block;box-sizing:border-box;overflow:scroll;' + 'margin:auto;border:1px;padding:1px;' + 'width:60%;top:1%';
            documentElement.appendChild(container).appendChild(div);
            var divStyle = window.getComputedStyle(div);
            pixelPositionVal = divStyle.top !== '1%';
            reliableMarginLeftVal = roundPixelMeasures(divStyle.marginLeft) === 12;
            div.style.right = '60%';
            pixelBoxStylesVal = roundPixelMeasures(divStyle.right) === 36;
            boxSizingReliableVal = roundPixelMeasures(divStyle.width) === 36;
            div.style.position = 'absolute';
            scrollboxSizeVal = div.offsetWidth === 36 || 'absolute';
            documentElement.removeChild(container);
            div = null;
        }
        function roundPixelMeasures(measure) {
            return Math.round(parseFloat(measure));
        }
        var pixelPositionVal, boxSizingReliableVal, scrollboxSizeVal, pixelBoxStylesVal, reliableMarginLeftVal, container = document.createElement('div'), div = document.createElement('div');
        if (!div.style) {
            return;
        }
        div.style.backgroundClip = 'content-box';
        div.cloneNode(true).style.backgroundClip = '';
        support.clearCloneStyle = div.style.backgroundClip === 'content-box';
        jQuery.extend(support, {
            boxSizingReliable: function () {
                computeStyleTests();
                return boxSizingReliableVal;
            },
            pixelBoxStyles: function () {
                computeStyleTests();
                return pixelBoxStylesVal;
            },
            pixelPosition: function () {
                computeStyleTests();
                return pixelPositionVal;
            },
            reliableMarginLeft: function () {
                computeStyleTests();
                return reliableMarginLeftVal;
            },
            scrollboxSize: function () {
                computeStyleTests();
                return scrollboxSizeVal;
            }
        });
    }());
    function curCSS(elem, name, computed) {
        var width, minWidth, maxWidth, ret, style = elem.style;
        computed = computed || getStyles(elem);
        if (computed) {
            ret = computed.getPropertyValue(name) || computed[name];
            if (ret === '' && !jQuery.contains(elem.ownerDocument, elem)) {
                ret = jQuery.style(elem, name);
            }
            if (!support.pixelBoxStyles() && rnumnonpx.test(ret) && rboxStyle.test(name)) {
                width = style.width;
                minWidth = style.minWidth;
                maxWidth = style.maxWidth;
                style.minWidth = style.maxWidth = style.width = ret;
                ret = computed.width;
                style.width = width;
                style.minWidth = minWidth;
                style.maxWidth = maxWidth;
            }
        }
        return ret !== undefined ? ret + '' : ret;
    }
    function addGetHookIf(conditionFn, hookFn) {
        return {
            get: function () {
                if (conditionFn()) {
                    delete this.get;
                    return;
                }
                return (this.get = hookFn).apply(this, arguments);
            }
        };
    }
    var rdisplayswap = /^(none|table(?!-c[ea]).+)/, rcustomProp = /^--/, cssShow = {
            position: 'absolute',
            visibility: 'hidden',
            display: 'block'
        }, cssNormalTransform = {
            letterSpacing: '0',
            fontWeight: '400'
        }, cssPrefixes = [
            'Webkit',
            'Moz',
            'ms'
        ], emptyStyle = document.createElement('div').style;
    function vendorPropName(name) {
        if (name in emptyStyle) {
            return name;
        }
        var capName = name[0].toUpperCase() + name.slice(1), i = cssPrefixes.length;
        while (i--) {
            name = cssPrefixes[i] + capName;
            if (name in emptyStyle) {
                return name;
            }
        }
    }
    function finalPropName(name) {
        var ret = jQuery.cssProps[name];
        if (!ret) {
            ret = jQuery.cssProps[name] = vendorPropName(name) || name;
        }
        return ret;
    }
    function setPositiveNumber(elem, value, subtract) {
        var matches = rcssNum.exec(value);
        return matches ? Math.max(0, matches[2] - (subtract || 0)) + (matches[3] || 'px') : value;
    }
    function boxModelAdjustment(elem, dimension, box, isBorderBox, styles, computedVal) {
        var i = dimension === 'width' ? 1 : 0, extra = 0, delta = 0;
        if (box === (isBorderBox ? 'border' : 'content')) {
            return 0;
        }
        for (; i < 4; i += 2) {
            if (box === 'margin') {
                delta += jQuery.css(elem, box + cssExpand[i], true, styles);
            }
            if (!isBorderBox) {
                delta += jQuery.css(elem, 'padding' + cssExpand[i], true, styles);
                if (box !== 'padding') {
                    delta += jQuery.css(elem, 'border' + cssExpand[i] + 'Width', true, styles);
                } else {
                    extra += jQuery.css(elem, 'border' + cssExpand[i] + 'Width', true, styles);
                }
            } else {
                if (box === 'content') {
                    delta -= jQuery.css(elem, 'padding' + cssExpand[i], true, styles);
                }
                if (box !== 'margin') {
                    delta -= jQuery.css(elem, 'border' + cssExpand[i] + 'Width', true, styles);
                }
            }
        }
        if (!isBorderBox && computedVal >= 0) {
            delta += Math.max(0, Math.ceil(elem['offset' + dimension[0].toUpperCase() + dimension.slice(1)] - computedVal - delta - extra - 0.5));
        }
        return delta;
    }
    function getWidthOrHeight(elem, dimension, extra) {
        var styles = getStyles(elem), val = curCSS(elem, dimension, styles), isBorderBox = jQuery.css(elem, 'boxSizing', false, styles) === 'border-box', valueIsBorderBox = isBorderBox;
        if (rnumnonpx.test(val)) {
            if (!extra) {
                return val;
            }
            val = 'auto';
        }
        valueIsBorderBox = valueIsBorderBox && (support.boxSizingReliable() || val === elem.style[dimension]);
        if (val === 'auto' || !parseFloat(val) && jQuery.css(elem, 'display', false, styles) === 'inline') {
            val = elem['offset' + dimension[0].toUpperCase() + dimension.slice(1)];
            valueIsBorderBox = true;
        }
        val = parseFloat(val) || 0;
        return val + boxModelAdjustment(elem, dimension, extra || (isBorderBox ? 'border' : 'content'), valueIsBorderBox, styles, val) + 'px';
    }
    jQuery.extend({
        cssHooks: {
            opacity: {
                get: function (elem, computed) {
                    if (computed) {
                        var ret = curCSS(elem, 'opacity');
                        return ret === '' ? '1' : ret;
                    }
                }
            }
        },
        cssNumber: {
            'animationIterationCount': true,
            'columnCount': true,
            'fillOpacity': true,
            'flexGrow': true,
            'flexShrink': true,
            'fontWeight': true,
            'lineHeight': true,
            'opacity': true,
            'order': true,
            'orphans': true,
            'widows': true,
            'zIndex': true,
            'zoom': true
        },
        cssProps: {},
        style: function (elem, name, value, extra) {
            if (!elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style) {
                return;
            }
            var ret, type, hooks, origName = camelCase(name), isCustomProp = rcustomProp.test(name), style = elem.style;
            if (!isCustomProp) {
                name = finalPropName(origName);
            }
            hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];
            if (value !== undefined) {
                type = typeof value;
                if (type === 'string' && (ret = rcssNum.exec(value)) && ret[1]) {
                    value = adjustCSS(elem, name, ret);
                    type = 'number';
                }
                if (value == null || value !== value) {
                    return;
                }
                if (type === 'number') {
                    value += ret && ret[3] || (jQuery.cssNumber[origName] ? '' : 'px');
                }
                if (!support.clearCloneStyle && value === '' && name.indexOf('background') === 0) {
                    style[name] = 'inherit';
                }
                if (!hooks || !('set' in hooks) || (value = hooks.set(elem, value, extra)) !== undefined) {
                    if (isCustomProp) {
                        style.setProperty(name, value);
                    } else {
                        style[name] = value;
                    }
                }
            } else {
                if (hooks && 'get' in hooks && (ret = hooks.get(elem, false, extra)) !== undefined) {
                    return ret;
                }
                return style[name];
            }
        },
        css: function (elem, name, extra, styles) {
            var val, num, hooks, origName = camelCase(name), isCustomProp = rcustomProp.test(name);
            if (!isCustomProp) {
                name = finalPropName(origName);
            }
            hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];
            if (hooks && 'get' in hooks) {
                val = hooks.get(elem, true, extra);
            }
            if (val === undefined) {
                val = curCSS(elem, name, styles);
            }
            if (val === 'normal' && name in cssNormalTransform) {
                val = cssNormalTransform[name];
            }
            if (extra === '' || extra) {
                num = parseFloat(val);
                return extra === true || isFinite(num) ? num || 0 : val;
            }
            return val;
        }
    });
    jQuery.each([
        'height',
        'width'
    ], function (i, dimension) {
        jQuery.cssHooks[dimension] = {
            get: function (elem, computed, extra) {
                if (computed) {
                    return rdisplayswap.test(jQuery.css(elem, 'display')) && (!elem.getClientRects().length || !elem.getBoundingClientRect().width) ? swap(elem, cssShow, function () {
                        return getWidthOrHeight(elem, dimension, extra);
                    }) : getWidthOrHeight(elem, dimension, extra);
                }
            },
            set: function (elem, value, extra) {
                var matches, styles = getStyles(elem), isBorderBox = jQuery.css(elem, 'boxSizing', false, styles) === 'border-box', subtract = extra && boxModelAdjustment(elem, dimension, extra, isBorderBox, styles);
                if (isBorderBox && support.scrollboxSize() === styles.position) {
                    subtract -= Math.ceil(elem['offset' + dimension[0].toUpperCase() + dimension.slice(1)] - parseFloat(styles[dimension]) - boxModelAdjustment(elem, dimension, 'border', false, styles) - 0.5);
                }
                if (subtract && (matches = rcssNum.exec(value)) && (matches[3] || 'px') !== 'px') {
                    elem.style[dimension] = value;
                    value = jQuery.css(elem, dimension);
                }
                return setPositiveNumber(elem, value, subtract);
            }
        };
    });
    jQuery.cssHooks.marginLeft = addGetHookIf(support.reliableMarginLeft, function (elem, computed) {
        if (computed) {
            return (parseFloat(curCSS(elem, 'marginLeft')) || elem.getBoundingClientRect().left - swap(elem, { marginLeft: 0 }, function () {
                return elem.getBoundingClientRect().left;
            })) + 'px';
        }
    });
    jQuery.each({
        margin: '',
        padding: '',
        border: 'Width'
    }, function (prefix, suffix) {
        jQuery.cssHooks[prefix + suffix] = {
            expand: function (value) {
                var i = 0, expanded = {}, parts = typeof value === 'string' ? value.split(' ') : [value];
                for (; i < 4; i++) {
                    expanded[prefix + cssExpand[i] + suffix] = parts[i] || parts[i - 2] || parts[0];
                }
                return expanded;
            }
        };
        if (prefix !== 'margin') {
            jQuery.cssHooks[prefix + suffix].set = setPositiveNumber;
        }
    });
    jQuery.fn.extend({
        css: function (name, value) {
            return access(this, function (elem, name, value) {
                var styles, len, map = {}, i = 0;
                if (Array.isArray(name)) {
                    styles = getStyles(elem);
                    len = name.length;
                    for (; i < len; i++) {
                        map[name[i]] = jQuery.css(elem, name[i], false, styles);
                    }
                    return map;
                }
                return value !== undefined ? jQuery.style(elem, name, value) : jQuery.css(elem, name);
            }, name, value, arguments.length > 1);
        }
    });
    function Tween(elem, options, prop, end, easing) {
        return new Tween.prototype.init(elem, options, prop, end, easing);
    }
    jQuery.Tween = Tween;
    Tween.prototype = {
        constructor: Tween,
        init: function (elem, options, prop, end, easing, unit) {
            this.elem = elem;
            this.prop = prop;
            this.easing = easing || jQuery.easing._default;
            this.options = options;
            this.start = this.now = this.cur();
            this.end = end;
            this.unit = unit || (jQuery.cssNumber[prop] ? '' : 'px');
        },
        cur: function () {
            var hooks = Tween.propHooks[this.prop];
            return hooks && hooks.get ? hooks.get(this) : Tween.propHooks._default.get(this);
        },
        run: function (percent) {
            var eased, hooks = Tween.propHooks[this.prop];
            if (this.options.duration) {
                this.pos = eased = jQuery.easing[this.easing](percent, this.options.duration * percent, 0, 1, this.options.duration);
            } else {
                this.pos = eased = percent;
            }
            this.now = (this.end - this.start) * eased + this.start;
            if (this.options.step) {
                this.options.step.call(this.elem, this.now, this);
            }
            if (hooks && hooks.set) {
                hooks.set(this);
            } else {
                Tween.propHooks._default.set(this);
            }
            return this;
        }
    };
    Tween.prototype.init.prototype = Tween.prototype;
    Tween.propHooks = {
        _default: {
            get: function (tween) {
                var result;
                if (tween.elem.nodeType !== 1 || tween.elem[tween.prop] != null && tween.elem.style[tween.prop] == null) {
                    return tween.elem[tween.prop];
                }
                result = jQuery.css(tween.elem, tween.prop, '');
                return !result || result === 'auto' ? 0 : result;
            },
            set: function (tween) {
                if (jQuery.fx.step[tween.prop]) {
                    jQuery.fx.step[tween.prop](tween);
                } else if (tween.elem.nodeType === 1 && (tween.elem.style[jQuery.cssProps[tween.prop]] != null || jQuery.cssHooks[tween.prop])) {
                    jQuery.style(tween.elem, tween.prop, tween.now + tween.unit);
                } else {
                    tween.elem[tween.prop] = tween.now;
                }
            }
        }
    };
    Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
        set: function (tween) {
            if (tween.elem.nodeType && tween.elem.parentNode) {
                tween.elem[tween.prop] = tween.now;
            }
        }
    };
    jQuery.easing = {
        linear: function (p) {
            return p;
        },
        swing: function (p) {
            return 0.5 - Math.cos(p * Math.PI) / 2;
        },
        _default: 'swing'
    };
    jQuery.fx = Tween.prototype.init;
    jQuery.fx.step = {};
    var fxNow, inProgress, rfxtypes = /^(?:toggle|show|hide)$/, rrun = /queueHooks$/;
    function schedule() {
        if (inProgress) {
            if (document.hidden === false && window.requestAnimationFrame) {
                window.requestAnimationFrame(schedule);
            } else {
                window.setTimeout(schedule, jQuery.fx.interval);
            }
            jQuery.fx.tick();
        }
    }
    function createFxNow() {
        window.setTimeout(function () {
            fxNow = undefined;
        });
        return fxNow = Date.now();
    }
    function genFx(type, includeWidth) {
        var which, i = 0, attrs = { height: type };
        includeWidth = includeWidth ? 1 : 0;
        for (; i < 4; i += 2 - includeWidth) {
            which = cssExpand[i];
            attrs['margin' + which] = attrs['padding' + which] = type;
        }
        if (includeWidth) {
            attrs.opacity = attrs.width = type;
        }
        return attrs;
    }
    function createTween(value, prop, animation) {
        var tween, collection = (Animation.tweeners[prop] || []).concat(Animation.tweeners['*']), index = 0, length = collection.length;
        for (; index < length; index++) {
            if (tween = collection[index].call(animation, prop, value)) {
                return tween;
            }
        }
    }
    function defaultPrefilter(elem, props, opts) {
        var prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display, isBox = 'width' in props || 'height' in props, anim = this, orig = {}, style = elem.style, hidden = elem.nodeType && isHiddenWithinTree(elem), dataShow = dataPriv.get(elem, 'fxshow');
        if (!opts.queue) {
            hooks = jQuery._queueHooks(elem, 'fx');
            if (hooks.unqueued == null) {
                hooks.unqueued = 0;
                oldfire = hooks.empty.fire;
                hooks.empty.fire = function () {
                    if (!hooks.unqueued) {
                        oldfire();
                    }
                };
            }
            hooks.unqueued++;
            anim.always(function () {
                anim.always(function () {
                    hooks.unqueued--;
                    if (!jQuery.queue(elem, 'fx').length) {
                        hooks.empty.fire();
                    }
                });
            });
        }
        for (prop in props) {
            value = props[prop];
            if (rfxtypes.test(value)) {
                delete props[prop];
                toggle = toggle || value === 'toggle';
                if (value === (hidden ? 'hide' : 'show')) {
                    if (value === 'show' && dataShow && dataShow[prop] !== undefined) {
                        hidden = true;
                    } else {
                        continue;
                    }
                }
                orig[prop] = dataShow && dataShow[prop] || jQuery.style(elem, prop);
            }
        }
        propTween = !jQuery.isEmptyObject(props);
        if (!propTween && jQuery.isEmptyObject(orig)) {
            return;
        }
        if (isBox && elem.nodeType === 1) {
            opts.overflow = [
                style.overflow,
                style.overflowX,
                style.overflowY
            ];
            restoreDisplay = dataShow && dataShow.display;
            if (restoreDisplay == null) {
                restoreDisplay = dataPriv.get(elem, 'display');
            }
            display = jQuery.css(elem, 'display');
            if (display === 'none') {
                if (restoreDisplay) {
                    display = restoreDisplay;
                } else {
                    showHide([elem], true);
                    restoreDisplay = elem.style.display || restoreDisplay;
                    display = jQuery.css(elem, 'display');
                    showHide([elem]);
                }
            }
            if (display === 'inline' || display === 'inline-block' && restoreDisplay != null) {
                if (jQuery.css(elem, 'float') === 'none') {
                    if (!propTween) {
                        anim.done(function () {
                            style.display = restoreDisplay;
                        });
                        if (restoreDisplay == null) {
                            display = style.display;
                            restoreDisplay = display === 'none' ? '' : display;
                        }
                    }
                    style.display = 'inline-block';
                }
            }
        }
        if (opts.overflow) {
            style.overflow = 'hidden';
            anim.always(function () {
                style.overflow = opts.overflow[0];
                style.overflowX = opts.overflow[1];
                style.overflowY = opts.overflow[2];
            });
        }
        propTween = false;
        for (prop in orig) {
            if (!propTween) {
                if (dataShow) {
                    if ('hidden' in dataShow) {
                        hidden = dataShow.hidden;
                    }
                } else {
                    dataShow = dataPriv.access(elem, 'fxshow', { display: restoreDisplay });
                }
                if (toggle) {
                    dataShow.hidden = !hidden;
                }
                if (hidden) {
                    showHide([elem], true);
                }
                anim.done(function () {
                    if (!hidden) {
                        showHide([elem]);
                    }
                    dataPriv.remove(elem, 'fxshow');
                    for (prop in orig) {
                        jQuery.style(elem, prop, orig[prop]);
                    }
                });
            }
            propTween = createTween(hidden ? dataShow[prop] : 0, prop, anim);
            if (!(prop in dataShow)) {
                dataShow[prop] = propTween.start;
                if (hidden) {
                    propTween.end = propTween.start;
                    propTween.start = 0;
                }
            }
        }
    }
    function propFilter(props, specialEasing) {
        var index, name, easing, value, hooks;
        for (index in props) {
            name = camelCase(index);
            easing = specialEasing[name];
            value = props[index];
            if (Array.isArray(value)) {
                easing = value[1];
                value = props[index] = value[0];
            }
            if (index !== name) {
                props[name] = value;
                delete props[index];
            }
            hooks = jQuery.cssHooks[name];
            if (hooks && 'expand' in hooks) {
                value = hooks.expand(value);
                delete props[name];
                for (index in value) {
                    if (!(index in props)) {
                        props[index] = value[index];
                        specialEasing[index] = easing;
                    }
                }
            } else {
                specialEasing[name] = easing;
            }
        }
    }
    function Animation(elem, properties, options) {
        var result, stopped, index = 0, length = Animation.prefilters.length, deferred = jQuery.Deferred().always(function () {
                delete tick.elem;
            }), tick = function () {
                if (stopped) {
                    return false;
                }
                var currentTime = fxNow || createFxNow(), remaining = Math.max(0, animation.startTime + animation.duration - currentTime), temp = remaining / animation.duration || 0, percent = 1 - temp, index = 0, length = animation.tweens.length;
                for (; index < length; index++) {
                    animation.tweens[index].run(percent);
                }
                deferred.notifyWith(elem, [
                    animation,
                    percent,
                    remaining
                ]);
                if (percent < 1 && length) {
                    return remaining;
                }
                if (!length) {
                    deferred.notifyWith(elem, [
                        animation,
                        1,
                        0
                    ]);
                }
                deferred.resolveWith(elem, [animation]);
                return false;
            }, animation = deferred.promise({
                elem: elem,
                props: jQuery.extend({}, properties),
                opts: jQuery.extend(true, {
                    specialEasing: {},
                    easing: jQuery.easing._default
                }, options),
                originalProperties: properties,
                originalOptions: options,
                startTime: fxNow || createFxNow(),
                duration: options.duration,
                tweens: [],
                createTween: function (prop, end) {
                    var tween = jQuery.Tween(elem, animation.opts, prop, end, animation.opts.specialEasing[prop] || animation.opts.easing);
                    animation.tweens.push(tween);
                    return tween;
                },
                stop: function (gotoEnd) {
                    var index = 0, length = gotoEnd ? animation.tweens.length : 0;
                    if (stopped) {
                        return this;
                    }
                    stopped = true;
                    for (; index < length; index++) {
                        animation.tweens[index].run(1);
                    }
                    if (gotoEnd) {
                        deferred.notifyWith(elem, [
                            animation,
                            1,
                            0
                        ]);
                        deferred.resolveWith(elem, [
                            animation,
                            gotoEnd
                        ]);
                    } else {
                        deferred.rejectWith(elem, [
                            animation,
                            gotoEnd
                        ]);
                    }
                    return this;
                }
            }), props = animation.props;
        propFilter(props, animation.opts.specialEasing);
        for (; index < length; index++) {
            result = Animation.prefilters[index].call(animation, elem, props, animation.opts);
            if (result) {
                if (isFunction(result.stop)) {
                    jQuery._queueHooks(animation.elem, animation.opts.queue).stop = result.stop.bind(result);
                }
                return result;
            }
        }
        jQuery.map(props, createTween, animation);
        if (isFunction(animation.opts.start)) {
            animation.opts.start.call(elem, animation);
        }
        animation.progress(animation.opts.progress).done(animation.opts.done, animation.opts.complete).fail(animation.opts.fail).always(animation.opts.always);
        jQuery.fx.timer(jQuery.extend(tick, {
            elem: elem,
            anim: animation,
            queue: animation.opts.queue
        }));
        return animation;
    }
    jQuery.Animation = jQuery.extend(Animation, {
        tweeners: {
            '*': [function (prop, value) {
                    var tween = this.createTween(prop, value);
                    adjustCSS(tween.elem, prop, rcssNum.exec(value), tween);
                    return tween;
                }]
        },
        tweener: function (props, callback) {
            if (isFunction(props)) {
                callback = props;
                props = ['*'];
            } else {
                props = props.match(rnothtmlwhite);
            }
            var prop, index = 0, length = props.length;
            for (; index < length; index++) {
                prop = props[index];
                Animation.tweeners[prop] = Animation.tweeners[prop] || [];
                Animation.tweeners[prop].unshift(callback);
            }
        },
        prefilters: [defaultPrefilter],
        prefilter: function (callback, prepend) {
            if (prepend) {
                Animation.prefilters.unshift(callback);
            } else {
                Animation.prefilters.push(callback);
            }
        }
    });
    jQuery.speed = function (speed, easing, fn) {
        var opt = speed && typeof speed === 'object' ? jQuery.extend({}, speed) : {
            complete: fn || !fn && easing || isFunction(speed) && speed,
            duration: speed,
            easing: fn && easing || easing && !isFunction(easing) && easing
        };
        if (jQuery.fx.off) {
            opt.duration = 0;
        } else {
            if (typeof opt.duration !== 'number') {
                if (opt.duration in jQuery.fx.speeds) {
                    opt.duration = jQuery.fx.speeds[opt.duration];
                } else {
                    opt.duration = jQuery.fx.speeds._default;
                }
            }
        }
        if (opt.queue == null || opt.queue === true) {
            opt.queue = 'fx';
        }
        opt.old = opt.complete;
        opt.complete = function () {
            if (isFunction(opt.old)) {
                opt.old.call(this);
            }
            if (opt.queue) {
                jQuery.dequeue(this, opt.queue);
            }
        };
        return opt;
    };
    jQuery.fn.extend({
        fadeTo: function (speed, to, easing, callback) {
            return this.filter(isHiddenWithinTree).css('opacity', 0).show().end().animate({ opacity: to }, speed, easing, callback);
        },
        animate: function (prop, speed, easing, callback) {
            var empty = jQuery.isEmptyObject(prop), optall = jQuery.speed(speed, easing, callback), doAnimation = function () {
                    var anim = Animation(this, jQuery.extend({}, prop), optall);
                    if (empty || dataPriv.get(this, 'finish')) {
                        anim.stop(true);
                    }
                };
            doAnimation.finish = doAnimation;
            return empty || optall.queue === false ? this.each(doAnimation) : this.queue(optall.queue, doAnimation);
        },
        stop: function (type, clearQueue, gotoEnd) {
            var stopQueue = function (hooks) {
                var stop = hooks.stop;
                delete hooks.stop;
                stop(gotoEnd);
            };
            if (typeof type !== 'string') {
                gotoEnd = clearQueue;
                clearQueue = type;
                type = undefined;
            }
            if (clearQueue && type !== false) {
                this.queue(type || 'fx', []);
            }
            return this.each(function () {
                var dequeue = true, index = type != null && type + 'queueHooks', timers = jQuery.timers, data = dataPriv.get(this);
                if (index) {
                    if (data[index] && data[index].stop) {
                        stopQueue(data[index]);
                    }
                } else {
                    for (index in data) {
                        if (data[index] && data[index].stop && rrun.test(index)) {
                            stopQueue(data[index]);
                        }
                    }
                }
                for (index = timers.length; index--;) {
                    if (timers[index].elem === this && (type == null || timers[index].queue === type)) {
                        timers[index].anim.stop(gotoEnd);
                        dequeue = false;
                        timers.splice(index, 1);
                    }
                }
                if (dequeue || !gotoEnd) {
                    jQuery.dequeue(this, type);
                }
            });
        },
        finish: function (type) {
            if (type !== false) {
                type = type || 'fx';
            }
            return this.each(function () {
                var index, data = dataPriv.get(this), queue = data[type + 'queue'], hooks = data[type + 'queueHooks'], timers = jQuery.timers, length = queue ? queue.length : 0;
                data.finish = true;
                jQuery.queue(this, type, []);
                if (hooks && hooks.stop) {
                    hooks.stop.call(this, true);
                }
                for (index = timers.length; index--;) {
                    if (timers[index].elem === this && timers[index].queue === type) {
                        timers[index].anim.stop(true);
                        timers.splice(index, 1);
                    }
                }
                for (index = 0; index < length; index++) {
                    if (queue[index] && queue[index].finish) {
                        queue[index].finish.call(this);
                    }
                }
                delete data.finish;
            });
        }
    });
    jQuery.each([
        'toggle',
        'show',
        'hide'
    ], function (i, name) {
        var cssFn = jQuery.fn[name];
        jQuery.fn[name] = function (speed, easing, callback) {
            return speed == null || typeof speed === 'boolean' ? cssFn.apply(this, arguments) : this.animate(genFx(name, true), speed, easing, callback);
        };
    });
    jQuery.each({
        slideDown: genFx('show'),
        slideUp: genFx('hide'),
        slideToggle: genFx('toggle'),
        fadeIn: { opacity: 'show' },
        fadeOut: { opacity: 'hide' },
        fadeToggle: { opacity: 'toggle' }
    }, function (name, props) {
        jQuery.fn[name] = function (speed, easing, callback) {
            return this.animate(props, speed, easing, callback);
        };
    });
    jQuery.timers = [];
    jQuery.fx.tick = function () {
        var timer, i = 0, timers = jQuery.timers;
        fxNow = Date.now();
        for (; i < timers.length; i++) {
            timer = timers[i];
            if (!timer() && timers[i] === timer) {
                timers.splice(i--, 1);
            }
        }
        if (!timers.length) {
            jQuery.fx.stop();
        }
        fxNow = undefined;
    };
    jQuery.fx.timer = function (timer) {
        jQuery.timers.push(timer);
        jQuery.fx.start();
    };
    jQuery.fx.interval = 13;
    jQuery.fx.start = function () {
        if (inProgress) {
            return;
        }
        inProgress = true;
        schedule();
    };
    jQuery.fx.stop = function () {
        inProgress = null;
    };
    jQuery.fx.speeds = {
        slow: 600,
        fast: 200,
        _default: 400
    };
    jQuery.fn.delay = function (time, type) {
        time = jQuery.fx ? jQuery.fx.speeds[time] || time : time;
        type = type || 'fx';
        return this.queue(type, function (next, hooks) {
            var timeout = window.setTimeout(next, time);
            hooks.stop = function () {
                window.clearTimeout(timeout);
            };
        });
    };
    (function () {
        var input = document.createElement('input'), select = document.createElement('select'), opt = select.appendChild(document.createElement('option'));
        input.type = 'checkbox';
        support.checkOn = input.value !== '';
        support.optSelected = opt.selected;
        input = document.createElement('input');
        input.value = 't';
        input.type = 'radio';
        support.radioValue = input.value === 't';
    }());
    var boolHook, attrHandle = jQuery.expr.attrHandle;
    jQuery.fn.extend({
        attr: function (name, value) {
            return access(this, jQuery.attr, name, value, arguments.length > 1);
        },
        removeAttr: function (name) {
            return this.each(function () {
                jQuery.removeAttr(this, name);
            });
        }
    });
    jQuery.extend({
        attr: function (elem, name, value) {
            var ret, hooks, nType = elem.nodeType;
            if (nType === 3 || nType === 8 || nType === 2) {
                return;
            }
            if (typeof elem.getAttribute === 'undefined') {
                return jQuery.prop(elem, name, value);
            }
            if (nType !== 1 || !jQuery.isXMLDoc(elem)) {
                hooks = jQuery.attrHooks[name.toLowerCase()] || (jQuery.expr.match.bool.test(name) ? boolHook : undefined);
            }
            if (value !== undefined) {
                if (value === null) {
                    jQuery.removeAttr(elem, name);
                    return;
                }
                if (hooks && 'set' in hooks && (ret = hooks.set(elem, value, name)) !== undefined) {
                    return ret;
                }
                elem.setAttribute(name, value + '');
                return value;
            }
            if (hooks && 'get' in hooks && (ret = hooks.get(elem, name)) !== null) {
                return ret;
            }
            ret = jQuery.find.attr(elem, name);
            return ret == null ? undefined : ret;
        },
        attrHooks: {
            type: {
                set: function (elem, value) {
                    if (!support.radioValue && value === 'radio' && nodeName(elem, 'input')) {
                        var val = elem.value;
                        elem.setAttribute('type', value);
                        if (val) {
                            elem.value = val;
                        }
                        return value;
                    }
                }
            }
        },
        removeAttr: function (elem, value) {
            var name, i = 0, attrNames = value && value.match(rnothtmlwhite);
            if (attrNames && elem.nodeType === 1) {
                while (name = attrNames[i++]) {
                    elem.removeAttribute(name);
                }
            }
        }
    });
    boolHook = {
        set: function (elem, value, name) {
            if (value === false) {
                jQuery.removeAttr(elem, name);
            } else {
                elem.setAttribute(name, name);
            }
            return name;
        }
    };
    jQuery.each(jQuery.expr.match.bool.source.match(/\w+/g), function (i, name) {
        var getter = attrHandle[name] || jQuery.find.attr;
        attrHandle[name] = function (elem, name, isXML) {
            var ret, handle, lowercaseName = name.toLowerCase();
            if (!isXML) {
                handle = attrHandle[lowercaseName];
                attrHandle[lowercaseName] = ret;
                ret = getter(elem, name, isXML) != null ? lowercaseName : null;
                attrHandle[lowercaseName] = handle;
            }
            return ret;
        };
    });
    var rfocusable = /^(?:input|select|textarea|button)$/i, rclickable = /^(?:a|area)$/i;
    jQuery.fn.extend({
        prop: function (name, value) {
            return access(this, jQuery.prop, name, value, arguments.length > 1);
        },
        removeProp: function (name) {
            return this.each(function () {
                delete this[jQuery.propFix[name] || name];
            });
        }
    });
    jQuery.extend({
        prop: function (elem, name, value) {
            var ret, hooks, nType = elem.nodeType;
            if (nType === 3 || nType === 8 || nType === 2) {
                return;
            }
            if (nType !== 1 || !jQuery.isXMLDoc(elem)) {
                name = jQuery.propFix[name] || name;
                hooks = jQuery.propHooks[name];
            }
            if (value !== undefined) {
                if (hooks && 'set' in hooks && (ret = hooks.set(elem, value, name)) !== undefined) {
                    return ret;
                }
                return elem[name] = value;
            }
            if (hooks && 'get' in hooks && (ret = hooks.get(elem, name)) !== null) {
                return ret;
            }
            return elem[name];
        },
        propHooks: {
            tabIndex: {
                get: function (elem) {
                    var tabindex = jQuery.find.attr(elem, 'tabindex');
                    if (tabindex) {
                        return parseInt(tabindex, 10);
                    }
                    if (rfocusable.test(elem.nodeName) || rclickable.test(elem.nodeName) && elem.href) {
                        return 0;
                    }
                    return -1;
                }
            }
        },
        propFix: {
            'for': 'htmlFor',
            'class': 'className'
        }
    });
    if (!support.optSelected) {
        jQuery.propHooks.selected = {
            get: function (elem) {
                var parent = elem.parentNode;
                if (parent && parent.parentNode) {
                    parent.parentNode.selectedIndex;
                }
                return null;
            },
            set: function (elem) {
                var parent = elem.parentNode;
                if (parent) {
                    parent.selectedIndex;
                    if (parent.parentNode) {
                        parent.parentNode.selectedIndex;
                    }
                }
            }
        };
    }
    jQuery.each([
        'tabIndex',
        'readOnly',
        'maxLength',
        'cellSpacing',
        'cellPadding',
        'rowSpan',
        'colSpan',
        'useMap',
        'frameBorder',
        'contentEditable'
    ], function () {
        jQuery.propFix[this.toLowerCase()] = this;
    });
    function stripAndCollapse(value) {
        var tokens = value.match(rnothtmlwhite) || [];
        return tokens.join(' ');
    }
    function getClass(elem) {
        return elem.getAttribute && elem.getAttribute('class') || '';
    }
    function classesToArray(value) {
        if (Array.isArray(value)) {
            return value;
        }
        if (typeof value === 'string') {
            return value.match(rnothtmlwhite) || [];
        }
        return [];
    }
    jQuery.fn.extend({
        addClass: function (value) {
            var classes, elem, cur, curValue, clazz, j, finalValue, i = 0;
            if (isFunction(value)) {
                return this.each(function (j) {
                    jQuery(this).addClass(value.call(this, j, getClass(this)));
                });
            }
            classes = classesToArray(value);
            if (classes.length) {
                while (elem = this[i++]) {
                    curValue = getClass(elem);
                    cur = elem.nodeType === 1 && ' ' + stripAndCollapse(curValue) + ' ';
                    if (cur) {
                        j = 0;
                        while (clazz = classes[j++]) {
                            if (cur.indexOf(' ' + clazz + ' ') < 0) {
                                cur += clazz + ' ';
                            }
                        }
                        finalValue = stripAndCollapse(cur);
                        if (curValue !== finalValue) {
                            elem.setAttribute('class', finalValue);
                        }
                    }
                }
            }
            return this;
        },
        removeClass: function (value) {
            var classes, elem, cur, curValue, clazz, j, finalValue, i = 0;
            if (isFunction(value)) {
                return this.each(function (j) {
                    jQuery(this).removeClass(value.call(this, j, getClass(this)));
                });
            }
            if (!arguments.length) {
                return this.attr('class', '');
            }
            classes = classesToArray(value);
            if (classes.length) {
                while (elem = this[i++]) {
                    curValue = getClass(elem);
                    cur = elem.nodeType === 1 && ' ' + stripAndCollapse(curValue) + ' ';
                    if (cur) {
                        j = 0;
                        while (clazz = classes[j++]) {
                            while (cur.indexOf(' ' + clazz + ' ') > -1) {
                                cur = cur.replace(' ' + clazz + ' ', ' ');
                            }
                        }
                        finalValue = stripAndCollapse(cur);
                        if (curValue !== finalValue) {
                            elem.setAttribute('class', finalValue);
                        }
                    }
                }
            }
            return this;
        },
        toggleClass: function (value, stateVal) {
            var type = typeof value, isValidValue = type === 'string' || Array.isArray(value);
            if (typeof stateVal === 'boolean' && isValidValue) {
                return stateVal ? this.addClass(value) : this.removeClass(value);
            }
            if (isFunction(value)) {
                return this.each(function (i) {
                    jQuery(this).toggleClass(value.call(this, i, getClass(this), stateVal), stateVal);
                });
            }
            return this.each(function () {
                var className, i, self, classNames;
                if (isValidValue) {
                    i = 0;
                    self = jQuery(this);
                    classNames = classesToArray(value);
                    while (className = classNames[i++]) {
                        if (self.hasClass(className)) {
                            self.removeClass(className);
                        } else {
                            self.addClass(className);
                        }
                    }
                } else if (value === undefined || type === 'boolean') {
                    className = getClass(this);
                    if (className) {
                        dataPriv.set(this, '__className__', className);
                    }
                    if (this.setAttribute) {
                        this.setAttribute('class', className || value === false ? '' : dataPriv.get(this, '__className__') || '');
                    }
                }
            });
        },
        hasClass: function (selector) {
            var className, elem, i = 0;
            className = ' ' + selector + ' ';
            while (elem = this[i++]) {
                if (elem.nodeType === 1 && (' ' + stripAndCollapse(getClass(elem)) + ' ').indexOf(className) > -1) {
                    return true;
                }
            }
            return false;
        }
    });
    var rreturn = /\r/g;
    jQuery.fn.extend({
        val: function (value) {
            var hooks, ret, valueIsFunction, elem = this[0];
            if (!arguments.length) {
                if (elem) {
                    hooks = jQuery.valHooks[elem.type] || jQuery.valHooks[elem.nodeName.toLowerCase()];
                    if (hooks && 'get' in hooks && (ret = hooks.get(elem, 'value')) !== undefined) {
                        return ret;
                    }
                    ret = elem.value;
                    if (typeof ret === 'string') {
                        return ret.replace(rreturn, '');
                    }
                    return ret == null ? '' : ret;
                }
                return;
            }
            valueIsFunction = isFunction(value);
            return this.each(function (i) {
                var val;
                if (this.nodeType !== 1) {
                    return;
                }
                if (valueIsFunction) {
                    val = value.call(this, i, jQuery(this).val());
                } else {
                    val = value;
                }
                if (val == null) {
                    val = '';
                } else if (typeof val === 'number') {
                    val += '';
                } else if (Array.isArray(val)) {
                    val = jQuery.map(val, function (value) {
                        return value == null ? '' : value + '';
                    });
                }
                hooks = jQuery.valHooks[this.type] || jQuery.valHooks[this.nodeName.toLowerCase()];
                if (!hooks || !('set' in hooks) || hooks.set(this, val, 'value') === undefined) {
                    this.value = val;
                }
            });
        }
    });
    jQuery.extend({
        valHooks: {
            option: {
                get: function (elem) {
                    var val = jQuery.find.attr(elem, 'value');
                    return val != null ? val : stripAndCollapse(jQuery.text(elem));
                }
            },
            select: {
                get: function (elem) {
                    var value, option, i, options = elem.options, index = elem.selectedIndex, one = elem.type === 'select-one', values = one ? null : [], max = one ? index + 1 : options.length;
                    if (index < 0) {
                        i = max;
                    } else {
                        i = one ? index : 0;
                    }
                    for (; i < max; i++) {
                        option = options[i];
                        if ((option.selected || i === index) && !option.disabled && (!option.parentNode.disabled || !nodeName(option.parentNode, 'optgroup'))) {
                            value = jQuery(option).val();
                            if (one) {
                                return value;
                            }
                            values.push(value);
                        }
                    }
                    return values;
                },
                set: function (elem, value) {
                    var optionSet, option, options = elem.options, values = jQuery.makeArray(value), i = options.length;
                    while (i--) {
                        option = options[i];
                        if (option.selected = jQuery.inArray(jQuery.valHooks.option.get(option), values) > -1) {
                            optionSet = true;
                        }
                    }
                    if (!optionSet) {
                        elem.selectedIndex = -1;
                    }
                    return values;
                }
            }
        }
    });
    jQuery.each([
        'radio',
        'checkbox'
    ], function () {
        jQuery.valHooks[this] = {
            set: function (elem, value) {
                if (Array.isArray(value)) {
                    return elem.checked = jQuery.inArray(jQuery(elem).val(), value) > -1;
                }
            }
        };
        if (!support.checkOn) {
            jQuery.valHooks[this].get = function (elem) {
                return elem.getAttribute('value') === null ? 'on' : elem.value;
            };
        }
    });
    support.focusin = 'onfocusin' in window;
    var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/, stopPropagationCallback = function (e) {
            e.stopPropagation();
        };
    jQuery.extend(jQuery.event, {
        trigger: function (event, data, elem, onlyHandlers) {
            var i, cur, tmp, bubbleType, ontype, handle, special, lastElement, eventPath = [elem || document], type = hasOwn.call(event, 'type') ? event.type : event, namespaces = hasOwn.call(event, 'namespace') ? event.namespace.split('.') : [];
            cur = lastElement = tmp = elem = elem || document;
            if (elem.nodeType === 3 || elem.nodeType === 8) {
                return;
            }
            if (rfocusMorph.test(type + jQuery.event.triggered)) {
                return;
            }
            if (type.indexOf('.') > -1) {
                namespaces = type.split('.');
                type = namespaces.shift();
                namespaces.sort();
            }
            ontype = type.indexOf(':') < 0 && 'on' + type;
            event = event[jQuery.expando] ? event : new jQuery.Event(type, typeof event === 'object' && event);
            event.isTrigger = onlyHandlers ? 2 : 3;
            event.namespace = namespaces.join('.');
            event.rnamespace = event.namespace ? new RegExp('(^|\\.)' + namespaces.join('\\.(?:.*\\.|)') + '(\\.|$)') : null;
            event.result = undefined;
            if (!event.target) {
                event.target = elem;
            }
            data = data == null ? [event] : jQuery.makeArray(data, [event]);
            special = jQuery.event.special[type] || {};
            if (!onlyHandlers && special.trigger && special.trigger.apply(elem, data) === false) {
                return;
            }
            if (!onlyHandlers && !special.noBubble && !isWindow(elem)) {
                bubbleType = special.delegateType || type;
                if (!rfocusMorph.test(bubbleType + type)) {
                    cur = cur.parentNode;
                }
                for (; cur; cur = cur.parentNode) {
                    eventPath.push(cur);
                    tmp = cur;
                }
                if (tmp === (elem.ownerDocument || document)) {
                    eventPath.push(tmp.defaultView || tmp.parentWindow || window);
                }
            }
            i = 0;
            while ((cur = eventPath[i++]) && !event.isPropagationStopped()) {
                lastElement = cur;
                event.type = i > 1 ? bubbleType : special.bindType || type;
                handle = (dataPriv.get(cur, 'events') || {})[event.type] && dataPriv.get(cur, 'handle');
                if (handle) {
                    handle.apply(cur, data);
                }
                handle = ontype && cur[ontype];
                if (handle && handle.apply && acceptData(cur)) {
                    event.result = handle.apply(cur, data);
                    if (event.result === false) {
                        event.preventDefault();
                    }
                }
            }
            event.type = type;
            if (!onlyHandlers && !event.isDefaultPrevented()) {
                if ((!special._default || special._default.apply(eventPath.pop(), data) === false) && acceptData(elem)) {
                    if (ontype && isFunction(elem[type]) && !isWindow(elem)) {
                        tmp = elem[ontype];
                        if (tmp) {
                            elem[ontype] = null;
                        }
                        jQuery.event.triggered = type;
                        if (event.isPropagationStopped()) {
                            lastElement.addEventListener(type, stopPropagationCallback);
                        }
                        elem[type]();
                        if (event.isPropagationStopped()) {
                            lastElement.removeEventListener(type, stopPropagationCallback);
                        }
                        jQuery.event.triggered = undefined;
                        if (tmp) {
                            elem[ontype] = tmp;
                        }
                    }
                }
            }
            return event.result;
        },
        simulate: function (type, elem, event) {
            var e = jQuery.extend(new jQuery.Event(), event, {
                type: type,
                isSimulated: true
            });
            jQuery.event.trigger(e, null, elem);
        }
    });
    jQuery.fn.extend({
        trigger: function (type, data) {
            return this.each(function () {
                jQuery.event.trigger(type, data, this);
            });
        },
        triggerHandler: function (type, data) {
            var elem = this[0];
            if (elem) {
                return jQuery.event.trigger(type, data, elem, true);
            }
        }
    });
    if (!support.focusin) {
        jQuery.each({
            focus: 'focusin',
            blur: 'focusout'
        }, function (orig, fix) {
            var handler = function (event) {
                jQuery.event.simulate(fix, event.target, jQuery.event.fix(event));
            };
            jQuery.event.special[fix] = {
                setup: function () {
                    var doc = this.ownerDocument || this, attaches = dataPriv.access(doc, fix);
                    if (!attaches) {
                        doc.addEventListener(orig, handler, true);
                    }
                    dataPriv.access(doc, fix, (attaches || 0) + 1);
                },
                teardown: function () {
                    var doc = this.ownerDocument || this, attaches = dataPriv.access(doc, fix) - 1;
                    if (!attaches) {
                        doc.removeEventListener(orig, handler, true);
                        dataPriv.remove(doc, fix);
                    } else {
                        dataPriv.access(doc, fix, attaches);
                    }
                }
            };
        });
    }
    var location = window.location;
    var nonce = Date.now();
    var rquery = /\?/;
    jQuery.parseXML = function (data) {
        var xml;
        if (!data || typeof data !== 'string') {
            return null;
        }
        try {
            xml = new window.DOMParser().parseFromString(data, 'text/xml');
        } catch (e) {
            xml = undefined;
        }
        if (!xml || xml.getElementsByTagName('parsererror').length) {
            jQuery.error('Invalid XML: ' + data);
        }
        return xml;
    };
    var rbracket = /\[\]$/, rCRLF = /\r?\n/g, rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i, rsubmittable = /^(?:input|select|textarea|keygen)/i;
    function buildParams(prefix, obj, traditional, add) {
        var name;
        if (Array.isArray(obj)) {
            jQuery.each(obj, function (i, v) {
                if (traditional || rbracket.test(prefix)) {
                    add(prefix, v);
                } else {
                    buildParams(prefix + '[' + (typeof v === 'object' && v != null ? i : '') + ']', v, traditional, add);
                }
            });
        } else if (!traditional && toType(obj) === 'object') {
            for (name in obj) {
                buildParams(prefix + '[' + name + ']', obj[name], traditional, add);
            }
        } else {
            add(prefix, obj);
        }
    }
    jQuery.param = function (a, traditional) {
        var prefix, s = [], add = function (key, valueOrFunction) {
                var value = isFunction(valueOrFunction) ? valueOrFunction() : valueOrFunction;
                s[s.length] = encodeURIComponent(key) + '=' + encodeURIComponent(value == null ? '' : value);
            };
        if (Array.isArray(a) || a.jquery && !jQuery.isPlainObject(a)) {
            jQuery.each(a, function () {
                add(this.name, this.value);
            });
        } else {
            for (prefix in a) {
                buildParams(prefix, a[prefix], traditional, add);
            }
        }
        return s.join('&');
    };
    jQuery.fn.extend({
        serialize: function () {
            return jQuery.param(this.serializeArray());
        },
        serializeArray: function () {
            return this.map(function () {
                var elements = jQuery.prop(this, 'elements');
                return elements ? jQuery.makeArray(elements) : this;
            }).filter(function () {
                var type = this.type;
                return this.name && !jQuery(this).is(':disabled') && rsubmittable.test(this.nodeName) && !rsubmitterTypes.test(type) && (this.checked || !rcheckableType.test(type));
            }).map(function (i, elem) {
                var val = jQuery(this).val();
                if (val == null) {
                    return null;
                }
                if (Array.isArray(val)) {
                    return jQuery.map(val, function (val) {
                        return {
                            name: elem.name,
                            value: val.replace(rCRLF, '\r\n')
                        };
                    });
                }
                return {
                    name: elem.name,
                    value: val.replace(rCRLF, '\r\n')
                };
            }).get();
        }
    });
    var r20 = /%20/g, rhash = /#.*$/, rantiCache = /([?&])_=[^&]*/, rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg, rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/, rnoContent = /^(?:GET|HEAD)$/, rprotocol = /^\/\//, prefilters = {}, transports = {}, allTypes = '*/'.concat('*'), originAnchor = document.createElement('a');
    originAnchor.href = location.href;
    function addToPrefiltersOrTransports(structure) {
        return function (dataTypeExpression, func) {
            if (typeof dataTypeExpression !== 'string') {
                func = dataTypeExpression;
                dataTypeExpression = '*';
            }
            var dataType, i = 0, dataTypes = dataTypeExpression.toLowerCase().match(rnothtmlwhite) || [];
            if (isFunction(func)) {
                while (dataType = dataTypes[i++]) {
                    if (dataType[0] === '+') {
                        dataType = dataType.slice(1) || '*';
                        (structure[dataType] = structure[dataType] || []).unshift(func);
                    } else {
                        (structure[dataType] = structure[dataType] || []).push(func);
                    }
                }
            }
        };
    }
    function inspectPrefiltersOrTransports(structure, options, originalOptions, jqXHR) {
        var inspected = {}, seekingTransport = structure === transports;
        function inspect(dataType) {
            var selected;
            inspected[dataType] = true;
            jQuery.each(structure[dataType] || [], function (_, prefilterOrFactory) {
                var dataTypeOrTransport = prefilterOrFactory(options, originalOptions, jqXHR);
                if (typeof dataTypeOrTransport === 'string' && !seekingTransport && !inspected[dataTypeOrTransport]) {
                    options.dataTypes.unshift(dataTypeOrTransport);
                    inspect(dataTypeOrTransport);
                    return false;
                } else if (seekingTransport) {
                    return !(selected = dataTypeOrTransport);
                }
            });
            return selected;
        }
        return inspect(options.dataTypes[0]) || !inspected['*'] && inspect('*');
    }
    function ajaxExtend(target, src) {
        var key, deep, flatOptions = jQuery.ajaxSettings.flatOptions || {};
        for (key in src) {
            if (src[key] !== undefined) {
                (flatOptions[key] ? target : deep || (deep = {}))[key] = src[key];
            }
        }
        if (deep) {
            jQuery.extend(true, target, deep);
        }
        return target;
    }
    function ajaxHandleResponses(s, jqXHR, responses) {
        var ct, type, finalDataType, firstDataType, contents = s.contents, dataTypes = s.dataTypes;
        while (dataTypes[0] === '*') {
            dataTypes.shift();
            if (ct === undefined) {
                ct = s.mimeType || jqXHR.getResponseHeader('Content-Type');
            }
        }
        if (ct) {
            for (type in contents) {
                if (contents[type] && contents[type].test(ct)) {
                    dataTypes.unshift(type);
                    break;
                }
            }
        }
        if (dataTypes[0] in responses) {
            finalDataType = dataTypes[0];
        } else {
            for (type in responses) {
                if (!dataTypes[0] || s.converters[type + ' ' + dataTypes[0]]) {
                    finalDataType = type;
                    break;
                }
                if (!firstDataType) {
                    firstDataType = type;
                }
            }
            finalDataType = finalDataType || firstDataType;
        }
        if (finalDataType) {
            if (finalDataType !== dataTypes[0]) {
                dataTypes.unshift(finalDataType);
            }
            return responses[finalDataType];
        }
    }
    function ajaxConvert(s, response, jqXHR, isSuccess) {
        var conv2, current, conv, tmp, prev, converters = {}, dataTypes = s.dataTypes.slice();
        if (dataTypes[1]) {
            for (conv in s.converters) {
                converters[conv.toLowerCase()] = s.converters[conv];
            }
        }
        current = dataTypes.shift();
        while (current) {
            if (s.responseFields[current]) {
                jqXHR[s.responseFields[current]] = response;
            }
            if (!prev && isSuccess && s.dataFilter) {
                response = s.dataFilter(response, s.dataType);
            }
            prev = current;
            current = dataTypes.shift();
            if (current) {
                if (current === '*') {
                    current = prev;
                } else if (prev !== '*' && prev !== current) {
                    conv = converters[prev + ' ' + current] || converters['* ' + current];
                    if (!conv) {
                        for (conv2 in converters) {
                            tmp = conv2.split(' ');
                            if (tmp[1] === current) {
                                conv = converters[prev + ' ' + tmp[0]] || converters['* ' + tmp[0]];
                                if (conv) {
                                    if (conv === true) {
                                        conv = converters[conv2];
                                    } else if (converters[conv2] !== true) {
                                        current = tmp[0];
                                        dataTypes.unshift(tmp[1]);
                                    }
                                    break;
                                }
                            }
                        }
                    }
                    if (conv !== true) {
                        if (conv && s.throws) {
                            response = conv(response);
                        } else {
                            try {
                                response = conv(response);
                            } catch (e) {
                                return {
                                    state: 'parsererror',
                                    error: conv ? e : 'No conversion from ' + prev + ' to ' + current
                                };
                            }
                        }
                    }
                }
            }
        }
        return {
            state: 'success',
            data: response
        };
    }
    jQuery.extend({
        active: 0,
        lastModified: {},
        etag: {},
        ajaxSettings: {
            url: location.href,
            type: 'GET',
            isLocal: rlocalProtocol.test(location.protocol),
            global: true,
            processData: true,
            async: true,
            contentType: 'application/x-www-form-urlencoded; charset=UTF-8',
            accepts: {
                '*': allTypes,
                text: 'text/plain',
                html: 'text/html',
                xml: 'application/xml, text/xml',
                json: 'application/json, text/javascript'
            },
            contents: {
                xml: /\bxml\b/,
                html: /\bhtml/,
                json: /\bjson\b/
            },
            responseFields: {
                xml: 'responseXML',
                text: 'responseText',
                json: 'responseJSON'
            },
            converters: {
                '* text': String,
                'text html': true,
                'text json': JSON.parse,
                'text xml': jQuery.parseXML
            },
            flatOptions: {
                url: true,
                context: true
            }
        },
        ajaxSetup: function (target, settings) {
            return settings ? ajaxExtend(ajaxExtend(target, jQuery.ajaxSettings), settings) : ajaxExtend(jQuery.ajaxSettings, target);
        },
        ajaxPrefilter: addToPrefiltersOrTransports(prefilters),
        ajaxTransport: addToPrefiltersOrTransports(transports),
        ajax: function (url, options) {
            if (typeof url === 'object') {
                options = url;
                url = undefined;
            }
            options = options || {};
            var transport, cacheURL, responseHeadersString, responseHeaders, timeoutTimer, urlAnchor, completed, fireGlobals, i, uncached, s = jQuery.ajaxSetup({}, options), callbackContext = s.context || s, globalEventContext = s.context && (callbackContext.nodeType || callbackContext.jquery) ? jQuery(callbackContext) : jQuery.event, deferred = jQuery.Deferred(), completeDeferred = jQuery.Callbacks('once memory'), statusCode = s.statusCode || {}, requestHeaders = {}, requestHeadersNames = {}, strAbort = 'canceled', jqXHR = {
                    readyState: 0,
                    getResponseHeader: function (key) {
                        var match;
                        if (completed) {
                            if (!responseHeaders) {
                                responseHeaders = {};
                                while (match = rheaders.exec(responseHeadersString)) {
                                    responseHeaders[match[1].toLowerCase()] = match[2];
                                }
                            }
                            match = responseHeaders[key.toLowerCase()];
                        }
                        return match == null ? null : match;
                    },
                    getAllResponseHeaders: function () {
                        return completed ? responseHeadersString : null;
                    },
                    setRequestHeader: function (name, value) {
                        if (completed == null) {
                            name = requestHeadersNames[name.toLowerCase()] = requestHeadersNames[name.toLowerCase()] || name;
                            requestHeaders[name] = value;
                        }
                        return this;
                    },
                    overrideMimeType: function (type) {
                        if (completed == null) {
                            s.mimeType = type;
                        }
                        return this;
                    },
                    statusCode: function (map) {
                        var code;
                        if (map) {
                            if (completed) {
                                jqXHR.always(map[jqXHR.status]);
                            } else {
                                for (code in map) {
                                    statusCode[code] = [
                                        statusCode[code],
                                        map[code]
                                    ];
                                }
                            }
                        }
                        return this;
                    },
                    abort: function (statusText) {
                        var finalText = statusText || strAbort;
                        if (transport) {
                            transport.abort(finalText);
                        }
                        done(0, finalText);
                        return this;
                    }
                };
            deferred.promise(jqXHR);
            s.url = ((url || s.url || location.href) + '').replace(rprotocol, location.protocol + '//');
            s.type = options.method || options.type || s.method || s.type;
            s.dataTypes = (s.dataType || '*').toLowerCase().match(rnothtmlwhite) || [''];
            if (s.crossDomain == null) {
                urlAnchor = document.createElement('a');
                try {
                    urlAnchor.href = s.url;
                    urlAnchor.href = urlAnchor.href;
                    s.crossDomain = originAnchor.protocol + '//' + originAnchor.host !== urlAnchor.protocol + '//' + urlAnchor.host;
                } catch (e) {
                    s.crossDomain = true;
                }
            }
            if (s.data && s.processData && typeof s.data !== 'string') {
                s.data = jQuery.param(s.data, s.traditional);
            }
            inspectPrefiltersOrTransports(prefilters, s, options, jqXHR);
            if (completed) {
                return jqXHR;
            }
            fireGlobals = jQuery.event && s.global;
            if (fireGlobals && jQuery.active++ === 0) {
                jQuery.event.trigger('ajaxStart');
            }
            s.type = s.type.toUpperCase();
            s.hasContent = !rnoContent.test(s.type);
            cacheURL = s.url.replace(rhash, '');
            if (!s.hasContent) {
                uncached = s.url.slice(cacheURL.length);
                if (s.data && (s.processData || typeof s.data === 'string')) {
                    cacheURL += (rquery.test(cacheURL) ? '&' : '?') + s.data;
                    delete s.data;
                }
                if (s.cache === false) {
                    cacheURL = cacheURL.replace(rantiCache, '$1');
                    uncached = (rquery.test(cacheURL) ? '&' : '?') + '_=' + nonce++ + uncached;
                }
                s.url = cacheURL + uncached;
            } else if (s.data && s.processData && (s.contentType || '').indexOf('application/x-www-form-urlencoded') === 0) {
                s.data = s.data.replace(r20, '+');
            }
            if (s.ifModified) {
                if (jQuery.lastModified[cacheURL]) {
                    jqXHR.setRequestHeader('If-Modified-Since', jQuery.lastModified[cacheURL]);
                }
                if (jQuery.etag[cacheURL]) {
                    jqXHR.setRequestHeader('If-None-Match', jQuery.etag[cacheURL]);
                }
            }
            if (s.data && s.hasContent && s.contentType !== false || options.contentType) {
                jqXHR.setRequestHeader('Content-Type', s.contentType);
            }
            jqXHR.setRequestHeader('Accept', s.dataTypes[0] && s.accepts[s.dataTypes[0]] ? s.accepts[s.dataTypes[0]] + (s.dataTypes[0] !== '*' ? ', ' + allTypes + '; q=0.01' : '') : s.accepts['*']);
            for (i in s.headers) {
                jqXHR.setRequestHeader(i, s.headers[i]);
            }
            if (s.beforeSend && (s.beforeSend.call(callbackContext, jqXHR, s) === false || completed)) {
                return jqXHR.abort();
            }
            strAbort = 'abort';
            completeDeferred.add(s.complete);
            jqXHR.done(s.success);
            jqXHR.fail(s.error);
            transport = inspectPrefiltersOrTransports(transports, s, options, jqXHR);
            if (!transport) {
                done(-1, 'No Transport');
            } else {
                jqXHR.readyState = 1;
                if (fireGlobals) {
                    globalEventContext.trigger('ajaxSend', [
                        jqXHR,
                        s
                    ]);
                }
                if (completed) {
                    return jqXHR;
                }
                if (s.async && s.timeout > 0) {
                    timeoutTimer = window.setTimeout(function () {
                        jqXHR.abort('timeout');
                    }, s.timeout);
                }
                try {
                    completed = false;
                    transport.send(requestHeaders, done);
                } catch (e) {
                    if (completed) {
                        throw e;
                    }
                    done(-1, e);
                }
            }
            function done(status, nativeStatusText, responses, headers) {
                var isSuccess, success, error, response, modified, statusText = nativeStatusText;
                if (completed) {
                    return;
                }
                completed = true;
                if (timeoutTimer) {
                    window.clearTimeout(timeoutTimer);
                }
                transport = undefined;
                responseHeadersString = headers || '';
                jqXHR.readyState = status > 0 ? 4 : 0;
                isSuccess = status >= 200 && status < 300 || status === 304;
                if (responses) {
                    response = ajaxHandleResponses(s, jqXHR, responses);
                }
                response = ajaxConvert(s, response, jqXHR, isSuccess);
                if (isSuccess) {
                    if (s.ifModified) {
                        modified = jqXHR.getResponseHeader('Last-Modified');
                        if (modified) {
                            jQuery.lastModified[cacheURL] = modified;
                        }
                        modified = jqXHR.getResponseHeader('etag');
                        if (modified) {
                            jQuery.etag[cacheURL] = modified;
                        }
                    }
                    if (status === 204 || s.type === 'HEAD') {
                        statusText = 'nocontent';
                    } else if (status === 304) {
                        statusText = 'notmodified';
                    } else {
                        statusText = response.state;
                        success = response.data;
                        error = response.error;
                        isSuccess = !error;
                    }
                } else {
                    error = statusText;
                    if (status || !statusText) {
                        statusText = 'error';
                        if (status < 0) {
                            status = 0;
                        }
                    }
                }
                jqXHR.status = status;
                jqXHR.statusText = (nativeStatusText || statusText) + '';
                if (isSuccess) {
                    deferred.resolveWith(callbackContext, [
                        success,
                        statusText,
                        jqXHR
                    ]);
                } else {
                    deferred.rejectWith(callbackContext, [
                        jqXHR,
                        statusText,
                        error
                    ]);
                }
                jqXHR.statusCode(statusCode);
                statusCode = undefined;
                if (fireGlobals) {
                    globalEventContext.trigger(isSuccess ? 'ajaxSuccess' : 'ajaxError', [
                        jqXHR,
                        s,
                        isSuccess ? success : error
                    ]);
                }
                completeDeferred.fireWith(callbackContext, [
                    jqXHR,
                    statusText
                ]);
                if (fireGlobals) {
                    globalEventContext.trigger('ajaxComplete', [
                        jqXHR,
                        s
                    ]);
                    if (!--jQuery.active) {
                        jQuery.event.trigger('ajaxStop');
                    }
                }
            }
            return jqXHR;
        },
        getJSON: function (url, data, callback) {
            return jQuery.get(url, data, callback, 'json');
        },
        getScript: function (url, callback) {
            return jQuery.get(url, undefined, callback, 'script');
        }
    });
    jQuery.each([
        'get',
        'post'
    ], function (i, method) {
        jQuery[method] = function (url, data, callback, type) {
            if (isFunction(data)) {
                type = type || callback;
                callback = data;
                data = undefined;
            }
            return jQuery.ajax(jQuery.extend({
                url: url,
                type: method,
                dataType: type,
                data: data,
                success: callback
            }, jQuery.isPlainObject(url) && url));
        };
    });
    jQuery._evalUrl = function (url) {
        return jQuery.ajax({
            url: url,
            type: 'GET',
            dataType: 'script',
            cache: true,
            async: false,
            global: false,
            'throws': true
        });
    };
    jQuery.fn.extend({
        wrapAll: function (html) {
            var wrap;
            if (this[0]) {
                if (isFunction(html)) {
                    html = html.call(this[0]);
                }
                wrap = jQuery(html, this[0].ownerDocument).eq(0).clone(true);
                if (this[0].parentNode) {
                    wrap.insertBefore(this[0]);
                }
                wrap.map(function () {
                    var elem = this;
                    while (elem.firstElementChild) {
                        elem = elem.firstElementChild;
                    }
                    return elem;
                }).append(this);
            }
            return this;
        },
        wrapInner: function (html) {
            if (isFunction(html)) {
                return this.each(function (i) {
                    jQuery(this).wrapInner(html.call(this, i));
                });
            }
            return this.each(function () {
                var self = jQuery(this), contents = self.contents();
                if (contents.length) {
                    contents.wrapAll(html);
                } else {
                    self.append(html);
                }
            });
        },
        wrap: function (html) {
            var htmlIsFunction = isFunction(html);
            return this.each(function (i) {
                jQuery(this).wrapAll(htmlIsFunction ? html.call(this, i) : html);
            });
        },
        unwrap: function (selector) {
            this.parent(selector).not('body').each(function () {
                jQuery(this).replaceWith(this.childNodes);
            });
            return this;
        }
    });
    jQuery.expr.pseudos.hidden = function (elem) {
        return !jQuery.expr.pseudos.visible(elem);
    };
    jQuery.expr.pseudos.visible = function (elem) {
        return !!(elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length);
    };
    jQuery.ajaxSettings.xhr = function () {
        try {
            return new window.XMLHttpRequest();
        } catch (e) {
        }
    };
    var xhrSuccessStatus = {
            0: 200,
            1223: 204
        }, xhrSupported = jQuery.ajaxSettings.xhr();
    support.cors = !!xhrSupported && 'withCredentials' in xhrSupported;
    support.ajax = xhrSupported = !!xhrSupported;
    jQuery.ajaxTransport(function (options) {
        var callback, errorCallback;
        if (support.cors || xhrSupported && !options.crossDomain) {
            return {
                send: function (headers, complete) {
                    var i, xhr = options.xhr();
                    xhr.open(options.type, options.url, options.async, options.username, options.password);
                    if (options.xhrFields) {
                        for (i in options.xhrFields) {
                            xhr[i] = options.xhrFields[i];
                        }
                    }
                    if (options.mimeType && xhr.overrideMimeType) {
                        xhr.overrideMimeType(options.mimeType);
                    }
                    if (!options.crossDomain && !headers['X-Requested-With']) {
                        headers['X-Requested-With'] = 'XMLHttpRequest';
                    }
                    for (i in headers) {
                        xhr.setRequestHeader(i, headers[i]);
                    }
                    callback = function (type) {
                        return function () {
                            if (callback) {
                                callback = errorCallback = xhr.onload = xhr.onerror = xhr.onabort = xhr.ontimeout = xhr.onreadystatechange = null;
                                if (type === 'abort') {
                                    xhr.abort();
                                } else if (type === 'error') {
                                    if (typeof xhr.status !== 'number') {
                                        complete(0, 'error');
                                    } else {
                                        complete(xhr.status, xhr.statusText);
                                    }
                                } else {
                                    complete(xhrSuccessStatus[xhr.status] || xhr.status, xhr.statusText, (xhr.responseType || 'text') !== 'text' || typeof xhr.responseText !== 'string' ? { binary: xhr.response } : { text: xhr.responseText }, xhr.getAllResponseHeaders());
                                }
                            }
                        };
                    };
                    xhr.onload = callback();
                    errorCallback = xhr.onerror = xhr.ontimeout = callback('error');
                    if (xhr.onabort !== undefined) {
                        xhr.onabort = errorCallback;
                    } else {
                        xhr.onreadystatechange = function () {
                            if (xhr.readyState === 4) {
                                window.setTimeout(function () {
                                    if (callback) {
                                        errorCallback();
                                    }
                                });
                            }
                        };
                    }
                    callback = callback('abort');
                    try {
                        xhr.send(options.hasContent && options.data || null);
                    } catch (e) {
                        if (callback) {
                            throw e;
                        }
                    }
                },
                abort: function () {
                    if (callback) {
                        callback();
                    }
                }
            };
        }
    });
    jQuery.ajaxPrefilter(function (s) {
        if (s.crossDomain) {
            s.contents.script = false;
        }
    });
    jQuery.ajaxSetup({
        accepts: { script: 'text/javascript, application/javascript, ' + 'application/ecmascript, application/x-ecmascript' },
        contents: { script: /\b(?:java|ecma)script\b/ },
        converters: {
            'text script': function (text) {
                jQuery.globalEval(text);
                return text;
            }
        }
    });
    jQuery.ajaxPrefilter('script', function (s) {
        if (s.cache === undefined) {
            s.cache = false;
        }
        if (s.crossDomain) {
            s.type = 'GET';
        }
    });
    jQuery.ajaxTransport('script', function (s) {
        if (s.crossDomain) {
            var script, callback;
            return {
                send: function (_, complete) {
                    script = jQuery('<script>').prop({
                        charset: s.scriptCharset,
                        src: s.url
                    }).on('load error', callback = function (evt) {
                        script.remove();
                        callback = null;
                        if (evt) {
                            complete(evt.type === 'error' ? 404 : 200, evt.type);
                        }
                    });
                    document.head.appendChild(script[0]);
                },
                abort: function () {
                    if (callback) {
                        callback();
                    }
                }
            };
        }
    });
    var oldCallbacks = [], rjsonp = /(=)\?(?=&|$)|\?\?/;
    jQuery.ajaxSetup({
        jsonp: 'callback',
        jsonpCallback: function () {
            var callback = oldCallbacks.pop() || jQuery.expando + '_' + nonce++;
            this[callback] = true;
            return callback;
        }
    });
    jQuery.ajaxPrefilter('json jsonp', function (s, originalSettings, jqXHR) {
        var callbackName, overwritten, responseContainer, jsonProp = s.jsonp !== false && (rjsonp.test(s.url) ? 'url' : typeof s.data === 'string' && (s.contentType || '').indexOf('application/x-www-form-urlencoded') === 0 && rjsonp.test(s.data) && 'data');
        if (jsonProp || s.dataTypes[0] === 'jsonp') {
            callbackName = s.jsonpCallback = isFunction(s.jsonpCallback) ? s.jsonpCallback() : s.jsonpCallback;
            if (jsonProp) {
                s[jsonProp] = s[jsonProp].replace(rjsonp, '$1' + callbackName);
            } else if (s.jsonp !== false) {
                s.url += (rquery.test(s.url) ? '&' : '?') + s.jsonp + '=' + callbackName;
            }
            s.converters['script json'] = function () {
                if (!responseContainer) {
                    jQuery.error(callbackName + ' was not called');
                }
                return responseContainer[0];
            };
            s.dataTypes[0] = 'json';
            overwritten = window[callbackName];
            window[callbackName] = function () {
                responseContainer = arguments;
            };
            jqXHR.always(function () {
                if (overwritten === undefined) {
                    jQuery(window).removeProp(callbackName);
                } else {
                    window[callbackName] = overwritten;
                }
                if (s[callbackName]) {
                    s.jsonpCallback = originalSettings.jsonpCallback;
                    oldCallbacks.push(callbackName);
                }
                if (responseContainer && isFunction(overwritten)) {
                    overwritten(responseContainer[0]);
                }
                responseContainer = overwritten = undefined;
            });
            return 'script';
        }
    });
    support.createHTMLDocument = function () {
        var body = document.implementation.createHTMLDocument('').body;
        body.innerHTML = '<form></form><form></form>';
        return body.childNodes.length === 2;
    }();
    jQuery.parseHTML = function (data, context, keepScripts) {
        if (typeof data !== 'string') {
            return [];
        }
        if (typeof context === 'boolean') {
            keepScripts = context;
            context = false;
        }
        var base, parsed, scripts;
        if (!context) {
            if (support.createHTMLDocument) {
                context = document.implementation.createHTMLDocument('');
                base = context.createElement('base');
                base.href = document.location.href;
                context.head.appendChild(base);
            } else {
                context = document;
            }
        }
        parsed = rsingleTag.exec(data);
        scripts = !keepScripts && [];
        if (parsed) {
            return [context.createElement(parsed[1])];
        }
        parsed = buildFragment([data], context, scripts);
        if (scripts && scripts.length) {
            jQuery(scripts).remove();
        }
        return jQuery.merge([], parsed.childNodes);
    };
    jQuery.fn.load = function (url, params, callback) {
        var selector, type, response, self = this, off = url.indexOf(' ');
        if (off > -1) {
            selector = stripAndCollapse(url.slice(off));
            url = url.slice(0, off);
        }
        if (isFunction(params)) {
            callback = params;
            params = undefined;
        } else if (params && typeof params === 'object') {
            type = 'POST';
        }
        if (self.length > 0) {
            jQuery.ajax({
                url: url,
                type: type || 'GET',
                dataType: 'html',
                data: params
            }).done(function (responseText) {
                response = arguments;
                self.html(selector ? jQuery('<div>').append(jQuery.parseHTML(responseText)).find(selector) : responseText);
            }).always(callback && function (jqXHR, status) {
                self.each(function () {
                    callback.apply(this, response || [
                        jqXHR.responseText,
                        status,
                        jqXHR
                    ]);
                });
            });
        }
        return this;
    };
    jQuery.each([
        'ajaxStart',
        'ajaxStop',
        'ajaxComplete',
        'ajaxError',
        'ajaxSuccess',
        'ajaxSend'
    ], function (i, type) {
        jQuery.fn[type] = function (fn) {
            return this.on(type, fn);
        };
    });
    jQuery.expr.pseudos.animated = function (elem) {
        return jQuery.grep(jQuery.timers, function (fn) {
            return elem === fn.elem;
        }).length;
    };
    jQuery.offset = {
        setOffset: function (elem, options, i) {
            var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition, position = jQuery.css(elem, 'position'), curElem = jQuery(elem), props = {};
            if (position === 'static') {
                elem.style.position = 'relative';
            }
            curOffset = curElem.offset();
            curCSSTop = jQuery.css(elem, 'top');
            curCSSLeft = jQuery.css(elem, 'left');
            calculatePosition = (position === 'absolute' || position === 'fixed') && (curCSSTop + curCSSLeft).indexOf('auto') > -1;
            if (calculatePosition) {
                curPosition = curElem.position();
                curTop = curPosition.top;
                curLeft = curPosition.left;
            } else {
                curTop = parseFloat(curCSSTop) || 0;
                curLeft = parseFloat(curCSSLeft) || 0;
            }
            if (isFunction(options)) {
                options = options.call(elem, i, jQuery.extend({}, curOffset));
            }
            if (options.top != null) {
                props.top = options.top - curOffset.top + curTop;
            }
            if (options.left != null) {
                props.left = options.left - curOffset.left + curLeft;
            }
            if ('using' in options) {
                options.using.call(elem, props);
            } else {
                curElem.css(props);
            }
        }
    };
    jQuery.fn.extend({
        offset: function (options) {
            if (arguments.length) {
                return options === undefined ? this : this.each(function (i) {
                    jQuery.offset.setOffset(this, options, i);
                });
            }
            var rect, win, elem = this[0];
            if (!elem) {
                return;
            }
            if (!elem.getClientRects().length) {
                return {
                    top: 0,
                    left: 0
                };
            }
            rect = elem.getBoundingClientRect();
            win = elem.ownerDocument.defaultView;
            return {
                top: rect.top + win.pageYOffset,
                left: rect.left + win.pageXOffset
            };
        },
        position: function () {
            if (!this[0]) {
                return;
            }
            var offsetParent, offset, doc, elem = this[0], parentOffset = {
                    top: 0,
                    left: 0
                };
            if (jQuery.css(elem, 'position') === 'fixed') {
                offset = elem.getBoundingClientRect();
            } else {
                offset = this.offset();
                doc = elem.ownerDocument;
                offsetParent = elem.offsetParent || doc.documentElement;
                while (offsetParent && (offsetParent === doc.body || offsetParent === doc.documentElement) && jQuery.css(offsetParent, 'position') === 'static') {
                    offsetParent = offsetParent.parentNode;
                }
                if (offsetParent && offsetParent !== elem && offsetParent.nodeType === 1) {
                    parentOffset = jQuery(offsetParent).offset();
                    parentOffset.top += jQuery.css(offsetParent, 'borderTopWidth', true);
                    parentOffset.left += jQuery.css(offsetParent, 'borderLeftWidth', true);
                }
            }
            return {
                top: offset.top - parentOffset.top - jQuery.css(elem, 'marginTop', true),
                left: offset.left - parentOffset.left - jQuery.css(elem, 'marginLeft', true)
            };
        },
        offsetParent: function () {
            return this.map(function () {
                var offsetParent = this.offsetParent;
                while (offsetParent && jQuery.css(offsetParent, 'position') === 'static') {
                    offsetParent = offsetParent.offsetParent;
                }
                return offsetParent || documentElement;
            });
        }
    });
    jQuery.each({
        scrollLeft: 'pageXOffset',
        scrollTop: 'pageYOffset'
    }, function (method, prop) {
        var top = 'pageYOffset' === prop;
        jQuery.fn[method] = function (val) {
            return access(this, function (elem, method, val) {
                var win;
                if (isWindow(elem)) {
                    win = elem;
                } else if (elem.nodeType === 9) {
                    win = elem.defaultView;
                }
                if (val === undefined) {
                    return win ? win[prop] : elem[method];
                }
                if (win) {
                    win.scrollTo(!top ? val : win.pageXOffset, top ? val : win.pageYOffset);
                } else {
                    elem[method] = val;
                }
            }, method, val, arguments.length);
        };
    });
    jQuery.each([
        'top',
        'left'
    ], function (i, prop) {
        jQuery.cssHooks[prop] = addGetHookIf(support.pixelPosition, function (elem, computed) {
            if (computed) {
                computed = curCSS(elem, prop);
                return rnumnonpx.test(computed) ? jQuery(elem).position()[prop] + 'px' : computed;
            }
        });
    });
    jQuery.each({
        Height: 'height',
        Width: 'width'
    }, function (name, type) {
        jQuery.each({
            padding: 'inner' + name,
            content: type,
            '': 'outer' + name
        }, function (defaultExtra, funcName) {
            jQuery.fn[funcName] = function (margin, value) {
                var chainable = arguments.length && (defaultExtra || typeof margin !== 'boolean'), extra = defaultExtra || (margin === true || value === true ? 'margin' : 'border');
                return access(this, function (elem, type, value) {
                    var doc;
                    if (isWindow(elem)) {
                        return funcName.indexOf('outer') === 0 ? elem['inner' + name] : elem.document.documentElement['client' + name];
                    }
                    if (elem.nodeType === 9) {
                        doc = elem.documentElement;
                        return Math.max(elem.body['scroll' + name], doc['scroll' + name], elem.body['offset' + name], doc['offset' + name], doc['client' + name]);
                    }
                    return value === undefined ? jQuery.css(elem, type, extra) : jQuery.style(elem, type, value, extra);
                }, type, chainable ? margin : undefined, chainable);
            };
        });
    });
    jQuery.each(('blur focus focusin focusout resize scroll click dblclick ' + 'mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave ' + 'change select submit keydown keypress keyup contextmenu').split(' '), function (i, name) {
        jQuery.fn[name] = function (data, fn) {
            return arguments.length > 0 ? this.on(name, null, data, fn) : this.trigger(name);
        };
    });
    jQuery.fn.extend({
        hover: function (fnOver, fnOut) {
            return this.mouseenter(fnOver).mouseleave(fnOut || fnOver);
        }
    });
    jQuery.fn.extend({
        bind: function (types, data, fn) {
            return this.on(types, null, data, fn);
        },
        unbind: function (types, fn) {
            return this.off(types, null, fn);
        },
        delegate: function (selector, types, data, fn) {
            return this.on(types, selector, data, fn);
        },
        undelegate: function (selector, types, fn) {
            return arguments.length === 1 ? this.off(selector, '**') : this.off(types, selector || '**', fn);
        }
    });
    jQuery.proxy = function (fn, context) {
        var tmp, args, proxy;
        if (typeof context === 'string') {
            tmp = fn[context];
            context = fn;
            fn = tmp;
        }
        if (!isFunction(fn)) {
            return undefined;
        }
        args = slice.call(arguments, 2);
        proxy = function () {
            return fn.apply(context || this, args.concat(slice.call(arguments)));
        };
        proxy.guid = fn.guid = fn.guid || jQuery.guid++;
        return proxy;
    };
    jQuery.holdReady = function (hold) {
        if (hold) {
            jQuery.readyWait++;
        } else {
            jQuery.ready(true);
        }
    };
    jQuery.isArray = Array.isArray;
    jQuery.parseJSON = JSON.parse;
    jQuery.nodeName = nodeName;
    jQuery.isFunction = isFunction;
    jQuery.isWindow = isWindow;
    jQuery.camelCase = camelCase;
    jQuery.type = toType;
    jQuery.now = Date.now;
    jQuery.isNumeric = function (obj) {
        var type = jQuery.type(obj);
        return (type === 'number' || type === 'string') && !isNaN(obj - parseFloat(obj));
    };
    if (typeof define === 'function' && define.amd) {
        define('jquery@3.3.1#dist/jquery', [], function () {
            return jQuery;
        });
    }
    var _jQuery = window.jQuery, _$ = window.$;
    jQuery.noConflict = function (deep) {
        if (window.$ === jQuery) {
            window.$ = _$;
        }
        if (deep && window.jQuery === jQuery) {
            window.jQuery = _jQuery;
        }
        return jQuery;
    };
    if (!noGlobal) {
        window.jQuery = window.$ = jQuery;
    }
    return jQuery;
}));
/*can-dom-events@1.1.1#helpers/add-event-jquery*/
define('can-dom-events@1.1.1#helpers/add-event-jquery', [
    'require',
    'exports',
    'module',
    './util'
], function (require, exports, module) {
    'use strict';
    var util = require('./util');
    module.exports = function addEventJQuery(jQuery, customEvent, customEventType) {
        customEventType = customEventType || customEvent.defaultEventType;
        var existingEvent = jQuery.event.special[customEventType];
        if (existingEvent) {
            throw new Error('Special event type "' + customEventType + '" already exists');
        }
        var domEvents = {
            addEventListener: function (target, eventType, handler) {
                $(target).on(eventType, handler);
            },
            removeEventListener: function (target, eventType, handler) {
                $(target).off(eventType, handler);
            },
            dispatch: function (target) {
                var event = util.createEvent.apply(null, arguments);
                $(target).trigger(event);
            }
        };
        var event = {
            add: function (handleObj) {
                var target = this;
                var eventType = handleObj.origType;
                var handler = handleObj.handler;
                customEvent.addEventListener.call(domEvents, target, eventType, handler);
            },
            remove: function (handleObj) {
                var target = this;
                var eventType = handleObj.origType;
                var handler = handleObj.handler;
                customEvent.removeEventListener.call(domEvents, target, eventType, handler);
            }
        };
        jQuery.event.special[customEventType] = event;
        return function removeEventJQuery() {
            delete jQuery.event.special[customEventType];
        };
    };
});
/*can-dom-events@1.1.1#helpers/add-event-jquery-test*/
define('can-dom-events@1.1.1#helpers/add-event-jquery-test', [
    'require',
    'exports',
    'module',
    'steal-qunit',
    'jquery',
    './add-event-jquery'
], function (require, exports, module) {
    var unit = require('steal-qunit');
    var jQuery = require('jquery');
    var addEvent = require('./add-event-jquery');
    unit.module('add-event-jquery');
    var mockEvent = function (firstEvent, secondEvent, addSpy, removeSpy) {
        return {
            defaultEventName: firstEvent,
            addEventListener: function (target, eventName, handler) {
                addSpy(this, arguments);
                this.addEventListener(target, secondEvent, handler);
            },
            removeEventListener: function (target, eventName, handler) {
                removeSpy(this, arguments);
                this.removeEventListener(target, secondEvent, handler);
            }
        };
    };
    unit.test('should work with the jQuery', function (assert) {
        assert.expect(1 + 2 * 3);
        var input = document.createElement('input');
        var handler = function () {
            assert.ok(true, 'handler should be called');
        };
        var customEventType = 'boi3';
        var lowerEventType = 'boi2';
        var hookSpy = function (context, args) {
            var target = args[0];
            var eventType = args[1];
            var callback = args[2];
            assert.equal(target, input, 'input should be the target');
            assert.equal(eventType, customEventType, 'event type should match custom event type');
            assert.equal(callback, handler, 'callback should be the passed handler');
        };
        var event = mockEvent(customEventType, lowerEventType, hookSpy, hookSpy);
        var removeEvent = addEvent(jQuery, event, customEventType);
        $(input).on(customEventType, handler);
        $(input).trigger(lowerEventType);
        $(input).on(customEventType, handler);
        removeEvent();
    });
});
/*can-dom-events@1.1.1#helpers/util-test*/
define('can-dom-events@1.1.1#helpers/util-test', [
    'require',
    'exports',
    'module',
    'steal-qunit',
    './util'
], function (require, exports, module) {
    var unit = require('steal-qunit');
    var util = require('./util');
    unit.module('util');
    unit.test('util.isDomEventTarget works', function (assert) {
        var element = document.createElement('div');
        assert.equal(util.isDomEventTarget(element), true, 'Elements work');
        assert.equal(util.isDomEventTarget(document), true, 'Documents work');
        assert.equal(util.isDomEventTarget(window), true, 'Window works');
        assert.equal(util.isDomEventTarget(8), false, 'Numbers should not work');
        assert.equal(util.isDomEventTarget('foo'), false, 'Strings should not work');
        assert.equal(util.isDomEventTarget({ a: 1 }), false, 'Plain objects should not work');
        var textNode = document.createTextNode('boi');
        assert.equal(util.isDomEventTarget(textNode), false, 'Text nodes should not work');
    });
    unit.test('util.createEvent should merge the eventData object properties', function (assert) {
        var target = document.createElement('input');
        var enterCode = 13;
        var event = util.createEvent(target, { keyCode: enterCode });
        assert.equal(event.keyCode, enterCode);
    });
    unit.test('util.createEvent should use eventData.type as the eventType', function (assert) {
        var target = document.createElement('input');
        var eventType = 'foo';
        var event = util.createEvent(target, { type: eventType });
        assert.equal(event.type, eventType);
    });
});
/*can-dom-events@1.1.1#can-dom-events-test*/
define('can-dom-events@1.1.1#can-dom-events-test', [
    'require',
    'exports',
    'module',
    'steal-qunit',
    './can-dom-events',
    './helpers/make-event-registry-test',
    './helpers/add-event-compat-test',
    './helpers/add-event-jquery-test',
    './helpers/util-test'
], function (require, exports, module) {
    var unit = require('steal-qunit');
    var domEvents = require('./can-dom-events');
    unit.module('can-dom-events');
    unit.test('domEvents.addEventListener works', function (assert) {
        assert.expect(1);
        var input = document.createElement('input');
        var eventType = 'click';
        var handler = function () {
            assert.ok(true, 'event handler should be called');
        };
        domEvents.addEventListener(input, eventType, handler);
        var event = new Event(eventType);
        input.dispatchEvent(event);
        domEvents.removeEventListener(input, eventType, handler);
    });
    unit.test('domEvents.removeEventListener works', function (assert) {
        assert.expect(1);
        var input = document.createElement('input');
        var eventType = 'click';
        var handler = function () {
            assert.ok(true, 'event handler should be called');
        };
        domEvents.addEventListener(input, eventType, handler);
        var event = new Event(eventType);
        input.dispatchEvent(event);
        domEvents.removeEventListener(input, eventType, handler);
        var event2 = new Event(eventType);
        input.dispatchEvent(event2);
    });
    unit.test('domEvents.dispatch works', function (assert) {
        assert.expect(1);
        var input = document.createElement('input');
        var eventType = 'click';
        var handler = function () {
            assert.ok(true, 'event handler should be called');
        };
        input.addEventListener(eventType, handler);
        domEvents.dispatch(input, eventType);
        input.removeEventListener(eventType, handler);
    });
    unit.test('domEvents.addDelegateListener works', function (assert) {
        var done = assert.async();
        var grandparent = document.createElement('div');
        var parent = document.createElement('div');
        var child = document.createElement('input');
        grandparent.appendChild(parent);
        parent.appendChild(child);
        domEvents.addDelegateListener(grandparent, 'click', 'input', function handler(event) {
            domEvents.removeDelegateListener(grandparent, 'click', 'input', handler);
            assert.equal(event.type, 'click', 'should be click event');
            assert.equal(event.target, child, 'should have input as the event.target');
            done();
        });
        domEvents.dispatch(child, 'click');
    });
    unit.test('domEvents.removeDelegateListener works', function (assert) {
        assert.expect(2);
        var grandparent = document.createElement('div');
        var parent = document.createElement('div');
        var child = document.createElement('input');
        grandparent.appendChild(parent);
        parent.appendChild(child);
        var handler = function handler(event) {
            assert.equal(event.type, 'click', 'should be click event');
            assert.equal(event.target, child, 'should have input as the event.target');
        };
        domEvents.addDelegateListener(grandparent, 'click', 'input', handler);
        domEvents.dispatch(child, 'click');
        domEvents.removeDelegateListener(grandparent, 'click', 'input', handler);
        domEvents.dispatch(child, 'click');
    });
    unit.test('can call removeDelegateListener without having previously called addDelegateListener', function (assert) {
        var ul = document.createElement('ul');
        domEvents.removeDelegateListener(ul, 'click', 'li', function () {
        });
        assert.ok(true, 'Calling removeDelegateListener does not throw');
    });
    unit.test('delegate events: focus should work using capture phase', function (assert) {
        var done = assert.async();
        var parent = document.createElement('div');
        var child = document.createElement('input');
        parent.appendChild(child);
        document.getElementById('qunit-fixture').appendChild(parent);
        domEvents.addDelegateListener(parent, 'focus', 'input', function handler(event) {
            domEvents.removeDelegateListener.call(parent, 'focus', 'input', handler);
            assert.equal(event.type, 'focus', 'should be focus event');
            assert.equal(event.target, child, 'should have input as event target');
            done();
        });
        domEvents.dispatch(child, 'focus', false);
    });
    unit.test('delegate events: blur should work using capture phase', function (assert) {
        var done = assert.async();
        var parent = document.createElement('div');
        var child = document.createElement('input');
        parent.appendChild(child);
        document.getElementById('qunit-fixture').appendChild(parent);
        domEvents.addDelegateListener(parent, 'blur', 'input', function handler(event) {
            domEvents.removeDelegateListener.call(parent, 'blur', 'input', handler);
            assert.equal(event.type, 'blur', 'should be blur event');
            assert.equal(event.target, child, 'should have input as event target');
            done();
        });
        domEvents.dispatch(child, 'blur', false);
    });
    require('./helpers/make-event-registry-test');
    require('./helpers/add-event-compat-test');
    require('./helpers/add-event-jquery-test');
    require('./helpers/util-test');
});
/*can-event-dom-enter@2.1.0#compat*/
define('can-event-dom-enter@2.1.0#compat', [
    'require',
    'exports',
    'module',
    'can-dom-events/helpers/add-event-compat',
    './can-event-dom-enter'
], function (require, exports, module) {
    var addEventCompat = require('can-dom-events/helpers/add-event-compat');
    var radioChange = require('./can-event-dom-enter');
    module.exports = function (domEvents, eventType) {
        return addEventCompat(domEvents, radioChange, eventType);
    };
});
/*can-event-dom-enter@2.1.0#can-event-dom-enter-test*/
define('can-event-dom-enter@2.1.0#can-event-dom-enter-test', [
    'require',
    'exports',
    'module',
    'steal-qunit',
    'can-dom-events',
    './can-event-dom-enter',
    './compat',
    'can-namespace'
], function (require, exports, module) {
    'use strict';
    var unit = require('steal-qunit');
    var domEvents = require('can-dom-events');
    var definition = require('./can-event-dom-enter');
    var compat = require('./compat');
    var canNamespace = require('can-namespace');
    var enterEventType = 'test-enter';
    function makeEnterEvent() {
        try {
            return new window.KeyboardEvent('keyup', { key: 'Enter' });
        } catch (e) {
            var event = document.createEvent('KeyboardEvent');
            event.initKeyboardEvent('keyup', true, false, document.parentWindow, 'Enter', 16, '', false, 'en-US');
            return event;
        }
    }
    function pressKey(target, keyCode) {
        var keyupEvent = {
            type: 'keyup',
            keyCode: keyCode
        };
        domEvents.dispatch(target, keyupEvent);
    }
    function pressEnter(target) {
        pressKey(target, 13);
    }
    var supportsKeyboardEvents = function () {
        if (typeof KeyboardEvent === 'undefined') {
            return false;
        }
        try {
            var eventType = 'keyup';
            var isSupported = false;
            var target = document.createElement('input');
            var handler = function (event) {
                if (event.key === 'Enter') {
                    isSupported = true;
                }
            };
            target.addEventListener(eventType, handler);
            target.dispatch(makeEnterEvent());
            target.removeEventListener(eventType, handler);
            return isSupported;
        } catch (error) {
            return false;
        }
    };
    var compatWithNew = {
        name: 'compat with can-dom-events',
        domEvents: domEvents,
        setup: function () {
            this.removeEvent = compat(domEvents, enterEventType);
        },
        teardown: function () {
            this.removeEvent();
        }
    };
    var rawNewDomEvents = {
        name: 'plain with can-dom-events',
        domEvents: domEvents,
        setup: function () {
            this.removeEvent = domEvents.addEvent(definition, enterEventType);
        },
        teardown: function () {
            this.removeEvent();
        }
    };
    var suites = [
        compatWithNew,
        rawNewDomEvents
    ];
    function runTests(mod) {
        unit.module(mod.name, {
            setup: mod.setup,
            teardown: mod.teardown
        });
        var domEvents = mod.domEvents;
        unit.test('calls enter event handler when enter key is pressed', function (assert) {
            assert.expect(1);
            var input = document.createElement('input');
            domEvents.addEventListener(input, enterEventType, function () {
                assert.ok(true, 'enter key detected');
            });
            pressEnter(input);
        });
        if (supportsKeyboardEvents) {
            unit.test('works for KeyboardEvent\'s', function (assert) {
                assert.expect(1);
                var input = document.createElement('input');
                domEvents.addEventListener(input, enterEventType, function handler() {
                    domEvents.removeEventListener(input, enterEventType, handler);
                    assert.ok(true, 'enter key detected');
                });
                domEvents.dispatch(input, makeEnterEvent());
            });
        }
        unit.test('does not call enter event handler when a different key is pressed', function (assert) {
            assert.expect(1);
            var input = document.createElement('input');
            domEvents.addEventListener(input, enterEventType, function handler() {
                domEvents.removeEventListener(input, enterEventType, handler);
                assert.ok(true, 'passed');
            });
            pressKey(input, 27);
            pressEnter(input);
        });
        unit.test('successfully removes enter event handler', function (assert) {
            assert.expect(1);
            var input = document.createElement('input');
            var enterEventHandler = function () {
                assert.ok(true);
            };
            domEvents.addEventListener(input, enterEventType, enterEventHandler);
            pressEnter(input);
            domEvents.removeEventListener(input, enterEventType, enterEventHandler);
            pressEnter(input);
        });
        unit.test('can have multiple enter event handlers and can remove them seperately', function (assert) {
            assert.expect(5);
            var input = document.createElement('input');
            var generateEvtHandler = function () {
                return function () {
                    assert.ok(true);
                };
            };
            var firstEvtHandler = generateEvtHandler();
            var secondEvtHandler = generateEvtHandler();
            domEvents.addEventListener(input, enterEventType, firstEvtHandler);
            domEvents.addEventListener(input, enterEventType, secondEvtHandler);
            pressEnter(input);
            pressEnter(input);
            domEvents.removeEventListener(input, enterEventType, firstEvtHandler);
            pressEnter(input);
            domEvents.removeEventListener(input, enterEventType, secondEvtHandler);
            pressEnter(input);
        });
        unit.test('still handles other event types appropriately', function (assert) {
            assert.expect(1);
            var button = document.createElement('button');
            domEvents.addEventListener(button, 'focus', function () {
                assert.ok(true, 'handles focus event still');
            });
            domEvents.dispatch(button, 'focus');
        });
    }
    suites.forEach(runTests);
    unit.module('can-event-dom-enter plain');
    unit.test('can use custom addEventListener and removeEventListener (#3)', function (assert) {
        assert.expect(2);
        var handler = function () {
        };
        var button = document.createElement('button');
        definition.addEventListener.call({
            addEventListener: function () {
                assert.ok(true, 'called custom addEventListener');
            }
        }, button, 'enter', handler);
        definition.removeEventListener.call({
            removeEventListener: function () {
                assert.ok(true, 'called custom removeEventListener');
            }
        }, button, 'enter', handler);
    });
    unit.test('adds event to can-namespace', function (assert) {
        assert.equal(canNamespace.domEventEnter, definition, 'event is added');
    });
});
/*can-event-dom-radiochange@2.1.0#compat*/
define('can-event-dom-radiochange@2.1.0#compat', [
    'require',
    'exports',
    'module',
    'can-dom-events/helpers/add-event-compat',
    './can-event-dom-radiochange'
], function (require, exports, module) {
    var addEventCompat = require('can-dom-events/helpers/add-event-compat');
    var radioChange = require('./can-event-dom-radiochange');
    module.exports = function (domEvents, eventType) {
        return addEventCompat(domEvents, radioChange, eventType);
    };
});
/*can-event-dom-radiochange@2.1.0#can-event-dom-radiochange-test*/
define('can-event-dom-radiochange@2.1.0#can-event-dom-radiochange-test', [
    'require',
    'exports',
    'module',
    'steal-qunit',
    'can-dom-events',
    './can-event-dom-radiochange',
    './compat',
    'can-namespace'
], function (require, exports, module) {
    'use strict';
    var QUnit = require('steal-qunit');
    var domEvents = require('can-dom-events');
    var definition = require('./can-event-dom-radiochange');
    var compat = require('./compat');
    var canNamespace = require('can-namespace');
    function fixture() {
        return document.getElementById('qunit-fixture');
    }
    var compatWithNew = {
        name: 'compat with can-dom-events',
        domEvents: domEvents,
        setup: function () {
            this.removeEvent = compat(domEvents);
        },
        teardown: function () {
            this.removeEvent();
        }
    };
    var rawNewDomEvents = {
        name: 'plain with can-dom-events',
        domEvents: domEvents,
        setup: function () {
            this.removeEvent = domEvents.addEvent(definition);
        },
        teardown: function () {
            this.removeEvent();
        }
    };
    var suites = [
        compatWithNew,
        rawNewDomEvents
    ];
    function runTests(mod) {
        QUnit.module(mod.name, {
            setup: mod.setup,
            teardown: mod.teardown
        });
        var domEvents = mod.domEvents;
        test('subscription to an untracked radio should call listener', function (assert) {
            assert.expect(1);
            var listener = document.createElement('input');
            listener.id = 'listener';
            listener.type = 'radio';
            listener.name = 'myfield';
            domEvents.addEventListener(listener, 'radiochange', function handler() {
                assert.ok(true, 'called from other element');
                domEvents.removeEventListener(listener, 'radiochange', handler);
            });
            var radio = document.createElement('input');
            radio.id = 'radio';
            radio.type = 'radio';
            radio.name = 'myfield';
            fixture().appendChild(listener);
            fixture().appendChild(radio);
            radio.setAttribute('checked', 'checked');
            domEvents.dispatch(radio, 'change');
        });
        test('subscription to a tracked radio should call itself', function (assert) {
            assert.expect(1);
            var radio = document.createElement('input');
            radio.id = 'selfish';
            radio.type = 'radio';
            radio.name = 'anynamejustsothereisaname';
            domEvents.addEventListener(radio, 'radiochange', function handler() {
                assert.ok(true, 'called from self');
                domEvents.removeEventListener(radio, 'radiochange', handler);
            });
            fixture().appendChild(radio);
            radio.setAttribute('checked', 'checked');
            domEvents.dispatch(radio, 'change');
        });
    }
    suites.forEach(runTests);
    QUnit.module('can-event-dom-radiochange plain');
    test('adds event to can-namespace', function (assert) {
        assert.equal(canNamespace.domEventRadioChange, definition, 'event is added');
    });
});
/*can-event-queue@1.0.0#map/map-test*/
define('can-event-queue@1.0.0#map/map-test', [
    'require',
    'exports',
    'module',
    'steal-qunit',
    './map',
    'can-queues',
    'can-dom-events',
    'can-symbol',
    'can-reflect'
], function (require, exports, module) {
    var QUnit = require('steal-qunit');
    var eventQueue = require('./map');
    var queues = require('can-queues');
    var domEvents = require('can-dom-events');
    var canSymbol = require('can-symbol');
    var canReflect = require('can-reflect');
    var onlyDevTest = steal.isEnv('production') ? QUnit.skip : QUnit.test;
    QUnit.module('can-event-queue/map', {
        setup: function () {
        },
        teardown: function () {
        }
    });
    QUnit.test('basics', function () {
        var collecting;
        var secondFired = false;
        var obj = eventQueue({});
        obj.on('first', function (ev, arg1, arg2) {
            QUnit.equal(arg1, 1, 'first arg');
            QUnit.equal(arg2, 2, 'second arg');
            QUnit.ok(!collecting, 'not collecting b/c we\'re not in a batch yet');
            obj.dispatch('second');
            QUnit.equal(secondFired, false, 'don\'t fire yet, put in next batch');
        });
        obj.on('second', function (ev) {
            secondFired = true;
            QUnit.ok(ev.batchNum, 'got a batch number');
        });
        queues.batch.start();
        obj.dispatch('first', [
            1,
            2
        ]);
        queues.batch.stop();
    });
    test('Everything is part of a batch', function () {
        var obj = eventQueue({});
        obj.on('foo', function (ev) {
            ok(ev.batchNum);
        });
        obj.dispatch('foo');
    });
    QUnit.test('flushing works (#18)', 3, function () {
        var firstFired, secondFired, thirdFired;
        var obj = eventQueue({});
        obj.on('first', function () {
            eventQueue.flush();
            QUnit.ok(firstFired, 'first fired');
            QUnit.ok(secondFired, 'second fired');
            QUnit.ok(thirdFired, 'third fired');
        });
        obj.on('first', function () {
            firstFired = true;
        });
        obj.on('second', function () {
            secondFired = true;
        });
        obj.on('third', function () {
            thirdFired = true;
        });
        queues.batch.start();
        obj.dispatch('first');
        obj.dispatch('second');
        obj.dispatch('third');
        queues.batch.stop();
    });
    QUnit.test('flushing a future batch (#18)', 3, function () {
        var firstFired, secondFired, thirdFired;
        var obj = eventQueue({});
        obj.on('first', function () {
            queues.batch.start();
            obj.dispatch('second');
            obj.dispatch('third');
            queues.batch.stop();
            eventQueue.flush();
            QUnit.ok(firstFired, 'first fired');
            QUnit.ok(secondFired, 'second fired');
            QUnit.ok(thirdFired, 'third fired');
        });
        obj.on('first', function () {
            firstFired = true;
        });
        obj.on('second', function () {
            secondFired = true;
        });
        obj.on('third', function () {
            thirdFired = true;
        });
        queues.batch.start();
        obj.dispatch('first');
        queues.batch.stop();
    });
    if (typeof document !== 'undefined') {
        QUnit.test('can listen to DOM events', 1, function () {
            var el = document.createElement('div');
            var handler = function () {
                QUnit.ok(true, 'click dispatched');
            };
            eventQueue.on.call(el, 'click', handler);
            domEvents.dispatch(el, 'click');
            eventQueue.off.call(el, 'click', handler);
            domEvents.dispatch(el, 'click');
        });
    }
    QUnit.test('handler-less unbind', function () {
        var obj = eventQueue({});
        obj.addEventListener('first', function () {
        });
        obj.addEventListener('first', function () {
        }, 'notify');
        var handlers = obj[canSymbol.for('can.meta')].handlers;
        QUnit.equal(handlers.get(['first']).length, 2, '2 first handlers');
        obj.removeEventListener('first');
        QUnit.equal(handlers.get(['first']).length, 0, 'first handlers removed');
    });
    QUnit.test('key-less unbind', function () {
        var obj = eventQueue({});
        obj.addEventListener('first', function () {
        });
        obj.addEventListener('first', function () {
        }, 'notify');
        obj.addEventListener('second', function () {
        });
        obj.addEventListener('second', function () {
        }, 'notify');
        canReflect.onKeyValue(obj, 'first', function () {
        });
        canReflect.onKeyValue(obj, 'first', function () {
        }, 'notify');
        canReflect.onKeyValue(obj, 'second', function () {
        });
        canReflect.onKeyValue(obj, 'second', function () {
        }, 'notify');
        var handlers = obj[canSymbol.for('can.meta')].handlers;
        QUnit.equal(handlers.get([]).length, 8, '2 first handlers');
        obj.removeEventListener();
        QUnit.equal(handlers.get([]).length, 4, 'first handlers removed');
    });
    QUnit.test('@@can.isBound symbol', function () {
        var obj = eventQueue({});
        var handler = function () {
        };
        QUnit.ok(!obj[canSymbol.for('can.isBound')](), 'Object is not bound initially');
        obj.on('first', handler);
        QUnit.ok(obj[canSymbol.for('can.isBound')](), 'Object is bound after adding listener');
        obj.off('first', handler);
        QUnit.ok(!obj[canSymbol.for('can.isBound')](), 'Object is not bound after removing listener');
    });
    test('listenTo and stopListening', 9, function () {
        var parent = eventQueue({});
        var child1 = eventQueue({});
        var child2 = eventQueue({});
        var change1WithId = 0;
        parent.listenTo(child1, 'change', function () {
            change1WithId++;
            if (change1WithId === 1) {
                ok(true, 'child 1 handler with id called');
            } else {
                ok(false, 'child 1 handler with id should only be called once');
            }
        });
        child1.bind('change', function () {
            ok(true, 'child 1 handler without id called');
        });
        var foo1WidthId = 0;
        parent.listenTo(child1, 'foo', function () {
            foo1WidthId++;
            if (foo1WidthId === 1) {
                ok(true, 'child 1 foo handler with id called');
            } else {
                ok(false, 'child 1 foo handler should not be called twice');
            }
        });
        (function () {
            var okToCall = true;
            parent.listenTo(child2, 'change', function () {
                ok(okToCall, 'child 2 handler with id called');
                okToCall = false;
            });
        }());
        child2.bind('change', function () {
            ok(true, 'child 2 handler without id called');
        });
        parent.listenTo(child2, 'foo', function () {
            ok(true, 'child 2 foo handler with id called');
        });
        eventQueue.dispatch.call(child1, 'change');
        eventQueue.dispatch.call(child1, 'foo');
        eventQueue.dispatch.call(child2, 'change');
        eventQueue.dispatch.call(child2, 'foo');
        parent.stopListening(child1);
        parent.stopListening(child2, 'change');
        eventQueue.dispatch.call(child1, 'change');
        eventQueue.dispatch.call(child1, 'foo');
        eventQueue.dispatch.call(child2, 'change');
        eventQueue.dispatch.call(child2, 'foo');
    });
    test('stopListening on something you\'ve never listened to ', function () {
        var parent = eventQueue({});
        var child = eventQueue({});
        parent.listenTo({
            addEventListener: function () {
            }
        }, 'foo');
        parent.stopListening(child, 'change');
        ok(true, 'did not error');
    });
    test('One will listen to an event once, then unbind', function () {
        var mixin = 0;
        var obj = eventQueue({});
        obj.one('mixin', function () {
            mixin++;
        });
        obj.dispatch('mixin');
        obj.dispatch('mixin');
        obj.dispatch('mixin');
        equal(mixin, 1, 'one should only fire a handler once (mixin)');
    });
    onlyDevTest('getWhatIChange', function (assert) {
        var observable = eventQueue({});
        var getWhatIChange = observable[canSymbol.for('can.getWhatIChange')].bind(observable);
        assert.equal(typeof getWhatIChange(), 'undefined', 'should return undefined if handlers is empty');
        var getChanges = function (value) {
            return function () {
                return { valueDependencies: new Set([value]) };
            };
        };
        var mutateHandler = function mutateHandler() {
        };
        var domUIHandler = function domUIHandler() {
        };
        var notifyHandler = function notifyHandler() {
        };
        var a = function a() {
        };
        var b = function b() {
        };
        var getChangesSymbol = canSymbol.for('can.getChangesDependencyRecord');
        mutateHandler[getChangesSymbol] = getChanges(a);
        domUIHandler[getChangesSymbol] = getChanges(b);
        notifyHandler[getChangesSymbol] = getChanges(a);
        observable.addEventListener('first', mutateHandler);
        canReflect.onKeyValue(observable, 'first', domUIHandler, 'domUI');
        canReflect.onKeyValue(observable, 'first', notifyHandler, 'notify');
        var whatIChange = getWhatIChange('first');
        assert.deepEqual(whatIChange.mutate, {
            valueDependencies: new Set([
                a,
                b
            ])
        }, 'domUI and mutate queues handlers deps should be included in .mutate');
        assert.deepEqual(whatIChange.derive, { valueDependencies: new Set([a]) }, 'notify queue handlers deps should be included in .derive');
    });
    test('One will listen to an event once, then unbind', 0, function () {
        var mixin = 0;
        var obj1 = eventQueue({}), obj2 = eventQueue({});
        obj1.listenTo(obj2, 'foo', function () {
            QUnit.ok(false, 'this handler should not be called');
        });
        obj1.stopListening();
        obj2.dispatch('foo');
    });
    test('unbind undefined with stopListening and onValue', function () {
        var HANDLER = function () {
        };
        var value = canReflect.assignSymbols({}, {
            'can.onValue': function (handler) {
                QUnit.equal(handler, HANDLER, 'handler onValue');
            },
            'can.offValue': function (handler) {
                QUnit.equal(handler, HANDLER, 'handler offValue');
            }
        });
        var obj = eventQueue({});
        obj.listenTo(value, HANDLER);
        obj.stopListening();
    });
    test('stopListeningArgumentsToKeys', function () {
        var getKeys = eventQueue.stopListeningArgumentsToKeys;
        var obj = {};
        var that = {
            context: obj,
            defaultQueue: 'mutate'
        };
        var obj2 = {};
        var handler = function () {
        };
        QUnit.deepEqual(getKeys.call(that), [], 'obj.stopListening()');
        QUnit.deepEqual(getKeys.call(that, obj2), [obj2], 'obj.stopListening(obj2)');
        QUnit.deepEqual(getKeys.call(that, 'event'), [
            obj,
            'event'
        ], 'obj.stopListening(\'event\')');
        QUnit.deepEqual(getKeys.call(that, 'event', handler), [
            obj,
            'event',
            'mutate',
            handler
        ], 'obj.stopListening(\'event\', handler)');
        QUnit.deepEqual(getKeys.call(that, 'event', handler, 'notify'), [
            obj,
            'event',
            'notify',
            handler
        ], 'obj.stopListening(\'event\', handler,\'notify\')');
        QUnit.deepEqual(getKeys.call(that, obj2, handler), [
            obj2,
            undefined,
            'mutate',
            handler
        ], 'obj.stopListening(obj2, handler)');
        QUnit.deepEqual(getKeys.call(that, obj2, handler, 'notify'), [
            obj2,
            undefined,
            'notify',
            handler
        ], 'obj.stopListening(obj2, handler, notify)');
        QUnit.deepEqual(getKeys.call(that, 'event', 'notify'), [
            obj,
            'event',
            'notify'
        ], 'obj.stopListening(\'event\', \'notify\')');
    });
    test('listenTo and stopListening takes a queueName', function () {
        var CALLS = [];
        var obj = eventQueue({});
        var handler = function () {
            CALLS.push('first');
        };
        var secondHandler = function () {
            CALLS.push('second');
        };
        obj.listenTo('first', handler, 'notify');
        obj.dispatch('first');
        obj.stopListening('first', handler, 'notify');
        obj.dispatch('first');
        QUnit.deepEqual(CALLS, ['first'], 'event, handler, queue');
        CALLS = [];
        obj.listenTo('first', handler, 'notify');
        obj.listenTo('first', secondHandler, 'mutate');
        obj.dispatch('first');
        obj.stopListening('first');
        obj.dispatch('first');
        QUnit.deepEqual(CALLS, [
            'first',
            'second'
        ], 'event');
        CALLS = [];
        obj.listenTo('first', handler, 'notify');
        obj.listenTo('first', secondHandler, 'mutate');
        obj.dispatch('first');
        obj.stopListening('first', 'notify');
        obj.dispatch('first');
        QUnit.deepEqual(CALLS, [
            'first',
            'second',
            'second'
        ], 'event, queue');
        CALLS = [];
    });
});
/*can-event-queue@1.0.0#type/type-test*/
define('can-event-queue@1.0.0#type/type-test', [
    'require',
    'exports',
    'module',
    'steal-qunit',
    '../map/map',
    'can-symbol',
    './type'
], function (require, exports, module) {
    var QUnit = require('steal-qunit');
    var eventQueue = require('../map/map');
    var canSymbol = require('can-symbol');
    var addTypeEvents = require('./type');
    QUnit.module('can-event-queue/type-events', {
        setup: function () {
        },
        teardown: function () {
        }
    });
    test('Events when object is bound/unbound', function () {
        expect(1);
        var Type = function () {
        };
        eventQueue(Type.prototype);
        addTypeEvents(Type);
        var obj1 = new Type(), obj2 = new Type();
        var calls = [];
        var metaHandler = function (obj, newVal) {
            calls.push([
                obj,
                newVal
            ]);
        };
        var handler = function () {
        };
        Type[canSymbol.for('can.onInstanceBoundChange')](metaHandler);
        obj1.on('first', handler);
        obj1.off('first', handler);
        obj2.on('second', handler);
        obj2.off('second', handler);
        Type[canSymbol.for('can.offInstanceBoundChange')](metaHandler);
        obj1.on('first', handler);
        obj1.off('first', handler);
        QUnit.deepEqual(calls, [
            [
                obj1,
                true
            ],
            [
                obj1,
                false
            ],
            [
                obj2,
                true
            ],
            [
                obj2,
                false
            ]
        ]);
    });
    test('can.dispatchInstanceOnPatches', function () {
        expect(1);
        var Type = function () {
        };
        eventQueue(Type.prototype);
        addTypeEvents(Type);
        var calls = [];
        var handler = function (obj, patches) {
            calls.push([
                obj,
                patches
            ]);
        };
        Type[canSymbol.for('can.onInstancePatches')](handler);
        var obj1 = new Type();
        Type[canSymbol.for('can.dispatchInstanceOnPatches')](obj1, [{
                type: 'add',
                key: 'b',
                value: 1
            }]);
        Type[canSymbol.for('can.offInstancePatches')](handler);
        QUnit.deepEqual(calls, [[
                obj1,
                [{
                        type: 'add',
                        key: 'b',
                        value: 1
                    }]
            ]]);
    });
    test('can.dispatchInstanceOnPatches with patches on event object', function () {
        expect(1);
        var Type = function () {
        };
        eventQueue(Type.prototype);
        addTypeEvents(Type);
        var calls = [];
        var handler = function (obj, patches) {
            calls.push([
                obj,
                patches
            ]);
        };
        Type[canSymbol.for('can.onInstancePatches')](handler);
        var obj1 = new Type();
        obj1.dispatch({
            type: 'b',
            patches: [{
                    type: 'add',
                    key: 'b',
                    value: 1
                }]
        });
        Type[canSymbol.for('can.offInstancePatches')](handler);
        obj1.dispatch({
            type: 'b',
            patches: [{
                    type: 'add',
                    key: 'b',
                    value: 1
                }]
        });
        QUnit.deepEqual(calls, [[
                obj1,
                [{
                        type: 'add',
                        key: 'b',
                        value: 1
                    }]
            ]]);
    });
});
/*can-event-queue@1.0.0#value/value-test*/
define('can-event-queue@1.0.0#value/value-test', [
    'require',
    'exports',
    'module',
    '@steal',
    'steal-qunit',
    './value',
    'can-reflect',
    'can-symbol'
], function (require, exports, module) {
    var steal = require('@steal');
    var QUnit = require('steal-qunit');
    var valueEventBindings = require('./value');
    var canReflect = require('can-reflect');
    var canSymbol = require('can-symbol');
    var onlyDevTest = steal.isEnv('production') ? QUnit.skip : QUnit.test;
    QUnit.module('can-event-queue/value', {
        setup: function () {
        },
        teardown: function () {
        }
    });
    QUnit.test('basics', function () {
        var observable = valueEventBindings({});
        var values = [];
        canReflect.onValue(observable, function (newVal, oldVal) {
            values.push([
                'onValue',
                newVal,
                oldVal
            ]);
        });
        observable.on(function (newVal, oldVal) {
            values.push([
                'on',
                newVal,
                oldVal
            ]);
        }, 'notify');
        observable[canSymbol.for('can.dispatch')](1, 2);
        QUnit.deepEqual(values, [
            [
                'on',
                1,
                2
            ],
            [
                'onValue',
                1,
                2
            ]
        ], 'dispatched worked');
    });
    QUnit.test('onBound and onUnbound called', 2, function (assert) {
        var obj = valueEventBindings({
            onBound: function () {
                assert.ok(true, 'setup called');
            },
            onUnbound: function () {
                assert.ok(true, 'teardown called');
            }
        });
        var handler = function () {
        };
        obj.on(handler);
        obj.off(handler);
    });
    onlyDevTest('getWhatIChange', function (assert) {
        var getChangesSymbol = canSymbol.for('can.getChangesDependencyRecord');
        var observable = valueEventBindings({});
        var getWhatIChange = observable[canSymbol.for('can.getWhatIChange')].bind(observable);
        assert.equal(typeof getWhatIChange(), 'undefined', 'should return undefined if handlers is empty');
        var getChanges = function (value) {
            return function () {
                return { valueDependencies: new Set([value]) };
            };
        };
        var mutateHandler = function mutateHandler() {
        };
        var domUIHandler = function domUIHandler() {
        };
        var notifyHandler = function notifyHandler() {
        };
        var a = function a() {
        };
        var b = function b() {
        };
        mutateHandler[getChangesSymbol] = getChanges(a);
        domUIHandler[getChangesSymbol] = getChanges(b);
        notifyHandler[getChangesSymbol] = getChanges(a);
        observable.handlers.add([
            'mutate',
            mutateHandler
        ]);
        observable.handlers.add([
            'domUI',
            domUIHandler
        ]);
        observable.handlers.add([
            'notify',
            notifyHandler
        ]);
        var whatIChange = getWhatIChange();
        assert.deepEqual(whatIChange.mutate, {
            valueDependencies: new Set([
                a,
                b
            ])
        }, 'domUI and mutate queues handlers deps should be included in .mutate');
        assert.deepEqual(whatIChange.derive, { valueDependencies: new Set([a]) }, 'notify queue handlers deps should be included in .derive');
    });
    QUnit.test('isBound is correct', 2, function (assert) {
        var isBoundSymbol = canSymbol.for('can.isBound');
        var obj = valueEventBindings({});
        var handler = function () {
        };
        obj.on(handler);
        assert.equal(obj[isBoundSymbol](), true, 'isBound true');
        obj.off(handler);
        assert.equal(obj[isBoundSymbol](), false, 'isBound false');
    });
});
/*can-event-queue@1.0.0#can-event-queue-test*/
define('can-event-queue@1.0.0#can-event-queue-test', [
    'require',
    'exports',
    'module',
    './map/map-test',
    './type/type-test',
    './value/value-test'
], function (require, exports, module) {
    require('./map/map-test');
    require('./type/type-test');
    require('./value/value-test');
});
/*can-globals@1.0.0#test-wrapper*/
define('can-globals@1.0.0#test-wrapper', [
    'require',
    'exports',
    'module',
    'qunitjs',
    'steal-qunit'
], function (require, exports, module) {
    var testType = typeof process !== 'undefined' && process.env.TEST;
    var isMochaQUnitUI = testType === 'mocha';
    var isQunit = testType === 'qunit';
    if (isMochaQUnitUI) {
        QUnit.assert.async = function () {
            QUnit.stop();
            return function done(error) {
                if (error) {
                    return QUnit.ok(false, '' + error);
                }
                QUnit.start();
            };
        };
        QUnit.test = test;
        module.exports = QUnit;
    } else if (isQunit) {
        module.exports = require('qunitjs');
    } else {
        module.exports = require('steal-qunit');
    }
});
/*can-globals@1.0.0#spy*/
define('can-globals@1.0.0#spy', function (require, exports, module) {
    'use strict';
    function spy(value) {
        var fn;
        var calls = [];
        if (typeof value === 'function') {
            fn = value;
        } else {
            fn = function () {
                return value;
            };
        }
        function wrapper() {
            var args = Array.prototype.slice.call(arguments);
            var ret = fn.apply(this, args);
            calls.push({
                calledWith: args,
                returned: ret
            });
            return ret;
        }
        Object.defineProperties(wrapper, {
            reset: {
                value: function () {
                    calls = [];
                }
            },
            callCount: {
                get: function () {
                    return calls.length;
                }
            },
            calls: {
                get: function () {
                    return calls;
                }
            }
        });
        return wrapper;
    }
    module.exports = spy;
});
/*can-globals@1.0.0#can-globals-test*/
define('can-globals@1.0.0#can-globals-test', [
    'require',
    'exports',
    'module',
    './can-globals-proto',
    './test-wrapper',
    './spy'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        'use strict';
        var Globals = require('./can-globals-proto');
        var QUnit = require('./test-wrapper');
        var spy = require('./spy');
        var globals;
        function mapEvents(spy) {
            return spy.calls.reduce(function (acc, cur) {
                return acc.concat(cur.calledWith[0]);
            }, []);
        }
        function loop(fn, count, ctx) {
            for (var i = count; i > 0; i--) {
                if (ctx) {
                    fn.call(ctx, i);
                    continue;
                }
                fn(i);
            }
        }
        QUnit.module('can-globals/can-globals-proto');
        QUnit.test('getKeyValue of undefined property', function () {
            globals = new Globals();
            globals.getKeyValue('test');
            ok(true);
        });
        QUnit.test('setKeyValue of undefined property', function () {
            globals = new Globals();
            globals.setKeyValue('foo', 'bar');
            equal(globals.getKeyValue('foo'), 'bar');
        });
        QUnit.test('deleteKeyValue of undefined property', function () {
            globals = new Globals();
            globals.deleteKeyValue('test');
            ok(true);
        });
        QUnit.test('onKeyValue of undefined property', function () {
            globals = new Globals();
            globals.onKeyValue('test', function () {
            });
            ok(true);
            globals.offKeyValue('test');
        });
        QUnit.test('offKeyValue of undefined property', function () {
            globals = new Globals();
            globals.offKeyValue('test', function () {
            });
            ok(true);
        });
        QUnit.test('makeExport of undefined property', function () {
            globals = new Globals();
            globals.makeExport('test');
            ok(true);
        });
        QUnit.test('define with cache disabled', function () {
            var getter = spy('bar');
            globals = new Globals();
            globals.define('foo', getter, false);
            loop(function () {
                globals.getKeyValue('foo');
            }, 5);
            equal(getter.callCount, 5);
        });
        QUnit.test('define with cache enabled', function () {
            var getter = spy('bar');
            globals = new Globals();
            globals.define('foo', getter);
            loop(function () {
                globals.getKeyValue('foo');
            }, 5);
            equal(getter.callCount, 1);
        });
        QUnit.test('define and get a new property', function () {
            globals = new Globals();
            globals.define('test', 'default');
            equal(globals.getKeyValue('test'), 'default');
        });
        QUnit.test('setKeyValue of existing property to string', function () {
            globals = new Globals();
            globals.define('test', 'default');
            globals.setKeyValue('test', 'updated');
            equal(globals.getKeyValue('test'), 'updated');
        });
        QUnit.test('setKeyValue of existing property to undefined', function () {
            globals = new Globals();
            globals.define('test', 'default');
            globals.setKeyValue('test', undefined);
            equal(globals.getKeyValue('test'), undefined);
        });
        QUnit.test('setKeyValue of existing property to a function', function () {
            globals = new Globals();
            globals.define('test', 'default');
            globals.setKeyValue('test', function () {
                return 'foo';
            });
            equal(globals.getKeyValue('test'), 'foo');
        });
        QUnit.test('setKeyValue on an existing property should reset cache', function () {
            var globals = new Globals();
            var bar = function () {
                return 'bar';
            };
            globals.define('foo', bar);
            globals.getKeyValue('foo');
            globals.setKeyValue('foo', function () {
                return 'baz';
            });
            equal(globals.getKeyValue('foo'), 'baz');
        });
        QUnit.test('deleteKeyValue to reset property to default', function () {
            var globals = new Globals();
            globals.define('test', 'default');
            globals.setKeyValue('test', 'updated');
            globals.deleteKeyValue('test');
            equal(globals.getKeyValue('test'), 'default');
        });
        QUnit.test('deleteKeyValue should clear cache', function () {
            var globals = new Globals();
            var bar = spy('bar');
            globals.define('foo', bar);
            globals.getKeyValue('foo');
            globals.setKeyValue('foo', function () {
                return 'baz';
            });
            globals.deleteKeyValue('foo');
            globals.getKeyValue('foo');
            equal(bar.callCount, 2);
        });
        QUnit.test('listen for key change', function () {
            var globals = new Globals();
            var handler = spy();
            globals.define('test', 'default');
            globals.define('foo', 'bar');
            globals.onKeyValue('test', handler);
            globals.setKeyValue('test', 'updated');
            globals.setKeyValue('foo', 'baz');
            globals.deleteKeyValue('test');
            equal(handler.callCount, 2);
            deepEqual(mapEvents(handler), [
                'updated',
                'default'
            ]);
            globals.offKeyValue('test');
        });
        QUnit.test('remove event listener for key', function () {
            var globals = new Globals();
            var handler = spy();
            globals.define('test', 'foo');
            globals.onKeyValue('test', handler);
            globals.offKeyValue('test', handler);
            globals.setKeyValue('test', 'updated');
            equal(handler.callCount, 0);
        });
        QUnit.test('makeExport of key', function () {
            var globals = new Globals();
            globals.define('foo', 'bar');
            var e = globals.makeExport('foo');
            equal(e(), 'bar');
            e('baz');
            equal(e(), 'baz');
            e(undefined);
            equal(e(), 'bar');
        });
        QUnit.test('reset export value with null (can-stache#288)', function () {
            var globals = new Globals();
            globals.define('foo', 'bar');
            var e = globals.makeExport('foo');
            equal(e(), 'bar');
            e('baz');
            equal(e(), 'baz');
            e(null);
            equal(e(), 'bar');
        });
        QUnit.test('reset cleares cache on all keys', function () {
            var globals = new Globals();
            var bar = spy('bar');
            var qux = spy('qux');
            globals.define('foo', bar);
            globals.define('baz', qux);
            loop(function () {
                globals.getKeyValue('foo');
                globals.getKeyValue('baz');
            }, 5);
            globals.reset();
            loop(function () {
                globals.getKeyValue('foo');
                globals.getKeyValue('baz');
            }, 5);
            equal(bar.callCount, 2);
            equal(qux.callCount, 2);
        });
        QUnit.test('reset should reset all keys to default value (#31)', function () {
            var globals = new Globals();
            globals.define('foo', 'bar');
            globals.define('baz', 'qux');
            globals.setKeyValue('foo', 'red');
            globals.setKeyValue('baz', 'green');
            globals.reset();
            equal(globals.getKeyValue('foo'), 'bar');
            equal(globals.getKeyValue('baz'), 'qux');
        });
        QUnit.test('reset triggers events', function () {
            var globals = new Globals();
            var fooHandler = spy();
            var barHandler = spy();
            globals.define('foo', true);
            globals.define('bar', true);
            globals.setKeyValue('foo', false);
            globals.setKeyValue('bar', false);
            globals.onKeyValue('foo', fooHandler);
            globals.onKeyValue('bar', barHandler);
            globals.reset();
            equal(fooHandler.callCount, 1);
            equal(barHandler.callCount, 1);
            globals.offKeyValue('foo');
            globals.offKeyValue('bar');
        });
        QUnit.test('export helper value can be set to a function', function () {
            var globals = new Globals();
            var foo = spy();
            globals.setKeyValue('foo', function () {
                return function () {
                };
            });
            var fooExport = globals.makeExport('foo');
            fooExport(foo);
            QUnit.equal(typeof fooExport(), 'function');
            QUnit.equal(foo.callCount, 0);
            fooExport()();
            QUnit.equal(foo.callCount, 1);
        });
        QUnit.test('onKeyValue should dispatch the resolved value (#29)', function () {
            var globals = new Globals();
            var foo = 'foo';
            globals.define('foo', '');
            globals.onKeyValue('foo', function (value) {
                QUnit.equal(value, foo);
            });
            globals.setKeyValue('foo', function () {
                return foo;
            });
            globals.offKeyValue('foo');
        });
        QUnit.test('onKeyValue should not trigger multiple calls of the value function (#33)', function () {
            var globals = new Globals();
            var baz = spy('baz');
            globals.define('foo', 'bar');
            globals.onKeyValue('foo', function () {
            });
            globals.setKeyValue('foo', baz);
            globals.getKeyValue('foo');
            equal(baz.callCount, 1);
        });
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-key-tree@1.0.0#can-key-tree-test*/
define('can-key-tree@1.0.0#can-key-tree-test', [
    'require',
    'exports',
    'module',
    'steal-qunit',
    './can-key-tree',
    'can-reflect'
], function (require, exports, module) {
    var QUnit = require('steal-qunit');
    var KeyTree = require('./can-key-tree');
    var canReflect = require('can-reflect');
    QUnit.module('can-key-tree');
    QUnit.test('basics', function () {
        var keyTree = new KeyTree([
            Object,
            Object,
            Array
        ]);
        function handler1() {
        }
        function handler2() {
        }
        QUnit.equal(keyTree.size(), 0, 'empty');
        keyTree.add([
            'click',
            'li',
            handler1
        ]);
        keyTree.add([
            'click',
            'li',
            handler2
        ]);
        QUnit.equal(keyTree.size(), 2, '2');
        QUnit.deepEqual(keyTree.get([
            'click',
            'li'
        ]), [
            handler1,
            handler2
        ]);
        keyTree.delete([
            'click',
            'li',
            handler1
        ]);
        QUnit.equal(keyTree.size(), 1, '1');
        keyTree.delete([
            'click',
            'li',
            handler1
        ]);
        QUnit.equal(keyTree.size(), 1, 'empty');
        keyTree.delete([
            'click',
            'li',
            handler2
        ]);
        QUnit.equal(keyTree.size(), 0, 'empty');
    });
    QUnit.test('root isnt a constructor', function () {
        var root = {};
        var keyTree = new KeyTree([
            root,
            Object,
            Array
        ]);
        function handler1() {
        }
        function handler2() {
        }
        QUnit.equal(keyTree.size(), 0, 'empty');
        keyTree.add([
            'click',
            'li',
            handler1
        ]);
        keyTree.add([
            'click',
            'li',
            handler2
        ]);
        QUnit.equal(canReflect.size(root), 1, '2');
        QUnit.deepEqual(keyTree.get([
            'click',
            'li'
        ]), [
            handler1,
            handler2
        ]);
        keyTree.delete([
            'click',
            'li',
            handler1
        ]);
        QUnit.equal(keyTree.size(), 1, '1');
        keyTree.delete([
            'click',
            'li',
            handler1
        ]);
        QUnit.equal(keyTree.size(), 1, 'empty');
        keyTree.delete([
            'click',
            'li',
            handler2
        ]);
        QUnit.equal(keyTree.size(), 0, 'empty');
    });
    QUnit.test('delete base recursively removes all properties', 2, function () {
        var MyMap = function (parentKey) {
            QUnit.equal(parentKey, 'element', 'got the right parent key');
            this.data = {};
        };
        canReflect.assignSymbols(MyMap.prototype, {
            'can.setKeyValue': function (key, value) {
                this.data[key] = value;
            },
            'can.getKeyValue': function (key) {
                return this.data[key];
            },
            'can.deleteKeyValue': function (key) {
                QUnit.equal(key, 'click', 'deleted 2');
                delete this.data[key];
            },
            'can.getOwnEnumerableKeys': function () {
                return Object.keys(this.data);
            }
        });
        var myTree = new KeyTree([
            Object,
            MyMap,
            Object,
            Array
        ]);
        myTree.add([
            'element',
            'click',
            'li',
            'A'
        ]);
        myTree.add([
            'element',
            'click',
            'li',
            'B'
        ]);
        myTree.delete(['element']);
    });
    if (typeof document !== 'undefined' && document.body && document.body.matches) {
        QUnit.test('event delegation example', function () {
            var fixture = document.querySelector('#qunit-fixture');
            fixture.innerHTML = '<li><a id=\'anchor\'>click</a></li>';
            var EventHandler = function (parentKey) {
                this.element = parentKey;
                this.events = {};
                this.delegated = {};
            };
            canReflect.assignSymbols(EventHandler.prototype, {
                'can.setKeyValue': function (eventName, handlersBySelector) {
                    this.delegated[eventName] = function (ev) {
                        canReflect.each(handlersBySelector, function (handlers, selector) {
                            var cur = ev.target;
                            do {
                                if (cur.matches(selector)) {
                                    handlers.forEach(function (handler) {
                                        handler.call(cur, ev);
                                    });
                                }
                                cur = cur.parentNode;
                            } while (cur && cur !== ev.currentTarget);
                        });
                    };
                    this.events[eventName] = handlersBySelector;
                    this.element.addEventListener(eventName, this.delegated[eventName]);
                },
                'can.getKeyValue': function (eventName) {
                    return this.events[eventName];
                },
                'can.deleteKeyValue': function (eventName) {
                    this.element.removeEventListener(eventName, this.delegated[eventName]);
                    delete this.delegated[eventName];
                    delete this.events[eventName];
                },
                'can.getOwnEnumerableKeys': function () {
                    return Object.keys(this.events);
                }
            });
            var eventTree = new KeyTree([
                Map,
                EventHandler,
                Object,
                Array
            ]);
            var dispatchNum = 0;
            function dispatch(el) {
                var event = document.createEvent('HTMLEvents');
                event.initEvent('click', true, false);
                dispatchNum++;
                document.querySelector(el).dispatchEvent(event);
            }
            function handler1() {
                QUnit.equal(dispatchNum, 1, 'only dispatched once');
            }
            eventTree.add([
                fixture,
                'click',
                'li',
                handler1
            ]);
            dispatch('#anchor');
            eventTree.delete([
                fixture,
                'click',
                'li',
                handler1
            ]);
            dispatch('#anchor');
            function handler2() {
                QUnit.equal(dispatchNum, 3, 'handler2');
            }
            function handler3() {
                QUnit.equal(dispatchNum, 3, 'handler3');
            }
            eventTree.add([
                fixture,
                'click',
                'li',
                handler2
            ]);
            eventTree.add([
                fixture,
                'click',
                'li',
                handler3
            ]);
            dispatch('#anchor');
            eventTree.delete([fixture]);
            dispatch('#anchor');
        });
    }
    QUnit.test('.getNode and .get', function () {
        var keyTree = new KeyTree([
            Object,
            Object,
            Array
        ]);
        function handler1() {
        }
        function handler2() {
        }
        keyTree.add([
            'click',
            'li',
            handler1
        ]);
        keyTree.add([
            'click',
            'li',
            handler2
        ]);
        keyTree.add([
            'click',
            'span',
            handler2
        ]);
        var nodeShouldBe = {
            li: [
                handler1,
                handler2
            ],
            span: [handler2]
        };
        QUnit.deepEqual(keyTree.getNode(['click']), nodeShouldBe, '.getNode works');
        QUnit.deepEqual(keyTree.get(['click']), [
            handler1,
            handler2,
            handler2
        ], '.get works');
    });
    QUnit.test('lifecycle callbacks', function () {
        var calls = 0;
        var keyTree = new KeyTree([
            Object,
            Object,
            Array
        ], {
            onFirst: function () {
                QUnit.equal(calls, 1, 'called when the first node is added');
            },
            onEmpty: function () {
                QUnit.equal(calls, 3, 'called when all nodes are removed');
            }
        });
        function handler1() {
        }
        function handler2() {
        }
        calls++;
        keyTree.add([
            'click',
            'li',
            handler1
        ]);
        calls++;
        keyTree.add([
            'click',
            'li',
            handler2
        ]);
        calls++;
        keyTree.delete([]);
    });
    QUnit.test('handle missing keys', function () {
        var keyTree = new KeyTree([
            Object,
            Array
        ]);
        QUnit.notOk(keyTree.delete(['abc']));
        QUnit.ok(true, 'no error');
    });
    QUnit.test('add too deep (#3)', function () {
        var keyTree = new KeyTree([
            Object,
            Array
        ]);
        try {
            keyTree.add([
                1,
                2,
                3,
                4,
                5
            ]);
        } catch (e) {
            QUnit.equal(e.message, 'can-key-tree: Can not add path deeper than tree.');
        }
    });
    QUnit.test('empty deep', function () {
        var keyTree = new KeyTree([
            Object,
            Object,
            Object,
            Array
        ]);
        QUnit.deepEqual(keyTree.get('foo'), []);
    });
    QUnit.test('delete can get path of nodes deleted', function () {
        var keyTree = new KeyTree([
            Object,
            Object,
            Array
        ]);
        var keys = [
            [
                'first',
                'mutate',
                'abc'
            ],
            [
                'first',
                'notify',
                'def'
            ]
        ];
        keyTree.add(keys[0]);
        keyTree.add(keys[1]);
        var KEYS = [];
        keyTree.delete([], function (event, queue, name) {
            KEYS.push([
                event,
                queue,
                name
            ]);
        });
        QUnit.deepEqual(KEYS, keys, 'got nodes that were deleted([])');
        keyTree.add(keys[0]);
        keyTree.add(keys[1]);
        KEYS = [];
        keyTree.delete(['first'], function (event, queue, name) {
            KEYS.push([
                event,
                queue,
                name
            ]);
        });
        QUnit.deepEqual(KEYS, keys, 'got nodes that were deleted([key])');
        keyTree.add(keys[0]);
        keyTree.add(keys[1]);
        KEYS = [];
        keyTree.delete([
            'first',
            'mutate',
            'abc'
        ], function (event, queue, name) {
            KEYS.push([
                event,
                queue,
                name
            ]);
        });
        QUnit.deepEqual(KEYS, [keys[0]], 'got nodes that were deleted([key])');
    });
});
/*can-param@1.0.2#can-param-test*/
define('can-param@1.0.2#can-param-test', [
    'require',
    'exports',
    'module',
    'steal-qunit',
    './can-param'
], function (require, exports, module) {
    var QUnit = require('steal-qunit');
    var param = require('./can-param');
    QUnit.module('can-param');
    QUnit.test('can-param', function () {
        QUnit.deepEqual(param({
            foo: 'bar',
            baz: 'zed'
        }), 'foo=bar&baz=zed', 'Regular object');
        QUnit.deepEqual(param({ foo: { bar: 'baz' } }), encodeURI('foo[bar]=baz'), 'Nested object');
        QUnit.deepEqual(param({
            foo: [
                'bar',
                'baz'
            ]
        }), encodeURI('foo[]=bar&foo[]=baz'), 'Nested array');
        QUnit.deepEqual(param({ foo: 'bar & baz' }), 'foo=bar+%26+baz', 'Spec chars values');
    });
});
/*can-parse-uri@1.0.1#can-parse-uri-test*/
define('can-parse-uri@1.0.1#can-parse-uri-test', [
    'require',
    'exports',
    'module',
    './can-parse-uri',
    'steal-qunit'
], function (require, exports, module) {
    var parseURI = require('./can-parse-uri');
    var QUnit = require('steal-qunit');
    QUnit.module('can-parse-uri');
    QUnit.test('basics', function () {
        QUnit.deepEqual(parseURI('http://foo:8080/bar.html#change'), {
            authority: '//foo:8080',
            hash: '#change',
            host: 'foo:8080',
            hostname: 'foo',
            href: 'http://foo:8080/bar.html#change',
            pathname: '/bar.html',
            port: '8080',
            protocol: 'http:',
            search: ''
        });
    });
});
/*can-queues@1.0.0#can-queues-test*/
define('can-queues@1.0.0#can-queues-test', [
    'require',
    'exports',
    'module',
    'steal-qunit',
    'can-queues',
    'can-util/js/dev/dev',
    './completion-queue'
], function (require, exports, module) {
    var QUnit = require('steal-qunit');
    var queues = require('can-queues');
    var canDev = require('can-util/js/dev/dev');
    var CompletionQueue = require('./completion-queue');
    QUnit.module('can-queues');
    QUnit.test('basics', function () {
        function makeCallbackMeta(handler, context) {
            return { log: [handler.name + ' by ' + context.name] };
        }
        var callbackOrder = [];
        var gc1, gc2, derivedChild, writableChild, root;
        gc1 = {
            name: 'gc1',
            notifyHandlers: [function derivedChild_queueUpdate() {
                    callbackOrder.push('derivedChild_queueUpdate');
                    derivedChild.queueUpdate();
                }],
            mutateHandlers: [function gc1_eventHandler_writableChild_dispatch() {
                    callbackOrder.push('gc1_eventHandler_writableChild_dispatch');
                    writableChild.dispatch();
                }],
            dispatch: function () {
                callbackOrder.push('gc1.dispatch');
                queues.enqueueByQueue({
                    notify: this.notifyHandlers,
                    mutate: this.mutateHandlers
                }, this, [], makeCallbackMeta);
            }
        };
        gc2 = {
            name: 'gc2',
            notifyHandlers: [function deriveChild_queueUpdate() {
                    callbackOrder.push('deriveChild_queueUpdate');
                }],
            mutateHandlers: [],
            dispatch: function () {
                callbackOrder.push('gc2.dispatch');
                queues.enqueueByQueue({
                    notify: this.notifyHandlers,
                    mutate: this.mutateHandlers
                }, this, [], makeCallbackMeta);
            }
        };
        derivedChild = {
            name: 'derivedChild',
            queueUpdate: function () {
                callbackOrder.push('derivedChild.queueUpdate');
                queues.deriveQueue.enqueue(this.update, this, [], {
                    priority: 1,
                    log: ['update on ' + this.name]
                });
            },
            update: function () {
                callbackOrder.push('derivedChild.update');
                queues.enqueueByQueue({
                    notify: this.notifyHandlers,
                    mutate: this.mutateHandlers
                }, this, [], makeCallbackMeta);
            },
            notifyHandlers: [function root_queueUpdate() {
                    callbackOrder.push('root_queueUpdate');
                    root.queueUpdate();
                }]
        };
        derivedChild.update = derivedChild.update.bind(derivedChild);
        writableChild = {
            name: 'writableChild',
            dispatch: function () {
                callbackOrder.push('writableChild.dispatch');
                queues.enqueueByQueue({
                    notify: this.notifyHandlers,
                    mutate: this.mutateHandlers
                }, this, [], makeCallbackMeta);
            },
            notifyHandlers: [function root_queueUpdate() {
                    callbackOrder.push('root_queueUpdate');
                    root.queueUpdate();
                }],
            mutateHandlers: [function eventHandler() {
                    callbackOrder.push('writableChild.eventHandler');
                }]
        };
        root = {
            name: 'root',
            queueUpdate: function () {
                callbackOrder.push('root.queueUpdate');
                queues.deriveQueue.enqueue(this.update, this, [], {
                    priority: 1,
                    log: ['update on ' + this.name]
                });
            },
            update: function () {
                callbackOrder.push('root.update');
                queues.enqueueByQueue({
                    notify: this.notifyHandlers,
                    mutate: this.mutateHandlers
                }, this, [], makeCallbackMeta);
            },
            mutateHandlers: [function eventHandler() {
                    callbackOrder.push('root.eventHandler');
                }]
        };
        root.update = root.update.bind(root);
        queues.batch.start();
        gc1.dispatch();
        gc2.dispatch();
        queues.batch.stop();
        QUnit.deepEqual(callbackOrder, [
            'gc1.dispatch',
            'gc2.dispatch',
            'derivedChild_queueUpdate',
            'derivedChild.queueUpdate',
            'deriveChild_queueUpdate',
            'derivedChild.update',
            'root_queueUpdate',
            'root.queueUpdate',
            'root.update',
            'gc1_eventHandler_writableChild_dispatch',
            'writableChild.dispatch',
            'root_queueUpdate',
            'root.queueUpdate',
            'root.update',
            'root.eventHandler',
            'writableChild.eventHandler',
            'root.eventHandler'
        ], 'abc');
    });
    if (System.env.indexOf('production') < 0) {
        QUnit.test('log basics', function () {
            var oldLog = canDev.log;
            canDev.log = function (area, name) {
                QUnit.equal('Test enqueuing:', area);
                QUnit.equal('fnName', name);
                canDev.log = function (area, name) {
                    QUnit.equal('Test running  :', area);
                    QUnit.equal('fnName', name);
                };
            };
            var queue = new queues.Queue('Test');
            queue.log();
            queue.enqueue(function fnName() {
            }, null, []);
            queue.flush();
            canDev.log = oldLog;
        });
        QUnit.test('logStack', function () {
            function makeCallbackMeta(handler, context) {
                return { log: [handler.name + ' by ' + context.name] };
            }
            var callbackOrder = [];
            var map, fullName, mapFullName;
            map = {
                name: 'map',
                notifyHandlers: [function derivedChild_queueUpdate() {
                        callbackOrder.push('derivedChild_queueUpdate');
                        fullName.queueUpdate();
                    }],
                dispatch: function () {
                    callbackOrder.push('map.dispatch');
                    queues.enqueueByQueue({
                        notify: this.notifyHandlers,
                        mutate: this.mutateHandlers
                    }, this, [], makeCallbackMeta, ['map.first = \'ramiya\'']);
                }
            };
            fullName = {
                name: 'fullName',
                queueUpdate: function () {
                    callbackOrder.push('fullName.queueUpdate');
                    queues.deriveQueue.enqueue(this.update, this, [], {
                        priority: 1,
                        log: ['update on ' + this.name]
                    });
                },
                update: function update() {
                    callbackOrder.push('fullName.update');
                    queues.enqueueByQueue({
                        notify: this.notifyHandlers,
                        mutate: this.mutateHandlers
                    }, this, [], makeCallbackMeta);
                },
                notifyHandlers: [],
                mutateHandlers: [function fullName_setFullNameProperty() {
                        mapFullName.dispatch();
                    }]
            };
            mapFullName = {
                name: 'map.fullName',
                mutateHandlers: [function mapFullName_handler() {
                        callbackOrder.push('gc1_eventHandler_writableChild_dispatch');
                        var stack = queues.stack();
                        QUnit.deepEqual(stack.map(function (task) {
                            return task.meta.stack.name + ' ' + task.context.name + ' ' + task.fn.name;
                        }), [
                            'NOTIFY map derivedChild_queueUpdate',
                            'DERIVE fullName update',
                            'MUTATE fullName fullName_setFullNameProperty',
                            'MUTATE map.fullName mapFullName_handler'
                        ]);
                        QUnit.deepEqual(stack[0].meta.reasonLog, ['map.first = \'ramiya\'']);
                    }],
                dispatch: function () {
                    callbackOrder.push('mapFullName.dispatch');
                    queues.enqueueByQueue({
                        notify: this.notifyHandlers,
                        mutate: this.mutateHandlers
                    }, this, [], makeCallbackMeta, ['map.fullName = \'Ramiya Meyer\'']);
                }
            };
            map.dispatch();
        });
    }
    QUnit.test('priority queue orders tasks correctly', function () {
        var queue = new queues.PriorityQueue('priority');
        var order = 0;
        queue.enqueue(function () {
            order++;
            QUnit.equal(order, 3, 'priority 1 ran after priority 0');
        }, null, [], { priority: 1 });
        var fn = function () {
            order++;
            QUnit.equal(order, 2, 'priority 2 ran after priority 0 because it was flushed');
        };
        queue.enqueue(function () {
            order++;
            QUnit.equal(order, 1, 'priority 0 ran first');
            queue.flushQueuedTask(fn);
        }, null, [], { priority: 0 });
        queue.enqueue(fn, null, [], { priority: 2 });
        queue.flush();
    });
    QUnit.test('priority queue works with holes in the order', function () {
        var queue = new queues.PriorityQueue('priority');
        var ran = [];
        queue.enqueue(function () {
            ran.push('priority 0');
        }, null, [], { priority: 0 });
        queue.enqueue(function () {
            ran.push('priority 10');
        }, null, [], { priority: 10 });
        queue.flush();
        QUnit.deepEqual(ran, [
            'priority 0',
            'priority 10'
        ]);
    });
    QUnit.test('DOM_UI_QUEUE', function () {
        var ran = [];
        queues.enqueueByQueue({
            'notify': [function notify() {
                    ran.push('notify');
                }],
            'derive': [
                function derive1() {
                    ran.push('derive1');
                },
                function derive2() {
                    ran.push('derive2');
                }
            ],
            'domUI': [function domUI() {
                    ran.push('domUI');
                }],
            'mutate': [function domUI() {
                    ran.push('mutate');
                }]
        });
        QUnit.deepEqual(ran, [
            'notify',
            'derive1',
            'derive2',
            'domUI',
            'mutate'
        ], 'ran all tasks');
    });
    QUnit.test('CompletionQueue', function () {
        var queue = new CompletionQueue('DOM');
        var ran = [];
        queue.enqueue(function () {
            ran.push('task 1:a');
            queue.enqueue(function () {
                ran.push('task 3');
            }, null, [], {});
            queue.flush();
            ran.push('task 1:b');
        }, null, [], {});
        queue.enqueue(function () {
            ran.push('task 2');
        }, null, [], {});
        queue.flush();
        QUnit.deepEqual(ran, [
            'task 1:a',
            'task 1:b',
            'task 2',
            'task 3'
        ]);
    });
    QUnit.test('priority queue can\'t flush already ran task', function () {
        var queue = new queues.PriorityQueue('priority');
        var ran = [];
        var task1 = function () {
            ran.push('1');
        };
        queue.enqueue(task1, null, [], { priority: 0 });
        queue.enqueue(function () {
            QUnit.equal(queue.isEnqueued(task1), false, 'not enqueued');
            queue.flushQueuedTask(task1);
            ran.push('2');
        }, null, [], { priority: 0 });
        queue.enqueue(function () {
            ran.push('3');
        }, null, [], { priority: 0 });
        queue.flush();
        QUnit.deepEqual(ran, [
            '1',
            '2',
            '3'
        ]);
    });
    QUnit.test('dequeue a priority queue', 0, function () {
        var queue = new queues.PriorityQueue('priority');
        var task1 = function () {
            QUnit.ok(false, 'this should not be called');
        };
        queue.enqueue(task1, null, [], { priority: 0 });
        queue.dequeue(task1);
        queue.flush();
    });
});
/*can-reflect@1.13.2#reflections/get-name/get-name-test*/
define('can-reflect@1.13.2#reflections/get-name/get-name-test', [
    'require',
    'exports',
    'module',
    'steal-qunit',
    'can-symbol',
    './get-name'
], function (require, exports, module) {
    var QUnit = require('steal-qunit');
    var canSymbol = require('can-symbol');
    var reflexions = require('./get-name');
    var supportsFunctionName = function name() {
    }.name === 'name';
    QUnit.module('can-reflect: getName');
    QUnit.test('it works with strings', function (assert) {
        var f = function () {
        };
        reflexions.setName(f, 'Christopher');
        assert.equal(reflexions.getName(f), 'Christopher');
    });
    QUnit.test('it works with functions', function (assert) {
        var f = function () {
        };
        reflexions.setName(f, function () {
            return 'Christopher';
        });
        assert.equal(reflexions.getName(f), 'Christopher');
    });
    if (supportsFunctionName) {
        QUnit.test('returns function name by default', function (assert) {
            assert.equal(reflexions.getName(function foo() {
            }), 'foo', 'should return function name');
        });
        QUnit.test('returns empty string for anonymous functions', function (assert) {
            assert.equal(reflexions.getName(function () {
            }), '', 'should return empty string');
        });
        QUnit.test('returns constructor name by default', function (assert) {
            assert.equal(reflexions.getName({}), 'Object{}', 'should return constructor name');
        });
    }
    QUnit.test('handles list-likes', function (assert) {
        function ListThing(id) {
            this.id = id;
        }
        ListThing.prototype[canSymbol.for('can.isMoreListLikeThanMapLike')] = true;
        if (supportsFunctionName) {
            assert.equal(reflexions.getName(new ListThing()), 'ListThing[]', 'should use can.getName symbol behavior');
        }
        reflexions.setName(ListThing, 'ListThing');
        assert.equal(reflexions.getName(new ListThing()), 'ListThing[]', 'should use can.getName symbol behavior');
    });
    QUnit.test('handles map-likes', function (assert) {
        function MapThing(id) {
            this.id = id;
        }
        MapThing.prototype[canSymbol.for('can.isMapLike')] = true;
        if (supportsFunctionName) {
            assert.equal(reflexions.getName(new MapThing()), 'MapThing{}', 'should use can.getName symbol behavior');
        }
        reflexions.setName(MapThing, 'MapThing');
        assert.equal(reflexions.getName(new MapThing()), 'MapThing{}', 'should use can.getName symbol behavior');
    });
    QUnit.test('handles value-likes', function (assert) {
        function ValueThing(id) {
            this.id = id;
        }
        ValueThing.prototype[canSymbol.for('can.isValueLike')] = true;
        if (supportsFunctionName) {
            assert.equal(reflexions.getName(new ValueThing()), 'ValueThing<>', 'should use can.getName symbol behavior');
        }
        reflexions.setName(ValueThing, 'ValueThing');
        assert.equal(reflexions.getName(new ValueThing()), 'ValueThing<>', 'should use can.getName symbol behavior');
    });
});
/*can-reflect@1.13.2#can-reflect-test_helpers*/
define('can-reflect@1.13.2#can-reflect-test_helpers', [
    'require',
    'exports',
    'module',
    'can-symbol'
], function (require, exports, module) {
    var canSymbol = require('can-symbol');
    var mapSupported = function () {
        if (typeof Map !== 'undefined' && typeof Map.prototype.keys === 'function') {
            var myMap = new Map();
            return myMap.toString() === '[object Map]';
        }
        return false;
    }();
    var setSupported = function () {
        if (typeof Set !== 'undefined') {
            var mySet = new Set();
            return mySet.toString() === '[object Set]' && canSymbol.iterator in mySet;
        }
        return false;
    }();
    var helpers = {
        mapSupported: mapSupported,
        setSupported: setSupported
    };
    module.exports = helpers;
});
/*can-reflect@1.13.2#reflections/type/type-test*/
define('can-reflect@1.13.2#reflections/type/type-test', [
    'require',
    'exports',
    'module',
    'steal-qunit',
    'can-symbol',
    './type',
    '../get-set/get-set',
    '../../can-reflect-test_helpers'
], function (require, exports, module) {
    var QUnit = require('steal-qunit');
    var canSymbol = require('can-symbol');
    var typeReflections = require('./type');
    var getSetReflections = require('../get-set/get-set');
    var testHelpers = require('../../can-reflect-test_helpers');
    QUnit.module('can-reflect: type reflections');
    QUnit.test('isConstructorLike', function () {
        var Constructor = function () {
        };
        Constructor.prototype.method = function () {
        };
        ok(typeReflections.isConstructorLike(Constructor));
        ok(!typeReflections.isConstructorLike(Constructor.prototype.method));
        var obj = {};
        getSetReflections.setKeyValue(obj, canSymbol.for('can.new'), function () {
        });
        ok(typeReflections.isConstructorLike(obj));
        ok(!typeReflections.isConstructorLike({}));
    });
    QUnit.test('isFunctionLike', function () {
        ok(!typeReflections.isFunctionLike({}), 'object is not function like');
        ok(typeReflections.isFunctionLike(function () {
        }), 'function is function like');
        var nonFunctionFunction = function () {
        };
        getSetReflections.setKeyValue(nonFunctionFunction, canSymbol.for('can.isFunctionLike'), false);
        ok(!typeReflections.isFunctionLike(nonFunctionFunction), 'function with can.isFunctionLike set to false is not function like');
        var obj = {};
        var func = function () {
        };
        getSetReflections.setKeyValue(obj, canSymbol.for('can.new'), func);
        getSetReflections.setKeyValue(obj, canSymbol.for('can.apply'), func);
        ok(typeReflections.isFunctionLike(obj), 'object with can.new and can.apply symbols is function like');
        getSetReflections.setKeyValue(obj, canSymbol.for('can.isFunctionLike'), false);
        ok(!typeReflections.isFunctionLike(obj), 'object with can.new, can.apply, and can.isFunctionLike set to false is not function like');
    });
    QUnit.test('isIteratorLike', function () {
        ok(!typeReflections.isIteratorLike({}));
        ok(typeReflections.isIteratorLike({
            next: function () {
            }
        }));
    });
    QUnit.test('isListLike', function () {
        ok(typeReflections.isListLike({
            0: 1,
            length: 1
        }));
        ok(typeReflections.isListLike('yes'), 'string');
        ok(typeReflections.isListLike({ length: 0 }), 'object with 0 length');
        var symboled = {};
        getSetReflections.setKeyValue(symboled, canSymbol.for('can.isListLike'), false);
        ok(!typeReflections.isListLike(symboled), '!@@can.isListLike');
        getSetReflections.setKeyValue(symboled, canSymbol.for('can.isListLike'), true);
        ok(typeReflections.isListLike(symboled), '@@can.isListLike');
        if (typeof document !== 'undefined') {
            var ul = document.createElement('ul');
            ul.innerHTML = '<li/><li/>';
            ok(typeReflections.isListLike(ul.childNodes), 'nodeList');
        }
        if (testHelpers.setSupported) {
            ok(typeReflections.isListLike(new Set()), 'Set');
        }
    });
    QUnit.test('isMapLike', function () {
        ok(typeReflections.isMapLike({}), 'Object');
        ok(typeReflections.isMapLike([]), 'Array');
        var symboled = {};
        getSetReflections.setKeyValue(symboled, canSymbol.for('can.isMapLike'), false);
        ok(!typeReflections.isMapLike(symboled), '!@@can.isMapLike');
        getSetReflections.setKeyValue(symboled, canSymbol.for('can.isMapLike'), true);
        ok(typeReflections.isMapLike(symboled), '@@can.isMapLike');
        ok(!typeReflections.isMapLike('String'), 'String');
    });
    QUnit.test('isMoreListLikeThanMapLike', function () {
        QUnit.equal(typeReflections.isMoreListLikeThanMapLike({}), false, 'Object');
        QUnit.equal(typeReflections.isMoreListLikeThanMapLike([]), true, 'Array');
    });
    QUnit.test('isObservableLike', function () {
        ok(typeReflections.isObservableLike({}) === false, 'Object');
        ok(typeReflections.isObservableLike([]) === false, 'Array');
        var obj = {};
        getSetReflections.setKeyValue(obj, canSymbol.for('can.onValue'), function () {
        });
        ok(typeReflections.isObservableLike(obj), 'Object');
    });
    QUnit.test('isPrimitive', function () {
        ok(!typeReflections.isPrimitive({}), 'Object');
        ok(typeReflections.isPrimitive(null), 'null');
        ok(typeReflections.isPrimitive(1), '1');
    });
    QUnit.test('isBuiltIn', function () {
        ok(typeReflections.isBuiltIn(1), 'Primitive');
        ok(typeReflections.isBuiltIn({}), 'Object');
        ok(typeReflections.isBuiltIn([]), 'Array');
        ok(typeReflections.isBuiltIn(function () {
        }), 'Function');
        ok(typeReflections.isBuiltIn(new Date()), 'Date');
        ok(typeReflections.isBuiltIn(/[foo].[bar]/), 'RegEx');
        if (document) {
            ok(typeReflections.isBuiltIn(document.createElement('div')), 'Elements');
        }
        var Foo = function () {
        };
        var customObj = new Foo();
        ok(!typeReflections.isBuiltIn(customObj), 'Custom Object');
        if (testHelpers.mapSupported) {
            var map = new Map();
            ok(typeReflections.isBuiltIn(map), 'Map');
        }
    });
    QUnit.test('isValueLike', function () {
        ok(!typeReflections.isValueLike({}), 'Object');
        ok(!typeReflections.isValueLike(function () {
        }), 'Function');
        ok(typeReflections.isValueLike('String'), 'String');
        var obj = {};
        getSetReflections.setKeyValue(obj, canSymbol.for('can.getValue'), true);
        ok(typeReflections.isValueLike(obj), 'symboled');
        var symboled = {};
        getSetReflections.setKeyValue(symboled, canSymbol.for('can.isValueLike'), false);
        ok(!typeReflections.isValueLike(symboled), '!@@can.isValueLike');
        getSetReflections.setKeyValue(symboled, canSymbol.for('can.isValueLike'), true);
        ok(typeReflections.isValueLike(symboled), '@@can.isValueLike');
    });
    QUnit.test('isSymbolLike', function () {
        if (typeof Symbol !== 'undefined') {
            ok(typeReflections.isSymbolLike(Symbol('a symbol')), 'Native Symbol');
        }
        ok(typeReflections.isSymbolLike(canSymbol('another Symbol')), 'canSymbol Symbol');
    });
    QUnit.test('isPromise', function () {
        QUnit.ok(!typeReflections.isPromise({}), 'Object is not a promise');
        QUnit.ok(!typeReflections.isPromise({
            catch: function () {
            },
            then: function () {
            }
        }), 'function with then and catch is not a Promise');
        QUnit.ok(typeReflections.isPromise(new Promise(function () {
        })), 'a new Promise() is a Promise');
    });
    QUnit.test('isConstructor - non enumerable properties on the prototype chain (#18)', function () {
        var Constructor = function () {
        };
        Object.defineProperty(Constructor.prototype, 'prop', {
            enumerable: false,
            value: 1
        });
        QUnit.ok(typeReflections.isConstructorLike(Constructor), 'decorated prototype means constructor');
    });
    QUnit.test('functions without prototypes (#20)', function () {
        var method = function () {
        }.bind({});
        QUnit.notOk(typeReflections.isConstructorLike(method), 'not a constructor');
    });
    QUnit.test('functions with deep non enumerable properties - non default proto chains (#22)', function () {
        var Base = function () {
        };
        Object.defineProperty(Base.prototype, 'prop', {
            enumerable: false,
            value: 1
        });
        var Constructor = function () {
        };
        Constructor.prototype = new Base();
        Constructor.prototype.constructor = Constructor;
        QUnit.ok(typeReflections.isConstructorLike(Constructor), 'decorated prototype means constructor');
    });
    QUnit.test('array -like type is MoreListLikeThanMapLike', function () {
        var MyArray = function (values) {
            this.push.apply(this, values || []);
        };
        MyArray.prototype = Object.create(Array.prototype);
        MyArray.prototype.constructor = MyArray;
        var arr = new MyArray();
        QUnit.ok(typeReflections.isMoreListLikeThanMapLike(arr), 'is array like');
    });
});
/*can-reflect@1.13.2#reflections/shape/shape-test*/
define('can-reflect@1.13.2#reflections/shape/shape-test', [
    'require',
    'exports',
    'module',
    'steal-qunit',
    'can-symbol',
    './shape',
    '../get-set/get-set',
    '../../can-reflect-test_helpers'
], function (require, exports, module) {
    var QUnit = require('steal-qunit');
    var canSymbol = require('can-symbol');
    var shapeReflections = require('./shape');
    var getSetReflections = require('../get-set/get-set');
    var testHelpers = require('../../can-reflect-test_helpers');
    QUnit.module('can-reflect: shape reflections: own+enumerable');
    function testModifiedMap(callback, symbolToMethod) {
        symbolToMethod = symbolToMethod || {
            getOwnEnumerableKeys: 'keys',
            hasOwnKey: 'has',
            getKeyValue: 'get'
        };
        if (testHelpers.mapSupported) {
            shapeReflections.eachKey(symbolToMethod, function (method, symbol) {
                getSetReflections.setKeyValue(Map.prototype, canSymbol.for('can.' + symbol), function () {
                    return this[method].apply(this, arguments);
                });
            });
            callback();
            shapeReflections.eachKey(symbolToMethod, function (symbol) {
                delete Map.prototype[canSymbol.for('can.' + symbol)];
            });
        }
    }
    QUnit.test('getOwnEnumerableKeys (aka: keys)', function () {
        QUnit.deepEqual(shapeReflections.keys({
            foo: 1,
            bar: 2
        }), [
            'foo',
            'bar'
        ], 'POJO');
        QUnit.deepEqual(shapeReflections.keys([
            '0',
            '1'
        ]), Object.keys([
            1,
            2
        ]), 'Array');
        testModifiedMap(function () {
            var map = new Map(), obj = {};
            map.set('foo', 1);
            map.set(obj, 2);
            QUnit.deepEqual(shapeReflections.toArray(shapeReflections.keys(map)), [
                'foo',
                {}
            ], 'Decorated Map with can.getOwnEnumerableKeys');
        });
        var proto = {};
        getSetReflections.setKeyValue(proto, canSymbol.for('can.getOwnKeys'), function () {
            return [
                'a',
                'b',
                'c'
            ];
        });
        getSetReflections.setKeyValue(proto, canSymbol.for('can.getOwnKeyDescriptor'), function (key) {
            return {
                a: { enumerable: false },
                b: { enumerable: true },
                c: { enumerable: true }
            }[key];
        });
        var defineMapLike = Object.create(proto, {});
        QUnit.deepEqual(shapeReflections.toArray(shapeReflections.keys(defineMapLike)), [
            'b',
            'c'
        ], 'Decorated Object with can.getOwnKeys and can.getOwnKeyDescriptor');
    });
    QUnit.test('eachIndex', function () {
        var Ctr = function () {
        };
        var arr = [
            'a',
            'b'
        ];
        getSetReflections.setKeyValue(Ctr.prototype, canSymbol.iterator, function () {
            return {
                i: 0,
                next: function () {
                    if (this.i === 1) {
                        return {
                            value: undefined,
                            done: true
                        };
                    }
                    this.i++;
                    return {
                        value: arr,
                        done: false
                    };
                }
            };
        });
        var obj = new Ctr();
        shapeReflections.eachIndex(obj, function (value, index) {
            QUnit.equal(index, 0);
            QUnit.equal(value, arr);
        });
        shapeReflections.eachIndex(['a'], function (value, index) {
            QUnit.equal(index, 0);
            QUnit.equal(value, 'a');
        });
        function ArrayLike() {
        }
        ArrayLike.prototype = [];
        ArrayLike.prototype[canSymbol.iterator] = null;
        var noniterator = new ArrayLike();
        noniterator.push('a');
        shapeReflections.eachIndex(noniterator, function (value, index) {
            QUnit.equal(index, 0);
            QUnit.equal(value, 'a');
        });
    });
    QUnit.test('eachKey', function () {
        var index;
        var answers, map;
        testModifiedMap(function () {
            var o1 = {}, o2 = {};
            map = new Map([
                [
                    o1,
                    '1'
                ],
                [
                    o2,
                    2
                ]
            ]);
            index = 0;
            answers = [
                [
                    o1,
                    '1'
                ],
                [
                    o2,
                    2
                ]
            ];
            shapeReflections.eachKey(map, function (value, key) {
                var answer = answers[index++];
                QUnit.equal(value, answer[1], 'map value');
                QUnit.equal(key, answer[0], 'map key');
            });
        });
        var obj = {
            a: '1',
            b: '2'
        };
        index = 0;
        answers = [
            [
                'a',
                '1'
            ],
            [
                'b',
                '2'
            ]
        ];
        shapeReflections.eachKey(obj, function (value, key) {
            var answer = answers[index++];
            QUnit.equal(value, answer[1], 'object value');
            QUnit.equal(key, answer[0], 'object key');
        });
    });
    QUnit.test('each', function () {
        shapeReflections.each({ foo: 'bar' }, function (value, key) {
            QUnit.equal(key, 'foo');
            QUnit.equal(value, 'bar');
        });
        shapeReflections.each(['bar'], function (value, index) {
            QUnit.equal(index, 0);
            QUnit.equal(value, 'bar');
        });
    });
    QUnit.test('toArray', function () {
        if (typeof document !== 'undefined') {
            var ul = document.createElement('ul');
            ul.innerHTML = '<li/><li/>';
            var arr = shapeReflections.toArray(ul.childNodes);
            QUnit.equal(arr.length, 2, 'childNodes');
            QUnit.equal(arr[0].nodeName.toLowerCase(), 'li', 'childNodes');
        }
    });
    QUnit.module('can-reflect: shape reflections: own');
    QUnit.test('hasOwnKey', function () {
        var map;
        testModifiedMap(function () {
            var o1 = {};
            map = new Map();
            map.set(o1, '1');
            QUnit.ok(shapeReflections.hasOwnKey(map, o1), 'Map');
        });
        var obj = { foo: 'bar' };
        QUnit.ok(shapeReflections.hasOwnKey(obj, 'foo'), 'obj');
        QUnit.ok(!shapeReflections.hasOwnKey(obj, 'bar'), 'obj');
    });
    QUnit.test('getOwnKeys', function () {
        var obj = Object.create(null, {
            foo: {
                value: '1',
                enumerable: true
            },
            bar: {
                value: '2',
                enumerable: false
            }
        });
        QUnit.deepEqual(shapeReflections.getOwnKeys(obj), [
            'foo',
            'bar'
        ], 'obj');
    });
    QUnit.test('getOwnKeyDescriptor', function () {
        var obj = { foo: 'bar' };
        QUnit.deepEqual(shapeReflections.getOwnKeyDescriptor(obj, 'foo'), Object.getOwnPropertyDescriptor(obj, 'foo'), 'POJO');
        var obj2 = {};
        getSetReflections.setKeyValue(obj2, canSymbol.for('can.getOwnKeyDescriptor'), function (key) {
            return {
                foo: {
                    enumerable: true,
                    type: 'thing'
                }
            }[key];
        });
        QUnit.deepEqual(shapeReflections.getOwnKeyDescriptor(obj2, 'foo'), {
            enumerable: true,
            type: 'thing'
        }, 'w/ symbol');
    });
    QUnit.test('unwrap basics', function () {
        var list = {};
        getSetReflections.setKeyValue(list, canSymbol.iterator, function () {
            return {
                i: 0,
                next: function () {
                    if (this.i === 3) {
                        return {
                            value: undefined,
                            done: true
                        };
                    }
                    this.i++;
                    return {
                        value: (this.i - 1) * 2,
                        done: false
                    };
                }
            };
        });
        getSetReflections.setKeyValue(list, canSymbol.for('can.isMoreListLikeThanMapLike'), true);
        var compute = {};
        getSetReflections.setKeyValue(compute, canSymbol.for('can.getValue'), function () {
            var map = {};
            getSetReflections.setKeyValue(map, canSymbol.for('can.getOwnEnumerableKeys'), function () {
                return [
                    'a',
                    'b',
                    'c',
                    'list'
                ];
            });
            getSetReflections.setKeyValue(map, canSymbol.for('can.getKeyValue'), function (key) {
                return key === 'list' ? list : key.toUpperCase();
            });
            return map;
        });
        var plain = shapeReflections.unwrap(compute);
        QUnit.deepEqual(plain, {
            a: 'A',
            b: 'B',
            c: 'C',
            list: [
                0,
                2,
                4
            ]
        });
    });
    QUnit.test('unwrap handles POJOs', function () {
        var a = { foo: 'bar' };
        var plain = shapeReflections.unwrap(a);
        QUnit.deepEqual(plain, a);
        QUnit.ok(a !== plain, 'returns copy');
    });
    if (typeof Map !== 'undefined') {
        QUnit.test('handles cycles', function () {
            var a = {}, b = {};
            a.b = b;
            b.a = a;
            var plain = shapeReflections.unwrap(a, Map);
            QUnit.equal(plain.b.a, plain, 'cycle intact');
            QUnit.ok(a !== plain, 'returns copy');
        });
    }
    QUnit.test('isBuiltIn is only called after decorators are checked in shouldSerialize', function () {
        var arr = [];
        QUnit.ok(shapeReflections.isSerializable(arr));
        arr[canSymbol.for('can.setKeyValue')] = function () {
        };
        QUnit.ok(!shapeReflections.isSerializable(arr));
        if (testHelpers.setSupported) {
            var set = new Set([
                {},
                {},
                {}
            ]);
            QUnit.ok(shapeReflections.isSerializable(set));
            set[canSymbol.for('can.setKeyValue')] = function () {
            };
            QUnit.ok(!shapeReflections.isSerializable(set));
        }
    });
    QUnit.test('.serialize handles recursion with .unwrap', function () {
        var list = {};
        getSetReflections.setKeyValue(list, canSymbol.iterator, function () {
            return {
                i: 0,
                next: function () {
                    if (this.i === 3) {
                        return {
                            value: undefined,
                            done: true
                        };
                    }
                    this.i++;
                    return {
                        value: (this.i - 1) * 2,
                        done: false
                    };
                }
            };
        });
        getSetReflections.setKeyValue(list, canSymbol.for('can.isMoreListLikeThanMapLike'), true);
        var compute = {};
        getSetReflections.setKeyValue(compute, canSymbol.for('can.getValue'), function () {
            var map = {};
            getSetReflections.setKeyValue(map, canSymbol.for('can.getOwnEnumerableKeys'), function () {
                return [
                    'a',
                    'b',
                    'c',
                    'list'
                ];
            });
            getSetReflections.setKeyValue(map, canSymbol.for('can.getKeyValue'), function (key) {
                return key === 'list' ? list : key.toUpperCase();
            });
            return map;
        });
        var plain = shapeReflections.unwrap(compute);
        QUnit.deepEqual(plain, {
            a: 'A',
            b: 'B',
            c: 'C',
            list: [
                0,
                2,
                4
            ]
        });
    });
    QUnit.test('.serialize with recursive data structures', function () {
        var obj = {};
        obj.prop = obj;
        var s = shapeReflections.serialize(obj);
        QUnit.equal(s.prop, s, 'Object points to itself');
    });
    QUnit.test('updateDeep basics', function () {
        var obj = {
            name: 'Justin',
            hobbies: [
                {
                    id: 1,
                    name: 'js'
                },
                {
                    id: 2,
                    name: 'foosball'
                }
            ]
        };
        var hobbies = obj.hobbies;
        var js = obj.hobbies[0];
        shapeReflections.updateDeep(obj, {
            age: 34,
            hobbies: [{
                    id: 1,
                    name: 'JS',
                    fun: true
                }]
        });
        QUnit.deepEqual(obj, {
            age: 34,
            hobbies: [{
                    id: 1,
                    name: 'JS',
                    fun: true
                }]
        });
        QUnit.equal(obj.hobbies, hobbies, 'merged hobbies');
        QUnit.equal(obj.hobbies[0], js, 'merged js');
        shapeReflections.updateDeep(obj, {
            age: 34,
            hobbies: [
                {
                    id: 1,
                    name: 'JS',
                    fun: true
                },
                {
                    id: 2,
                    name: 'foosball'
                }
            ]
        });
        QUnit.deepEqual(obj, {
            age: 34,
            hobbies: [
                {
                    id: 1,
                    name: 'JS',
                    fun: true
                },
                {
                    id: 2,
                    name: 'foosball'
                }
            ]
        }, 'added foosball');
        QUnit.equal(obj.hobbies, hobbies, 'merged hobbies');
        QUnit.equal(obj.hobbies[0], js, 'merged js');
    });
    QUnit.test('updateDeep', function () {
        var a = [];
        shapeReflections.updateDeep(a, [
            'a',
            'b'
        ]);
        QUnit.deepEqual(a, [
            'a',
            'b'
        ]);
    });
    QUnit.test('can assign undefined values', function () {
        var obj = shapeReflections.assignMap({}, { foo: undefined });
        QUnit.ok(obj.hasOwnProperty('foo'), 'has an undefined foo');
    });
    QUnit.test('assignMap', function () {
        var target = shapeReflections.assignSymbols({}, {
            'can.setKeyValue': function (key, value) {
                this[key] = value * 2;
            },
            'can.getKeyValue': function (key) {
                return this[key] !== undefined ? this[key] / 2 : undefined;
            }
        });
        target.a = 22;
        var source = shapeReflections.assignSymbols({}, {
            'can.setKeyValue': function (key, value) {
                this[key] = value * 3;
            },
            'can.getKeyValue': function (key) {
                return this[key] !== undefined ? this[key] / 3 : undefined;
            }
        });
        shapeReflections.assignMap(source, {
            a: 1,
            b: 2
        });
        QUnit.deepEqual(source, {
            a: 3,
            b: 6
        }, 'set values on source');
        shapeReflections.assignMap(target, source);
        QUnit.deepEqual(target, {
            a: 2,
            b: 4
        }, 'set values on target');
    });
    QUnit.test('getOwnEnumerableKeys with primitives', function () {
        QUnit.deepEqual(shapeReflections.getOwnEnumerableKeys(1), [], 'works with primitive');
    });
    if (typeof Symbol !== 'undefined') {
        QUnit.test('assignSymbols can set Symbol.iterator', function () {
            var fn = function () {
            };
            var obj = shapeReflections.assignSymbols({}, { 'iterator': fn });
            QUnit.equal(obj[Symbol.iterator], fn, 'works');
        });
    }
    QUnit.test('defineInstanceKey with symbol on prototype', function () {
        var testKey = 'foo';
        var testDef = { value: 'bar' };
        function Foo() {
        }
        Foo.prototype[canSymbol.for('can.defineInstanceKey')] = function (key, definition) {
            QUnit.equal(key, testKey);
            QUnit.deepEqual(definition, testDef);
        };
        shapeReflections.defineInstanceKey(Foo, testKey, testDef);
    });
    QUnit.test('defineInstanceKey with no symbol on prototype', function () {
        var testKey = 'foo';
        var testDef = { value: 'bar' };
        var def;
        function Foo() {
        }
        shapeReflections.defineInstanceKey(Foo, testKey, testDef);
        QUnit.ok(def = Object.getOwnPropertyDescriptor(Foo.prototype, testKey), 'Has descriptor');
        QUnit.equal(def.value, testDef.value, 'Value is correctly set');
        QUnit.equal(def.configurable, true, 'value is configurable');
        QUnit.equal(def.writable, true, 'value is writable');
    });
    QUnit.test('updateDeep recurses correctly (#73)', function () {
        var source = {
                name: 'juan',
                hobbies: [
                    'games',
                    'photography',
                    'building'
                ]
            }, sourceArray = source.hobbies;
        shapeReflections.updateDeep(source, { hobbies: ['headdesk'] });
        QUnit.deepEqual(source, { hobbies: ['headdesk'] }, 'source looks right');
        QUnit.equal(sourceArray, source.hobbies, 'array updated');
    });
    QUnit.module('can-reflect: shape reflections: proto chain');
    QUnit.test('hasKey', function () {
        var objHasKey = {};
        Object.defineProperty(objHasKey, '_keys', { value: { foo: true } });
        getSetReflections.setKeyValue(objHasKey, canSymbol.for('can.hasKey'), function (key) {
            return key in this._keys;
        });
        QUnit.ok(shapeReflections.hasKey(objHasKey, 'foo'), 'returns true when hasKey Symbol returns true');
        QUnit.ok(!shapeReflections.hasKey(objHasKey, 'bar'), 'returns false when hasKey Symbol returns false');
        var objHasOwnKey = {};
        Object.defineProperty(objHasOwnKey, '_keys', { value: { foo: true } });
        getSetReflections.setKeyValue(objHasOwnKey, canSymbol.for('can.hasOwnKey'), function (key) {
            return key in this._keys;
        });
        QUnit.ok(shapeReflections.hasKey(objHasOwnKey, 'foo'), 'returns true when hasOwnKey Symbol returns true');
        QUnit.ok(!shapeReflections.hasKey(objHasOwnKey, 'bar'), 'returns false when hasOwnKey Symbol returns false');
        objHasOwnKey.bar = 'baz';
        QUnit.ok(shapeReflections.hasKey(objHasOwnKey, 'bar'), 'returns true when hasOwnKey Symbol returns false but `in` returns true');
    });
});
/*can-reflect@1.13.2#reflections/get-set/get-set-test*/
define('can-reflect@1.13.2#reflections/get-set/get-set-test', [
    'require',
    'exports',
    'module',
    'steal-qunit',
    'can-symbol',
    '../shape/shape',
    './get-set'
], function (require, exports, module) {
    var QUnit = require('steal-qunit');
    var canSymbol = require('can-symbol');
    var shapeReflections = require('../shape/shape');
    var getSetReflections = require('./get-set');
    QUnit.module('can-reflect: get-set reflections: key');
    QUnit.test('getKeyValue', function () {
        QUnit.equal(getSetReflections.getKeyValue({ foo: 'bar' }, 'foo'), 'bar', 'POJO');
        QUnit.equal(getSetReflections.getKeyValue([1], 'length'), 1, 'Array length');
        QUnit.equal(getSetReflections.getKeyValue([2], 0), 2, 'Array index');
        var obj = {};
        getSetReflections.setKeyValue(obj, canSymbol.for('can.getKeyValue'), function (key) {
            return { foo: 'bar' }[key];
        });
        QUnit.equal(getSetReflections.getKeyValue(obj, 'foo'), 'bar');
    });
    QUnit.test('get / set alias', function () {
        QUnit.equal(getSetReflections.get, getSetReflections.getKeyValue);
        QUnit.equal(getSetReflections.set, getSetReflections.setKeyValue);
    });
    QUnit.test('setKeyValue', function () {
        var obj = {};
        var mysymbol = canSymbol('some symbol');
        if (typeof mysymbol === 'object') {
            getSetReflections.setKeyValue(obj, mysymbol, 'VALUE');
            QUnit.deepEqual(Object.getOwnPropertyDescriptor(obj, mysymbol.toString()), {
                enumerable: false,
                writable: true,
                configurable: true,
                value: 'VALUE'
            });
        }
        obj = {};
        getSetReflections.setKeyValue(obj, 'prop', 'VALUE');
        QUnit.equal(obj.prop, 'VALUE');
        getSetReflections.setKeyValue(obj, canSymbol.for('can.setKeyValue'), function (prop, value) {
            QUnit.equal(prop, 'someProp', 'can.setKeyValue');
            QUnit.equal(value, 'someValue', 'can.setKeyValue');
        });
        getSetReflections.setKeyValue(obj, 'someProp', 'someValue');
    });
    QUnit.test('deleteKeyValue', function () {
        var obj = { prop: 'Value' };
        getSetReflections.deleteKeyValue(obj, 'prop');
        QUnit.equal(obj.prop, undefined, 'deleted');
    });
    QUnit.module('can-reflect: get-set reflections: value');
    QUnit.test('getValue', function () {
        [
            true,
            1,
            null,
            undefined,
            {}
        ].forEach(function (value) {
            QUnit.equal(getSetReflections.getValue(value), value, 'Value: ' + value);
        });
        var obj = { value: 0 };
        getSetReflections.setKeyValue(obj, canSymbol.for('can.getValue'), function () {
            return this.value;
        });
        QUnit.equal(getSetReflections.getValue(obj), 0);
    });
    QUnit.test('setValue', function () {
        try {
            getSetReflections.setValue({}, {});
            QUnit.ok(false, 'set POJO');
        } catch (e) {
            QUnit.ok(true, 'set POJO errors');
        }
        var obj = { value: 0 };
        getSetReflections.setKeyValue(obj, canSymbol.for('can.setValue'), function (value) {
            this.value = value;
        });
        getSetReflections.setValue(obj, 2);
        QUnit.deepEqual(obj, { value: 2 }, 'can.setValue');
    });
});
/*can-reflect@1.13.2#reflections/call/call-test*/
define('can-reflect@1.13.2#reflections/call/call-test', [
    'require',
    'exports',
    'module',
    'steal-qunit',
    'can-symbol',
    './call',
    '../get-set/get-set'
], function (require, exports, module) {
    var QUnit = require('steal-qunit');
    var canSymbol = require('can-symbol');
    var callReflections = require('./call');
    var getSetReflections = require('../get-set/get-set');
    QUnit.module('can-reflect: function reflections');
    QUnit.test('call', function () {
        var obj = {};
        var ret = callReflections.call(function (arg1, arg2) {
            QUnit.equal(this, obj, 'this');
            QUnit.equal(arg1, 1, 'arg1');
            QUnit.equal(arg2, 2, 'arg2');
            return 3;
        }, obj, 1, 2);
        QUnit.equal(ret, 3, 'return value');
        var func = {};
        getSetReflections.setKeyValue(func, canSymbol.for('can.apply'), function (context, args) {
            QUnit.equal(this, func, 'this');
            QUnit.equal(context, obj, 'context');
            QUnit.equal(args[0], 1, 'arg1');
            QUnit.equal(args[1], 2, 'arg2');
            return 3;
        });
        ret = callReflections.call(func, obj, 1, 2);
        QUnit.equal(ret, 3, 'return value');
    });
    QUnit.test('apply', function () {
        var obj = {};
        var ret = callReflections.apply(function (arg1, arg2) {
            QUnit.equal(this, obj, 'this');
            QUnit.equal(arg1, 1, 'arg1');
            QUnit.equal(arg2, 2, 'arg2');
            return 3;
        }, obj, [
            1,
            2
        ]);
        QUnit.equal(ret, 3, 'return value');
        var func = {};
        getSetReflections.setKeyValue(func, canSymbol.for('can.apply'), function (context, args) {
            QUnit.equal(this, func, 'this');
            QUnit.equal(context, obj, 'context');
            QUnit.equal(args[0], 1, 'arg1');
            QUnit.equal(args[1], 2, 'arg2');
            return 3;
        });
        ret = callReflections.apply(func, obj, [
            1,
            2
        ]);
        QUnit.equal(ret, 3, 'return value');
    });
    QUnit.test('new', function () {
        var Constructor = function (arg1, arg2) {
            QUnit.ok(this instanceof Constructor, 'this');
            QUnit.equal(arg1, 1, 'arg1');
            QUnit.equal(arg2, 2, 'arg2');
            return 3;
        };
        var instance = callReflections['new'](Constructor, 1, 2);
        QUnit.ok(instance instanceof Constructor, 'this');
        var Func = {};
        getSetReflections.setKeyValue(Func, canSymbol.for('can.new'), function (arg1, arg2) {
            QUnit.equal(this, Func, 'this');
            QUnit.equal(arg1, 1, 'arg1');
            QUnit.equal(arg2, 2, 'arg2');
            return 3;
        });
        var ret = callReflections.new(Func, 1, 2);
        QUnit.equal(ret, 3, 'return value');
    });
});
/*can-reflect@1.13.2#reflections/observe/observe-test*/
define('can-reflect@1.13.2#reflections/observe/observe-test', [
    'require',
    'exports',
    'module',
    'steal-qunit',
    'can-symbol',
    './observe',
    '../get-set/get-set'
], function (require, exports, module) {
    var QUnit = require('steal-qunit');
    var canSymbol = require('can-symbol');
    var observeReflections = require('./observe');
    var getSetReflections = require('../get-set/get-set');
    QUnit.module('can-reflect: observe reflections: key');
    QUnit.test('onKeyValue / offKeyValue', function () {
        var obj = { callbacks: { foo: [] } };
        getSetReflections.setKeyValue(obj, canSymbol.for('can.onKeyValue'), function (key, callback) {
            this.callbacks[key].push(callback);
        });
        var callback = function (ev, value) {
            QUnit.equal(value, 'bar');
        };
        observeReflections.onKeyValue(obj, 'foo', callback);
        obj.callbacks.foo[0]({}, 'bar');
        getSetReflections.setKeyValue(obj, canSymbol.for('can.offKeyValue'), function (key, callback) {
            var index = this.callbacks[key].indexOf(callback);
            this.callbacks[key].splice(index, 1);
        });
        observeReflections.offKeyValue(obj, 'foo', callback);
        QUnit.equal(obj.callbacks.foo.length, 0, 'no event handlers');
    });
    QUnit.test('onKeys', function () {
        try {
            observeReflections.onKeys({}, function () {
            });
            QUnit.ok(false, 'should throw error');
        } catch (e) {
            QUnit.ok(true, 'threw error');
        }
    });
    QUnit.test('onKeysAdded / onKeysRemoved', function () {
        try {
            observeReflections.onKeysAdded({}, function () {
            });
            QUnit.ok(false, 'should throw error');
        } catch (e) {
            QUnit.ok(true, 'threw error');
        }
        try {
            observeReflections.onKeysRemoved({}, function () {
            });
            QUnit.ok(false, 'should throw error');
        } catch (e) {
            QUnit.ok(true, 'threw error');
        }
    });
    QUnit.test('getKeyDependencies', function () {
        try {
            observeReflections.getKeyDependencies({});
            QUnit.ok(false, 'should throw error');
        } catch (e) {
            QUnit.ok(true, 'threw error');
        }
    });
    QUnit.test('getWhatIChange', function () {
        try {
            observeReflections.getWhatIChange({});
            QUnit.ok(false, 'should throw error');
        } catch (e) {
            QUnit.ok(true, 'threw error');
        }
    });
    QUnit.test('getChangesDependencyRecord', function (assert) {
        assert.equal(typeof observeReflections.getChangesDependencyRecord({}), 'undefined', 'should return undefined when symbol is not implemented');
    });
    QUnit.module('can-reflect: observe reflections: value');
    QUnit.test('onValue / offValue', function () {
        var obj = { callbacks: [] };
        getSetReflections.setKeyValue(obj, canSymbol.for('can.onValue'), function (callback) {
            this.callbacks.push(callback);
        });
        var callback = function (ev, value) {
            QUnit.equal(value, 'bar');
        };
        observeReflections.onValue(obj, callback);
        obj.callbacks[0]({}, 'bar');
        getSetReflections.setKeyValue(obj, canSymbol.for('can.offValue'), function (callback) {
            var index = this.callbacks.indexOf(callback);
            this.callbacks.splice(index, 1);
        });
        observeReflections.offValue(obj, callback);
        QUnit.equal(obj.callbacks.length, 0, 'no event handlers');
    });
    QUnit.test('getValueDependencies', function () {
        try {
            observeReflections.getValueDependencies({});
            QUnit.ok(false, 'should throw error');
        } catch (e) {
            QUnit.ok(true, 'threw error');
        }
    });
    QUnit.module('can-reflect: observe reflections: event');
    QUnit.test('onEvent / offEvent', function () {
        var cb = function () {
        };
        var obj = {
            addEventListener: function (arg1, arg2) {
                QUnit.equal(this, obj);
                QUnit.equal(arg2, cb);
                QUnit.equal(arg1, 'click', 'eventName');
            },
            removeEventListener: function (arg1, arg2) {
                QUnit.equal(this, obj);
                QUnit.equal(arg1, 'click', 'event name');
                QUnit.equal(arg2, cb);
            }
        };
        observeReflections.onEvent(obj, 'click', cb);
        observeReflections.offEvent(obj, 'click', cb);
    });
    QUnit.test('onEvent / offEvent gets 3rd argument', function () {
        var cb = function () {
        };
        var obj = {
            addEventListener: function (arg1, arg2, queue) {
                QUnit.equal(this, obj);
                QUnit.equal(arg2, cb);
                QUnit.equal(arg1, 'click', 'eventName');
                QUnit.equal(queue, 'mutate', 'queue');
            },
            removeEventListener: function (arg1, arg2, queue) {
                QUnit.equal(this, obj);
                QUnit.equal(arg1, 'click', 'event name');
                QUnit.equal(arg2, cb);
                QUnit.equal(queue, 'mutate', 'queue');
            }
        };
        observeReflections.onEvent(obj, 'click', cb, 'mutate');
        observeReflections.offEvent(obj, 'click', cb, 'mutate');
    });
    QUnit.test('setPriority', function () {
        var obj = {};
        QUnit.equal(observeReflections.setPriority(obj, 5), false, 'unable to set priority');
        var obj2 = {};
        getSetReflections.setKeyValue(obj2, canSymbol.for('can.setPriority'), function (number) {
            this.priority = number;
        });
        QUnit.equal(observeReflections.setPriority(obj2, 5), true, 'unable to set priority');
        QUnit.equal(obj2.priority, 5, 'set priority');
    });
    QUnit.test('getPriority', function () {
        var obj = {};
        QUnit.equal(observeReflections.getPriority(obj), undefined, 'no priority');
        var obj2 = {};
        getSetReflections.setKeyValue(obj2, canSymbol.for('can.getPriority'), function () {
            return 5;
        });
        QUnit.equal(observeReflections.getPriority(obj2), 5, 'unable to set priority');
    });
});
/*can-reflect@1.13.2#types/map-test*/
define('can-reflect@1.13.2#types/map-test', [
    'require',
    'exports',
    'module',
    'steal-qunit',
    '../reflections/shape/shape',
    './map'
], function (require, exports, module) {
    var QUnit = require('steal-qunit');
    var shape = require('../reflections/shape/shape');
    require('./map');
    if (typeof Map !== 'undefined') {
        QUnit.module('can-reflect/types/map Map');
        QUnit.test('assign', function () {
            var map = new Map();
            shape.assign(map, { name: 'CanJS' });
            QUnit.equal(map.get('name'), 'CanJS', 'object to map');
            var map1 = new Map();
            map = new Map();
            var o1 = { name: 'foo' };
            var o2 = { name: 'bar' };
            map1.set(o1, o2);
            shape.assign(map, map1);
            QUnit.equal(map.get(o1), o2, 'map to map');
        });
        QUnit.test('has', function () {
            var map = new Map();
            var o1 = { name: 'foo' };
            var o2 = { name: 'bar' };
            map.set(o1, o2);
            QUnit.ok(shape.hasOwnKey(map, o1), 'Shape has object key');
        });
        QUnit.test('update', function () {
            var map = new Map();
            var o1 = { name: 'o1' };
            var o2 = { name: 'o2' };
            var o3 = { name: 'o3' };
            map.set(o1, o2);
            map.set(o2, o1);
            var map2 = new Map();
            map2.set(o1, o3);
            map2.set(o3, o1);
            shape.update(map, map2);
            QUnit.notOk(map.has(o2), 'removed key');
            QUnit.equal(map.get(o3), o1, 'added key');
            QUnit.equal(map.get(o1), o3, 'updated key');
        });
    }
    if (typeof WeakMap !== 'undefined') {
        QUnit.module('can-reflect/types/map WeakMap');
        QUnit.test('assign', function () {
            var canjs = new Map();
            var name = { name: 'toUpperCase' };
            canjs.set(name, 'CANJS');
            var map = new WeakMap();
            shape.assign(map, canjs);
            QUnit.equal(map.get(name), 'CANJS', 'map to weakmap');
            map = new WeakMap();
            var map1 = new Map();
            var o1 = { name: 'foo' };
            var o2 = { name: 'bar' };
            map1.set(o1, o2);
            shape.assign(map, map1);
            QUnit.equal(map.get(o1), o2, 'map to map');
        });
        QUnit.test('has', function () {
            var map = new WeakMap();
            var o1 = { name: 'foo' };
            var o2 = { name: 'bar' };
            map.set(o1, o2);
            QUnit.ok(shape.hasOwnKey(map, o1), 'Shape has object key');
        });
        QUnit.test('update', function () {
            var map = new WeakMap();
            var o1 = { name: 'o1' };
            var o2 = { name: 'o2' };
            var o3 = { name: 'o3' };
            map.set(o1, o2);
            map.set(o2, o1);
            var map2 = new WeakMap();
            map2.set(o1, o3);
            map2.set(o3, o1);
            try {
                shape.update(map, map2);
            } catch (e) {
                QUnit.ok(true, 'throws an error');
            }
        });
    }
});
/*can-reflect@1.13.2#types/set-test*/
define('can-reflect@1.13.2#types/set-test', [
    'require',
    'exports',
    'module',
    'steal-qunit',
    '../reflections/shape/shape',
    '../reflections/type/type',
    './set'
], function (require, exports, module) {
    var QUnit = require('steal-qunit');
    var shape = require('../reflections/shape/shape');
    var type = require('../reflections/type/type');
    require('./set');
    function assertSetMatchesArray(set, array, msg) {
        QUnit.equal(set.size, array.length, msg + ' - size matches');
        for (var i = 0; i < array.length; i++) {
            QUnit.ok(set.has(array[i]), msg + ' - set contains ' + array[i]);
        }
    }
    if (typeof Set !== 'undefined') {
        QUnit.module('can-reflect/types/set Set');
        QUnit.test('isListLike', function () {
            QUnit.ok(type.isListLike(new Set()), 'isListLike');
            QUnit.ok(type.isMoreListLikeThanMapLike(new Set()), 'isMoreListLikeThanMapLike');
        });
        QUnit.test('shape.each', function () {
            var arr = [
                'a',
                'b'
            ];
            var set = new Set();
            arr.forEach(function (val) {
                set.add(val);
            });
            var count = 0;
            shape.each(set, function (value) {
                QUnit.equal(value, arr[count++], 'got the right values back');
            });
        });
        QUnit.test('shape.update', function () {
            var set = new Set([
                'a',
                'b'
            ]);
            shape.update(set, [
                'a',
                'a',
                'c'
            ]);
            assertSetMatchesArray(set, [
                'a',
                'c'
            ], '.update');
        });
        QUnit.test('shape.assign', function () {
            var arr = [
                'a',
                'b'
            ];
            var set = new Set();
            arr.forEach(function (val) {
                set.add(val);
            });
            shape.assign(set, [
                'a',
                'a',
                'c'
            ]);
            assertSetMatchesArray(set, [
                'a',
                'b',
                'c'
            ], '.assign');
        });
    }
    if (typeof WeakSet !== 'undefined') {
        QUnit.module('can-reflect/types/set WeakSet');
        QUnit.test('isListLike', function () {
            QUnit.ok(type.isListLike(new WeakSet()), 'isListLike');
            QUnit.ok(type.isMoreListLikeThanMapLike(new WeakSet()), 'isMoreListLikeThanMapLike');
        });
        QUnit.test('shape.each', function () {
            var arr = [
                {},
                {}
            ];
            var set = new WeakSet(arr);
            try {
                shape.each(set, function () {
                });
            } catch (e) {
                QUnit.ok(true, 'Error ' + e.message);
            }
        });
        QUnit.test('shape.update', function () {
            var a = {}, b = {}, c = {};
            var set = new WeakSet([
                a,
                b
            ]);
            try {
                shape.update(set, [
                    a,
                    a,
                    c
                ]);
            } catch (e) {
                QUnit.ok(true, 'Error ' + e.message);
            }
        });
        QUnit.test('shape.assign', function () {
            var a = {}, b = {}, c = {};
            var set = new WeakSet([
                a,
                b
            ]);
            shape.assign(set, [
                a,
                a,
                c
            ]);
            QUnit.ok(set.has(a));
            QUnit.ok(set.has(b));
            QUnit.ok(set.has(c));
        });
    }
});
/*can-reflect@1.13.2#can-reflect-test*/
define('can-reflect@1.13.2#can-reflect-test', [
    'require',
    'exports',
    'module',
    './reflections/get-name/get-name-test',
    './reflections/type/type-test',
    './reflections/shape/shape-test',
    './reflections/get-set/get-set-test',
    './reflections/call/call-test',
    './reflections/observe/observe-test',
    './types/map-test',
    './types/set-test',
    './can-reflect'
], function (require, exports, module) {
    require('./reflections/get-name/get-name-test');
    require('./reflections/type/type-test');
    require('./reflections/shape/shape-test');
    require('./reflections/get-set/get-set-test');
    require('./reflections/call/call-test');
    require('./reflections/observe/observe-test');
    require('./types/map-test');
    require('./types/set-test');
    require('./can-reflect');
});
/*can-reflect-dependencies@1.0.0#test*/
define('can-reflect-dependencies@1.0.0#test', [
    'require',
    'exports',
    'module',
    'steal-qunit',
    'can-simple-map',
    'can-simple-observable',
    './can-reflect-dependencies'
], function (require, exports, module) {
    var QUnit = require('steal-qunit');
    var SimpleMap = require('can-simple-map');
    var SimpleObservable = require('can-simple-observable');
    var canReflectDeps = require('./can-reflect-dependencies');
    QUnit.module('can-reflect-dependencies: one to one');
    var makeKeyDependencies = function makeKeyDependencies(key, value) {
        var keyDependencies = new Map();
        keyDependencies.set(key, new Set(value));
        return keyDependencies;
    };
    QUnit.test('value - value dependency', function (assert) {
        var one = new SimpleObservable('one');
        var two = new SimpleObservable('two');
        canReflectDeps.addMutatedBy(one, two);
        assert.deepEqual(canReflectDeps.getDependencyDataOf(one).whatChangesMe, { mutate: { valueDependencies: new Set([two]) } });
        canReflectDeps.deleteMutatedBy(one, two);
        assert.equal(typeof canReflectDeps.getDependencyDataOf(one), 'undefined');
    });
    QUnit.test('value - key dependency', function (assert) {
        var value = new SimpleObservable('one');
        var map = new SimpleMap({ foo: 'foo' });
        var keyDependencies = makeKeyDependencies(map, ['foo']);
        var mutator = { keyDependencies: keyDependencies };
        canReflectDeps.addMutatedBy(value, mutator);
        var res = canReflectDeps.getDependencyDataOf(value).whatChangesMe;
        assert.deepEqual(res.mutate.keyDependencies, keyDependencies);
        canReflectDeps.deleteMutatedBy(value, mutator);
        assert.equal(typeof canReflectDeps.getDependencyDataOf(value), 'undefined');
    });
    QUnit.test('key - value dependency', function (assert) {
        var one = new SimpleObservable('one');
        var map = new SimpleMap({ foo: 'foo' });
        canReflectDeps.addMutatedBy(map, 'foo', one);
        assert.equal(typeof canReflectDeps.getDependencyDataOf(map), 'undefined', 'has no value dependencies');
        assert.deepEqual(canReflectDeps.getDependencyDataOf(map, 'foo').whatChangesMe.mutate.valueDependencies, new Set([one]));
        canReflectDeps.deleteMutatedBy(map, 'foo', one);
        assert.equal(typeof canReflectDeps.getDependencyDataOf(map, 'foo'), 'undefined');
    });
    QUnit.module('can-reflect-dependencies: one to many');
    QUnit.test('value - key & value dependencies', function (assert) {
        var value = new SimpleObservable('value');
        var map = new SimpleMap({ foo: 'foo' });
        var one = new SimpleObservable('one');
        var keyDependencies = makeKeyDependencies(map, ['foo']);
        var mutator = {
            keyDependencies: keyDependencies,
            valueDependencies: new Set([one])
        };
        canReflectDeps.addMutatedBy(value, mutator);
        var res = canReflectDeps.getDependencyDataOf(value).whatChangesMe;
        assert.deepEqual(res.mutate.valueDependencies, new Set([one]));
        assert.deepEqual(res.mutate.keyDependencies, keyDependencies);
        canReflectDeps.deleteMutatedBy(value, mutator);
        assert.equal(typeof canReflectDeps.getDependencyDataOf(value), 'undefined');
    });
    QUnit.test('key - key & value dependencies', function (assert) {
        var map = new SimpleMap({ foo: 'foo' });
        var one = new SimpleObservable('one');
        var map2 = new SimpleMap({ bar: 'bar' });
        var keyDependencies = makeKeyDependencies(map2, ['bar']);
        var mutator = {
            keyDependencies: keyDependencies,
            valueDependencies: new Set([one])
        };
        canReflectDeps.addMutatedBy(map, 'foo', mutator);
        var expectedKeyMap = new Map();
        expectedKeyMap.set(map2, new Set(['bar']));
        var res = canReflectDeps.getDependencyDataOf(map, 'foo').whatChangesMe;
        assert.deepEqual(res.mutate.valueDependencies, new Set([one]));
        assert.deepEqual(res.mutate.keyDependencies, expectedKeyMap);
        canReflectDeps.deleteMutatedBy(map, 'foo', mutator);
        assert.equal(typeof canReflectDeps.getDependencyDataOf(map, 'foo'), 'undefined');
    });
});
/*can-reflect-promise@2.0.1#test/can-reflect-promise_test*/
define('can-reflect-promise@2.0.1#test/can-reflect-promise_test', [
    'require',
    'exports',
    'module',
    'steal-qunit',
    'can-util/js/global/global',
    'can-symbol',
    'can-reflect-promise',
    'can-observation-recorder',
    'can-test-helpers'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        var QUnit = require('steal-qunit');
        var GLOBAL = require('can-util/js/global/global');
        var canSymbol = require('can-symbol');
        var canReflectPromise = require('can-reflect-promise');
        var ObservationRecorder = require('can-observation-recorder');
        var testHelpers = require('can-test-helpers');
        var nativePromise = GLOBAL().Promise;
        var Promise;
        QUnit.module('can-reflect-promise', {
            setup: function () {
                function tempPromise() {
                    if ('Reflect' in GLOBAL() && typeof GLOBAL().Reflect.construct === 'function') {
                        return GLOBAL().Reflect.construct(nativePromise, arguments, tempPromise);
                    } else {
                        nativePromise.apply(this, arguments);
                        return this;
                    }
                }
                [
                    'resolve',
                    'reject'
                ].forEach(function (key) {
                    if (~nativePromise[key].toString().indexOf('[native code]')) {
                        tempPromise[key] = nativePromise[key];
                    } else {
                        tempPromise[key] = new Function('value', 'return new this(function(resolve, reject) { ' + key + '(value); });');
                    }
                });
                var protoDefs = {};
                protoDefs[canSymbol.for('can.observeData')] = {
                    value: null,
                    writable: true,
                    configurable: true
                };
                protoDefs[canSymbol.for('can.getKeyValue')] = {
                    value: null,
                    writable: true,
                    configurable: true
                };
                tempPromise.prototype = Object.create(nativePromise.prototype, protoDefs);
                Promise = tempPromise;
            },
            teardown: function () {
                Promise = null;
            }
        });
        QUnit.test('decorates promise', function () {
            QUnit.ok(!Promise.prototype[canSymbol.for('can.getKeyValue')], 'no decoration');
            canReflectPromise(new Promise(function () {
            }));
            QUnit.ok(Promise.prototype[canSymbol.for('can.getKeyValue')], 'has decoration');
        });
        QUnit.test('has all necessary symbols', function () {
            var p = new Promise(function () {
            });
            canReflectPromise(p);
            QUnit.ok(p[canSymbol.for('can.getKeyValue')], 'can.getKeyValue');
            QUnit.ok(p[canSymbol.for('can.getValue')], 'can.getValue');
            QUnit.ok(p[canSymbol.for('can.onKeyValue')], 'can.onKeyValue');
            QUnit.ok(p[canSymbol.for('can.offKeyValue')], 'can.offKeyValue');
            QUnit.equal(p[canSymbol.for('can.isValueLike')], false, 'can.isValueLike');
        });
        QUnit.test('getKeyValue for promise-specific values', 8, function () {
            var p = Promise.resolve('a');
            canReflectPromise(p);
            QUnit.equal(p[canSymbol.for('can.getKeyValue')]('isPending'), true, 'isPending true in sync');
            QUnit.equal(p[canSymbol.for('can.getKeyValue')]('isResolved'), false, 'isResolved false in sync');
            QUnit.equal(p[canSymbol.for('can.getKeyValue')]('value'), undefined, 'no value in sync');
            QUnit.equal(p[canSymbol.for('can.getKeyValue')]('state'), 'pending', 'state pending in sync');
            stop();
            setTimeout(function () {
                QUnit.equal(p[canSymbol.for('can.getKeyValue')]('value'), 'a', 'value in async');
                QUnit.equal(p[canSymbol.for('can.getKeyValue')]('isPending'), false, 'isPending false in async');
                QUnit.equal(p[canSymbol.for('can.getKeyValue')]('isResolved'), true, 'isResolved true in async');
                QUnit.equal(p[canSymbol.for('can.getKeyValue')]('state'), 'resolved', 'state resolved in async');
                start();
            }, 30);
        });
        QUnit.test('computable', 4, function () {
            stop(3);
            var p = Promise.resolve('a');
            canReflectPromise(p);
            ObservationRecorder.start();
            p[canSymbol.for('can.getKeyValue')]('value');
            var deps = ObservationRecorder.stop();
            QUnit.ok(deps.keyDependencies.has(p), 'has the key dep');
            p[canSymbol.for('can.onKeyValue')]('value', function (newVal) {
                QUnit.equal(newVal, 'a', 'value updates on event');
                start();
            });
            p[canSymbol.for('can.onKeyValue')]('isResolved', function (newVal) {
                QUnit.equal(newVal, true, 'isResolved updates on event');
                start();
            });
            p[canSymbol.for('can.onKeyValue')]('state', function (newVal) {
                QUnit.equal(newVal, 'resolved', 'state updates on event');
                start();
            });
        });
        testHelpers.dev.devOnlyTest('promise readers throw errors (#70)', function () {
            var teardown = testHelpers.dev.willError(/Rejected Reason/);
            var promise = Promise.reject('Rejected Reason');
            canReflectPromise(promise);
            promise[canSymbol.for('can.onKeyValue')]('value', function () {
            });
            stop();
            promise.catch(function () {
                QUnit.equal(teardown(), 1, 'error thrown');
                start();
            });
        });
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-simple-dom@1.3.4#test/document-test*/
define('can-simple-dom@1.3.4#test/document-test', [
    'can-simple-dom/simple-dom/document',
    'steal-qunit'
], function (_document, _stealQunit) {
    'use strict';
    var _document2 = _interopRequireDefault(_document);
    var _stealQunit2 = _interopRequireDefault(_stealQunit);
    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
    }
    _stealQunit2.default.module('can-simple-dom - Document');
    _stealQunit2.default.test('Document should contain appended Elements', function (assert) {
        var document = new _document2.default();
        var element = document.createElement('div');
        document.body.appendChild(element);
        assert.ok(document.contains(element), 'document should contain element');
        document.body.removeChild(element);
        assert.notOk(document.contains(element), 'document should not contain element');
    });
});
/*can-simple-dom@1.3.4#test/support*/
define('can-simple-dom@1.3.4#test/support', [
    'exports',
    'can-simple-dom/simple-dom/document'
], function (exports, _document) {
    'use strict';
    Object.defineProperty(exports, '__esModule', { value: true });
    exports.document = undefined;
    exports.element = element;
    exports.fragment = fragment;
    exports.text = text;
    exports.comment = comment;
    var _document2 = _interopRequireDefault(_document);
    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
    }
    var root = typeof window !== 'undefined' ? window : global;
    var document = exports.document = undefined;
    exports.document = document = new _document2.default();
    function element(tagName, attrs) {
        var el = document.createElement(tagName);
        for (var key in attrs) {
            el.setAttribute(key, attrs[key]);
        }
        for (var i = 2; i < arguments.length; i++) {
            el.appendChild(arguments[i]);
        }
        return el;
    }
    function fragment() {
        var frag = document.createDocumentFragment();
        for (var i = 0; i < arguments.length; i++) {
            frag.appendChild(arguments[i]);
        }
        return frag;
    }
    function text(s) {
        return document.createTextNode(s);
    }
    function comment(s) {
        return document.createComment(s);
    }
});
/*can-simple-dom@1.3.4#test/element-test*/
define('can-simple-dom@1.3.4#test/element-test', [
    'can-simple-dom/simple-dom/document',
    'can-simple-dom/simple-dom/html-serializer',
    'can-simple-dom/simple-dom/void-map',
    './support',
    'steal-qunit'
], function (_document, _htmlSerializer, _voidMap, _support, _stealQunit) {
    'use strict';
    var _document2 = _interopRequireDefault(_document);
    var _htmlSerializer2 = _interopRequireDefault(_htmlSerializer);
    var _voidMap2 = _interopRequireDefault(_voidMap);
    var _stealQunit2 = _interopRequireDefault(_stealQunit);
    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
    }
    _stealQunit2.default.module('can-simple-dom - Element');
    _stealQunit2.default.test('appending a document fragment appends the fragment\'s children and not the fragment itself', function (assert) {
        var document = new _document2.default();
        var frag = document.createDocumentFragment();
        var elem = document.createElement('div');
        var head = document.head;
        var body = document.body;
        assert.ok(!!head, 'There is a <head> element');
        assert.ok(!!body, 'There is a <body> element');
        assert.strictEqual(body.firstChild, null, 'body has no children');
        frag.appendChild(elem);
        body.appendChild(frag);
        assert.strictEqual(body.firstChild.tagName, 'DIV', 'fragment\'s child is added as child of document');
    });
    _stealQunit2.default.test('appending a document fragment (via insertBefore) appends the fragment\'s children and not the fragment itself', function (assert) {
        var document = new _document2.default();
        var frag = document.createDocumentFragment();
        var elem = document.createElement('div');
        var existing = document.createElement('main');
        var body = document.body;
        body.appendChild(existing);
        assert.strictEqual(body.firstChild.tagName, 'MAIN', 'sanity check: the main element was actually inserted');
        assert.strictEqual(body.lastChild.tagName, 'MAIN', 'sanity check: the main element was actually inserted');
        frag.appendChild(elem);
        body.insertBefore(frag, existing);
        assert.strictEqual(body.firstChild.tagName, 'DIV', 'The body\'s first child is now DIV');
        assert.strictEqual(body.lastChild.tagName, 'MAIN', 'The body\'s last child is now MAIN');
    });
    _stealQunit2.default.test('child nodes can be access via item()', function (assert) {
        var document = new _document2.default();
        var parent = document.createElement('div');
        var child1 = document.createElement('p');
        var child2 = document.createElement('img');
        assert.strictEqual(parent.childNodes.item(0), null, 'attempting to access an item that doesn\'t exist returns null');
        parent.appendChild(child1);
        parent.appendChild(child2);
        assert.strictEqual(parent.childNodes.item(0), child1);
        assert.strictEqual(parent.childNodes.item(1), child2);
        assert.strictEqual(parent.childNodes.item(2), null);
        parent.removeChild(child1);
        assert.strictEqual(parent.childNodes.item(0), child2);
        assert.strictEqual(parent.childNodes.item(1), null);
        parent.removeChild(child2);
        assert.strictEqual(parent.childNodes.item(0), null);
        assert.strictEqual(parent.childNodes.item(1), null);
    });
    _stealQunit2.default.test('insertBefore can insert before the last child node', function (assert) {
        var document = new _document2.default();
        var parent = document.createElement('div');
        var child1 = document.createElement('p');
        var child2 = document.createElement('img');
        var child3 = document.createElement('span');
        parent.appendChild(child1);
        parent.appendChild(child2);
        parent.insertBefore(child3, child2);
        assert.strictEqual(parent.childNodes.item(1), child3);
    });
    _stealQunit2.default.test('cloneNode(true) recursively clones nodes', function (assert) {
        var parent = (0, _support.element)('div');
        var child1 = (0, _support.element)('p');
        var child2 = (0, _support.element)('img', { src: 'hamster.png' });
        var child3 = (0, _support.element)('span');
        parent.appendChild(child1);
        parent.appendChild(child2);
        parent.appendChild(child3);
        var child11 = (0, _support.text)('hello');
        var child12 = (0, _support.element)('span');
        child12.appendChild((0, _support.text)(' world'));
        var child13 = (0, _support.text)('!');
        child1.appendChild(child11);
        child1.appendChild(child12);
        child1.appendChild(child13);
        var clone = parent.cloneNode(true);
        assert.notEqual(parent.firstChild, null);
        assert.notStrictEqual(clone.firstChild, parent.firstChild);
        var clone2 = parent.cloneNode(true);
        assert.notEqual(parent.firstChild, null);
        assert.notStrictEqual(clone2.firstChild, clone.firstChild);
        assert.notStrictEqual(clone2.firstChild, parent.firstChild);
        var actual = new _htmlSerializer2.default(_voidMap2.default).serialize((0, _support.fragment)(clone));
        assert.equal(actual, '<div><p>hello<span> world</span>!</p><img src="hamster.png"><span></span></div>');
    });
    _stealQunit2.default.test('anchor element is created successfully - micro-location works (see #11)', function (assert) {
        assert.expect(0);
        var document = new _document2.default();
        try {
            document.createElement('a');
        } catch (ex) {
            assert.ok(false, 'Anchor throws exception');
        }
    });
    _stealQunit2.default.test('style.cssText is two way bound to the style attribute (#13)', function (assert) {
        var document = new _document2.default();
        var el = document.createElement('div');
        el.style.cssText = 'color: green;';
        assert.equal(el.getAttribute('style'), 'color: green;');
    });
    _stealQunit2.default.test('replaceChild works', function (assert) {
        var document = new _document2.default();
        var parent = document.createElement('div');
        var one = document.createElement('p');
        var two = document.createElement('span');
        parent.appendChild(one);
        assert.equal(parent.firstChild.nodeName, 'P', 'first child is a p');
        var oldChild = parent.replaceChild(two, one);
        assert.equal(oldChild, one, 'correct return value');
        assert.equal(parent.firstChild.nodeName, 'SPAN', 'child is now the span');
    });
    _stealQunit2.default.test('Replacing the document\'s firstChild updates documentElement', function (assert) {
        var document = new _document2.default();
        var first = document.documentElement;
        var html = document.createElement('html');
        var head = document.createElement('head');
        var body = document.createElement('body');
        html.appendChild(head);
        html.appendChild(body);
        document.replaceChild(html, document.documentElement);
        assert.equal(document.documentElement, html, 'documentElement is updated');
        assert.equal(document.body, body, 'document.body is updated');
        assert.equal(document.head, head, 'document.head is updated');
    });
    _stealQunit2.default.test('setAttribute(\'class\', value) updates the className', function (assert) {
        var document = new _document2.default();
        var el = document.createElement('div');
        el.setAttribute('class', 'foo bar');
        assert.equal(el.className, 'foo bar', 'Element\'s className is same as the attribute class');
    });
    _stealQunit2.default.test('setAttribute(\'class\', value) updates an existing className', function (assert) {
        var document = new _document2.default();
        var el = document.createElement('div');
        el.setAttribute('class', 'foo bar');
        el.setAttribute('class', 'baz foo');
        assert.equal(el.className, 'baz foo', 'Element\'s className is updated');
    });
    _stealQunit2.default.test('removeAttribute(\'class\') updates the className', function (assert) {
        var document = new _document2.default();
        var el = document.createElement('div');
        el.setAttribute('class', 'foo bar');
        el.removeAttribute('class');
        assert.equal(el.className, '', 'Element\'s className is same as the attribute class');
    });
    _stealQunit2.default.test('innerHTML does not parse the contents of SCRIPT and STYLE nodes', function (assert) {
        var document = new _document2.default();
        var div = document.createElement('div');
        var script = document.createElement('script');
        try {
            div.innerHTML = '<span>foo</span>';
            ok(0, 'should not make it here b/c no parser is shipped');
        } catch (ex) {
            ok(1, 'tried to parse content');
        }
        var jsCode = 'var foo = \'<span>bar</span>\';';
        try {
            script.innerHTML = jsCode;
            equal(script.firstChild, script.lastChild, 'script has one child');
            equal(script.firstChild.nodeType, 3, 'only child is a text node');
            equal(script.firstChild.nodeValue, jsCode, 'code matches');
        } catch (ex) {
            ok(0, 'should not cause an error');
        }
    });
    _stealQunit2.default.test('removeChild should return the removed node', function (assert) {
        var document = new _document2.default();
        var parent = document.createElement('div');
        var child = document.createElement('p');
        parent.appendChild(child);
        var removedNode = parent.removeChild(child);
        assert.strictEqual(removedNode, child, 'removeChild should return the removed node');
    });
    _stealQunit2.default.test('Input\'s type property is two-way bound to the attribute', function (assert) {
        var document = new _document2.default();
        var input = document.createElement('input');
        input.setAttribute('type', 'text');
        assert.equal(input.type, 'text');
        input.type = 'radio';
        assert.equal(input.type, 'radio');
        assert.equal(input.getAttribute('type'), 'radio');
    });
    _stealQunit2.default.test('Input\'s value property is two-way bound to the attribute', function (assert) {
        var document = new _document2.default();
        var input = document.createElement('input');
        input.setAttribute('value', 'foo');
        assert.equal(input.value, 'foo');
        input.value = 'bar';
        assert.equal(input.value, 'bar');
        assert.equal(input.getAttribute('value'), 'bar');
    });
    _stealQunit2.default.test('Input\'s checked value is two-way bound', function (assert) {
        var document = new _document2.default();
        var input = document.createElement('input');
        input.setAttribute('checked', '');
        assert.ok(input.checked);
        input.checked = false;
        assert.equal(input.hasAttribute('checked'), false);
        assert.equal(input.checked, false);
    });
    _stealQunit2.default.test('Select\'s value attribute is two-way bound', function (assert) {
        var document = new _document2.default();
        var select = document.createElement('select');
        select.setAttribute('value', 'foo');
        assert.equal(select.value, 'foo');
        select.value = 'bar';
        assert.equal(select.value, 'bar');
        assert.equal(select.getAttribute('value'), 'bar');
    });
    _stealQunit2.default.test('Option\'s value attribute is two-way bound', function (assert) {
        var document = new _document2.default();
        var option = document.createElement('option');
        option.setAttribute('value', 'foo');
        assert.equal(option.value, 'foo');
        option.value = 'bar';
        assert.equal(option.value, 'bar');
        assert.equal(option.getAttribute('value'), 'bar');
    });
    _stealQunit2.default.test('Option\'s selected value is tied to parent select\'s value', function (assert) {
        var document = new _document2.default();
        var select = document.createElement('select');
        var option = document.createElement('option');
        select.appendChild(option);
        select.value = 'foo';
        option.value = 'foo';
        assert.equal(option.selected, true);
        option.value = 'bar';
        assert.equal(option.selected, false);
        option.selected = true;
        assert.equal(select.value, 'bar');
    });
    _stealQunit2.default.test('option\'s selected property is configurable and enumerable', function (assert) {
        var document = new _document2.default();
        var option = document.createElement('option');
        var proto = Object.getPrototypeOf(option);
        var desc = Object.getOwnPropertyDescriptor(proto, 'selected');
        assert.equal(desc.enumerable, true, 'selected is enumerable');
        assert.equal(desc.configurable, true, 'selected is configurable');
    });
    _stealQunit2.default.test('The className property is configurable and enumerable', function (assert) {
        var document = new _document2.default();
        var option = document.createElement('some-el');
        var proto = Object.getPrototypeOf(option);
        var desc = Object.getOwnPropertyDescriptor(proto, 'className');
        assert.equal(desc.enumerable, true, 'selected is enumerable');
        assert.equal(desc.configurable, true, 'selected is configurable');
    });
    _stealQunit2.default.test('The innerHTML property is configurable and enumerable', function (assert) {
        var document = new _document2.default();
        var option = document.createElement('some-el');
        var proto = Object.getPrototypeOf(option);
        var desc = Object.getOwnPropertyDescriptor(proto, 'innerHTML');
        assert.equal(desc.enumerable, true, 'selected is enumerable');
        assert.equal(desc.configurable, true, 'selected is configurable');
    });
    _stealQunit2.default.test('Elements created in one document but inserted into another have their ownerDocument updated', function (assert) {
        var doc1 = new _document2.default();
        var doc2 = new _document2.default();
        var div = doc1.createElement('div');
        var span = doc1.createElement('span');
        div.appendChild(span);
        doc2.body.appendChild(div);
        assert.equal(div.ownerDocument, doc2, 'The ownerDocument was updated');
        assert.equal(span.ownerDocument, doc2, 'ownerDocument on a child was updated too');
    });
    _stealQunit2.default.test('Elements created in one document but inserted into another have their ownerDocument updated (documentElement)', function (assert) {
        var doc1 = new _document2.default();
        var doc2 = new _document2.default();
        var html = doc1.createElement('html');
        doc2.replaceChild(html, doc2.documentElement);
        assert.equal(html.ownerDocument, doc2, 'The ownerDocument was updated');
    });
    _stealQunit2.default.test('Elements created in one document but inserted into another have their ownerDocument updated (DocumentFragment)', function (assert) {
        var doc1 = new _document2.default();
        var doc2 = new _document2.default();
        var div = doc1.createElement('div');
        var span = doc1.createElement('span');
        div.appendChild(span);
        var frag = doc1.createDocumentFragment();
        frag.appendChild(div);
        doc2.body.appendChild(frag);
        assert.equal(div.ownerDocument, doc2, 'The ownerDocument was updated');
        assert.equal(span.ownerDocument, doc2, 'ownerDocument on a child was updated too');
    });
    _stealQunit2.default.test('Setting an element\'s textContent inserts TextNode', function (assert) {
        var document = new _document2.default();
        var el = document.createElement('div');
        el.textContent = 'foo';
        var tn = el.childNodes.item(0);
        assert.equal(tn.nodeType, 3, 'It is a TextNode');
        assert.equal(tn.nodeValue, 'foo', 'With the text');
        assert.equal(el.textContent, 'foo', 'Getter works');
    });
    _stealQunit2.default.test('Setting textContent when there is already a child', function (assert) {
        var document = new _document2.default();
        var el = document.createElement('div');
        el.appendChild(document.createElement('span'));
        assert.equal(el.childNodes.item(0).nodeName, 'SPAN', 'starts as a span');
        el.textContent = 'hello world';
        var tn = el.childNodes.item(0);
        assert.equal(tn.nodeType, 3, 'It is a TextNode');
        assert.equal(tn.nodeValue, 'hello world', 'With the text');
        assert.equal(el.textContent, 'hello world', 'Getter works');
        assert.equal(el.childNodes.item(1), null, 'span is gone');
    });
});
/*can-simple-dom@1.3.4#test/serializer-test*/
define('can-simple-dom@1.3.4#test/serializer-test', [
    './support',
    'can-simple-dom/simple-dom/html-serializer',
    'can-simple-dom/simple-dom/void-map',
    'steal-qunit'
], function (_support, _htmlSerializer, _voidMap, _stealQunit) {
    'use strict';
    var _htmlSerializer2 = _interopRequireDefault(_htmlSerializer);
    var _voidMap2 = _interopRequireDefault(_voidMap);
    var _stealQunit2 = _interopRequireDefault(_stealQunit);
    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
    }
    _stealQunit2.default.module('can-simple-dom - Serializer', {
        beforeEach: function beforeEach() {
            this.serializer = new _htmlSerializer2.default(_voidMap2.default);
        }
    });
    _stealQunit2.default.test('simple text', function (assert) {
        var actual = this.serializer.serialize((0, _support.fragment)((0, _support.text)('hello > world &amp; &nbsp;&nbsp; & goodbye')));
        assert.equal(actual, 'hello &gt; world &amp; &nbsp;&nbsp; &amp; goodbye');
    });
    _stealQunit2.default.test('serializes correctly', function (assert) {
        var actual = this.serializer.serialize((0, _support.fragment)((0, _support.element)('div', {
            id: 'foo',
            title: '&amp;&"'
        }, (0, _support.element)('b', {}, (0, _support.text)('Foo & Bar &amp; Baz < Buz > Biz \xA9')))));
        assert.equal(actual, '<div id="foo" title="&amp;&amp;&quot;"><b>Foo &amp; Bar &amp; Baz &lt; Buz &gt; Biz \xA9</b></div>');
    });
    _stealQunit2.default.test('serializes image correctly', function (assert) {
        var actual = this.serializer.serialize((0, _support.fragment)((0, _support.element)('img', { src: 'https://foo.com/foobar.jpg?foo=bar&bar=foo' })));
        assert.equal(actual, '<img src="https://foo.com/foobar.jpg?foo=bar&bar=foo">');
    });
    _stealQunit2.default.test('serializes textContent', function (assert) {
        var el, actual, frag;
        el = (0, _support.element)('div', {});
        el.textContent = 'hello world';
        actual = this.serializer.serialize((0, _support.fragment)(el));
        assert.equal(actual, '<div>hello world</div>');
    });
    _stealQunit2.default.test('correctly serializes code blocks', function (assert) {
        var el, actual, frag;
        el = (0, _support.element)('script', {});
        el.appendChild((0, _support.text)('<anonymous>'));
        actual = this.serializer.serialize((0, _support.fragment)(el));
        assert.equal(actual, '<script><anonymous></script>', 'script tag content serialized');
    });
});
/*simple-html-tokenizer@0.2.6#lib/simple-html-tokenizer/utils*/
define('simple-html-tokenizer@0.2.6#lib/simple-html-tokenizer/utils', ['exports'], function (exports) {
    'use strict';
    Object.defineProperty(exports, '__esModule', { value: true });
    exports.isSpace = isSpace;
    exports.isAlpha = isAlpha;
    exports.preprocessInput = preprocessInput;
    var WSP = /[\t\n\f ]/;
    var ALPHA = /[A-Za-z]/;
    var CRLF = /\r\n?/g;
    function isSpace(char) {
        return WSP.test(char);
    }
    function isAlpha(char) {
        return ALPHA.test(char);
    }
    function preprocessInput(input) {
        return input.replace(CRLF, '\n');
    }
});
/*simple-html-tokenizer@0.2.6#lib/simple-html-tokenizer/evented-tokenizer*/
define('simple-html-tokenizer@0.2.6#lib/simple-html-tokenizer/evented-tokenizer', [
    'exports',
    './utils'
], function (exports, _utils) {
    'use strict';
    Object.defineProperty(exports, '__esModule', { value: true });
    function EventedTokenizer(delegate, entityParser) {
        this.delegate = delegate;
        this.entityParser = entityParser;
        this.state = null;
        this.input = null;
        this.index = -1;
        this.line = -1;
        this.column = -1;
        this.tagLine = -1;
        this.tagColumn = -1;
        this.reset();
    }
    EventedTokenizer.prototype = {
        reset: function reset() {
            this.state = 'beforeData';
            this.input = '';
            this.index = 0;
            this.line = 1;
            this.column = 0;
            this.tagLine = -1;
            this.tagColumn = -1;
            this.delegate.reset();
        },
        tokenize: function tokenize(input) {
            this.reset();
            this.tokenizePart(input);
            this.tokenizeEOF();
        },
        tokenizePart: function tokenizePart(input) {
            this.input += (0, _utils.preprocessInput)(input);
            while (this.index < this.input.length) {
                this.states[this.state].call(this);
            }
        },
        tokenizeEOF: function tokenizeEOF() {
            this.flushData();
        },
        flushData: function flushData() {
            if (this.state === 'data') {
                this.delegate.finishData();
                this.state = 'beforeData';
            }
        },
        peek: function peek() {
            return this.input.charAt(this.index);
        },
        consume: function consume() {
            var char = this.peek();
            this.index++;
            if (char === '\n') {
                this.line++;
                this.column = 0;
            } else {
                this.column++;
            }
            return char;
        },
        consumeCharRef: function consumeCharRef() {
            var endIndex = this.input.indexOf(';', this.index);
            if (endIndex === -1) {
                return;
            }
            var entity = this.input.slice(this.index, endIndex);
            var chars = this.entityParser.parse(entity);
            if (chars) {
                var count = entity.length;
                while (count) {
                    this.consume();
                    count--;
                }
                this.consume();
                return chars;
            }
        },
        markTagStart: function markTagStart() {
            this.tagLine = this.line;
            this.tagColumn = this.column;
            if (this.delegate.tagOpen) {
                this.delegate.tagOpen();
            }
        },
        states: {
            beforeData: function beforeData() {
                var char = this.peek();
                if (char === '<') {
                    this.state = 'tagOpen';
                    this.markTagStart();
                    this.consume();
                } else {
                    this.state = 'data';
                    this.delegate.beginData();
                }
            },
            data: function data() {
                var char = this.peek();
                if (char === '<') {
                    this.delegate.finishData();
                    this.state = 'tagOpen';
                    this.markTagStart();
                    this.consume();
                } else if (char === '&') {
                    this.consume();
                    this.delegate.appendToData(this.consumeCharRef() || '&');
                } else {
                    this.consume();
                    this.delegate.appendToData(char);
                }
            },
            tagOpen: function tagOpen() {
                var char = this.consume();
                if (char === '!') {
                    this.state = 'markupDeclaration';
                } else if (char === '/') {
                    this.state = 'endTagOpen';
                } else if ((0, _utils.isAlpha)(char)) {
                    this.state = 'tagName';
                    this.delegate.beginStartTag();
                    this.delegate.appendToTagName(char.toLowerCase());
                }
            },
            markupDeclaration: function markupDeclaration() {
                var char = this.consume();
                if (char === '-' && this.input.charAt(this.index) === '-') {
                    this.consume();
                    this.state = 'commentStart';
                    this.delegate.beginComment();
                }
            },
            commentStart: function commentStart() {
                var char = this.consume();
                if (char === '-') {
                    this.state = 'commentStartDash';
                } else if (char === '>') {
                    this.delegate.finishComment();
                    this.state = 'beforeData';
                } else {
                    this.delegate.appendToCommentData(char);
                    this.state = 'comment';
                }
            },
            commentStartDash: function commentStartDash() {
                var char = this.consume();
                if (char === '-') {
                    this.state = 'commentEnd';
                } else if (char === '>') {
                    this.delegate.finishComment();
                    this.state = 'beforeData';
                } else {
                    this.delegate.appendToCommentData('-');
                    this.state = 'comment';
                }
            },
            comment: function comment() {
                var char = this.consume();
                if (char === '-') {
                    this.state = 'commentEndDash';
                } else {
                    this.delegate.appendToCommentData(char);
                }
            },
            commentEndDash: function commentEndDash() {
                var char = this.consume();
                if (char === '-') {
                    this.state = 'commentEnd';
                } else {
                    this.delegate.appendToCommentData('-' + char);
                    this.state = 'comment';
                }
            },
            commentEnd: function commentEnd() {
                var char = this.consume();
                if (char === '>') {
                    this.delegate.finishComment();
                    this.state = 'beforeData';
                } else {
                    this.delegate.appendToCommentData('--' + char);
                    this.state = 'comment';
                }
            },
            tagName: function tagName() {
                var char = this.consume();
                if ((0, _utils.isSpace)(char)) {
                    this.state = 'beforeAttributeName';
                } else if (char === '/') {
                    this.state = 'selfClosingStartTag';
                } else if (char === '>') {
                    this.delegate.finishTag();
                    this.state = 'beforeData';
                } else {
                    this.delegate.appendToTagName(char);
                }
            },
            beforeAttributeName: function beforeAttributeName() {
                var char = this.peek();
                if ((0, _utils.isSpace)(char)) {
                    this.consume();
                    return;
                } else if (char === '/') {
                    this.state = 'selfClosingStartTag';
                    this.consume();
                } else if (char === '>') {
                    this.consume();
                    this.delegate.finishTag();
                    this.state = 'beforeData';
                } else {
                    this.state = 'attributeName';
                    this.delegate.beginAttribute();
                    this.consume();
                    this.delegate.appendToAttributeName(char);
                }
            },
            attributeName: function attributeName() {
                var char = this.peek();
                if ((0, _utils.isSpace)(char)) {
                    this.state = 'afterAttributeName';
                    this.consume();
                } else if (char === '/') {
                    this.delegate.beginAttributeValue(false);
                    this.delegate.finishAttributeValue();
                    this.consume();
                    this.state = 'selfClosingStartTag';
                } else if (char === '=') {
                    this.state = 'beforeAttributeValue';
                    this.consume();
                } else if (char === '>') {
                    this.delegate.beginAttributeValue(false);
                    this.delegate.finishAttributeValue();
                    this.consume();
                    this.delegate.finishTag();
                    this.state = 'beforeData';
                } else {
                    this.consume();
                    this.delegate.appendToAttributeName(char);
                }
            },
            afterAttributeName: function afterAttributeName() {
                var char = this.peek();
                if ((0, _utils.isSpace)(char)) {
                    this.consume();
                    return;
                } else if (char === '/') {
                    this.delegate.beginAttributeValue(false);
                    this.delegate.finishAttributeValue();
                    this.consume();
                    this.state = 'selfClosingStartTag';
                } else if (char === '=') {
                    this.consume();
                    this.state = 'beforeAttributeValue';
                } else if (char === '>') {
                    this.delegate.beginAttributeValue(false);
                    this.delegate.finishAttributeValue();
                    this.consume();
                    this.delegate.finishTag();
                    this.state = 'beforeData';
                } else {
                    this.delegate.beginAttributeValue(false);
                    this.delegate.finishAttributeValue();
                    this.consume();
                    this.state = 'attributeName';
                    this.delegate.beginAttribute();
                    this.delegate.appendToAttributeName(char);
                }
            },
            beforeAttributeValue: function beforeAttributeValue() {
                var char = this.peek();
                if ((0, _utils.isSpace)(char)) {
                    this.consume();
                } else if (char === '"') {
                    this.state = 'attributeValueDoubleQuoted';
                    this.delegate.beginAttributeValue(true);
                    this.consume();
                } else if (char === '\'') {
                    this.state = 'attributeValueSingleQuoted';
                    this.delegate.beginAttributeValue(true);
                    this.consume();
                } else if (char === '>') {
                    this.delegate.beginAttributeValue(false);
                    this.delegate.finishAttributeValue();
                    this.consume();
                    this.delegate.finishTag();
                    this.state = 'beforeData';
                } else {
                    this.state = 'attributeValueUnquoted';
                    this.delegate.beginAttributeValue(false);
                    this.consume();
                    this.delegate.appendToAttributeValue(char);
                }
            },
            attributeValueDoubleQuoted: function attributeValueDoubleQuoted() {
                var char = this.consume();
                if (char === '"') {
                    this.delegate.finishAttributeValue();
                    this.state = 'afterAttributeValueQuoted';
                } else if (char === '&') {
                    this.delegate.appendToAttributeValue(this.consumeCharRef('"') || '&');
                } else {
                    this.delegate.appendToAttributeValue(char);
                }
            },
            attributeValueSingleQuoted: function attributeValueSingleQuoted() {
                var char = this.consume();
                if (char === '\'') {
                    this.delegate.finishAttributeValue();
                    this.state = 'afterAttributeValueQuoted';
                } else if (char === '&') {
                    this.delegate.appendToAttributeValue(this.consumeCharRef('\'') || '&');
                } else {
                    this.delegate.appendToAttributeValue(char);
                }
            },
            attributeValueUnquoted: function attributeValueUnquoted() {
                var char = this.peek();
                if ((0, _utils.isSpace)(char)) {
                    this.delegate.finishAttributeValue();
                    this.consume();
                    this.state = 'beforeAttributeName';
                } else if (char === '&') {
                    this.consume();
                    this.delegate.appendToAttributeValue(this.consumeCharRef('>') || '&');
                } else if (char === '>') {
                    this.delegate.finishAttributeValue();
                    this.consume();
                    this.delegate.finishTag();
                    this.state = 'beforeData';
                } else {
                    this.consume();
                    this.delegate.appendToAttributeValue(char);
                }
            },
            afterAttributeValueQuoted: function afterAttributeValueQuoted() {
                var char = this.peek();
                if ((0, _utils.isSpace)(char)) {
                    this.consume();
                    this.state = 'beforeAttributeName';
                } else if (char === '/') {
                    this.consume();
                    this.state = 'selfClosingStartTag';
                } else if (char === '>') {
                    this.consume();
                    this.delegate.finishTag();
                    this.state = 'beforeData';
                } else {
                    this.state = 'beforeAttributeName';
                }
            },
            selfClosingStartTag: function selfClosingStartTag() {
                var char = this.peek();
                if (char === '>') {
                    this.consume();
                    this.delegate.markTagAsSelfClosing();
                    this.delegate.finishTag();
                    this.state = 'beforeData';
                } else {
                    this.state = 'beforeAttributeName';
                }
            },
            endTagOpen: function endTagOpen() {
                var char = this.consume();
                if ((0, _utils.isAlpha)(char)) {
                    this.state = 'tagName';
                    this.delegate.beginEndTag();
                    this.delegate.appendToTagName(char.toLowerCase());
                }
            }
        }
    };
    exports.default = EventedTokenizer;
});
/*simple-html-tokenizer@0.2.6#lib/simple-html-tokenizer/tokenizer*/
define('simple-html-tokenizer@0.2.6#lib/simple-html-tokenizer/tokenizer', [
    'exports',
    './evented-tokenizer'
], function (exports, _eventedTokenizer) {
    'use strict';
    Object.defineProperty(exports, '__esModule', { value: true });
    var _eventedTokenizer2 = _interopRequireDefault(_eventedTokenizer);
    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
    }
    function Tokenizer(entityParser, options) {
        this.token = null;
        this.startLine = 1;
        this.startColumn = 0;
        this.options = options || {};
        this.tokenizer = new _eventedTokenizer2.default(this, entityParser);
    }
    Tokenizer.prototype = {
        tokenize: function tokenize(input) {
            this.tokens = [];
            this.tokenizer.tokenize(input);
            return this.tokens;
        },
        tokenizePart: function tokenizePart(input) {
            this.tokens = [];
            this.tokenizer.tokenizePart(input);
            return this.tokens;
        },
        tokenizeEOF: function tokenizeEOF() {
            this.tokens = [];
            this.tokenizer.tokenizeEOF();
            return this.tokens[0];
        },
        reset: function reset() {
            this.token = null;
            this.startLine = 1;
            this.startColumn = 0;
        },
        addLocInfo: function addLocInfo() {
            if (this.options.loc) {
                this.token.loc = {
                    start: {
                        line: this.startLine,
                        column: this.startColumn
                    },
                    end: {
                        line: this.tokenizer.line,
                        column: this.tokenizer.column
                    }
                };
            }
            this.startLine = this.tokenizer.line;
            this.startColumn = this.tokenizer.column;
        },
        beginData: function beginData() {
            this.token = {
                type: 'Chars',
                chars: ''
            };
            this.tokens.push(this.token);
        },
        appendToData: function appendToData(char) {
            this.token.chars += char;
        },
        finishData: function finishData() {
            this.addLocInfo();
        },
        beginComment: function beginComment() {
            this.token = {
                type: 'Comment',
                chars: ''
            };
            this.tokens.push(this.token);
        },
        appendToCommentData: function appendToCommentData(char) {
            this.token.chars += char;
        },
        finishComment: function finishComment() {
            this.addLocInfo();
        },
        beginStartTag: function beginStartTag() {
            this.token = {
                type: 'StartTag',
                tagName: '',
                attributes: [],
                selfClosing: false
            };
            this.tokens.push(this.token);
        },
        beginEndTag: function beginEndTag() {
            this.token = {
                type: 'EndTag',
                tagName: ''
            };
            this.tokens.push(this.token);
        },
        finishTag: function finishTag() {
            this.addLocInfo();
        },
        markTagAsSelfClosing: function markTagAsSelfClosing() {
            this.token.selfClosing = true;
        },
        appendToTagName: function appendToTagName(char) {
            this.token.tagName += char;
        },
        beginAttribute: function beginAttribute() {
            this._currentAttribute = [
                '',
                '',
                null
            ];
            this.token.attributes.push(this._currentAttribute);
        },
        appendToAttributeName: function appendToAttributeName(char) {
            this._currentAttribute[0] += char;
        },
        beginAttributeValue: function beginAttributeValue(isQuoted) {
            this._currentAttribute[2] = isQuoted;
        },
        appendToAttributeValue: function appendToAttributeValue(char) {
            this._currentAttribute[1] = this._currentAttribute[1] || '';
            this._currentAttribute[1] += char;
        },
        finishAttributeValue: function finishAttributeValue() {
        }
    };
    exports.default = Tokenizer;
});
/*simple-html-tokenizer@0.2.6#lib/simple-html-tokenizer/entity-parser*/
define('simple-html-tokenizer@0.2.6#lib/simple-html-tokenizer/entity-parser', ['exports'], function (exports) {
    'use strict';
    Object.defineProperty(exports, '__esModule', { value: true });
    function EntityParser(named) {
        this.named = named;
    }
    var HEXCHARCODE = /^#[xX]([A-Fa-f0-9]+)$/;
    var CHARCODE = /^#([0-9]+)$/;
    var NAMED = /^([A-Za-z0-9]+)$/;
    EntityParser.prototype.parse = function (entity) {
        if (!entity) {
            return;
        }
        var matches = entity.match(HEXCHARCODE);
        if (matches) {
            return String.fromCharCode(parseInt(matches[1], 16));
        }
        matches = entity.match(CHARCODE);
        if (matches) {
            return String.fromCharCode(parseInt(matches[1], 10));
        }
        matches = entity.match(NAMED);
        if (matches) {
            return this.named[matches[1]];
        }
    };
    exports.default = EntityParser;
});
/*simple-html-tokenizer@0.2.6#lib/simple-html-tokenizer/html5-named-char-refs*/
define('simple-html-tokenizer@0.2.6#lib/simple-html-tokenizer/html5-named-char-refs', ['exports'], function (exports) {
    'use strict';
    Object.defineProperty(exports, '__esModule', { value: true });
    exports.default = {
        Aacute: '',
        aacute: '',
        Abreve: '',
        abreve: '',
        ac: '\u223E',
        acd: '\u223F',
        acE: '\u223E',
        Acirc: '',
        acirc: '',
        acute: '\xB4',
        Acy: '',
        acy: '',
        AElig: '',
        aelig: '',
        af: '\u2061',
        Afr: '\uD835\uDD04',
        afr: '\uD835\uDD1E',
        Agrave: '',
        agrave: '',
        alefsym: '',
        aleph: '',
        Alpha: '',
        alpha: '',
        Amacr: '',
        amacr: '',
        amalg: '\u2A3F',
        AMP: '&',
        amp: '&',
        And: '\u2A53',
        and: '\u2227',
        andand: '\u2A55',
        andd: '\u2A5C',
        andslope: '\u2A58',
        andv: '\u2A5A',
        ang: '\u2220',
        ange: '\u29A4',
        angle: '\u2220',
        angmsd: '\u2221',
        angmsdaa: '\u29A8',
        angmsdab: '\u29A9',
        angmsdac: '\u29AA',
        angmsdad: '\u29AB',
        angmsdae: '\u29AC',
        angmsdaf: '\u29AD',
        angmsdag: '\u29AE',
        angmsdah: '\u29AF',
        angrt: '\u221F',
        angrtvb: '\u22BE',
        angrtvbd: '\u299D',
        angsph: '\u2222',
        angst: '',
        angzarr: '\u237C',
        Aogon: '',
        aogon: '',
        Aopf: '\uD835\uDD38',
        aopf: '\uD835\uDD52',
        ap: '\u2248',
        apacir: '\u2A6F',
        apE: '\u2A70',
        ape: '\u224A',
        apid: '\u224B',
        apos: '\'',
        ApplyFunction: '\u2061',
        approx: '\u2248',
        approxeq: '\u224A',
        Aring: '',
        aring: '',
        Ascr: '\uD835\uDC9C',
        ascr: '\uD835\uDCB6',
        Assign: '\u2254',
        ast: '*',
        asymp: '\u2248',
        asympeq: '\u224D',
        Atilde: '',
        atilde: '',
        Auml: '',
        auml: '',
        awconint: '\u2233',
        awint: '\u2A11',
        backcong: '\u224C',
        backepsilon: '\u03F6',
        backprime: '\u2035',
        backsim: '\u223D',
        backsimeq: '\u22CD',
        Backslash: '\u2216',
        Barv: '\u2AE7',
        barvee: '\u22BD',
        Barwed: '\u2306',
        barwed: '\u2305',
        barwedge: '\u2305',
        bbrk: '\u23B5',
        bbrktbrk: '\u23B6',
        bcong: '\u224C',
        Bcy: '',
        bcy: '',
        bdquo: '\u201E',
        becaus: '\u2235',
        Because: '\u2235',
        because: '\u2235',
        bemptyv: '\u29B0',
        bepsi: '\u03F6',
        bernou: '',
        Bernoullis: '',
        Beta: '',
        beta: '',
        beth: '',
        between: '\u226C',
        Bfr: '\uD835\uDD05',
        bfr: '\uD835\uDD1F',
        bigcap: '\u22C2',
        bigcirc: '\u25EF',
        bigcup: '\u22C3',
        bigodot: '\u2A00',
        bigoplus: '\u2A01',
        bigotimes: '\u2A02',
        bigsqcup: '\u2A06',
        bigstar: '\u2605',
        bigtriangledown: '\u25BD',
        bigtriangleup: '\u25B3',
        biguplus: '\u2A04',
        bigvee: '\u22C1',
        bigwedge: '\u22C0',
        bkarow: '\u290D',
        blacklozenge: '\u29EB',
        blacksquare: '\u25AA',
        blacktriangle: '\u25B4',
        blacktriangledown: '\u25BE',
        blacktriangleleft: '\u25C2',
        blacktriangleright: '\u25B8',
        blank: '\u2423',
        blk12: '\u2592',
        blk14: '\u2591',
        blk34: '\u2593',
        block: '\u2588',
        bne: '=',
        bnequiv: '\u2261',
        bNot: '\u2AED',
        bnot: '\u2310',
        Bopf: '\uD835\uDD39',
        bopf: '\uD835\uDD53',
        bot: '\u22A5',
        bottom: '\u22A5',
        bowtie: '\u22C8',
        boxbox: '\u29C9',
        boxDL: '\u2557',
        boxDl: '\u2556',
        boxdL: '\u2555',
        boxdl: '\u2510',
        boxDR: '\u2554',
        boxDr: '\u2553',
        boxdR: '\u2552',
        boxdr: '\u250C',
        boxH: '\u2550',
        boxh: '\u2500',
        boxHD: '\u2566',
        boxHd: '\u2564',
        boxhD: '\u2565',
        boxhd: '\u252C',
        boxHU: '\u2569',
        boxHu: '\u2567',
        boxhU: '\u2568',
        boxhu: '\u2534',
        boxminus: '\u229F',
        boxplus: '\u229E',
        boxtimes: '\u22A0',
        boxUL: '\u255D',
        boxUl: '\u255C',
        boxuL: '\u255B',
        boxul: '\u2518',
        boxUR: '\u255A',
        boxUr: '\u2559',
        boxuR: '\u2558',
        boxur: '\u2514',
        boxV: '\u2551',
        boxv: '\u2502',
        boxVH: '\u256C',
        boxVh: '\u256B',
        boxvH: '\u256A',
        boxvh: '\u253C',
        boxVL: '\u2563',
        boxVl: '\u2562',
        boxvL: '\u2561',
        boxvl: '\u2524',
        boxVR: '\u2560',
        boxVr: '\u255F',
        boxvR: '\u255E',
        boxvr: '\u251C',
        bprime: '\u2035',
        Breve: '\u02D8',
        breve: '\u02D8',
        brvbar: '\xA6',
        Bscr: '',
        bscr: '\uD835\uDCB7',
        bsemi: '\u204F',
        bsim: '\u223D',
        bsime: '\u22CD',
        bsol: '\\',
        bsolb: '\u29C5',
        bsolhsub: '\u27C8',
        bull: '\u2022',
        bullet: '\u2022',
        bump: '\u224E',
        bumpE: '\u2AAE',
        bumpe: '\u224F',
        Bumpeq: '\u224E',
        bumpeq: '\u224F',
        Cacute: '',
        cacute: '',
        Cap: '\u22D2',
        cap: '\u2229',
        capand: '\u2A44',
        capbrcup: '\u2A49',
        capcap: '\u2A4B',
        capcup: '\u2A47',
        capdot: '\u2A40',
        CapitalDifferentialD: '',
        caps: '\u2229',
        caret: '\u2041',
        caron: '',
        Cayleys: '',
        ccaps: '\u2A4D',
        Ccaron: '',
        ccaron: '',
        Ccedil: '',
        ccedil: '',
        Ccirc: '',
        ccirc: '',
        Cconint: '\u2230',
        ccups: '\u2A4C',
        ccupssm: '\u2A50',
        Cdot: '',
        cdot: '',
        cedil: '\xB8',
        Cedilla: '\xB8',
        cemptyv: '\u29B2',
        cent: '\xA2',
        CenterDot: '\xB7',
        centerdot: '\xB7',
        Cfr: '',
        cfr: '\uD835\uDD20',
        CHcy: '',
        chcy: '',
        check: '\u2713',
        checkmark: '\u2713',
        Chi: '',
        chi: '',
        cir: '\u25CB',
        circ: '',
        circeq: '\u2257',
        circlearrowleft: '\u21BA',
        circlearrowright: '\u21BB',
        circledast: '\u229B',
        circledcirc: '\u229A',
        circleddash: '\u229D',
        CircleDot: '\u2299',
        circledR: '\xAE',
        circledS: '\u24C8',
        CircleMinus: '\u2296',
        CirclePlus: '\u2295',
        CircleTimes: '\u2297',
        cirE: '\u29C3',
        cire: '\u2257',
        cirfnint: '\u2A10',
        cirmid: '\u2AEF',
        cirscir: '\u29C2',
        ClockwiseContourIntegral: '\u2232',
        CloseCurlyDoubleQuote: '\u201D',
        CloseCurlyQuote: '\u2019',
        clubs: '\u2663',
        clubsuit: '\u2663',
        Colon: '\u2237',
        colon: ':',
        Colone: '\u2A74',
        colone: '\u2254',
        coloneq: '\u2254',
        comma: ',',
        commat: '@',
        comp: '\u2201',
        compfn: '\u2218',
        complement: '\u2201',
        complexes: '',
        cong: '\u2245',
        congdot: '\u2A6D',
        Congruent: '\u2261',
        Conint: '\u222F',
        conint: '\u222E',
        ContourIntegral: '\u222E',
        Copf: '',
        copf: '\uD835\uDD54',
        coprod: '\u2210',
        Coproduct: '\u2210',
        COPY: '\xA9',
        copy: '\xA9',
        copysr: '\u2117',
        CounterClockwiseContourIntegral: '\u2233',
        crarr: '\u21B5',
        Cross: '\u2A2F',
        cross: '\u2717',
        Cscr: '\uD835\uDC9E',
        cscr: '\uD835\uDCB8',
        csub: '\u2ACF',
        csube: '\u2AD1',
        csup: '\u2AD0',
        csupe: '\u2AD2',
        ctdot: '\u22EF',
        cudarrl: '\u2938',
        cudarrr: '\u2935',
        cuepr: '\u22DE',
        cuesc: '\u22DF',
        cularr: '\u21B6',
        cularrp: '\u293D',
        Cup: '\u22D3',
        cup: '\u222A',
        cupbrcap: '\u2A48',
        CupCap: '\u224D',
        cupcap: '\u2A46',
        cupcup: '\u2A4A',
        cupdot: '\u228D',
        cupor: '\u2A45',
        cups: '\u222A',
        curarr: '\u21B7',
        curarrm: '\u293C',
        curlyeqprec: '\u22DE',
        curlyeqsucc: '\u22DF',
        curlyvee: '\u22CE',
        curlywedge: '\u22CF',
        curren: '\xA4',
        curvearrowleft: '\u21B6',
        curvearrowright: '\u21B7',
        cuvee: '\u22CE',
        cuwed: '\u22CF',
        cwconint: '\u2232',
        cwint: '\u2231',
        cylcty: '\u232D',
        Dagger: '\u2021',
        dagger: '\u2020',
        daleth: '',
        Darr: '\u21A1',
        dArr: '\u21D3',
        darr: '\u2193',
        dash: '\u2010',
        Dashv: '\u2AE4',
        dashv: '\u22A3',
        dbkarow: '\u290F',
        dblac: '\u02DD',
        Dcaron: '',
        dcaron: '',
        Dcy: '',
        dcy: '',
        DD: '',
        dd: '',
        ddagger: '\u2021',
        ddarr: '\u21CA',
        DDotrahd: '\u2911',
        ddotseq: '\u2A77',
        deg: '\xB0',
        Del: '\u2207',
        Delta: '',
        delta: '',
        demptyv: '\u29B1',
        dfisht: '\u297F',
        Dfr: '\uD835\uDD07',
        dfr: '\uD835\uDD21',
        dHar: '\u2965',
        dharl: '\u21C3',
        dharr: '\u21C2',
        DiacriticalAcute: '\xB4',
        DiacriticalDot: '\u02D9',
        DiacriticalDoubleAcute: '\u02DD',
        DiacriticalGrave: '`',
        DiacriticalTilde: '\u02DC',
        diam: '\u22C4',
        Diamond: '\u22C4',
        diamond: '\u22C4',
        diamondsuit: '\u2666',
        diams: '\u2666',
        die: '\xA8',
        DifferentialD: '',
        digamma: '',
        disin: '\u22F2',
        div: '\xF7',
        divide: '\xF7',
        divideontimes: '\u22C7',
        divonx: '\u22C7',
        DJcy: '',
        djcy: '',
        dlcorn: '\u231E',
        dlcrop: '\u230D',
        dollar: '$',
        Dopf: '\uD835\uDD3B',
        dopf: '\uD835\uDD55',
        Dot: '\xA8',
        dot: '\u02D9',
        DotDot: '',
        doteq: '\u2250',
        doteqdot: '\u2251',
        DotEqual: '\u2250',
        dotminus: '\u2238',
        dotplus: '\u2214',
        dotsquare: '\u22A1',
        doublebarwedge: '\u2306',
        DoubleContourIntegral: '\u222F',
        DoubleDot: '\xA8',
        DoubleDownArrow: '\u21D3',
        DoubleLeftArrow: '\u21D0',
        DoubleLeftRightArrow: '\u21D4',
        DoubleLeftTee: '\u2AE4',
        DoubleLongLeftArrow: '\u27F8',
        DoubleLongLeftRightArrow: '\u27FA',
        DoubleLongRightArrow: '\u27F9',
        DoubleRightArrow: '\u21D2',
        DoubleRightTee: '\u22A8',
        DoubleUpArrow: '\u21D1',
        DoubleUpDownArrow: '\u21D5',
        DoubleVerticalBar: '\u2225',
        DownArrow: '\u2193',
        Downarrow: '\u21D3',
        downarrow: '\u2193',
        DownArrowBar: '\u2913',
        DownArrowUpArrow: '\u21F5',
        DownBreve: '',
        downdownarrows: '\u21CA',
        downharpoonleft: '\u21C3',
        downharpoonright: '\u21C2',
        DownLeftRightVector: '\u2950',
        DownLeftTeeVector: '\u295E',
        DownLeftVector: '\u21BD',
        DownLeftVectorBar: '\u2956',
        DownRightTeeVector: '\u295F',
        DownRightVector: '\u21C1',
        DownRightVectorBar: '\u2957',
        DownTee: '\u22A4',
        DownTeeArrow: '\u21A7',
        drbkarow: '\u2910',
        drcorn: '\u231F',
        drcrop: '\u230C',
        Dscr: '\uD835\uDC9F',
        dscr: '\uD835\uDCB9',
        DScy: '',
        dscy: '',
        dsol: '\u29F6',
        Dstrok: '',
        dstrok: '',
        dtdot: '\u22F1',
        dtri: '\u25BF',
        dtrif: '\u25BE',
        duarr: '\u21F5',
        duhar: '\u296F',
        dwangle: '\u29A6',
        DZcy: '',
        dzcy: '',
        dzigrarr: '\u27FF',
        Eacute: '',
        eacute: '',
        easter: '\u2A6E',
        Ecaron: '',
        ecaron: '',
        ecir: '\u2256',
        Ecirc: '',
        ecirc: '',
        ecolon: '\u2255',
        Ecy: '',
        ecy: '',
        eDDot: '\u2A77',
        Edot: '',
        eDot: '\u2251',
        edot: '',
        ee: '',
        efDot: '\u2252',
        Efr: '\uD835\uDD08',
        efr: '\uD835\uDD22',
        eg: '\u2A9A',
        Egrave: '',
        egrave: '',
        egs: '\u2A96',
        egsdot: '\u2A98',
        el: '\u2A99',
        Element: '\u2208',
        elinters: '\u23E7',
        ell: '',
        els: '\u2A95',
        elsdot: '\u2A97',
        Emacr: '',
        emacr: '',
        empty: '\u2205',
        emptyset: '\u2205',
        EmptySmallSquare: '\u25FB',
        emptyv: '\u2205',
        EmptyVerySmallSquare: '\u25AB',
        emsp: '\u2003',
        emsp13: '\u2004',
        emsp14: '\u2005',
        ENG: '',
        eng: '',
        ensp: '\u2002',
        Eogon: '',
        eogon: '',
        Eopf: '\uD835\uDD3C',
        eopf: '\uD835\uDD56',
        epar: '\u22D5',
        eparsl: '\u29E3',
        eplus: '\u2A71',
        epsi: '',
        Epsilon: '',
        epsilon: '',
        epsiv: '',
        eqcirc: '\u2256',
        eqcolon: '\u2255',
        eqsim: '\u2242',
        eqslantgtr: '\u2A96',
        eqslantless: '\u2A95',
        Equal: '\u2A75',
        equals: '=',
        EqualTilde: '\u2242',
        equest: '\u225F',
        Equilibrium: '\u21CC',
        equiv: '\u2261',
        equivDD: '\u2A78',
        eqvparsl: '\u29E5',
        erarr: '\u2971',
        erDot: '\u2253',
        Escr: '',
        escr: '',
        esdot: '\u2250',
        Esim: '\u2A73',
        esim: '\u2242',
        Eta: '',
        eta: '',
        ETH: '',
        eth: '',
        Euml: '',
        euml: '',
        euro: '\u20AC',
        excl: '!',
        exist: '\u2203',
        Exists: '\u2203',
        expectation: '',
        ExponentialE: '',
        exponentiale: '',
        fallingdotseq: '\u2252',
        Fcy: '',
        fcy: '',
        female: '\u2640',
        ffilig: '',
        fflig: '',
        ffllig: '',
        Ffr: '\uD835\uDD09',
        ffr: '\uD835\uDD23',
        filig: '',
        FilledSmallSquare: '\u25FC',
        FilledVerySmallSquare: '\u25AA',
        fjlig: 'fj',
        flat: '\u266D',
        fllig: '',
        fltns: '\u25B1',
        fnof: '',
        Fopf: '\uD835\uDD3D',
        fopf: '\uD835\uDD57',
        ForAll: '\u2200',
        forall: '\u2200',
        fork: '\u22D4',
        forkv: '\u2AD9',
        Fouriertrf: '',
        fpartint: '\u2A0D',
        frac12: '\xBD',
        frac13: '\u2153',
        frac14: '\xBC',
        frac15: '\u2155',
        frac16: '\u2159',
        frac18: '\u215B',
        frac23: '\u2154',
        frac25: '\u2156',
        frac34: '\xBE',
        frac35: '\u2157',
        frac38: '\u215C',
        frac45: '\u2158',
        frac56: '\u215A',
        frac58: '\u215D',
        frac78: '\u215E',
        frasl: '\u2044',
        frown: '\u2322',
        Fscr: '',
        fscr: '\uD835\uDCBB',
        gacute: '',
        Gamma: '',
        gamma: '',
        Gammad: '',
        gammad: '',
        gap: '\u2A86',
        Gbreve: '',
        gbreve: '',
        Gcedil: '',
        Gcirc: '',
        gcirc: '',
        Gcy: '',
        gcy: '',
        Gdot: '',
        gdot: '',
        gE: '\u2267',
        ge: '\u2265',
        gEl: '\u2A8C',
        gel: '\u22DB',
        geq: '\u2265',
        geqq: '\u2267',
        geqslant: '\u2A7E',
        ges: '\u2A7E',
        gescc: '\u2AA9',
        gesdot: '\u2A80',
        gesdoto: '\u2A82',
        gesdotol: '\u2A84',
        gesl: '\u22DB',
        gesles: '\u2A94',
        Gfr: '\uD835\uDD0A',
        gfr: '\uD835\uDD24',
        Gg: '\u22D9',
        gg: '\u226B',
        ggg: '\u22D9',
        gimel: '',
        GJcy: '',
        gjcy: '',
        gl: '\u2277',
        gla: '\u2AA5',
        glE: '\u2A92',
        glj: '\u2AA4',
        gnap: '\u2A8A',
        gnapprox: '\u2A8A',
        gnE: '\u2269',
        gne: '\u2A88',
        gneq: '\u2A88',
        gneqq: '\u2269',
        gnsim: '\u22E7',
        Gopf: '\uD835\uDD3E',
        gopf: '\uD835\uDD58',
        grave: '`',
        GreaterEqual: '\u2265',
        GreaterEqualLess: '\u22DB',
        GreaterFullEqual: '\u2267',
        GreaterGreater: '\u2AA2',
        GreaterLess: '\u2277',
        GreaterSlantEqual: '\u2A7E',
        GreaterTilde: '\u2273',
        Gscr: '\uD835\uDCA2',
        gscr: '',
        gsim: '\u2273',
        gsime: '\u2A8E',
        gsiml: '\u2A90',
        GT: '>',
        Gt: '\u226B',
        gt: '>',
        gtcc: '\u2AA7',
        gtcir: '\u2A7A',
        gtdot: '\u22D7',
        gtlPar: '\u2995',
        gtquest: '\u2A7C',
        gtrapprox: '\u2A86',
        gtrarr: '\u2978',
        gtrdot: '\u22D7',
        gtreqless: '\u22DB',
        gtreqqless: '\u2A8C',
        gtrless: '\u2277',
        gtrsim: '\u2273',
        gvertneqq: '\u2269',
        gvnE: '\u2269',
        Hacek: '',
        hairsp: '\u200A',
        half: '\xBD',
        hamilt: '',
        HARDcy: '',
        hardcy: '',
        hArr: '\u21D4',
        harr: '\u2194',
        harrcir: '\u2948',
        harrw: '\u21AD',
        Hat: '^',
        hbar: '',
        Hcirc: '',
        hcirc: '',
        hearts: '\u2665',
        heartsuit: '\u2665',
        hellip: '\u2026',
        hercon: '\u22B9',
        Hfr: '',
        hfr: '\uD835\uDD25',
        HilbertSpace: '',
        hksearow: '\u2925',
        hkswarow: '\u2926',
        hoarr: '\u21FF',
        homtht: '\u223B',
        hookleftarrow: '\u21A9',
        hookrightarrow: '\u21AA',
        Hopf: '',
        hopf: '\uD835\uDD59',
        horbar: '\u2015',
        HorizontalLine: '\u2500',
        Hscr: '',
        hscr: '\uD835\uDCBD',
        hslash: '',
        Hstrok: '',
        hstrok: '',
        HumpDownHump: '\u224E',
        HumpEqual: '\u224F',
        hybull: '\u2043',
        hyphen: '\u2010',
        Iacute: '',
        iacute: '',
        ic: '\u2063',
        Icirc: '',
        icirc: '',
        Icy: '',
        icy: '',
        Idot: '',
        IEcy: '',
        iecy: '',
        iexcl: '\xA1',
        iff: '\u21D4',
        Ifr: '',
        ifr: '\uD835\uDD26',
        Igrave: '',
        igrave: '',
        ii: '',
        iiiint: '\u2A0C',
        iiint: '\u222D',
        iinfin: '\u29DC',
        iiota: '\u2129',
        IJlig: '',
        ijlig: '',
        Im: '',
        Imacr: '',
        imacr: '',
        image: '',
        ImaginaryI: '',
        imagline: '',
        imagpart: '',
        imath: '',
        imof: '\u22B7',
        imped: '',
        Implies: '\u21D2',
        in: '\u2208',
        incare: '\u2105',
        infin: '\u221E',
        infintie: '\u29DD',
        inodot: '',
        Int: '\u222C',
        int: '\u222B',
        intcal: '\u22BA',
        integers: '',
        Integral: '\u222B',
        intercal: '\u22BA',
        Intersection: '\u22C2',
        intlarhk: '\u2A17',
        intprod: '\u2A3C',
        InvisibleComma: '\u2063',
        InvisibleTimes: '\u2062',
        IOcy: '',
        iocy: '',
        Iogon: '',
        iogon: '',
        Iopf: '\uD835\uDD40',
        iopf: '\uD835\uDD5A',
        Iota: '',
        iota: '',
        iprod: '\u2A3C',
        iquest: '\xBF',
        Iscr: '',
        iscr: '\uD835\uDCBE',
        isin: '\u2208',
        isindot: '\u22F5',
        isinE: '\u22F9',
        isins: '\u22F4',
        isinsv: '\u22F3',
        isinv: '\u2208',
        it: '\u2062',
        Itilde: '',
        itilde: '',
        Iukcy: '',
        iukcy: '',
        Iuml: '',
        iuml: '',
        Jcirc: '',
        jcirc: '',
        Jcy: '',
        jcy: '',
        Jfr: '\uD835\uDD0D',
        jfr: '\uD835\uDD27',
        jmath: '',
        Jopf: '\uD835\uDD41',
        jopf: '\uD835\uDD5B',
        Jscr: '\uD835\uDCA5',
        jscr: '\uD835\uDCBF',
        Jsercy: '',
        jsercy: '',
        Jukcy: '',
        jukcy: '',
        Kappa: '',
        kappa: '',
        kappav: '',
        Kcedil: '',
        kcedil: '',
        Kcy: '',
        kcy: '',
        Kfr: '\uD835\uDD0E',
        kfr: '\uD835\uDD28',
        kgreen: '',
        KHcy: '',
        khcy: '',
        KJcy: '',
        kjcy: '',
        Kopf: '\uD835\uDD42',
        kopf: '\uD835\uDD5C',
        Kscr: '\uD835\uDCA6',
        kscr: '\uD835\uDCC0',
        lAarr: '\u21DA',
        Lacute: '',
        lacute: '',
        laemptyv: '\u29B4',
        lagran: '',
        Lambda: '',
        lambda: '',
        Lang: '\u27EA',
        lang: '\u27E8',
        langd: '\u2991',
        langle: '\u27E8',
        lap: '\u2A85',
        Laplacetrf: '',
        laquo: '\xAB',
        Larr: '\u219E',
        lArr: '\u21D0',
        larr: '\u2190',
        larrb: '\u21E4',
        larrbfs: '\u291F',
        larrfs: '\u291D',
        larrhk: '\u21A9',
        larrlp: '\u21AB',
        larrpl: '\u2939',
        larrsim: '\u2973',
        larrtl: '\u21A2',
        lat: '\u2AAB',
        lAtail: '\u291B',
        latail: '\u2919',
        late: '\u2AAD',
        lates: '\u2AAD',
        lBarr: '\u290E',
        lbarr: '\u290C',
        lbbrk: '\u2772',
        lbrace: '{',
        lbrack: '[',
        lbrke: '\u298B',
        lbrksld: '\u298F',
        lbrkslu: '\u298D',
        Lcaron: '',
        lcaron: '',
        Lcedil: '',
        lcedil: '',
        lceil: '\u2308',
        lcub: '{',
        Lcy: '',
        lcy: '',
        ldca: '\u2936',
        ldquo: '\u201C',
        ldquor: '\u201E',
        ldrdhar: '\u2967',
        ldrushar: '\u294B',
        ldsh: '\u21B2',
        lE: '\u2266',
        le: '\u2264',
        LeftAngleBracket: '\u27E8',
        LeftArrow: '\u2190',
        Leftarrow: '\u21D0',
        leftarrow: '\u2190',
        LeftArrowBar: '\u21E4',
        LeftArrowRightArrow: '\u21C6',
        leftarrowtail: '\u21A2',
        LeftCeiling: '\u2308',
        LeftDoubleBracket: '\u27E6',
        LeftDownTeeVector: '\u2961',
        LeftDownVector: '\u21C3',
        LeftDownVectorBar: '\u2959',
        LeftFloor: '\u230A',
        leftharpoondown: '\u21BD',
        leftharpoonup: '\u21BC',
        leftleftarrows: '\u21C7',
        LeftRightArrow: '\u2194',
        Leftrightarrow: '\u21D4',
        leftrightarrow: '\u2194',
        leftrightarrows: '\u21C6',
        leftrightharpoons: '\u21CB',
        leftrightsquigarrow: '\u21AD',
        LeftRightVector: '\u294E',
        LeftTee: '\u22A3',
        LeftTeeArrow: '\u21A4',
        LeftTeeVector: '\u295A',
        leftthreetimes: '\u22CB',
        LeftTriangle: '\u22B2',
        LeftTriangleBar: '\u29CF',
        LeftTriangleEqual: '\u22B4',
        LeftUpDownVector: '\u2951',
        LeftUpTeeVector: '\u2960',
        LeftUpVector: '\u21BF',
        LeftUpVectorBar: '\u2958',
        LeftVector: '\u21BC',
        LeftVectorBar: '\u2952',
        lEg: '\u2A8B',
        leg: '\u22DA',
        leq: '\u2264',
        leqq: '\u2266',
        leqslant: '\u2A7D',
        les: '\u2A7D',
        lescc: '\u2AA8',
        lesdot: '\u2A7F',
        lesdoto: '\u2A81',
        lesdotor: '\u2A83',
        lesg: '\u22DA',
        lesges: '\u2A93',
        lessapprox: '\u2A85',
        lessdot: '\u22D6',
        lesseqgtr: '\u22DA',
        lesseqqgtr: '\u2A8B',
        LessEqualGreater: '\u22DA',
        LessFullEqual: '\u2266',
        LessGreater: '\u2276',
        lessgtr: '\u2276',
        LessLess: '\u2AA1',
        lesssim: '\u2272',
        LessSlantEqual: '\u2A7D',
        LessTilde: '\u2272',
        lfisht: '\u297C',
        lfloor: '\u230A',
        Lfr: '\uD835\uDD0F',
        lfr: '\uD835\uDD29',
        lg: '\u2276',
        lgE: '\u2A91',
        lHar: '\u2962',
        lhard: '\u21BD',
        lharu: '\u21BC',
        lharul: '\u296A',
        lhblk: '\u2584',
        LJcy: '',
        ljcy: '',
        Ll: '\u22D8',
        ll: '\u226A',
        llarr: '\u21C7',
        llcorner: '\u231E',
        Lleftarrow: '\u21DA',
        llhard: '\u296B',
        lltri: '\u25FA',
        Lmidot: '',
        lmidot: '',
        lmoust: '\u23B0',
        lmoustache: '\u23B0',
        lnap: '\u2A89',
        lnapprox: '\u2A89',
        lnE: '\u2268',
        lne: '\u2A87',
        lneq: '\u2A87',
        lneqq: '\u2268',
        lnsim: '\u22E6',
        loang: '\u27EC',
        loarr: '\u21FD',
        lobrk: '\u27E6',
        LongLeftArrow: '\u27F5',
        Longleftarrow: '\u27F8',
        longleftarrow: '\u27F5',
        LongLeftRightArrow: '\u27F7',
        Longleftrightarrow: '\u27FA',
        longleftrightarrow: '\u27F7',
        longmapsto: '\u27FC',
        LongRightArrow: '\u27F6',
        Longrightarrow: '\u27F9',
        longrightarrow: '\u27F6',
        looparrowleft: '\u21AB',
        looparrowright: '\u21AC',
        lopar: '\u2985',
        Lopf: '\uD835\uDD43',
        lopf: '\uD835\uDD5D',
        loplus: '\u2A2D',
        lotimes: '\u2A34',
        lowast: '\u2217',
        lowbar: '_',
        LowerLeftArrow: '\u2199',
        LowerRightArrow: '\u2198',
        loz: '\u25CA',
        lozenge: '\u25CA',
        lozf: '\u29EB',
        lpar: '(',
        lparlt: '\u2993',
        lrarr: '\u21C6',
        lrcorner: '\u231F',
        lrhar: '\u21CB',
        lrhard: '\u296D',
        lrm: '\u200E',
        lrtri: '\u22BF',
        lsaquo: '\u2039',
        Lscr: '',
        lscr: '\uD835\uDCC1',
        Lsh: '\u21B0',
        lsh: '\u21B0',
        lsim: '\u2272',
        lsime: '\u2A8D',
        lsimg: '\u2A8F',
        lsqb: '[',
        lsquo: '\u2018',
        lsquor: '\u201A',
        Lstrok: '',
        lstrok: '',
        LT: '<',
        Lt: '\u226A',
        lt: '<',
        ltcc: '\u2AA6',
        ltcir: '\u2A79',
        ltdot: '\u22D6',
        lthree: '\u22CB',
        ltimes: '\u22C9',
        ltlarr: '\u2976',
        ltquest: '\u2A7B',
        ltri: '\u25C3',
        ltrie: '\u22B4',
        ltrif: '\u25C2',
        ltrPar: '\u2996',
        lurdshar: '\u294A',
        luruhar: '\u2966',
        lvertneqq: '\u2268',
        lvnE: '\u2268',
        macr: '\xAF',
        male: '\u2642',
        malt: '\u2720',
        maltese: '\u2720',
        Map: '\u2905',
        map: '\u21A6',
        mapsto: '\u21A6',
        mapstodown: '\u21A7',
        mapstoleft: '\u21A4',
        mapstoup: '\u21A5',
        marker: '\u25AE',
        mcomma: '\u2A29',
        Mcy: '',
        mcy: '',
        mdash: '\u2014',
        mDDot: '\u223A',
        measuredangle: '\u2221',
        MediumSpace: '\u205F',
        Mellintrf: '',
        Mfr: '\uD835\uDD10',
        mfr: '\uD835\uDD2A',
        mho: '\u2127',
        micro: '',
        mid: '\u2223',
        midast: '*',
        midcir: '\u2AF0',
        middot: '\xB7',
        minus: '\u2212',
        minusb: '\u229F',
        minusd: '\u2238',
        minusdu: '\u2A2A',
        MinusPlus: '\u2213',
        mlcp: '\u2ADB',
        mldr: '\u2026',
        mnplus: '\u2213',
        models: '\u22A7',
        Mopf: '\uD835\uDD44',
        mopf: '\uD835\uDD5E',
        mp: '\u2213',
        Mscr: '',
        mscr: '\uD835\uDCC2',
        mstpos: '\u223E',
        Mu: '',
        mu: '',
        multimap: '\u22B8',
        mumap: '\u22B8',
        nabla: '\u2207',
        Nacute: '',
        nacute: '',
        nang: '\u2220',
        nap: '\u2249',
        napE: '\u2A70',
        napid: '\u224B',
        napos: '',
        napprox: '\u2249',
        natur: '\u266E',
        natural: '\u266E',
        naturals: '',
        nbsp: '\xA0',
        nbump: '\u224E',
        nbumpe: '\u224F',
        ncap: '\u2A43',
        Ncaron: '',
        ncaron: '',
        Ncedil: '',
        ncedil: '',
        ncong: '\u2247',
        ncongdot: '\u2A6D',
        ncup: '\u2A42',
        Ncy: '',
        ncy: '',
        ndash: '\u2013',
        ne: '\u2260',
        nearhk: '\u2924',
        neArr: '\u21D7',
        nearr: '\u2197',
        nearrow: '\u2197',
        nedot: '\u2250',
        NegativeMediumSpace: '\u200B',
        NegativeThickSpace: '\u200B',
        NegativeThinSpace: '\u200B',
        NegativeVeryThinSpace: '\u200B',
        nequiv: '\u2262',
        nesear: '\u2928',
        nesim: '\u2242',
        NestedGreaterGreater: '\u226B',
        NestedLessLess: '\u226A',
        NewLine: '\n',
        nexist: '\u2204',
        nexists: '\u2204',
        Nfr: '\uD835\uDD11',
        nfr: '\uD835\uDD2B',
        ngE: '\u2267',
        nge: '\u2271',
        ngeq: '\u2271',
        ngeqq: '\u2267',
        ngeqslant: '\u2A7E',
        nges: '\u2A7E',
        nGg: '\u22D9',
        ngsim: '\u2275',
        nGt: '\u226B',
        ngt: '\u226F',
        ngtr: '\u226F',
        nGtv: '\u226B',
        nhArr: '\u21CE',
        nharr: '\u21AE',
        nhpar: '\u2AF2',
        ni: '\u220B',
        nis: '\u22FC',
        nisd: '\u22FA',
        niv: '\u220B',
        NJcy: '',
        njcy: '',
        nlArr: '\u21CD',
        nlarr: '\u219A',
        nldr: '\u2025',
        nlE: '\u2266',
        nle: '\u2270',
        nLeftarrow: '\u21CD',
        nleftarrow: '\u219A',
        nLeftrightarrow: '\u21CE',
        nleftrightarrow: '\u21AE',
        nleq: '\u2270',
        nleqq: '\u2266',
        nleqslant: '\u2A7D',
        nles: '\u2A7D',
        nless: '\u226E',
        nLl: '\u22D8',
        nlsim: '\u2274',
        nLt: '\u226A',
        nlt: '\u226E',
        nltri: '\u22EA',
        nltrie: '\u22EC',
        nLtv: '\u226A',
        nmid: '\u2224',
        NoBreak: '\u2060',
        NonBreakingSpace: '\xA0',
        Nopf: '',
        nopf: '\uD835\uDD5F',
        Not: '\u2AEC',
        not: '\xAC',
        NotCongruent: '\u2262',
        NotCupCap: '\u226D',
        NotDoubleVerticalBar: '\u2226',
        NotElement: '\u2209',
        NotEqual: '\u2260',
        NotEqualTilde: '\u2242',
        NotExists: '\u2204',
        NotGreater: '\u226F',
        NotGreaterEqual: '\u2271',
        NotGreaterFullEqual: '\u2267',
        NotGreaterGreater: '\u226B',
        NotGreaterLess: '\u2279',
        NotGreaterSlantEqual: '\u2A7E',
        NotGreaterTilde: '\u2275',
        NotHumpDownHump: '\u224E',
        NotHumpEqual: '\u224F',
        notin: '\u2209',
        notindot: '\u22F5',
        notinE: '\u22F9',
        notinva: '\u2209',
        notinvb: '\u22F7',
        notinvc: '\u22F6',
        NotLeftTriangle: '\u22EA',
        NotLeftTriangleBar: '\u29CF',
        NotLeftTriangleEqual: '\u22EC',
        NotLess: '\u226E',
        NotLessEqual: '\u2270',
        NotLessGreater: '\u2278',
        NotLessLess: '\u226A',
        NotLessSlantEqual: '\u2A7D',
        NotLessTilde: '\u2274',
        NotNestedGreaterGreater: '\u2AA2',
        NotNestedLessLess: '\u2AA1',
        notni: '\u220C',
        notniva: '\u220C',
        notnivb: '\u22FE',
        notnivc: '\u22FD',
        NotPrecedes: '\u2280',
        NotPrecedesEqual: '\u2AAF',
        NotPrecedesSlantEqual: '\u22E0',
        NotReverseElement: '\u220C',
        NotRightTriangle: '\u22EB',
        NotRightTriangleBar: '\u29D0',
        NotRightTriangleEqual: '\u22ED',
        NotSquareSubset: '\u228F',
        NotSquareSubsetEqual: '\u22E2',
        NotSquareSuperset: '\u2290',
        NotSquareSupersetEqual: '\u22E3',
        NotSubset: '\u2282',
        NotSubsetEqual: '\u2288',
        NotSucceeds: '\u2281',
        NotSucceedsEqual: '\u2AB0',
        NotSucceedsSlantEqual: '\u22E1',
        NotSucceedsTilde: '\u227F',
        NotSuperset: '\u2283',
        NotSupersetEqual: '\u2289',
        NotTilde: '\u2241',
        NotTildeEqual: '\u2244',
        NotTildeFullEqual: '\u2247',
        NotTildeTilde: '\u2249',
        NotVerticalBar: '\u2224',
        npar: '\u2226',
        nparallel: '\u2226',
        nparsl: '\u2AFD',
        npart: '\u2202',
        npolint: '\u2A14',
        npr: '\u2280',
        nprcue: '\u22E0',
        npre: '\u2AAF',
        nprec: '\u2280',
        npreceq: '\u2AAF',
        nrArr: '\u21CF',
        nrarr: '\u219B',
        nrarrc: '\u2933',
        nrarrw: '\u219D',
        nRightarrow: '\u21CF',
        nrightarrow: '\u219B',
        nrtri: '\u22EB',
        nrtrie: '\u22ED',
        nsc: '\u2281',
        nsccue: '\u22E1',
        nsce: '\u2AB0',
        Nscr: '\uD835\uDCA9',
        nscr: '\uD835\uDCC3',
        nshortmid: '\u2224',
        nshortparallel: '\u2226',
        nsim: '\u2241',
        nsime: '\u2244',
        nsimeq: '\u2244',
        nsmid: '\u2224',
        nspar: '\u2226',
        nsqsube: '\u22E2',
        nsqsupe: '\u22E3',
        nsub: '\u2284',
        nsubE: '\u2AC5',
        nsube: '\u2288',
        nsubset: '\u2282',
        nsubseteq: '\u2288',
        nsubseteqq: '\u2AC5',
        nsucc: '\u2281',
        nsucceq: '\u2AB0',
        nsup: '\u2285',
        nsupE: '\u2AC6',
        nsupe: '\u2289',
        nsupset: '\u2283',
        nsupseteq: '\u2289',
        nsupseteqq: '\u2AC6',
        ntgl: '\u2279',
        Ntilde: '',
        ntilde: '',
        ntlg: '\u2278',
        ntriangleleft: '\u22EA',
        ntrianglelefteq: '\u22EC',
        ntriangleright: '\u22EB',
        ntrianglerighteq: '\u22ED',
        Nu: '',
        nu: '',
        num: '#',
        numero: '\u2116',
        numsp: '\u2007',
        nvap: '\u224D',
        nVDash: '\u22AF',
        nVdash: '\u22AE',
        nvDash: '\u22AD',
        nvdash: '\u22AC',
        nvge: '\u2265',
        nvgt: '>',
        nvHarr: '\u2904',
        nvinfin: '\u29DE',
        nvlArr: '\u2902',
        nvle: '\u2264',
        nvlt: '<',
        nvltrie: '\u22B4',
        nvrArr: '\u2903',
        nvrtrie: '\u22B5',
        nvsim: '\u223C',
        nwarhk: '\u2923',
        nwArr: '\u21D6',
        nwarr: '\u2196',
        nwarrow: '\u2196',
        nwnear: '\u2927',
        Oacute: '',
        oacute: '',
        oast: '\u229B',
        ocir: '\u229A',
        Ocirc: '',
        ocirc: '',
        Ocy: '',
        ocy: '',
        odash: '\u229D',
        Odblac: '',
        odblac: '',
        odiv: '\u2A38',
        odot: '\u2299',
        odsold: '\u29BC',
        OElig: '',
        oelig: '',
        ofcir: '\u29BF',
        Ofr: '\uD835\uDD12',
        ofr: '\uD835\uDD2C',
        ogon: '\u02DB',
        Ograve: '',
        ograve: '',
        ogt: '\u29C1',
        ohbar: '\u29B5',
        ohm: '',
        oint: '\u222E',
        olarr: '\u21BA',
        olcir: '\u29BE',
        olcross: '\u29BB',
        oline: '\u203E',
        olt: '\u29C0',
        Omacr: '',
        omacr: '',
        Omega: '',
        omega: '',
        Omicron: '',
        omicron: '',
        omid: '\u29B6',
        ominus: '\u2296',
        Oopf: '\uD835\uDD46',
        oopf: '\uD835\uDD60',
        opar: '\u29B7',
        OpenCurlyDoubleQuote: '\u201C',
        OpenCurlyQuote: '\u2018',
        operp: '\u29B9',
        oplus: '\u2295',
        Or: '\u2A54',
        or: '\u2228',
        orarr: '\u21BB',
        ord: '\u2A5D',
        order: '',
        orderof: '',
        ordf: '',
        ordm: '',
        origof: '\u22B6',
        oror: '\u2A56',
        orslope: '\u2A57',
        orv: '\u2A5B',
        oS: '\u24C8',
        Oscr: '\uD835\uDCAA',
        oscr: '',
        Oslash: '',
        oslash: '',
        osol: '\u2298',
        Otilde: '',
        otilde: '',
        Otimes: '\u2A37',
        otimes: '\u2297',
        otimesas: '\u2A36',
        Ouml: '',
        ouml: '',
        ovbar: '\u233D',
        OverBar: '\u203E',
        OverBrace: '\u23DE',
        OverBracket: '\u23B4',
        OverParenthesis: '\u23DC',
        par: '\u2225',
        para: '\xB6',
        parallel: '\u2225',
        parsim: '\u2AF3',
        parsl: '\u2AFD',
        part: '\u2202',
        PartialD: '\u2202',
        Pcy: '',
        pcy: '',
        percnt: '%',
        period: '.',
        permil: '\u2030',
        perp: '\u22A5',
        pertenk: '\u2031',
        Pfr: '\uD835\uDD13',
        pfr: '\uD835\uDD2D',
        Phi: '',
        phi: '',
        phiv: '',
        phmmat: '',
        phone: '\u260E',
        Pi: '',
        pi: '',
        pitchfork: '\u22D4',
        piv: '',
        planck: '',
        planckh: '',
        plankv: '',
        plus: '+',
        plusacir: '\u2A23',
        plusb: '\u229E',
        pluscir: '\u2A22',
        plusdo: '\u2214',
        plusdu: '\u2A25',
        pluse: '\u2A72',
        PlusMinus: '\xB1',
        plusmn: '\xB1',
        plussim: '\u2A26',
        plustwo: '\u2A27',
        pm: '\xB1',
        Poincareplane: '',
        pointint: '\u2A15',
        Popf: '',
        popf: '\uD835\uDD61',
        pound: '\xA3',
        Pr: '\u2ABB',
        pr: '\u227A',
        prap: '\u2AB7',
        prcue: '\u227C',
        prE: '\u2AB3',
        pre: '\u2AAF',
        prec: '\u227A',
        precapprox: '\u2AB7',
        preccurlyeq: '\u227C',
        Precedes: '\u227A',
        PrecedesEqual: '\u2AAF',
        PrecedesSlantEqual: '\u227C',
        PrecedesTilde: '\u227E',
        preceq: '\u2AAF',
        precnapprox: '\u2AB9',
        precneqq: '\u2AB5',
        precnsim: '\u22E8',
        precsim: '\u227E',
        Prime: '\u2033',
        prime: '\u2032',
        primes: '',
        prnap: '\u2AB9',
        prnE: '\u2AB5',
        prnsim: '\u22E8',
        prod: '\u220F',
        Product: '\u220F',
        profalar: '\u232E',
        profline: '\u2312',
        profsurf: '\u2313',
        prop: '\u221D',
        Proportion: '\u2237',
        Proportional: '\u221D',
        propto: '\u221D',
        prsim: '\u227E',
        prurel: '\u22B0',
        Pscr: '\uD835\uDCAB',
        pscr: '\uD835\uDCC5',
        Psi: '',
        psi: '',
        puncsp: '\u2008',
        Qfr: '\uD835\uDD14',
        qfr: '\uD835\uDD2E',
        qint: '\u2A0C',
        Qopf: '',
        qopf: '\uD835\uDD62',
        qprime: '\u2057',
        Qscr: '\uD835\uDCAC',
        qscr: '\uD835\uDCC6',
        quaternions: '',
        quatint: '\u2A16',
        quest: '?',
        questeq: '\u225F',
        QUOT: '"',
        quot: '"',
        rAarr: '\u21DB',
        race: '\u223D',
        Racute: '',
        racute: '',
        radic: '\u221A',
        raemptyv: '\u29B3',
        Rang: '\u27EB',
        rang: '\u27E9',
        rangd: '\u2992',
        range: '\u29A5',
        rangle: '\u27E9',
        raquo: '\xBB',
        Rarr: '\u21A0',
        rArr: '\u21D2',
        rarr: '\u2192',
        rarrap: '\u2975',
        rarrb: '\u21E5',
        rarrbfs: '\u2920',
        rarrc: '\u2933',
        rarrfs: '\u291E',
        rarrhk: '\u21AA',
        rarrlp: '\u21AC',
        rarrpl: '\u2945',
        rarrsim: '\u2974',
        Rarrtl: '\u2916',
        rarrtl: '\u21A3',
        rarrw: '\u219D',
        rAtail: '\u291C',
        ratail: '\u291A',
        ratio: '\u2236',
        rationals: '',
        RBarr: '\u2910',
        rBarr: '\u290F',
        rbarr: '\u290D',
        rbbrk: '\u2773',
        rbrace: '}',
        rbrack: ']',
        rbrke: '\u298C',
        rbrksld: '\u298E',
        rbrkslu: '\u2990',
        Rcaron: '',
        rcaron: '',
        Rcedil: '',
        rcedil: '',
        rceil: '\u2309',
        rcub: '}',
        Rcy: '',
        rcy: '',
        rdca: '\u2937',
        rdldhar: '\u2969',
        rdquo: '\u201D',
        rdquor: '\u201D',
        rdsh: '\u21B3',
        Re: '',
        real: '',
        realine: '',
        realpart: '',
        reals: '',
        rect: '\u25AD',
        REG: '\xAE',
        reg: '\xAE',
        ReverseElement: '\u220B',
        ReverseEquilibrium: '\u21CB',
        ReverseUpEquilibrium: '\u296F',
        rfisht: '\u297D',
        rfloor: '\u230B',
        Rfr: '',
        rfr: '\uD835\uDD2F',
        rHar: '\u2964',
        rhard: '\u21C1',
        rharu: '\u21C0',
        rharul: '\u296C',
        Rho: '',
        rho: '',
        rhov: '',
        RightAngleBracket: '\u27E9',
        RightArrow: '\u2192',
        Rightarrow: '\u21D2',
        rightarrow: '\u2192',
        RightArrowBar: '\u21E5',
        RightArrowLeftArrow: '\u21C4',
        rightarrowtail: '\u21A3',
        RightCeiling: '\u2309',
        RightDoubleBracket: '\u27E7',
        RightDownTeeVector: '\u295D',
        RightDownVector: '\u21C2',
        RightDownVectorBar: '\u2955',
        RightFloor: '\u230B',
        rightharpoondown: '\u21C1',
        rightharpoonup: '\u21C0',
        rightleftarrows: '\u21C4',
        rightleftharpoons: '\u21CC',
        rightrightarrows: '\u21C9',
        rightsquigarrow: '\u219D',
        RightTee: '\u22A2',
        RightTeeArrow: '\u21A6',
        RightTeeVector: '\u295B',
        rightthreetimes: '\u22CC',
        RightTriangle: '\u22B3',
        RightTriangleBar: '\u29D0',
        RightTriangleEqual: '\u22B5',
        RightUpDownVector: '\u294F',
        RightUpTeeVector: '\u295C',
        RightUpVector: '\u21BE',
        RightUpVectorBar: '\u2954',
        RightVector: '\u21C0',
        RightVectorBar: '\u2953',
        ring: '\u02DA',
        risingdotseq: '\u2253',
        rlarr: '\u21C4',
        rlhar: '\u21CC',
        rlm: '\u200F',
        rmoust: '\u23B1',
        rmoustache: '\u23B1',
        rnmid: '\u2AEE',
        roang: '\u27ED',
        roarr: '\u21FE',
        robrk: '\u27E7',
        ropar: '\u2986',
        Ropf: '',
        ropf: '\uD835\uDD63',
        roplus: '\u2A2E',
        rotimes: '\u2A35',
        RoundImplies: '\u2970',
        rpar: ')',
        rpargt: '\u2994',
        rppolint: '\u2A12',
        rrarr: '\u21C9',
        Rrightarrow: '\u21DB',
        rsaquo: '\u203A',
        Rscr: '',
        rscr: '\uD835\uDCC7',
        Rsh: '\u21B1',
        rsh: '\u21B1',
        rsqb: ']',
        rsquo: '\u2019',
        rsquor: '\u2019',
        rthree: '\u22CC',
        rtimes: '\u22CA',
        rtri: '\u25B9',
        rtrie: '\u22B5',
        rtrif: '\u25B8',
        rtriltri: '\u29CE',
        RuleDelayed: '\u29F4',
        ruluhar: '\u2968',
        rx: '\u211E',
        Sacute: '',
        sacute: '',
        sbquo: '\u201A',
        Sc: '\u2ABC',
        sc: '\u227B',
        scap: '\u2AB8',
        Scaron: '',
        scaron: '',
        sccue: '\u227D',
        scE: '\u2AB4',
        sce: '\u2AB0',
        Scedil: '',
        scedil: '',
        Scirc: '',
        scirc: '',
        scnap: '\u2ABA',
        scnE: '\u2AB6',
        scnsim: '\u22E9',
        scpolint: '\u2A13',
        scsim: '\u227F',
        Scy: '',
        scy: '',
        sdot: '\u22C5',
        sdotb: '\u22A1',
        sdote: '\u2A66',
        searhk: '\u2925',
        seArr: '\u21D8',
        searr: '\u2198',
        searrow: '\u2198',
        sect: '\xA7',
        semi: ';',
        seswar: '\u2929',
        setminus: '\u2216',
        setmn: '\u2216',
        sext: '\u2736',
        Sfr: '\uD835\uDD16',
        sfr: '\uD835\uDD30',
        sfrown: '\u2322',
        sharp: '\u266F',
        SHCHcy: '',
        shchcy: '',
        SHcy: '',
        shcy: '',
        ShortDownArrow: '\u2193',
        ShortLeftArrow: '\u2190',
        shortmid: '\u2223',
        shortparallel: '\u2225',
        ShortRightArrow: '\u2192',
        ShortUpArrow: '\u2191',
        shy: '\xAD',
        Sigma: '',
        sigma: '',
        sigmaf: '',
        sigmav: '',
        sim: '\u223C',
        simdot: '\u2A6A',
        sime: '\u2243',
        simeq: '\u2243',
        simg: '\u2A9E',
        simgE: '\u2AA0',
        siml: '\u2A9D',
        simlE: '\u2A9F',
        simne: '\u2246',
        simplus: '\u2A24',
        simrarr: '\u2972',
        slarr: '\u2190',
        SmallCircle: '\u2218',
        smallsetminus: '\u2216',
        smashp: '\u2A33',
        smeparsl: '\u29E4',
        smid: '\u2223',
        smile: '\u2323',
        smt: '\u2AAA',
        smte: '\u2AAC',
        smtes: '\u2AAC',
        SOFTcy: '',
        softcy: '',
        sol: '/',
        solb: '\u29C4',
        solbar: '\u233F',
        Sopf: '\uD835\uDD4A',
        sopf: '\uD835\uDD64',
        spades: '\u2660',
        spadesuit: '\u2660',
        spar: '\u2225',
        sqcap: '\u2293',
        sqcaps: '\u2293',
        sqcup: '\u2294',
        sqcups: '\u2294',
        Sqrt: '\u221A',
        sqsub: '\u228F',
        sqsube: '\u2291',
        sqsubset: '\u228F',
        sqsubseteq: '\u2291',
        sqsup: '\u2290',
        sqsupe: '\u2292',
        sqsupset: '\u2290',
        sqsupseteq: '\u2292',
        squ: '\u25A1',
        Square: '\u25A1',
        square: '\u25A1',
        SquareIntersection: '\u2293',
        SquareSubset: '\u228F',
        SquareSubsetEqual: '\u2291',
        SquareSuperset: '\u2290',
        SquareSupersetEqual: '\u2292',
        SquareUnion: '\u2294',
        squarf: '\u25AA',
        squf: '\u25AA',
        srarr: '\u2192',
        Sscr: '\uD835\uDCAE',
        sscr: '\uD835\uDCC8',
        ssetmn: '\u2216',
        ssmile: '\u2323',
        sstarf: '\u22C6',
        Star: '\u22C6',
        star: '\u2606',
        starf: '\u2605',
        straightepsilon: '',
        straightphi: '',
        strns: '\xAF',
        Sub: '\u22D0',
        sub: '\u2282',
        subdot: '\u2ABD',
        subE: '\u2AC5',
        sube: '\u2286',
        subedot: '\u2AC3',
        submult: '\u2AC1',
        subnE: '\u2ACB',
        subne: '\u228A',
        subplus: '\u2ABF',
        subrarr: '\u2979',
        Subset: '\u22D0',
        subset: '\u2282',
        subseteq: '\u2286',
        subseteqq: '\u2AC5',
        SubsetEqual: '\u2286',
        subsetneq: '\u228A',
        subsetneqq: '\u2ACB',
        subsim: '\u2AC7',
        subsub: '\u2AD5',
        subsup: '\u2AD3',
        succ: '\u227B',
        succapprox: '\u2AB8',
        succcurlyeq: '\u227D',
        Succeeds: '\u227B',
        SucceedsEqual: '\u2AB0',
        SucceedsSlantEqual: '\u227D',
        SucceedsTilde: '\u227F',
        succeq: '\u2AB0',
        succnapprox: '\u2ABA',
        succneqq: '\u2AB6',
        succnsim: '\u22E9',
        succsim: '\u227F',
        SuchThat: '\u220B',
        Sum: '\u2211',
        sum: '\u2211',
        sung: '\u266A',
        Sup: '\u22D1',
        sup: '\u2283',
        sup1: '\xB9',
        sup2: '\xB2',
        sup3: '\xB3',
        supdot: '\u2ABE',
        supdsub: '\u2AD8',
        supE: '\u2AC6',
        supe: '\u2287',
        supedot: '\u2AC4',
        Superset: '\u2283',
        SupersetEqual: '\u2287',
        suphsol: '\u27C9',
        suphsub: '\u2AD7',
        suplarr: '\u297B',
        supmult: '\u2AC2',
        supnE: '\u2ACC',
        supne: '\u228B',
        supplus: '\u2AC0',
        Supset: '\u22D1',
        supset: '\u2283',
        supseteq: '\u2287',
        supseteqq: '\u2AC6',
        supsetneq: '\u228B',
        supsetneqq: '\u2ACC',
        supsim: '\u2AC8',
        supsub: '\u2AD4',
        supsup: '\u2AD6',
        swarhk: '\u2926',
        swArr: '\u21D9',
        swarr: '\u2199',
        swarrow: '\u2199',
        swnwar: '\u292A',
        szlig: '',
        Tab: '\t',
        target: '\u2316',
        Tau: '',
        tau: '',
        tbrk: '\u23B4',
        Tcaron: '',
        tcaron: '',
        Tcedil: '',
        tcedil: '',
        Tcy: '',
        tcy: '',
        tdot: '',
        telrec: '\u2315',
        Tfr: '\uD835\uDD17',
        tfr: '\uD835\uDD31',
        there4: '\u2234',
        Therefore: '\u2234',
        therefore: '\u2234',
        Theta: '',
        theta: '',
        thetasym: '',
        thetav: '',
        thickapprox: '\u2248',
        thicksim: '\u223C',
        ThickSpace: '\u205F\u200A',
        thinsp: '\u2009',
        ThinSpace: '\u2009',
        thkap: '\u2248',
        thksim: '\u223C',
        THORN: '',
        thorn: '',
        Tilde: '\u223C',
        tilde: '\u02DC',
        TildeEqual: '\u2243',
        TildeFullEqual: '\u2245',
        TildeTilde: '\u2248',
        times: '\xD7',
        timesb: '\u22A0',
        timesbar: '\u2A31',
        timesd: '\u2A30',
        tint: '\u222D',
        toea: '\u2928',
        top: '\u22A4',
        topbot: '\u2336',
        topcir: '\u2AF1',
        Topf: '\uD835\uDD4B',
        topf: '\uD835\uDD65',
        topfork: '\u2ADA',
        tosa: '\u2929',
        tprime: '\u2034',
        TRADE: '\u2122',
        trade: '\u2122',
        triangle: '\u25B5',
        triangledown: '\u25BF',
        triangleleft: '\u25C3',
        trianglelefteq: '\u22B4',
        triangleq: '\u225C',
        triangleright: '\u25B9',
        trianglerighteq: '\u22B5',
        tridot: '\u25EC',
        trie: '\u225C',
        triminus: '\u2A3A',
        TripleDot: '',
        triplus: '\u2A39',
        trisb: '\u29CD',
        tritime: '\u2A3B',
        trpezium: '\u23E2',
        Tscr: '\uD835\uDCAF',
        tscr: '\uD835\uDCC9',
        TScy: '',
        tscy: '',
        TSHcy: '',
        tshcy: '',
        Tstrok: '',
        tstrok: '',
        twixt: '\u226C',
        twoheadleftarrow: '\u219E',
        twoheadrightarrow: '\u21A0',
        Uacute: '',
        uacute: '',
        Uarr: '\u219F',
        uArr: '\u21D1',
        uarr: '\u2191',
        Uarrocir: '\u2949',
        Ubrcy: '',
        ubrcy: '',
        Ubreve: '',
        ubreve: '',
        Ucirc: '',
        ucirc: '',
        Ucy: '',
        ucy: '',
        udarr: '\u21C5',
        Udblac: '',
        udblac: '',
        udhar: '\u296E',
        ufisht: '\u297E',
        Ufr: '\uD835\uDD18',
        ufr: '\uD835\uDD32',
        Ugrave: '',
        ugrave: '',
        uHar: '\u2963',
        uharl: '\u21BF',
        uharr: '\u21BE',
        uhblk: '\u2580',
        ulcorn: '\u231C',
        ulcorner: '\u231C',
        ulcrop: '\u230F',
        ultri: '\u25F8',
        Umacr: '',
        umacr: '',
        uml: '\xA8',
        UnderBar: '_',
        UnderBrace: '\u23DF',
        UnderBracket: '\u23B5',
        UnderParenthesis: '\u23DD',
        Union: '\u22C3',
        UnionPlus: '\u228E',
        Uogon: '',
        uogon: '',
        Uopf: '\uD835\uDD4C',
        uopf: '\uD835\uDD66',
        UpArrow: '\u2191',
        Uparrow: '\u21D1',
        uparrow: '\u2191',
        UpArrowBar: '\u2912',
        UpArrowDownArrow: '\u21C5',
        UpDownArrow: '\u2195',
        Updownarrow: '\u21D5',
        updownarrow: '\u2195',
        UpEquilibrium: '\u296E',
        upharpoonleft: '\u21BF',
        upharpoonright: '\u21BE',
        uplus: '\u228E',
        UpperLeftArrow: '\u2196',
        UpperRightArrow: '\u2197',
        Upsi: '',
        upsi: '',
        upsih: '',
        Upsilon: '',
        upsilon: '',
        UpTee: '\u22A5',
        UpTeeArrow: '\u21A5',
        upuparrows: '\u21C8',
        urcorn: '\u231D',
        urcorner: '\u231D',
        urcrop: '\u230E',
        Uring: '',
        uring: '',
        urtri: '\u25F9',
        Uscr: '\uD835\uDCB0',
        uscr: '\uD835\uDCCA',
        utdot: '\u22F0',
        Utilde: '',
        utilde: '',
        utri: '\u25B5',
        utrif: '\u25B4',
        uuarr: '\u21C8',
        Uuml: '',
        uuml: '',
        uwangle: '\u29A7',
        vangrt: '\u299C',
        varepsilon: '',
        varkappa: '',
        varnothing: '\u2205',
        varphi: '',
        varpi: '',
        varpropto: '\u221D',
        vArr: '\u21D5',
        varr: '\u2195',
        varrho: '',
        varsigma: '',
        varsubsetneq: '\u228A',
        varsubsetneqq: '\u2ACB',
        varsupsetneq: '\u228B',
        varsupsetneqq: '\u2ACC',
        vartheta: '',
        vartriangleleft: '\u22B2',
        vartriangleright: '\u22B3',
        Vbar: '\u2AEB',
        vBar: '\u2AE8',
        vBarv: '\u2AE9',
        Vcy: '',
        vcy: '',
        VDash: '\u22AB',
        Vdash: '\u22A9',
        vDash: '\u22A8',
        vdash: '\u22A2',
        Vdashl: '\u2AE6',
        Vee: '\u22C1',
        vee: '\u2228',
        veebar: '\u22BB',
        veeeq: '\u225A',
        vellip: '\u22EE',
        Verbar: '\u2016',
        verbar: '|',
        Vert: '\u2016',
        vert: '|',
        VerticalBar: '\u2223',
        VerticalLine: '|',
        VerticalSeparator: '\u2758',
        VerticalTilde: '\u2240',
        VeryThinSpace: '\u200A',
        Vfr: '\uD835\uDD19',
        vfr: '\uD835\uDD33',
        vltri: '\u22B2',
        vnsub: '\u2282',
        vnsup: '\u2283',
        Vopf: '\uD835\uDD4D',
        vopf: '\uD835\uDD67',
        vprop: '\u221D',
        vrtri: '\u22B3',
        Vscr: '\uD835\uDCB1',
        vscr: '\uD835\uDCCB',
        vsubnE: '\u2ACB',
        vsubne: '\u228A',
        vsupnE: '\u2ACC',
        vsupne: '\u228B',
        Vvdash: '\u22AA',
        vzigzag: '\u299A',
        Wcirc: '',
        wcirc: '',
        wedbar: '\u2A5F',
        Wedge: '\u22C0',
        wedge: '\u2227',
        wedgeq: '\u2259',
        weierp: '\u2118',
        Wfr: '\uD835\uDD1A',
        wfr: '\uD835\uDD34',
        Wopf: '\uD835\uDD4E',
        wopf: '\uD835\uDD68',
        wp: '\u2118',
        wr: '\u2240',
        wreath: '\u2240',
        Wscr: '\uD835\uDCB2',
        wscr: '\uD835\uDCCC',
        xcap: '\u22C2',
        xcirc: '\u25EF',
        xcup: '\u22C3',
        xdtri: '\u25BD',
        Xfr: '\uD835\uDD1B',
        xfr: '\uD835\uDD35',
        xhArr: '\u27FA',
        xharr: '\u27F7',
        Xi: '',
        xi: '',
        xlArr: '\u27F8',
        xlarr: '\u27F5',
        xmap: '\u27FC',
        xnis: '\u22FB',
        xodot: '\u2A00',
        Xopf: '\uD835\uDD4F',
        xopf: '\uD835\uDD69',
        xoplus: '\u2A01',
        xotime: '\u2A02',
        xrArr: '\u27F9',
        xrarr: '\u27F6',
        Xscr: '\uD835\uDCB3',
        xscr: '\uD835\uDCCD',
        xsqcup: '\u2A06',
        xuplus: '\u2A04',
        xutri: '\u25B3',
        xvee: '\u22C1',
        xwedge: '\u22C0',
        Yacute: '',
        yacute: '',
        YAcy: '',
        yacy: '',
        Ycirc: '',
        ycirc: '',
        Ycy: '',
        ycy: '',
        yen: '\xA5',
        Yfr: '\uD835\uDD1C',
        yfr: '\uD835\uDD36',
        YIcy: '',
        yicy: '',
        Yopf: '\uD835\uDD50',
        yopf: '\uD835\uDD6A',
        Yscr: '\uD835\uDCB4',
        yscr: '\uD835\uDCCE',
        YUcy: '',
        yucy: '',
        Yuml: '',
        yuml: '',
        Zacute: '',
        zacute: '',
        Zcaron: '',
        zcaron: '',
        Zcy: '',
        zcy: '',
        Zdot: '',
        zdot: '',
        zeetrf: '',
        ZeroWidthSpace: '\u200B',
        Zeta: '',
        zeta: '',
        Zfr: '',
        zfr: '\uD835\uDD37',
        ZHcy: '',
        zhcy: '',
        zigrarr: '\u21DD',
        Zopf: '',
        zopf: '\uD835\uDD6B',
        Zscr: '\uD835\uDCB5',
        zscr: '\uD835\uDCCF',
        zwj: '',
        zwnj: ''
    };
});
/*simple-html-tokenizer@0.2.6#lib/simple-html-tokenizer/tokenize*/
define('simple-html-tokenizer@0.2.6#lib/simple-html-tokenizer/tokenize', [
    'exports',
    './tokenizer',
    './entity-parser',
    './html5-named-char-refs'
], function (exports, _tokenizer, _entityParser, _html5NamedCharRefs) {
    'use strict';
    Object.defineProperty(exports, '__esModule', { value: true });
    exports.default = tokenize;
    var _tokenizer2 = _interopRequireDefault(_tokenizer);
    var _entityParser2 = _interopRequireDefault(_entityParser);
    var _html5NamedCharRefs2 = _interopRequireDefault(_html5NamedCharRefs);
    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
    }
    function tokenize(input, options) {
        var tokenizer = new _tokenizer2.default(new _entityParser2.default(_html5NamedCharRefs2.default), options);
        return tokenizer.tokenize(input);
    }
});
/*can-simple-dom@1.3.4#simple-dom/default-tokenize*/
define('can-simple-dom@1.3.4#simple-dom/default-tokenize', [
    'exports',
    'simple-html-tokenizer/lib/simple-html-tokenizer/tokenize'
], function (exports, _tokenize) {
    'use strict';
    Object.defineProperty(exports, '__esModule', { value: true });
    exports.default = function (input) {
        return (0, _tokenize2.default)(input);
    };
    var _tokenize2 = _interopRequireDefault(_tokenize);
    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
    }
    ;
});
/*can-simple-dom@1.3.4#test/element-sp-test*/
define('can-simple-dom@1.3.4#test/element-sp-test', [
    'can-simple-dom',
    'steal-qunit',
    'can-simple-dom/simple-dom/html-parser',
    'can-simple-dom/simple-dom/void-map',
    'can-simple-dom/simple-dom/html-serializer',
    'can-simple-dom/simple-dom/default-tokenize'
], function (_canSimpleDom, _stealQunit, _htmlParser, _voidMap, _htmlSerializer, _defaultTokenize) {
    'use strict';
    var _stealQunit2 = _interopRequireDefault(_stealQunit);
    var _htmlParser2 = _interopRequireDefault(_htmlParser);
    var _voidMap2 = _interopRequireDefault(_voidMap);
    var _htmlSerializer2 = _interopRequireDefault(_htmlSerializer);
    var _defaultTokenize2 = _interopRequireDefault(_defaultTokenize);
    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
    }
    _stealQunit2.default.module('can-simple-dom - Element with serialization and parsing');
    _stealQunit2.default.test('document.implementation is supported (#23)', function () {
        var document = new _canSimpleDom.Document();
        document.__addSerializerAndParser(new _htmlSerializer2.default(_voidMap2.default), new _htmlParser2.default(_defaultTokenize2.default, document, _voidMap2.default));
        ok(document.implementation, 'implementation exists');
        var doc2 = document.implementation.createHTMLDocument('');
        ok(doc2.body, 'has a body');
    });
    _stealQunit2.default.test('innerHTML supported', function () {
        var document = new _canSimpleDom.Document();
        document.__addSerializerAndParser(new _htmlSerializer2.default(_voidMap2.default), new _htmlParser2.default(_defaultTokenize2.default, document, _voidMap2.default));
        document.body.innerHTML = '<span class=\'bar\'>HI</span>';
        _stealQunit2.default.equal(document.body.firstChild.nodeName, 'SPAN');
        _stealQunit2.default.equal(document.body.firstChild.className, 'bar');
        _stealQunit2.default.equal(document.body.firstChild.firstChild.nodeValue, 'HI');
        _stealQunit2.default.equal(document.body.innerHTML, '<span class="bar">HI</span>');
    });
    _stealQunit2.default.test('outerHTML supported', function () {
        var document = new _canSimpleDom.Document();
        document.__addSerializerAndParser(new _htmlSerializer2.default(_voidMap2.default), new _htmlParser2.default(_defaultTokenize2.default, document, _voidMap2.default));
        document.body.innerHTML = '<span/><div id=\'item\'>HI</div><span/>';
        var item = document.getElementById('item');
        _stealQunit2.default.equal(item.outerHTML, '<div id="item">HI</div>', 'getter');
        item.outerHTML = '<label>IT</label>';
        _stealQunit2.default.equal(document.body.innerHTML, '<span></span><label>IT</label><span></span>', 'setter');
    });
});
/*can-simple-dom@1.3.4#test/element-event-test*/
define('can-simple-dom@1.3.4#test/element-event-test', [
    'can-simple-dom/simple-dom/document',
    'can-simple-dom/simple-dom/html-serializer',
    'can-simple-dom/simple-dom/void-map',
    './support',
    'steal-qunit'
], function (_document, _htmlSerializer, _voidMap, _support, _stealQunit) {
    'use strict';
    var _document2 = _interopRequireDefault(_document);
    var _htmlSerializer2 = _interopRequireDefault(_htmlSerializer);
    var _voidMap2 = _interopRequireDefault(_voidMap);
    var _stealQunit2 = _interopRequireDefault(_stealQunit);
    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
    }
    _stealQunit2.default.module('can-simple-dom - Event');
    _stealQunit2.default.test('basic bubbling', 4, function (assert) {
        var document = new _document2.default();
        var elem = document.createElement('div');
        document.body.appendChild(elem);
        document.addEventListener('foo', function (event) {
            assert.strictEqual(event.currentTarget, document, 'document current target');
        });
        document.documentElement.addEventListener('foo', function (event) {
            assert.strictEqual(event.currentTarget, document.documentElement, 'documentElement current target');
        });
        document.body.addEventListener('foo', function (event) {
            assert.strictEqual(event.currentTarget, document.body, 'body current target');
        });
        elem.addEventListener('foo', function (event) {
            assert.strictEqual(event.currentTarget, elem, 'elem current target');
        });
        document.body.appendChild(elem);
        var ev = document.createEvent('HTMLEvents');
        ev.initEvent('foo', true, false);
        elem.dispatchEvent(ev);
    });
    _stealQunit2.default.test('stop propagation', 2, function (assert) {
        var document = new _document2.default();
        var elem = document.createElement('div');
        document.body.appendChild(elem);
        document.addEventListener('foo', function (event) {
            assert.strictEqual(event.currentTarget, document, 'document current target');
        });
        document.documentElement.addEventListener('foo', function (event) {
            assert.strictEqual(event.currentTarget, document.documentElement, 'documentElement current target');
        });
        document.body.addEventListener('foo', function (event) {
            assert.strictEqual(event.currentTarget, document.body, 'body current target');
            event.stopPropagation();
        });
        elem.addEventListener('foo', function (event) {
            assert.strictEqual(event.currentTarget, elem, 'elem current target');
        });
        document.body.appendChild(elem);
        var ev = document.createEvent('HTMLEvents');
        ev.initEvent('foo', true, false);
        elem.dispatchEvent(ev);
    });
    _stealQunit2.default.test('initEvent without bubbling', 2, function (assert) {
        var document = new _document2.default();
        var elem = document.createElement('div');
        document.body.appendChild(elem);
        document.body.addEventListener('foo', function (event) {
            assert.strictEqual(event.currentTarget, document.body, 'body current target');
            event.stopPropagation();
        });
        elem.addEventListener('foo', function (event) {
            assert.strictEqual(event.currentTarget, elem, 'elem current target');
        });
        elem.addEventListener('foo', function (event) {
            assert.strictEqual(event.currentTarget, elem, 'elem current target');
        });
        document.body.appendChild(elem);
        var ev = document.createEvent('HTMLEvents');
        ev.initEvent('foo', false, false);
        elem.dispatchEvent(ev);
    });
    _stealQunit2.default.test('this inside event handler', function (assert) {
        var document = new _document2.default();
        var elem = document.createElement('div');
        document.body.appendChild(elem);
        elem.addEventListener('foo', function () {
            assert.equal(this, elem, 'this is the element');
        });
        var ev = document.createEvent('HTMLEvents');
        ev.initEvent('foo', true, false);
        elem.dispatchEvent(ev);
    });
    _stealQunit2.default.test('deduplicate event handlers', function (assert) {
        var done = assert.async();
        var document = new _document2.default();
        var elem = document.createElement('div');
        document.body.appendChild(elem);
        var handler = function handler() {
            assert.ok(true, 'event dispatched');
            done();
        };
        elem.addEventListener('foo', handler);
        elem.addEventListener('foo', handler);
        var ev = document.createEvent('HTMLEvents');
        ev.initEvent('foo', true, false);
        elem.dispatchEvent(ev);
    });
});
/*can-simple-dom@1.3.4#test/parser-test*/
define('can-simple-dom@1.3.4#test/parser-test', [
    './support',
    'can-simple-dom/simple-dom/html-parser',
    'can-simple-dom/simple-dom/void-map',
    'can-simple-dom/simple-dom/default-tokenize',
    'steal-qunit'
], function (_support, _htmlParser, _voidMap, _defaultTokenize, _stealQunit) {
    'use strict';
    var _htmlParser2 = _interopRequireDefault(_htmlParser);
    var _voidMap2 = _interopRequireDefault(_voidMap);
    var _defaultTokenize2 = _interopRequireDefault(_defaultTokenize);
    var _stealQunit2 = _interopRequireDefault(_stealQunit);
    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
    }
    _stealQunit2.default.module('can-simple-dom - Basic HTML parsing', {
        beforeEach: function beforeEach() {
            this.parser = new _htmlParser2.default(_defaultTokenize2.default, _support.document, _voidMap2.default);
        }
    });
    _stealQunit2.default.test('simple parse', function (assert) {
        var fragment = this.parser.parse('<div>Hello</div>');
        assert.ok(fragment);
        var node = fragment.firstChild;
        assert.ok(node);
        assert.equal(node.nodeType, 1);
        assert.equal(node.nodeName.toLowerCase(), 'div');
        assert.ok(node.firstChild);
        assert.equal(node.firstChild.nodeType, 3);
        assert.equal(node.firstChild.nodeValue, 'Hello');
    });
    _stealQunit2.default.test('nested parse', function (assert) {
        var fragment = this.parser.parse('text before<div>Hello</div>text between<div id=foo title="Hello World">World</div>text after');
        assert.ok(fragment);
        var node = fragment.firstChild;
        assert.ok(node);
        assert.equal(node.nodeType, 3);
        assert.equal(node.nodeValue, 'text before');
        node = node.nextSibling;
        assert.ok(node);
        assert.equal(node.nodeType, 1);
        assert.equal(node.nodeName, 'DIV');
        assert.ok(node.firstChild);
        assert.equal(node.firstChild.nodeType, 3);
        assert.equal(node.firstChild.nodeValue, 'Hello');
        node = node.nextSibling;
        assert.ok(node);
        assert.equal(node.nodeType, 3);
        assert.equal(node.nodeValue, 'text between');
        node = node.nextSibling;
        assert.ok(node);
        assert.equal(node.nodeType, 1);
        assert.equal(node.nodeName, 'DIV');
        var expectedValues = {
            id: 'foo',
            title: 'Hello World'
        };
        assert.equal(node.attributes.length, 2);
        assert.equal(node.attributes[0].value, expectedValues[node.attributes[0].name]);
        assert.equal(node.attributes[1].value, expectedValues[node.attributes[1].name]);
        assert.equal(node.attributes.length, 2);
        assert.ok(node.firstChild);
        assert.equal(node.firstChild.nodeType, 3);
        assert.equal(node.firstChild.nodeValue, 'World');
        node = node.nextSibling;
        assert.ok(node);
        assert.equal(node.nodeType, 3);
        assert.equal(node.nodeValue, 'text after');
    });
    _stealQunit2.default.test('void tags', function (assert) {
        var fragment = this.parser.parse('<div>Hello<br>World<img src="http://example.com/image.png?foo=bar&bar=foo"></div>');
        assert.ok(fragment);
        var node = fragment.firstChild;
        assert.ok(node);
        assert.equal(node.nodeType, 1);
        assert.equal(node.nodeName, 'DIV');
        node = node.firstChild;
        assert.ok(node);
        assert.equal(node.nodeType, 3);
        assert.equal(node.nodeValue, 'Hello');
        node = node.nextSibling;
        assert.ok(node);
        assert.equal(node.nodeType, 1);
        assert.equal(node.nodeName, 'BR');
        node = node.nextSibling;
        assert.ok(node);
        assert.equal(node.nodeType, 3);
        assert.equal(node.nodeValue, 'World');
        node = node.nextSibling;
        assert.ok(node);
        assert.equal(node.nodeType, 1);
        assert.equal(node.nodeName, 'IMG');
        assert.equal(node.getAttribute('src'), 'http://example.com/image.png?foo=bar&bar=foo');
        assert.equal(node.nextSibling, null);
    });
    _stealQunit2.default.test('node attribute charater encode', function (assert) {
        var fragment = this.parser.parse('<div title="&nbsp;foo & bar &amp; baz < buz > biz"></div>');
        assert.ok(fragment);
        var node = fragment.firstChild;
        assert.ok(node);
        assert.equal(node.nodeType, 1);
        assert.equal(node.nodeName, 'DIV');
        var attibutes = node.attributes;
        assert.ok(attibutes.length);
        var title = attibutes[0];
        assert.equal(title.name, 'title');
        assert.equal(title.value, '&#xA0;foo &#x26; bar &#x26; baz &#x3C; buz &#x3E; biz');
    });
});
/*can-simple-dom@1.3.4#test/style-test*/
define('can-simple-dom@1.3.4#test/style-test', [
    'steal-qunit',
    'can-simple-dom/simple-dom/document/style'
], function (_stealQunit, _style) {
    'use strict';
    var _stealQunit2 = _interopRequireDefault(_stealQunit);
    var _style2 = _interopRequireDefault(_style);
    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
    }
    var _typeof = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? function (obj) {
        return typeof obj;
    } : function (obj) {
        return obj && typeof Symbol === 'function' && obj.constructor === Symbol && obj !== Symbol.prototype ? 'symbol' : typeof obj;
    };
    _stealQunit2.default.module('can-simple-dom - CSStyleDeclaration');
    _stealQunit2.default.test('cssText is enumerable', function () {
        var proto = _style2.default.prototype;
        var descriptor = Object.getOwnPropertyDescriptor(proto, 'cssText');
        _stealQunit2.default.equal(descriptor.enumerable, true, 'it is enumerable');
    });
    _stealQunit2.default.test('cssText is configurable', function () {
        var proto = _style2.default.prototype;
        var descriptor = Object.getOwnPropertyDescriptor(proto, 'cssText');
        _stealQunit2.default.equal(descriptor.configurable, true, 'it is configurable');
    });
    _stealQunit2.default.test('getPropertyValue must be a function', function () {
        var proto = _style2.default.prototype;
        _stealQunit2.default.equal(_typeof(proto.getPropertyValue), 'function', 'it is a function');
    });
});
/*can-simple-dom@1.3.4#test/test*/
define('can-simple-dom@1.3.4#test/test', [
    './document-test',
    './element-test',
    './serializer-test',
    './element-sp-test',
    './element-event-test',
    './parser-test',
    './style-test'
], function () {
    'use strict';
});
/*can-simple-observable@2.0.1#can-simple-observable-test*/
define('can-simple-observable@2.0.1#can-simple-observable-test', [
    'require',
    'exports',
    'module',
    '@steal',
    'steal-qunit',
    'can-symbol',
    'can-simple-observable',
    'can-reflect',
    'can-observation-recorder'
], function (require, exports, module) {
    var steal = require('@steal');
    var QUnit = require('steal-qunit');
    var canSymbol = require('can-symbol');
    var SimpleObservable = require('can-simple-observable');
    var canReflect = require('can-reflect');
    var ObservationRecorder = require('can-observation-recorder');
    var getChangesSymbol = canSymbol.for('can.getChangesDependencyRecord');
    var skipProduction = steal.isEnv('production') ? QUnit.skip : QUnit.test;
    QUnit.module('can-simple-observable');
    QUnit.test('basics', function () {
        expect(5);
        var obs = new SimpleObservable('one');
        QUnit.equal(canReflect.getValue(obs), 'one', 'getValue');
        canReflect.setValue(obs, 'two');
        ObservationRecorder.start();
        QUnit.equal(canReflect.getValue(obs), 'two', 'setValue');
        var dependencies = ObservationRecorder.stop();
        QUnit.ok(dependencies.valueDependencies.has(obs), 'was recorded');
        var handler = function (newValue) {
            QUnit.equal(newValue, 'three', 'onValue');
        };
        canReflect.onValue(obs, handler);
        canReflect.setValue(obs, 'three');
        canReflect.offValue(obs, handler);
        canReflect.setValue(obs, 'four');
        QUnit.equal(canReflect.getValue(obs), 'four', 'getValue after offValue');
    });
    skipProduction('log observable changes', function (assert) {
        var done = assert.async();
        var obs = new SimpleObservable('one');
        obs.log();
        assert.expect(2);
        obs._log = function (previous, current) {
            assert.equal(current, 'two', 'should get current value');
            assert.equal(previous, 'one', 'should get previous value');
            done();
        };
        canReflect.setValue(obs, 'two');
    });
    skipProduction('getWhatIChange works', function (assert) {
        var one = new SimpleObservable('one');
        var two = new SimpleObservable('two');
        var handler = function handler() {
            two.set('three');
        };
        var dependencyRecord = { valueDependencies: new Set([two]) };
        handler[getChangesSymbol] = function () {
            return dependencyRecord;
        };
        canReflect.onValue(one, handler);
        assert.deepEqual(canReflect.getWhatIChange(one).mutate, dependencyRecord);
    });
});
/*can-stache-key@1.0.0#can-stache-key-test*/
define('can-stache-key@1.0.0#can-stache-key-test', [
    'require',
    'exports',
    'module',
    'can-stache-key',
    'steal-qunit',
    'can-observation',
    'can-event-queue/map/map',
    'can-simple-observable',
    'can-test-helpers',
    'can-observation-recorder',
    'can-simple-map',
    'can-reflect'
], function (require, exports, module) {
    var observeReader = require('can-stache-key');
    var QUnit = require('steal-qunit');
    var Observation = require('can-observation');
    var eventQueue = require('can-event-queue/map/map');
    var SimpleObservable = require('can-simple-observable');
    var testHelpers = require('can-test-helpers');
    var ObservationRecorder = require('can-observation-recorder');
    var SimpleMap = require('can-simple-map');
    var canReflect = require('can-reflect');
    QUnit.module('can-stache-key', {});
    test('can read a promise (#179)', function () {
        var data = {
            promise: new Promise(function (resolve) {
                setTimeout(function () {
                    resolve('Something');
                }, 2);
            })
        };
        var calls = 0;
        var c = new Observation(function () {
            return observeReader.read(data, observeReader.reads('promise.value')).value;
        });
        canReflect.onValue(c, function (newVal, oldVal) {
            calls++;
            equal(calls, 1, 'only one call');
            equal(newVal, 'Something', 'new value');
            equal(oldVal, undefined, 'oldVal');
            start();
        });
        stop();
    });
    test('can.Compute.read can read a promise-like (#82)', function () {
        var data = {
            promiseLike: {
                then: function (resolve) {
                    setTimeout(function () {
                        resolve('Something');
                    }, 2);
                }
            }
        };
        var calls = 0;
        var c = new Observation(function () {
            return observeReader.read(data, observeReader.reads('promiseLike.value')).value;
        });
        canReflect.onValue(c, function (newVal, oldVal) {
            calls++;
            equal(calls, 1, 'only one call');
            equal(newVal, 'Something', 'new value');
            equal(oldVal, undefined, 'oldVal');
            start();
        });
        stop();
    });
    test('can.compute.reads', function () {
        deepEqual(observeReader.reads('@foo'), [{
                key: 'foo',
                at: true
            }]);
        deepEqual(observeReader.reads('@foo.bar'), [
            {
                key: 'foo',
                at: true
            },
            {
                key: 'bar',
                at: false
            }
        ]);
        deepEqual(observeReader.reads('@foo\\.bar'), [{
                key: 'foo.bar',
                at: true
            }]);
        deepEqual(observeReader.reads('foo.bar@zed'), [
            {
                key: 'foo',
                at: false
            },
            {
                key: 'bar',
                at: false
            },
            {
                key: 'zed',
                at: true
            }
        ]);
    });
    test('able to read things like can-define', 3, function () {
        var obj = eventQueue({});
        var prop = 'PROP';
        Object.defineProperty(obj, 'prop', {
            get: function () {
                ObservationRecorder.add(obj, 'prop');
                return prop;
            },
            set: function (val) {
                var old = prop;
                prop = val;
                this.dispatch('prop', prop, old);
            }
        });
        var data = { obj: obj };
        var c = new Observation(function () {
            var value = observeReader.read(data, observeReader.reads('obj.prop'), {
                foundObservable: function (obs, index) {
                    equal(obs, obj, 'got an observable');
                    equal(index, 1, 'got the right index');
                }
            }).value;
            equal(value, 'PROP');
        });
        canReflect.onValue(c, function () {
        });
    });
    test('foundObservable called with observable object (#7)', function () {
        var map = new SimpleMap({
            isSaving: function () {
                ObservationRecorder.add(this, '_saving');
            },
            addEventListener: function () {
            }
        });
        var c = new Observation(function () {
            observeReader.read(map, observeReader.reads('isSaving'), {
                foundObservable: function (obs) {
                    QUnit.equal(obs, map);
                },
                callMethodsOnObservables: true
            });
        });
        canReflect.onValue(c, function () {
        });
    });
    test('can read from strings', function () {
        var context = ' hi there ';
        var result = observeReader.read(context, observeReader.reads('trim'), {});
        QUnit.equal(result.value(context), context.trim(context), 'trim method works');
    });
    test('read / write to DefineMap', function () {
        var map = new SimpleMap();
        var c = new Observation(function () {
            var data = observeReader.read(map, observeReader.reads('value'), {
                foundObservable: function (obs) {
                    QUnit.equal(obs, map, 'got map');
                }
            });
            return data.value;
        });
        canReflect.onValue(c, function (newVal) {
            QUnit.equal(newVal, 1, 'got updated');
        });
        observeReader.write(map, 'value', 1);
    });
    test('write deep in DefineMap', function () {
        var map = new SimpleMap();
        observeReader.write(map, 'foo', new SimpleMap());
        observeReader.write(map, 'foo.bar', 1);
        QUnit.equal(map.get('foo').get('bar'), 1, 'value set');
    });
    test('write to compute in object', function () {
        var value = 2;
        var computeObject = {};
        canReflect.assignSymbols(computeObject, {
            'can.getValue': function () {
                return value;
            },
            'can.setValue': function (newVal) {
                value = newVal;
            }
        });
        var obj = { compute: computeObject };
        observeReader.write(obj, 'compute', 3);
        QUnit.equal(value, 3, 'value set');
    });
    test('write to a map in a compute', function () {
        var map = new SimpleMap({ complete: true });
        var computeObject = {};
        canReflect.assignSymbols(computeObject, {
            'can.getValue': function () {
                return map;
            },
            'can.setValue': function (newVal) {
                map = newVal;
            }
        });
        observeReader.write(computeObject, 'complete', false);
        QUnit.equal(map.attr('complete'), false, 'value set');
    });
    QUnit.test('reads can be passed a number (can-stache#207)', function () {
        var reads = observeReader.reads(0);
        QUnit.deepEqual(reads, [{
                key: '0',
                at: false
            }], 'number converted to string');
    });
    QUnit.test('can read primitive numbers (#88)', function () {
        var reads = observeReader.reads('num@toFixed');
        var toFixed = observeReader.read({ num: 5 }, reads, {}).value;
        QUnit.equal(typeof toFixed, 'function', 'got to fixed');
    });
    test('it returns null when promise getter is null #2', function () {
        var nullPromise = observeReader.read(null, observeReader.reads('value'));
        QUnit.equal(typeof nullPromise, 'object');
    });
    QUnit.test('set onto observable objects and values', function () {
        var map = new SimpleMap();
        observeReader.write({ map: map }, 'map', { a: 'b' });
        QUnit.equal(map.get('a'), 'b', 'merged');
        var simple = new SimpleObservable();
        observeReader.write({ simple: simple }, 'simple', 1);
        QUnit.equal(simple.get(), 1);
    });
    testHelpers.dev.devOnlyTest('functions are not called by read()', function () {
        var func = function () {
            QUnit.ok(false, 'method called');
        };
        var data = { func: func };
        var reads = observeReader.reads('func');
        observeReader.read(data, reads);
        QUnit.ok(true);
    });
    testHelpers.dev.devOnlyTest('a warning is given for `callMethodsOnObservables: true`', function () {
        var teardown = testHelpers.dev.willWarn('can-stache-key: read() called with `callMethodsOnObservables: true`.');
        var func = function () {
            QUnit.ok(true, 'method called');
        };
        var data = new SimpleMap({ func: func });
        var reads = observeReader.reads('func');
        observeReader.read(data, reads, { callMethodsOnObservables: true });
        QUnit.equal(teardown(), 1, 'warning displayed');
    });
});
/*can-symbol@1.6.0#can-symbol-test*/
define('can-symbol@1.6.0#can-symbol-test', [
    'require',
    'exports',
    'module',
    'steal-qunit',
    'can-symbol'
], function (require, exports, module) {
    var QUnit = require('steal-qunit');
    var canSymbol = require('can-symbol');
    QUnit.module('can-symbol');
    QUnit.test('for and keyFor', function () {
        var symbol = canSymbol.for('abc');
        QUnit.ok(canSymbol.for('abc') === canSymbol.for('abc'));
        QUnit.equal(canSymbol.keyFor(symbol), 'abc', 'key for');
    });
    QUnit.test('can get/set symbols', function () {
        var obj = {};
        var symbol1 = canSymbol('prop1'), symbol2 = canSymbol('prop2');
        obj[symbol1] = 'VALUE';
        QUnit.equal(obj[symbol1], 'VALUE', 'got value');
        Object.defineProperty(obj, symbol2, { value: 'DP-VALUE' });
        QUnit.equal(obj[symbol2], 'DP-VALUE', 'got define property value');
    });
});
/*can-util@3.11.2#js/set-not-enumerable/set-not-enumerable*/
define('can-util@3.11.2#js/set-not-enumerable/set-not-enumerable', function (require, exports, module) {
    'use strict';
    module.exports = function (obj, prop, value) {
        Object.defineProperty(obj, prop, {
            configurable: true,
            enumerable: false,
            writable: true,
            value: value
        });
    };
});
/*can-util@3.11.2#js/assign-non-enumerable/assign-non-enumerable*/
define('can-util@3.11.2#js/assign-non-enumerable/assign-non-enumerable', [
    'require',
    'exports',
    'module',
    '../set-not-enumerable/set-not-enumerable'
], function (require, exports, module) {
    var setNotEnumerable = require('../set-not-enumerable/set-not-enumerable');
    module.exports = function (d, s) {
        for (var prop in s) {
            setNotEnumerable(d, prop, s[prop]);
        }
        return d;
    };
});
/*can-util@3.11.2#test/qunit*/
define('can-util@3.11.2#test/qunit', [
    'require',
    'exports',
    'module',
    'qunitjs',
    'steal-qunit'
], function (require, exports, module) {
    var testType = typeof process !== 'undefined' && process.env.TEST;
    var isQunit = testType === 'qunit';
    if (isQunit) {
        module.exports = require('qunitjs');
    } else {
        module.exports = require('steal-qunit');
    }
});
/*can-util@3.11.2#js/assign-non-enumerable/assign-non-enumerable-test*/
define('can-util@3.11.2#js/assign-non-enumerable/assign-non-enumerable-test', [
    'require',
    'exports',
    'module',
    './assign-non-enumerable',
    '../../test/qunit'
], function (require, exports, module) {
    var assignNonEnumerable = require('./assign-non-enumerable');
    var QUnit = require('../../test/qunit');
    QUnit.module('can-util/js/assign-non-enumerable');
    QUnit.test('Assign all properties to an object', function (assert) {
        var a = { a: 1 };
        var b = {
            b: 3,
            c: 2
        };
        var actual = assignNonEnumerable(a, b);
        assert.equal(a, actual);
        for (var prop in a) {
            if (prop !== 'a') {
                assert.ok(false, 'we got a prop of ' + prop);
            }
        }
        assert.equal(actual.b, 3);
        assert.equal(actual.c, 2);
        actual.b = 'B';
        assert.equal(actual.b, 'B');
    });
});
/*can-util@3.11.2#js/base-url/base-url-test*/
define('can-util@3.11.2#js/base-url/base-url-test', [
    'require',
    'exports',
    'module',
    '../../test/qunit',
    './base-url',
    'can-globals/global/global',
    'can-globals/document/document'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        'use strict';
        var QUnit = require('../../test/qunit');
        var getBaseUrl = require('./base-url');
        var getGlobal = require('can-globals/global/global');
        var getDomDocument = require('can-globals/document/document');
        QUnit.module('can-util/js/base-url');
        QUnit.test('basics', function (assert) {
            var global = getGlobal(), domDocument = getDomDocument();
            if (domDocument && 'baseURI' in domDocument) {
                assert.ok(getBaseUrl() === global.document.baseURI, getBaseUrl());
            } else if (global.location) {
                assert.ok(getBaseUrl() === global.location.href.substr(0, global.location.href.lastIndexOf('/')), getBaseUrl());
            } else if (typeof process !== 'undefined') {
                assert.ok(getBaseUrl() === process.cwd(), getBaseUrl());
            }
        });
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-util@3.11.2#js/deep-assign/deep-assign-test*/
define('can-util@3.11.2#js/deep-assign/deep-assign-test', [
    'require',
    'exports',
    'module',
    '../../test/qunit',
    './deep-assign'
], function (require, exports, module) {
    'use strict';
    var QUnit = require('../../test/qunit');
    var deepAssign = require('./deep-assign');
    QUnit.module('can-util/js/deep-assign');
    QUnit.test('basics', function (assert) {
        var original = { nested: { foo: 'bar' } };
        var res = deepAssign(true, {}, original);
        assert.deepEqual(res, { nested: { foo: 'bar' } }, 'they look the same');
        assert.ok(res.nested !== original.nested, 'different objects');
    });
});
/*can-util@3.11.2#js/defaults/defaults-test*/
define('can-util@3.11.2#js/defaults/defaults-test', [
    'require',
    'exports',
    'module',
    './defaults',
    '../../test/qunit'
], function (require, exports, module) {
    'use strict';
    var defaults = require('./defaults');
    var QUnit = require('../../test/qunit');
    QUnit.module('can-util/js/defaults');
    QUnit.test('Assigns props from sources to object if they are undefined in object', function (assert) {
        var a = {
            a: 1,
            b: 2,
            c: 3
        };
        var b = {
            a: 2,
            b: 3,
            d: 4
        };
        var c = {
            d: 5,
            e: 5
        };
        var expected = {
            a: 1,
            b: 2,
            c: 3,
            d: 4,
            e: 5
        };
        var actual = defaults(a, b, c);
        for (var prop in actual) {
            assert.equal(expected[prop], actual[prop]);
        }
    });
});
/*can-util@3.11.2#js/diff/diff-test*/
define('can-util@3.11.2#js/diff/diff-test', [
    'require',
    'exports',
    'module',
    '../../test/qunit',
    './diff'
], function (require, exports, module) {
    'use strict';
    var QUnit = require('../../test/qunit');
    var diff = require('./diff');
    QUnit.module('can-util/js/diff');
    QUnit.test('basics', function (assert) {
        var patches = diff([], [
            1,
            2,
            3
        ]);
        assert.deepEqual(patches, [{
                index: 0,
                deleteCount: 0,
                insert: [
                    1,
                    2,
                    3
                ]
            }], 'insert many at end');
        patches = diff([
            1,
            2,
            3
        ], [
            1,
            2,
            3
        ]);
        assert.deepEqual(patches, [], 'no changes');
        patches = diff([
            1,
            2,
            3
        ], [
            1,
            2,
            3,
            4
        ]);
        assert.deepEqual(patches, [{
                index: 3,
                deleteCount: 0,
                insert: [4]
            }], 'add one at the end');
        patches = diff([
            1,
            2,
            3,
            4
        ], [
            1,
            2,
            4
        ]);
        assert.deepEqual(patches, [{
                index: 2,
                deleteCount: 1,
                insert: []
            }], 'remove one in the middle');
        patches = diff([
            'a',
            'b',
            'z',
            'f',
            'x'
        ], [
            'a',
            'b',
            'f',
            'w',
            'z'
        ]);
        assert.deepEqual(patches, [
            {
                index: 2,
                insert: [],
                deleteCount: 1
            },
            {
                index: 3,
                deleteCount: 1,
                insert: [
                    'w',
                    'z'
                ]
            }
        ]);
        patches = diff([
            'a',
            'b',
            'b'
        ], [
            'c',
            'a',
            'b'
        ]);
        assert.deepEqual(patches, [
            {
                index: 0,
                insert: ['c'],
                deleteCount: 0
            },
            {
                index: 3,
                deleteCount: 1,
                insert: []
            }
        ]);
        patches = diff([
            'a',
            'b',
            'c',
            'd',
            'e',
            'f',
            'g'
        ], [
            'a',
            'c',
            'e',
            'g'
        ]);
        assert.deepEqual(patches, [
            {
                index: 1,
                insert: [],
                deleteCount: 1
            },
            {
                index: 2,
                deleteCount: 1,
                insert: []
            },
            {
                index: 3,
                deleteCount: 1,
                insert: []
            }
        ]);
        patches = diff([
            { id: 1 },
            { id: 2 }
        ], [
            { id: 1 },
            { id: 1.5 },
            { id: 3 }
        ], function (a, b) {
            return a.id === b.id;
        });
        assert.deepEqual(patches, [{
                index: 1,
                deleteCount: 1,
                insert: [
                    { id: 1.5 },
                    { id: 3 }
                ]
            }], 'identity works');
        patches = diff([
            { id: 1 },
            { id: 2 }
        ], [
            { id: 1 },
            { id: 3 },
            { id: 2 }
        ], function (a, b) {
            return a.id === b.id;
        });
        assert.deepEqual(patches, [{
                index: 1,
                deleteCount: 0,
                insert: [{ id: 3 }]
            }], 'identity for a single middle insertion');
    });
});
/*can-util@3.11.2#js/diff-array/diff-array*/
define('can-util@3.11.2#js/diff-array/diff-array', [
    'require',
    'exports',
    'module',
    '../diff/diff'
], function (require, exports, module) {
    'use strict';
    var diff = require('../diff/diff');
    module.exports = exports = diff;
});
/*can-util@3.11.2#js/diff-array/diff-array-test*/
define('can-util@3.11.2#js/diff-array/diff-array-test', [
    'require',
    'exports',
    'module',
    '../../test/qunit',
    './diff-array'
], function (require, exports, module) {
    'use strict';
    var QUnit = require('../../test/qunit');
    var diffArray = require('./diff-array');
    QUnit.module('can-util/js/diff-array');
    QUnit.test('basics', function (assert) {
        var patches = diffArray([], [
            1,
            2,
            3
        ]);
        assert.deepEqual(patches, [{
                index: 0,
                deleteCount: 0,
                insert: [
                    1,
                    2,
                    3
                ]
            }], 'insert many at end');
        patches = diffArray([
            1,
            2,
            3
        ], [
            1,
            2,
            3
        ]);
        assert.deepEqual(patches, [], 'no changes');
        patches = diffArray([
            1,
            2,
            3
        ], [
            1,
            2,
            3,
            4
        ]);
        assert.deepEqual(patches, [{
                index: 3,
                deleteCount: 0,
                insert: [4]
            }], 'add one at the end');
        patches = diffArray([
            1,
            2,
            3,
            4
        ], [
            1,
            2,
            4
        ]);
        assert.deepEqual(patches, [{
                index: 2,
                deleteCount: 1,
                insert: []
            }], 'remove one in the middle');
        patches = diffArray([
            'a',
            'b',
            'z',
            'f',
            'x'
        ], [
            'a',
            'b',
            'f',
            'w',
            'z'
        ]);
        assert.deepEqual(patches, [
            {
                index: 2,
                deleteCount: 1,
                insert: []
            },
            {
                index: 3,
                deleteCount: 1,
                insert: [
                    'w',
                    'z'
                ]
            }
        ], 'can delete one');
        patches = diffArray([
            'a',
            'b',
            'b'
        ], [
            'c',
            'a',
            'b'
        ]);
        assert.deepEqual(patches, [
            {
                index: 0,
                insert: ['c'],
                deleteCount: 0
            },
            {
                index: 3,
                deleteCount: 1,
                insert: []
            }
        ]);
        patches = diffArray([
            'a',
            'b',
            'c',
            'd',
            'e',
            'f',
            'g'
        ], [
            'a',
            'c',
            'e',
            'g'
        ]);
        assert.deepEqual(patches, [
            {
                index: 1,
                insert: [],
                deleteCount: 1
            },
            {
                index: 2,
                deleteCount: 1,
                insert: []
            },
            {
                index: 3,
                deleteCount: 1,
                insert: []
            }
        ]);
    });
    QUnit.test('handle swaps at the end (#193)', function (assert) {
        var patches = diffArray([
            'a',
            'b',
            'c',
            'd',
            'e'
        ], [
            'a',
            'x',
            'y',
            'z',
            'e'
        ]);
        assert.deepEqual(patches, [{
                index: 1,
                deleteCount: 3,
                insert: [
                    'x',
                    'y',
                    'z'
                ]
            }], 'handle reverse patch');
    });
    QUnit.test('handle swaps at the end after a delete (#193)', function (assert) {
        var patches = diffArray([
            'a',
            'b',
            'c',
            'd',
            'e'
        ], [
            'a',
            'x',
            'b',
            'y',
            'z',
            'e'
        ]);
        assert.deepEqual(patches, [
            {
                index: 1,
                deleteCount: 0,
                insert: ['x']
            },
            {
                index: 3,
                deleteCount: 2,
                insert: [
                    'y',
                    'z'
                ]
            }
        ], 'handle reverse patch');
    });
});
/*can-util@3.11.2#js/diff-object/diff-object*/
define('can-util@3.11.2#js/diff-object/diff-object', [
    'require',
    'exports',
    'module',
    'can-assign'
], function (require, exports, module) {
    'use strict';
    var assign = require('can-assign');
    module.exports = exports = function (oldObject, newObject) {
        var oldObjectClone, patches = [];
        oldObjectClone = assign({}, oldObject);
        for (var newProp in newObject) {
            if (!oldObject || !oldObject.hasOwnProperty(newProp)) {
                patches.push({
                    property: newProp,
                    type: 'add',
                    value: newObject[newProp]
                });
            } else if (newObject[newProp] !== oldObject[newProp]) {
                patches.push({
                    property: newProp,
                    type: 'set',
                    value: newObject[newProp]
                });
            }
            delete oldObjectClone[newProp];
        }
        for (var oldProp in oldObjectClone) {
            patches.push({
                property: oldProp,
                type: 'remove'
            });
        }
        return patches;
    };
});
/*can-util@3.11.2#js/diff-object/diff-object-test*/
define('can-util@3.11.2#js/diff-object/diff-object-test', [
    'require',
    'exports',
    'module',
    '../../test/qunit',
    './diff-object'
], function (require, exports, module) {
    'use strict';
    var QUnit = require('../../test/qunit');
    var diffObject = require('./diff-object');
    QUnit.module('can-util/js/diff');
    QUnit.test('basics', function (assert) {
        var patches = diffObject({}, { a: 'foo' });
        assert.deepEqual(patches, [{
                property: 'a',
                type: 'add',
                value: 'foo'
            }], 'add property');
        patches = diffObject(null, { a: 'foo' });
        assert.deepEqual(patches, [{
                property: 'a',
                type: 'add',
                value: 'foo'
            }], 'add property - oldObject null');
        patches = diffObject({ a: 'foo' }, { a: 'bar' });
        assert.deepEqual(patches, [{
                property: 'a',
                type: 'set',
                value: 'bar'
            }], 'change property');
        patches = diffObject({ a: 'foo' }, {});
        assert.deepEqual(patches, [{
                property: 'a',
                type: 'remove'
            }], 'remove property');
        patches = diffObject({
            a: 'foo',
            b: 'baz'
        }, {
            a: 'bar',
            c: 'quz'
        });
        assert.deepEqual(patches, [
            {
                property: 'a',
                type: 'set',
                value: 'bar'
            },
            {
                property: 'c',
                type: 'add',
                value: 'quz'
            },
            {
                property: 'b',
                type: 'remove'
            }
        ], 'add, set, and remove');
    });
    QUnit.test('mutation test', function (assert) {
        var oldObject = {
            a: 'foo',
            b: 'baz'
        };
        var newObject = {
            a: 'bar',
            c: 'quz'
        };
        diffObject(oldObject, newObject);
        assert.deepEqual(oldObject, {
            a: 'foo',
            b: 'baz'
        }, 'should not mutate old object');
        assert.deepEqual(newObject, {
            a: 'bar',
            c: 'quz'
        }, 'should not mutate new object');
    });
});
/*can-util@3.11.2#js/each/each-test*/
define('can-util@3.11.2#js/each/each-test', [
    'require',
    'exports',
    'module',
    '../../test/qunit',
    './each',
    'can-symbol'
], function (require, exports, module) {
    'use strict';
    var QUnit = require('../../test/qunit');
    var each = require('./each');
    var canSymbol = require('can-symbol');
    QUnit.module('can-util/js/each');
    QUnit.test('iOS 8 64-bit JIT object length bug', function (assert) {
        assert.expect(4);
        var i;
        for (i = 0; i < 1000; i++) {
            each([]);
        }
        i = 0;
        each({
            1: '1',
            2: '2',
            3: '3'
        }, function (index) {
            assert.equal(++i, index, 'Iterate over object');
        });
        assert.equal(i, 3, 'Last index should be the length of the array');
    });
    QUnit.test('#1989 - isArrayLike needs to check for object type', function (assert) {
        try {
            each(true, function (index) {
            });
            assert.ok(true, 'each on true worked');
        } catch (e) {
            assert.ok(false, 'Should not fail');
        }
    });
    QUnit.test('objects that implement iterators work', function (assert) {
        var Ctr = function () {
        };
        Ctr.prototype[canSymbol.iterator || canSymbol.for('iterator')] = function () {
            return {
                i: 0,
                next: function () {
                    if (this.i === 1) {
                        return {
                            value: undefined,
                            done: true
                        };
                    }
                    this.i++;
                    return {
                        value: [
                            'a',
                            'b'
                        ],
                        done: false
                    };
                }
            };
        };
        var obj = new Ctr();
        each(obj, function (value, key) {
            assert.equal(key, 'a');
            assert.equal(value, 'b');
        });
    });
});
/*can-util@3.11.2#js/get/get-test*/
define('can-util@3.11.2#js/get/get-test', [
    'require',
    'exports',
    'module',
    '../../test/qunit',
    './get'
], function (require, exports, module) {
    'use strict';
    var QUnit = require('../../test/qunit');
    var get = require('./get');
    QUnit.module('can-util/js/get');
    QUnit.test('get Single root', function (assert) {
        var root, result;
        root = { foo: 'bar' };
        result = get(root, 'foo');
        assert.equal(result, 'bar', 'got \'bar\'');
        result = get(root, 'baz');
        assert.equal(result, undefined, 'got \'undefined\'');
    });
    QUnit.test('get Deep objects', function (assert) {
        var root, result;
        root = { foo: { bar: 'baz' } };
        result = get(root, 'foo.bar');
        assert.equal(result, 'baz', 'got \'baz\'');
        result = get(root, 'foo.world');
        assert.equal(result, undefined, 'got \'undefined\'');
    });
    QUnit.test('get with numeric index', function (assert) {
        var list = [
                1,
                2,
                3
            ], result0 = get(list, 0);
        assert.equal(result0, 1, 'got the 1st element of the list');
        var result1 = get(list, 1);
        assert.equal(result1, 2, 'got the 2nd element of the list');
    });
});
/*can-util@3.11.2#js/is-node/is-node*/
define('can-util@3.11.2#js/is-node/is-node', function (require, exports, module) {
    (function (global, require, exports, module) {
        'use strict';
        module.exports = function () {
            return typeof process === 'object' && {}.toString.call(process) === '[object process]';
        };
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-util@3.11.2#js/import/import-test*/
define('can-util@3.11.2#js/import/import-test', [
    'require',
    'exports',
    'module',
    '../../test/qunit',
    './import',
    '../is-node/is-node'
], function (require, exports, module) {
    (function (global, __dirname, require, exports, module) {
        'use strict';
        var QUnit = require('../../test/qunit');
        var load = require('./import');
        var isNode = require('../is-node/is-node')();
        if (!isNode) {
            QUnit.module('can-util/js/import');
            if (__dirname !== '/') {
                QUnit.test('basic can-import works', function (assert) {
                    return load('can-util/js/import/testmodule', __dirname).then(function (data) {
                        assert.equal(data, 'Hello world');
                    }).then(null, function (err) {
                        assert.ok(false, err);
                    });
                });
            }
        } else {
            QUnit.module('can-util/js/import - Node', {
                before: function () {
                    this.oldSystem = global.System;
                    global.System = {
                        'import': function (name) {
                            name = name.replace('can-util', '');
                            return new Promise(function (resolve, reject) {
                                try {
                                    var mod = require(process.cwd() + name);
                                    resolve(mod);
                                } catch (err) {
                                    reject(err);
                                }
                            });
                        }
                    };
                },
                after: function () {
                    global.System = this.oldSystem;
                }
            });
            QUnit.test('basic can-import works', function (assert) {
                return load('can-util/js/import/testmodule', __dirname).then(function (data) {
                    assert.equal(data, 'Hello world');
                }).then(null, function (err) {
                    assert.ok(false, err);
                });
            });
        }
    }(function () {
        return this;
    }(), '/', require, exports, module));
});
/*can-util@3.11.2#js/is-array-like/is-array-like-test*/
define('can-util@3.11.2#js/is-array-like/is-array-like-test', [
    'require',
    'exports',
    'module',
    '../../test/qunit',
    './is-array-like'
], function (require, exports, module) {
    'use strict';
    var QUnit = require('../../test/qunit');
    var isArrayLike = require('./is-array-like');
    QUnit.module('can-util/js/is-array-like');
    QUnit.test('basics', function (assert) {
        assert.ok(isArrayLike({
            0: 1,
            length: 1
        }));
    });
    QUnit.test('string', function (assert) {
        assert.ok(isArrayLike('yes'));
    });
    QUnit.test('Object with a .length property', function (assert) {
        var obj = { length: 0 };
        assert.ok(isArrayLike(obj));
    });
    QUnit.test('function should be false', function (assert) {
        var func = function () {
        };
        assert.ok(!isArrayLike(func));
    });
    QUnit.test('0 should be false', function (assert) {
        assert.ok(!isArrayLike(0));
    });
});
/*can-util@3.11.2#js/is-container/is-container-test*/
define('can-util@3.11.2#js/is-container/is-container-test', [
    'require',
    'exports',
    'module',
    '../../test/qunit',
    './is-container'
], function (require, exports, module) {
    'use strict';
    var QUnit = require('../../test/qunit');
    var isContainer = require('./is-container');
    QUnit.module('can-util/js/is-container');
    QUnit.test('object', function (assert) {
        assert.ok(isContainer({ 'a': 1 }));
    });
    QUnit.test('function', function (assert) {
        var sum = function (num1, num2) {
            return num1 + num2;
        };
        assert.ok(isContainer(sum));
    });
    QUnit.test('NaN and undefined is not a container', function (assert) {
        assert.ok(!isContainer(NaN));
        assert.ok(!isContainer());
    });
});
/*can-util@3.11.2#js/is-empty-object/is-empty-object-test*/
define('can-util@3.11.2#js/is-empty-object/is-empty-object-test', [
    'require',
    'exports',
    'module',
    './is-empty-object',
    '../../test/qunit'
], function (require, exports, module) {
    'use strict';
    var isEmptyObject = require('./is-empty-object');
    var QUnit = require('../../test/qunit');
    QUnit.module('can-util/js/is-empty-object/is-empty-object');
    QUnit.test('Returns true for plain objects', function (assert) {
        assert.ok(isEmptyObject({}), '{} is true');
        assert.ok(isEmptyObject(new Object()), 'new Object is true');
    });
    QUnit.test('Plain objects with properties are false', function (assert) {
        assert.equal(isEmptyObject({ a: 1 }), false, 'not empty');
    });
    QUnit.test('Returns true for custom objects with no props', function (assert) {
        var Thing = function () {
        };
        assert.equal(isEmptyObject(new Thing()), true, 'is empty');
        var thing2 = new Thing();
        thing2.foo = 'bar';
        assert.equal(isEmptyObject(thing2), false, 'not empty');
    });
});
/*can-util@3.11.2#js/is-function/is-function-test*/
define('can-util@3.11.2#js/is-function/is-function-test', [
    'require',
    'exports',
    'module',
    '../../test/qunit',
    './is-function'
], function (require, exports, module) {
    'use strict';
    var QUnit = require('../../test/qunit');
    var isFunction = require('./is-function');
    QUnit.module('can-util/js/is-function');
    QUnit.test('basics', function (assert) {
        assert.ok(isFunction(function () {
        }));
    });
});
/*can-util@3.11.2#js/is-node/is-node-test*/
define('can-util@3.11.2#js/is-node/is-node-test', [
    'require',
    'exports',
    'module',
    '../../test/qunit',
    './is-node'
], function (require, exports, module) {
    'use strict';
    var QUnit = require('../../test/qunit');
    var isNode = require('./is-node');
    QUnit.module('can-util/js/is-node');
    QUnit.test('basics', function (assert) {
        assert.equal(typeof isNode(), 'boolean');
    });
});
/*can-util@3.11.2#js/is-plain-object/is-plain-object-test*/
define('can-util@3.11.2#js/is-plain-object/is-plain-object-test', [
    'require',
    'exports',
    'module',
    '../../test/qunit',
    './is-plain-object'
], function (require, exports, module) {
    'use strict';
    var QUnit = require('../../test/qunit');
    var isPlainObject = require('./is-plain-object');
    QUnit.module('can-util/js/is-plain-object');
    QUnit.test('basics', function (assert) {
        assert.ok(isPlainObject({ foo: 'bar' }));
    });
    QUnit.test('objects with prototypes', function (assert) {
        var Ctr = function () {
        };
        var obj = new Ctr();
        assert.equal(isPlainObject(obj), false, 'not a plain object');
    });
    QUnit.test('new Object', function (assert) {
        var obj;
        obj = new Object();
        assert.equal(isPlainObject(obj), true, 'using new Object gives you a plain object');
    });
    QUnit.test('Booleans', function (assert) {
        assert.equal(isPlainObject(true), false, 'Boolean value true is false');
        assert.equal(isPlainObject(Boolean(true)), false, 'Boolean constructor');
    });
    QUnit.test('Numbers', function (assert) {
        assert.equal(isPlainObject(15.66), false, 'number is not a plain object');
        assert.equal(isPlainObject(parseInt(13)), false, 'integer is not a plain object');
    });
    QUnit.test('NaN', function (assert) {
        assert.equal(isPlainObject(NaN), false, 'NaN is not a plain object');
    });
});
/*can-util@3.11.2#js/is-promise-like/is-promise-like-test*/
define('can-util@3.11.2#js/is-promise-like/is-promise-like-test', [
    'require',
    'exports',
    'module',
    '../../test/qunit',
    './is-promise-like'
], function (require, exports, module) {
    'use strict';
    var QUnit = require('../../test/qunit');
    var isPromise = require('./is-promise-like');
    QUnit.module('can-util/js/is-promise-like');
    QUnit.test('basics', function (assert) {
        assert.ok(isPromise({
            then: function () {
            }
        }));
    });
});
/*can-util@3.11.2#js/is-promise/is-promise*/
define('can-util@3.11.2#js/is-promise/is-promise', [
    'require',
    'exports',
    'module',
    'can-reflect'
], function (require, exports, module) {
    'use strict';
    var canReflect = require('can-reflect');
    module.exports = function (obj) {
        return canReflect.isPromise(obj);
    };
});
/*can-util@3.11.2#js/make-promise/make-promise*/
define('can-util@3.11.2#js/make-promise/make-promise', [
    'require',
    'exports',
    'module',
    '../is-promise-like/is-promise-like',
    '../is-promise/is-promise'
], function (require, exports, module) {
    'use strict';
    var isPromiseLike = require('../is-promise-like/is-promise-like');
    var isPromise = require('../is-promise/is-promise');
    module.exports = function (obj) {
        if (isPromiseLike(obj) && !isPromise(obj)) {
            return new Promise(function (resolve, reject) {
                obj.then(resolve, reject);
            });
        } else {
            return obj;
        }
    };
});
/*can-util@3.11.2#js/make-promise/make-promise-test*/
define('can-util@3.11.2#js/make-promise/make-promise-test', [
    'require',
    'exports',
    'module',
    '../../test/qunit',
    '../is-promise/is-promise',
    './make-promise'
], function (require, exports, module) {
    'use strict';
    var QUnit = require('../../test/qunit');
    var isPromise = require('../is-promise/is-promise');
    var makePromise = require('./make-promise');
    QUnit.module('can-util/js/make-promise');
    QUnit.test('basics', function (assert) {
        var obj = {
            fail: function () {
            },
            then: function () {
            }
        };
        var promise = makePromise(obj);
        assert.ok(isPromise(promise));
        obj = {
            catch: function () {
            },
            then: function () {
            }
        };
        promise = makePromise(obj);
        assert.ok(isPromise(promise));
    });
});
/*can-util@3.11.2#js/omit/omit*/
define('can-util@3.11.2#js/omit/omit', function (require, exports, module) {
    'use strict';
    module.exports = function (source, propsToOmit) {
        var result = {};
        for (var prop in source) {
            if (propsToOmit.indexOf(prop) < 0) {
                result[prop] = source[prop];
            }
        }
        return result;
    };
});
/*can-util@3.11.2#js/omit/omit-test*/
define('can-util@3.11.2#js/omit/omit-test', [
    'require',
    'exports',
    'module',
    './omit',
    '../../test/qunit'
], function (require, exports, module) {
    'use strict';
    var omit = require('./omit');
    var QUnit = require('../../test/qunit');
    QUnit.module('can-util/js/omit');
    QUnit.test('Omit properties from an object', function (assert) {
        var source = {
            a: 1,
            b: 2,
            c: 3,
            d: 4
        };
        var propsToOmit = [
            'b',
            'd'
        ];
        var expected = {
            a: 1,
            c: 3
        };
        var actual = omit(source, propsToOmit);
        assert.deepEqual(expected, actual);
    });
});
/*can-util@3.11.2#js/is-web-worker/is-web-worker*/
define('can-util@3.11.2#js/is-web-worker/is-web-worker', function (require, exports, module) {
    (function (global, require, exports, module) {
        'use strict';
        module.exports = function () {
            return typeof WorkerGlobalScope !== 'undefined' && this instanceof WorkerGlobalScope;
        };
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-util@3.11.2#js/is-web-worker/is-web-worker-test*/
define('can-util@3.11.2#js/is-web-worker/is-web-worker-test', [
    'require',
    'exports',
    'module',
    '../../test/qunit',
    './is-web-worker'
], function (require, exports, module) {
    'use strict';
    var QUnit = require('../../test/qunit');
    var isWebWorker = require('./is-web-worker');
    QUnit.module('can-util/js/is-web-worker');
    QUnit.test('basics', function (assert) {
        assert.equal(typeof isWebWorker(), 'boolean');
    });
});
/*can-util@3.11.2#js/join-uris/join-uris-test*/
define('can-util@3.11.2#js/join-uris/join-uris-test', [
    'require',
    'exports',
    'module',
    '../../test/qunit',
    './join-uris'
], function (require, exports, module) {
    'use strict';
    var QUnit = require('../../test/qunit');
    var joinURIs = require('./join-uris');
    QUnit.module('can-util/js/join-uris');
    QUnit.test('basics', function (assert) {
        assert.deepEqual(joinURIs('foo/bar/car.html', '../zed.html'), 'foo/zed.html');
    });
});
/*can-util@3.11.2#js/last/last-test*/
define('can-util@3.11.2#js/last/last-test', [
    'require',
    'exports',
    'module',
    '../../test/qunit',
    './last'
], function (require, exports, module) {
    'use strict';
    var QUnit = require('../../test/qunit');
    var last = require('./last');
    QUnit.module('can-util/js/last');
    QUnit.test('basics', function (assert) {
        assert.equal(last([
            'a',
            'b'
        ]), 'b');
    });
});
/*can-util@3.11.2#js/make-array/make-array-test*/
define('can-util@3.11.2#js/make-array/make-array-test', [
    'require',
    'exports',
    'module',
    '../../test/qunit',
    './make-array'
], function (require, exports, module) {
    'use strict';
    var QUnit = require('../../test/qunit');
    var makeArray = require('./make-array');
    QUnit.module('can-util/js/make-array');
    QUnit.test('basics', function (assert) {
        var res = makeArray({
            0: 'a',
            length: 1
        });
        assert.deepEqual(res, ['a']);
        assert.ok(res instanceof Array);
    });
    QUnit.test('with Object', function (assert) {
        var res = makeArray({
            abc: 'xyz',
            bar: 'foo'
        });
        assert.deepEqual(res, [{
                abc: 'xyz',
                bar: 'foo'
            }]);
        assert.ok(res instanceof Array);
    });
    QUnit.test('with number', function (assert) {
        var res = makeArray(1);
        assert.deepEqual(res, [1]);
        assert.ok(res instanceof Array);
    });
    QUnit.test('with zero', function (assert) {
        var res = makeArray(0);
        assert.deepEqual(res, [0]);
        assert.ok(res instanceof Array);
    });
    QUnit.test('with null', function (assert) {
        var res = makeArray(null);
        assert.deepEqual(res, []);
        assert.ok(res instanceof Array);
    });
});
/*can-util@3.11.2#js/make-map/make-map*/
define('can-util@3.11.2#js/make-map/make-map', [
    'require',
    'exports',
    'module',
    '../each/each'
], function (require, exports, module) {
    'use strict';
    var each = require('../each/each');
    function makeMap(str) {
        var obj = {}, items = str.split(',');
        each(items, function (name) {
            obj[name] = true;
        });
        return obj;
    }
    module.exports = makeMap;
});
/*can-util@3.11.2#js/make-map/make-map-test*/
define('can-util@3.11.2#js/make-map/make-map-test', [
    'require',
    'exports',
    'module',
    '../../test/qunit',
    './make-map'
], function (require, exports, module) {
    'use strict';
    var QUnit = require('../../test/qunit');
    var makeMap = require('./make-map');
    QUnit.module('can-util/js/make-map');
    QUnit.test('basics', function (assert) {
        var res = makeMap('a,b,c');
        assert.deepEqual(res, {
            a: true,
            b: true,
            c: true
        });
        assert.ok(res instanceof Object);
    });
});
/*can-util@3.11.2#js/set-not-enumerable/set-not-enumerable-test*/
define('can-util@3.11.2#js/set-not-enumerable/set-not-enumerable-test', [
    'require',
    'exports',
    'module',
    '../../test/qunit',
    './set-not-enumerable'
], function (require, exports, module) {
    'use strict';
    var QUnit = require('../../test/qunit');
    var setNotEnumerable = require('./set-not-enumerable');
    QUnit.module('can-util/js/set-not-enumerable');
    QUnit.test('basics', function (assert) {
        assert.expect(0);
        var obj = {};
        setNotEnumerable(obj, 'prop', 'val');
        for (var prop in obj) {
            assert.ok(false, prop);
        }
    });
});
/*can-util@3.11.2#js/single-reference/single-reference-test*/
define('can-util@3.11.2#js/single-reference/single-reference-test', [
    'require',
    'exports',
    'module',
    '../../test/qunit',
    './single-reference'
], function (require, exports, module) {
    'use strict';
    var QUnit = require('../../test/qunit');
    var singleReference = require('./single-reference');
    QUnit.module('can-util/js/single-reference');
    QUnit.test('basics', function (assert) {
        var obj = {};
        singleReference.set(obj, 'pet', 'dog');
        var retrieved = singleReference.getAndDelete(obj, 'pet');
        assert.equal(retrieved, 'dog', 'sets and retrieves successfully');
        assert.equal(Object.keys(obj).length, 0, 'also deletes when retrieved');
    });
});
/*can-util@3.11.2#js/string/string-test*/
define('can-util@3.11.2#js/string/string-test', [
    'require',
    'exports',
    'module',
    '../../test/qunit',
    './string',
    '../get/get'
], function (require, exports, module) {
    'use strict';
    var QUnit = require('../../test/qunit');
    var string = require('./string');
    var get = require('../get/get');
    QUnit.module('can-util/js/string');
    QUnit.test('string.sub', function (assert) {
        assert.equal(string.sub('a{b}', { b: 'c' }), 'ac');
        var foo = { b: 'c' };
        assert.equal(string.sub('a{b}', foo, true), 'ac');
        assert.ok(!foo.b, 'b\'s value was removed');
    });
    QUnit.test('string.sub with undefined values', function (assert) {
        var subbed = string.sub('test{exists} plus{noexists}', { exists: 'test' });
        assert.deepEqual(subbed, null, 'Rendering with undefined values should return null');
        subbed = string.sub('test{exists} plus{noexists}', { exists: 'test' }, true);
        assert.deepEqual(subbed, null, 'Rendering with undefined values should return null even when remove param is true');
    });
    QUnit.test('string.sub with null values', function (assert) {
        var subbed = string.sub('test{exists} plus{noexists}', {
            exists: 'test',
            noexists: null
        });
        assert.deepEqual(subbed, null, 'Rendering with null values should return null');
        subbed = string.sub('test{exists} plus{noexists}', {
            exists: 'test',
            noexists: null
        }, true);
        assert.deepEqual(subbed, null, 'Rendering with null values should return null even when remove param is true');
    });
    QUnit.test('string.sub double', function (assert) {
        assert.equal(string.sub('{b} {d}', {
            b: 'c',
            d: 'e'
        }), 'c e');
    });
    QUnit.test('String.underscore', function (assert) {
        assert.equal(string.underscore('Foo.Bar.ZarDar'), 'foo.bar.zar_dar');
    });
    QUnit.test('string.sub remove', function (assert) {
        var obj = { a: 'a' };
        assert.equal(string.sub('{a}', obj, false), 'a');
        assert.deepEqual(obj, { a: 'a' });
        assert.equal(string.sub('{a}', obj, true), 'a');
        assert.deepEqual(obj, {});
    });
    QUnit.test('get Single root', function (assert) {
        var root, result;
        root = { foo: 'bar' };
        result = get(root, 'foo');
        assert.equal(result, 'bar', 'got \'bar\'');
        result = get(root, 'baz');
        assert.equal(result, undefined, 'got \'undefined\'');
    });
    QUnit.test('get Multiple root', function (assert) {
        var root1, root2, roots, result;
        root1 = { a: 1 };
        root2 = { b: 2 };
        roots = [
            root1,
            root2
        ];
        result = get(roots, '0.a');
        assert.equal(result, 1, 'got \'1\'');
        result = get(roots, '1.b');
        assert.equal(result, 2, 'got \'2\'');
        result = get(roots, 'c');
        assert.equal(result, undefined, 'got \'undefined\'');
        root1 = undefined;
        root2 = { b: 2 };
        roots = [
            root1,
            root2
        ];
        result = get(roots, '1.b');
        assert.equal(result, 2, 'got \'2\'');
    });
    QUnit.test('get Deep objects', function (assert) {
        var root, result;
        root = { foo: { bar: 'baz' } };
        result = get(root, 'foo.bar');
        assert.equal(result, 'baz', 'got \'baz\'');
        result = get(root, 'foo.world');
        assert.equal(result, undefined, 'got \'undefined\'');
    });
    QUnit.test('string.esc', function (assert) {
        var text = string.esc(0);
        assert.equal(text, '0', '0 value properly rendered');
        text = string.esc(null);
        assert.deepEqual(text, '', 'null value returns empty string');
        text = string.esc();
        assert.deepEqual(text, '', 'undefined returns empty string');
        text = string.esc(NaN);
        assert.deepEqual(text, '', 'NaN returns empty string');
        text = string.esc('<div>&nbsp;</div>');
        assert.equal(text, '&lt;div&gt;&amp;nbsp;&lt;/div&gt;', 'HTML escaped properly');
    });
    QUnit.test('string.camelize', function (assert) {
        var text = string.camelize(0);
        assert.equal(text, '0', '0 value properly rendered');
        text = string.camelize(null);
        assert.equal(text, '', 'null value returns empty string');
        text = string.camelize();
        assert.equal(text, '', 'undefined returns empty string');
        text = string.camelize(NaN);
        assert.equal(text, '', 'NaN returns empty string');
        text = string.camelize('-moz-index');
        assert.equal(text, 'MozIndex');
        text = string.camelize('foo-bar');
        assert.equal(text, 'fooBar');
    });
    QUnit.test('string.hyphenate', function (assert) {
        var text = string.hyphenate(0);
        assert.equal(text, '0', '0 value properly rendered');
        text = string.hyphenate(null);
        assert.equal(text, '', 'null value returns empty string');
        text = string.hyphenate();
        assert.equal(text, '', 'undefined returns empty string');
        text = string.hyphenate(NaN);
        assert.equal(text, '', 'NaN returns empty string');
        text = string.hyphenate('ABC');
        assert.equal(text, 'ABC');
        text = string.hyphenate('dataNode');
        assert.equal(text, 'data-node');
    });
    QUnit.test('string.replaceWith should substitute paths with replacer values', function (assert) {
        assert.expect(5);
        var str = 'I like {food} and {hobbies.favorite}';
        var data = {
            food: 'cake',
            hobbies: { favorite: 'writing unit tests' }
        };
        var callCount = 0;
        var replacer = function (key, value) {
            callCount++;
            if (callCount === 1) {
                assert.equal(key, 'food');
                assert.equal(value, 'cake');
            }
            if (callCount === 2) {
                assert.equal(key, 'hobbies.favorite');
                assert.equal(value, 'writing unit tests');
            }
            return value;
        };
        assert.equal(string.replaceWith(str, data, replacer), 'I like cake and writing unit tests');
    });
});
/*can-util@3.11.2#js/string-to-any/string-to-any-test*/
define('can-util@3.11.2#js/string-to-any/string-to-any-test', [
    'require',
    'exports',
    'module',
    '../../test/qunit',
    './string-to-any',
    '../each/each'
], function (require, exports, module) {
    'use strict';
    var QUnit = require('../../test/qunit');
    var stringToAny = require('./string-to-any');
    var each = require('../each/each');
    QUnit.module('can-util/js/string-to-any');
    QUnit.test('works with primitive types', function (assert) {
        var fixture = {
            'foo': 'foo',
            '33': 33,
            'true': true,
            'false': false,
            'undefined': undefined,
            'null': null,
            'Infinity': Infinity
        };
        each(fixture, function (value, key) {
            assert.ok(stringToAny(key) === value, 'Correctly converted type: ' + key);
        });
        assert.ok(isNaN(stringToAny('NaN')), 'Correclty converted type: NaN');
    });
});
/*can-util@3.11.2#js/tests*/
define('can-util@3.11.2#js/tests', [
    'require',
    'exports',
    'module',
    './assign-non-enumerable/assign-non-enumerable-test',
    './base-url/base-url-test',
    './deep-assign/deep-assign-test',
    './defaults/defaults-test',
    './diff/diff-test',
    './diff-array/diff-array-test',
    './diff-object/diff-object-test',
    './each/each-test',
    './get/get-test',
    './import/import-test',
    './is-array-like/is-array-like-test',
    './is-container/is-container-test',
    './is-empty-object/is-empty-object-test',
    './is-function/is-function-test',
    './is-node/is-node-test',
    './is-plain-object/is-plain-object-test',
    './is-promise-like/is-promise-like-test',
    './make-promise/make-promise-test',
    './omit/omit-test',
    './is-web-worker/is-web-worker-test',
    './join-uris/join-uris-test',
    './last/last-test',
    './make-array/make-array-test',
    './make-map/make-map-test',
    './set-not-enumerable/set-not-enumerable-test',
    './single-reference/single-reference-test',
    './string/string-test',
    './string-to-any/string-to-any-test'
], function (require, exports, module) {
    'use strict';
    require('./assign-non-enumerable/assign-non-enumerable-test');
    require('./base-url/base-url-test');
    require('./deep-assign/deep-assign-test');
    require('./defaults/defaults-test');
    require('./diff/diff-test');
    require('./diff-array/diff-array-test');
    require('./diff-object/diff-object-test');
    require('./each/each-test');
    require('./get/get-test');
    require('./import/import-test');
    require('./is-array-like/is-array-like-test');
    require('./is-container/is-container-test');
    require('./is-empty-object/is-empty-object-test');
    require('./is-function/is-function-test');
    require('./is-node/is-node-test');
    require('./is-plain-object/is-plain-object-test');
    require('./is-promise-like/is-promise-like-test');
    require('./make-promise/make-promise-test');
    require('./omit/omit-test');
    require('./is-web-worker/is-web-worker-test');
    require('./join-uris/join-uris-test');
    require('./last/last-test');
    require('./make-array/make-array-test');
    require('./make-map/make-map-test');
    require('./set-not-enumerable/set-not-enumerable-test');
    require('./single-reference/single-reference-test');
    require('./string/string-test');
    require('./string-to-any/string-to-any-test');
});
/*can-connect@2.0.1#connect*/
define('can-connect@2.0.1#connect', [
    'require',
    'exports',
    'module',
    'can-util/js/assign/assign'
], function (require, exports, module) {
    var assign = require('can-util/js/assign/assign');
    var connect = function (behaviors, options) {
        behaviors = behaviors.map(function (behavior, index) {
            var sortedIndex = -1;
            if (typeof behavior === 'string') {
                sortedIndex = connect.order.indexOf(behavior);
                behavior = behaviorsMap[behavior];
            } else if (behavior.isBehavior) {
                sortedIndex = connect.order.indexOf(behavior.behaviorName);
            } else {
                behavior = connect.behavior(behavior);
            }
            return {
                originalIndex: index,
                sortedIndex: sortedIndex,
                behavior: behavior
            };
        });
        behaviors.sort(function (b1, b2) {
            if (~b1.sortedIndex && ~b2.sortedIndex) {
                return b1.sortedIndex - b2.sortedIndex;
            }
            return b1.originalIndex - b2.originalIndex;
        });
        behaviors = behaviors.map(function (b) {
            return b.behavior;
        });
        var behavior = connect.base(connect.behavior('options', function () {
            return options;
        })());
        behaviors.forEach(function (behave) {
            behavior = behave(behavior);
        });
        if (behavior.init) {
            behavior.init();
        }
        return behavior;
    };
    connect.order = [
        'data/localstorage-cache',
        'data/url',
        'data/parse',
        'cache-requests',
        'data/combine-requests',
        'constructor',
        'constructor/store',
        'can/map',
        'can/ref',
        'fall-through-cache',
        'data/worker',
        'real-time',
        'data/callbacks-cache',
        'data/callbacks',
        'constructor/callbacks-once'
    ];
    connect.behavior = function (name, behavior) {
        if (typeof name !== 'string') {
            behavior = name;
            name = undefined;
        }
        var behaviorMixin = function (base) {
            var Behavior = function () {
            };
            Behavior.name = name;
            Behavior.prototype = base;
            var newBehavior = new Behavior();
            var res = typeof behavior === 'function' ? behavior.apply(newBehavior, arguments) : behavior;
            assign(newBehavior, res);
            newBehavior.__behaviorName = name;
            return newBehavior;
        };
        if (name) {
            behaviorMixin.behaviorName = name;
            behaviorsMap[name] = behaviorMixin;
        }
        behaviorMixin.isBehavior = true;
        return behaviorMixin;
    };
    var behaviorsMap = {};
    module.exports = connect;
});
/*can-connect@2.0.1#base/base*/
define('can-connect@2.0.1#base/base', [
    'require',
    'exports',
    'module',
    'can-connect/connect'
], function (require, exports, module) {
    var connect = require('can-connect/connect');
    module.exports = connect.behavior('base', function (baseConnection) {
        return {
            id: function (instance) {
                var ids = [], algebra = this.algebra;
                if (algebra && algebra.clauses && algebra.clauses.id) {
                    for (var prop in algebra.clauses.id) {
                        ids.push(instance[prop]);
                    }
                }
                if (this.idProp && !ids.length) {
                    ids.push(instance[this.idProp]);
                }
                if (!ids.length) {
                    ids.push(instance.id);
                }
                return ids.length > 1 ? ids.join('@|@') : ids[0];
            },
            idProp: baseConnection.idProp || 'id',
            listSet: function (list) {
                return list[this.listSetProp];
            },
            listSetProp: '__listSet',
            init: function () {
            }
        };
    });
});
/*can-connect@2.0.1#can-connect*/
define('can-connect@2.0.1#can-connect', [
    'require',
    'exports',
    'module',
    'can-connect/connect',
    'can-connect/base/base',
    'can-namespace'
], function (require, exports, module) {
    var connect = require('can-connect/connect');
    var base = require('can-connect/base/base');
    var ns = require('can-namespace');
    connect.base = base;
    module.exports = ns.connect = connect;
});
/*can-validate-interface@1.0.0#index*/
define('can-validate-interface@1.0.0#index', function (require, exports, module) {
    'use strict';
    function flatten(arrays) {
        return arrays.reduce(function (ret, val) {
            return ret.concat(val);
        }, []);
    }
    function makeInterfaceValidator(interfacePropArrays) {
        var props = flatten(interfacePropArrays);
        return function (base) {
            var missingProps = props.reduce(function (missing, prop) {
                return prop in base ? missing : missing.concat(prop);
            }, []);
            return missingProps.length ? {
                message: 'missing expected properties',
                related: missingProps
            } : undefined;
        };
    }
    module.exports = makeInterfaceValidator;
});
/*can-validate-interface@1.0.0#test*/
define('can-validate-interface@1.0.0#test', [
    'require',
    'exports',
    'module',
    'steal-qunit',
    'can-connect',
    './index.js'
], function (require, exports, module) {
    'use strict';
    var QUnit = require('steal-qunit');
    var connect = require('can-connect');
    var makeInterfaceValidator = require('./index.js');
    var BaseInterface = [
        'id',
        'idProp',
        'listSet',
        'listSetProp'
    ];
    QUnit.module('can-validate-interface/makeInterfaceValidator');
    QUnit.test('should return can-validate style error when can-connect connection is missing property', function () {
        var testBehavior = function (baseBehavior) {
            var validator = makeInterfaceValidator([
                    BaseInterface,
                    'testProp'
                ]), error = validator(baseBehavior);
            equal(error.message, 'missing expected properties', 'missing property validation error raised');
            deepEqual(error.related, ['testProp'], 'error contains missing property name');
            return baseBehavior;
        };
        connect([testBehavior], {});
    });
});
/*can-view-live@4.0.1#test/html-test*/
define('can-view-live@4.0.1#test/html-test', [
    'require',
    'exports',
    'module',
    'can-view-live',
    'can-define/list/list',
    'can-observation',
    'steal-qunit',
    'can-simple-observable',
    'can-view-nodelist',
    'can-test-helpers'
], function (require, exports, module) {
    var live = require('can-view-live');
    var DefineList = require('can-define/list/list');
    var Observation = require('can-observation');
    var QUnit = require('steal-qunit');
    var SimpleObservable = require('can-simple-observable');
    var NodeLists = require('can-view-nodelist');
    var testHelpers = require('can-test-helpers');
    QUnit.module('can-view-live.html');
    test('basics', function () {
        var div = document.createElement('div'), span = document.createElement('span');
        div.appendChild(span);
        var items = new DefineList([
            'one',
            'two'
        ]);
        var html = new Observation(function itemsHTML() {
            var html = '';
            items.forEach(function (item) {
                html += '<label>' + item + '</label>';
            });
            return html;
        });
        live.html(span, html, div);
        equal(div.getElementsByTagName('label').length, 2);
        items.push('three');
        equal(div.getElementsByTagName('label').length, 3);
    });
    test('html live binding handles getting a function from a compute', 5, function () {
        var handler = function (el) {
            ok(true, 'called handler');
            equal(el.nodeType, 3, 'got a placeholder');
        };
        var div = document.createElement('div'), placeholder = document.createTextNode('');
        div.appendChild(placeholder);
        var count = new SimpleObservable(0);
        var html = new Observation(function () {
            if (count.get() === 0) {
                return '<h1>Hello World</h1>';
            } else {
                return handler;
            }
        });
        live.html(placeholder, html, div);
        equal(div.getElementsByTagName('h1').length, 1, 'got h1');
        count.set(1);
        equal(div.getElementsByTagName('h1').length, 0, 'got h1');
        count.set(0);
        equal(div.getElementsByTagName('h1').length, 1, 'got h1');
    });
    QUnit.test('Works with Observations - .html', function () {
        var div = document.createElement('div'), span = document.createElement('span');
        div.appendChild(span);
        var items = new DefineList([
            'one',
            'two'
        ]);
        var html = new Observation(function () {
            var html = '';
            items.forEach(function (item) {
                html += '<label>' + item + '</label>';
            });
            return html;
        });
        live.html(span, html, div);
        equal(div.getElementsByTagName('label').length, 2);
        items.push('three');
        equal(div.getElementsByTagName('label').length, 3);
    });
    testHelpers.dev.devOnlyTest('child elements must disconnect before parents can re-evaluate', 1, function () {
        var observable = new SimpleObservable('value');
        var childObservation = new Observation(function child() {
            QUnit.ok(true, 'called child content once');
            observable.get();
            return 'CHILD CONTENT';
        }, null, { priority: 1 });
        var htmlNodeList = [];
        var parentObservation = new Observation(function parent() {
            var result = observable.get();
            if (result === 'value') {
                var childTextNode = document.createTextNode('');
                var childFrag = document.createDocumentFragment();
                childFrag.appendChild(childTextNode);
                var nodeList = [childTextNode];
                NodeLists.register(nodeList, null, htmlNodeList, true);
                live.html(childTextNode, childObservation, null, nodeList);
                return childFrag;
            } else {
                return 'NEW CONTENT';
            }
        }, null, { priority: 0 });
        var parentTextNode = document.createTextNode('');
        var div = document.createElement('div');
        div.appendChild(parentTextNode);
        htmlNodeList.push(parentTextNode);
        NodeLists.register(htmlNodeList, function () {
        }, true, true);
        live.html(parentTextNode, parentObservation, div, htmlNodeList);
        observable.set('VALUE');
    });
});
/*can-view-live@4.0.1#test/patcher-test*/
define('can-view-live@4.0.1#test/patcher-test', [
    'require',
    'exports',
    'module',
    'can-define/list/list',
    'steal-qunit',
    'can-symbol',
    '../lib/patcher',
    'can-simple-observable'
], function (require, exports, module) {
    var DefineList = require('can-define/list/list');
    var QUnit = require('steal-qunit');
    var canSymbol = require('can-symbol');
    var Patcher = require('../lib/patcher');
    var SimpleObservable = require('can-simple-observable');
    QUnit.module('can-view-live patcher', {
        setup: function () {
            this.fixture = document.getElementById('qunit-fixture');
        }
    });
    QUnit.test('multiple lists can be updated at once', 2, function () {
        var list = new DefineList([
            'a',
            'b'
        ]);
        var p1 = new Patcher(list), p2 = new Patcher(list);
        p1[canSymbol.for('can.onPatches')](function () {
            QUnit.ok(true, 'called p1');
        });
        p2[canSymbol.for('can.onPatches')](function () {
            QUnit.ok(true, 'called p2');
        });
        list.push('c');
    });
    QUnit.test('undefined value won\'t error', 1, function () {
        var undfinedObservable = new SimpleObservable(undefined);
        var pu = new Patcher(undfinedObservable);
        pu[canSymbol.for('can.onPatches')](function () {
            QUnit.ok(true, 'called pu');
        });
        undfinedObservable.set('a');
    });
});
/*can-view-live@4.0.1#test/list-test*/
define('can-view-live@4.0.1#test/list-test', [
    'require',
    'exports',
    'module',
    'can-view-live',
    'can-define/list/list',
    'can-observation',
    'steal-qunit',
    'can-simple-observable',
    'can-simple-map',
    'can-reflect',
    'can-queues',
    'can-util/dom/fragment/fragment',
    'can-view-nodelist',
    'can-dom-mutate',
    'can-dom-mutate/node',
    'can-symbol',
    'can-test-helpers',
    'can-reflect-dependencies'
], function (require, exports, module) {
    var live = require('can-view-live');
    var DefineList = require('can-define/list/list');
    var Observation = require('can-observation');
    var QUnit = require('steal-qunit');
    var SimpleObservable = require('can-simple-observable');
    var SimpleMap = require('can-simple-map');
    var canReflect = require('can-reflect');
    var queues = require('can-queues');
    var fragment = require('can-util/dom/fragment/fragment');
    var NodeLists = require('can-view-nodelist');
    var domMutate = require('can-dom-mutate');
    var domMutateNode = require('can-dom-mutate/node');
    var canSymbol = require('can-symbol');
    var testHelpers = require('can-test-helpers');
    var canReflectDeps = require('can-reflect-dependencies');
    QUnit.module('can-view-live.list', {
        setup: function () {
            this.fixture = document.getElementById('qunit-fixture');
        }
    });
    QUnit.test('basics', function () {
        var div = document.createElement('div'), list = new DefineList([
                'sloth',
                'bear'
            ]), template = function (animal) {
                return '<label>Animal=</label> <span>' + animal.get() + '</span>';
            };
        div.innerHTML = 'my <b>fav</b> animals: <span></span> !';
        var el = div.getElementsByTagName('span')[0];
        live.list(el, list, template, {});
        equal(div.getElementsByTagName('label').length, 2, 'There are 2 labels');
        div.getElementsByTagName('label')[0].myexpando = 'EXPANDO-ED';
        list.push('turtle');
        equal(div.getElementsByTagName('label')[0].myexpando, 'EXPANDO-ED', 'same expando');
        equal(div.getElementsByTagName('span')[2].innerHTML, 'turtle', 'turtle added');
    });
    QUnit.test('list within an Observation', 5, function () {
        var div = document.createElement('div'), map = new SimpleMap({
                animals: new DefineList([
                    'bear',
                    'turtle'
                ])
            }), template = function (animal) {
                return '<label>Animal=</label> <span>' + animal.get() + '</span>';
            };
        var listCompute = new Observation(function animalsFromMap() {
            return map.attr('animals');
        });
        div.innerHTML = 'my <b>fav</b> animals: <span></span> !';
        var el = div.getElementsByTagName('span')[0];
        live.list(el, listCompute, template, {});
        equal(div.getElementsByTagName('label').length, 2, 'There are 2 labels');
        div.getElementsByTagName('label')[0].myexpando = 'EXPANDO-ED';
        map.attr('animals').push('turtle');
        equal(div.getElementsByTagName('label')[0].myexpando, 'EXPANDO-ED', 'same expando');
        equal(div.getElementsByTagName('span')[2].innerHTML, 'turtle', 'turtle added');
        map.attr('animals', new DefineList([
            'sloth',
            'bear',
            'turtle'
        ]));
        var spans = div.getElementsByTagName('span');
        equal(spans.length, 3, 'there are 3 spans');
        ok(!div.getElementsByTagName('label')[0].myexpando, 'no expando');
    });
    QUnit.test('.list within a observable value holding an Array list', function () {
        var div = document.createElement('div');
        var template = function (num) {
            return '<label>num=</label> <span>' + num + '</span>';
        };
        var arr = new SimpleObservable([
            0,
            1
        ]);
        div.innerHTML = 'my <b>fav</b> nums: <span></span> !';
        var el = div.getElementsByTagName('span')[0];
        live.list(el, arr, template, {});
        equal(div.getElementsByTagName('label').length, 2, 'There are 2 labels');
        arr.set([
            0,
            1,
            2
        ]);
        var spans = div.getElementsByTagName('span');
        equal(spans.length, 3, 'there are 3 spans');
    });
    test('live.list should handle move patches', function (assert) {
        var parent = document.createElement('div');
        var child = document.createElement('div');
        parent.appendChild(child);
        var onPatchesHandler;
        var list = [
            'a',
            'b',
            'c'
        ];
        canReflect.assignSymbols(list, {
            'can.onPatches': function (handler) {
                onPatchesHandler = handler;
            }
        });
        var template = function (num) {
            return '<span>' + num.get() + '</span>';
        };
        live.list(child, list, template, {});
        list.shift();
        list.splice(1, 0, 'a');
        queues.batch.start();
        onPatchesHandler([{
                type: 'move',
                fromIndex: 0,
                toIndex: 1
            }]);
        queues.batch.stop();
        assert.ok(true, 'The list should not blow up');
        var values = canReflect.toArray(parent.getElementsByTagName('span')).map(function (span) {
            return span.innerHTML;
        });
        QUnit.deepEqual(values, [
            'b',
            'a',
            'c'
        ]);
    });
    QUnit.test('list and an falsey section (#1979)', function () {
        var div = document.createElement('div'), template = function (num) {
                return '<label>num=</label> <span>' + num + '</span>';
            }, falseyTemplate = function () {
                return '<p>NOTHING</p>';
            };
        var listCompute = new SimpleObservable([
            0,
            1
        ]);
        div.innerHTML = 'my <b>fav</b> nums: <span></span> !';
        var el = div.getElementsByTagName('span')[0];
        live.list(el, listCompute, template, {}, undefined, undefined, falseyTemplate);
        equal(div.getElementsByTagName('label').length, 2, 'There are 2 labels');
        listCompute.set([]);
        var spans = div.getElementsByTagName('span');
        equal(spans.length, 0, 'there are 0 spans');
        var ps = div.getElementsByTagName('p');
        equal(ps.length, 1, 'there is 1 p');
        listCompute.set([2]);
        spans = div.getElementsByTagName('span');
        equal(spans.length, 1, 'there is 1 spans');
        ps = div.getElementsByTagName('p');
        equal(ps.length, 0, 'there is 1 p');
    });
    QUnit.test('list and an initial falsey section (#1979)', function () {
        var div = document.createElement('div'), template = function (num) {
                return '<label>num=</label> <span>' + num + '</span>';
            }, falseyTemplate = function () {
                return '<p>NOTHING</p>';
            };
        var listCompute = new SimpleObservable([]);
        div.innerHTML = 'my <b>fav</b> nums: <span></span> !';
        var el = div.getElementsByTagName('span')[0];
        live.list(el, listCompute, template, {}, undefined, undefined, falseyTemplate);
        var spans = div.getElementsByTagName('span');
        equal(spans.length, 0, 'there are 0 spans');
        var ps = div.getElementsByTagName('p');
        equal(ps.length, 1, 'there is 1 p');
        listCompute.set([2]);
        spans = div.getElementsByTagName('span');
        equal(spans.length, 1, 'there is 1 spans');
        ps = div.getElementsByTagName('p');
        equal(ps.length, 0, 'there is 1 p');
    });
    test('list items should be correct even if renderer flushes batch (#8)', function () {
        var partial = document.createElement('div');
        var placeholderElement = document.createElement('span');
        var list = new DefineList([
            'one',
            'two'
        ]);
        var renderer = function (item) {
            queues.flush();
            return '<span>' + item.get() + '</span>';
        };
        partial.appendChild(placeholderElement);
        live.list(placeholderElement, list, renderer, {});
        equal(partial.getElementsByTagName('span').length, 2, 'should be two items');
        equal(partial.getElementsByTagName('span')[0].firstChild.data, 'one', 'list item 0 is "one"');
        equal(partial.getElementsByTagName('span')[1].firstChild.data, 'two', 'list item 1 is "two"');
        queues.batch.start();
        list.splice(0, 0, 'three');
        list.splice(2, 1);
        queues.batch.stop();
        equal(partial.getElementsByTagName('span').length, 2, 'should be two items');
        equal(partial.getElementsByTagName('span')[0].firstChild.data, 'three', 'list item 0 is "three"');
        equal(partial.getElementsByTagName('span')[1].firstChild.data, 'one', 'list item 1 is "one"');
    });
    test('changing items in a live.list after it has been unregistered works (#55)', function () {
        var map = new SimpleMap({
            show: true,
            list: new DefineList(['one'])
        });
        var htmlNodeList = canReflect.toArray(fragment('<div></div>').childNodes);
        NodeLists.register(htmlNodeList, function () {
        }, true);
        var listNodeList = canReflect.toArray(fragment('<div></div>').childNodes);
        NodeLists.register(listNodeList, function () {
        }, htmlNodeList, true);
        var listTextNode = document.createTextNode('');
        var listFrag = document.createDocumentFragment();
        listFrag.appendChild(listTextNode);
        var htmlTextNode = document.createTextNode('');
        var div = document.createElement('div');
        div.appendChild(htmlTextNode);
        var listObs = new Observation(function list() {
            return map.attr('list');
        }, { priority: 2 });
        var listRenderer = function (item) {
            Observation.temporarilyBind(item);
            return item.get();
        };
        live.list(listTextNode, listObs, listRenderer, map, listTextNode.parentNode, listNodeList);
        var htmlObservation = new Observation(function if_show_html() {
            return map.attr('show') ? listFrag : undefined;
        }, { priority: 1 });
        live.html(htmlTextNode, htmlObservation, htmlTextNode.parentNode, htmlNodeList);
        queues.batch.start();
        map.attr('show', false);
        map.attr('list').replace([
            'two',
            'three'
        ]);
        queues.batch.stop();
        QUnit.ok(true, 'should not throw');
    });
    QUnit.test('Works with Observations - .list', function () {
        var div = document.createElement('div'), map = new SimpleMap({
                animals: new DefineList([
                    'bear',
                    'turtle'
                ])
            }), template = function (animal) {
                return '<label>Animal=</label> <span>' + animal.get() + '</span>';
            };
        var listObservation = new Observation(function () {
            return map.attr('animals');
        });
        div.innerHTML = 'my <b>fav</b> animals: <span></span> !';
        var el = div.getElementsByTagName('span')[0];
        live.list(el, listObservation, template, {});
        equal(div.getElementsByTagName('label').length, 2, 'There are 2 labels');
        div.getElementsByTagName('label')[0].myexpando = 'EXPANDO-ED';
        map.attr('animals').push('turtle');
        equal(div.getElementsByTagName('label')[0].myexpando, 'EXPANDO-ED', 'same expando');
        equal(div.getElementsByTagName('span')[2].innerHTML, 'turtle', 'turtle added');
        map.attr('animals', new DefineList([
            'sloth',
            'bear',
            'turtle'
        ]));
        var spans = div.getElementsByTagName('span');
        equal(spans.length, 3, 'there are 3 spans');
        ok(!div.getElementsByTagName('label')[0].myexpando, 'no expando');
    });
    test('no memory leaks', function () {
        var div = document.createElement('div'), map = new SimpleMap({
                animals: new DefineList([
                    'bear',
                    'turtle'
                ])
            }), template = function (animal) {
                return '<label>Animal=</label> <span>' + animal.get() + '</span>';
            };
        var listObservation = new Observation(function () {
            return map.attr('animals');
        });
        div.innerHTML = 'my <b>fav</b> animals: <span></span> !';
        var el = div.getElementsByTagName('span')[0];
        this.fixture.appendChild(div);
        var fixture = this.fixture;
        live.list(el, listObservation, template, {});
        QUnit.stop();
        setTimeout(function () {
            domMutateNode.removeChild.call(fixture, div);
            setTimeout(function () {
                var handlers = map[canSymbol.for('can.meta')].handlers.get([]);
                equal(handlers.length, 0, 'there are no bindings');
                start();
            }, 50);
        }, 10);
    });
    testHelpers.dev.devOnlyTest('can-reflect-dependencies', function (assert) {
        var done = assert.async();
        assert.expect(2);
        var div = document.createElement('div');
        div.innerHTML = 'my <b>fav</b> animals: <span></span> !';
        document.body.appendChild(div);
        var el = div.getElementsByTagName('span')[0];
        var list = new DefineList([
            'sloth',
            'bear'
        ]);
        var template = function (animal) {
            return '<label>Animal=</label> <span>' + animal.get() + '</span>';
        };
        live.list(el, list, template, {});
        assert.deepEqual(canReflectDeps.getDependencyDataOf(div).whatChangesMe.mutate.valueDependencies, new Set([list]));
        var undo = domMutate.onNodeRemoval(div, function checkTeardown() {
            undo();
            assert.equal(typeof canReflectDeps.getDependencyDataOf(div), 'undefined', 'dependencies should be cleared when parent node is removed');
            done();
        });
        div.remove();
    });
});
/*can-view-live@4.0.1#test/text-test*/
define('can-view-live@4.0.1#test/text-test', [
    'require',
    'exports',
    'module',
    'can-view-live',
    'can-observation',
    'steal-qunit',
    'can-simple-observable',
    'can-dom-mutate',
    'can-dom-mutate/node',
    'can-view-nodelist',
    'can-test-helpers',
    'can-reflect-dependencies'
], function (require, exports, module) {
    var live = require('can-view-live');
    var Observation = require('can-observation');
    var QUnit = require('steal-qunit');
    var SimpleObservable = require('can-simple-observable');
    var domMutate = require('can-dom-mutate');
    var domMutateNode = require('can-dom-mutate/node');
    var nodeLists = require('can-view-nodelist');
    var testHelpers = require('can-test-helpers');
    var canReflectDeps = require('can-reflect-dependencies');
    QUnit.module('can-view-live.text', {
        setup: function () {
            this.fixture = document.getElementById('qunit-fixture');
        }
    });
    var esc = function (str) {
        return str.replace(/</g, '&lt;').replace(/>/g, '&gt;');
    };
    QUnit.test('text', function () {
        var div = document.createElement('div'), span = document.createElement('span');
        div.appendChild(span);
        var value = new SimpleObservable([
            'one',
            'two'
        ]);
        var text = new Observation(function html() {
            var html = '';
            value.get().forEach(function (item) {
                html += '<label>' + item + '</label>';
            });
            return html;
        });
        live.text(span, text, div);
        equal(div.innerHTML, esc('<label>one</label><label>two</label>'));
        value.set([
            'one',
            'two',
            'three'
        ]);
        equal(div.innerHTML, esc('<label>one</label><label>two</label><label>three</label>'));
    });
    QUnit.test('text binding is memory safe (#666)', function () {
        nodeLists.nodeMap.clear();
        var div = document.createElement('div'), span = document.createElement('span'), text = new Observation(function () {
                return 'foo';
            });
        div.appendChild(span);
        domMutateNode.appendChild.call(this.fixture, div);
        live.text(span, text, div);
        domMutateNode.removeChild.call(this.fixture, div);
        stop();
        setTimeout(function () {
            ok(!nodeLists.nodeMap.size, 'nothing in nodeMap');
            start();
        }, 100);
    });
    testHelpers.dev.devOnlyTest('can-reflect-dependencies', function (assert) {
        var done = assert.async();
        assert.expect(2);
        var div = document.createElement('div');
        var span = document.createElement('span');
        div.appendChild(span);
        document.body.appendChild(div);
        var value = new SimpleObservable([
            'one',
            'two'
        ]);
        var text = new Observation(function html() {
            return value.get().map(function (item) {
                return '<label>' + item + '</label>';
            }).join('');
        });
        live.text(span, text, div);
        assert.deepEqual(canReflectDeps.getDependencyDataOf(div).whatChangesMe.mutate.valueDependencies, new Set([text]));
        var undo = domMutate.onNodeRemoval(div, function checkTeardown() {
            undo();
            assert.equal(typeof canReflectDeps.getDependencyDataOf(div), 'undefined', 'dependencies should be clear out when elements is removed');
            done();
        });
        div.remove();
    });
});
/*can-view-live@4.0.1#test/attr-test*/
define('can-view-live@4.0.1#test/attr-test', [
    'require',
    'exports',
    'module',
    'can-view-live',
    'can-observation',
    'steal-qunit',
    'can-dom-mutate',
    'can-dom-mutate/node',
    'can-simple-observable',
    'can-test-helpers',
    'can-reflect-dependencies'
], function (require, exports, module) {
    var live = require('can-view-live');
    var Observation = require('can-observation');
    var QUnit = require('steal-qunit');
    var domMutate = require('can-dom-mutate');
    var domMutateNode = require('can-dom-mutate/node');
    var SimpleObservable = require('can-simple-observable');
    var testHelpers = require('can-test-helpers');
    var canReflectDeps = require('can-reflect-dependencies');
    QUnit.module('can-view-live.attr', {
        setup: function () {
            this.fixture = document.getElementById('qunit-fixture');
        }
    });
    QUnit.test('basics', function () {
        var div = document.createElement('div');
        var firstValue = new SimpleObservable(null);
        var first = new Observation(function () {
            return firstValue.get() ? 'selected' : '';
        });
        var secondValue = new SimpleObservable(null);
        var second = new Observation(function () {
            return secondValue.get() ? 'active' : '';
        });
        var className = new Observation(function () {
            return 'foo ' + first.get() + ' ' + second.get() + ' end';
        });
        live.attr(div, 'class', className);
        equal(div.className, 'foo   end');
        firstValue.set(true);
        equal(div.className, 'foo selected  end');
        secondValue.set(true);
        equal(div.className, 'foo selected active end');
        firstValue.set(false);
        equal(div.className, 'foo  active end');
    });
    QUnit.test('specialAttribute with new line', function () {
        var div = document.createElement('div');
        var style = new SimpleObservable('width: 50px;\nheight:50px;');
        live.attr(div, 'style', style);
        equal(div.style.height, '50px');
        equal(div.style.width, '50px');
    });
    QUnit.test('can.live.attr works with non-string attributes (#1790)', function () {
        var el = document.createElement('div'), attrCompute = new Observation(function () {
                return 2;
            });
        domMutateNode.setAttribute.call(el, 'value', 1);
        live.attr(el, 'value', attrCompute);
        ok(true, 'No exception thrown.');
    });
    testHelpers.dev.devOnlyTest('can-reflect-dependencies', function (assert) {
        var done = assert.async();
        assert.expect(2);
        var div = document.createElement('div');
        document.body.appendChild(div);
        var id = new SimpleObservable('foo');
        var title = new SimpleObservable('something');
        live.attr(div, 'id', id);
        live.attr(div, 'title', title);
        var divDeps = canReflectDeps.getDependencyDataOf(div).whatChangesMe;
        assert.deepEqual(divDeps.mutate.valueDependencies, new Set([
            id,
            title
        ]), 'should return the two SimpleObservable as dependencies');
        var undo = domMutate.onNodeRemoval(div, function checkTeardown() {
            undo();
            assert.equal(typeof canReflectDeps.getDependencyDataOf(div), 'undefined', 'dependencies should be cleared out when elements is removed');
            done();
        });
        div.remove();
    });
});
/*can-view-live@4.0.1#test/attrs-test*/
define('can-view-live@4.0.1#test/attrs-test', [
    'require',
    'exports',
    'module',
    'can-view-live',
    'can-observation',
    'steal-qunit',
    'can-simple-observable',
    'can-queues',
    'can-dom-mutate',
    'can-dom-mutate/node',
    'can-test-helpers',
    'can-reflect-dependencies'
], function (require, exports, module) {
    var live = require('can-view-live');
    var Observation = require('can-observation');
    var QUnit = require('steal-qunit');
    var SimpleObservable = require('can-simple-observable');
    var queues = require('can-queues');
    var domMutate = require('can-dom-mutate');
    var domMutateNode = require('can-dom-mutate/node');
    var testHelpers = require('can-test-helpers');
    var canReflectDeps = require('can-reflect-dependencies');
    QUnit.module('can-view-live.attrs', {
        setup: function () {
            this.fixture = document.getElementById('qunit-fixture');
        }
    });
    QUnit.test('basics', function () {
        var div = document.createElement('div');
        var property = new SimpleObservable('class'), value = new SimpleObservable('foo');
        var text = new Observation(function () {
            var html = '';
            if (property.get() && value.get()) {
                html += property.get() + '=\'' + value.get() + '\'';
            }
            return html;
        });
        live.attrs(div, text);
        equal(div.className, 'foo');
        property.set(null);
        equal(div.className, '');
        queues.batch.start();
        property.set('foo');
        value.set('bar');
        queues.batch.stop();
        equal(div.getAttribute('foo'), 'bar');
    });
    QUnit.test('should remove `removed` events listener', function (assert) {
        var done = assert.async();
        var onNodeRemoval = domMutate.onNodeRemoval;
        domMutate.onNodeRemoval = function () {
            assert.ok(true, 'addEventListener called');
            var disposal = onNodeRemoval.apply(null, arguments);
            domMutate.onNodeRemoval = onNodeRemoval;
            return function () {
                assert.ok(true, 'disposal function was called');
                disposal();
                done();
            };
        };
        var div = document.createElement('div');
        var text = new SimpleObservable('hello');
        domMutateNode.appendChild.call(this.fixture, div);
        live.attrs(div, text);
        domMutateNode.removeChild.call(this.fixture, div);
    });
    testHelpers.dev.devOnlyTest('can-reflect-dependencies', function (assert) {
        var done = assert.async();
        assert.expect(2);
        var div = document.createElement('div');
        document.body.appendChild(div);
        var attr = new SimpleObservable('class');
        var value = new SimpleObservable('foo');
        var text = new Observation(function () {
            var html = '';
            if (attr.get() && value.get()) {
                html += attr.get() + '="' + value.get() + '"';
            }
            return html;
        });
        live.attrs(div, text);
        assert.deepEqual(canReflectDeps.getDependencyDataOf(div).whatChangesMe.mutate.valueDependencies, new Set([text]));
        var undo = domMutate.onNodeRemoval(div, function checkTeardown() {
            undo();
            assert.equal(typeof canReflectDeps.getDependencyDataOf(div), 'undefined', 'dependencies should be cleared out when element is removed');
            done();
        });
        div.remove();
    });
});
/*can-view-live@4.0.1#test/test*/
define('can-view-live@4.0.1#test/test', [
    'require',
    'exports',
    'module',
    './html-test',
    './patcher-test',
    './list-test',
    './text-test',
    './attr-test',
    './attrs-test'
], function (require, exports, module) {
    require('./html-test');
    require('./patcher-test');
    require('./list-test');
    require('./text-test');
    require('./attr-test');
    require('./attrs-test');
});
/*can-view-model@4.0.0#can-view-model_test*/
define('can-view-model@4.0.0#can-view-model_test', [
    'require',
    'exports',
    'module',
    'steal-qunit',
    'can-view-model',
    'can-simple-map'
], function (require, exports, module) {
    var QUnit = require('steal-qunit');
    var viewModel = require('can-view-model');
    var SimpleMap = require('can-simple-map');
    QUnit.module('can-view-model');
    QUnit.test('basics', function () {
        var el = document.createElement('div');
        viewModel(el, 'foo', 'bar');
        QUnit.equal(viewModel(el, 'foo'), 'bar');
        QUnit.ok(viewModel(el) instanceof SimpleMap, 'is SimpleMap');
    });
    QUnit.test('a selector can be passed as the first argument (#6)', function () {
        var el = document.createElement('div');
        el.className = 'the-el';
        document.getElementById('qunit-fixture').appendChild(el);
        viewModel('.the-el', 'foo', 'bar');
        QUnit.equal(viewModel('.the-el', 'foo'), 'bar');
        QUnit.ok(viewModel(el) instanceof SimpleMap, 'is can-map');
    });
    QUnit.test('set custom can-simple-map on element (#5)', function () {
        var vm, elVm;
        var CustomMap = SimpleMap.extend({});
        var el = document.createElement('div');
        document.getElementById('qunit-fixture').appendChild(el);
        vm = new CustomMap({ foo: 'bar' });
        elVm = viewModel(el, vm);
        QUnit.equal(viewModel(el, 'foo'), 'bar');
    });
    QUnit.test('Allow passing array like (jQuery) element', function () {
        var $el = {};
        var el = document.createElement('div');
        el.className = 'the-el';
        $el[0] = el;
        $el.length = 1;
        document.getElementById('qunit-fixture').appendChild(el);
        viewModel($el, 'foo', 'bar');
        QUnit.equal(viewModel('.the-el', 'foo'), 'bar', 'It reads view scope from html element');
        QUnit.equal(viewModel($el, 'foo'), 'bar', 'It reads view scope from array like (jQuery) element');
        QUnit.ok(viewModel(el) instanceof SimpleMap, 'is can-map');
    });
    QUnit.test('elements with length property not treated as arraylikes (#31)', function () {
        var el = document.createElement('select');
        document.getElementById('qunit-fixture').appendChild(el);
        QUnit.equal(el.length, 0, 'Select has length property (0 for empty)');
        QUnit.deepEqual(viewModel(el).get(), {}, 'viewModel created on empty select');
        var opt = document.createElement('option');
        el.appendChild(opt);
        QUnit.equal(el.length, 1, 'Select has length 1');
        QUnit.deepEqual(viewModel(el).get(), {}, 'viewModel created on non-empty select');
    });
});
/*can-view-model@4.0.0#test/test*/
define('can-view-model@4.0.0#test/test', [
    'require',
    'exports',
    'module',
    '../can-view-model_test'
], function (require, exports, module) {
    require('../can-view-model_test');
});
/*can-view-nodelist@4.0.1#test/can-view-nodelist-test*/
define('can-view-nodelist@4.0.1#test/can-view-nodelist-test', [
    'require',
    'exports',
    'module',
    'can-view-nodelist',
    'can-util/dom/fragment/fragment',
    'can-util/js/make-array/make-array',
    'can-util/dom/frag/frag',
    'steal-qunit'
], function (require, exports, module) {
    var nodeLists = require('can-view-nodelist');
    var fragment = require('can-util/dom/fragment/fragment');
    var makeArray = require('can-util/js/make-array/make-array');
    var frag = require('can-util/dom/frag/frag');
    var QUnit = require('steal-qunit');
    QUnit.module('can-view-nodelist');
    test('unregisters child nodeLists', function () {
        expect(3);
        var spansFrag = fragment('<span>1</span><span>2</span>');
        var spansList = makeArray(spansFrag.childNodes);
        nodeLists.register(spansList, function () {
            ok(true, 'unregistered spansList');
        });
        var labelFrag = fragment('<label>l</label>');
        var labelList = makeArray(labelFrag.childNodes);
        nodeLists.register(labelList, function () {
            ok(true, 'unregistered labelList');
        });
        var ifPreHookupFrag = frag([
                '~',
                '',
                '-',
                ''
            ]), ifChildNodes = ifPreHookupFrag.childNodes, ifEls = makeArray(ifChildNodes);
        nodeLists.replace([ifChildNodes[1]], spansFrag);
        nodeLists.replace([ifChildNodes[4]], labelFrag);
        var ifList = makeArray(ifPreHookupFrag.childNodes);
        nodeLists.register(ifList, function () {
            ok(true, 'unregistered ifList');
        });
        deepEqual(ifList, [
            ifEls[0],
            spansList,
            ifEls[2],
            labelList
        ]);
        nodeLists.update(ifList, [document.createTextNode('empty')]);
    });
});
/*can-view-parser@4.0.1#test/can-view-parser-test*/
define('can-view-parser@4.0.1#test/can-view-parser-test', [
    'require',
    'exports',
    'module',
    'can-view-parser',
    'steal-qunit',
    'can-log/dev/dev',
    'can-attribute-encoder',
    'can-test-helpers'
], function (require, exports, module) {
    var parser = require('can-view-parser');
    var QUnit = require('steal-qunit');
    var canDev = require('can-log/dev/dev');
    var encoder = require('can-attribute-encoder');
    var testHelpers = require('can-test-helpers');
    QUnit.module('can-view-parser');
    var makeChecks = function (tests) {
        var count = 0;
        var makeCheck = function (name) {
            return function () {
                if (count >= tests.length) {
                    ok(false, 'called ' + name + ' with ' + JSON.stringify([].slice.call(arguments)));
                } else {
                    var test = tests[count], args = test[1];
                    equal(name, test[0], 'test ' + count + ' ' + name + '(');
                    for (var i = 0; i < args.length; i++) {
                        equal(arguments[i], args[i], i + 1 + ' arg -> ' + args[i]);
                    }
                    count++;
                }
            };
        };
        return {
            start: makeCheck('start'),
            end: makeCheck('end'),
            close: makeCheck('close'),
            attrStart: makeCheck('attrStart'),
            attrEnd: makeCheck('attrEnd'),
            attrValue: makeCheck('attrValue'),
            chars: makeCheck('chars'),
            comment: makeCheck('comment'),
            special: makeCheck('special'),
            done: makeCheck('done')
        };
    };
    test('html to html', function () {
        var tests = [
            [
                'start',
                [
                    'h1',
                    false
                ]
            ],
            [
                'attrStart',
                ['id']
            ],
            [
                'attrValue',
                ['foo']
            ],
            [
                'attrEnd',
                ['id']
            ],
            [
                'special',
                ['#if']
            ],
            [
                'special',
                ['.']
            ],
            [
                'special',
                ['/if']
            ],
            [
                'attrStart',
                ['class']
            ],
            [
                'attrValue',
                ['a']
            ],
            [
                'special',
                ['foo']
            ],
            [
                'attrEnd',
                ['class']
            ],
            [
                'end',
                [
                    'h1',
                    false
                ]
            ],
            [
                'chars',
                ['Hello ']
            ],
            [
                'special',
                ['message']
            ],
            [
                'chars',
                ['!']
            ],
            [
                'close',
                ['h1']
            ],
            [
                'done',
                []
            ]
        ];
        parser('<h1 id=\'foo\' {{#if}}{{.}}{{/if}} class=\'a{{foo}}\'>Hello {{message}}!</h1>', makeChecks(tests));
    });
    test('uppercase html to html', function () {
        var tests = [
            [
                'start',
                [
                    'div',
                    false
                ]
            ],
            [
                'end',
                [
                    'div',
                    false
                ]
            ],
            [
                'chars',
                ['sibling']
            ],
            [
                'close',
                ['div']
            ],
            [
                'start',
                [
                    'div',
                    false
                ]
            ],
            [
                'end',
                [
                    'div',
                    false
                ]
            ],
            [
                'chars',
                ['sibling']
            ],
            [
                'close',
                ['div']
            ],
            [
                'done',
                []
            ]
        ];
        parser('<DIV>sibling</DIV><DIV>sibling</DIV>', makeChecks(tests));
    });
    test('camelCase attributes stay untouched (svg) - #22', function () {
        var tests = [
            [
                'start',
                [
                    'svg',
                    false
                ]
            ],
            [
                'attrStart',
                ['viewBox']
            ],
            [
                'attrValue',
                ['0 0 15 22']
            ],
            [
                'attrEnd',
                ['viewBox']
            ],
            [
                'end',
                [
                    'svg',
                    false
                ]
            ],
            [
                'close',
                ['svg']
            ],
            [
                'done',
                []
            ]
        ];
        parser('<svg viewBox="0 0 15 22"></svg>', makeChecks(tests));
    });
    test('camelCase tags stay untouched (svg)', function () {
        var tests = [
            [
                'start',
                [
                    'svg',
                    false
                ]
            ],
            [
                'end',
                [
                    'svg',
                    false
                ]
            ],
            [
                'start',
                [
                    'radialGradient',
                    false
                ]
            ],
            [
                'end',
                [
                    'radialGradient',
                    false
                ]
            ],
            [
                'close',
                ['radialGradient']
            ],
            [
                'close',
                ['svg']
            ],
            [
                'done',
                []
            ]
        ];
        parser('<svg><radialGradient></radialGradient></svg>', makeChecks(tests));
    });
    test('special in an attribute in an in-tag section', function () {
        parser('<div {{#truthy}}foo=\'{{baz}}\'{{/truthy}}></div>', makeChecks([
            [
                'start',
                [
                    'div',
                    false
                ]
            ],
            [
                'special',
                ['#truthy']
            ],
            [
                'attrStart',
                ['foo']
            ],
            [
                'special',
                ['baz']
            ],
            [
                'attrEnd',
                ['foo']
            ],
            [
                'special',
                ['/truthy']
            ],
            [
                'end',
                [
                    'div',
                    false
                ]
            ],
            [
                'close',
                ['div']
            ],
            [
                'done',
                []
            ]
        ]));
    });
    test('special with a custom attribute', function () {
        parser('<div {{#attribute}} {{name}}="{{value}}" {{/attribute}}></div>', makeChecks([
            [
                'start',
                [
                    'div',
                    false
                ]
            ],
            [
                'special',
                ['#attribute']
            ],
            [
                'special',
                ['name']
            ],
            [
                'attrStart',
                ['']
            ],
            [
                'special',
                ['value']
            ],
            [
                'attrEnd',
                ['']
            ],
            [
                'special',
                ['/attribute']
            ],
            [
                'end',
                [
                    'div',
                    false
                ]
            ],
            [
                'close',
                ['div']
            ],
            [
                'done',
                []
            ]
        ]));
    });
    test('single attribute value', function () {
        parser('<input DISABLED/>', makeChecks([
            [
                'start',
                [
                    'input',
                    true
                ]
            ],
            [
                'attrStart',
                ['DISABLED']
            ],
            [
                'attrEnd',
                ['DISABLED']
            ],
            [
                'end',
                [
                    'input',
                    true
                ]
            ],
            [
                'done',
                []
            ]
        ]));
    });
    test('trailing linebreaks in IE', function () {
        parser('12345{{!\n  This is a\n  multi-line comment...\n}}67890\n', makeChecks([
            [
                'chars',
                ['12345']
            ],
            [
                'special',
                ['!\n  This is a\n  multi-line comment...\n']
            ],
            [
                'chars',
                ['67890\n']
            ],
            [
                'done',
                []
            ]
        ]));
    });
    test('block are allowed inside anchor tags', function () {
        parser('<a><div></div></a>', makeChecks([
            [
                'start',
                [
                    'a',
                    false
                ]
            ],
            [
                'end',
                [
                    'a',
                    false
                ]
            ],
            [
                'start',
                [
                    'div',
                    false
                ]
            ],
            [
                'end',
                [
                    'div',
                    false
                ]
            ],
            [
                'close',
                ['div']
            ],
            [
                'close',
                ['a']
            ],
            [
                'done',
                []
            ]
        ]));
    });
    test('anchors are allowed as children of inline elements - #2169', function () {
        parser('<span><a></a></span>', makeChecks([
            [
                'start',
                [
                    'span',
                    false
                ]
            ],
            [
                'end',
                [
                    'span',
                    false
                ]
            ],
            [
                'start',
                [
                    'a',
                    false
                ]
            ],
            [
                'end',
                [
                    'a',
                    false
                ]
            ],
            [
                'close',
                ['a']
            ],
            [
                'close',
                ['span']
            ],
            [
                'done',
                []
            ]
        ]));
    });
    test('inline tags encapsulate inner block elements', function () {
        parser('<span><div></div></span>', makeChecks([
            [
                'start',
                [
                    'span',
                    false
                ]
            ],
            [
                'end',
                [
                    'span',
                    false
                ]
            ],
            [
                'start',
                [
                    'div',
                    false
                ]
            ],
            [
                'end',
                [
                    'div',
                    false
                ]
            ],
            [
                'close',
                ['div']
            ],
            [
                'close',
                ['span']
            ],
            [
                'done',
                []
            ]
        ]));
        parser('<em><h1></h1></em>', makeChecks([
            [
                'start',
                [
                    'em',
                    false
                ]
            ],
            [
                'end',
                [
                    'em',
                    false
                ]
            ],
            [
                'start',
                [
                    'h1',
                    false
                ]
            ],
            [
                'end',
                [
                    'h1',
                    false
                ]
            ],
            [
                'close',
                ['h1']
            ],
            [
                'close',
                ['em']
            ],
            [
                'done',
                []
            ]
        ]));
    });
    test('unordered lists will contain their list items', function () {
        parser('<ul><li></li><li></li></ul>', makeChecks([
            [
                'start',
                [
                    'ul',
                    false
                ]
            ],
            [
                'end',
                [
                    'ul',
                    false
                ]
            ],
            [
                'start',
                [
                    'li',
                    false
                ]
            ],
            [
                'end',
                [
                    'li',
                    false
                ]
            ],
            [
                'close',
                ['li']
            ],
            [
                'start',
                [
                    'li',
                    false
                ]
            ],
            [
                'end',
                [
                    'li',
                    false
                ]
            ],
            [
                'close',
                ['li']
            ],
            [
                'close',
                ['ul']
            ],
            [
                'done',
                []
            ]
        ]));
    });
    test('supports single character attributes (#1132)', function () {
        parser('<circle r="25"></circle>', makeChecks([
            [
                'start',
                [
                    'circle',
                    false
                ]
            ],
            [
                'attrStart',
                ['r']
            ],
            [
                'attrValue',
                ['25']
            ],
            [
                'attrEnd',
                ['r']
            ],
            [
                'end',
                [
                    'circle',
                    false
                ]
            ],
            [
                'close',
                ['circle']
            ],
            [
                'done',
                []
            ]
        ]));
    });
    test('accept custom tag with colon ":" #1108', function () {
        parser('<x:widget/>', makeChecks([
            [
                'start',
                [
                    'x:widget',
                    true
                ]
            ],
            [
                'end',
                [
                    'x:widget',
                    true
                ]
            ],
            [
                'done',
                []
            ]
        ]));
    });
    test('output json', function () {
        var tests = [
            [
                'start',
                [
                    'h1',
                    false
                ]
            ],
            [
                'attrStart',
                ['id']
            ],
            [
                'attrValue',
                ['foo']
            ],
            [
                'attrEnd',
                ['id']
            ],
            [
                'special',
                ['#if']
            ],
            [
                'special',
                ['.']
            ],
            [
                'special',
                ['/if']
            ],
            [
                'attrStart',
                ['class']
            ],
            [
                'attrValue',
                ['a']
            ],
            [
                'special',
                ['foo']
            ],
            [
                'attrEnd',
                ['class']
            ],
            [
                'end',
                [
                    'h1',
                    false
                ]
            ],
            [
                'chars',
                ['Hello ']
            ],
            [
                'special',
                ['message']
            ],
            [
                'chars',
                ['!']
            ],
            [
                'close',
                ['h1']
            ],
            [
                'done',
                []
            ]
        ];
        var intermediate = parser('<h1 id=\'foo\' {{#if}}{{.}}{{/if}} class=\'a{{foo}}\'>Hello {{message}}!</h1>', makeChecks(tests), true);
        parser(intermediate, makeChecks(tests));
    });
    test('less than outside of an element', function () {
        var tests = [
            [
                'start',
                [
                    'h1',
                    false
                ]
            ],
            [
                'end',
                [
                    'h1',
                    false
                ]
            ],
            [
                'chars',
                [' < ']
            ],
            [
                'close',
                ['h1']
            ],
            [
                'done',
                []
            ]
        ];
        var intermediate = parser('<h1> < </h1>', makeChecks(tests), true);
        parser(intermediate, makeChecks(tests));
    });
    test('allow () and [] to enclose attributes', function () {
        parser('<p [click]="test"></p>', makeChecks([
            [
                'start',
                [
                    'p',
                    false
                ]
            ],
            [
                'attrStart',
                ['[click]']
            ],
            [
                'attrValue',
                ['test']
            ],
            [
                'attrEnd',
                ['[click]']
            ],
            [
                'end',
                ['p']
            ],
            [
                'close',
                ['p']
            ],
            [
                'done',
                []
            ]
        ]));
        parser('<p (click)="test"></p>', makeChecks([
            [
                'start',
                [
                    'p',
                    false
                ]
            ],
            [
                'attrStart',
                [encoder.encode('(click)')]
            ],
            [
                'attrValue',
                ['test']
            ],
            [
                'attrEnd',
                [encoder.encode('(click)')]
            ],
            [
                'end',
                ['p']
            ],
            [
                'close',
                ['p']
            ],
            [
                'done',
                []
            ]
        ]));
        parser('<p (click-me)="test"></p>', makeChecks([
            [
                'start',
                [
                    'p',
                    false
                ]
            ],
            [
                'attrStart',
                [encoder.encode('(click-me)')]
            ],
            [
                'attrValue',
                ['test']
            ],
            [
                'attrEnd',
                [encoder.encode('(click-me)')]
            ],
            [
                'end',
                ['p']
            ],
            [
                'close',
                ['p']
            ],
            [
                'done',
                []
            ]
        ]));
        parser('<p (click_me)="test"></p>', makeChecks([
            [
                'start',
                [
                    'p',
                    false
                ]
            ],
            [
                'attrStart',
                [encoder.encode('(click_me)')]
            ],
            [
                'attrValue',
                ['test']
            ],
            [
                'attrEnd',
                [encoder.encode('(click_me)')]
            ],
            [
                'end',
                ['p']
            ],
            [
                'close',
                ['p']
            ],
            [
                'done',
                []
            ]
        ]));
    });
    test('allow {} to enclose attributes', function () {
        parser.parseAttrs('{a}="b" {{#c}}d{{/c}}', makeChecks([
            [
                'attrStart',
                [encoder.encode('{a}')]
            ],
            [
                'attrValue',
                ['b']
            ],
            [
                'attrEnd',
                [encoder.encode('{a}')]
            ],
            [
                'special',
                ['#c']
            ],
            [
                'attrStart',
                ['d']
            ],
            [
                'attrEnd',
                ['d']
            ],
            [
                'special',
                ['/c']
            ]
        ]));
    });
    test('tripple curly in attrs', function () {
        parser.parseAttrs('items="{{{ completed }}}"', makeChecks([
            [
                'attrStart',
                ['items']
            ],
            [
                'special',
                ['{ completed ']
            ],
            [
                'attrEnd',
                ['items']
            ]
        ]));
    });
    test('something', function () {
        parser.parseAttrs('c d=\'e\'', makeChecks([
            [
                'attrStart',
                ['c']
            ],
            [
                'attrEnd',
                ['c']
            ],
            [
                'attrStart',
                ['d']
            ],
            [
                'attrValue',
                ['e']
            ],
            [
                'attrEnd',
                ['d']
            ]
        ]));
    });
    test('references', function () {
        parser('<year-selector *y />', makeChecks([
            [
                'start',
                [
                    'year-selector',
                    true
                ]
            ],
            [
                'attrStart',
                ['*y']
            ],
            [
                'attrEnd',
                ['*y']
            ],
            [
                'end',
                ['year-selector']
            ],
            [
                'done',
                []
            ]
        ]));
    });
    test('quotes around attributes and other lazy attribute writing (#2097)', function () {
        parser('<c-d a={z}/>', makeChecks([
            [
                'start',
                [
                    'c-d',
                    true
                ]
            ],
            [
                'attrStart',
                ['a']
            ],
            [
                'attrValue',
                ['{z}']
            ],
            [
                'attrEnd',
                ['a']
            ],
            [
                'end',
                ['c-d']
            ],
            [
                'done',
                []
            ]
        ]));
        parser('<span v={{.}}/>', makeChecks([
            [
                'start',
                [
                    'span',
                    true
                ]
            ],
            [
                'attrStart',
                ['v']
            ],
            [
                'special',
                ['.']
            ],
            [
                'attrEnd',
                ['v']
            ],
            [
                'end',
                ['span']
            ],
            [
                'done',
                []
            ]
        ]));
        parser('<div {{^f}} d {{/f}}/>', makeChecks([
            [
                'start',
                [
                    'div',
                    true
                ]
            ],
            [
                'special',
                ['^f']
            ],
            [
                'attrStart',
                ['d']
            ],
            [
                'attrEnd',
                ['d']
            ],
            [
                'special',
                ['/f']
            ],
            [
                'end',
                ['div']
            ],
            [
                'done',
                []
            ]
        ]));
    });
    test('camelCased attributes are converted to spinal-case', function () {
        parser.parseAttrs('({camelCase})=\'assigned\'', makeChecks([
            [
                'attrStart',
                [encoder.encode('({camelCase})')]
            ],
            [
                'attrValue',
                ['assigned']
            ],
            [
                'attrEnd',
                [encoder.encode('({camelCase})')]
            ]
        ]));
    });
    test('elements that have attributes with equal signs and no values are handled appropriately (#17)', function () {
        parser('<input class=\'toggle\' type=\'checkbox\' {($checked)}=\'complete\' ($change)=>', makeChecks([
            [
                'start',
                [
                    'input',
                    true
                ]
            ],
            [
                'attrStart',
                ['class']
            ],
            [
                'attrValue',
                ['toggle']
            ],
            [
                'attrEnd',
                ['class']
            ],
            [
                'attrStart',
                ['type']
            ],
            [
                'attrValue',
                ['checkbox']
            ],
            [
                'attrEnd',
                ['type']
            ],
            [
                'attrStart',
                [encoder.encode('{($checked)}')]
            ],
            [
                'attrValue',
                ['complete']
            ],
            [
                'attrEnd',
                [encoder.encode('{($checked)}')]
            ],
            [
                'attrStart',
                [encoder.encode('($change)')]
            ],
            [
                'attrEnd',
                [encoder.encode('($change)')]
            ],
            [
                'end',
                ['input']
            ],
            [
                'done',
                []
            ]
        ]));
    });
    test('{{}} in attribute values are handled correctly (#34)', function () {
        var tests = [
            [
                'start',
                [
                    'h1',
                    false
                ]
            ],
            [
                'attrStart',
                ['class']
            ],
            [
                'special',
                ['foo']
            ],
            [
                'attrValue',
                ['a']
            ],
            [
                'attrEnd',
                ['class']
            ],
            [
                'end',
                [
                    'h1',
                    false
                ]
            ],
            [
                'close',
                ['h1']
            ],
            [
                'done',
                []
            ]
        ];
        parser('<h1 class=\'{{foo}}a\'></h1>', makeChecks(tests));
    });
    test('> in attribute values are handled correctly', function () {
        parser('<h1 data-content="<b>foo</b>">bar</h1>', makeChecks([
            [
                'start',
                [
                    'h1',
                    false
                ]
            ],
            [
                'attrStart',
                ['data-content']
            ],
            [
                'attrValue',
                ['<b>foo</b>']
            ],
            [
                'attrEnd',
                ['data-content']
            ],
            [
                'end',
                [
                    'h1',
                    false
                ]
            ],
            [
                'chars',
                ['bar']
            ],
            [
                'close',
                ['h1']
            ],
            [
                'done',
                []
            ]
        ]));
        parser('<h1 data-nothing="" data-something="something" data-content="<b>foo</b>" data-something-after="something-after">bar</h1>', makeChecks([
            [
                'start',
                [
                    'h1',
                    false
                ]
            ],
            [
                'attrStart',
                ['data-nothing']
            ],
            [
                'attrEnd',
                ['data-nothing']
            ],
            [
                'attrStart',
                ['data-something']
            ],
            [
                'attrValue',
                ['something']
            ],
            [
                'attrEnd',
                ['data-something']
            ],
            [
                'attrStart',
                ['data-content']
            ],
            [
                'attrValue',
                ['<b>foo</b>']
            ],
            [
                'attrEnd',
                ['data-content']
            ],
            [
                'attrStart',
                ['data-something-after']
            ],
            [
                'attrValue',
                ['something-after']
            ],
            [
                'attrEnd',
                ['data-something-after']
            ],
            [
                'end',
                [
                    'h1',
                    false
                ]
            ],
            [
                'chars',
                ['bar']
            ],
            [
                'close',
                ['h1']
            ],
            [
                'done',
                []
            ]
        ]));
        parser('<h1 data-first="<b>foo</b>" \n data-second="><>>>>><foo>>>/>> \n />"  \n >\nbar</h1>', makeChecks([
            [
                'start',
                [
                    'h1',
                    false
                ]
            ],
            [
                'attrStart',
                ['data-first']
            ],
            [
                'attrValue',
                ['<b>foo</b>']
            ],
            [
                'attrEnd',
                ['data-first']
            ],
            [
                'attrStart',
                ['data-second']
            ],
            [
                'attrValue',
                ['><>>>>><foo>>>/>> \n />']
            ],
            [
                'attrEnd',
                ['data-second']
            ],
            [
                'end',
                [
                    'h1',
                    false
                ]
            ],
            [
                'chars',
                ['\nbar']
            ],
            [
                'close',
                ['h1']
            ],
            [
                'done',
                []
            ]
        ]));
    });
    test('tags with data attributes are allowed in comments (#2)', function () {
        parser('{{! foo }}', makeChecks([
            [
                'special',
                ['! foo ']
            ],
            [
                'done',
                []
            ]
        ]));
        parser('{{! <foo /> }}', makeChecks([
            [
                'special',
                ['! <foo /> ']
            ],
            [
                'done',
                []
            ]
        ]));
        parser('{{! <foo bar="{bam}" /> }}', makeChecks([
            [
                'special',
                ['! <foo bar="{bam}" /> ']
            ],
            [
                'done',
                []
            ]
        ]));
    });
    test('multiline special comments (#14)', function () {
        parser('{{! foo !}}', makeChecks([
            [
                'special',
                ['! foo !']
            ],
            [
                'done',
                []
            ]
        ]));
        parser('{{! {{foo}} {{bar}} !}}', makeChecks([
            [
                'special',
                ['! {{foo}} {{bar}} !']
            ],
            [
                'done',
                []
            ]
        ]));
        parser('{{!\n{{foo}}\n{{bar}}\n!}}', makeChecks([
            [
                'special',
                ['!\n{{foo}}\n{{bar}}\n!']
            ],
            [
                'done',
                []
            ]
        ]));
    });
    test('spaces in attribute names that start with `{` or `(` are encoded (#48)', function () {
        var tests = [
            [
                'start',
                [
                    'h1',
                    false
                ]
            ],
            [
                'attrStart',
                [encoder.encode('{foo bar}')]
            ],
            [
                'attrValue',
                ['a']
            ],
            [
                'attrEnd',
                [encoder.encode('{foo bar}')]
            ],
            [
                'end',
                [
                    'h1',
                    false
                ]
            ],
            [
                'close',
                ['h1']
            ],
            [
                'done',
                []
            ]
        ];
        parser('<h1 {foo bar}=\'a\'></h1>', makeChecks(tests));
    });
    test('for attributes without values, spaces in attribute names that start with `{` or `(` are encoded (#48)', function () {
        var tests = [
            [
                'start',
                [
                    'h1',
                    false
                ]
            ],
            [
                'attrStart',
                [encoder.encode('{foo }')]
            ],
            [
                'attrEnd',
                [encoder.encode('{foo }')]
            ],
            [
                'attrStart',
                [encoder.encode('{bar }')]
            ],
            [
                'attrEnd',
                [encoder.encode('{bar }')]
            ],
            [
                'end',
                [
                    'h1',
                    false
                ]
            ],
            [
                'close',
                ['h1']
            ],
            [
                'done',
                []
            ]
        ];
        parser('<h1 {foo } {bar }></h1>', makeChecks(tests));
    });
    test('mismatched brackets work: {(foo})', function () {
        var tests = [
            [
                'start',
                [
                    'h1',
                    false
                ]
            ],
            [
                'attrStart',
                [encoder.encode('{(foo})')]
            ],
            [
                'attrValue',
                ['a']
            ],
            [
                'attrEnd',
                [encoder.encode('{(foo})')]
            ],
            [
                'end',
                [
                    'h1',
                    false
                ]
            ],
            [
                'close',
                ['h1']
            ],
            [
                'done',
                []
            ]
        ];
        parser('<h1 {(foo})=\'a\'></h1>', makeChecks(tests));
    });
    test('mismatched brackets work: ({foo)}', function () {
        var tests = [
            [
                'start',
                [
                    'h1',
                    false
                ]
            ],
            [
                'attrStart',
                [encoder.encode('({foo)}')]
            ],
            [
                'attrValue',
                ['a']
            ],
            [
                'attrEnd',
                [encoder.encode('({foo)}')]
            ],
            [
                'end',
                [
                    'h1',
                    false
                ]
            ],
            [
                'close',
                ['h1']
            ],
            [
                'done',
                []
            ]
        ];
        parser('<h1 ({foo)}=\'a\'></h1>', makeChecks(tests));
    });
    test('forward slashes are encoded (#52)', function () {
        var tests = [
            [
                'start',
                [
                    'h1',
                    false
                ]
            ],
            [
                'attrStart',
                [encoder.encode('{foo/bar}')]
            ],
            [
                'attrValue',
                ['a']
            ],
            [
                'attrEnd',
                [encoder.encode('{foo/bar}')]
            ],
            [
                'end',
                [
                    'h1',
                    false
                ]
            ],
            [
                'close',
                ['h1']
            ],
            [
                'done',
                []
            ]
        ];
        parser('<h1 {foo/bar}=\'a\'></h1>', makeChecks(tests));
    });
    test('camelCase properties are encoded with on:, :to, :from, :bind bindings', function () {
        var tests = [
            [
                'start',
                [
                    'h1',
                    false
                ]
            ],
            [
                'attrStart',
                [encoder.encode('on:aB')]
            ],
            [
                'attrValue',
                ['c']
            ],
            [
                'attrEnd',
                [encoder.encode('on:aB')]
            ],
            [
                'attrStart',
                [encoder.encode('dE:to')]
            ],
            [
                'attrValue',
                ['f']
            ],
            [
                'attrEnd',
                [encoder.encode('dE:to')]
            ],
            [
                'attrStart',
                [encoder.encode('gH:from')]
            ],
            [
                'attrValue',
                ['i']
            ],
            [
                'attrEnd',
                [encoder.encode('gH:from')]
            ],
            [
                'attrStart',
                [encoder.encode('jK:bind')]
            ],
            [
                'attrValue',
                ['l']
            ],
            [
                'attrEnd',
                [encoder.encode('jK:bind')]
            ],
            [
                'end',
                [
                    'h1',
                    false
                ]
            ],
            [
                'close',
                ['h1']
            ],
            [
                'done',
                []
            ]
        ];
        parser('<h1 on:aB=\'c\' dE:to=\'f\' gH:from=\'i\' jK:bind=\'l\'></h1>', makeChecks(tests));
    });
    testHelpers.dev.devOnlyTest('Warn on missing attribute value end quotes (canjs/can-view-parser#7)', function () {
        var makeWarnChecks = function (input, texts) {
            var count = 0;
            var teardown = testHelpers.dev.willWarn(/End quote is missing for/, function (message, matched) {
                ok(matched, texts[count++]);
            });
            parser(input, {
                start: function (tagName, unary) {
                },
                end: function (tagName, unary) {
                },
                attrStart: function (attrName) {
                },
                attrEnd: function (attrName) {
                },
                attrValue: function (val) {
                },
                done: function () {
                }
            });
            equal(count, teardown());
        };
        makeWarnChecks('<my-input {value}="name" (value)="updateNameOnEven(%viewModel.value)/>', ['1: End quote is missing for updateNameOnEven(%viewModel.value)']);
        makeWarnChecks('<input on:click="callback />', ['1: End quote is missing for callback']);
        makeWarnChecks('<my-input {an-attr}="aValue />', ['1: End quote is missing for aValue']);
        makeWarnChecks('<my-input {an-other-attr}=\'anotherValue />', ['1: End quote is missing for anotherValue']);
    });
    testHelpers.dev.devOnlyTest('Fix false warning on missing closed quote (canjs/can-view-parser#7#issuecomment-336468766)', function () {
        var makeWarnChecks = function (input, texts) {
            var count = 0;
            var teardown = testHelpers.dev.willWarn(/End quote is missing for/, function (message, matched) {
                notOk(matched, texts[count++]);
            });
            parser(input, {
                start: function (tagName, unary) {
                },
                end: function (tagName, unary) {
                },
                attrStart: function (attrName) {
                },
                attrEnd: function (attrName) {
                },
                attrValue: function (val) {
                },
                done: function () {
                },
                special: function () {
                    return [
                        '#if',
                        '/if'
                    ];
                }
            });
            equal(count, teardown());
        };
        var truthy = true;
        makeWarnChecks('<div {{#if truthy}} class="current-page"{{/if}} />', ['1: End quote is missing for current-page']);
        makeWarnChecks('<div class="current-page"($click)="" />', ['1: End quote is missing for current-page']);
        makeWarnChecks('<input type="text">', ['1: End quote is missing for current-page']);
    });
});
/*can-view-scope@4.0.1#test/scope-test*/
define('can-view-scope@4.0.1#test/scope-test', [
    'require',
    'exports',
    'module',
    'can-view-scope',
    'can-stache-key',
    '../template-context',
    'can-symbol',
    'steal-qunit',
    'can-reflect',
    'can-observation',
    'can-test-helpers',
    'can-simple-map',
    'can-simple-observable',
    'can-observation-recorder',
    'can-reflect-dependencies',
    'can-stache-helpers'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        var Scope = require('can-view-scope');
        var observeReader = require('can-stache-key');
        var TemplateContext = require('../template-context');
        var canSymbol = require('can-symbol');
        var QUnit = require('steal-qunit');
        var canReflect = require('can-reflect');
        var Observation = require('can-observation');
        var testHelpers = require('can-test-helpers');
        var SimpleMap = require('can-simple-map');
        var SimpleObservable = require('can-simple-observable');
        var ObservationRecorder = require('can-observation-recorder');
        var canReflectDeps = require('can-reflect-dependencies');
        var canStacheHelpers = require('can-stache-helpers');
        QUnit.module('can/view/scope');
        test('basics', function () {
            var address = new SimpleMap({ zip: 60647 });
            var person = new SimpleMap({
                name: 'Justin',
                address: address
            });
            var items = new SimpleMap({
                people: person,
                count: 1000
            });
            var itemsScope = new Scope(items), personScope = new Scope(person, itemsScope), zipScope = new Scope(address, personScope);
            var nameInfo;
            var c = new Observation(function () {
                nameInfo = zipScope.read('../name');
            });
            canReflect.onValue(c, function () {
            });
            deepEqual(nameInfo.reads, [{
                    key: 'name',
                    at: false
                }], 'reads');
            equal(nameInfo.scope, personScope, 'scope');
            equal(nameInfo.value, 'Justin', 'value');
            equal(nameInfo.rootObserve, person, 'rootObserve');
        });
        test('Scope.prototype.computeData', function () {
            var map = new SimpleMap();
            var base = new Scope(map);
            var computeData = base.computeData('age');
            equal(computeData.observation, computeData.options.observation, 'ScopeKeyData should have a backing observation stored on its `options`');
            var age = computeData.compute;
            equal(age(), undefined, 'age is not set');
            age.bind('change', function (ev, newVal, oldVal) {
                equal(newVal, 31, 'newVal is provided correctly');
                equal(oldVal, undefined, 'oldVal is undefined');
            });
            age(31);
            equal(map.attr('age'), 31, 'maps age is set correctly');
        });
        test('backtrack path (#163)', function () {
            var row = new SimpleMap({ first: 'Justin' }), col = { format: 'str' }, base = new Scope(row), cur = base.add(col);
            equal(cur.peek('.'), col, 'got col');
            equal(cur.peek('..'), row, 'got row');
            equal(cur.peek('../first'), 'Justin', 'got row');
        });
        test('nested properties with compute', function () {
            var me = new SimpleMap({ name: new SimpleMap({ first: 'Justin' }) });
            var cur = new Scope(me);
            var compute = cur.computeData('name.first').compute;
            var changes = 0;
            var handler = function (ev, newVal, oldVal) {
                if (changes === 0) {
                    equal(oldVal, 'Justin');
                    equal(newVal, 'Brian');
                } else if (changes === 1) {
                    equal(oldVal, 'Brian');
                    equal(newVal, undefined);
                } else if (changes === 2) {
                    equal(oldVal, undefined);
                    equal(newVal, 'Payal');
                } else if (changes === 3) {
                    equal(oldVal, 'Payal');
                    equal(newVal, 'Curtis');
                }
                changes++;
            };
            compute.bind('change', handler);
            equal(compute(), 'Justin', 'read value after bind');
            me.attr('name').attr('first', 'Brian');
            me.attr('name', undefined);
            me.attr('name', { first: 'Payal' });
            me.attr('name', new SimpleMap({ first: 'Curtis' }));
            compute.unbind('change', handler);
        });
        test('function at the end', function () {
            var compute = new Scope({
                me: {
                    info: function () {
                        return 'Justin';
                    }
                }
            }).computeData('me.info').compute;
            equal(compute()(), 'Justin');
            var fn = function () {
                return this.name;
            };
            var compute2 = new Scope({
                me: {
                    info: fn,
                    name: 'Hank'
                }
            }).computeData('me.info', {
                isArgument: true,
                args: []
            }).compute;
            equal(compute2()(), 'Hank');
        });
        test('binds to the right scope only', function () {
            var baseMap = new SimpleMap({ me: new SimpleMap({ name: new SimpleMap({ first: 'Justin' }) }) });
            var base = new Scope(baseMap);
            var topMap = new SimpleMap({ me: new SimpleMap({ name: new SimpleMap({}) }) });
            var scope = base.add(topMap);
            var compute = scope.computeData('../me.name.first').compute;
            compute.bind('change', function (ev, newVal, oldVal) {
                equal(oldVal, 'Justin');
                equal(newVal, 'Brian');
            });
            equal(compute(), 'Justin');
            topMap.attr('me').attr('name').attr('first', 'Payal');
            baseMap.attr('me').attr('name').attr('first', 'Brian');
        });
        test('Scope read returnObserveMethods=true', function () {
            var MapConstruct = SimpleMap.extend({
                foo: function (arg) {
                    equal(this, data.map, 'correct this');
                    equal(arg, true, 'correct arg');
                }
            });
            var data = { map: new MapConstruct() };
            var res = Scope.read(data, observeReader.reads('map.foo'), { isArgument: true });
            res.value(true);
        });
        test('rooted observable is able to update correctly', function () {
            var baseMap = new SimpleMap({ name: new SimpleMap({ first: 'Justin' }) });
            var scope = new Scope(baseMap);
            var compute = scope.computeData('name.first').compute;
            equal(compute(), 'Justin');
            baseMap.attr('name', new SimpleMap({ first: 'Brian' }));
            equal(compute(), 'Brian');
        });
        test('computeData reading an object with a compute', function () {
            var age = new SimpleObservable(21);
            var scope = new Scope({ person: { age: age } });
            var computeData = scope.computeData('person.age');
            var value = computeData.compute();
            equal(value, 21, 'correct value');
            computeData.compute(31);
            equal(age.get(), 31, 'age updated');
        });
        test('computeData with initial empty compute (#638)', function () {
            expect(2);
            var c = new SimpleObservable();
            var scope = new Scope({ compute: c });
            var computeData = scope.computeData('compute');
            equal(computeData.compute(), undefined);
            computeData.compute.bind('change', function (ev, newVal) {
                equal(newVal, 'compute value');
            });
            c.set('compute value');
        });
        test('Can read static properties on constructors (#634)', function () {
            var Foo = SimpleMap.extend({ static_prop: 'baz' }, { proto_prop: 'thud' });
            var data = new Foo({ own_prop: 'quux' }), scope = new Scope(data);
            equal(scope.computeData('constructor.static_prop').compute(), 'baz', 'static prop');
        });
        test('Can read static properties on constructors (#634)', function () {
            var Foo = SimpleMap.extend({ static_prop: 'baz' }, { proto_prop: 'thud' });
            var data = new Foo({ own_prop: 'quux' }), scope = new Scope(data);
            equal(scope.computeData('constructor.static_prop').compute(), 'baz', 'static prop');
        });
        test('Scope lookup restricted to current scope with ./ (#874)', function () {
            var current;
            var scope = new Scope(new SimpleMap({ value: 'A Value' })).add(current = new SimpleMap({}));
            var compute = scope.computeData('./value').compute;
            equal(compute(), undefined, 'no initial value');
            compute.bind('change', function (ev, newVal) {
                equal(newVal, 'B Value', 'changed');
            });
            compute('B Value');
            equal(current.attr('value'), 'B Value', 'updated');
        });
        test('reading properties on undefined (#1314)', function () {
            var scope = new Scope(undefined);
            var compute = scope.compute('property');
            equal(compute(), undefined, 'got back undefined');
        });
        test('Scope attributes can be set (#1297, #1304)', function () {
            var comp = new SimpleObservable('Test');
            var map = new SimpleMap({ other: new SimpleMap({ name: 'Justin' }) });
            var scope = new Scope({
                name: 'Matthew',
                other: {
                    person: { name: 'David' },
                    comp: comp
                }
            });
            scope.set('name', 'Wilbur');
            equal(scope.get('name'), 'Wilbur', 'Value updated');
            scope.set('other.person.name', 'Dave');
            equal(scope.get('other.person.name'), 'Dave', 'Value updated');
            scope.set('other.comp', 'Changed');
            equal(comp.get(), 'Changed', 'Compute updated');
            scope = new Scope(map);
            scope.set('other.name', 'Brian');
            equal(scope.get('other.name'), 'Brian', 'Value updated');
            equal(map.attr('other').attr('name'), 'Brian', 'Name update in map');
        });
        testHelpers.dev.devOnlyTest('Setting a value to an attribute with an undefined parent errors (canjs/can-stache-bindings#298)', function () {
            var teardown = testHelpers.dev.willError(/Attempting to set a value at (.+) where (.+) is undefined./);
            var scope = new Scope({});
            scope.set('person.name', 'Christopher');
            QUnit.equal(teardown(), 1, 'saw errors');
        });
        test('computeData.compute get/sets computes in maps', function () {
            var cmpt = new SimpleObservable(4);
            var map = new SimpleMap();
            map.attr('computer', cmpt);
            var scope = new Scope(map);
            var computeData = scope.computeData('computer', {});
            equal(computeData.compute(), 4, 'got the value');
            computeData.compute(5);
            equal(cmpt.get(), 5, 'updated compute value');
            equal(computeData.compute(), 5, 'the compute has the right value');
        });
        test('computesData can find update when initially undefined parent scope becomes defined (#579)', function () {
            expect(2);
            var map = new SimpleMap();
            var scope = new Scope(map);
            var top = scope.add(new SimpleMap());
            var computeData = top.computeData('../value', {});
            equal(computeData.compute(), undefined, 'initially undefined');
            computeData.compute.bind('change', function (ev, newVal) {
                equal(newVal, 'first');
            });
            map.attr('value', 'first');
        });
        test('can set scope attributes with ../ (#2132)', function () {
            var map = new SimpleMap();
            var scope = new Scope(map);
            var top = scope.add(new SimpleMap());
            top.set('../foo', 'bar');
            equal(map.attr('foo'), 'bar');
        });
        test('can read parent context with ../ (#2244)', function () {
            var map = new SimpleMap();
            var scope = new Scope(map);
            var top = scope.add(new SimpleMap());
            equal(top.peek('../'), map, 'looked up value correctly');
        });
        test('trying to read constructor from refs scope is ok', function () {
            var map = new TemplateContext();
            var construct = new Observation(function () {
                return map.constructor;
            });
            canReflect.onValue(construct, function () {
            });
            equal(canReflect.getValue(construct), TemplateContext);
        });
        test('reading from a string in a nested scope doesn\'t throw an error (#22)', function () {
            var foo = new SimpleObservable('foo');
            var bar = new SimpleObservable('bar');
            var scope = new Scope(foo);
            var localScope = scope.add(bar);
            equal(localScope.read('foo').value, undefined);
        });
        test('Optimize for compute().observableProperty (#29)', function () {
            var map = new SimpleMap({ value: 'a' });
            var wrap = new SimpleObservable(map);
            var scope = new Scope(wrap);
            var scopeKeyData = scope.computeData('value');
            var scopeCompute = scopeKeyData.compute;
            var changeNumber = 0;
            scopeCompute.on('change', function (ev, newVal, oldVal) {
                if (changeNumber === 1) {
                    QUnit.equal(newVal, 'b');
                    QUnit.equal(oldVal, 'a');
                    QUnit.ok(scopeKeyData.fastPath, 'still fast path');
                    changeNumber++;
                    wrap.set(new SimpleMap({ value: 'c' }));
                } else if (changeNumber === 2) {
                    QUnit.equal(newVal, 'c', 'got new value');
                    QUnit.equal(oldVal, 'b', 'got old value');
                    QUnit.notOk(scopeKeyData.fastPath, 'still fast path');
                }
            });
            QUnit.ok(scopeKeyData.fastPath, 'fast path');
            changeNumber++;
            map.attr('value', 'b');
        });
        test('a compute can observe the ScopeKeyData', 3, function () {
            var map = new SimpleMap({
                value: 'a',
                other: 'b'
            });
            var wrap = new SimpleObservable(map);
            var scope = new Scope(wrap);
            var scopeKeyData = scope.computeData('value');
            var oldOnValue = scopeKeyData[canSymbol.for('can.onValue')];
            scopeKeyData[canSymbol.for('can.onValue')] = function () {
                QUnit.ok(true, 'bound on the scopeKeyData');
                return oldOnValue.apply(this, arguments);
            };
            var c = new Observation(function () {
                return scopeKeyData.get() + map.attr('other');
            });
            canReflect.onValue(c, function (newValue) {
                QUnit.equal(newValue, 'Ab', 'observation changed');
            });
            map.attr('value', 'A');
        });
        QUnit.asyncTest('unbinding clears all event bindings', function () {
            var map = new SimpleMap({
                value: 'a',
                other: 'b'
            });
            var wrap = new SimpleObservable(map);
            var scope = new Scope(wrap);
            var scopeKeyData = scope.computeData('value');
            var c = new Observation(function () {
                return scopeKeyData.get() + map.attr('other');
            });
            var handlers = function (newValue) {
                QUnit.equal(newValue, 'Ab');
            };
            canReflect.onValue(c, handlers);
            canReflect.offValue(c, handlers);
            setTimeout(function () {
                var handlers = map[canSymbol.for('can.meta')].handlers.get([]);
                equal(handlers.length, 0, 'there are no bindings');
                start();
            }, 30);
        });
        QUnit.test('computes are read as this and . and  ../', function () {
            var value = new SimpleObservable(1);
            var scope = new Scope(value);
            QUnit.equal(scope.get('this'), 1, 'this read value');
            QUnit.equal(scope.get('.'), 1, '. read value');
            scope = scope.add({});
            QUnit.equal(scope.get('..'), 1, '.. read value');
        });
        QUnit.test('computes are set as this and . and  ../', function () {
            var value = new SimpleObservable(1);
            var scope = new Scope(value);
            scope.set('this', 2);
            QUnit.equal(scope.get('this'), 2, 'this read value');
            scope.set('.', 3);
            QUnit.equal(scope.get('this'), 3, '. read value');
            scope = scope.add({});
            scope.set('..', 4);
            QUnit.equal(scope.get('..'), 4, '.. read value');
        });
        QUnit.test('maps are set with this.foo and ./foo', function () {
            var map = new SimpleObservable(new SimpleMap({ value: 1 }));
            var scope = new Scope(map);
            scope.set('this.value', 2);
            QUnit.equal(scope.get('this.value'), 2, 'this read value');
            scope.set('./value', 3);
            QUnit.equal(scope.get('./value'), 3, '. read value');
        });
        QUnit.test('setting a key on a non observable context', function () {
            var context = { colors: new SimpleMap() };
            var scope = new Scope(context);
            scope.set('colors', { prop: 'bar' });
            QUnit.deepEqual(context.colors.attr(), { prop: 'bar' }, 'can updateDeep');
        });
        testHelpers.dev.devOnlyTest('fast path computeData dependencies', function (assert) {
            var map = new SimpleMap({ value: 'a' });
            var scope = new Scope(map);
            var computeData = scope.computeData('value');
            var c = new Observation(function () {
                return computeData.get();
            });
            canReflect.onValue(c, function () {
            });
            var dependencies = canReflect.getValueDependencies(c);
            assert.ok(dependencies.valueDependencies.has(computeData), 'compute has computeData');
            assert.equal(dependencies.valueDependencies.size, 1, 'compute only has computeData');
            var computeDataDependencies = canReflect.getValueDependencies(computeData);
            assert.ok(!computeDataDependencies.valueDependencies, 'the internal Observation should not be a visible dependency of computeData');
            assert.ok(computeDataDependencies.keyDependencies.get(map).has('value'), 'the map\'s \'value\' property should be a dependency of computeData');
            var mapValueDependencies = canReflectDeps.getDependencyDataOf(map, 'value').whatChangesMe.mutate;
            assert.ok(mapValueDependencies.valueDependencies.has(computeData), 'the computeData should be a mutation dependency of the map\'s \'value\' property');
        });
        QUnit.test('scopeKeyData offValue resets dependencyChange/start', function () {
            var map = new SimpleMap({
                value: 'a',
                other: 'b'
            });
            var wrap = new SimpleObservable(map);
            var scope = new Scope(wrap);
            var scopeKeyData = scope.computeData('value');
            var handler = function () {
            };
            canReflect.onValue(scopeKeyData, handler);
            canReflect.offValue(scopeKeyData, handler);
            QUnit.equal(scopeKeyData.observation.dependencyChange, Observation.prototype.dependencyChange, 'dependencyChange should be restored');
            QUnit.equal(scopeKeyData.observation.start, Observation.prototype.start, 'start should be restored');
        });
        QUnit.test('Rendering a template with a custom scope (#55)', function () {
            var scope = new Scope({});
            QUnit.equal(scope.get('name'), undefined, 'No name');
            scope.set('name', 'John');
            QUnit.equal(scope.get('name'), 'John', 'Got the name');
            scope = scope.add({ name: 'Justin' });
            QUnit.equal(scope.get('name'), 'Justin', 'Got the top scope name');
        });
        QUnit.test('./ scope lookup should read current scope', function () {
            var parent = new SimpleMap();
            var map = new SimpleMap();
            var scope = new Scope(parent).add(map);
            QUnit.equal(scope.attr('./'), map);
        });
        QUnit.test('getTemplateContext() gives a scope with the templateContext', function () {
            var map = new SimpleMap();
            var scope = new Scope(map);
            var templateContext = scope.getTemplateContext();
            QUnit.ok(templateContext instanceof Scope, 'templateContext is a Scope');
            QUnit.ok(templateContext._context instanceof TemplateContext, 'templateContext context is a TemplateContext object');
        });
        QUnit.test('scope can be used to read from the templateContext', function () {
            var map = new SimpleMap();
            var scope = new Scope(map);
            QUnit.deepEqual(scope.peek('scope'), scope, 'scope');
            scope.set('scope.vars.name', 'Kevin');
            QUnit.equal(scope.peek('scope.vars.name'), 'Kevin', 'scope.vars.name === Kevin');
            var ageFn = function () {
                return '30';
            };
            scope.set('scope.vars.age', ageFn);
            QUnit.equal(scope.peek('scope.vars.age')(), '30', 'scope.vars.age === 30');
        });
        QUnit.test('scope.index reads from special scopes', function () {
            var originalIndexHelper = canStacheHelpers.index;
            delete canStacheHelpers.index;
            var map1 = new SimpleMap({ index: 1 });
            var map2 = new SimpleMap({ index: 3 });
            var scope = new Scope(map1);
            QUnit.equal(scope.peek('scope.index'), undefined, 'scope.index returns undefined if no special context exists');
            scope = scope.add({ index: 2 }, { special: true }).add(map2).add({ index: 0 }, { special: true });
            QUnit.equal(scope.peek('scope.index'), 0, 'scope.index is read correctly');
            QUnit.equal(scope._parent.peek('scope.index'), 2, 'scope.index is only read from special contexts');
            canStacheHelpers.index = originalIndexHelper;
        });
        QUnit.test('scope.index should not return a global helper', function () {
            var mockGlobalHelper = function () {
                QUnit.ok(false, 'global helper should not be called');
            };
            var originalIndexHelper = canStacheHelpers.index;
            canStacheHelpers.index = mockGlobalHelper;
            var scope = new Scope({});
            QUnit.equal(scope.peek('scope.index'), undefined, 'scope.index returns undefined if no special context exists');
            canStacheHelpers.index = originalIndexHelper;
        });
        QUnit.test('scope.key reads from special scopes', function () {
            var map1 = new SimpleMap({ key: 'one' });
            var map2 = new SimpleMap({ key: 3 });
            var scope = new Scope(map1).add({ key: 'two' }, { special: true }).add(map2).add({ key: 'four' }, { special: true });
            QUnit.equal(scope.peek('scope.key'), 'four', 'scope.key is read correctly');
            QUnit.equal(scope._parent.peek('scope.key'), 'two', 'scope.key is only read from special contexts');
        });
        QUnit.test('variables starting with \'scope\' should not be read from templateContext (#104)', function () {
            var map = new SimpleMap({ scope1: 'this is scope1' });
            var scope = new Scope(map);
            QUnit.deepEqual(scope.peek('scope1'), 'this is scope1', 'scope1');
        });
        QUnit.test('nested properties can be read from templateContext.vars', function () {
            var foo = new SimpleMap({ bar: 'baz' });
            var map = new SimpleMap();
            var scope = new Scope(map);
            QUnit.ok(!scope.peek('scope.vars.foo.bar'), 'vars.foo.bar === undefined');
            scope.set('scope.vars.foo', foo);
            QUnit.equal(scope.peek('scope.vars.foo.bar'), 'baz', 'vars.foo.bar === baz');
            scope.set('scope.vars.foo.bar', 'quz');
            QUnit.equal(scope.peek('scope.vars.foo.bar'), 'quz', 'vars.foo.bar === quz');
        });
        QUnit.test('filename and lineNumber can be read from anywhere in scope chain', function () {
            var parent = new Scope({});
            var scope = parent.add({});
            parent.set('scope.filename', 'my-cool-file.txt');
            parent.set('scope.lineNumber', '5');
            QUnit.equal(scope.peek('scope.filename'), 'my-cool-file.txt', 'scope.peek("scope.filename")');
            QUnit.equal(scope.peek('scope.lineNumber'), '5', 'scope.peek("scope.lineNumber")');
        });
        QUnit.test('nested properties can be read from scope.root', function () {
            var root = new SimpleMap({ bar: 'baz' });
            var map = new SimpleMap({ bar: 'abc' });
            var scope = new Scope(root).add(map);
            QUnit.equal(scope.peek('scope.root.bar'), 'baz', 'root.bar === baz');
        });
        QUnit.test('special scopes are skipped if options.special !== true', function () {
            var map1 = new SimpleMap({});
            var scope = new Scope(map1).add({ foo: 'two' }, { special: true }).add({});
            QUnit.equal(scope.peek('foo', { special: true }), 'two', 'foo is read from special scope');
        });
        QUnit.test('special scopes are skipped when using ../.', function () {
            var map = new SimpleMap({ foo: 'one' });
            var scope = new Scope(map).add({ foo: 'two' }, { special: true }).add({});
            QUnit.equal(scope.peek('../.'), map);
        });
        QUnit.test('special scopes are skipped when using .', function () {
            var map = new SimpleMap({ foo: 'one' });
            var scope = new Scope(map).add({ foo: 'two' }, { special: true });
            QUnit.equal(scope.peek('.'), map);
        });
        QUnit.test('this works everywhere (#45)', function () {
            var obj = { foo: 'bar' };
            var scope = new Scope(obj);
            QUnit.equal(scope.get('this.foo'), 'bar');
        });
        QUnit.test('\'this\' and %context give the context', 1, function () {
            var vm;
            var MyMap = SimpleMap.extend({
                doSomething: function () {
                    QUnit.equal(this, vm, 'event callback called on context');
                }
            });
            vm = new MyMap();
            var compute = new Scope(vm).computeData('this.doSomething', {
                isArgument: true,
                args: []
            }).compute;
            compute()();
        });
        QUnit.test('that .set with ../ is able to skip notContext scopes (#43)', function () {
            var instance = new SimpleMap({ prop: 0 });
            var notContextContext = { NAME: 'NOT CONTEXT' };
            var top = { NAME: 'TOP' };
            var scope = new Scope(instance).add(notContextContext, { notContext: true }).add(top);
            scope.set('../prop', 1);
            QUnit.equal(instance.attr('prop'), 1);
        });
        test('undefined props should be a scope hit (#20)', function () {
            var MyType = SimpleMap.extend('MyType', {
                init: function () {
                    this.value = undefined;
                }
            });
            var EmptyType = SimpleMap.extend('EmptyType', {});
            var instance = new MyType();
            var scope = new Scope(instance).add(new EmptyType());
            var c1 = scope.computeData('../value').compute;
            c1.on('change', function () {
            });
            c1('BAR');
            QUnit.equal(instance.attr('value'), 'BAR');
            var instance2 = new MyType();
            var scope2 = new Scope(instance2).add(new SimpleObservable());
            var c2 = scope2.computeData('../value').compute;
            c2.on('change', function () {
            });
            c2('BAR');
            QUnit.equal(instance2.attr('value'), 'BAR');
        });
        QUnit.test('ScopeKeyData can.valueHasDependencies', function () {
            var map = new SimpleMap({ age: 21 });
            var base = new Scope(map);
            var age = base.computeData('age');
            QUnit.equal(canReflect.valueHasDependencies(age), undefined, 'undefined');
            canReflect.onValue(age, function () {
            });
            QUnit.equal(canReflect.valueHasDependencies(age), true, 'undefined');
        });
        QUnit.test('get and set Priority', function () {
            var map = new SimpleMap({ age: 21 });
            var base = new Scope(map);
            var age = base.computeData('age');
            canReflect.setPriority(age, 5);
            QUnit.equal(canReflect.getPriority(age), 5, 'set priority');
            var compute = age.compute;
            QUnit.equal(canReflect.getPriority(compute), 5, 'set priority');
        });
        QUnit.test('fast path checking does not leak ObservationRecord.adds', function () {
            var map = new SimpleMap({ age: 21 });
            Object.defineProperty(map, 'age', {
                get: function () {
                    return this.attr('age');
                },
                set: function (newVal) {
                    this.attr('age', newVal);
                }
            });
            var base = new Scope(map);
            var age = base.computeData('age');
            ObservationRecorder.start();
            age.get();
            var dependencies = ObservationRecorder.stop();
            QUnit.equal(dependencies.keyDependencies.size, 0, 'no key dependencies');
            QUnit.equal(dependencies.valueDependencies.size, 1, 'only sees age');
            QUnit.ok(dependencies.valueDependencies.has(age), 'only sees age');
        });
        QUnit.test('{{scope.set(...)}} works', function () {
            var map = new SimpleMap({ foo: 'bar' });
            var scope = new Scope(map);
            var set = scope.peek('scope@set');
            set('foo', 'baz');
            QUnit.equal(map.get('foo'), 'baz', 'map.foo updated using scope.set');
        });
        QUnit.test('can read a method from scope.viewModel', function () {
            var viewModel = new SimpleMap({
                method: function () {
                    return 'method return value';
                }
            });
            var scope = new Scope({}).add({ viewModel: viewModel }, { special: true });
            var method = scope.peek('scope.viewModel@method');
            QUnit.equal(method(), 'method return value');
        });
        QUnit.test('can read a value from scope.element', function () {
            var element = { value: 'element value' };
            var scope = new Scope({}).add({ element: element }, { special: true });
            var value = scope.peek('scope.element.value');
            QUnit.equal(value, 'element value');
        });
        QUnit.test('scope.find can be used to find a value in the first scope it exists', function () {
            var a = new SimpleMap({ a: 'a' });
            var b = new SimpleMap({ b: 'b' });
            var c = new SimpleMap({ c: 'c' });
            var scope = new Scope(c).add(b).add(a);
            QUnit.equal(scope.find('a'), 'a', 'a');
            QUnit.equal(scope.find('b'), 'b', 'b');
            QUnit.equal(scope.find('c'), 'c', 'c');
        });
        QUnit.test('scope.find accepts readOptions', function () {
            var a = new SimpleMap({ a: 'a' });
            a.func = function () {
                return this;
            };
            var b = new SimpleMap({ b: 'b' });
            var c = new SimpleMap({ c: 'c' });
            var scope = new Scope(c).add(b).add(a);
            var aDotFunc = scope.find('func');
            QUnit.equal(aDotFunc(), a, 'a.func() got correct context');
            aDotFunc = scope.find('func', { proxyMethods: false });
            QUnit.notEqual(aDotFunc(), a, 'non-proxied a.func() got correct context');
        });
        QUnit.test('scope.read should not walk up normal scopes by default', function () {
            var a = new SimpleMap({ a: 'a' });
            var b = new SimpleMap({ b: 'b' });
            var c = new SimpleMap({ c: 'c' });
            var scope = new Scope(c).add(b).add(a);
            QUnit.equal(scope.read('a').value, 'a', 'a');
            QUnit.equal(scope.read('b').value, undefined, 'b');
            QUnit.equal(scope.read('c').value, undefined, 'c');
        });
        QUnit.test('scope.read should walk over special scopes', function () {
            var map = new SimpleMap({
                a: 'a',
                b: 'b',
                c: 'c'
            });
            var scope = new Scope(map).add({ d: 'd' }, { special: true });
            QUnit.equal(scope.read('a').value, 'a', 'a');
            QUnit.equal(scope.read('b').value, 'b', 'b');
            QUnit.equal(scope.read('c').value, 'c', 'c');
        });
        QUnit.test('scope.read should skip special contexts and read from not-context scope higher in the chain', function () {
            var scope = new Scope({ a: 'a' }).add({ b: 'b' }, { notContext: true }).add({ c: 'c' }, { special: true }).add({ d: 'd' }, { notContext: true }).add({ e: 'e' });
            QUnit.equal(scope.read('a').value, undefined, 'a not read from normal parent context');
            QUnit.equal(scope.read('b').value, 'b', 'b read correctly from notContext parent context');
            QUnit.equal(scope.read('c').value, undefined, 'c not read from special context');
            QUnit.equal(scope.read('d').value, 'd', 'd read correctly from notContext parent context');
            QUnit.equal(scope.read('e').value, 'e', 'e read correctly');
        });
        QUnit.test('reading using ../ when there is no parent returns undefined', function () {
            var scope = new Scope({});
            try {
                QUnit.equal(scope.read('../foo').value, undefined, 'returns undefined');
            } catch (e) {
                QUnit.ok(false, 'error occured: ' + e);
            }
        });
        QUnit.test('read checks templateContext helpers then global helpers after checking the scope', function () {
            var map = {
                scopeFunction: function () {
                    return 'scopeFunction';
                }
            };
            var helperFunction = function () {
                return 'helperFunction';
            };
            var localHelperFunction = function () {
                return 'localHelperFunction';
            };
            var globalHelperCalledLocalHelperFunction = function () {
                return 'global helper function called "localHelperFunction"';
            };
            var scope = new Scope(map);
            canStacheHelpers.helperFunction = helperFunction;
            canReflect.setKeyValue(scope.templateContext.helpers, 'localHelperFunction', localHelperFunction);
            canStacheHelpers.localHelperFunction = globalHelperCalledLocalHelperFunction;
            var readScopeFunction = scope.read('scopeFunction').value;
            QUnit.deepEqual(readScopeFunction(), 'scopeFunction', 'scopeFunction');
            var readLocalHelperFunction = scope.read('localHelperFunction').value;
            QUnit.deepEqual(readLocalHelperFunction(), 'localHelperFunction', 'localHelperFunction');
            var readHelperFunction = scope.read('helperFunction').value;
            QUnit.deepEqual(readHelperFunction(), 'helperFunction', 'helperFunction');
            delete canStacheHelpers.helperFunction;
            delete canStacheHelpers.localHelperFunction;
            canReflect.setKeyValue(scope.templateContext.helpers, 'localHelperFunction', undefined);
        });
        QUnit.test('read can handle objects stored on helpers', function () {
            var scope = new Scope();
            var fakeConsole = {
                log: function () {
                    return 'fakeConsole.log';
                },
                warn: function () {
                    return 'fakeConsole.warn';
                }
            };
            canStacheHelpers.console = fakeConsole;
            var readConsoleLog = scope.read('console.log').value;
            QUnit.deepEqual(readConsoleLog(), 'fakeConsole.log', 'fakeConsole.log');
            var readConsoleWarn = scope.read('console.warn').value;
            QUnit.deepEqual(readConsoleWarn(), 'fakeConsole.warn', 'fakeConsole.warn');
            delete canStacheHelpers.console;
        });
        QUnit.test('scope.helpers can be used to read a helper that conflicts with a property in the scope', function () {
            var map = {
                myIf: function () {
                    return 'map.myIf';
                }
            };
            var myIf = function () {
                return 'global.myIf';
            };
            var scope = new Scope(map);
            canStacheHelpers.myIf = myIf;
            var localIf = scope.read('myIf').value;
            QUnit.deepEqual(localIf(), 'map.myIf', 'scope function');
            var globalIf = scope.read('scope.helpers.myIf').value;
            QUnit.deepEqual(globalIf(), 'global.myIf', 'global function');
            delete canStacheHelpers.myIf;
        });
        QUnit.test('functions have correct `thisArg` so they can be called even with `proxyMethods: false`', function () {
            var parent = {
                name: function () {
                    return 'parent';
                }
            };
            var child = {
                name: function () {
                    return 'child';
                }
            };
            var func = function () {
            };
            var childData = {
                child: child,
                func: func
            };
            var parentData = {
                parent: parent,
                func: func
            };
            var scope = new Scope(parentData).add(childData);
            var childName = scope.read('child.name', { proxyMethods: false });
            QUnit.equal(childName.value, child.name, 'childName.value === child.name');
            QUnit.equal(childName.thisArg, child, 'childName.thisArg === child');
            var childNameCompute = scope.computeData('child.name', { proxyMethods: false });
            Observation.temporarilyBind(childNameCompute);
            QUnit.equal(childNameCompute.initialValue, child.name, 'childNameCompute.inititalValue === child.name');
            QUnit.equal(childNameCompute.thisArg, child, 'childNameCompute.thisArg === child');
            var rootFunc = scope.read('func', { proxyMethods: false });
            QUnit.equal(rootFunc.value, func, 'rootFunc.value === func');
            QUnit.equal(rootFunc.thisArg, undefined, 'rootFunc.thisArg === undefined');
            var myHelper = function () {
            };
            canReflect.setKeyValue(scope.templateContext.helpers, 'myHelper', myHelper);
            var helper = scope.read('myHelper', { proxyMethods: false });
            QUnit.equal(helper.value, myHelper, 'helper.value === func');
            QUnit.equal(helper.thisArg, undefined, 'helper.thisArg === undefined');
            var parentName = scope.read('../parent.name', { proxyMethods: false });
            QUnit.equal(parentName.value, parent.name, 'parentName.value === parent.name');
            QUnit.equal(parentName.thisArg, parent, 'parentName.thisArg === parent');
            var parentFunc = scope.read('../func', { proxyMethods: false });
            QUnit.equal(parentFunc.value, func, 'parentFunc.value === func');
            QUnit.equal(parentFunc.thisArg, parentData, 'rootFunc.thisArg === parentData');
        });
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-view-target@4.0.0#test/test*/
define('can-view-target@4.0.0#test/test', [
    'require',
    'exports',
    'module',
    'can-view-target',
    'can-simple-dom',
    'steal-qunit',
    'can-globals/mutation-observer/mutation-observer'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        var target = require('can-view-target');
        var simpleDom = require('can-simple-dom');
        var QUnit = require('steal-qunit');
        var MUTATION_OBSERVER = require('can-globals/mutation-observer/mutation-observer');
        QUnit.module('can-view-target');
        test('basics', function () {
            var classCallback = function () {
                    equal(this.nodeName.toLowerCase(), 'h1', 'class on the right element');
                    this.className = 'selected';
                }, attributesCallback = function () {
                    equal(this.nodeName.toLowerCase(), 'h1', 'attributes on the right element');
                }, textNodeCallback = function () {
                    equal(this.nodeType, 3, 'got a text node');
                    this.nodeValue = 'World';
                };
            var data = target([{
                    tag: 'h1',
                    attrs: {
                        'id': 'myh1',
                        'class': classCallback
                    },
                    attributes: [attributesCallback],
                    children: [{
                            tag: 'span',
                            children: [
                                'Hello ',
                                textNodeCallback,
                                '!'
                            ]
                        }]
                }]);
            equal(data.clone.childNodes.length, 1, 'there is one child');
            var h1 = data.clone.childNodes[0];
            equal(h1.nodeName.toLowerCase(), 'h1', 'there is one h1');
            equal(h1.id, 'myh1', 'the h1 has the right id');
            equal(h1.childNodes.length, 1, 'the h1 has span');
            equal(h1.childNodes[0].childNodes.length, 3, 'the span has 3 children');
            deepEqual(data.paths, [{
                    path: [0],
                    callbacks: [
                        { callback: classCallback },
                        { callback: attributesCallback }
                    ],
                    paths: [{
                            path: [
                                0,
                                1
                            ],
                            callbacks: [{ callback: target.keepsTextNodes ? textNodeCallback : data.paths[0].paths[0].callbacks[0].callback }]
                        }]
                }]);
            var result = data.hydrate();
            var newH1 = result.childNodes[0];
            equal(newH1.className, 'selected', 'got selected class name');
            equal(newH1.innerHTML.toLowerCase(), '<span>hello world!</span>');
        });
        test('replacing items', function () {
            var data = target([
                function () {
                    this.parentNode.insertBefore(document.createTextNode('inserted'), this.nextSibling);
                },
                'hi',
                function () {
                    equal(this.previousSibling.nodeValue, 'hi', 'previous is as expected');
                }
            ]);
            data.hydrate();
        });
        test('comments', function () {
            var data = target([
                { tag: 'h1' },
                { comment: 'foo bar' }
            ]);
            var node = data.clone.childNodes[1];
            equal(node.nodeValue, 'foo bar', 'node value is right');
            equal(node.nodeType, 8, 'node is a comment');
        });
        test('paths should be run in reverse order (#966)', function () {
            var data = target([{
                    tag: 'h1',
                    attributes: [function () {
                        }],
                    children: [
                        function () {
                            this.parentNode.insertBefore(document.createElement('div'), this.nextSibling);
                        },
                        {
                            tag: 'span',
                            children: [function () {
                                    equal(this.nodeType, 3, 'got an element');
                                }]
                        }
                    ]
                }]);
            data.hydrate();
        });
        test('renderToVirtualDOM', function () {
            var simpleDocument = new simpleDom.Document();
            var innerData = target([{ tag: 'span' }], simpleDocument);
            var outerData = target([{
                    tag: 'h1',
                    children: [
                        function (data) {
                            this.parentNode.insertBefore(innerData.hydrate(data), this);
                            this.parentNode.removeChild(this);
                        },
                        'foo'
                    ]
                }], simpleDocument);
            var out = outerData.hydrate({ foo: true });
            equal(out.firstChild.nodeName, 'H1');
            equal(out.firstChild.firstChild.nodeName, 'SPAN');
            equal(out.firstChild.lastChild.nodeValue, 'foo');
        });
        test('cloneNode works in IE11', function () {
            var frag = document.createDocumentFragment();
            var text = document.createTextNode('some-text');
            var MO = MUTATION_OBSERVER();
            var observer;
            frag.appendChild(text);
            var clone = target.cloneNode(frag);
            equal(clone.childNodes.length, 1, 'cloneNode should work');
            if (MO) {
                observer = new MO(function (mutations) {
                });
                observer.observe(document.documentElement, {
                    childList: true,
                    subtree: true
                });
                clone = target.cloneNode(frag);
                equal(clone.childNodes.length, 1, 'cloneNode should work after creating MutationObserver');
            }
        });
        test('cloneNode keeps non-default element namespace', function () {
            var frag = document.createDocumentFragment();
            var svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            frag.appendChild(svg);
            var clone = target.cloneNode(frag);
            equal(clone.firstChild.namespaceURI, 'http://www.w3.org/2000/svg', 'cloneNode should keep non-default element namespace');
        });
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-stache-converters@4.0.1#can-stache-converters*/
define('can-stache-converters@4.0.1#can-stache-converters', [
    'require',
    'exports',
    'module',
    'can-reflect',
    'can-stache',
    'can-util/js/string-to-any/string-to-any',
    'can-util/js/make-array/make-array',
    'can-util/js/dev/dev',
    'can-stache-bindings'
], function (require, exports, module) {
    var canReflect = require('can-reflect');
    var stache = require('can-stache');
    var stringToAny = require('can-util/js/string-to-any/string-to-any');
    var makeArray = require('can-util/js/make-array/make-array');
    var dev = require('can-util/js/dev/dev');
    require('can-stache-bindings');
    stache.registerConverter('boolean-to-inList', {
        get: function (item, list) {
            if (!list) {
                return false;
            } else {
                return list.indexOf(item) !== -1;
            }
        },
        set: function (newVal, item, list) {
            if (!list) {
                return;
            }
            if (!newVal) {
                var idx = list.indexOf(item);
                if (idx !== -1) {
                    list.splice(idx, 1);
                }
            } else {
                list.push(item);
            }
        }
    });
    stache.addConverter('string-to-any', {
        get: function (obs) {
            return '' + canReflect.getValue(obs);
        },
        set: function (newVal, obs) {
            var converted = stringToAny(newVal);
            canReflect.setValue(obs, converted);
        }
    });
    stache.addConverter('not', {
        get: function (obs) {
            return !canReflect.getValue(obs);
        },
        set: function (newVal, obs) {
            canReflect.setValue(obs, !newVal);
        }
    });
    stache.addConverter('index-to-selected', {
        get: function (item, list) {
            var val = canReflect.getValue(item);
            var idx = canReflect.getValue(list).indexOf(val);
            return idx;
        },
        set: function (idx, item, list) {
            var newVal = canReflect.getValue(list)[idx];
            canReflect.setValue(item, newVal);
        }
    });
    stache.addConverter('selected-to-index', {
        get: function (idx, list) {
            var val = canReflect.getValue(idx), listValue = canReflect.getValue(list);
            var item = listValue[val];
            return item;
        },
        set: function (item, idx, list) {
            var newVal = canReflect.getValue(list).indexOf(item);
            canReflect.setValue(idx, newVal);
        }
    });
    stache.addConverter('either-or', {
        get: function (chosen, a, b) {
            var chosenVal = canReflect.getValue(chosen), aValue = canReflect.getValue(a), bValue = canReflect.getValue(b);
            var matchA = aValue === chosenVal;
            var matchB = bValue === chosenVal;
            if (!matchA && !matchB) {
                return;
            } else {
                return matchA;
            }
        },
        set: function (newVal, chosen, a, b) {
            var setVal = newVal ? canReflect.getValue(a) : canReflect.getValue(b);
            canReflect.setValue(chosen, setVal);
        }
    });
    stache.addConverter('equal', {
        get: function () {
            var args = makeArray(arguments);
            args.pop();
            if (args.length > 1) {
                var comparer = canReflect.getValue(args.pop());
                return args.every(function (obs) {
                    var value = canReflect.getValue(obs);
                    return value === comparer;
                });
            }
        },
        set: function () {
            var args = makeArray(arguments);
            args.pop();
            if (args.length > 2) {
                var b = args.shift();
                var comparer = args.pop();
                if (b) {
                    for (var i = 0; i < args.length; i++) {
                        canReflect.setValue(args[i], comparer);
                    }
                }
            }
        }
    });
});
/*can-stache-converters@4.0.1#test/boolean-to-inList_test*/
define('can-stache-converters@4.0.1#test/boolean-to-inList_test', [
    'require',
    'exports',
    'module',
    'can-stache-converters',
    'can-define/list/list',
    'can-define/map/map',
    'can-stache',
    'can-util/js/each/each',
    'can-dom-events',
    'steal-qunit'
], function (require, exports, module) {
    require('can-stache-converters');
    var DefineList = require('can-define/list/list');
    var DefineMap = require('can-define/map/map');
    var stache = require('can-stache');
    var each = require('can-util/js/each/each');
    var domEvents = require('can-dom-events');
    var QUnit = require('steal-qunit');
    QUnit.module('boolean-to-inList', {
        setup: function () {
            this.fixture = document.getElementById('qunit-fixture');
        }
    });
    QUnit.test('Works with checkboxes', function () {
        var template = stache('<input type=\'checkbox\' checked:bind=\'boolean-to-inList(item, list)\' />');
        var map = new DefineMap({
            item: 2,
            list: new DefineList([
                1,
                2,
                3
            ])
        });
        var frag = template(map);
        var input = frag.firstChild;
        QUnit.ok(input.checked, 'it is initially checked');
        QUnit.equal(map.list.indexOf(2), 1, 'two is in the list');
        input.checked = false;
        domEvents.dispatch(input, 'change');
        QUnit.equal(map.list.indexOf(2), -1, 'No longer in the list');
        map.item = 3;
        QUnit.ok(input.checked, '3 is in the list');
        map.item = 5;
        QUnit.ok(!input.checked, '5 is not in the list');
        map.list.push(5);
        QUnit.ok(input.checked, 'Now 5 is in the list');
        map.item = 6;
        input.checked = true;
        domEvents.dispatch(input, 'change');
        QUnit.equal(map.list.indexOf(6), 3, 'pushed into the list');
    });
    QUnit.test('If there is no list, treated as false', function () {
        var template = stache('<input type=\'checkbox\' checked:bind=\'boolean-to-inList(item, list)\' />');
        var map = new DefineMap({
            item: 2,
            list: undefined
        });
        var frag = template(map);
        var input = frag.firstChild;
        QUnit.ok(!input.checked, 'not checked because there is no list');
        input.checked = true;
        domEvents.dispatch(input, 'change');
        QUnit.ok(true, 'no errors thrown');
    });
    QUnit.test('works with radio buttons', function () {
        var template = stache('<form><input type=\'radio\' name=\'name\' value=\'Matthew\' checked:bind=\'boolean-to-inList("Matthew", names)\' /><input type=\'radio\' name=\'name\' value=\'Wilbur\' checked:bind=\'boolean-to-inList("Wilbur", names)\' /></form>');
        var map = new DefineMap({ names: ['Wilbur'] });
        var frag = template(map);
        var radioOne = frag.firstChild.firstChild;
        var radioTwo = radioOne.nextSibling;
        this.fixture.appendChild(frag);
        QUnit.equal(radioOne.checked, false, 'Matthew not checked');
        QUnit.equal(radioTwo.checked, true, 'Wilbur is checked');
        radioOne.checked = true;
        domEvents.dispatch(radioOne, 'change');
        QUnit.equal(radioOne.checked, true, 'Matthew is checked');
        QUnit.equal(radioTwo.checked, false, 'Wilbur is not checked');
    });
});
/*can-stache-converters@4.0.1#test/index-to-selected_test*/
define('can-stache-converters@4.0.1#test/index-to-selected_test', [
    'require',
    'exports',
    'module',
    'can-stache-converters',
    'can-define/list/list',
    'can-define/map/map',
    'can-dom-events',
    'can-stache',
    'can-util/js/each/each',
    'steal-qunit'
], function (require, exports, module) {
    require('can-stache-converters');
    var DefineList = require('can-define/list/list');
    var DefineMap = require('can-define/map/map');
    var domEvents = require('can-dom-events');
    var stache = require('can-stache');
    var each = require('can-util/js/each/each');
    var QUnit = require('steal-qunit');
    QUnit.module('index-to-selected');
    QUnit.test('chooses select option by the index from a list', function () {
        var template = stache('<select value:bind="index-to-selected(~person, people)"><option value="none"></option>{{#each people}}<option value="{{scope.index}}">{{name}}</option>{{/each}}</select>');
        var map = new DefineMap({
            person: 'Anne',
            people: [
                'Matthew',
                'Anne',
                'Wilbur'
            ]
        });
        var select = template(map).firstChild;
        QUnit.equal(select.value, 1, 'initially set to the first value');
        select.value = 2;
        domEvents.dispatch(select, 'change');
        QUnit.equal(map.person, 'Wilbur', 'now it is me');
        map.person = map.people.item(0);
        QUnit.equal(select.value, 0, 'set back');
        select.value = 'none';
        domEvents.dispatch(select, 'change');
        QUnit.equal(map.person, undefined, 'now undefined because not in the list');
    });
    QUnit.test('chooses select option by the index from a list without ~', function () {
        var template = stache('<select value:bind="index-to-selected(person, people)"><option value="none"></option>{{#each people}}<option value="{{scope.index}}">{{name}}</option>{{/each}}</select>');
        var map = new DefineMap({
            person: 'Anne',
            people: [
                'Matthew',
                'Anne',
                'Wilbur'
            ]
        });
        var select = template(map).firstChild;
        QUnit.equal(select.value, 1, 'initially set to the first value');
        select.value = 2;
        domEvents.dispatch(select, 'change');
        QUnit.equal(map.person, 'Wilbur', 'now it is me');
        map.person = map.people.item(0);
        QUnit.equal(select.value, 0, 'set back');
        select.value = 'none';
        domEvents.dispatch(select, 'change');
        QUnit.equal(map.person, undefined, 'now undefined because not in the list');
    });
});
/*can-stache-converters@4.0.1#test/selected-to-index_test*/
define('can-stache-converters@4.0.1#test/selected-to-index_test', [
    'require',
    'exports',
    'module',
    'can-stache-converters',
    'can-define/map/map',
    'can-dom-events',
    'can-stache',
    'steal-qunit'
], function (require, exports, module) {
    require('can-stache-converters');
    var DefineMap = require('can-define/map/map');
    var domEvents = require('can-dom-events');
    var stache = require('can-stache');
    var QUnit = require('steal-qunit');
    QUnit.module('selected-to-index');
    QUnit.test('sets index by the value from a list', function () {
        var template = stache('<input value:bind="selected-to-index(~index, people)" />');
        var map = new DefineMap({
            index: '1',
            people: [
                'Matthew',
                'Anne',
                'Wilbur'
            ]
        });
        var input = template(map).firstChild;
        QUnit.equal(input.value, 'Anne', 'initially set to the first value');
        input.value = 'Wilbur';
        domEvents.dispatch(input, 'change');
        QUnit.equal(map.index, '2', 'now it is me');
        map.index = '0';
        QUnit.equal(input.value, 'Matthew', 'set back');
        input.value = 'none';
        domEvents.dispatch(input, 'change');
        QUnit.equal(map.index, -1, 'now -1 because not in the list');
    });
    QUnit.test('sets index by the value from a list without ~', function () {
        var template = stache('<input value:bind="selected-to-index(index, people)" />');
        var map = new DefineMap({
            index: '1',
            people: [
                'Matthew',
                'Anne',
                'Wilbur'
            ]
        });
        var input = template(map).firstChild;
        QUnit.equal(input.value, 'Anne', 'initially set to the first value');
        input.value = 'Wilbur';
        domEvents.dispatch(input, 'change');
        QUnit.equal(map.index, '2', 'now it is me');
        map.index = '0';
        QUnit.equal(input.value, 'Matthew', 'set back');
        input.value = 'none';
        domEvents.dispatch(input, 'change');
        QUnit.equal(map.index, -1, 'now -1 because not in the list');
    });
});
/*can-stache-converters@4.0.1#test/string-to-any_test*/
define('can-stache-converters@4.0.1#test/string-to-any_test', [
    'require',
    'exports',
    'module',
    'can-stache-converters',
    'can-define/list/list',
    'can-define/map/map',
    'can-dom-events',
    'can-stache',
    'can-util/js/each/each',
    'steal-qunit'
], function (require, exports, module) {
    require('can-stache-converters');
    var DefineList = require('can-define/list/list');
    var DefineMap = require('can-define/map/map');
    var domEvents = require('can-dom-events');
    var stache = require('can-stache');
    var each = require('can-util/js/each/each');
    var QUnit = require('steal-qunit');
    QUnit.module('string-to-any');
    QUnit.test('Works on all the types', function () {
        var types = {
            '22.3': 22.3,
            'foo': 'foo',
            'true': true,
            'false': false,
            'undefined': undefined,
            'null': null,
            'Infinity': Infinity,
            'NaN': {
                expected: NaN,
                equalityTest: function (a) {
                    return isNaN(a);
                }
            }
        };
        var defaultEquality = function (a, b) {
            return a === b;
        };
        each(types, function (expected, type) {
            var template = stache('<select value:bind="string-to-any(~val)"><option value="test">test</option><option value="' + type + '">' + type + '</option></select>');
            var map = new DefineMap({ val: 'test' });
            var frag = template(map);
            var select = frag.firstChild;
            var option = select.firstChild.nextSibling;
            var equality = defaultEquality;
            if (expected != null && expected.equalityTest) {
                equality = expected.equalityTest;
                expected = expected.expected;
            }
            select.value = type;
            domEvents.dispatch(select, 'change');
            QUnit.ok(equality(map.val, expected), 'map\'s value updated to: ' + type);
            map.val = 'test';
            map.val = expected;
            QUnit.equal(select.value, type, 'select\'s value updated to: ' + type);
        });
    });
    QUnit.test('Works on all the types without ~', function () {
        var types = {
            '22.3': 22.3,
            'foo': 'foo',
            'true': true,
            'false': false,
            'undefined': undefined,
            'null': null,
            'Infinity': Infinity,
            'NaN': {
                expected: NaN,
                equalityTest: function (a) {
                    return isNaN(a);
                }
            }
        };
        var defaultEquality = function (a, b) {
            return a === b;
        };
        each(types, function (expected, type) {
            var template = stache('<select value:bind="string-to-any(val)"><option value="test">test</option><option value="' + type + '">' + type + '</option></select>');
            var map = new DefineMap({ val: 'test' });
            var frag = template(map);
            var select = frag.firstChild;
            var option = select.firstChild.nextSibling;
            var equality = defaultEquality;
            if (expected != null && expected.equalityTest) {
                equality = expected.equalityTest;
                expected = expected.expected;
            }
            select.value = type;
            domEvents.dispatch(select, 'change');
            QUnit.ok(equality(map.val, expected), 'map\'s value updated to: ' + type);
            map.val = 'test';
            map.val = expected;
            QUnit.equal(select.value, type, 'select\'s value updated to: ' + type);
        });
    });
});
/*can-stache-converters@4.0.1#test/not_test*/
define('can-stache-converters@4.0.1#test/not_test', [
    'require',
    'exports',
    'module',
    'can-stache-converters',
    'can-define/list/list',
    'can-define/map/map',
    'can-dom-events',
    'can-stache',
    'steal-qunit'
], function (require, exports, module) {
    require('can-stache-converters');
    var DefineList = require('can-define/list/list');
    var DefineMap = require('can-define/map/map');
    var domEvents = require('can-dom-events');
    var stache = require('can-stache');
    var QUnit = require('steal-qunit');
    QUnit.module('not');
    QUnit.test('saves the inverse of the selected value without ~ (#68)', function () {
        var template = stache('<input type="checkbox" checked:bind="not(val)" />');
        var map = new DefineMap({ val: true });
        var input = template(map).firstChild;
        QUnit.equal(input.checked, false, 'initially false');
        map.val = false;
        QUnit.equal(input.checked, true, 'true because map val is false');
        input.checked = false;
        domEvents.dispatch(input, 'change');
        QUnit.equal(map.val, true, 'map is now true because checkbox is false');
    });
    QUnit.test('saves the inverse of the selected value', function () {
        var template = stache('<input type="checkbox" checked:bind="not(~val)" />');
        var map = new DefineMap({ val: true });
        var input = template(map).firstChild;
        QUnit.equal(input.checked, false, 'initially false');
        map.val = false;
        QUnit.equal(input.checked, true, 'true because map val is false');
        input.checked = false;
        domEvents.dispatch(input, 'change');
        QUnit.equal(map.val, true, 'map is now true because checkbox is false');
    });
    QUnit.test('works with boolean-to-inList', function () {
        var template = stache('<input type=\'checkbox\' checked:bind=\'not(~boolean-to-inList(item, list))\' />');
        var map = new DefineMap({
            item: 2,
            list: new DefineList([
                1,
                2,
                3
            ])
        });
        var input = template(map).firstChild;
        QUnit.equal(input.checked, false, 'not checked because it is in the list');
        map.item = 4;
        QUnit.equal(input.checked, true, 'checked because not in the list');
        input.checked = false;
        domEvents.dispatch(input, 'change');
        QUnit.equal(map.list.indexOf(4), 3, 'it was pushed into the list');
        map.list.splice(3, 1);
        QUnit.equal(input.checked, true, 'now it\'s checked because not in the list');
    });
});
/*can-compute@4.0.0#proto-compute*/
define('can-compute@4.0.0#proto-compute', [
    'require',
    'exports',
    'module',
    'can-observation',
    'can-observation-recorder',
    'can-event-queue/map/map',
    'can-stache-key',
    'can-util/js/get/get',
    'can-assign',
    'can-reflect',
    'can-util/js/single-reference/single-reference'
], function (require, exports, module) {
    var Observation = require('can-observation');
    var ObservationRecorder = require('can-observation-recorder');
    var eventQueue = require('can-event-queue/map/map');
    var observeReader = require('can-stache-key');
    var getObject = require('can-util/js/get/get');
    var assign = require('can-assign');
    var canReflect = require('can-reflect');
    var singleReference = require('can-util/js/single-reference/single-reference');
    var Compute = function (getterSetter, context, eventName, bindOnce) {
        var args = [];
        for (var i = 0, arglen = arguments.length; i < arglen; i++) {
            args[i] = arguments[i];
        }
        var contextType = typeof args[1];
        if (typeof args[0] === 'function') {
            this._setupGetterSetterFn(args[0], args[1], args[2], args[3]);
        } else if (args[1] !== undefined) {
            if (contextType === 'string' || contextType === 'number') {
                var isListLike = canReflect.isObservableLike(args[0]) && canReflect.isListLike(args[0]);
                var isMapLike = canReflect.isObservableLike(args[0]) && canReflect.isMapLike(args[0]);
                if (isMapLike || isListLike) {
                    var map = args[0];
                    var propertyName = args[1];
                    var mapGetterSetter = function (newValue) {
                        if (arguments.length) {
                            observeReader.set(map, propertyName, newValue);
                        } else {
                            if (isListLike) {
                                observeReader.get(map, 'length');
                            }
                            return observeReader.get(map, '' + propertyName);
                        }
                    };
                    this._setupGetterSetterFn(mapGetterSetter, args[1], args[2], args[3]);
                } else {
                    this._setupProperty(args[0], args[1], args[2]);
                }
            } else if (contextType === 'function') {
                this._setupSetter(args[0], args[1], args[2]);
            } else {
                if (args[1] && args[1].fn) {
                    this._setupAsyncCompute(args[0], args[1]);
                } else {
                    this._setupSettings(args[0], args[1]);
                }
            }
        } else {
            this._setupSimpleValue(args[0]);
        }
        this._args = args;
        this._primaryDepth = 0;
        this.isComputed = true;
    };
    var updateOnChange = function (compute, newValue, oldValue, batchNum) {
        var valueChanged = newValue !== oldValue && !(newValue !== newValue && oldValue !== oldValue);
        if (valueChanged) {
            compute.dispatch({
                type: 'change',
                batchNum: batchNum
            }, [
                newValue,
                oldValue
            ]);
        }
    };
    var setupComputeHandlers = function (compute, func, context) {
        var observation = new Observation(func, context, compute);
        var updater = compute.updater.bind(compute);
        compute.observation = observation;
        return {
            _on: function () {
                canReflect.onValue(observation, updater, 'notify');
                compute.value = observation.value;
            },
            _off: function () {
                canReflect.offValue(observation, updater, 'notify');
            },
            getDepth: function () {
                return observation.getDepth();
            }
        };
    };
    eventQueue(Compute.prototype);
    assign(Compute.prototype, {
        setPrimaryDepth: function (depth) {
            this._primaryDepth = depth;
        },
        _setupGetterSetterFn: function (getterSetter, context, eventName) {
            this._set = context ? getterSetter.bind(context) : getterSetter;
            this._get = context ? getterSetter.bind(context) : getterSetter;
            this._canObserve = eventName === false ? false : true;
            var handlers = setupComputeHandlers(this, getterSetter, context || this);
            assign(this, handlers);
        },
        _setupProperty: function (target, propertyName, eventName) {
            var self = this, handler;
            handler = function () {
                self.updater(self._get(), self.value);
            };
            this._get = function () {
                return getObject(target, propertyName);
            };
            this._set = function (value) {
                var properties = propertyName.split('.'), leafPropertyName = properties.pop();
                if (properties.length) {
                    var targetProperty = getObject(target, properties.join('.'));
                    targetProperty[leafPropertyName] = value;
                } else {
                    target[propertyName] = value;
                }
            };
            this._on = function (update) {
                eventQueue.on.call(target, eventName || propertyName, handler);
                this.value = this._get();
            };
            this._off = function () {
                return eventQueue.off.call(target, eventName || propertyName, handler);
            };
        },
        _setupSetter: function (initialValue, setter, eventName) {
            this.value = initialValue;
            this._set = setter;
            assign(this, eventName);
        },
        _setupSettings: function (initialValue, settings) {
            this.value = initialValue;
            this._set = settings.set || this._set;
            this._get = settings.get || this._get;
            if (!settings.__selfUpdater) {
                var self = this, oldUpdater = this.updater;
                this.updater = function () {
                    oldUpdater.call(self, self._get(), self.value);
                };
            }
            this._on = settings.on ? settings.on : this._on;
            this._off = settings.off ? settings.off : this._off;
        },
        _setupAsyncCompute: function (initialValue, settings) {
            var self = this;
            var getter = settings.fn;
            var bindings;
            this.value = initialValue;
            this._setUpdates = true;
            this.lastSetValue = new Compute(initialValue);
            this._set = function (newVal) {
                if (newVal === self.lastSetValue.get()) {
                    return this.value;
                }
                return self.lastSetValue.set(newVal);
            };
            this._get = function () {
                return getter.call(settings.context, self.lastSetValue.get());
            };
            if (getter.length === 0) {
                bindings = setupComputeHandlers(this, getter, settings.context);
            } else if (getter.length === 1) {
                bindings = setupComputeHandlers(this, function () {
                    return getter.call(settings.context, self.lastSetValue.get());
                }, settings);
            } else {
                var oldUpdater = this.updater, resolve = ObservationRecorder.ignore(function (newVal) {
                        oldUpdater.call(self, newVal, self.value);
                    });
                this.updater = function (newVal) {
                    oldUpdater.call(self, newVal, self.value);
                };
                bindings = setupComputeHandlers(this, function () {
                    var res = getter.call(settings.context, self.lastSetValue.get(), resolve);
                    return res !== undefined ? res : this.value;
                }, this);
            }
            assign(this, bindings);
        },
        _setupSimpleValue: function (initialValue) {
            this.value = initialValue;
        },
        _eventSetup: ObservationRecorder.ignore(function () {
            this.bound = true;
            this._on(this.updater);
        }),
        _eventTeardown: function () {
            this._off(this.updater);
            this.bound = false;
        },
        clone: function (context) {
            if (context && typeof this._args[0] === 'function') {
                this._args[1] = context;
            } else if (context) {
                this._args[2] = context;
            }
            return new Compute(this._args[0], this._args[1], this._args[2], this._args[3]);
        },
        _on: function () {
        },
        _off: function () {
        },
        get: function () {
            var recordingObservation = ObservationRecorder.isRecording();
            if (recordingObservation && this._canObserve !== false) {
                ObservationRecorder.add(this, 'change');
                if (!this.bound) {
                    Compute.temporarilyBind(this);
                }
            }
            if (this.bound) {
                if (this.observation) {
                    return this.observation.get();
                } else {
                    return this.value;
                }
            } else {
                return this._get();
            }
        },
        _get: function () {
            return this.value;
        },
        set: function (newVal) {
            var old = this.value;
            var setVal = this._set(newVal, old);
            if (this._setUpdates) {
                return this.value;
            }
            if (this.hasDependencies) {
                return this._get();
            }
            this.updater(setVal === undefined ? this._get() : setVal, old);
            return this.value;
        },
        _set: function (newVal) {
            return this.value = newVal;
        },
        updater: function (newVal, oldVal, batchNum) {
            this.value = newVal;
            if (this.observation) {
                this.observation.value = newVal;
            }
            updateOnChange(this, newVal, oldVal, batchNum);
        },
        toFunction: function () {
            return this._computeFn.bind(this);
        },
        _computeFn: function (newVal) {
            if (arguments.length) {
                return this.set(newVal);
            }
            return this.get();
        }
    });
    Compute.prototype.on = Compute.prototype.bind = Compute.prototype.addEventListener;
    Compute.prototype.off = Compute.prototype.unbind = Compute.prototype.removeEventListener;
    var hasDependencies = function hasDependencies() {
        return this.observation && this.observation.hasDependencies();
    };
    Object.defineProperty(Compute.prototype, 'hasDependencies', { get: hasDependencies });
    Compute.temporarilyBind = Observation.temporarilyBind;
    Compute.async = function (initialValue, asyncComputer, context) {
        return new Compute(initialValue, {
            fn: asyncComputer,
            context: context
        });
    };
    Compute.truthy = function (compute) {
        return new Compute(function () {
            var res = compute.get();
            if (typeof res === 'function') {
                res = res.get();
            }
            return !!res;
        });
    };
    canReflect.assignSymbols(Compute.prototype, {
        'can.isValueLike': true,
        'can.isMapLike': false,
        'can.isListLike': false,
        'can.setValue': Compute.prototype.set,
        'can.getValue': Compute.prototype.get,
        'can.valueHasDependencies': hasDependencies,
        'can.onValue': function onValue(handler, queue) {
            function translationHandler(ev, newValue) {
                handler(newValue);
            }
            singleReference.set(handler, this, translationHandler);
            this.addEventListener('change', translationHandler, queue);
        },
        'can.offValue': function offValue(handler, queue) {
            this.removeEventListener('change', singleReference.getAndDelete(handler, this), queue);
        },
        'can.getValueDependencies': function getValueDependencies() {
            var ret;
            if (this.observation) {
                ret = { valueDependencies: new Set([this.observation]) };
            }
            return ret;
        }
    });
    module.exports = exports = Compute;
});
/*can-compute@4.0.0#can-compute*/
define('can-compute@4.0.0#can-compute', [
    'require',
    'exports',
    'module',
    './proto-compute',
    'can-namespace',
    'can-util/js/single-reference/single-reference',
    'can-reflect/reflections/get-set/get-set',
    'can-symbol'
], function (require, exports, module) {
    var Compute = require('./proto-compute');
    var namespace = require('can-namespace');
    var singleReference = require('can-util/js/single-reference/single-reference');
    var canReflect = require('can-reflect/reflections/get-set/get-set');
    var canSymbol = require('can-symbol');
    var canOnValueSymbol = canSymbol.for('can.onValue'), canOffValueSymbol = canSymbol.for('can.offValue'), canGetValue = canSymbol.for('can.getValue'), canSetValue = canSymbol.for('can.setValue'), isValueLike = canSymbol.for('can.isValueLike'), isMapLike = canSymbol.for('can.isMapLike'), isListLike = canSymbol.for('can.isListLike'), isFunctionLike = canSymbol.for('can.isFunctionLike'), canValueHasDependencies = canSymbol.for('can.valueHasDependencies'), canGetValueDependencies = canSymbol.for('can.getValueDependencies');
    var addEventListener = function (ev, handler) {
        var compute = this;
        var translationHandler;
        if (handler) {
            translationHandler = function () {
                handler.apply(compute, arguments);
            };
            singleReference.set(handler, this, translationHandler);
        }
        return compute.computeInstance.addEventListener(ev, translationHandler);
    };
    var removeEventListener = function (ev, handler) {
        var args = [];
        if (typeof ev !== 'undefined') {
            args.push(ev);
            if (typeof handler !== 'undefined') {
                args.push(singleReference.getAndDelete(handler, this));
            }
        }
        return this.computeInstance.removeEventListener.apply(this.computeInstance, args);
    };
    var onValue = function (handler, queue) {
            return this.computeInstance[canOnValueSymbol](handler, queue);
        }, offValue = function (handler, queue) {
            return this.computeInstance[canOffValueSymbol](handler, queue);
        }, getValue = function () {
            return this.computeInstance.get();
        }, setValue = function (value) {
            return this.computeInstance.set(value);
        }, hasDependencies = function () {
            return this.computeInstance.hasDependencies;
        }, getDependencies = function () {
            return this.computeInstance[canGetValueDependencies]();
        };
    var COMPUTE = function (getterSetter, context, eventName, bindOnce) {
        function compute(val) {
            if (arguments.length) {
                return compute.computeInstance.set(val);
            }
            return compute.computeInstance.get();
        }
        compute.computeInstance = new Compute(getterSetter, context, eventName, bindOnce);
        compute.on = compute.bind = compute.addEventListener = addEventListener;
        compute.off = compute.unbind = compute.removeEventListener = removeEventListener;
        compute.isComputed = compute.computeInstance.isComputed;
        compute.clone = function (ctx) {
            if (typeof getterSetter === 'function') {
                context = ctx;
            }
            return COMPUTE(getterSetter, context, ctx, bindOnce);
        };
        canReflect.set(compute, canOnValueSymbol, onValue);
        canReflect.set(compute, canOffValueSymbol, offValue);
        canReflect.set(compute, canGetValue, getValue);
        canReflect.set(compute, canSetValue, setValue);
        canReflect.set(compute, isValueLike, true);
        canReflect.set(compute, isMapLike, false);
        canReflect.set(compute, isListLike, false);
        canReflect.set(compute, isFunctionLike, false);
        canReflect.set(compute, canValueHasDependencies, hasDependencies);
        canReflect.set(compute, canGetValueDependencies, getDependencies);
        return compute;
    };
    COMPUTE.truthy = function (compute) {
        return COMPUTE(function () {
            var res = compute();
            return !!res;
        });
    };
    COMPUTE.async = function (initialValue, asyncComputer, context) {
        return COMPUTE(initialValue, {
            fn: asyncComputer,
            context: context
        });
    };
    COMPUTE.temporarilyBind = Compute.temporarilyBind;
    module.exports = namespace.compute = COMPUTE;
});
/*can-stache-converters@4.0.1#test/either-or_test*/
define('can-stache-converters@4.0.1#test/either-or_test', [
    'require',
    'exports',
    'module',
    'can-stache-converters',
    'can-compute',
    'can-define/map/map',
    'can-dom-events',
    'can-stache',
    'steal-qunit'
], function (require, exports, module) {
    require('can-stache-converters');
    var compute = require('can-compute');
    var DefineMap = require('can-define/map/map');
    var domEvents = require('can-dom-events');
    var stache = require('can-stache');
    var QUnit = require('steal-qunit');
    QUnit.module('either-or');
    QUnit.test('can bind to a checkbox', function () {
        var renderer = stache('<input type=\'checkbox\' checked:bind=\'either-or(~pref, "Star Trek", "Star Wars")\' />');
        var map = new DefineMap({ pref: 'Star Trek' });
        var input = renderer(map).firstChild;
        QUnit.equal(input.checked, true, 'initial value is right');
        input.checked = false;
        domEvents.dispatch(input, 'change');
        QUnit.equal(map.pref, 'Star Wars', 'changed because input changed');
        map.pref = 'Star Trek';
        QUnit.equal(input.checked, true, 'changed because map changed');
    });
    QUnit.test('initial null selection', function () {
        var renderer = stache('<input type=\'checkbox\' checked:bind=\'either-or(~pref, "Yes", "No")\' />');
        var map = new DefineMap({ pref: null });
        var input = renderer(map).firstChild;
        QUnit.equal(input.checked, false, 'checkbox is unchecked');
        QUnit.strictEqual(map.pref, 'No', 'null value changed to falsey case by checkbox');
        input.checked = true;
        domEvents.dispatch(input, 'change');
        QUnit.equal(map.pref, 'Yes', 'map updated because check was checked');
    });
    QUnit.test('initial undefined selection', function () {
        var renderer = stache('<input type=\'checkbox\' checked:bind=\'either-or(~pref, "Yes", "No")\' />');
        var map = new DefineMap({ pref: undefined });
        var input = renderer(map).firstChild;
        QUnit.equal(input.checked, false, 'checkbox is unchecked');
        QUnit.strictEqual(map.pref, 'No', 'undefined value changed to falsey case by checkbox');
        input.checked = true;
        domEvents.dispatch(input, 'change');
        QUnit.equal(map.pref, 'Yes', 'map updated because check was checked');
    });
    QUnit.test('initial no match selection', function () {
        var renderer = stache('<input type=\'checkbox\' checked:bind=\'either-or(~pref, "Yes", "No")\' />');
        var map = new DefineMap({ pref: 'fubar' });
        var input = renderer(map).firstChild;
        QUnit.equal(input.checked, false, 'checkbox is unchecked');
        QUnit.strictEqual(map.pref, 'No', 'fubar value changed to falsey case by checkbox');
        input.checked = true;
        domEvents.dispatch(input, 'change');
        QUnit.equal(map.pref, 'Yes', 'map updated because check was checked');
    });
    QUnit.test('supports computes', function () {
        var renderer = stache('<input type=\'checkbox\' checked:bind=\'either-or(~pref, a, b)\' />');
        var map = new DefineMap({
            pref: compute('Maybe'),
            a: compute('Yes'),
            b: compute('No')
        });
        var input = renderer(map).firstChild;
        QUnit.equal(input.checked, false, 'checkbox is unchecked');
        QUnit.strictEqual(map.pref(), 'No', 'chosen value changed to falsey case by checkbox');
        input.checked = true;
        domEvents.dispatch(input, 'change');
        QUnit.equal(map.pref(), 'Yes', 'map updated because check was checked');
        input.checked = false;
        domEvents.dispatch(input, 'change');
        QUnit.equal(map.pref(), 'No', 'map updated because check was unchecked');
    });
    QUnit.test('supports computes without ~', function () {
        var renderer = stache('<input type=\'checkbox\' checked:bind=\'either-or(pref, a, b)\' />');
        var map = new DefineMap({
            pref: compute('Maybe'),
            a: compute('Yes'),
            b: compute('No')
        });
        var input = renderer(map).firstChild;
        QUnit.equal(input.checked, false, 'checkbox is unchecked');
        QUnit.strictEqual(map.pref(), 'No', 'chosen value changed to falsey case by checkbox');
        input.checked = true;
        domEvents.dispatch(input, 'change');
        QUnit.equal(map.pref(), 'Yes', 'map updated because check was checked');
        input.checked = false;
        domEvents.dispatch(input, 'change');
        QUnit.equal(map.pref(), 'No', 'map updated because check was unchecked');
    });
});
/*can-stache-converters@4.0.1#test/equal_test*/
define('can-stache-converters@4.0.1#test/equal_test', [
    'require',
    'exports',
    'module',
    'can-stache-converters',
    'can-compute',
    'can-dom-events',
    'can-stache',
    'steal-qunit'
], function (require, exports, module) {
    require('can-stache-converters');
    var compute = require('can-compute');
    var domEvents = require('can-dom-events');
    var stache = require('can-stache');
    var QUnit = require('steal-qunit');
    QUnit.module('can-stache-converters: equal');
    QUnit.test('Basics works', function () {
        var template = stache('<input type="radio" checked:bind="equal(~attending, \'yes\'" /><input type="radio" checked:bind="equal(~attending, \'no\'" />');
        var attending = compute('yes');
        var yes = template({ attending: attending }).firstChild, no = yes.nextSibling;
        QUnit.equal(yes.checked, true, 'initially a yes');
        QUnit.equal(no.checked, false, 'initially unchecked');
        attending('no');
        QUnit.equal(yes.checked, false, 'now not checked');
        QUnit.equal(no.checked, true, 'now checked');
        yes.checked = true;
        domEvents.dispatch(yes, 'change');
        QUnit.equal(attending(), 'yes', 'now it is yes');
        QUnit.equal(yes.checked, true, 'yes is checked');
        QUnit.equal(no.checked, false, 'no is unchecked');
    });
    QUnit.test('works without ~', function () {
        var template = stache('<input type="radio" checked:bind="equal(attending, \'yes\'" /><input type="radio" checked:bind="equal(~attending, \'no\'" />');
        var attending = compute('yes');
        var yes = template({ attending: attending }).firstChild, no = yes.nextSibling;
        QUnit.equal(yes.checked, true, 'initially a yes');
        QUnit.equal(no.checked, false, 'initially unchecked');
        attending('no');
        QUnit.equal(yes.checked, false, 'now not checked');
        QUnit.equal(no.checked, true, 'now checked');
        yes.checked = true;
        domEvents.dispatch(yes, 'change');
        QUnit.equal(attending(), 'yes', 'now it is yes');
        QUnit.equal(yes.checked, true, 'yes is checked');
        QUnit.equal(no.checked, false, 'no is unchecked');
    });
    QUnit.test('Allows one-way binding when passed a non-compute as the first argument', function () {
        var template = stache('<input type="radio" checked:bind="equal(attending, true)" />');
        var attending = compute(false);
        var input = template({ attending: attending }).firstChild;
        QUnit.equal(input.checked, false, 'initially false');
        attending(true);
        QUnit.equal(input.checked, true, 'can be changed to true');
        input.checked = false;
        QUnit.equal(attending(), true, 'does not change compute');
    });
    QUnit.test('Allow multiple expressions to be passed in', function () {
        var template = stache('<input type="radio" checked:bind="equal(~foo, ~bar, true)" />');
        var foo = compute(true);
        var bar = compute(false);
        var input = template({
            foo: foo,
            bar: bar
        }).firstChild;
        QUnit.equal(input.checked, false, 'initially unchecked');
        bar(true);
        QUnit.equal(input.checked, true, 'now checked');
        foo(false);
        bar(false);
        QUnit.equal(input.checked, false, 'now unchecked');
        input.checked = true;
        domEvents.dispatch(input, 'change');
        QUnit.equal(foo(), true, 'computed foo value is true');
        QUnit.equal(bar(), true, 'computed bar value is true');
    });
    QUnit.test('Allow multiple expressions to be passed in without ~', function () {
        var template = stache('<input type="radio" checked:bind="equal(foo, bar, true)" />');
        var foo = compute(true);
        var bar = compute(false);
        var input = template({
            foo: foo,
            bar: bar
        }).firstChild;
        QUnit.equal(input.checked, false, 'initially unchecked');
        bar(true);
        QUnit.equal(input.checked, true, 'now checked');
        foo(false);
        bar(false);
        QUnit.equal(input.checked, false, 'now unchecked');
        input.checked = true;
        domEvents.dispatch(input, 'change');
        QUnit.equal(foo(), true, 'computed foo value is true');
        QUnit.equal(bar(), true, 'computed bar value is true');
    });
});
/*can-stache-converters@4.0.1#test/test*/
define('can-stache-converters@4.0.1#test/test', [
    'require',
    'exports',
    'module',
    './boolean-to-inList_test',
    './index-to-selected_test',
    './selected-to-index_test',
    './string-to-any_test',
    './not_test',
    './either-or_test',
    './equal_test'
], function (require, exports, module) {
    require('./boolean-to-inList_test');
    require('./index-to-selected_test');
    require('./selected-to-index_test');
    require('./string-to-any_test');
    require('./not_test');
    require('./either-or_test');
    require('./equal_test');
});
/*can-compute@4.0.0#proto-compute_test*/
define('can-compute@4.0.0#proto-compute_test', [
    'require',
    'exports',
    'module',
    'steal-qunit',
    'can-compute/proto-compute',
    'can-queues',
    'can-symbol',
    'can-reflect'
], function (require, exports, module) {
    var QUnit = require('steal-qunit');
    var Compute = require('can-compute/proto-compute');
    var queues = require('can-queues');
    var canSymbol = require('can-symbol');
    var canReflect = require('can-reflect');
    QUnit.module('can/Compute');
    test('single value compute', function () {
        expect(2);
        var num = new Compute(1);
        num.bind('change', function (ev, newVal, oldVal) {
            equal(newVal, 2, 'newVal');
            equal(oldVal, 1, 'oldVal');
        });
        num.set(2);
    });
    test('inner computes values are not bound to', function () {
        var num = new Compute(1);
        var outer = new Compute(function () {
            var inner = new Compute(function () {
                return num.get() + 1;
            });
            return 2 * inner.get();
        });
        var handler = function () {
        };
        outer.bind('change', handler);
        stop();
        setTimeout(function () {
            var handlers = num[canSymbol.for('can.meta')].handlers;
            equal(handlers.get([]).length, 1, 'compute only bound to once');
            start();
        }, 50);
    });
    test('compute.truthy', function () {
        var result = 0;
        var num = new Compute(3);
        var truthy = Compute.truthy(num);
        var tester = new Compute(function () {
            if (truthy.get()) {
                return ++result;
            } else {
                return ++result;
            }
        });
        tester.bind('change', function (ev, newVal, oldVal) {
            if (num.get() === 0) {
                equal(newVal, 2, '2 is the new val');
            } else if (num.get() === -1) {
                equal(newVal, 3, '3 is the new val');
            } else {
                ok(false, 'change should not be called');
            }
        });
        equal(tester.get(), 1, 'on bind, we call tester once');
        num.set(2);
        num.set(1);
        num.set(0);
        num.set(-1);
    });
    test('a binding compute does not double read', function () {
        var sourceAge = 30, timesComputeIsCalled = 0;
        var age = new Compute(function (newVal) {
            timesComputeIsCalled++;
            if (timesComputeIsCalled === 1) {
                ok(true, 'reading age to get value');
            } else if (timesComputeIsCalled === 2) {
                equal(newVal, 31, 'the second time should be an update');
            } else if (timesComputeIsCalled === 3) {
                ok(true, 'called after set to get the value');
            } else {
                ok(false, 'You\'ve called the callback ' + timesComputeIsCalled + ' times');
            }
            if (arguments.length) {
                sourceAge = newVal;
            } else {
                return sourceAge;
            }
        });
        var info = new Compute(function () {
            return 'I am ' + age.get();
        });
        var k = function () {
        };
        info.bind('change', k);
        equal(info.get(), 'I am 30');
        age.set(31);
        equal(info.get(), 'I am 31');
    });
    test('cloning a setter compute (#547)', function () {
        var name = new Compute('', function (newVal) {
            return this.txt + newVal;
        });
        var cloned = name.clone({ txt: '.' });
        cloned.set('-');
        equal(cloned.get(), '.-');
    });
    test('compute updated method uses get and old value (#732)', function () {
        expect(9);
        var input = { value: 1 };
        var value = new Compute('', {
            get: function () {
                return input.value;
            },
            set: function (newVal) {
                input.value = newVal;
            },
            on: function (update) {
                input.onchange = update;
            },
            off: function () {
                delete input.onchange;
            }
        });
        equal(value.get(), 1, 'original value');
        ok(!input.onchange, 'nothing bound');
        value.set(2);
        equal(value.get(), 2, 'updated value');
        equal(input.value, 2, 'updated input.value');
        value.bind('change', function (ev, newVal, oldVal) {
            equal(newVal, 3, 'newVal');
            equal(oldVal, 2, 'oldVal');
            value.unbind('change', this.Constructor);
        });
        ok(input.onchange, 'binding to onchange');
        input.value = 3;
        input.onchange({});
        ok(!input.onchange, 'removed binding');
        equal(value.get(), 3);
    });
    test('a compute updated by source changes within a batch is part of that batch', function () {
        var computeA = new Compute('a');
        var computeB = new Compute('b');
        var combined1 = new Compute(function () {
            return computeA.get() + ' ' + computeB.get();
        });
        var combined2 = new Compute(function () {
            return computeA.get() + ' ' + computeB.get();
        });
        var combo = new Compute(function () {
            return combined1.get() + ' ' + combined2.get();
        });
        var callbacks = 0;
        combo.bind('change', function () {
            if (callbacks === 0) {
                ok(true, 'called change once');
            } else {
                ok(false, 'called change multiple times');
            }
            callbacks++;
        });
        queues.batch.start();
        computeA.set('A');
        computeB.set('B');
        queues.batch.stop();
    });
    test('Compute.async can be like a normal getter', function () {
        var first = new Compute('Justin'), last = new Compute('Meyer'), fullName = Compute.async('', function () {
                return first.get() + ' ' + last.get();
            });
        equal(fullName.get(), 'Justin Meyer');
    });
    test('Compute.async operate on single value', function () {
        var a = new Compute(1);
        var b = new Compute(2);
        var obj = Compute.async({}, function (curVal) {
            if (a.get()) {
                curVal.a = a.get();
            } else {
                delete curVal.a;
            }
            if (b.get()) {
                curVal.b = b.get();
            } else {
                delete curVal.b;
            }
            return curVal;
        });
        obj.bind('change', function () {
        });
        deepEqual(obj.get(), {
            a: 1,
            b: 2
        }, 'object has all properties');
        a.set(0);
        deepEqual(obj.get(), { b: 2 }, 'removed a');
        b.set(0);
        deepEqual(obj.get(), {}, 'removed b');
    });
    test('Compute.async async changing value', function () {
        var a = new Compute(1);
        var b = new Compute(2);
        var async = Compute.async(undefined, function (curVal, setVal) {
            if (a.get()) {
                setTimeout(function () {
                    setVal('a');
                }, 10);
            } else if (b.get()) {
                setTimeout(function () {
                    setVal('b');
                }, 10);
            } else {
                return null;
            }
        });
        var changeArgs = [
                {
                    newVal: 'a',
                    oldVal: undefined,
                    run: function () {
                        a.set(0);
                    }
                },
                {
                    newVal: 'b',
                    oldVal: 'a',
                    run: function () {
                        b.set(0);
                    }
                },
                {
                    newVal: null,
                    oldVal: 'b',
                    run: function () {
                        start();
                    }
                }
            ], changeNum = 0;
        stop();
        async.bind('change', function (ev, newVal, oldVal) {
            var data = changeArgs[changeNum++];
            equal(newVal, data.newVal, 'newVal is correct');
            equal(oldVal, data.oldVal, 'oldVal is correct');
            setTimeout(data.run, 10);
        });
    });
    test('Compute.async read without binding', function () {
        var source = new Compute(1);
        var async = Compute.async([], function (curVal, setVal) {
            curVal.push(source.get());
            return curVal;
        });
        ok(async.get(), 'calling async worked');
    });
    test('Compute.async set uses last set or initial value', function () {
        var add = new Compute(1);
        var fnCount = 0;
        var async = Compute.async(10, function (curVal) {
            switch (fnCount++) {
            case 0:
                equal(curVal, 10);
                break;
            case 1:
                equal(curVal, 20);
                break;
            case 2:
                equal(curVal, 30, 'on bind');
                break;
            case 3:
                equal(curVal, 30, 'on bind');
                break;
            }
            return curVal + add.get();
        });
        equal(async.get(), 11, 'initial value');
        async.set(20);
        async.bind('change', function () {
        });
        async.set(20);
        async.set(30);
    });
    test('Change propagation in a batch with late bindings (#2412)', function () {
        var rootA = new Compute('a');
        var rootB = new Compute('b');
        var childA = new Compute(function () {
            return 'childA' + rootA.get();
        });
        var grandChild = new Compute(function () {
            var b = rootB.get();
            if (b === 'b') {
                return 'grandChild->b';
            }
            var a = childA.get();
            return 'grandChild->' + a;
        });
        childA.bind('change', function (ev, newVal, oldVal) {
        });
        grandChild.bind('change', function (ev, newVal, oldVal) {
            equal(newVal, 'grandChild->childAA');
        });
        queues.batch.start();
        rootA.set('A');
        rootB.set('B');
        queues.batch.stop();
    });
    if (Compute.prototype.trace) {
        test('trace', function () {
            var rootA = new Compute('a');
            var rootB = new Compute('b');
            var childA = new Compute(function () {
                return 'childA' + rootA.get();
            });
            var fn = function () {
                var b = rootB.get();
                if (b === 'b') {
                    return 'grandChild->b';
                }
                var a = childA.get();
                return 'grandChild->' + a;
            };
            var grandChild = new Compute(fn);
            childA.bind('change', function (ev, newVal, oldVal) {
            });
            grandChild.bind('change', function (ev, newVal, oldVal) {
                equal(newVal, 'grandChild->childAA');
            });
            var out = grandChild.trace();
            equal(out.definition, fn, 'got the right function');
            equal(out.computeValue, 'grandChild->b');
            grandChild.log();
            queues.batch.start();
            rootA.set('A');
            rootB.set('B');
            queues.batch.stop();
            grandChild.log();
        });
    }
    test('works with can-reflect', 5, function () {
        var c = new Compute(0);
        QUnit.equal(canReflect.getValue(c), 0, 'unbound value');
        QUnit.ok(canReflect.isValueLike(c), 'isValueLike is true');
        QUnit.ok(!canReflect.valueHasDependencies(c), 'valueHasDependencies -- false');
        var d = new Compute(function () {
            return c.get();
        });
        d.on('change', function () {
        });
        QUnit.ok(canReflect.valueHasDependencies(d), 'valueHasDependencies -- true');
        c.set(1);
        QUnit.equal(canReflect.getValue(d), 1, 'bound value');
        c.set(2);
    });
    QUnit.test('can-reflect setValue', function () {
        var a = new Compute('a');
        canReflect.setValue(a, 'A');
        QUnit.equal(a.get(), 'A', 'compute');
    });
    QUnit.test('registered symbols', function () {
        var a = new Compute('a');
        ok(a[canSymbol.for('can.isValueLike')], 'can.isValueLike');
        equal(a[canSymbol.for('can.getValue')](), 'a', 'can.getValue');
        a[canSymbol.for('can.setValue')]('b');
        equal(a.get(), 'b', 'can.setValue');
        function handler(val) {
            equal(val, 'c', 'can.onValue');
        }
        a[canSymbol.for('can.onValue')](handler);
        a.set('c');
        a[canSymbol.for('can.offValue')](handler);
        a.set('d');
    });
});
/*can-util@3.11.2#dom/events/events*/
define('can-util@3.11.2#dom/events/events', [
    'require',
    'exports',
    'module',
    'can-globals/document/document',
    'can-globals/is-browser-window/is-browser-window',
    '../../js/is-plain-object/is-plain-object',
    'can-log/dev/dev'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        'use strict';
        var getDocument = require('can-globals/document/document');
        var isBrowserWindow = require('can-globals/is-browser-window/is-browser-window');
        var isPlainObject = require('../../js/is-plain-object/is-plain-object');
        var fixSyntheticEventsOnDisabled = false;
        var dev = require('can-log/dev/dev');
        function isDispatchingOnDisabled(element, ev) {
            var isInsertedOrRemoved = isPlainObject(ev) ? ev.type === 'inserted' || ev.type === 'removed' : ev === 'inserted' || ev === 'removed';
            var isDisabled = !!element.disabled;
            return isInsertedOrRemoved && isDisabled;
        }
        module.exports = {
            addEventListener: function () {
                this.addEventListener.apply(this, arguments);
            },
            removeEventListener: function () {
                this.removeEventListener.apply(this, arguments);
            },
            canAddEventListener: function () {
                return this.nodeName && (this.nodeType === 1 || this.nodeType === 9) || this === window;
            },
            dispatch: function (event, args, bubbles) {
                var ret;
                var dispatchingOnDisabled = fixSyntheticEventsOnDisabled && isDispatchingOnDisabled(this, event);
                var doc = this.ownerDocument || getDocument();
                var ev = doc.createEvent('HTMLEvents');
                var isString = typeof event === 'string';
                ev.initEvent(isString ? event : event.type, bubbles === undefined ? true : bubbles, false);
                if (!isString) {
                    for (var prop in event) {
                        if (ev[prop] === undefined) {
                            ev[prop] = event[prop];
                        }
                    }
                }
                if (this.disabled === true && ev.type !== 'fix_synthetic_events_on_disabled_test') {
                }
                ev.args = args;
                if (dispatchingOnDisabled) {
                    this.disabled = false;
                }
                ret = this.dispatchEvent(ev);
                if (dispatchingOnDisabled) {
                    this.disabled = true;
                }
                return ret;
            }
        };
        (function () {
            if (!isBrowserWindow()) {
                return;
            }
            var testEventName = 'fix_synthetic_events_on_disabled_test';
            var input = document.createElement('input');
            input.disabled = true;
            var timer = setTimeout(function () {
                fixSyntheticEventsOnDisabled = true;
            }, 50);
            var onTest = function onTest() {
                clearTimeout(timer);
                module.exports.removeEventListener.call(input, testEventName, onTest);
            };
            module.exports.addEventListener.call(input, testEventName, onTest);
            try {
                module.exports.dispatch.call(input, testEventName, [], false);
            } catch (e) {
                onTest();
                fixSyntheticEventsOnDisabled = true;
            }
        }());
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-util@3.11.2#dom/dispatch/dispatch*/
define('can-util@3.11.2#dom/dispatch/dispatch', [
    'require',
    'exports',
    'module',
    '../events/events'
], function (require, exports, module) {
    'use strict';
    var domEvents = require('../events/events');
    module.exports = function () {
        return domEvents.dispatch.apply(this, arguments);
    };
});
/*can-compute@4.0.0#can-compute_test*/
define('can-compute@4.0.0#can-compute_test', [
    'require',
    'exports',
    'module',
    './proto-compute_test',
    'can-compute',
    'steal-qunit',
    'can-observation-recorder',
    'can-util/dom/dispatch/dispatch',
    'can-symbol',
    'can-reflect',
    'can-event-queue/map/map',
    'can-queues'
], function (require, exports, module) {
    require('./proto-compute_test');
    var compute = require('can-compute');
    var QUnit = require('steal-qunit');
    var ObservationRecorder = require('can-observation-recorder');
    var domDispatch = require('can-util/dom/dispatch/dispatch');
    var canSymbol = require('can-symbol');
    var canReflect = require('can-reflect');
    var eventQueue = require('can-event-queue/map/map');
    var queues = require('can-queues');
    var metaSymbol = canSymbol.for('can.meta');
    QUnit.module('can/compute');
    test('single value compute', function () {
        var num = compute(1);
        num.on('change', function (ev, newVal, oldVal) {
            equal(newVal, 2, 'newVal');
            equal(oldVal, 1, 'oldVal');
        });
        num(2);
    });
    test('inner computes values are not bound to', function () {
        var num = compute(1);
        var outer = compute(function () {
            var inner = compute(function () {
                return num() + 1;
            });
            return 2 * inner();
        });
        var handler = function () {
        };
        outer.on('change', handler);
        stop();
        setTimeout(function () {
            equal(num.computeInstance[metaSymbol].handlers.get([]).length, 1, 'inner compute only bound once');
            equal(outer.computeInstance[metaSymbol].handlers.get([]).length, 1, 'outer compute only bound once');
            start();
        }, 50);
    });
    test('compute.truthy', function () {
        var result = 0;
        var numValue;
        var num = compute(numValue = 3);
        var truthy = compute.truthy(num);
        var tester = compute(function () {
            if (truthy()) {
                return ++result;
            } else {
                return ++result;
            }
        });
        tester.addEventListener('change', function (ev, newVal, oldVal) {
            if (num() === 0) {
                equal(newVal, 2, '2 is the new val');
            } else if (num() === -1) {
                equal(newVal, 3, '3 is the new val');
            } else {
                ok(false, 'change should not be called');
            }
        });
        equal(tester(), 1, 'on bind, we call tester once');
        num(numValue = 2);
        num(numValue = 1);
        num(numValue = 0);
        num(numValue = -1);
    });
    test('a binding compute does not double read', function () {
        var sourceAge = 30, timesComputeIsCalled = 0;
        var age = compute(function (newVal) {
            timesComputeIsCalled++;
            if (timesComputeIsCalled === 1) {
                ok(true, 'reading age to get value');
            } else if (timesComputeIsCalled === 2) {
                equal(newVal, 31, 'the second time should be an update');
            } else if (timesComputeIsCalled === 3) {
                ok(true, 'called after set to get the value');
            } else {
                ok(false, 'You\'ve called the callback ' + timesComputeIsCalled + ' times');
            }
            if (arguments.length) {
                sourceAge = newVal;
            } else {
                return sourceAge;
            }
        });
        var info = compute(function () {
            return 'I am ' + age();
        });
        var k = function () {
        };
        info.bind('change', k);
        equal(info(), 'I am 30');
        age(31);
        equal(info(), 'I am 31');
    });
    test('cloning a setter compute (#547)', function () {
        var name = compute('', function (newVal) {
            return this.txt + newVal;
        });
        var cloned = name.clone({ txt: '.' });
        cloned('-');
        equal(cloned(), '.-');
    });
    test('compute updated method uses get and old value (#732)', function () {
        expect(9);
        var input = { value: 1 };
        var value = compute('', {
            get: function () {
                return input.value;
            },
            set: function (newVal) {
                input.value = newVal;
            },
            on: function (update) {
                input.onchange = update;
            },
            off: function () {
                delete input.onchange;
            }
        });
        equal(value(), 1, 'original value');
        ok(!input.onchange, 'nothing bound');
        value(2);
        equal(value(), 2, 'updated value');
        equal(input.value, 2, 'updated input.value');
        function handler(ev, newVal, oldVal) {
            equal(newVal, 3, 'newVal');
            equal(oldVal, 2, 'oldVal');
            value.unbind('change', handler);
        }
        value.bind('change', handler);
        ok(input.onchange, 'binding to onchange');
        input.value = 3;
        input.onchange({});
        ok(!input.onchange, 'removed binding');
        equal(value(), 3);
    });
    test('a compute updated by source changes within a batch is part of that batch', function () {
        var computeA = compute('a');
        var computeB = compute('b');
        var combined1 = compute(function combined1() {
            return computeA() + ' ' + computeB();
        });
        var combined2 = compute(function combined2() {
            return computeA() + ' ' + computeB();
        });
        var combo = compute(function combo() {
            return combined1() + ' ' + combined2();
        });
        var callbacks = 0;
        combo.bind('change', function () {
            if (callbacks === 0) {
                ok(true, 'called change once');
            } else {
                ok(false, 'called change multiple times');
            }
            callbacks++;
        });
        queues.batch.start();
        computeA('A');
        computeB('B');
        queues.batch.stop();
    });
    test('compute.async can be like a normal getter', function () {
        var first = compute('Justin'), last = compute('Meyer'), fullName = compute.async('', function () {
                return first() + ' ' + last();
            });
        equal(fullName(), 'Justin Meyer');
    });
    test('compute.async operate on single value', function () {
        var a = compute(1);
        var b = compute(2);
        var obj = compute.async({}, function (curVal) {
            if (a()) {
                curVal.a = a();
            } else {
                delete curVal.a;
            }
            if (b()) {
                curVal.b = b();
            } else {
                delete curVal.b;
            }
            return curVal;
        });
        obj.bind('change', function () {
        });
        deepEqual(obj(), {
            a: 1,
            b: 2
        }, 'object has all properties');
        a(0);
        deepEqual(obj(), { b: 2 }, 'removed a');
        b(0);
        deepEqual(obj(), {}, 'removed b');
    });
    test('compute.async async changing value', function () {
        var a = compute(1);
        var b = compute(2);
        var async = compute.async(undefined, function (curVal, setVal) {
            if (a()) {
                setTimeout(function () {
                    setVal('a');
                }, 10);
            } else if (b()) {
                setTimeout(function () {
                    setVal('b');
                }, 10);
            } else {
                return null;
            }
        });
        var changeArgs = [
                {
                    newVal: 'a',
                    oldVal: undefined,
                    run: function () {
                        a(0);
                    }
                },
                {
                    newVal: 'b',
                    oldVal: 'a',
                    run: function () {
                        b(0);
                    }
                },
                {
                    newVal: null,
                    oldVal: 'b',
                    run: function () {
                        start();
                    }
                }
            ], changeNum = 0;
        stop();
        async.bind('change', function (ev, newVal, oldVal) {
            var data = changeArgs[changeNum++];
            equal(newVal, data.newVal, 'newVal is correct');
            equal(oldVal, data.oldVal, 'oldVal is correct');
            setTimeout(data.run, 10);
        });
    });
    test('compute.async read without binding', function () {
        var source = compute(1);
        var async = compute.async([], function (curVal, setVal) {
            curVal.push(source());
            return curVal;
        });
        ok(async(), 'calling async worked');
    });
    test('bug with nested computes and batch ordering (#1519)', function () {
        var root = compute('a');
        var isA = compute(function () {
            return root() === 'a';
        });
        var isB = compute(function () {
            return root() === 'b';
        });
        var combined = compute(function () {
            var valA = isA(), valB = isB();
            return valA || valB;
        });
        equal(combined(), true);
        combined.bind('change', function () {
        });
        queues.batch.start();
        root('b');
        queues.batch.stop();
        equal(combined(), true);
    });
    test('compute change handler context is set to the function not compute', function () {
        var comp = compute(null);
        comp.bind('change', function () {
            equal(typeof this, 'function');
        });
        comp('test');
    });
    test('Calling .unbind() on un-bound compute does not throw an error', function () {
        var count = compute(0);
        count.unbind('change');
        ok(true, 'No error was thrown');
    });
    test('dependent computes update in the right order (2093)', function () {
        var root = compute('a'), childB = compute(function () {
                return root();
            }), combine = compute(function () {
                return root() + childB();
            });
        combine.bind('change', function (ev, newVal) {
            equal(newVal, 'bb', 'concat changed');
        });
        root('b');
    });
    test('dependent computes update in the right order with a batch (#2093)', function () {
        var root = compute('a'), child = compute(function () {
                return root();
            }), child2 = compute(function () {
                return root();
            }), grandChild = compute(function () {
                return child();
            }), combine = compute(function () {
                return child2() + grandChild();
            });
        combine.bind('change', function (ev, newVal) {
            equal(newVal, 'bb', 'concat changed');
        });
        queues.batch.start();
        root('b');
        queues.batch.stop();
    });
    test('bug with nested computes and batch ordering (#1519)', function () {
        var root = compute('a');
        var isA = compute(function () {
            return root() === 'a';
        });
        var isB = compute(function () {
            return root() === 'b';
        });
        var combined = compute(function () {
            var valA = isA(), valB = isB();
            return valA || valB;
        });
        equal(combined(), true);
        combined.bind('change', function () {
        });
        queues.batch.start();
        root('b');
        queues.batch.stop();
        equal(combined(), true);
    });
    test('binding, unbinding, and rebinding works after a timeout (#2095)', function () {
        var root = compute(1), derived = compute(function () {
                return root();
            });
        var change = function () {
        };
        derived.bind('change', change);
        derived.unbind('change', change);
        stop();
        setTimeout(function () {
            derived.bind('change', function (ev, newVal, oldVal) {
                equal(newVal, 2, 'updated');
                start();
            });
            root(2);
        }, 10);
    });
    test('ObservationRecorder.isRecording observes doesn\'t understand ObservationRecorder.ignore (#2099)', function () {
        expect(0);
        var c = compute(1);
        c.computeInstance.bind = function () {
            ok(false);
        };
        var outer = compute(function () {
            ObservationRecorder.ignore(function () {
                c();
            })();
        });
        outer.bind('change', function () {
        });
    });
    test('handles missing update order items (#2121)', function () {
        var root1 = compute('root1'), child1 = compute(function () {
                return root1();
            }), root2 = compute('root2'), child2 = compute(function () {
                return root2();
            }), gc2 = compute(function () {
                return child2();
            }), res = compute(function () {
                return child1() + gc2();
            });
        res.bind('change', function (ev, newVal) {
            equal(newVal, 'ROOT1root2');
        });
        queues.batch.start();
        root1('ROOT1');
        queues.batch.stop();
    });
    test('compute should not fire event when NaN is set multiple times #2128', function () {
        var c = compute(NaN);
        compute.bind('change', function () {
            ok(false, 'change event should not be fired');
        });
        ok(isNaN(c()));
        c(NaN);
    });
    test('eventQueue.afterPreviousEvents firing too late (#2198)', function () {
        var compute1 = compute('a'), compute2 = compute('b');
        var derived = compute(function () {
            return compute1().toUpperCase();
        });
        derived.bind('change', function () {
            var afterPrevious = false;
            compute2.bind('change', function () {
                ok(afterPrevious, 'after previous should have fired so we would respond to this event');
            });
            queues.batch.start();
            queues.batch.stop();
            eventQueue.afterPreviousEvents(function () {
                afterPrevious = true;
            });
            compute2('c');
        });
        queues.batch.start();
        compute1('x');
        queues.batch.stop();
    });
    test('Async getter causes infinite loop (#28)', function () {
        var changeCount = 0;
        var idCompute = compute(1);
        stop();
        var comp = compute.async(undefined, function (last, resolve) {
            var id = idCompute();
            setTimeout(function () {
                resolve(changeCount + '|' + id);
            }, 1);
            resolve(changeCount + '|' + id);
        }, null);
        comp.bind('change', function (ev, newVal) {
            changeCount++;
            comp();
        });
        setTimeout(function () {
            idCompute(2);
        }, 50);
        var checkChangeCount = function () {
            if (changeCount === 4) {
                equal(changeCount, 4);
                start();
            } else {
                setTimeout(checkChangeCount, 10);
            }
        };
        checkChangeCount();
    });
    test('Listening to input change', function () {
        var input = document.createElement('input');
        var comp = compute(input, 'value', 'input');
        comp.on('change', function () {
            ok(true, 'it changed');
        });
        input.value = 'foo';
        domDispatch.call(input, 'input');
    });
    test('Setting an input to change', function () {
        var input = document.createElement('input');
        var comp = compute(input, 'value', 'input');
        comp('foo');
        ok(input.value === 'foo');
    });
    test('compute.truthy with functions (canjs/can-stache#172)', function () {
        var func = compute(function () {
            return function () {
                ok(false, 'should not be run');
            };
        });
        var truthy = compute.truthy(func);
        equal(truthy(), true);
    });
    test('works with can-reflect', 5, function () {
        var c = compute(0);
        QUnit.equal(canReflect.getValue(c), 0, 'unbound value');
        var handler = function (newValue) {
            QUnit.equal(newValue, 1, 'observed new value');
            canReflect.offValue(c, handler);
        };
        QUnit.ok(canReflect.isValueLike(c), 'isValueLike is true');
        canReflect.onValue(c, handler);
        QUnit.equal(canReflect.valueHasDependencies(c), undefined, 'valueHasDependencies');
        c(1);
        QUnit.equal(canReflect.getValue(c), 1, 'bound value');
        c(2);
    });
    QUnit.test('can-reflect valueHasDependencies', function () {
        var a = compute('a');
        var b = compute('b');
        var c = compute(function () {
            return a() + b();
        });
        c.on('change', function () {
        });
        QUnit.ok(canReflect.valueHasDependencies(c), 'valueHasDependencies');
    });
    QUnit.test('registered symbols', function () {
        var a = compute('a');
        ok(a[canSymbol.for('can.isValueLike')], 'can.isValueLike');
        equal(a[canSymbol.for('can.getValue')](), 'a', 'can.getValue');
        a[canSymbol.for('can.setValue')]('b');
        equal(a(), 'b', 'can.setValue');
        function handler(val) {
            equal(val, 'c', 'can.onValue');
        }
        a[canSymbol.for('can.onValue')](handler);
        a('c');
        a[canSymbol.for('can.offValue')](handler);
        a('d');
    });
    QUnit.test('can-reflect setValue', function () {
        var a = compute('a');
        canReflect.setValue(a, 'A');
        QUnit.equal(a(), 'A', 'compute');
    });
    QUnit.test('Calling .unbind() with no arguments should tear down all event handlers', function () {
        var count = compute(0);
        count.on('change', function () {
            console.log('Count changed');
        });
        var handlers = count.computeInstance[canSymbol.for('can.meta')].handlers;
        QUnit.equal(handlers.get(['change']).length, 1, 'Change event added');
        count.unbind();
        QUnit.equal(handlers.get(['change']).length, 0, 'All events for compute removed');
    });
    QUnit.test('.off() unbinds a given handler', function () {
        var handler = function () {
        };
        var c = compute('foo');
        c.on('change', handler);
        var handlers = c.computeInstance[canSymbol.for('can.meta')].handlers;
        QUnit.equal(handlers.get(['change']).length, 1, 'handler added');
        c.off('change', handler);
        QUnit.equal(handlers.get(['change']).length, 0, 'hander removed');
    });
});
/*can-map@4.0.0#bubble*/
define('can-map@4.0.0#bubble', [
    'require',
    'exports',
    'module',
    'can-event-queue/map/map',
    'can-util/js/make-array/make-array',
    'can-reflect',
    'can-util/js/is-empty-object/is-empty-object'
], function (require, exports, module) {
    var canEvent = require('can-event-queue/map/map');
    var makeArray = require('can-util/js/make-array/make-array');
    var canReflect = require('can-reflect');
    var isEmptyObject = require('can-util/js/is-empty-object/is-empty-object');
    var bubble = {
        bind: function (parent, eventName) {
            if (!parent.__inSetup) {
                var bubbleEvents = bubble.events(parent, eventName), len = bubbleEvents.length, bubbleEvent;
                if (!parent._bubbleBindings) {
                    parent._bubbleBindings = {};
                }
                for (var i = 0; i < len; i++) {
                    bubbleEvent = bubbleEvents[i];
                    if (!parent._bubbleBindings[bubbleEvent]) {
                        parent._bubbleBindings[bubbleEvent] = 1;
                        bubble.childrenOf(parent, bubbleEvent);
                    } else {
                        parent._bubbleBindings[bubbleEvent]++;
                    }
                }
            }
        },
        unbind: function (parent, eventName) {
            var bubbleEvents = bubble.events(parent, eventName), len = bubbleEvents.length, bubbleEvent;
            for (var i = 0; i < len; i++) {
                bubbleEvent = bubbleEvents[i];
                if (parent._bubbleBindings) {
                    parent._bubbleBindings[bubbleEvent]--;
                }
                if (parent._bubbleBindings && !parent._bubbleBindings[bubbleEvent]) {
                    delete parent._bubbleBindings[bubbleEvent];
                    bubble.teardownChildrenFrom(parent, bubbleEvent);
                    if (isEmptyObject(parent._bubbleBindings)) {
                        delete parent._bubbleBindings;
                    }
                }
            }
        },
        add: function (parent, child, prop) {
            if (canReflect.isObservableLike(child) && canReflect.isMapLike(child) && parent._bubbleBindings) {
                for (var eventName in parent._bubbleBindings) {
                    if (parent._bubbleBindings[eventName]) {
                        bubble.teardownFromParent(parent, child, eventName);
                        bubble.toParent(child, parent, prop, eventName);
                    }
                }
            }
        },
        addMany: function (parent, children) {
            for (var i = 0, len = children.length; i < len; i++) {
                bubble.add(parent, children[i], i);
            }
        },
        remove: function (parent, child) {
            if (canReflect.isObservableLike(child) && canReflect.isMapLike(child) && parent._bubbleBindings) {
                for (var eventName in parent._bubbleBindings) {
                    if (parent._bubbleBindings[eventName]) {
                        bubble.teardownFromParent(parent, child, eventName);
                    }
                }
            }
        },
        removeMany: function (parent, children) {
            for (var i = 0, len = children.length; i < len; i++) {
                bubble.remove(parent, children[i]);
            }
        },
        set: function (parent, prop, value, current) {
            if (canReflect.isObservableLike(value) && canReflect.isMapLike(value)) {
                bubble.add(parent, value, prop);
            }
            if (canReflect.isObservableLike(current) && canReflect.isMapLike(current)) {
                bubble.remove(parent, current);
            }
            return value;
        },
        events: function (map, boundEventName) {
            return map.constructor._bubbleRule(boundEventName, map);
        },
        toParent: function (child, parent, prop, eventName) {
            canEvent.listenTo.call(parent, child, eventName, function () {
                var args = makeArray(arguments), ev = args.shift();
                args[0] = (canReflect.isObservableLike(parent) && canReflect.isListLike(parent) ? parent.indexOf(child) : prop) + (args[0] ? '.' + args[0] : '');
                ev.triggeredNS = ev.triggeredNS || {};
                if (ev.triggeredNS[parent._cid]) {
                    return;
                }
                ev.triggeredNS[parent._cid] = true;
                canEvent.dispatch.call(parent, ev, args);
                if (eventName === 'change') {
                    canEvent.dispatch.call(parent, args[0], [
                        args[2],
                        args[3]
                    ]);
                }
            });
        },
        childrenOf: function (parent, eventName) {
            parent._each(function (child, prop) {
                if (child && child.bind) {
                    bubble.toParent(child, parent, prop, eventName);
                }
            });
        },
        teardownFromParent: function (parent, child, eventName) {
            if (child && child.unbind) {
                canEvent.stopListening.call(parent, child, eventName);
            }
        },
        teardownChildrenFrom: function (parent, eventName) {
            parent._each(function (child) {
                bubble.teardownFromParent(parent, child, eventName);
            });
        },
        isBubbling: function (parent, eventName) {
            return parent._bubbleBindings && parent._bubbleBindings[eventName];
        }
    };
    module.exports = bubble;
});
/*can-map@4.0.0#map-helpers*/
define('can-map@4.0.0#map-helpers', [
    'require',
    'exports',
    'module',
    'can-util/js/is-plain-object/is-plain-object',
    'can-util/js/is-promise/is-promise',
    'can-cid',
    'can-util/js/assign/assign',
    'can-reflect'
], function (require, exports, module) {
    var isPlainObject = require('can-util/js/is-plain-object/is-plain-object');
    var isPromise = require('can-util/js/is-promise/is-promise');
    var CID = require('can-cid');
    var assign = require('can-util/js/assign/assign');
    var canReflect = require('can-reflect');
    var madeMap = null;
    var teardownMap = function () {
        for (var cid in madeMap) {
            if (madeMap[cid].added) {
                delete madeMap[cid].obj._cid;
            }
        }
        madeMap = null;
    };
    var mapHelpers = {
        attrParts: function (attr, keepKey) {
            if (keepKey) {
                return [attr];
            }
            return typeof attr === 'object' ? attr : ('' + attr).split('.');
        },
        canMakeObserve: function (obj) {
            return obj && !isPromise(obj) && (Array.isArray(obj) || isPlainObject(obj));
        },
        reflectSerialize: function (unwrapped) {
            this.forEach(function (val, name) {
                if (this.___serialize) {
                    val = this.___serialize(name, val);
                } else {
                    val = canReflect.serialize(val);
                }
                if (val !== undefined) {
                    unwrapped[name] = val;
                }
            }, this);
            return unwrapped;
        },
        reflectUnwrap: function (unwrapped) {
            this.forEach(function (value, key) {
                if (value !== undefined) {
                    unwrapped[key] = canReflect.unwrap(value);
                }
            });
            return unwrapped;
        },
        removeSpecialKeys: function (map) {
            if (map) {
                [
                    '_data',
                    'constructor',
                    '_cid',
                    '__bindEvents'
                ].forEach(function (key) {
                    delete map[key];
                });
            }
            return map;
        },
        define: null,
        addComputedAttr: function (map, attrName, compute) {
            map._computedAttrs[attrName] = {
                compute: compute,
                count: 0,
                handler: function (newVal, oldVal) {
                    map._triggerChange(attrName, 'set', newVal, oldVal);
                }
            };
        },
        addToMap: function addToMap(obj, instance) {
            var teardown;
            if (!madeMap) {
                teardown = teardownMap;
                madeMap = {};
            }
            var hasCid = obj._cid;
            var cid = CID(obj);
            if (!madeMap[cid]) {
                madeMap[cid] = {
                    obj: obj,
                    instance: instance,
                    added: !hasCid
                };
            }
            return teardown;
        },
        getMapFromObject: function (obj) {
            return madeMap && madeMap[obj._cid] && madeMap[obj._cid].instance;
        },
        twoLevelDeepExtend: function (destination, source) {
            for (var prop in source) {
                destination[prop] = destination[prop] || {};
                assign(destination[prop], source[prop]);
            }
        }
    };
    module.exports = exports = mapHelpers;
});
/*can-util@3.11.2#js/cid-set/cid-set*/
define('can-util@3.11.2#js/cid-set/cid-set', [
    'require',
    'exports',
    'module',
    'can-cid/set/set'
], function (require, exports, module) {
    'use strict';
    module.exports = require('can-cid/set/set');
});
/*can-cid@1.1.2#map/map*/
define('can-cid@1.1.2#map/map', [
    'require',
    'exports',
    'module',
    '../can-cid',
    '../helpers'
], function (require, exports, module) {
    'use strict';
    var getCID = require('../can-cid').get;
    var helpers = require('../helpers');
    var CIDMap;
    if (typeof Map !== 'undefined') {
        CIDMap = Map;
    } else {
        var CIDMap = function () {
            this.values = {};
        };
        CIDMap.prototype.set = function (key, value) {
            this.values[getCID(key)] = {
                key: key,
                value: value
            };
        };
        CIDMap.prototype['delete'] = function (key) {
            var has = getCID(key) in this.values;
            if (has) {
                delete this.values[getCID(key)];
            }
            return has;
        };
        CIDMap.prototype.forEach = function (cb, thisArg) {
            helpers.each(this.values, function (pair) {
                return cb.call(thisArg || this, pair.value, pair.key, this);
            }, this);
        };
        CIDMap.prototype.has = function (key) {
            return getCID(key) in this.values;
        };
        CIDMap.prototype.get = function (key) {
            var obj = this.values[getCID(key)];
            return obj && obj.value;
        };
        CIDMap.prototype.clear = function () {
            return this.values = {};
        };
        Object.defineProperty(CIDMap.prototype, 'size', {
            get: function () {
                var size = 0;
                helpers.each(this.values, function () {
                    size++;
                });
                return size;
            }
        });
    }
    module.exports = CIDMap;
});
/*can-util@3.11.2#js/cid-map/cid-map*/
define('can-util@3.11.2#js/cid-map/cid-map', [
    'require',
    'exports',
    'module',
    'can-cid/map/map'
], function (require, exports, module) {
    'use strict';
    module.exports = require('can-cid/map/map');
});
/*can-map@4.0.0#can-map*/
define('can-map@4.0.0#can-map', [
    'require',
    'exports',
    'module',
    './bubble',
    './map-helpers',
    'can-event-queue/map/map',
    'can-event-queue/type/type',
    'can-construct',
    'can-observation-recorder',
    'can-stache-key',
    'can-compute',
    'can-util/js/single-reference/single-reference',
    'can-namespace',
    'can-util/js/dev/dev',
    'can-cid',
    'can-util/js/deep-assign/deep-assign',
    'can-util/js/assign/assign',
    'can-types',
    'can-reflect',
    'can-symbol',
    'can-util/js/cid-set/cid-set',
    'can-util/js/cid-map/cid-map',
    'can-queues'
], function (require, exports, module) {
    var bubble = require('./bubble');
    var mapHelpers = require('./map-helpers');
    var canEvent = require('can-event-queue/map/map');
    var addTypeEvents = require('can-event-queue/type/type');
    var Construct = require('can-construct');
    var ObservationRecorder = require('can-observation-recorder');
    var ObserveReader = require('can-stache-key');
    var canCompute = require('can-compute');
    var singleReference = require('can-util/js/single-reference/single-reference');
    var namespace = require('can-namespace');
    var dev = require('can-util/js/dev/dev');
    var CID = require('can-cid');
    var deepAssign = require('can-util/js/deep-assign/deep-assign');
    var assign = require('can-util/js/assign/assign');
    var types = require('can-types');
    var canReflect = require('can-reflect');
    var canSymbol = require('can-symbol');
    var CIDSet = require('can-util/js/cid-set/cid-set');
    var CIDMap = require('can-util/js/cid-map/cid-map');
    var canQueues = require('can-queues');
    var unobservable = { 'constructor': true };
    var hasOwnProperty = {}.hasOwnProperty;
    var Map = Construct.extend({
        setup: function (baseMap) {
            Construct.setup.apply(this, arguments);
            this._computedPropertyNames = [];
            if (Map) {
                addTypeEvents(this);
                this[canSymbol.for('can.defineInstanceKey')] = function (prop, definition) {
                    if (definition.value !== undefined) {
                        this.defaults[prop] = definition.value;
                    }
                    if (definition.enumerable === false) {
                        this.enumerable[prop] = false;
                    }
                };
                if (!this.defaults) {
                    this.defaults = {};
                }
                if (!this.enumerable) {
                    this.enumerable = {};
                }
                for (var prop in this.prototype) {
                    if (prop !== 'define' && prop !== 'constructor' && (typeof this.prototype[prop] !== 'function' && !canReflect.isValueLike(this.prototype[prop]) || this.prototype[prop].prototype instanceof Construct)) {
                        this.defaults[prop] = this.prototype[prop];
                    } else if (canReflect.isObservableLike(this.prototype[prop])) {
                        this._computedPropertyNames.push(prop);
                    }
                }
                if (mapHelpers.define) {
                    mapHelpers.define(this, baseMap.prototype.define);
                }
            }
        },
        shortName: 'Map',
        _bubbleRule: function (eventName) {
            return eventName === 'change' || eventName.indexOf('.') >= 0 ? ['change'] : [];
        },
        addEventListener: canEvent.addEventListener,
        removeEventListener: canEvent.removeEventListener,
        keys: function (map) {
            return canReflect.getOwnEnumerableKeys(map);
        }
    }, {
        setup: function (obj) {
            if (canReflect.isObservableLike(obj) && typeof obj.serialize === 'function') {
                obj = obj.serialize();
            }
            this._data = Object.create(null);
            CID(this, '.map');
            this._setupComputedProperties();
            var teardownMapping = obj && mapHelpers.addToMap(obj, this);
            var defaultValues = this._setupDefaults(obj);
            var data = assign(deepAssign(true, {}, defaultValues), obj);
            this.attr(data);
            if (teardownMapping) {
                teardownMapping();
            }
        },
        _setupComputedProperties: function () {
            this._computedAttrs = Object.create(null);
            var computes = this.constructor._computedPropertyNames;
            for (var i = 0, len = computes.length; i < len; i++) {
                var attrName = computes[i];
                mapHelpers.addComputedAttr(this, attrName, this[attrName]);
            }
        },
        _setupDefaults: function () {
            return this.constructor.defaults || {};
        },
        attr: function (attr, val) {
            var type = typeof attr;
            if (attr === undefined) {
                return this._getAttrs();
            } else if (type !== 'string' && type !== 'number') {
                return this._setAttrs(attr, val);
            } else if (arguments.length === 1) {
                return this._get(attr + '');
            } else {
                this._set(attr + '', val);
                return this;
            }
        },
        _get: function (attr) {
            var dotIndex = attr.indexOf('.');
            if (dotIndex >= 0) {
                var value = this.___get(attr);
                if (value !== undefined) {
                    ObservationRecorder.add(this, attr);
                    return value;
                }
                var first = attr.substr(0, dotIndex), second = attr.substr(dotIndex + 1);
                var current = this.__get(first);
                return current && canReflect.getKeyValue(current, second);
            } else {
                return this.__get(attr);
            }
        },
        __get: function (attr) {
            if (!unobservable[attr] && !this._computedAttrs[attr]) {
                ObservationRecorder.add(this, attr);
            }
            return this.___get(attr);
        },
        ___get: function (attr) {
            if (attr !== undefined) {
                var computedAttr = this._computedAttrs[attr];
                if (computedAttr) {
                    return canReflect.getValue(computedAttr.compute);
                } else {
                    return hasOwnProperty.call(this._data, attr) ? this._data[attr] : undefined;
                }
            } else {
                return this._data;
            }
        },
        _set: function (attr, value, keepKey) {
            var dotIndex = attr.indexOf('.'), current;
            if (dotIndex >= 0 && !keepKey) {
                var first = attr.substr(0, dotIndex), second = attr.substr(dotIndex + 1);
                current = this.__inSetup ? undefined : this.___get(first);
                if (canReflect.isMapLike(current)) {
                    canReflect.setKeyValue(current, second, value);
                } else {
                    current = this.__inSetup ? undefined : this.___get(attr);
                    if (this.__convert) {
                        value = this.__convert(attr, value);
                    }
                    this.__set(attr, this.__type(value, attr), current);
                }
            } else {
                current = this.__inSetup ? undefined : this.___get(attr);
                if (this.__convert) {
                    value = this.__convert(attr, value);
                }
                this.__set(attr, this.__type(value, attr), current);
            }
        },
        __type: function (value, prop) {
            if (typeof value === 'object' && !canReflect.isObservableLike(value) && mapHelpers.canMakeObserve(value) && !canReflect.isListLike(value)) {
                var cached = mapHelpers.getMapFromObject(value);
                if (cached) {
                    return cached;
                }
                var MapConstructor = this.constructor.Map || Map;
                return new MapConstructor(value);
            }
            return value;
        },
        __set: function (prop, value, current) {
            if (value !== current) {
                var computedAttr = this._computedAttrs[prop];
                var changeType = computedAttr || current !== undefined || hasOwnProperty.call(this.___get(), prop) ? 'set' : 'add';
                this.___set(prop, typeof value === 'object' ? bubble.set(this, prop, value, current) : value);
                if (!computedAttr || !computedAttr.count) {
                    this._triggerChange(prop, changeType, value, current);
                }
                if (typeof current === 'object') {
                    bubble.teardownFromParent(this, current);
                }
            }
        },
        ___set: function (prop, val) {
            var computedAttr = this._computedAttrs[prop];
            if (computedAttr) {
                canReflect.setKeyValue(computedAttr.compute, val);
            } else {
                this._data[prop] = val;
            }
            if (typeof this.constructor.prototype[prop] !== 'function' && !computedAttr) {
                this[prop] = val;
            }
        },
        removeAttr: function (attr) {
            return this._remove(attr);
        },
        _remove: function (attr) {
            var parts = mapHelpers.attrParts(attr), prop = parts.shift(), current = this.___get(prop);
            if (parts.length && current) {
                return canReflect.deleteKeyValue(current, parts.join('.'));
            } else {
                if (typeof attr === 'string' && !!~attr.indexOf('.')) {
                    prop = attr;
                }
                this.__remove(prop, current);
                return current;
            }
        },
        __remove: function (prop, current) {
            if (prop in this._data) {
                this.___remove(prop);
                this._triggerChange(prop, 'remove', undefined, current);
            }
        },
        ___remove: function (prop) {
            delete this._data[prop];
            if (!(prop in this.constructor.prototype)) {
                delete this[prop];
            }
        },
        ___serialize: function (name, val) {
            return canReflect.serialize(val, CIDMap);
        },
        _getAttrs: function () {
            return canReflect.unwrap(this, CIDMap);
        },
        _setAttrs: function (props, remove) {
            if (remove === true) {
                this[canSymbol.for('can.updateDeep')](props);
            } else {
                this[canSymbol.for('can.assignDeep')](props);
            }
            return this;
        },
        serialize: function () {
            return canReflect.serialize(this, CIDMap);
        },
        _triggerChange: function (attr, how, newVal, oldVal, batchNum) {
            canQueues.batch.start();
            if (bubble.isBubbling(this, 'change')) {
                canEvent.dispatch.call(this, {
                    type: 'change',
                    target: this,
                    batchNum: batchNum
                }, [
                    attr,
                    how,
                    newVal,
                    oldVal
                ]);
            }
            canEvent.dispatch.call(this, {
                type: attr,
                target: this,
                batchNum: batchNum,
                patches: [{
                        type: 'set',
                        key: attr,
                        value: newVal
                    }]
            }, [
                newVal,
                oldVal
            ]);
            if (how === 'remove' || how === 'add') {
                canEvent.dispatch.call(this, {
                    type: '__keys',
                    target: this,
                    batchNum: batchNum
                });
            }
            canQueues.batch.stop();
        },
        compute: function (prop) {
            if (typeof this.constructor.prototype[prop] === 'function') {
                return canCompute(this[prop], this);
            } else {
                var reads = ObserveReader.reads(prop);
                var last = reads.length - 1;
                return canCompute(function (newVal) {
                    if (arguments.length) {
                        ObserveReader.write(this, reads[last].key, newVal, {});
                    } else {
                        return ObserveReader.get(this, prop);
                    }
                }, this);
            }
        },
        forEach: function (callback, context) {
            var key, item;
            var keys = canReflect.getOwnEnumerableKeys(this);
            for (var i = 0, len = keys.length; i < len; i++) {
                key = keys[i];
                item = this.attr(key);
                if (callback.call(context || item, item, key, this) === false) {
                    break;
                }
            }
            return this;
        },
        _each: function (callback) {
            var data = this.___get();
            for (var prop in data) {
                if (hasOwnProperty.call(data, prop)) {
                    callback(data[prop], prop);
                }
            }
        },
        dispatch: canEvent.dispatch
    });
    canEvent(Map.prototype);
    Map.prototype.addEventListener = function (eventName, handler) {
        var computedBinding = this._computedAttrs && this._computedAttrs[eventName];
        if (computedBinding && computedBinding.compute) {
            if (!computedBinding.count) {
                computedBinding.count = 1;
                canReflect.onValue(computedBinding.compute, computedBinding.handler, 'notify');
            } else {
                computedBinding.count++;
            }
        }
        bubble.bind(this, eventName);
        return canEvent.addEventListener.apply(this, arguments);
    };
    Map.prototype.removeEventListener = function (eventName, handler) {
        var computedBinding = this._computedAttrs && this._computedAttrs[eventName];
        if (computedBinding) {
            if (computedBinding.count === 1) {
                computedBinding.count = 0;
                canReflect.offValue(computedBinding.compute, computedBinding.handler);
            } else {
                computedBinding.count--;
            }
        }
        bubble.unbind(this, eventName);
        return canEvent.removeEventListener.apply(this, arguments);
    };
    Map.prototype.on = Map.prototype.bind = Map.prototype.addEventListener;
    Map.prototype.off = Map.prototype.unbind = Map.prototype.removeEventListener;
    Map.on = Map.bind = Map.addEventListener;
    Map.off = Map.unbind = Map.removeEventListener;
    canReflect.assignSymbols(Map.prototype, {
        'can.isMapLike': true,
        'can.isListLike': false,
        'can.isValueLike': false,
        'can.getKeyValue': Map.prototype._get,
        'can.setKeyValue': Map.prototype._set,
        'can.deleteKeyValue': Map.prototype._remove,
        'can.getOwnEnumerableKeys': function () {
            ObservationRecorder.add(this, '__keys');
            var enumerable = this.constructor.enumerable;
            if (enumerable) {
                return Object.keys(this._data).filter(function (key) {
                    return enumerable[key] !== false;
                }, this);
            } else {
                return Object.keys(this._data);
            }
        },
        'can.assignDeep': function (source) {
            canQueues.batch.start();
            canReflect.assignDeepMap(this, mapHelpers.removeSpecialKeys(canReflect.assignMap({}, source)));
            canQueues.batch.stop();
        },
        'can.updateDeep': function (source) {
            canQueues.batch.start();
            canReflect.updateDeepMap(this, mapHelpers.removeSpecialKeys(canReflect.assignMap({}, source)));
            canQueues.batch.stop();
        },
        'can.unwrap': mapHelpers.reflectUnwrap,
        'can.serialize': mapHelpers.reflectSerialize,
        'can.onKeyValue': function (key, handler, queue) {
            var translationHandler = function (ev, newValue, oldValue) {
                handler.call(this, newValue, oldValue);
            };
            singleReference.set(handler, this, translationHandler, key);
            this.addEventListener(key, translationHandler, queue);
        },
        'can.offKeyValue': function (key, handler, queue) {
            this.removeEventListener(key, singleReference.getAndDelete(handler, this, key), queue);
        },
        'can.keyHasDependencies': function (key) {
            return !!(this._computedAttrs && this._computedAttrs[key] && this._computedAttrs[key].compute);
        },
        'can.getKeyDependencies': function (key) {
            var ret;
            if (this._computedAttrs && this._computedAttrs[key] && this._computedAttrs[key].compute) {
                ret = {};
                ret.valueDependencies = new CIDSet();
                ret.valueDependencies.add(this._computedAttrs[key].compute);
            }
            return ret;
        }
    });
    if (!types.DefaultMap) {
        types.DefaultMap = Map;
    }
    module.exports = namespace.Map = Map;
});
/*can-list@4.0.0#can-list*/
define('can-list@4.0.0#can-list', [
    'require',
    'exports',
    'module',
    'can-namespace',
    'can-map',
    'can-map/bubble',
    'can-map/map-helpers',
    'can-queues',
    'can-event-queue/map/map',
    'can-observation',
    'can-cid',
    'can-util/js/is-promise/is-promise',
    'can-util/js/make-array/make-array',
    'can-util/js/assign/assign',
    'can-types',
    'can-util/js/each/each',
    'can-reflect',
    'can-symbol',
    'can-util/js/cid-map/cid-map'
], function (require, exports, module) {
    var namespace = require('can-namespace');
    var Map = require('can-map');
    var bubble = require('can-map/bubble');
    var mapHelpers = require('can-map/map-helpers');
    var queues = require('can-queues');
    var canEvent = require('can-event-queue/map/map');
    var Observation = require('can-observation');
    var CID = require('can-cid');
    var isPromise = require('can-util/js/is-promise/is-promise');
    var makeArray = require('can-util/js/make-array/make-array');
    var assign = require('can-util/js/assign/assign');
    var types = require('can-types');
    var each = require('can-util/js/each/each');
    var canReflect = require('can-reflect');
    var canSymbol = require('can-symbol');
    var CIDMap = require('can-util/js/cid-map/cid-map');
    var splice = [].splice, spliceRemovesProps = function () {
            var obj = {
                0: 'a',
                length: 1
            };
            splice.call(obj, 0, 1);
            return !obj[0];
        }();
    var serializeNonTypes = function (MapType, arg, args) {
        if (arg && arg.serialize && !(arg instanceof MapType)) {
            args.push(new MapType(arg.serialize()));
        } else {
            args.push(arg);
        }
    };
    var List = Map.extend({ Map: Map }, {
            setup: function (instances, options) {
                this.length = 0;
                CID(this, '.map');
                this._setupComputedProperties();
                instances = instances || [];
                var teardownMapping;
                if (isPromise(instances)) {
                    this.replace(instances);
                } else {
                    teardownMapping = instances.length && mapHelpers.addToMap(instances, this);
                    this.push.apply(this, makeArray(instances || []));
                }
                if (teardownMapping) {
                    teardownMapping();
                }
                assign(this, options);
            },
            _triggerChange: function (attr, how, newVal, oldVal) {
                queues.batch.start();
                var index = +attr, patches;
                if (!~('' + attr).indexOf('.') && !isNaN(index)) {
                    if (bubble.isBubbling(this, 'change')) {
                        canEvent.dispatch.call(this, {
                            type: 'change',
                            target: this
                        }, [
                            attr,
                            how,
                            newVal,
                            oldVal
                        ]);
                    }
                    if (how === 'add') {
                        patches = [{
                                insert: newVal,
                                index: index,
                                deleteCount: 0,
                                type: 'splice'
                            }];
                        canEvent.dispatch.call(this, {
                            type: how,
                            patches: patches
                        }, [
                            newVal,
                            index
                        ]);
                        canEvent.dispatch.call(this, 'length', [this.length]);
                        canEvent.dispatch.call(this, 'can.onPatches', [patches]);
                    } else if (how === 'remove') {
                        patches = [{
                                index: index,
                                deleteCount: oldVal.length,
                                type: 'splice'
                            }];
                        canEvent.dispatch.call(this, {
                            type: how,
                            patches: patches
                        }, [
                            oldVal,
                            index
                        ]);
                        canEvent.dispatch.call(this, 'length', [this.length]);
                        canEvent.dispatch.call(this, 'can.onPatches', [patches]);
                    } else {
                        canEvent.dispatch.call(this, how, [
                            newVal,
                            index
                        ]);
                    }
                } else {
                    Map.prototype._triggerChange.apply(this, arguments);
                }
                queues.batch.stop();
            },
            ___get: function (attr) {
                if (attr) {
                    var computedAttr = this._computedAttrs[attr];
                    if (computedAttr && computedAttr.compute) {
                        return canReflect.getValue(computedAttr.compute);
                    }
                    if (this[attr] && this[attr].isComputed && typeof this.constructor.prototype[attr] === 'function') {
                        return canReflect.getValue(this[attr]);
                    } else {
                        return this[attr];
                    }
                } else {
                    return this;
                }
            },
            __set: function (prop, value, current) {
                prop = isNaN(+prop) || prop % 1 ? prop : +prop;
                if (typeof prop === 'number') {
                    if (prop > this.length - 1) {
                        var newArr = new Array(prop + 1 - this.length);
                        newArr[newArr.length - 1] = value;
                        this.push.apply(this, newArr);
                        return newArr;
                    } else {
                        this.splice(prop, 1, value);
                        return this;
                    }
                }
                return Map.prototype.__set.call(this, '' + prop, value, current);
            },
            ___set: function (attr, val) {
                this[attr] = val;
                if (+attr >= this.length) {
                    this.length = +attr + 1;
                }
            },
            __remove: function (prop, current) {
                if (isNaN(+prop)) {
                    delete this[prop];
                    this._triggerChange(prop, 'remove', undefined, current);
                } else {
                    this.splice(prop, 1);
                }
            },
            _each: function (callback) {
                var data = this.___get();
                for (var i = 0; i < data.length; i++) {
                    callback(data[i], i);
                }
            },
            serialize: function () {
                return canReflect.serialize(this, CIDMap);
            },
            splice: function (index, howMany) {
                var args = makeArray(arguments), added = [], i, len, listIndex, allSame = args.length > 2;
                index = index || 0;
                for (i = 0, len = args.length - 2; i < len; i++) {
                    listIndex = i + 2;
                    args[listIndex] = this.__type(args[listIndex], listIndex);
                    added.push(args[listIndex]);
                    if (this[i + index] !== args[listIndex]) {
                        allSame = false;
                    }
                }
                if (allSame && this.length <= added.length) {
                    return added;
                }
                if (howMany === undefined) {
                    howMany = args[1] = this.length - index;
                }
                var removed = splice.apply(this, args);
                if (!spliceRemovesProps) {
                    for (i = this.length; i < removed.length + this.length; i++) {
                        delete this[i];
                    }
                }
                queues.batch.start();
                if (howMany > 0) {
                    bubble.removeMany(this, removed);
                    this._triggerChange('' + index, 'remove', undefined, removed);
                }
                if (args.length > 2) {
                    bubble.addMany(this, added);
                    this._triggerChange('' + index, 'add', added, removed);
                }
                queues.batch.stop();
                return removed;
            }
        }), getArgs = function (args) {
            return args[0] && Array.isArray(args[0]) ? args[0] : makeArray(args);
        };
    each({
        push: 'length',
        unshift: 0
    }, function (where, name) {
        var orig = [][name];
        List.prototype[name] = function () {
            var args = [], len = where ? this.length : 0, i = arguments.length, res, val;
            while (i--) {
                val = arguments[i];
                args[i] = bubble.set(this, i, this.__type(val, i));
            }
            res = orig.apply(this, args);
            if (!this.comparator || args.length) {
                this._triggerChange('' + len, 'add', args, undefined);
            }
            return res;
        };
    });
    each({
        pop: 'length',
        shift: 0
    }, function (where, name) {
        List.prototype[name] = function () {
            if (!this.length) {
                return undefined;
            }
            var args = getArgs(arguments), len = where && this.length ? this.length - 1 : 0;
            var res = [][name].apply(this, args);
            this._triggerChange('' + len, 'remove', undefined, [res]);
            if (res && res.removeEventListener) {
                bubble.remove(this, res);
            }
            return res;
        };
    });
    assign(List.prototype, {
        indexOf: function (item, fromIndex) {
            Observation.add(this, 'length');
            for (var i = fromIndex || 0, len = this.length; i < len; i++) {
                if (this.attr(i) === item) {
                    return i;
                }
            }
            return -1;
        },
        join: function () {
            Observation.add(this, 'length');
            return [].join.apply(this, arguments);
        },
        reverse: function () {
            var list = [].reverse.call(makeArray(this));
            return this.replace(list);
        },
        slice: function () {
            Observation.add(this, 'length');
            var temp = Array.prototype.slice.apply(this, arguments);
            return new this.constructor(temp);
        },
        concat: function () {
            var args = [], MapType = this.constructor.Map;
            each(arguments, function (arg) {
                if (canReflect.isObservableLike(arg) && canReflect.isListLike(arg) || Array.isArray(arg)) {
                    var arr = canReflect.isObservableLike(arg) && canReflect.isListLike(arg) ? makeArray(arg) : arg;
                    each(arr, function (innerArg) {
                        serializeNonTypes(MapType, innerArg, args);
                    });
                } else {
                    serializeNonTypes(MapType, arg, args);
                }
            });
            return new this.constructor(Array.prototype.concat.apply(makeArray(this), args));
        },
        forEach: function (cb, thisarg) {
            var item;
            for (var i = 0, len = this.attr('length'); i < len; i++) {
                item = this.attr(i);
                if (item !== undefined && cb.call(thisarg || item, item, i, this) === false) {
                    break;
                }
            }
            return this;
        },
        replace: function (newList) {
            if (isPromise(newList)) {
                if (this._promise) {
                    this._promise.__isCurrentPromise = false;
                }
                var promise = this._promise = newList;
                promise.__isCurrentPromise = true;
                var self = this;
                newList.then(function (newList) {
                    if (promise.__isCurrentPromise) {
                        self.replace(newList);
                    }
                });
            } else {
                this.splice.apply(this, [
                    0,
                    this.length
                ].concat(makeArray(newList || [])));
            }
            return this;
        },
        filter: function (callback, thisArg) {
            var filteredList = new this.constructor(), self = this, filtered;
            this.forEach(function (item, index, list) {
                filtered = callback.call(thisArg || self, item, index, self);
                if (filtered) {
                    filteredList.push(item);
                }
            });
            return filteredList;
        },
        map: function (callback, thisArg) {
            var filteredList = new List(), self = this;
            this.forEach(function (item, index, list) {
                var mapped = callback.call(thisArg || self, item, index, self);
                filteredList.push(mapped);
            });
            return filteredList;
        }
    });
    var oldType = Map.prototype.__type;
    Map.prototype.__type = function (value, prop) {
        if (typeof value === 'object' && Array.isArray(value)) {
            var cached = mapHelpers.getMapFromObject(value);
            if (cached) {
                return cached;
            }
            return new List(value);
        }
        return oldType.apply(this, arguments);
    };
    var oldSetup = Map.setup;
    Map.setup = function () {
        oldSetup.apply(this, arguments);
        if (!(this.prototype instanceof List)) {
            this.List = Map.List.extend({ Map: this }, {});
        }
    };
    if (!types.DefaultList) {
        types.DefaultList = List;
    }
    canReflect.assignSymbols(List.prototype, {
        'can.isMoreListLikeThanMapLike': true,
        'can.isListLike': true,
        'can.getKeyValue': List.prototype._get,
        'can.setKeyValue': List.prototype._set,
        'can.deleteKeyValue': List.prototype._remove,
        'can.getOwnEnumerableKeys': function () {
            return Object.keys(this._data || {}).concat(this.map(function (val, index) {
                return index;
            }));
        },
        'can.assignDeep': function (source) {
            queues.batch.start();
            canReflect.assignDeepList(this, source);
            queues.batch.stop();
        },
        'can.updateDeep': function (source) {
            queues.batch.start();
            canReflect.updateDeepList(this, source);
            queues.batch.stop();
        },
        'can.unwrap': mapHelpers.reflectUnwrap,
        'can.serialize': mapHelpers.reflectSerialize,
        'can.onKeysAdded': function (handler) {
            this[canSymbol.for('can.onKeyValue')]('add', handler);
        },
        'can.onKeysRemoved': function (handler) {
            this[canSymbol.for('can.onKeyValue')]('remove', handler);
        },
        'can.onPatches': function (handler, queue) {
            this[canSymbol.for('can.onKeyValue')]('can.onPatches', handler, queue);
        },
        'can.offPatches': function (handler, queue) {
            this[canSymbol.for('can.offKeyValue')]('can.onPatches', handler, queue);
        },
        'can.splice': function (index, deleteCount, insert) {
            this.splice.apply(this, [
                index,
                deleteCount
            ].concat(insert));
        }
    });
    Map.List = List;
    module.exports = namespace.List = List;
});
/*can-list@4.0.0#can-list_test*/
define('can-list@4.0.0#can-list_test', [
    'require',
    'exports',
    'module',
    'can-list',
    'steal-qunit',
    'can-observation',
    'can-map',
    'can-reflect',
    'can-symbol'
], function (require, exports, module) {
    var List = require('can-list');
    var QUnit = require('steal-qunit');
    var Observation = require('can-observation');
    var Map = require('can-map');
    var canReflect = require('can-reflect');
    var canSymbol = require('can-symbol');
    QUnit.module('can-list');
    test('list attr changes length', function () {
        var l = new List([
            0,
            1,
            2
        ]);
        l.attr(3, 3);
        equal(l.length, 4);
    });
    test('removeAttr on list', function () {
        var l = new List([
            0,
            1,
            2
        ]);
        l.removeAttr(1);
        equal(l.attr('length'), 2);
        deepEqual(l.attr(), [
            0,
            2
        ]);
    });
    test('list splice', function () {
        var l = new List([
                0,
                1,
                2,
                3
            ]), first = true;
        l.bind('change', function (ev, attr, how, newVals, oldVals) {
            equal(attr, '1');
            if (first) {
                equal(how, 'remove', 'removing items');
                equal(newVals, undefined, 'no new Vals');
            } else {
                deepEqual(newVals, [
                    'a',
                    'b'
                ], 'got the right newVals');
                equal(how, 'add', 'adding items');
            }
            first = false;
        });
        l.splice(1, 2, 'a', 'b');
        deepEqual(l.serialize(), [
            0,
            'a',
            'b',
            3
        ], 'serialized');
    });
    test('list pop', function () {
        var l = new List([
            0,
            1,
            2,
            3
        ]);
        l.bind('change', function (ev, attr, how, newVals, oldVals) {
            equal(attr, '3');
            equal(how, 'remove');
            equal(newVals, undefined);
            deepEqual(oldVals, [3]);
        });
        l.pop();
        deepEqual(l.serialize(), [
            0,
            1,
            2
        ]);
    });
    test('remove nested property in item of array map', function () {
        var state = new List([{ nested: true }]);
        state.bind('change', function (ev, attr, how, newVal, old) {
            equal(attr, '0.nested');
            equal(how, 'remove');
            deepEqual(old, true);
        });
        state.removeAttr('0.nested');
        equal(undefined, state.attr('0.nested'));
    });
    test('pop unbinds', function () {
        var l = new List([{ foo: 'bar' }]);
        var o = l.attr(0), count = 0;
        l.bind('change', function (ev, attr, how, newVal, oldVal) {
            count++;
            if (count === 1) {
                equal(attr, '0.foo', 'count is set');
            } else if (count === 2) {
                equal(how, 'remove');
                equal(attr, '0');
            } else {
                ok(false, 'called too many times');
            }
        });
        equal(o.attr('foo'), 'bar', 'read foo property');
        o.attr('foo', 'car');
        l.pop();
        o.attr('foo', 'bad');
    });
    test('splice unbinds', function () {
        var l = new List([{ foo: 'bar' }]);
        var o = l.attr(0), count = 0;
        l.bind('change', function (ev, attr, how, newVal, oldVal) {
            count++;
            if (count === 1) {
                equal(attr, '0.foo', 'count is set');
            } else if (count === 2) {
                equal(how, 'remove');
                equal(attr, '0');
            } else {
                ok(false, 'called too many times');
            }
        });
        equal(o.attr('foo'), 'bar');
        o.attr('foo', 'car');
        l.splice(0, 1);
        o.attr('foo', 'bad');
    });
    test('always gets right attr even after moving array items', function () {
        var l = new List([{ foo: 'bar' }]);
        var o = l.attr(0);
        l.unshift('A new Value');
        l.bind('change', function (ev, attr, how) {
            equal(attr, '1.foo');
        });
        o.attr('foo', 'led you');
    });
    test('Array accessor methods', 11, function () {
        var l = new List([
                'a',
                'b',
                'c'
            ]), sliced = l.slice(2), joined = l.join(' | '), concatenated = l.concat([
                2,
                1
            ], new List([0]));
        ok(sliced instanceof List, 'Slice is an Observable list');
        equal(sliced.length, 1, 'Sliced off two elements');
        equal(sliced[0], 'c', 'Single element as expected');
        equal(joined, 'a | b | c', 'Joined list properly');
        ok(concatenated instanceof List, 'Concatenated is an Observable list');
        deepEqual(concatenated.serialize(), [
            'a',
            'b',
            'c',
            2,
            1,
            0
        ], 'List concatenated properly');
        l.forEach(function (letter, index) {
            ok(true, 'Iteration');
            if (index === 0) {
                equal(letter, 'a', 'First letter right');
            }
            if (index === 2) {
                equal(letter, 'c', 'Last letter right');
            }
        });
    });
    test('Concatenated list items Equal original', function () {
        var l = new List([
                { firstProp: 'Some data' },
                { secondProp: 'Next data' }
            ]), concatenated = l.concat([
                { hello: 'World' },
                { foo: 'Bar' }
            ]);
        ok(l[0] === concatenated[0], 'They are Equal');
        ok(l[1] === concatenated[1], 'They are Equal');
    });
    test('Lists with maps concatenate properly', function () {
        var Person = Map.extend();
        var People = List.extend({ Map: Person }, {});
        var Genius = Person.extend();
        var Animal = Map.extend();
        var me = new Person({ name: 'John' });
        var animal = new Animal({ name: 'Tak' });
        var genius = new Genius({ name: 'Einstein' });
        var hero = { name: 'Ghandi' };
        var people = new People([]);
        var specialPeople = new People([
            genius,
            hero
        ]);
        people = people.concat([
            me,
            animal,
            specialPeople
        ], specialPeople, [
            1,
            2
        ], 3);
        ok(people.attr('length') === 8, 'List length is right');
        ok(people[0] === me, 'Map in list === vars created before concat');
        ok(people[1] instanceof Person, 'Animal got serialized to Person');
    });
    test('splice removes items in IE (#562)', function () {
        var l = new List(['a']);
        l.splice(0, 1);
        ok(!l.attr(0), 'all props are removed');
    });
    test('reverse triggers add/remove events (#851)', function () {
        expect(6);
        var l = new List([
            1,
            2,
            3
        ]);
        l.bind('change', function () {
            ok(true, 'change should be called');
        });
        l.bind('set', function () {
            ok(false, 'set should not be called');
        });
        l.bind('add', function () {
            ok(true, 'add called');
        });
        l.bind('remove', function () {
            ok(true, 'remove called');
        });
        l.bind('length', function () {
            ok(true, 'length should be called');
        });
        l.reverse();
    });
    test('filter', function () {
        var l = new List([
            {
                id: 1,
                name: 'John'
            },
            {
                id: 2,
                name: 'Mary'
            }
        ]);
        var filtered = l.filter(function (item) {
            return item.name === 'Mary';
        });
        notEqual(filtered._cid, l._cid, 'not same object');
        equal(filtered.length, 1, 'one item');
        equal(filtered[0].name, 'Mary', 'filter works');
    });
    test('removing expandos on lists', function () {
        var list = new List([
            'a',
            'b'
        ]);
        list.removeAttr('foo');
        equal(list.length, 2);
    });
    test('No Add Events if List Splice adds the same items that it is removing. (#1277, #1399)', function () {
        var list = new List([
            'a',
            'b'
        ]);
        list.bind('add', function () {
            ok(false, 'Add callback should not be called.');
        });
        list.bind('remove', function () {
            ok(false, 'Remove callback should not be called.');
        });
        var result = list.splice(0, 2, 'a', 'b');
        deepEqual(result, [
            'a',
            'b'
        ]);
    });
    test('add event always returns an array as the value (#998)', function () {
        var list = new List([]), msg;
        list.bind('add', function (ev, newElements, index) {
            deepEqual(newElements, [4], msg);
        });
        msg = 'works on push';
        list.push(4);
        list.pop();
        msg = 'works on attr()';
        list.attr(0, 4);
        list.pop();
        msg = 'works on replace()';
        list.replace([4]);
    });
    test('Setting with .attr() out of bounds of length triggers add event with leading undefineds', function () {
        var list = new List([1]);
        list.bind('add', function (ev, newElements, index) {
            deepEqual(newElements, [
                undefined,
                undefined,
                4
            ], 'Leading undefineds are included');
            equal(index, 1, 'Index takes into account the leading undefineds from a .attr()');
        });
        list.attr(3, 4);
    });
    test('No events should fire if removals happened on empty arrays', function () {
        var list = new List([]), msg;
        list.bind('remove', function (ev, removed, index) {
            ok(false, msg);
        });
        msg = 'works on pop';
        list.pop();
        msg = 'works on shift';
        list.shift();
        ok(true, 'No events were fired.');
    });
    test('setting an index out of bounds does not create an array', function () {
        expect(1);
        var l = new List();
        l.attr('1', 'foo');
        equal(l.attr('1'), 'foo');
    });
    test('splice with similar but less items works (#1606)', function () {
        var list = new List([
            'aa',
            'bb',
            'cc'
        ]);
        list.splice(0, list.length, 'aa', 'cc', 'dd');
        deepEqual(list.attr(), [
            'aa',
            'cc',
            'dd'
        ]);
        list.splice(0, list.length, 'aa', 'cc');
        deepEqual(list.attr(), [
            'aa',
            'cc'
        ]);
    });
    test('filter returns same list type (#1744)', function () {
        var ParentList = List.extend();
        var ChildList = ParentList.extend();
        var children = new ChildList([
            1,
            2,
            3
        ]);
        ok(children.filter(function () {
        }) instanceof ChildList);
    });
    test('reverse returns the same list instance (#1744)', function () {
        var ParentList = List.extend();
        var ChildList = ParentList.extend();
        var children = new ChildList([
            1,
            2,
            3
        ]);
        ok(children.reverse() === children);
    });
    test('slice and join are observable by a compute (#1884)', function () {
        expect(2);
        var list = new List([
            1,
            2,
            3
        ]);
        var sliced = new Observation(function () {
            return list.slice(0, 1);
        });
        canReflect.onValue(sliced, function (newVal) {
            deepEqual(newVal.attr(), [2], 'got a new List');
        });
        var joined = new Observation(function () {
            return list.join(',');
        });
        canReflect.onValue(joined, function (newVal) {
            equal(newVal, '2,3', 'joined is observable');
        });
        list.shift();
    });
    test('list is always updated with the last promise passed to replace (#2136)', function () {
        var list = new List();
        stop();
        list.replace(new Promise(function (resolve) {
            setTimeout(function () {
                resolve(['A']);
                setTimeout(function () {
                    equal(list.attr(0), 'B', 'list set to last promise\'s value');
                    start();
                }, 10);
            }, 20);
        }));
        list.replace(new Promise(function (resolve) {
            setTimeout(function () {
                resolve(['B']);
            }, 10);
        }));
    });
    test('forEach callback', function () {
        var list = new List([]), counter = 0;
        list.attr(9, 'foo');
        list.forEach(function (element, index, list) {
            counter++;
        });
        equal(counter, 1, 'Should not be invoked for uninitialized attr keys');
    });
    test('filter with context', function () {
        var l = new List([{ id: 1 }]);
        var context = {};
        var contextWasCorrect = false;
        l.filter(function () {
            contextWasCorrect = this === context;
            return true;
        }, context);
        equal(contextWasCorrect, true, 'context was correctly passed');
    });
    test('map with context', function () {
        var l = new List([{ id: 1 }]);
        var context = {};
        var contextWasCorrect = false;
        l.map(function () {
            contextWasCorrect = this === context;
            return true;
        }, context);
        equal(contextWasCorrect, true, 'context was correctly passed');
    });
    test('works with can-reflect', 11, function () {
        var a = new Map({ foo: 4 });
        var b = new List([
            'foo',
            'bar'
        ]);
        QUnit.equal(canReflect.getKeyValue(b, '0'), 'foo', 'unbound value');
        var handler = function (newValue) {
            QUnit.equal(newValue, 'quux', 'observed new value');
        };
        QUnit.ok(!canReflect.isValueLike(b), 'isValueLike is false');
        QUnit.ok(canReflect.isMapLike(b), 'isMapLike is true');
        QUnit.ok(canReflect.isListLike(b), 'isListLike is false');
        QUnit.ok(!canReflect.keyHasDependencies(b, 'length'), 'keyHasDependencies -- false');
        b._computedAttrs['length'] = {
            compute: new Observation(function () {
                return a.attr('foo');
            }, null)
        };
        b._computedAttrs['length'].compute.start();
        QUnit.ok(canReflect.keyHasDependencies(b, 'length'), 'keyHasDependencies -- true');
        canReflect.onKeysAdded(b, handler);
        canReflect.onKeysRemoved(b, handler);
        var handlers = b[canSymbol.for('can.meta')].handlers;
        QUnit.ok(handlers.get(['add']).length, 'add handler added');
        QUnit.ok(handlers.get(['remove']).length, 'remove handler added');
        b.push('quux');
        QUnit.equal(canReflect.getKeyValue(b, 'length'), '4', 'bound value');
        b.pop();
    });
    QUnit.test('can-reflect setKeyValue', function () {
        var a = new Map({ 'a': 'b' });
        canReflect.setKeyValue(a, 'a', 'c');
        QUnit.equal(a.attr('a'), 'c', 'setKeyValue');
    });
    QUnit.test('can-reflect getKeyDependencies', function () {
        var a = new Map({ foo: 4 });
        var b = new List([
            'foo',
            'bar'
        ]);
        ok(!canReflect.getKeyDependencies(b, 'length'), 'No dependencies before binding');
        b._computedAttrs.length = {
            compute: new Observation(function () {
                return a.attr('foo');
            }, null)
        };
        b._computedAttrs.length.compute.start();
        ok(canReflect.getKeyDependencies(b, 'length'), 'dependencies exist');
        ok(canReflect.getKeyDependencies(b, 'length').valueDependencies.has(b._computedAttrs.length.compute), 'dependencies returned');
    });
    QUnit.test('registered symbols', function () {
        var a = new Map({ 'a': 'a' });
        ok(a[canSymbol.for('can.isMapLike')], 'can.isMapLike');
        equal(a[canSymbol.for('can.getKeyValue')]('a'), 'a', 'can.getKeyValue');
        a[canSymbol.for('can.setKeyValue')]('a', 'b');
        equal(a.attr('a'), 'b', 'can.setKeyValue');
        function handler(val) {
            equal(val, 'c', 'can.onKeyValue');
        }
        a[canSymbol.for('can.onKeyValue')]('a', handler);
        a.attr('a', 'c');
        a[canSymbol.for('can.offKeyValue')]('a', handler);
        a.attr('a', 'd');
    });
    QUnit.test('onPatches', function () {
        var list = new List([
            'a',
            'b'
        ]);
        var PATCHES = [
            [{
                    deleteCount: 2,
                    index: 0,
                    type: 'splice'
                }],
            [{
                    index: 0,
                    insert: [
                        'A',
                        'B'
                    ],
                    deleteCount: 0,
                    type: 'splice'
                }]
        ];
        var handlerCalls = 0;
        var handler = function (patches) {
            QUnit.deepEqual(patches, PATCHES[handlerCalls], 'patches looked right for ' + handlerCalls);
            handlerCalls++;
        };
        list[canSymbol.for('can.onPatches')](handler, 'notify');
        list.replace([
            'A',
            'B'
        ]);
        list[canSymbol.for('can.offPatches')](handler, 'notify');
        list.replace([
            '1',
            '2'
        ]);
    });
    QUnit.test('can.onInstancePatches basics', function () {
        var People = List.extend({});
        var calls = [];
        function handler(obj, patches) {
            calls.push([
                obj,
                patches
            ]);
        }
        People[canSymbol.for('can.onInstancePatches')](handler);
        var list = new People([
            1,
            2
        ]);
        list.push(3);
        list.attr('count', 8);
        People[canSymbol.for('can.offInstancePatches')](handler);
        list.push(4);
        list.attr('count', 7);
        QUnit.deepEqual(calls, [
            [
                list,
                [{
                        type: 'splice',
                        index: 2,
                        deleteCount: 0,
                        insert: [3]
                    }]
            ],
            [
                list,
                [{
                        type: 'set',
                        key: 'count',
                        value: 8
                    }]
            ]
        ]);
    });
    QUnit.test('can.onInstanceBoundChange basics', function () {
        var People = List.extend({});
        var calls = [];
        function handler(obj, patches) {
            calls.push([
                obj,
                patches
            ]);
        }
        People[canSymbol.for('can.onInstanceBoundChange')](handler);
        var people = new People([]);
        var bindHandler = function () {
        };
        canReflect.onKeyValue(people, 'length', bindHandler);
        canReflect.offKeyValue(people, 'length', bindHandler);
        People[canSymbol.for('can.offInstanceBoundChange')](handler);
        canReflect.onKeyValue(people, 'length', bindHandler);
        canReflect.offKeyValue(people, 'length', bindHandler);
        QUnit.deepEqual(calls, [
            [
                people,
                true
            ],
            [
                people,
                false
            ]
        ]);
    });
});
/*can-map@4.0.0#can-map_test*/
define('can-map@4.0.0#can-map_test', [
    'require',
    'exports',
    'module',
    'can-map',
    'steal-qunit',
    'can-compute',
    'can-observation-recorder',
    'can-construct',
    'can-stache-key',
    'can-reflect',
    'can-symbol',
    'can-queues',
    'can-reflect-tests/observables/map-like/type/type'
], function (require, exports, module) {
    var Map = require('can-map');
    var QUnit = require('steal-qunit');
    var canCompute = require('can-compute');
    var ObservationRecorder = require('can-observation-recorder');
    var Construct = require('can-construct');
    var observeReader = require('can-stache-key');
    var canReflect = require('can-reflect');
    var canSymbol = require('can-symbol');
    var queues = require('can-queues');
    QUnit.module('can-map');
    test('Basic Map', 4, function () {
        var state = new Map({
            category: 5,
            productType: 4
        });
        state.bind('change', function (ev, attr, how, val, old) {
            equal(attr, 'category', 'correct change name');
            equal(how, 'set');
            equal(val, 6, 'correct');
            equal(old, 5, 'correct');
        });
        state.attr('category', 6);
        state.unbind('change');
    });
    test('Nested Map', 5, function () {
        var me = new Map({
            name: {
                first: 'Justin',
                last: 'Meyer'
            }
        });
        ok(me.attr('name') instanceof Map);
        me.bind('change', function (ev, attr, how, val, old) {
            equal(attr, 'name.first', 'correct change name');
            equal(how, 'set');
            equal(val, 'Brian', 'correct');
            equal(old, 'Justin', 'correct');
        });
        me.attr('name.first', 'Brian');
        me.unbind('change');
    });
    test('remove attr', function () {
        var state = new Map({
            category: 5,
            productType: 4
        });
        state.removeAttr('category');
        deepEqual(Map.keys(state), ['productType'], 'one property');
    });
    test('remove attr on key with dot', function () {
        var state = new Map({
            'key.with.dots': 12,
            productType: 4
        });
        var state2 = new Map({
            'key.with.dots': 4,
            key: { 'with': { someValue: 20 } }
        });
        state.removeAttr('key.with.dots');
        state2.removeAttr('key.with.someValue');
        deepEqual(Map.keys(state), ['productType'], 'one property');
        deepEqual(Map.keys(state2), [
            'key.with.dots',
            'key'
        ], 'two properties');
        deepEqual(Map.keys(state2.key['with']), [], 'zero properties');
    });
    test('nested event handlers are not run by changing the parent property (#280)', function () {
        var person = new Map({ name: { first: 'Justin' } });
        person.bind('name.first', function (ev, newName) {
            ok(false, 'name.first should never be called');
        });
        person.bind('name', function () {
            ok(true, 'name event triggered');
        });
        person.attr('name', { first: 'Hank' });
    });
    test('cyclical objects (#521)', function () {
        var foo = {};
        foo.foo = foo;
        var fooed = new Map(foo);
        ok(true, 'did not cause infinate recursion');
        ok(fooed.attr('foo') === fooed, 'map points to itself');
        var me = { name: 'Justin' };
        var references = {
            husband: me,
            friend: me
        };
        var ref = new Map(references);
        ok(ref.attr('husband') === ref.attr('friend'), 'multiple properties point to the same thing');
    });
    test('_cid add to original object', function () {
        var map = new Map(), obj = { 'name': 'thecountofzero' };
        map.attr('myObj', obj);
        ok(!obj._cid, '_cid not added to original object');
    });
    test('Map serialize triggers reading (#626)', function () {
        var old = ObservationRecorder.add;
        var attributesRead = [];
        var readingTriggeredForKeys = false;
        ObservationRecorder.add = function (object, attribute) {
            if (attribute === '__keys') {
                readingTriggeredForKeys = true;
            } else {
                attributesRead.push(attribute);
            }
        };
        var testMap = new Map({
            cats: 'meow',
            dogs: 'bark'
        });
        testMap.serialize();
        ok(attributesRead.indexOf('cats') !== -1 && attributesRead.indexOf('dogs') !== -1, 'map serialization triggered __reading on all attributes');
        ok(readingTriggeredForKeys, 'map serialization triggered __reading for __keys');
        ObservationRecorder.add = old;
    });
    test('Test top level attributes', 7, function () {
        var test = new Map({
            'my.enable': false,
            'my.item': true,
            'my.count': 0,
            'my.newCount': 1,
            'my': {
                'value': true,
                'nested': { 'value': 100 }
            }
        });
        equal(test.attr('my.value'), true, 'correct');
        equal(test.attr('my.nested.value'), 100, 'correct');
        ok(test.attr('my.nested') instanceof Map);
        equal(test.attr('my.enable'), false, 'falsey (false) value accessed correctly');
        equal(test.attr('my.item'), true, 'truthey (true) value accessed correctly');
        equal(test.attr('my.count'), 0, 'falsey (0) value accessed correctly');
        equal(test.attr('my.newCount'), 1, 'falsey (1) value accessed correctly');
    });
    test('serializing cycles', function () {
        var map1 = new Map({ name: 'map1' });
        var map2 = new Map({ name: 'map2' });
        map1.attr('map2', map2);
        map2.attr('map1', map1);
        var res = map1.serialize();
        equal(res.name, 'map1');
        equal(res.map2.name, 'map2');
    });
    test('Unbinding from a map with no bindings doesn\'t throw an error (#1015)', function () {
        expect(0);
        var test = new Map({});
        try {
            test.unbind('change');
        } catch (e) {
            ok(false, 'No error should be thrown');
        }
    });
    test('Fast dispatch event still has target and type (#1082)', 4, function () {
        var data = new Map({ name: 'CanJS' });
        data.bind('change', function (ev) {
            equal(ev.type, 'change');
            equal(ev.target, data);
        });
        data.bind('name', function (ev) {
            equal(ev.type, 'name');
            equal(ev.target, data);
        });
        data.attr('name', 'David');
    });
    test('map passed to Map constructor (#1166)', function () {
        function y() {
        }
        var map = new Map({
            x: 1,
            y: y
        });
        var res = new Map(map);
        deepEqual(res.attr(), {
            x: 1,
            y: y
        }, 'has the same properties');
    });
    test('constructor passed to scope is threated as a property (#1261)', function () {
        var Constructor = Construct.extend({});
        var MyMap = Map.extend({ Todo: Constructor });
        var m = new MyMap();
        equal(m.attr('Todo'), Constructor);
    });
    test('_bindings count maintained after calling .off() on undefined property (#1490) ', function () {
        var map = new Map({ test: 1 });
        map.on('test', function () {
        });
        var handlers = map[canSymbol.for('can.meta')].handlers;
        equal(handlers.get([]).length, 1, 'The number of bindings is correct');
        map.off('undefined_property');
        equal(handlers.get([]).length, 1, 'The number of bindings is still correct');
    });
    test('Should be able to get and set attribute named \'watch\' on Map in Firefox', function () {
        var map = new Map({});
        map.attr('watch');
        ok(true, 'can have attribute named \'watch\' on a Map instance');
    });
    test('Should be able to get and set attribute named \'unwatch\' on Map in Firefox', function () {
        var map = new Map({});
        map.attr('unwatch');
        ok(true, 'can have attribute named \'unwatch\' on a Map instance');
    });
    test('should get an empty string property value correctly', function () {
        var map = new Map({
            foo: 'foo',
            '': 'empty string'
        });
        equal(map.attr(''), 'empty string');
    });
    test('ObserveReader - can.Construct derived classes should be considered objects, not functions (#450)', function () {
        var foostructor = Map.extend({ text: 'bar' }, {}), obj = {
                next_level: {
                    thing: foostructor,
                    text: 'In the inner context'
                }
            }, read;
        foostructor.self = foostructor;
        read = observeReader.read(obj, observeReader.reads('next_level.thing.self.text'));
        equal(read.value, 'bar', 'static properties on a can.Construct-based function');
        read = observeReader.read(obj, observeReader.reads('next_level.thing.self'), { isArgument: true });
        ok(read.value === foostructor, 'arguments shouldn\'t be executed');
    });
    test('works with can-reflect', 7, function () {
        var b = new Map({ 'foo': 'bar' });
        var c = new (Map.extend({
            'baz': canCompute(function () {
                return b.attr('foo');
            })
        }))({
            'foo': 'bar',
            thud: 'baz'
        });
        QUnit.equal(canReflect.getKeyValue(b, 'foo'), 'bar', 'unbound value');
        function bazHandler(newValue) {
            QUnit.equal(newValue, 'quux', 'observed new value on baz');
            canReflect.offKeyValue(c, 'baz', bazHandler);
        }
        function thudHandler(newValue) {
            QUnit.equal(newValue, 'quux', 'observed new value on thud');
            canReflect.offKeyValue(c, 'thud', thudHandler);
        }
        QUnit.ok(!canReflect.isValueLike(c), 'isValueLike is false');
        QUnit.ok(canReflect.isMapLike(c), 'isMapLike is true');
        QUnit.ok(!canReflect.isListLike(c), 'isListLike is false');
        canReflect.onKeyValue(c, 'baz', bazHandler);
        canReflect.onKeyValue(c, 'thud', thudHandler);
        b.attr('foo', 'quux');
        c.attr('thud', 'quux');
        QUnit.equal(canReflect.getKeyValue(c, 'baz'), 'quux', 'bound value');
        b.attr('foo', 'thud');
        c.attr('baz', 'jeek');
    });
    QUnit.test('onKeyValue and queues', function () {
        var b = new Map({ 'foo': 'bar' });
        var order = [];
        canReflect.onKeyValue(b, 'foo', function () {
            order.push('onKeyValue');
        }, 'notify');
        queues.batch.start();
        queues.mutateQueue.enqueue(function () {
            order.push('mutate');
        });
        b.attr('foo', 'baz');
        queues.batch.stop();
        QUnit.deepEqual(order, [
            'onKeyValue',
            'mutate'
        ]);
    });
    QUnit.test('can-reflect setKeyValue', function () {
        var a = new Map({ 'a': 'b' });
        canReflect.setKeyValue(a, 'a', 'c');
        QUnit.equal(a.attr('a'), 'c', 'setKeyValue');
    });
    QUnit.test('can-reflect getKeyDependencies', function () {
        var a = new Map({ 'a': 'a' });
        var b = new (Map.extend({
            'a': canCompute(function () {
                return a.attr('a');
            }),
            'b': 'b'
        }))();
        ok(canReflect.getKeyDependencies(b, 'a'), 'Dependencies on computed attr');
        ok(!canReflect.getKeyDependencies(b, 'b'), 'No dependencies on data attr');
        b.on('a', function () {
        });
        ok(canReflect.getKeyDependencies(b, 'a').valueDependencies.has(b._computedAttrs.a.compute), 'dependencies returned');
        ok(canReflect.getValueDependencies(b._computedAttrs.a.compute).valueDependencies, 'dependencies returned from compute');
    });
    QUnit.test('registered symbols', function () {
        var a = new Map({ 'a': 'a' });
        ok(a[canSymbol.for('can.isMapLike')], 'can.isMapLike');
        equal(a[canSymbol.for('can.getKeyValue')]('a'), 'a', 'can.getKeyValue');
        a[canSymbol.for('can.setKeyValue')]('a', 'b');
        equal(a.attr('a'), 'b', 'can.setKeyValue');
        function handler(val) {
            equal(this, a);
            equal(val, 'c', 'can.onKeyValue');
        }
        a[canSymbol.for('can.onKeyValue')]('a', handler);
        a.attr('a', 'c');
        a[canSymbol.for('can.offKeyValue')]('a', handler);
        a.attr('a', 'd');
    });
    require('can-reflect-tests/observables/map-like/type/type')('Map', function () {
        return Map.extend({});
    });
    QUnit.test('can.isBound', function () {
        var Person = Map.extend({
            first: 'any',
            last: 'any'
        });
        var p = new Person();
        QUnit.ok(!p[canSymbol.for('can.isBound')](), 'not bound');
    });
});
/*can-fixture@2.0.2#helpers/getid*/
define('can-fixture@2.0.2#helpers/getid', function (require, exports, module) {
    module.exports = function (xhrSettings, fixtureSettings) {
        var id = xhrSettings.data.id;
        if (id === undefined && typeof xhrSettings.data === 'number') {
            id = xhrSettings.data;
        }
        if (id === undefined) {
            xhrSettings.url.replace(/\/(\d+)(\/|$|\.)/g, function (all, num) {
                id = num;
            });
        }
        if (id === undefined) {
            id = xhrSettings.url.replace(/\/(\w+)(\/|$|\.)/g, function (all, num) {
                if (num !== 'update') {
                    id = num;
                }
            });
        }
        if (id === undefined) {
            id = Math.round(Math.random() * 1000);
        }
        return id;
    };
});
/*can-fixture@2.0.2#helpers/legacyStore*/
define('can-fixture@2.0.2#helpers/legacyStore', [
    'require',
    'exports',
    'module',
    './getid',
    'can-set',
    'can-util/js/is-array-like/is-array-like',
    'can-util/js/each/each',
    'can-util/js/assign/assign'
], function (require, exports, module) {
    var getId = require('./getid');
    var canSet = require('can-set');
    var isArrayLike = require('can-util/js/is-array-like/is-array-like');
    var each = require('can-util/js/each/each');
    var assign = require('can-util/js/assign/assign');
    function getStartingId(items) {
        var startingId = 0;
        each(items, function (item) {
            if (typeof item.id === 'number') {
                startingId = Math.max(startingId, item.id + 1);
            }
        });
        return startingId;
    }
    module.exports = function (count, make, filter) {
        var nextItemId;
        var getNextItemId = function () {
            return nextItemId++;
        };
        var items, findOne = function (id) {
                for (var i = 0; i < items.length; i++) {
                    if (id == items[i].id) {
                        return items[i];
                    }
                }
            }, methods = {}, types, reset;
        if (isArrayLike(count) && typeof count[0] === 'string') {
            types = count;
            count = make;
            make = filter;
            filter = arguments[3];
        } else if (typeof count === 'string') {
            types = [
                count + 's',
                count
            ];
            count = make;
            make = filter;
            filter = arguments[3];
        }
        if (typeof count === 'number') {
            nextItemId = 0;
            items = [];
            reset = function () {
                items = [];
                for (var i = 0; i < count; i++) {
                    var item = make(i, items);
                    if (!item.id) {
                        item.id = getNextItemId();
                    }
                    items.push(item);
                }
            };
        } else {
            filter = make;
            var initialItems = count;
            nextItemId = getStartingId(initialItems);
            reset = function () {
                items = initialItems.slice(0);
            };
        }
        assign(methods, {
            getListData: function (request) {
                request = request || {};
                var retArr = items.slice(0);
                request.data = request.data || {};
                each((request.data.order || []).slice(0).reverse(), function (name) {
                    var split = name.split(' ');
                    retArr = retArr.sort(function (a, b) {
                        if (split[1].toUpperCase() !== 'ASC') {
                            if (a[split[0]] < b[split[0]]) {
                                return 1;
                            } else if (a[split[0]] === b[split[0]]) {
                                return 0;
                            } else {
                                return -1;
                            }
                        } else {
                            if (a[split[0]] < b[split[0]]) {
                                return -1;
                            } else if (a[split[0]] === b[split[0]]) {
                                return 0;
                            } else {
                                return 1;
                            }
                        }
                    });
                });
                each((request.data.group || []).slice(0).reverse(), function (name) {
                    var split = name.split(' ');
                    retArr = retArr.sort(function (a, b) {
                        return a[split[0]] > b[split[0]];
                    });
                });
                var offset = parseInt(request.data.offset, 10) || 0, limit = parseInt(request.data.limit, 10) || items.length - offset, i = 0;
                for (var param in request.data) {
                    i = 0;
                    if (request.data[param] !== undefined && (param.indexOf('Id') !== -1 || param.indexOf('_id') !== -1)) {
                        while (i < retArr.length) {
                            if (request.data[param] != retArr[i][param]) {
                                retArr.splice(i, 1);
                            } else {
                                i++;
                            }
                        }
                    }
                }
                if (typeof filter === 'function') {
                    i = 0;
                    while (i < retArr.length) {
                        if (!filter(retArr[i], request)) {
                            retArr.splice(i, 1);
                        } else {
                            i++;
                        }
                    }
                } else if (typeof filter === 'object') {
                    i = 0;
                    while (i < retArr.length) {
                        var subset = canSet.subset(retArr[i], request.data, filter);
                        if (!subset) {
                            retArr.splice(i, 1);
                        } else {
                            i++;
                        }
                    }
                }
                var responseData = {
                    'count': retArr.length,
                    'data': retArr.slice(offset, offset + limit)
                };
                each([
                    'limit',
                    'offset'
                ], function (prop) {
                    if (prop in request.data) {
                        responseData[prop] = request.data[prop];
                    }
                });
                return responseData;
            },
            getData: function (request, response) {
                var item = findOne(getId(request));
                if (typeof item === 'undefined') {
                    return response(404, 'Requested resource not found');
                }
                response(item);
            },
            updateData: function (request, response) {
                var id = getId(request), item = findOne(id);
                if (typeof item === 'undefined') {
                    return response(404, 'Requested resource not found');
                }
                assign(item, request.data);
                response({ id: id }, { location: request.url || '/' + getId(request) });
            },
            destroyData: function (request, response) {
                var id = getId(request), item = findOne(id);
                if (typeof item === 'undefined') {
                    return response(404, 'Requested resource not found');
                }
                for (var i = 0; i < items.length; i++) {
                    if (items[i].id == id) {
                        items.splice(i, 1);
                        break;
                    }
                }
                return {};
            },
            createData: function (settings, response) {
                var item = typeof make === 'function' ? make(items.length, items) : {};
                assign(item, settings.data);
                if (!item.id) {
                    item.id = getNextItemId();
                }
                items.push(item);
                response({ id: item.id }, { location: settings.url + '/' + item.id });
            }
        });
        reset();
        return assign({
            findAll: methods.getListData,
            findOne: methods.getData,
            create: methods.createData,
            update: methods.updateData,
            destroy: methods.destroyData,
            getId: getId,
            find: function (settings) {
                return findOne(getId(settings));
            },
            reset: reset
        }, methods);
    };
});
/*can-connect@2.0.1#helpers/get-items*/
define('can-connect@2.0.1#helpers/get-items', function (require, exports, module) {
    module.exports = function (data) {
        if (Array.isArray(data)) {
            return data;
        } else {
            return data.data;
        }
    };
});
/*can-connect@2.0.1#helpers/sorted-set-json*/
define('can-connect@2.0.1#helpers/sorted-set-json', function (require, exports, module) {
    var forEach = [].forEach;
    var keys = Object.keys;
    module.exports = function (set) {
        if (set == null) {
            return set;
        } else {
            var sorted = {};
            forEach.call(keys(set).sort(), function (prop) {
                sorted[prop] = set[prop];
            });
            return JSON.stringify(sorted);
        }
    };
});
/*can-connect@2.0.1#helpers/overwrite*/
define('can-connect@2.0.1#helpers/overwrite', function (require, exports, module) {
    module.exports = function (d, s, id) {
        for (var prop in d) {
            if (d.hasOwnProperty(prop) && !(prop.substr(0, 2) === '__') && prop !== id && !(prop in s)) {
                delete d[prop];
            }
        }
        for (prop in s) {
            d[prop] = s[prop];
        }
        return d;
    };
});
/*can-connect@2.0.1#helpers/set-add*/
define('can-connect@2.0.1#helpers/set-add', [
    'require',
    'exports',
    'module',
    'can-set'
], function (require, exports, module) {
    var canSet = require('can-set');
    module.exports = function (connection, setItems, items, item, algebra) {
        var index = canSet.index(setItems, items, item, algebra);
        if (index === undefined) {
            index = items.length;
        }
        var copy = items.slice(0);
        copy.splice(index, 0, item);
        return copy;
    };
});
/*can-connect@2.0.1#helpers/get-index-by-id*/
define('can-connect@2.0.1#helpers/get-index-by-id', function (require, exports, module) {
    module.exports = function (connection, props, items) {
        var id = connection.id(props);
        for (var i = 0; i < items.length; i++) {
            var connId = connection.id(items[i]);
            if (id == connId) {
                return i;
            }
        }
        return -1;
    };
});
/*can-connect@2.0.1#helpers/clone-data*/
define('can-connect@2.0.1#helpers/clone-data', [
    'require',
    'exports',
    'module',
    'can-util/js/deep-assign/deep-assign'
], function (require, exports, module) {
    var deepAssign = require('can-util/js/deep-assign/deep-assign');
    module.exports = function (data) {
        return Array.isArray(data) ? data.slice(0) : deepAssign({}, data);
    };
});
/*can-connect@2.0.1#data/memory-cache/memory-cache*/
define('can-connect@2.0.1#data/memory-cache/memory-cache', [
    'require',
    'exports',
    'module',
    'can-connect/helpers/get-items',
    'can-connect',
    'can-connect/helpers/sorted-set-json',
    'can-set',
    'can-connect/helpers/overwrite',
    'can-connect/helpers/set-add',
    'can-connect/helpers/get-index-by-id',
    'can-util/js/assign/assign',
    'can-connect/helpers/clone-data'
], function (require, exports, module) {
    var getItems = require('can-connect/helpers/get-items');
    var connect = require('can-connect');
    var sortedSetJSON = require('can-connect/helpers/sorted-set-json');
    var canSet = require('can-set');
    var overwrite = require('can-connect/helpers/overwrite');
    var setAdd = require('can-connect/helpers/set-add');
    var indexOf = require('can-connect/helpers/get-index-by-id');
    var assign = require('can-util/js/assign/assign');
    var cloneData = require('can-connect/helpers/clone-data');
    module.exports = connect.behavior('data/memory-cache', function (baseConnection) {
        var behavior = {
            _sets: {},
            getSetData: function () {
                return this._sets;
            },
            __getListData: function (set) {
                var setsData = this.getSetData();
                var setData = setsData[sortedSetJSON(set)];
                if (setData) {
                    return setData.items;
                }
            },
            _instances: {},
            getInstance: function (id) {
                return this._instances[id];
            },
            removeSet: function (setKey, noUpdate) {
                var sets = this.getSetData();
                delete sets[setKey];
                if (noUpdate !== true) {
                    this.updateSets();
                }
            },
            updateSets: function () {
            },
            updateInstance: function (props) {
                var id = this.id(props);
                if (!(id in this._instances)) {
                    this._instances[id] = props;
                } else {
                    overwrite(this._instances[id], props, this.idProp);
                }
                return this._instances[id];
            },
            updateSet: function (setDatum, items, newSet) {
                var newSetKey = newSet ? sortedSetJSON(newSet) : setDatum.setKey;
                if (newSet) {
                    if (newSetKey !== setDatum.setKey) {
                        var sets = this.getSetData();
                        var oldSetKey = setDatum.setKey;
                        sets[newSetKey] = setDatum;
                        setDatum.setKey = newSetKey;
                        setDatum.set = assign({}, newSet);
                        this.removeSet(oldSetKey);
                    }
                }
                setDatum.items = items;
                var self = this;
                items.forEach(function (item) {
                    self.updateInstance(item);
                });
            },
            addSet: function (set, data) {
                var items = getItems(data);
                var sets = this.getSetData();
                var setKey = sortedSetJSON(set);
                sets[setKey] = {
                    setKey: setKey,
                    items: items,
                    set: assign({}, set)
                };
                var self = this;
                items.forEach(function (item) {
                    self.updateInstance(item);
                });
                this.updateSets();
            },
            _eachSet: function (cb) {
                var sets = this.getSetData();
                var self = this;
                var loop = function (setDatum, setKey) {
                    return cb.call(self, setDatum, setKey, function () {
                        return setDatum.items;
                    });
                };
                for (var setKey in sets) {
                    var setDatum = sets[setKey];
                    var result = loop(setDatum, setKey);
                    if (result !== undefined) {
                        return result;
                    }
                }
            },
            _getSets: function () {
                var sets = [], setsData = this.getSetData();
                for (var prop in setsData) {
                    sets.push(setsData[prop].set);
                }
                return sets;
            },
            getSets: function () {
                return Promise.resolve(this._getSets());
            },
            clear: function () {
                this._instances = {};
                this._sets = {};
            },
            getListData: function (set) {
                set = set || {};
                var listData = this.getListDataSync(set);
                if (listData) {
                    return Promise.resolve(listData);
                }
                return Promise.reject({
                    message: 'no data',
                    error: 404
                });
            },
            getListDataSync: function (set) {
                var sets = this._getSets();
                for (var i = 0; i < sets.length; i++) {
                    var checkSet = sets[i];
                    if (canSet.subset(set, checkSet, this.algebra)) {
                        var source = this.__getListData(checkSet);
                        var items = canSet.getSubset(set, checkSet, source, this.algebra);
                        return {
                            data: items,
                            count: source.length
                        };
                    }
                }
            },
            _getListData: function (set) {
                return this.getListDataSync(set);
            },
            updateListData: function (data, set) {
                set = set || {};
                var clonedData = cloneData(data);
                var items = getItems(clonedData);
                var sets = this.getSetData();
                var self = this;
                for (var setKey in sets) {
                    var setDatum = sets[setKey];
                    var union = canSet.union(setDatum.set, set, this.algebra);
                    if (union) {
                        var getSet = assign({}, setDatum.set);
                        return this.getListData(getSet).then(function (setData) {
                            self.updateSet(setDatum, canSet.getUnion(getSet, set, getItems(setData), items, self.algebra), union);
                        });
                    }
                }
                this.addSet(set, clonedData);
                return Promise.resolve();
            },
            getData: function (params) {
                var id = this.id(params);
                var res = this.getInstance(id);
                if (res) {
                    return Promise.resolve(res);
                } else {
                    return Promise.reject({
                        message: 'no data',
                        error: 404
                    });
                }
            },
            createData: function (props) {
                var self = this;
                var instance = this.updateInstance(props);
                this._eachSet(function (setDatum, setKey, getItems) {
                    if (canSet.has(setDatum.set, instance, this.algebra)) {
                        self.updateSet(setDatum, setAdd(self, setDatum.set, getItems(), instance, self.algebra), setDatum.set);
                    }
                });
                return Promise.resolve(assign({}, instance));
            },
            updateData: function (props) {
                var self = this;
                var instance = this.updateInstance(props);
                this._eachSet(function (setDatum, setKey, getItems) {
                    var items = getItems();
                    var index = indexOf(self, instance, items);
                    if (canSet.subset(instance, setDatum.set, this.algebra)) {
                        if (index === -1) {
                            self.updateSet(setDatum, setAdd(self, setDatum.set, getItems(), instance, self.algebra));
                        } else {
                            items.splice(index, 1, instance);
                            self.updateSet(setDatum, items);
                        }
                    } else if (index !== -1) {
                        items.splice(index, 1);
                        self.updateSet(setDatum, items);
                    }
                });
                return Promise.resolve(assign({}, instance));
            },
            destroyData: function (props) {
                var self = this;
                this._eachSet(function (setDatum, setKey, getItems) {
                    var items = getItems();
                    var index = indexOf(self, props, items);
                    if (index !== -1) {
                        items.splice(index, 1);
                        self.updateSet(setDatum, items);
                    }
                });
                var id = this.id(props);
                delete this._instances[id];
                return Promise.resolve(assign({}, props));
            }
        };
        return behavior;
    });
});
/*can-fixture@2.0.2#store*/
define('can-fixture@2.0.2#store', [
    'require',
    'exports',
    'module',
    'can-set',
    'can-connect',
    './helpers/legacyStore',
    'can-util/js/each/each',
    'can-util/js/assign/assign',
    'can-util/js/is-array-like/is-array-like',
    'can-connect/data/memory-cache/memory-cache'
], function (require, exports, module) {
    var canSet = require('can-set');
    var connect = require('can-connect');
    var legacyStore = require('./helpers/legacyStore');
    var each = require('can-util/js/each/each');
    var assign = require('can-util/js/assign/assign');
    var isArrayLike = require('can-util/js/is-array-like/is-array-like');
    var dataMemoryCache = require('can-connect/data/memory-cache/memory-cache');
    var firstProp = function (obj) {
        for (var prop in obj) {
            return prop;
        }
    };
    var connectToConnection = function (method) {
        return function (req, res) {
            this.connection[method](req.data).then(function (data) {
                res(data);
            }, function (err) {
                res(403, err);
            });
        };
    };
    var makeMakeItems = function (baseItems, idProp) {
        return function () {
            var items = [], maxId = 0;
            each(baseItems, function (item) {
                items.push(JSON.parse(JSON.stringify(item)));
                maxId = Math.max(item[idProp] + 1, maxId + 1) || items.length;
            });
            return {
                maxId: maxId,
                items: items
            };
        };
    };
    var Store = function (connection, makeItems, idProp) {
        this.connection = connection;
        this.makeItems = makeItems;
        this.idProp = idProp;
        this.reset();
        for (var method in Store.prototype) {
            this[method] = this[method].bind(this);
        }
    };
    assign(Store.prototype, {
        getListData: connectToConnection('getListData'),
        getData: connectToConnection('getData'),
        createData: function (req, res) {
            var idProp = this.idProp;
            req.data[idProp] = ++this.maxId;
            this.connection.createData(req.data).then(function (data) {
                var responseData = {};
                responseData[idProp] = req.data[idProp];
                res(responseData);
            }, function (err) {
                res(403, err);
            });
        },
        updateData: connectToConnection('updateData'),
        destroyData: connectToConnection('destroyData'),
        reset: function (newItems) {
            if (newItems) {
                this.makeItems = makeMakeItems(newItems, this.idProp);
            }
            var itemData = this.makeItems();
            this.maxId = itemData.maxId;
            this.connection.addSet({}, { data: itemData.items });
        },
        get: function (params) {
            var id = this.connection.id(params);
            return this.connection.getInstance(id);
        },
        getList: function (set) {
            return this.connection._getListData(set);
        }
    });
    each({
        findAll: 'getListData',
        findOne: 'getData',
        create: 'createData',
        update: 'updateData',
        destroy: 'destroyData'
    }, function (method, prop) {
        Store.prototype[prop] = function () {
            return this[method].apply(this, arguments);
        };
    });
    Store.make = function (count, make, algebra) {
        var isNew = false;
        if (count instanceof canSet.Algebra || make instanceof canSet.Algebra || algebra instanceof canSet.Algebra) {
            isNew = true;
        }
        if (!isNew) {
            console.warn('can-fixture: This form ( `fixture(count, make, filter)` ) of making a store is deprecated.  Please use the algebra-based form.');
            return legacyStore.apply(this, arguments);
        }
        var makeItems, idProp;
        if (typeof count === 'number') {
            idProp = firstProp(algebra.clauses.id || {}) || 'id';
            makeItems = function () {
                var items = [];
                var maxId = 0;
                for (var i = 0; i < count; i++) {
                    var item = make(i, items);
                    if (!item[idProp]) {
                        item[idProp] = i;
                    }
                    maxId = Math.max(item[idProp] + 1, maxId + 1) || items.length;
                    items.push(item);
                }
                return {
                    maxId: maxId,
                    items: items
                };
            };
        } else if (isArrayLike(count)) {
            algebra = make;
            idProp = firstProp(algebra.clauses.id || {}) || 'id';
            makeItems = makeMakeItems(count, idProp);
        }
        var connection = connect([dataMemoryCache], {
            algebra: algebra,
            idProp: idProp
        });
        return new Store(connection, makeItems, idProp);
    };
    module.exports = Store;
});
/*can-fixture@2.0.2#core*/
define('can-fixture@2.0.2#core', [
    'require',
    'exports',
    'module',
    'can-set',
    'can-util/js/string/string',
    'can-util/js/each/each',
    'can-util/js/assign/assign',
    'can-util/js/is-empty-object/is-empty-object',
    'can-util/js/is-plain-object/is-plain-object',
    'can-util/js/log/log',
    'can-util/js/dev/dev',
    './store'
], function (require, exports, module) {
    var canSet = require('can-set');
    var sub = require('can-util/js/string/string').sub;
    var each = require('can-util/js/each/each');
    var assign = require('can-util/js/assign/assign');
    var isEmptyObject = require('can-util/js/is-empty-object/is-empty-object');
    var isPlainObject = require('can-util/js/is-plain-object/is-plain-object');
    var canLog = require('can-util/js/log/log');
    var canDev = require('can-util/js/dev/dev');
    require('./store');
    var fixtures = [];
    exports.fixtures = fixtures;
    function isStoreLike(fixture) {
        return fixture && (fixture.getData || fixture.getListData);
    }
    var methodMapping = {
        item: {
            'GET': 'getData',
            'PUT': 'updateData',
            'DELETE': 'destroyData'
        },
        list: {
            'GET': 'getListData',
            'POST': 'createData'
        }
    };
    function getMethodAndPath(route) {
        var matches = route.match(/(GET|POST|PUT|DELETE|PATCH) (.+)/i);
        if (!matches) {
            return [
                undefined,
                route
            ];
        }
        var method = matches[1];
        var path = matches[2];
        return [
            method,
            path
        ];
    }
    function inferIdProp(url) {
        var wrappedInBraces = /\{(.*)\}/;
        var matches = url.match(wrappedInBraces);
        var isUniqueMatch = matches && matches.length === 2;
        if (isUniqueMatch) {
            return matches[1];
        }
    }
    function getItemAndListUrls(url, idProp) {
        idProp = idProp || inferIdProp(url);
        if (!idProp) {
            return [
                undefined,
                url
            ];
        }
        var itemRegex = new RegExp('\\/\\{' + idProp + '\\}.*');
        var rootIsItemUrl = itemRegex.test(url);
        var listUrl = rootIsItemUrl ? url.replace(itemRegex, '') : url;
        var itemUrl = rootIsItemUrl ? url : url.trim() + '/{' + idProp + '}';
        return [
            itemUrl,
            listUrl
        ];
    }
    function addStoreFixture(root, store) {
        var settings = {};
        var typeAndUrl = getMethodAndPath(root);
        var type = typeAndUrl[0];
        var url = typeAndUrl[1];
        var itemAndListUrls = getItemAndListUrls(url, store.idProp);
        var itemUrl = itemAndListUrls[0];
        var listUrl = itemAndListUrls[1];
        if (type) {
            var warning = ['fixture("' + root + '", fixture) must use a store method, not a store directly.'];
            if (itemUrl) {
                var itemAction = methodMapping.item[type];
                if (itemAction) {
                    settings[type + ' ' + itemUrl] = store[itemAction];
                    var itemWarning = 'Replace with fixture("' + type + ' ' + itemUrl + '", fixture.' + itemAction + ') for items.';
                    warning.push(itemWarning);
                }
            }
            var listAction = methodMapping.list[type];
            if (listAction) {
                settings[type + ' ' + listUrl] = store[listAction];
                var listWarning = 'Replace with fixture("' + type + ' ' + listUrl + '", fixture.' + listAction + ') for lists.';
                warning.push(listWarning);
            }
            var message = warning.join(' ');
            canDev.warn(message);
        } else {
            var itemMapping = methodMapping.item;
            for (var itemMethod in itemMapping) {
                var storeItemMethod = itemMapping[itemMethod];
                settings[itemMethod + ' ' + itemUrl] = store[storeItemMethod];
            }
            var listMapping = methodMapping.list;
            for (var listMethod in listMapping) {
                var storeListMethod = listMapping[listMethod];
                settings[listMethod + ' ' + listUrl] = store[storeListMethod];
            }
        }
        return settings;
    }
    function getSettingsFromString(route) {
        var typeAndUrl = getMethodAndPath(route);
        var type = typeAndUrl[0];
        var url = typeAndUrl[1];
        if (type) {
            return {
                type: type,
                url: url
            };
        }
        return { url: url };
    }
    function upsertFixture(fixtureList, settings, fixture) {
        var index = exports.index(settings, true);
        if (index > -1) {
            fixtures.splice(index, 1);
        }
        if (fixture == null) {
            return;
        }
        if (typeof fixture === 'object') {
            var data = fixture;
            fixture = function () {
                return data;
            };
        }
        settings.fixture = fixture;
        fixtures.unshift(settings);
    }
    exports.add = function (settings, fixture) {
        if (fixture === undefined) {
            each(settings, function (fixture, url) {
                exports.add(url, fixture);
            });
            return;
        }
        if (isStoreLike(fixture)) {
            settings = addStoreFixture(settings, fixture);
            exports.add(settings);
            return;
        }
        if (typeof settings === 'string') {
            settings = getSettingsFromString(settings);
        }
        upsertFixture(fixtures, settings, fixture);
    };
    var $fixture = exports.add;
    $fixture.on = true;
    $fixture.delay = 10;
    exports.callDynamicFixture = function (xhrSettings, fixtureSettings, cb) {
        xhrSettings.data = fixtureSettings.data;
        var response = function () {
            var res = exports.extractResponse.apply(xhrSettings, arguments);
            return cb.apply(this, res);
        };
        var callFixture = function () {
            var result = fixtureSettings.fixture(xhrSettings, response, xhrSettings.headers, fixtureSettings);
            if (result !== undefined) {
                response(200, result);
            }
        };
        if (!xhrSettings.async) {
            callFixture();
            return null;
        } else {
            return setTimeout(callFixture, $fixture.delay);
        }
    };
    exports.index = function (settings, exact) {
        for (var i = 0; i < fixtures.length; i++) {
            if (exports.matches(settings, fixtures[i], exact)) {
                return i;
            }
        }
        return -1;
    };
    exports.get = function (xhrSettings) {
        if (!$fixture.on) {
            return;
        }
        var index = exports.index(xhrSettings, true);
        if (index === -1) {
            index = exports.index(xhrSettings, false);
        }
        var fixtureSettings = index >= 0 ? assign({}, fixtures[index]) : undefined;
        if (fixtureSettings) {
            var url = fixtureSettings.fixture, data = exports.dataFromUrl(fixtureSettings.url, xhrSettings.url);
            if (typeof fixtureSettings.fixture === 'string') {
                if (data) {
                    url = sub(url, data);
                }
                fixtureSettings.url = url;
                fixtureSettings.data = null;
                fixtureSettings.type = 'GET';
                if (!fixtureSettings.error) {
                    fixtureSettings.error = function (xhr, error, message) {
                        throw 'fixtures.js Error ' + error + ' ' + message;
                    };
                }
            } else if (isPlainObject(xhrSettings.data) || xhrSettings.data == null) {
                var xhrData = assign({}, xhrSettings.data || {});
                fixtureSettings.data = assign(xhrData, data);
            } else {
                fixtureSettings.data = xhrSettings.data;
            }
        }
        return fixtureSettings;
    };
    exports.matches = function (settings, fixture, exact) {
        if (exact) {
            return canSet.equal(settings, fixture, {
                fixture: function () {
                    return true;
                }
            });
        } else {
            return canSet.subset(settings, fixture, exports.defaultCompare);
        }
    };
    var isEmptyOrNull = function (a, b) {
        if (a == null && isEmptyObject(b)) {
            return true;
        } else if (b == null && isEmptyObject(a)) {
            return true;
        } else {
            return canSet.equal(a, b);
        }
    };
    var isEmptyOrSubset = function (a, b) {
        if (a == null && isEmptyObject(b)) {
            return true;
        } else if (b == null && isEmptyObject(a)) {
            return true;
        } else {
            return canSet.subset(a, b);
        }
    };
    exports.defaultCompare = {
        url: function (a, b) {
            return !!exports.dataFromUrl(b, a);
        },
        fixture: function () {
            return true;
        },
        xhr: function () {
            return true;
        },
        type: function (a, b) {
            return b && a ? a.toLowerCase() === b.toLowerCase() : b === a;
        },
        method: function (a, b) {
            return b && a ? a.toLowerCase() === b.toLowerCase() : b === a;
        },
        helpers: function () {
            return true;
        },
        headers: isEmptyOrNull,
        data: isEmptyOrSubset
    };
    var replacer = /\{([^\}]+)\}/g;
    exports.dataFromUrl = function (fixtureUrl, url) {
        if (!fixtureUrl) {
            return {};
        }
        var order = [], fixtureUrlAdjusted = fixtureUrl.replace('.', '\\.').replace('?', '\\?'), res = new RegExp(fixtureUrlAdjusted.replace(replacer, function (whole, part) {
                order.push(part);
                return '([^/]+)';
            }) + '$').exec(url), data = {};
        if (!res) {
            return null;
        }
        res.shift();
        each(order, function (name) {
            data[name] = res.shift();
        });
        return data;
    };
    exports.extractResponse = function (status, response, headers, statusText) {
        if (typeof status !== 'number') {
            headers = response;
            response = status;
            status = 200;
        }
        if (typeof headers === 'string') {
            statusText = headers;
            headers = {};
        }
        return [
            status,
            response,
            headers,
            statusText
        ];
    };
});
/*can-fixture@2.0.2#xhr*/
define('can-fixture@2.0.2#xhr', [
    'require',
    'exports',
    'module',
    './core',
    'can-deparam',
    'can-util/js/assign/assign',
    'can-util/js/each/each',
    'can-util/js/log/log'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        var fixtureCore = require('./core');
        var deparam = require('can-deparam');
        var assign = require('can-util/js/assign/assign');
        var each = require('can-util/js/each/each');
        var canLog = require('can-util/js/log/log');
        var XHR = XMLHttpRequest, GLOBAL = typeof global !== 'undefined' ? global : window;
        var props = [
            'type',
            'url',
            'async',
            'response',
            'responseText',
            'responseType',
            'responseXML',
            'responseURL',
            'status',
            'statusText',
            'readyState'
        ];
        var events = [
            'abort',
            'error',
            'load',
            'loadend',
            'loadstart',
            'progress',
            'readystatechange'
        ];
        (function () {
            var x = new XHR();
            for (var prop in x) {
                if (prop.indexOf('on') === 0) {
                    if (events.indexOf(prop.substr(2)) === -1) {
                        events.push(prop.substr(2));
                    }
                } else if (props.indexOf(prop) === -1 && typeof x[prop] !== 'function') {
                    props.push(prop);
                }
            }
        }());
        function callEvents(xhr, ev) {
            var evs = xhr.__events[ev] || [], fn;
            for (var i = 0, len = evs.length; i < len; i++) {
                fn = evs[i];
                fn.call(xhr);
            }
        }
        GLOBAL.XMLHttpRequest = function () {
            var mockXHR = this;
            var realXHR = new XHR();
            this._xhr = realXHR;
            this._requestHeaders = {};
            this.__events = {};
            each(events, function (eventName) {
                realXHR['on' + eventName] = function () {
                    callEvents(mockXHR, eventName);
                    if (mockXHR['on' + eventName]) {
                        return mockXHR['on' + eventName].apply(mockXHR, arguments);
                    }
                };
            });
            this.onload = null;
        };
        GLOBAL.XMLHttpRequest._XHR = XHR;
        assign(XMLHttpRequest.prototype, {
            setRequestHeader: function (name, value) {
                this._requestHeaders[name] = value;
            },
            open: function (type, url, async) {
                this.type = type;
                this.url = url;
                this.async = async === false ? false : true;
            },
            getAllResponseHeaders: function () {
                return this._xhr.getAllResponseHeaders.apply(this._xhr, arguments);
            },
            addEventListener: function (ev, fn) {
                var evs = this.__events[ev] = this.__events[ev] || [];
                evs.push(fn);
            },
            removeEventListener: function (ev, fn) {
                var evs = this.__events[ev] = this.__events[ev] || [];
                var idx = evs.indexOf(fn);
                if (idx >= 0) {
                    evs.splice(idx, 1);
                }
            },
            setDisableHeaderCheck: function (val) {
                this._disableHeaderCheck = !!val;
            },
            getResponseHeader: function (key) {
                return this._xhr.getResponseHeader(key);
            },
            abort: function () {
                var xhr = this._xhr;
                if (this.timeoutId !== undefined) {
                    clearTimeout(this.timeoutId);
                    xhr.open(this.type, this.url, this.async === false ? false : true);
                    xhr.send();
                }
                return xhr.abort();
            },
            send: function (data) {
                var type = this.type.toLowerCase() || 'get';
                var xhrSettings = {
                    url: this.url,
                    data: data,
                    headers: this._requestHeaders,
                    type: type,
                    method: type,
                    async: this.async,
                    xhr: this
                };
                if (!xhrSettings.data && xhrSettings.type === 'get' || xhrSettings.type === 'delete') {
                    xhrSettings.data = deparam(xhrSettings.url.split('?')[1]);
                    xhrSettings.url = xhrSettings.url.split('?')[0];
                }
                if (typeof xhrSettings.data === 'string') {
                    try {
                        xhrSettings.data = JSON.parse(xhrSettings.data);
                    } catch (e) {
                        xhrSettings.data = deparam(xhrSettings.data);
                    }
                }
                var fixtureSettings = fixtureCore.get(xhrSettings);
                var mockXHR = this;
                if (fixtureSettings && typeof fixtureSettings.fixture === 'function') {
                    this.timeoutId = fixtureCore.callDynamicFixture(xhrSettings, fixtureSettings, function (status, body, headers, statusText) {
                        body = typeof body === 'string' ? body : JSON.stringify(body);
                        mockXHR._xhr = {
                            open: function () {
                            },
                            send: function () {
                            },
                            abort: function () {
                            },
                            getResponseHeader: function () {
                            }
                        };
                        assign(mockXHR, {
                            readyState: 4,
                            status: status
                        });
                        var success = status >= 200 && status < 300 || status === 304;
                        if (success) {
                            assign(mockXHR, {
                                statusText: statusText || 'OK',
                                responseText: body
                            });
                        } else {
                            assign(mockXHR, {
                                statusText: statusText || 'error',
                                responseText: body
                            });
                        }
                        mockXHR.getAllResponseHeaders = function () {
                            var ret = [];
                            each(headers || {}, function (value, name) {
                                Array.prototype.push.apply(ret, [
                                    name,
                                    ': ',
                                    value,
                                    '\r\n'
                                ]);
                            });
                            return ret.join('');
                        };
                        if (mockXHR.onreadystatechange) {
                            mockXHR.onreadystatechange({ target: mockXHR });
                        }
                        callEvents(mockXHR, 'progress');
                        if (mockXHR.onprogress) {
                            mockXHR.onprogress();
                        }
                        callEvents(mockXHR, 'load');
                        if (mockXHR.onload) {
                            mockXHR.onload();
                        }
                        callEvents(mockXHR, 'loadend');
                        if (mockXHR.onloadend) {
                            mockXHR.onloadend();
                        }
                    });
                    return;
                }
                var makeRequest = function () {
                    mockXHR._xhr.open(mockXHR._xhr.type, mockXHR._xhr.url, mockXHR._xhr.async);
                    if (mockXHR._requestHeaders) {
                        Object.keys(mockXHR._requestHeaders).forEach(function (key) {
                            mockXHR._xhr.setRequestHeader(key, mockXHR._requestHeaders[key]);
                        });
                    }
                    return mockXHR._xhr.send(data);
                };
                if (fixtureSettings && typeof fixtureSettings.fixture === 'number') {
                    canLog.log(xhrSettings.url + ' -> delay ' + fixtureSettings.fixture + 'ms');
                    this.timeoutId = setTimeout(makeRequest, fixtureSettings.fixture);
                    return;
                }
                if (fixtureSettings) {
                    canLog.log(xhrSettings.url + ' -> ' + fixtureSettings.url);
                    assign(mockXHR, fixtureSettings);
                }
                return makeRequest();
            }
        });
        each(props, function (prop) {
            Object.defineProperty(XMLHttpRequest.prototype, prop, {
                get: function () {
                    return this._xhr[prop];
                },
                set: function (newVal) {
                    try {
                        this._xhr[prop] = newVal;
                    } catch (e) {
                    }
                }
            });
        });
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-fixture@2.0.2#fixture*/
define('can-fixture@2.0.2#fixture', [
    'require',
    'exports',
    'module',
    './core',
    './store',
    './xhr',
    'can-util/js/assign/assign',
    'can-namespace'
], function (require, exports, module) {
    var core = require('./core');
    var fixture = core.add;
    var Store = require('./store');
    require('./xhr');
    var assign = require('can-util/js/assign/assign');
    var ns = require('can-namespace');
    var noop = function () {
    };
    assign(fixture, {
        rand: function randomize(arr, min, max) {
            if (typeof arr === 'number') {
                if (typeof min === 'number') {
                    return arr + Math.floor(Math.random() * (min - arr + 1));
                } else {
                    return Math.floor(Math.random() * (arr + 1));
                }
            }
            var choices = arr.slice(0);
            if (min === undefined) {
                min = 1;
                max = choices.length;
            } else if (max === undefined) {
                max = min;
            }
            var result = [];
            var selectedCount = min + Math.round(randomize(max - min));
            for (var i = 0; i < selectedCount; i++) {
                var selectedIndex = randomize(choices.length - 1), selected = choices.splice(selectedIndex, 1)[0];
                result.push(selected);
            }
            return result;
        },
        xhr: function (xhr) {
            return assign({}, {
                abort: noop,
                getAllResponseHeaders: function () {
                    return '';
                },
                getResponseHeader: function () {
                    return '';
                },
                open: noop,
                overrideMimeType: noop,
                readyState: 4,
                responseText: '',
                responseXML: null,
                send: noop,
                setRequestHeader: noop,
                status: 200,
                statusText: 'OK'
            }, xhr);
        },
        store: Store.make,
        fixtures: core.fixtures
    });
    if (typeof window !== 'undefined' && typeof require.resolve !== 'function') {
        window.fixture = fixture;
    }
    module.exports = ns.fixture = fixture;
});
/*can-fixture@2.0.2#test/fixture_test*/
define('can-fixture@2.0.2#test/fixture_test', [
    'require',
    'exports',
    'module',
    'steal-qunit',
    'can-fixture',
    '../core',
    'can-set',
    'jquery',
    'can-util/js/each/each',
    'can-util/js/is-empty-object/is-empty-object',
    'can-util/js/dev/dev'
], function (require, exports, module) {
    (function (__dirname, require, exports, module) {
        var QUnit = require('steal-qunit');
        var fixture = require('can-fixture');
        var core = require('../core');
        var set = require('can-set');
        var $ = require('jquery');
        var each = require('can-util/js/each/each');
        var isEmptyObject = require('can-util/js/is-empty-object/is-empty-object');
        var canDev = require('can-util/js/dev/dev');
        var errorCallback = function (xhr, status, error) {
            ok(false, error);
            start();
        };
        var parseHeaders = function (str) {
            var lines = str.split(/\r?\n/);
            var fields = {};
            var index;
            var line;
            var field;
            var val;
            lines.pop();
            for (var i = 0, len = lines.length; i < len; ++i) {
                line = lines[i];
                index = line.indexOf(':');
                field = line.slice(0, index).toLowerCase();
                val = line.slice(index + 1).replace(/(^\s*|\s*$)/g, '');
                fields[field] = val;
            }
            return fields;
        };
        QUnit.module('can-fixture');
        if (__dirname !== '/') {
            test('static fixtures', function () {
                stop();
                fixture('GET something', __dirname + '/fixtures/test.json');
                fixture('POST something', __dirname + '/fixtures/test.json');
                fixture('PATCH something', __dirname + '/fixtures/test.json');
                $.ajax({
                    url: 'something',
                    dataType: 'json'
                }).then(function (data) {
                    equal(data.sweet, 'ness', 'can.get works');
                    $.ajax({
                        url: 'something',
                        method: 'POST',
                        dataType: 'json'
                    }).then(function (data) {
                        equal(data.sweet, 'ness', 'can.post works');
                        $.ajax({
                            url: 'something',
                            method: 'PATCH',
                            dataType: 'json'
                        }).then(function (data) {
                            equal(data.sweet, 'ness', 'can.patch works');
                            start();
                        }, errorCallback);
                    }, errorCallback);
                }, errorCallback);
            });
        }
        if (__dirname !== '/') {
            test('static fixtures (using method signature)', function () {
                stop();
                fixture({
                    method: 'get',
                    url: 'method/{id}'
                }, __dirname + '/fixtures/method.{id}.json');
                $.ajax({
                    url: 'method/4',
                    dataType: 'json'
                }).then(function (data) {
                    equal(data.id, 4, 'Got data with proper id using method');
                    start();
                }, errorCallback);
            });
        }
        if (__dirname !== '/') {
            test('static fixtures (using type signature)', function () {
                stop();
                fixture({
                    type: 'get',
                    url: 'type/{id}'
                }, __dirname + '/fixtures/type.{id}.json');
                $.ajax({
                    url: 'type/4',
                    dataType: 'json'
                }).then(function (data) {
                    equal(data.id, 4, 'Got data with proper id using type');
                    start();
                }, errorCallback);
            });
        }
        if (__dirname !== '/') {
            test('templated static fixtures', function () {
                stop();
                fixture('GET some/{id}', __dirname + '/fixtures/stuff.{id}.json');
                $.ajax({
                    url: 'some/3',
                    dataType: 'json'
                }).then(function (data) {
                    equal(data.id, 3, 'Got data with proper id');
                    start();
                }, errorCallback);
            });
        }
        test('dynamic fixtures', function () {
            stop();
            fixture.delay = 10;
            fixture('something', function () {
                return [{ sweet: 'ness' }];
            });
            $.ajax({
                url: 'something',
                dataType: 'json'
            }).done(function (data) {
                equal(data[0].sweet, 'ness', 'can.get works');
                start();
            });
        });
        if (__dirname !== '/') {
            test('fixture function', 3, function () {
                stop();
                var url = __dirname + '/fixtures/foo.json';
                fixture(url, __dirname + '/fixtures/foobar.json');
                $.ajax({
                    url: url,
                    dataType: 'json'
                }).done(function (data) {
                    equal(data.sweet, 'ner', 'url passed works');
                    fixture(url, __dirname + '/fixtures/test.json');
                    $.ajax({
                        url: url,
                        dataType: 'json'
                    }).done(function (data) {
                        equal(data.sweet, 'ness', 'replaced');
                        fixture(url, null);
                        $.ajax({
                            url: url,
                            dataType: 'json'
                        }).done(function (data) {
                            equal(data.a, 'b', 'removed');
                            start();
                        });
                    });
                });
            });
        }
        test('fixture.store fixtures', function () {
            stop();
            var algebra = new set.Algebra({
                searchText: function (searchTextProp, querySearchText, data, query) {
                    if (querySearchText && data.name) {
                        var regex = new RegExp('^' + querySearchText);
                        return regex.test(data.name);
                    } else {
                        return true;
                    }
                }
            }, set.props.offsetLimit('offset', 'limit'), set.props.sort('order'));
            var store = fixture.store(1000, function (i) {
                return {
                    id: i,
                    name: 'thing ' + i
                };
            }, algebra);
            fixture('things', store.findAll);
            $.ajax({
                url: 'things',
                dataType: 'json',
                data: {
                    offset: 100,
                    limit: 200,
                    order: 'name ASC',
                    searchText: 'thing 2'
                },
                success: function (things) {
                    equal(things.data[0].name, 'thing 29', 'first item is correct');
                    equal(things.data.length, 11, 'there are 11 items');
                    start();
                }
            });
        });
        test('fixture.store fixtures should have unique IDs', function () {
            stop();
            var store = fixture.store(100, function (i) {
                return { name: 'Test ' + i };
            });
            fixture('things', store.findAll);
            $.ajax({
                url: 'things',
                dataType: 'json',
                data: {
                    offset: 0,
                    limit: 200,
                    order: ['name ASC']
                },
                success: function (result) {
                    var seenIds = [];
                    var things = result.data;
                    for (var thingKey in things) {
                        var thing = things[thingKey];
                        ok(seenIds.indexOf(thing.id) === -1);
                        seenIds.push(thing.id);
                    }
                    start();
                }
            });
        });
        test('fixture.store should assign unique IDs when fixtures provide IDs', function () {
            var store = fixture.store([
                {
                    id: 0,
                    name: 'Object 0'
                },
                {
                    id: 1,
                    name: 'Object 1'
                },
                {
                    id: 2,
                    name: 'Object 2'
                }
            ]);
            fixture('POST /models', store.createData);
            function then(ajax, callback) {
                ajax.then(callback, function (error) {
                    ok(false, 'ajax failure: ' + error);
                    start();
                });
            }
            var request = $.ajax({
                url: '/models',
                dataType: 'json',
                type: 'post',
                data: { name: 'My test object' }
            });
            stop();
            then(request, function (response) {
                notEqual(response.id, 0);
                notEqual(response.id, 1);
                notEqual(response.id, 2);
                equal(response.id, 3);
                start();
            });
        });
        test('simulating an error', function () {
            fixture('/foo', function (request, response) {
                return response(401, { type: 'unauthorized' });
            });
            stop();
            $.ajax({
                url: '/foo',
                dataType: 'json'
            }).done(function () {
                ok(false, 'success called');
                start();
            }).fail(function (original, type) {
                ok(true, 'error called');
                deepEqual(JSON.parse(original.responseText), { type: 'unauthorized' }, 'Original text passed');
                start();
            });
        });
        test('rand', function () {
            var rand = fixture.rand;
            var num = rand(3);
            equal(typeof num, 'number');
            var matched = {};
            for (var i = 0; i < 100; i++) {
                num = rand(3);
                matched[num] = true;
            }
            for (i = 0; i <= 3; i++) {
                ok(matched[i], 'has ' + i);
            }
            matched = {};
            var result, choices = [
                    'a',
                    'b',
                    'c'
                ];
            for (i = 0; i < 100; i++) {
                result = rand(choices);
                matched[result.length] = true;
                matched[result[0]] = true;
            }
            for (i = 1; i <= 3; i++) {
                ok(matched[i], 'has ' + i);
                delete matched[i];
            }
            each(choices, function (choice) {
                ok(matched[choice], 'has ' + choice);
                delete matched[choice];
            });
            ok(isEmptyObject(matched), 'nothing else unexpected');
        });
        test('core.dataFromUrl', function () {
            var data = core.dataFromUrl('/thingers/{id}', '/thingers/5');
            equal(data.id, 5, 'gets data');
            data = core.dataFromUrl('/thingers/5?hi.there', '/thingers/5?hi.there');
            deepEqual(data, {}, 'gets data');
        });
        test('core.dataFromUrl with double character value', function () {
            var data = core.dataFromUrl('/days/{id}/time_slots.json', '/days/17/time_slots.json');
            equal(data.id, 17, 'gets data');
        });
        test('core.defaultCompare', function () {
            var same = set.equal({ url: '/thingers/5' }, { url: '/thingers/{id}' }, core.defaultCompare);
            ok(same, 'they are similar');
            same = set.equal({ url: '/thingers/5' }, { url: '/thingers' }, core.defaultCompare);
            ok(!same, 'they are not the same');
        });
        test('core.matches', function () {
            var same = core.matches({ url: '/thingers/5' }, { url: '/thingers/{id}' });
            ok(same, 'similar');
            same = core.matches({
                url: '/thingers/5',
                type: 'get'
            }, { url: '/thingers/{id}' });
            ok(same, 'similar with extra pops on settings');
            var exact = core.matches({
                url: '/thingers/5',
                type: 'get'
            }, { url: '/thingers/{id}' }, true);
            ok(!exact, 'not exact');
            exact = core.matches({ url: '/thingers/5' }, { url: '/thingers/5' }, true);
            ok(exact, 'exact');
        });
        test('fixture function gets id', function () {
            fixture('/thingers/{id}', function (settings) {
                return {
                    id: settings.data.id,
                    name: 'justin'
                };
            });
            stop();
            $.ajax({
                url: '/thingers/5',
                dataType: 'json',
                data: { id: 5 }
            }).done(function (data) {
                ok(data.id);
                start();
            });
        });
        if (__dirname !== '/') {
            test('replacing and removing a fixture', function () {
                var url = __dirname + '/fixtures/remove.json';
                fixture('GET ' + url, function () {
                    return { weird: 'ness!' };
                });
                stop();
                $.ajax({
                    url: url,
                    dataType: 'json'
                }).done(function (json) {
                    equal(json.weird, 'ness!', 'fixture set right');
                    fixture('GET ' + url, function () {
                        return { weird: 'ness?' };
                    });
                    $.ajax({
                        url: url,
                        dataType: 'json'
                    }).done(function (json) {
                        equal(json.weird, 'ness?', 'fixture set right');
                        fixture('GET ' + url, null);
                        $.ajax({
                            url: url,
                            dataType: 'json'
                        }).done(function (json) {
                            equal(json.weird, 'ness', 'fixture set right');
                            start();
                        });
                    });
                });
            });
        }
        test('fixture.store with can.Model', function () {
            var store = fixture.store(100, function (i) {
                return {
                    id: i,
                    name: 'Object ' + i
                };
            });
            fixture('GET /models', store.getListData);
            fixture('GET /models/{id}', store.getData);
            fixture('POST /models', store.createData);
            fixture('PUT /models/{id}', store.updateData);
            fixture('DELETE /models/{id}', store.destroyData);
            stop();
            function errorAndStart(e) {
                ok(false, 'borked' + e);
                start();
            }
            var check100Updated = function () {
                return $.ajax({
                    url: '/models/100',
                    dataType: 'json'
                }).then(function (model) {
                    equal(model.name, 'Updated test object', 'Successfully updated object');
                });
            };
            $.ajax({
                url: '/models',
                dataType: 'json'
            }).then(function (modelsData) {
                var models = modelsData.data;
                equal(models.length, 100, 'Got 100 models for findAll with no parameters');
                equal(models[95].name, 'Object 95', 'All models generated properly');
                return $.ajax({
                    url: '/models/51',
                    dataType: 'json'
                }).then(function (data) {
                    equal(data.id, 51, 'Got correct object id');
                    equal('Object 51', data.name, 'Object name generated correctly');
                    return $.ajax({
                        url: '/models',
                        dataType: 'json',
                        type: 'post',
                        data: { name: 'My test object' }
                    }).then(function (newmodel) {
                        equal(newmodel.id, 100, 'Id got incremented');
                        return $.ajax({
                            url: '/models/100',
                            dataType: 'json'
                        }).then(function (model) {
                            equal(model.id, 100, 'Loaded new object');
                            return $.ajax({
                                url: '/models/100',
                                dataType: 'json',
                                type: 'put',
                                data: { name: 'Updated test object' }
                            }).then(function (model) {
                                return check100Updated().then(function () {
                                    return $.ajax({
                                        url: '/models/100',
                                        dataType: 'json',
                                        type: 'delete'
                                    }).then(function (deleted) {
                                        start();
                                    }, errorAndStart);
                                }, errorAndStart);
                            }, errorAndStart);
                        }, errorAndStart);
                    }, errorAndStart);
                }, errorAndStart);
            }, errorAndStart);
        });
        test('GET fixture.store returns 404 on findOne with bad id (#803)', function () {
            var store = fixture.store(2, function (i) {
                return {
                    id: i,
                    name: 'Object ' + i
                };
            });
            fixture('GET /models/{id}', store.findOne);
            stop();
            $.ajax({
                url: '/models/3',
                dataType: 'json'
            }).then(function () {
            }, function (data) {
                equal(data.statusText, 'error', 'statusText');
                equal(data.responseText, 'Requested resource not found', 'responseText');
                start();
            });
        });
        test('fixture.store returns 404 on update with a bad id (#803)', function () {
            var store = fixture.store(5, function (i) {
                return {
                    id: i,
                    name: 'Object ' + i
                };
            });
            stop();
            fixture('POST /models/{id}', store.updateData);
            $.ajax({
                url: '/models/6',
                dataType: 'json',
                data: { 'jedan': 'dva' },
                type: 'POST'
            }).then(function () {
            }, function (data) {
                equal(data.statusText, 'error', 'Got an error');
                equal(data.responseText, 'Requested resource not found', 'Got correct status message');
                start();
            });
        });
        test('fixture.store returns 404 on destroy with a bad id (#803)', function () {
            var store = fixture.store(2, function (i) {
                return {
                    id: i,
                    name: 'Object ' + i
                };
            });
            stop();
            fixture('DELETE /models/{id}', store.destroy);
            $.ajax({
                url: '/models/6',
                dataType: 'json',
                type: 'DELETE'
            }).then(function () {
            }, function (data) {
                equal(data.statusText, 'error', 'Got an error');
                equal(data.responseText, 'Requested resource not found', 'Got correct status message');
                start();
            });
        });
        test('fixture.store can use id of different type (#742)', function () {
            var store = fixture.store(100, function (i) {
                return {
                    id: i,
                    parentId: i * 2,
                    name: 'Object ' + i
                };
            });
            fixture('GET /models', store.findAll);
            stop();
            $.ajax({
                url: '/models',
                dataType: 'json',
                data: { parentId: '4' }
            }).then(function (models) {
                equal(models.data.length, 1, 'Got one model');
                deepEqual(models.data[0], {
                    id: 2,
                    parentId: 4,
                    name: 'Object 2'
                });
                start();
            });
        });
        test('fixture("METHOD /path", store) should use the right method', function () {
            var store = fixture.store(100, function (i) {
                return {
                    id: i,
                    name: 'Object ' + i
                };
            });
            fixture('GET /models', store);
            stop();
            $.ajax({
                url: '/models',
                dataType: 'json'
            }).then(function (models) {
                equal(models.data.length, 100, 'Gotta catch up all!');
                start();
            });
        });
        test('fixture with response callback', 4, function () {
            fixture.delay = 10;
            fixture('responseCb', function (orig, response) {
                response({ sweet: 'ness' });
            });
            fixture('responseErrorCb', function (orig, response) {
                response(404, 'This is an error from callback');
            });
            stop();
            $.ajax({
                url: 'responseCb',
                dataType: 'json'
            }).done(function (data) {
                equal(data.sweet, 'ness', 'can.get works');
                start();
            });
            stop();
            $.ajax({
                url: 'responseErrorCb',
                dataType: 'json'
            }).fail(function (orig, error, text) {
                equal(error, 'error', 'Got error status');
                equal(orig.responseText, 'This is an error from callback', 'Got error text');
                start();
            });
            stop();
            fixture('cbWithTimeout', function (orig, response) {
                setTimeout(function () {
                    response([{ epic: 'ness' }]);
                }, 10);
            });
            $.ajax({
                url: 'cbWithTimeout',
                dataType: 'json'
            }).done(function (data) {
                equal(data[0].epic, 'ness', 'Got responsen with timeout');
                start();
            });
        });
        test('store create works with an empty array of items', function () {
            var store = fixture.store(0, function () {
                return {};
            });
            store.create({ data: {} }, function (responseData, responseHeaders) {
                equal(responseData.id, 0, 'the first id is 0');
            });
        });
        test('store creates sequential ids', function () {
            var store = fixture.store(0, function () {
                return {};
            });
            store.create({ data: {} }, function (responseData, responseHeaders) {
                equal(responseData.id, 0, 'the first id is 0');
            });
            store.create({ data: {} }, function (responseData, responseHeaders) {
                equal(responseData.id, 1, 'the second id is 1');
            });
            store.destroy({ data: { id: 0 } });
            store.create({ data: {} }, function (responseData, responseHeaders) {
                equal(responseData.id, 2, 'the third id is 2');
            });
        });
        test('fixture updates request.data with id', function () {
            expect(1);
            stop();
            fixture('foo/{id}', function (request) {
                equal(request.data.id, 5);
                start();
            });
            $.ajax({ url: 'foo/5' });
        });
        test('create a store with array and comparison object', function () {
            var store = fixture.store([
                {
                    id: 1,
                    modelId: 1,
                    year: 2013,
                    name: '2013 Mustang',
                    thumb: 'http://mustangsdaily.com/blog/wp-content/uploads/2012/07/01-2013-ford-mustang-gt-review-585x388.jpg'
                },
                {
                    id: 2,
                    modelId: 1,
                    year: 2014,
                    name: '2014 Mustang',
                    thumb: 'http://mustangsdaily.com/blog/wp-content/uploads/2013/03/2014-roush-mustang.jpg'
                },
                {
                    id: 2,
                    modelId: 2,
                    year: 2013,
                    name: '2013 Focus',
                    thumb: 'http://images.newcars.com/images/car-pictures/original/2013-Ford-Focus-Sedan-S-4dr-Sedan-Exterior.png'
                },
                {
                    id: 2,
                    modelId: 2,
                    year: 2014,
                    name: '2014 Focus',
                    thumb: 'http://ipinvite.iperceptions.com/Invitations/survey705/images_V2/top4.jpg'
                },
                {
                    id: 2,
                    modelId: 3,
                    year: 2013,
                    name: '2013 Altima',
                    thumb: 'http://www.blogcdn.com/www.autoblog.com/media/2012/04/04-2013-nissan-altima-1333416664.jpg'
                },
                {
                    id: 2,
                    modelId: 3,
                    year: 2014,
                    name: '2014 Altima',
                    thumb: 'http://www.blogcdn.com/www.autoblog.com/media/2012/04/01-2013-nissan-altima-ny.jpg'
                },
                {
                    id: 2,
                    modelId: 4,
                    year: 2013,
                    name: '2013 Leaf',
                    thumb: 'http://www.blogcdn.com/www.autoblog.com/media/2012/04/01-2013-nissan-altima-ny.jpg'
                },
                {
                    id: 2,
                    modelId: 4,
                    year: 2014,
                    name: '2014 Leaf',
                    thumb: 'http://images.thecarconnection.com/med/2013-nissan-leaf_100414473_m.jpg'
                }
            ], {
                year: function (a, b) {
                    return a == b;
                },
                modelId: function (a, b) {
                    return a == b;
                }
            });
            fixture('GET /presetStore', store.findAll);
            stop();
            $.ajax({
                url: '/presetStore',
                method: 'get',
                data: {
                    year: 2013,
                    modelId: 1
                },
                dataType: 'json'
            }).then(function (response) {
                equal(response.data[0].id, 1, 'got the first item');
                equal(response.data.length, 1, 'only got one item');
                start();
            });
        });
        QUnit.test('posting an empty data object', function (assert) {
            var done = assert.async();
            fixture('/data', function (req, res) {
                if (req.data == null) {
                    throw new Error('req.data should be an empty object');
                } else {
                    return {};
                }
            });
            var def = $.ajax({
                method: 'post',
                url: '/data',
                dataType: 'json',
                data: {}
            });
            def.then(function () {
                assert.ok(true, 'works!');
                done();
            }, function (e) {
                assert.notOk(e, 'should not fail');
            });
        });
        test('store with objects allows .create, .update and .destroy (#1471)', 4, function () {
            var store = fixture.store([
                {
                    id: 1,
                    modelId: 1,
                    year: 2013,
                    name: '2013 Mustang',
                    thumb: 'http://mustangsdaily.com/blog/wp-content/uploads/2012/07/01-2013-ford-mustang-gt-review-585x388.jpg'
                },
                {
                    id: 2,
                    modelId: 1,
                    year: 2014,
                    name: '2014 Mustang',
                    thumb: 'http://mustangsdaily.com/blog/wp-content/uploads/2013/03/2014-roush-mustang.jpg'
                },
                {
                    id: 3,
                    modelId: 2,
                    year: 2013,
                    name: '2013 Focus',
                    thumb: 'http://images.newcars.com/images/car-pictures/original/2013-Ford-Focus-Sedan-S-4dr-Sedan-Exterior.png'
                },
                {
                    id: 4,
                    modelId: 2,
                    year: 2014,
                    name: '2014 Focus',
                    thumb: 'http://ipinvite.iperceptions.com/Invitations/survey705/images_V2/top4.jpg'
                },
                {
                    id: 5,
                    modelId: 3,
                    year: 2013,
                    name: '2013 Altima',
                    thumb: 'http://www.blogcdn.com/www.autoblog.com/media/2012/04/04-2013-nissan-altima-1333416664.jpg'
                },
                {
                    id: 6,
                    modelId: 3,
                    year: 2014,
                    name: '2014 Altima',
                    thumb: 'http://www.blogcdn.com/www.autoblog.com/media/2012/04/01-2013-nissan-altima-ny.jpg'
                },
                {
                    id: 7,
                    modelId: 4,
                    year: 2013,
                    name: '2013 Leaf',
                    thumb: 'http://www.blogcdn.com/www.autoblog.com/media/201204/01-2013-nissan-altima-ny.jpg'
                },
                {
                    id: 8,
                    modelId: 4,
                    year: 2014,
                    name: '2014 Leaf',
                    thumb: 'http://images.thecarconnection.com/med/2013-nissan-leaf_100414473_m.jpg'
                }
            ]);
            fixture('GET /cars', store.findAll);
            fixture('POST /cars', store.create);
            fixture('PUT /cars/{id}', store.update);
            fixture('DELETE /cars/{id}', store.destroy);
            var findAll = function () {
                return $.ajax({
                    url: '/cars',
                    dataType: 'json'
                });
            };
            stop();
            findAll().then(function (carsData) {
                equal(carsData.data.length, 8, 'Got all cars');
                return $.ajax({
                    url: '/cars/' + carsData.data[1].id,
                    method: 'DELETE',
                    dataType: 'json'
                });
            }).then(function () {
                return findAll();
            }).then(function (carsData) {
                equal(carsData.data.length, 7, 'One car less');
                equal(carsData.data[1].name, '2013 Focus', 'Car actually deleted');
            }).then(function () {
                return $.ajax({
                    url: '/cars',
                    method: 'post',
                    dataType: 'json',
                    data: {
                        modelId: 3,
                        year: 2015,
                        name: '2015 Altima'
                    }
                });
            }).then(function (saved) {
                return $.ajax({
                    url: '/cars/' + saved.id,
                    method: 'put',
                    dataType: 'json',
                    data: {
                        modelId: 3,
                        year: 2015,
                        name: '2015 Nissan Altima'
                    }
                });
            }).then(function (updated) {
                return findAll();
            }).then(function (cars) {
                equal(cars.data.length, 8, 'New car created');
                start();
            });
        });
        test('filtering works', function () {
            var next;
            var store = fixture.store([
                {
                    state: 'CA',
                    name: 'Casadina'
                },
                {
                    state: 'NT',
                    name: 'Alberny'
                }
            ], {});
            fixture({ 'GET /api/cities': store.findAll });
            stop();
            $.getJSON('/api/cities?state=CA').then(function (data) {
                deepEqual(data, {
                    data: [{
                            state: 'CA',
                            name: 'Casadina'
                        }],
                    count: 1
                });
                next();
            }, function (e) {
                ok(false, '' + e);
                start();
            });
            next = function () {
                var store = fixture.store([
                    {
                        _id: 1,
                        name: 'Cheese City',
                        slug: 'cheese-city',
                        address: {
                            city: 'Casadina',
                            state: 'CA'
                        }
                    },
                    {
                        _id: 2,
                        name: 'Crab Barn',
                        slug: 'crab-barn',
                        address: {
                            city: 'Alberny',
                            state: 'NT'
                        }
                    }
                ], {});
                fixture({ 'GET /restaurants': store.findAll });
                $.getJSON('/api/restaurants?address[city]=Alberny').then(function (responseData) {
                    deepEqual(responseData, {
                        count: 1,
                        data: [{
                                _id: 2,
                                name: 'Crab Barn',
                                slug: 'crab-barn',
                                address: {
                                    city: 'Alberny',
                                    state: 'NT'
                                }
                            }]
                    });
                    last();
                }, function (e) {
                    ok(false);
                    start();
                });
            };
            function last() {
                var store = fixture.store([
                    {
                        _id: 1,
                        name: 'Cheese City',
                        slug: 'cheese-city',
                        address: {
                            city: 'Casadina',
                            state: 'CA'
                        }
                    },
                    {
                        _id: 2,
                        name: 'Crab Barn',
                        slug: 'crab-barn',
                        address: {
                            city: 'Alberny',
                            state: 'NT'
                        }
                    }
                ], {
                    'address.city': function (restaurantValue, paramValue, restaurant, params) {
                        return restaurant.address.city === paramValue;
                    }
                });
                var responseData = store.findAll({ data: { 'address.city': 'Alberny' } });
                deepEqual(responseData, {
                    count: 1,
                    data: [{
                            _id: 2,
                            name: 'Crab Barn',
                            slug: 'crab-barn',
                            address: {
                                city: 'Alberny',
                                state: 'NT'
                            }
                        }]
                });
                start();
            }
        });
        QUnit.test('onreadystatechange, event is passed', function () {
            fixture('GET something', function () {
                return {};
            });
            var xhr = new XMLHttpRequest();
            xhr.open('GET', 'something');
            xhr.onreadystatechange = function (ev) {
                ok(ev.target != null, 'the event object passed to onreadystatechange');
                start();
            };
            xhr.send();
            stop();
        });
        if (__dirname !== '/') {
            asyncTest('doesn\'t break onreadystatechange (#3)', function () {
                var url = __dirname + '/fixtures/test.json';
                var xhr = new XMLHttpRequest();
                xhr.onreadystatechange = function () {
                    if (xhr.readyState === 4) {
                        ok(true, 'we made a successful request');
                        start();
                    }
                };
                xhr.open('GET', url);
                xhr.send();
            });
        }
        QUnit.module('XHR Shim');
        test('Supports onload', function () {
            var xhr = new XMLHttpRequest();
            QUnit.ok('onload' in xhr, 'shim passes onload detection');
        });
        if (__dirname !== '/') {
            asyncTest('supports addEventListener on XHR shim', function () {
                var url = __dirname + '/fixtures/test.json';
                var xhr = new XMLHttpRequest();
                xhr.addEventListener('load', function () {
                    ok(true, 'our shim supports addEventListener');
                    start();
                });
                xhr.open('GET', url);
                xhr.send();
            });
        }
        if (__dirname !== '/') {
            asyncTest('supports removeEventListener on XHR shim', function () {
                var url = __dirname + '/fixtures/test.json';
                var xhr = new XMLHttpRequest();
                var onload = function () {
                    ok(false, 'this should not be called');
                };
                xhr.addEventListener('load', onload);
                xhr.removeEventListener('load', onload);
                xhr.onload = function () {
                    setTimeout(function () {
                        ok(true, 'didn\'t call the event listener');
                        start();
                    });
                };
                xhr.open('GET', url);
                xhr.send();
            });
        }
        test('supports setDisableHeaderCheck', function () {
            var xhr = new XMLHttpRequest();
            try {
                xhr.setDisableHeaderCheck(true);
                ok(true, 'did not throw');
            } catch (e) {
                ok(false, 'do not support setDisableHeaderCheck');
            }
        });
        if (__dirname !== '/') {
            asyncTest('supports setRequestHeader', function () {
                var url = __dirname + '/fixtures/test.json';
                var xhr = new XMLHttpRequest();
                xhr.setRequestHeader('foo', 'bar');
                xhr.onreadystatechange = function () {
                    if (xhr.readyState === 4) {
                        equal(xhr._requestHeaders.foo, 'bar', 'header was set');
                        start();
                    }
                };
                xhr.open('GET', url);
                xhr.send();
            });
        }
        if (__dirname !== '/') {
            asyncTest('supports getResponseHeader', function () {
                var url = __dirname + '/fixtures/test.json';
                var xhr = new XMLHttpRequest();
                xhr.onreadystatechange = function () {
                    if (xhr.readyState === 4) {
                        var header = xhr.getResponseHeader('Content-Type');
                        ok(header.indexOf('application/json') >= 0, 'got correct header back');
                        start();
                    }
                };
                xhr.open('GET', url);
                xhr.send();
            });
        }
        asyncTest('supports getAllResponseHeaders', function () {
            fixture('GET something', function (req, res) {
                res(200, { message: 'this is the body' }, { foo: 'bar' });
            });
            var xhr = new XMLHttpRequest();
            xhr.onreadystatechange = function () {
                if (xhr.readyState === 4) {
                    var headers = xhr.getAllResponseHeaders();
                    var parsed = parseHeaders(headers);
                    ok(typeof headers === 'string', 'got headers back');
                    ok(parsed.foo === 'bar', 'got proper values');
                    start();
                }
            };
            xhr.open('GET', 'something');
            xhr.send();
        });
        asyncTest('pass data to response handler (#13)', function () {
            fixture('GET something', function (req, res) {
                res(403, { message: 'No bad guys' });
            });
            var xhr = new XMLHttpRequest();
            xhr.open('GET', 'something');
            xhr.onreadystatechange = function (ev) {
                deepEqual(JSON.parse(this.responseText), { message: 'No bad guys' }, 'correct response');
                equal(this.status, 403, 'correct status');
                start();
            };
            xhr.send();
        });
        asyncTest('pass return value for fixture', function () {
            fixture('GET something', { foo: 'bar' });
            var xhr = new XMLHttpRequest();
            xhr.open('GET', 'something');
            xhr.onreadystatechange = function (ev) {
                deepEqual(JSON.parse(this.responseText), { foo: 'bar' }, 'correct response');
                equal(this.status, 200, 'correct status');
                start();
            };
            xhr.send();
        });
        if (__dirname !== '/') {
            asyncTest('pass headers in fallthrough', function () {
                var url = __dirname + '/fixtures/foobar.json';
                var xhr = new XMLHttpRequest();
                expect(2);
                xhr.open('GET', url);
                xhr.setRequestHeader('foo', 'bar');
                xhr.onreadystatechange = function (ev) {
                    var originalXhr = ev.target;
                    if (originalXhr.readyState === 1) {
                        originalXhr.setRequestHeader = function (key, val) {
                            equal(key, 'foo');
                            equal(val, 'bar');
                        };
                    }
                    if (originalXhr.readyState === 4) {
                        start();
                    }
                };
                xhr.send();
            });
        }
        test('set.Algebra CRUD works (#12)', 5, function () {
            var algebra = new set.Algebra(new set.Translate('where', 'where'), set.props.id('_id'), set.props.sort('orderBy'), set.props.enum('type', [
                'used',
                'new',
                'certified'
            ]), set.props.rangeInclusive('start', 'end'));
            var store = fixture.store([
                {
                    _id: 1,
                    modelId: 1,
                    year: 2013,
                    name: '2013 Mustang',
                    type: 'used'
                },
                {
                    _id: 2,
                    modelId: 1,
                    year: 2014,
                    name: '2014 Mustang',
                    type: 'new'
                },
                {
                    _id: 3,
                    modelId: 2,
                    year: 2013,
                    name: '2013 Focus',
                    type: 'used'
                },
                {
                    _id: 4,
                    modelId: 2,
                    year: 2014,
                    name: '2014 Focus',
                    type: 'certified'
                },
                {
                    _id: 5,
                    modelId: 3,
                    year: 2013,
                    name: '2013 Altima',
                    type: 'used'
                },
                {
                    _id: 6,
                    modelId: 3,
                    year: 2014,
                    name: '2014 Altima',
                    type: 'certified'
                },
                {
                    _id: 7,
                    modelId: 4,
                    year: 2013,
                    name: '2013 Leaf',
                    type: 'used'
                },
                {
                    _id: 8,
                    modelId: 4,
                    year: 2014,
                    name: '2014 Leaf',
                    type: 'used'
                }
            ], algebra);
            fixture('GET /cars', store.findAll);
            fixture('POST /cars', store.create);
            fixture('PUT /cars/{_id}', store.update);
            fixture('DELETE /cars/{_id}', store.destroy);
            fixture('GET /cars/{_id}', store.findOne);
            var findAll = function () {
                return $.ajax({
                    url: '/cars',
                    dataType: 'json'
                });
            };
            stop();
            findAll().then(function (carsData) {
                equal(carsData.data.length, 8, 'Got all cars');
                return $.ajax({
                    url: '/cars/' + carsData.data[1]._id,
                    method: 'DELETE',
                    dataType: 'json'
                });
            }).then(function () {
                return findAll();
            }).then(function (carsData) {
                equal(carsData.data.length, 7, 'One car less');
                equal(carsData.data[1].name, '2013 Focus', 'Car actually deleted');
            }).then(function () {
                return $.ajax({
                    url: '/cars',
                    method: 'post',
                    dataType: 'json',
                    data: {
                        modelId: 3,
                        year: 2015,
                        name: '2015 Altima',
                        type: 'new'
                    }
                });
            }).then(function (saved) {
                return $.ajax({
                    url: '/cars/' + saved._id,
                    method: 'put',
                    dataType: 'json',
                    data: {
                        modelId: 3,
                        year: 2015,
                        name: '2015 Nissan Altima'
                    }
                });
            }).then(function (updated) {
                return findAll();
            }).then(function (cars) {
                equal(cars.data.length, 8, 'New car created');
                return $.ajax({
                    url: '/cars/5',
                    method: 'get',
                    dataType: 'json'
                });
            }).then(function (car) {
                equal(car.name, '2013 Altima', 'get a single car works');
                start();
            });
        });
        test('set.Algebra CRUD works (#12)', 5, function () {
            var algebra = new set.Algebra(new set.Translate('where', 'where'), set.props.id('_id'), set.props.sort('orderBy'), set.props.enum('type', [
                'used',
                'new',
                'certified'
            ]), set.props.rangeInclusive('start', 'end'));
            var store = fixture.store([
                {
                    _id: 1,
                    modelId: 1,
                    year: 2013,
                    name: '2013 Mustang',
                    type: 'used'
                },
                {
                    _id: 2,
                    modelId: 1,
                    year: 2014,
                    name: '2014 Mustang',
                    type: 'new'
                },
                {
                    _id: 3,
                    modelId: 2,
                    year: 2013,
                    name: '2013 Focus',
                    type: 'used'
                },
                {
                    _id: 4,
                    modelId: 2,
                    year: 2014,
                    name: '2014 Focus',
                    type: 'certified'
                },
                {
                    _id: 5,
                    modelId: 3,
                    year: 2013,
                    name: '2013 Altima',
                    type: 'used'
                },
                {
                    _id: 6,
                    modelId: 3,
                    year: 2014,
                    name: '2014 Altima',
                    type: 'certified'
                },
                {
                    _id: 7,
                    modelId: 4,
                    year: 2013,
                    name: '2013 Leaf',
                    type: 'used'
                },
                {
                    _id: 8,
                    modelId: 4,
                    year: 2014,
                    name: '2014 Leaf',
                    type: 'used'
                }
            ], algebra);
            fixture('GET /cars', store.getListData);
            fixture('POST /cars', store.createData);
            fixture('PUT /cars/{_id}', store.updateData);
            fixture('DELETE /cars/{_id}', store.destroyData);
            fixture('GET /cars/{_id}', store.getData);
            var findAll = function () {
                return $.ajax({
                    url: '/cars',
                    dataType: 'json'
                });
            };
            stop();
            findAll().then(function (carsData) {
                equal(carsData.data.length, 8, 'Got all cars');
                return $.ajax({
                    url: '/cars/' + carsData.data[1]._id,
                    method: 'DELETE',
                    dataType: 'json'
                });
            }).then(function () {
                return findAll();
            }).then(function (carsData) {
                equal(carsData.data.length, 7, 'One car less');
                equal(carsData.data[1].name, '2013 Focus', 'Car actually deleted');
            }).then(function () {
                return $.ajax({
                    url: '/cars',
                    method: 'post',
                    dataType: 'json',
                    data: {
                        modelId: 3,
                        year: 2015,
                        name: '2015 Altima',
                        type: 'new'
                    }
                });
            }).then(function (saved) {
                return $.ajax({
                    url: '/cars/' + saved._id,
                    method: 'put',
                    dataType: 'json',
                    data: {
                        modelId: 3,
                        year: 2015,
                        name: '2015 Nissan Altima'
                    }
                });
            }).then(function (updated) {
                return findAll();
            }).then(function (cars) {
                equal(cars.data.length, 8, 'New car created');
                return $.ajax({
                    url: '/cars/5',
                    method: 'get',
                    dataType: 'json'
                });
            }).then(function (car) {
                equal(car.name, '2013 Altima', 'get a single car works');
                start();
            });
        });
        asyncTest('set.Algebra clauses work', function () {
            var algebra = new set.Algebra(new set.Translate('where', 'where'), set.props.id('_id'), set.props.sort('orderBy'), set.props.enum('type', [
                'used',
                'new',
                'certified'
            ]), set.props.rangeInclusive('start', 'end'), {
                year: function (a, b) {
                    if (a === b) {
                        return true;
                    }
                    if (a && b) {
                        return +a === +b;
                    }
                    return false;
                }
            });
            var store = fixture.store([
                {
                    _id: 1,
                    modelId: 1,
                    year: 2013,
                    name: '2013 Mustang',
                    type: 'used'
                },
                {
                    _id: 2,
                    modelId: 1,
                    year: 2014,
                    name: '2014 Mustang',
                    type: 'new'
                },
                {
                    _id: 3,
                    modelId: 2,
                    year: 2013,
                    name: '2013 Focus',
                    type: 'used'
                },
                {
                    _id: 4,
                    modelId: 2,
                    year: 2014,
                    name: '2014 Focus',
                    type: 'certified'
                },
                {
                    _id: 5,
                    modelId: 3,
                    year: 2013,
                    name: '2013 Altima',
                    type: 'used'
                },
                {
                    _id: 6,
                    modelId: 3,
                    year: 2014,
                    name: '2014 Altima',
                    type: 'certified'
                },
                {
                    _id: 7,
                    modelId: 4,
                    year: 2013,
                    name: '2013 Leaf',
                    type: 'used'
                },
                {
                    _id: 8,
                    modelId: 4,
                    year: 2014,
                    name: '2014 Leaf',
                    type: 'used'
                }
            ], algebra);
            fixture('GET /cars', store.findAll);
            $.ajax({
                url: '/cars?where[year]=2013',
                dataType: 'json'
            }).then(function (carsData) {
                equal(carsData.data.length, 4, 'Where clause works with numbers');
                return $.ajax({
                    url: '/cars?where[year]=2013&orderBy=name',
                    dataType: 'json'
                });
            }).then(function (carsData) {
                var names = carsData.data.map(function (c) {
                    return c.name;
                });
                deepEqual(names, [
                    '2013 Altima',
                    '2013 Focus',
                    '2013 Leaf',
                    '2013 Mustang'
                ], 'sort works');
                return $.ajax({
                    url: '/cars?where[year]=2013&orderBy=name&start=1&end=2',
                    dataType: 'json'
                });
            }).then(function (carsData) {
                var names = carsData.data.map(function (c) {
                    return c.name;
                });
                deepEqual(names, [
                    '2013 Focus',
                    '2013 Leaf'
                ], 'pagination works');
                start();
            });
        });
        test('storeConnection reset', function () {
            var algebra = new set.Algebra(new set.Translate('where', 'where'), set.props.id('_id'));
            var store = fixture.store([
                {
                    _id: 1,
                    modelId: 1,
                    year: 2013,
                    name: '2013 Mustang',
                    type: 'used'
                },
                {
                    _id: 2,
                    modelId: 1,
                    year: 2014,
                    name: '2014 Mustang',
                    type: 'new'
                }
            ], algebra);
            fixture('GET /cars', store.getListData);
            fixture('POST /cars', store.createData);
            fixture('PUT /cars/{_id}', store.updateData);
            fixture('DELETE /cars/{_id}', store.destroyData);
            fixture('GET /cars/{_id}', store.getData);
            var findAll = function () {
                return $.ajax({
                    url: '/cars',
                    dataType: 'json'
                });
            };
            $.ajax({
                url: '/cars/1',
                method: 'DELETE',
                dataType: 'json'
            }).then(function () {
                store.reset();
                return findAll();
            }).then(function (carsData) {
                equal(carsData.data.length, 2, 'Got all cars');
                start();
            });
            stop();
        });
        function makeAlgebraTest(fixtureUrl) {
            return function () {
                var algebra = new set.Algebra(new set.Translate('where', 'where'), set.props.id('_id'), set.props.sort('orderBy'), set.props.enum('type', [
                    'used',
                    'new',
                    'certified'
                ]), set.props.rangeInclusive('start', 'end'));
                var store = fixture.store([
                    {
                        _id: 1,
                        modelId: 1,
                        year: 2013,
                        name: '2013 Mustang',
                        type: 'used'
                    },
                    {
                        _id: 2,
                        modelId: 1,
                        year: 2014,
                        name: '2014 Mustang',
                        type: 'new'
                    },
                    {
                        _id: 3,
                        modelId: 2,
                        year: 2013,
                        name: '2013 Focus',
                        type: 'used'
                    },
                    {
                        _id: 4,
                        modelId: 2,
                        year: 2014,
                        name: '2014 Focus',
                        type: 'certified'
                    },
                    {
                        _id: 5,
                        modelId: 3,
                        year: 2013,
                        name: '2013 Altima',
                        type: 'used'
                    },
                    {
                        _id: 6,
                        modelId: 3,
                        year: 2014,
                        name: '2014 Altima',
                        type: 'certified'
                    },
                    {
                        _id: 7,
                        modelId: 4,
                        year: 2013,
                        name: '2013 Leaf',
                        type: 'used'
                    },
                    {
                        _id: 8,
                        modelId: 4,
                        year: 2014,
                        name: '2014 Leaf',
                        type: 'used'
                    }
                ], algebra);
                fixture(fixtureUrl, store);
                var findAll = function () {
                    return $.ajax({
                        url: '/cars',
                        dataType: 'json'
                    });
                };
                stop();
                findAll().then(function (carsData) {
                    equal(carsData.data.length, 8, 'Got all cars');
                    return $.ajax({
                        url: '/cars/' + carsData.data[1]._id,
                        method: 'DELETE',
                        dataType: 'json'
                    });
                }).then(function () {
                    return findAll();
                }).then(function (carsData) {
                    equal(carsData.data.length, 7, 'One car less');
                    equal(carsData.data[1].name, '2013 Focus', 'Car actually deleted');
                }).then(function () {
                    return $.ajax({
                        url: '/cars',
                        method: 'post',
                        dataType: 'json',
                        data: {
                            modelId: 3,
                            year: 2015,
                            name: '2015 Altima',
                            type: 'new'
                        }
                    });
                }).then(function (saved) {
                    return $.ajax({
                        url: '/cars/' + saved._id,
                        method: 'put',
                        dataType: 'json',
                        data: {
                            modelId: 3,
                            year: 2015,
                            name: '2015 Nissan Altima'
                        }
                    });
                }).then(function (updated) {
                    return findAll();
                }).then(function (cars) {
                    equal(cars.data.length, 8, 'New car created');
                    return $.ajax({
                        url: '/cars/5',
                        method: 'get',
                        dataType: 'json'
                    });
                }).then(function (car) {
                    equal(car.name, '2013 Altima', 'get a single car works');
                    start();
                });
            };
        }
        test('set.Algebra CRUD works with easy hookup (#12)', 5, makeAlgebraTest('/cars/{_id}'));
        test('set.Algebra CRUD works with easy hookup and list-style url (#52)', 5, makeAlgebraTest('/cars'));
        test('store.getList and store.get', function () {
            var algebra = new set.Algebra(set.props.id('_id'));
            var store = fixture.store([
                {
                    _id: 1,
                    modelId: 1,
                    year: 2013,
                    name: '2013 Mustang',
                    type: 'used'
                },
                {
                    _id: 2,
                    modelId: 1,
                    year: 2014,
                    name: '2014 Mustang',
                    type: 'new'
                },
                {
                    _id: 3,
                    modelId: 2,
                    year: 2013,
                    name: '2013 Focus',
                    type: 'used'
                },
                {
                    _id: 4,
                    modelId: 2,
                    year: 2014,
                    name: '2014 Focus',
                    type: 'certified'
                },
                {
                    _id: 5,
                    modelId: 3,
                    year: 2013,
                    name: '2013 Altima',
                    type: 'used'
                },
                {
                    _id: 6,
                    modelId: 3,
                    year: 2014,
                    name: '2014 Altima',
                    type: 'certified'
                },
                {
                    _id: 7,
                    modelId: 4,
                    year: 2013,
                    name: '2013 Leaf',
                    type: 'used'
                },
                {
                    _id: 8,
                    modelId: 4,
                    year: 2014,
                    name: '2014 Leaf',
                    type: 'used'
                }
            ], algebra);
            equal(store.getList({ year: 2013 }).data.length, 4, 'filtered');
            deepEqual(store.get({ _id: 5 }).name, '2013 Altima', 'get');
        });
        asyncTest('supports addEventListener on shim using fixture', function () {
            fixture('/addEventListener', function () {
                return {};
            });
            var xhr = new XMLHttpRequest();
            xhr.addEventListener('load', function () {
                ok(true, 'our shim supports addEventListener');
                start();
            });
            xhr.open('GET', '/addEventListener');
            xhr.send();
        });
        if (__dirname !== '/') {
            test('supports sync on XHR shim (#23)', function () {
                var url = __dirname + '/fixtures/test.json';
                var xhr = new XMLHttpRequest();
                xhr.addEventListener('load', function () {
                    ok(true, 'our shim supports addEventListener');
                });
                xhr.open('GET', url, false);
                xhr.send();
            });
        }
        test('supports sync fixtures (#23)', function () {
            fixture('/sync', function () {
                return {};
            });
            var xhr = new XMLHttpRequest();
            xhr.addEventListener('load', function () {
                ok(true, 'our shim supports sync');
            });
            xhr.open('GET', '/sync', false);
            xhr.send();
        });
        if (__dirname !== '/') {
            test('supports sync redirect fixtures (#23)', function () {
                fixture('/sync_redirect', __dirname + '/fixtures/test.json');
                var xhr = new XMLHttpRequest();
                xhr.addEventListener('load', function () {
                    ok(true, 'our shim supports sync redirect');
                });
                xhr.open('GET', '/sync_redirect', false);
                xhr.send();
            });
        }
        if (__dirname !== '/') {
            asyncTest('slow mode works (#26)', function () {
                var url = __dirname + '/fixtures/test.json';
                fixture({ url: url }, 1000);
                var xhr = new XMLHttpRequest();
                var startTime = new Date();
                xhr.addEventListener('load', function () {
                    var delay = new Date() - startTime;
                    ok(delay >= 900, delay + 'ms >= 900ms');
                    fixture({ url: url }, null);
                    start();
                });
                xhr.open('GET', url);
                xhr.send();
            });
        }
        asyncTest('onload should be triggered for HTTP error responses (#36)', function () {
            fixture('/onload', function (req, res) {
                res(400);
            });
            var xhr = new XMLHttpRequest();
            xhr.addEventListener('load', function () {
                ok(true, 'onload should be invoked');
                fixture('/onload', null);
                start();
            });
            xhr.addEventListener('error', function () {
                ok(false, 'onerror should not be invoked');
                fixture('/onload', null);
                start();
            });
            xhr.open('GET', '/onload');
            xhr.send();
        });
        asyncTest('responseText & responseXML should not be set for arraybuffer types (#38)', function () {
            fixture('/onload', '/test/fixtures/foo.json');
            var oldError = window.onerror;
            window.onerror = function (msg, url, line) {
                ok(false, 'There should not be an error');
                start();
            };
            var xhr = new XMLHttpRequest();
            xhr.addEventListener('load', function () {
                fixture('/onload', null);
                window.onerror = oldError;
                ok(true, 'Got here without an error');
                start();
            });
            xhr.responseType = 'arraybuffer';
            xhr.open('GET', '/onload');
            xhr.send();
        });
        asyncTest('fixture with timeout does not run if $.ajax timeout less than delay', function () {
            var delay = fixture.delay;
            fixture.delay = 1000;
            fixture('/onload', function () {
                fixture('/onload', null);
                ok(false, 'timed out xhr did not abort');
                start();
            });
            $.ajax({
                url: '/onload',
                timeout: 50,
                error: function (xhr) {
                    fixture('/onload', null);
                    ok(true, 'Got to the error handler');
                    equal(xhr.statusText, 'timeout');
                    equal(xhr.status, '0');
                    start();
                }
            });
            fixture.delay = delay;
        });
        asyncTest('response headers are set', function () {
            fixture('GET /todos', function (request, response) {
                response(200, '{}', { foo: 'bar' });
            });
            var xhr = new XMLHttpRequest();
            xhr.addEventListener('load', function () {
                var headers = parseHeaders(xhr.getAllResponseHeaders());
                ok(headers.foo === 'bar', 'header was set');
                start();
            });
            xhr.open('GET', '/todos');
            xhr.send();
        });
        asyncTest('match values in get data', function () {
            fixture({
                method: 'GET',
                url: '/data-value',
                data: { name: 'justin' }
            }, function (request, response) {
                QUnit.ok(true, 'got it');
                return {};
            });
            var xhr = new XMLHttpRequest();
            xhr.addEventListener('load', function () {
                QUnit.start();
            });
            xhr.open('GET', '/data-value?name=justin&age=22');
            xhr.send();
        });
        asyncTest('universal match (#2000)', function () {
            fixture({}, function () {
                ok(true, 'got hit');
                return {};
            });
            var xhr = new XMLHttpRequest();
            xhr.addEventListener('load', function () {
                QUnit.start();
                fixture.fixtures.splice(0, fixture.fixtures.length);
            });
            xhr.open('GET', '/something-totally-unexpected-62');
            xhr.send();
        });
        test('set.Algebra stores provide a count (#58)', function () {
            var algebra = new set.Algebra(new set.Translate('where', 'where'), set.props.id('_id'), set.props.sort('orderBy'), set.props.enum('type', [
                'used',
                'new',
                'certified'
            ]), set.props.rangeInclusive('start', 'end'));
            var store = fixture.store([
                {
                    _id: 1,
                    modelId: 1,
                    year: 2013,
                    name: '2013 Mustang',
                    type: 'used'
                },
                {
                    _id: 2,
                    modelId: 1,
                    year: 2014,
                    name: '2014 Mustang',
                    type: 'new'
                },
                {
                    _id: 3,
                    modelId: 2,
                    year: 2013,
                    name: '2013 Focus',
                    type: 'used'
                },
                {
                    _id: 4,
                    modelId: 2,
                    year: 2014,
                    name: '2014 Focus',
                    type: 'certified'
                },
                {
                    _id: 5,
                    modelId: 3,
                    year: 2013,
                    name: '2013 Altima',
                    type: 'used'
                },
                {
                    _id: 6,
                    modelId: 3,
                    year: 2014,
                    name: '2014 Altima',
                    type: 'certified'
                },
                {
                    _id: 7,
                    modelId: 4,
                    year: 2013,
                    name: '2013 Leaf',
                    type: 'used'
                },
                {
                    _id: 8,
                    modelId: 4,
                    year: 2014,
                    name: '2014 Leaf',
                    type: 'used'
                }
            ], algebra);
            fixture('/cars/{_id}', store);
            stop();
            $.ajax({
                url: '/cars',
                dataType: 'json',
                data: {
                    start: 2,
                    end: 3
                }
            }).then(function (carsData) {
                equal(carsData.data.length, 2, 'Got 2 cars');
                equal(carsData.count, 8, 'got the count');
                QUnit.start();
            }, function () {
                QUnit.ok(false, 'borked');
                QUnit.start();
            });
        });
        asyncTest('should allow Arrays as data type (#133)', function () {
            fixture('/array-data', function (req, res) {
                ok(req.data instanceof Array, 'data returned should be instance of Array');
                return {};
            });
            var data = [];
            var xhr = new XMLHttpRequest();
            xhr.addEventListener('load', function () {
                fixture('/array-data', null);
                ok(true, 'should not throw when sending Array');
                start();
            });
            xhr.open('GET', '/array-data');
            xhr.send(data);
        });
        asyncTest('should allow FormData as data type (#133)', function () {
            fixture('/upload', function (req, res) {
                ok(req.data instanceof FormData, 'data returned should be instance of formdata');
                res(400);
            });
            var data = new FormData();
            var xhr = new XMLHttpRequest();
            xhr.addEventListener('load', function () {
                fixture('/upload', null);
                ok(true, 'should not throw when sending FormData');
                start();
            });
            xhr.open('POST', '/upload', true);
            xhr.send(data);
        });
        if ('onabort' in XMLHttpRequest._XHR.prototype) {
            asyncTest('fixture with timeout aborts if xhr timeout less than delay', function () {
                fixture('/onload', 1000);
                var xhr = new XMLHttpRequest();
                xhr.open('GET', '/onload');
                xhr.send();
                setTimeout(function () {
                    xhr.abort();
                }, 50);
                xhr.addEventListener('abort', function () {
                    fixture('/onload', null);
                    ok(true, 'Got to the error handler');
                    equal(xhr.statusText, '');
                    equal(xhr.status, 0);
                    start();
                });
                xhr.addEventListener('load', function () {
                    fixture('/onload', null);
                    ok(false, 'timed out xhr did not abort');
                    start();
                });
            });
            asyncTest('dynamic fixture with timeout does not run if xhr timeout less than delay', function () {
                var delay = fixture.delay;
                fixture.delay = 1000;
                fixture('/onload', function () {
                    fixture('/onload', null);
                    ok(false, 'timed out xhr did not abort');
                    start();
                });
                var xhr = new XMLHttpRequest();
                xhr.open('GET', '/onload');
                setTimeout(function () {
                    xhr.abort();
                }, 50);
                xhr.send();
                xhr.addEventListener('abort', function () {
                    fixture('/onload', null);
                    ok(true, 'Got to the error handler');
                    equal(xhr.statusText, '');
                    equal(xhr.status, 0);
                    start();
                });
                fixture.delay = delay;
            });
            test('abort() sets readyState correctly', function () {
                stop();
                fixture('/foo', function () {
                    return {};
                });
                var xhr = new XMLHttpRequest();
                xhr.open('GET', '/foo');
                xhr.addEventListener('abort', function () {
                    fixture('/foo', null);
                    ok(true, 'Got to the error handler');
                    equal(xhr.status, 0);
                    equal(xhr.statusText, '');
                    setTimeout(function () {
                        equal(xhr.readyState, 0);
                        start();
                    }, 50);
                });
                xhr.send();
                xhr.abort();
            });
            test('abort() of already completed fixture', function () {
                stop();
                fixture('/foo', function () {
                    return {};
                });
                var xhr = new XMLHttpRequest();
                xhr.open('GET', '/foo');
                xhr.addEventListener('load', function () {
                    fixture('/foo', null);
                    equal(xhr.readyState, 4);
                    xhr.abort();
                    start();
                });
                xhr.send();
            });
            asyncTest('should be able to call getResponseHeader onload', function () {
                fixture('/onload', function (req, res) {
                    res(400);
                });
                var xhr = new XMLHttpRequest();
                xhr.addEventListener('load', function () {
                    fixture('/onload', null);
                    xhr.getResponseHeader('Set-Cookie');
                    ok(true, 'should not throw when calling getResponseHeader');
                    start();
                });
                xhr.open('GET', '/onload');
                xhr.send();
            });
        }
    }('/', require, exports, module));
});
/*kefir@3.8.1#dist/kefir*/
(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) : typeof define === 'function' && define.amd ? define('kefir@3.8.1#dist/kefir', ['exports'], factory) : factory(global.Kefir = global.Kefir || {});
}(this, function (exports) {
    'use strict';
    function createObj(proto) {
        var F = function () {
        };
        F.prototype = proto;
        return new F();
    }
    function extend(target) {
        var length = arguments.length, i = void 0, prop = void 0;
        for (i = 1; i < length; i++) {
            for (prop in arguments[i]) {
                target[prop] = arguments[i][prop];
            }
        }
        return target;
    }
    function inherit(Child, Parent) {
        var length = arguments.length, i = void 0;
        Child.prototype = createObj(Parent.prototype);
        Child.prototype.constructor = Child;
        for (i = 2; i < length; i++) {
            extend(Child.prototype, arguments[i]);
        }
        return Child;
    }
    var NOTHING = ['<nothing>'];
    var END = 'end';
    var VALUE = 'value';
    var ERROR = 'error';
    var ANY = 'any';
    function concat(a, b) {
        var result = void 0, length = void 0, i = void 0, j = void 0;
        if (a.length === 0) {
            return b;
        }
        if (b.length === 0) {
            return a;
        }
        j = 0;
        result = new Array(a.length + b.length);
        length = a.length;
        for (i = 0; i < length; i++, j++) {
            result[j] = a[i];
        }
        length = b.length;
        for (i = 0; i < length; i++, j++) {
            result[j] = b[i];
        }
        return result;
    }
    function find(arr, value) {
        var length = arr.length, i = void 0;
        for (i = 0; i < length; i++) {
            if (arr[i] === value) {
                return i;
            }
        }
        return -1;
    }
    function findByPred(arr, pred) {
        var length = arr.length, i = void 0;
        for (i = 0; i < length; i++) {
            if (pred(arr[i])) {
                return i;
            }
        }
        return -1;
    }
    function cloneArray(input) {
        var length = input.length, result = new Array(length), i = void 0;
        for (i = 0; i < length; i++) {
            result[i] = input[i];
        }
        return result;
    }
    function remove(input, index) {
        var length = input.length, result = void 0, i = void 0, j = void 0;
        if (index >= 0 && index < length) {
            if (length === 1) {
                return [];
            } else {
                result = new Array(length - 1);
                for (i = 0, j = 0; i < length; i++) {
                    if (i !== index) {
                        result[j] = input[i];
                        j++;
                    }
                }
                return result;
            }
        } else {
            return input;
        }
    }
    function map(input, fn) {
        var length = input.length, result = new Array(length), i = void 0;
        for (i = 0; i < length; i++) {
            result[i] = fn(input[i]);
        }
        return result;
    }
    function forEach(arr, fn) {
        var length = arr.length, i = void 0;
        for (i = 0; i < length; i++) {
            fn(arr[i]);
        }
    }
    function fillArray(arr, value) {
        var length = arr.length, i = void 0;
        for (i = 0; i < length; i++) {
            arr[i] = value;
        }
    }
    function contains(arr, value) {
        return find(arr, value) !== -1;
    }
    function slide(cur, next, max) {
        var length = Math.min(max, cur.length + 1), offset = cur.length - length + 1, result = new Array(length), i = void 0;
        for (i = offset; i < length; i++) {
            result[i - offset] = cur[i];
        }
        result[length - 1] = next;
        return result;
    }
    function callSubscriber(type, fn, event) {
        if (type === ANY) {
            fn(event);
        } else if (type === event.type) {
            if (type === VALUE || type === ERROR) {
                fn(event.value);
            } else {
                fn();
            }
        }
    }
    function Dispatcher() {
        this._items = [];
        this._spies = [];
        this._inLoop = 0;
        this._removedItems = null;
    }
    extend(Dispatcher.prototype, {
        add: function (type, fn) {
            this._items = concat(this._items, [{
                    type: type,
                    fn: fn
                }]);
            return this._items.length;
        },
        remove: function (type, fn) {
            var index = findByPred(this._items, function (x) {
                return x.type === type && x.fn === fn;
            });
            if (this._inLoop !== 0 && index !== -1) {
                if (this._removedItems === null) {
                    this._removedItems = [];
                }
                this._removedItems.push(this._items[index]);
            }
            this._items = remove(this._items, index);
            return this._items.length;
        },
        addSpy: function (fn) {
            this._spies = concat(this._spies, [fn]);
            return this._spies.length;
        },
        removeSpy: function (fn) {
            this._spies = remove(this._spies, this._spies.indexOf(fn));
            return this._spies.length;
        },
        dispatch: function (event) {
            this._inLoop++;
            for (var i = 0, spies = this._spies; this._spies !== null && i < spies.length; i++) {
                spies[i](event);
            }
            for (var _i = 0, items = this._items; _i < items.length; _i++) {
                if (this._items === null) {
                    break;
                }
                if (this._removedItems !== null && contains(this._removedItems, items[_i])) {
                    continue;
                }
                callSubscriber(items[_i].type, items[_i].fn, event);
            }
            this._inLoop--;
            if (this._inLoop === 0) {
                this._removedItems = null;
            }
        },
        cleanup: function () {
            this._items = null;
            this._spies = null;
        }
    });
    function Observable() {
        this._dispatcher = new Dispatcher();
        this._active = false;
        this._alive = true;
        this._activating = false;
        this._logHandlers = null;
        this._spyHandlers = null;
    }
    extend(Observable.prototype, {
        _name: 'observable',
        _onActivation: function () {
        },
        _onDeactivation: function () {
        },
        _setActive: function (active) {
            if (this._active !== active) {
                this._active = active;
                if (active) {
                    this._activating = true;
                    this._onActivation();
                    this._activating = false;
                } else {
                    this._onDeactivation();
                }
            }
        },
        _clear: function () {
            this._setActive(false);
            this._dispatcher.cleanup();
            this._dispatcher = null;
            this._logHandlers = null;
        },
        _emit: function (type, x) {
            switch (type) {
            case VALUE:
                return this._emitValue(x);
            case ERROR:
                return this._emitError(x);
            case END:
                return this._emitEnd();
            }
        },
        _emitValue: function (value) {
            if (this._alive) {
                this._dispatcher.dispatch({
                    type: VALUE,
                    value: value
                });
            }
        },
        _emitError: function (value) {
            if (this._alive) {
                this._dispatcher.dispatch({
                    type: ERROR,
                    value: value
                });
            }
        },
        _emitEnd: function () {
            if (this._alive) {
                this._alive = false;
                this._dispatcher.dispatch({ type: END });
                this._clear();
            }
        },
        _on: function (type, fn) {
            if (this._alive) {
                this._dispatcher.add(type, fn);
                this._setActive(true);
            } else {
                callSubscriber(type, fn, { type: END });
            }
            return this;
        },
        _off: function (type, fn) {
            if (this._alive) {
                var count = this._dispatcher.remove(type, fn);
                if (count === 0) {
                    this._setActive(false);
                }
            }
            return this;
        },
        onValue: function (fn) {
            return this._on(VALUE, fn);
        },
        onError: function (fn) {
            return this._on(ERROR, fn);
        },
        onEnd: function (fn) {
            return this._on(END, fn);
        },
        onAny: function (fn) {
            return this._on(ANY, fn);
        },
        offValue: function (fn) {
            return this._off(VALUE, fn);
        },
        offError: function (fn) {
            return this._off(ERROR, fn);
        },
        offEnd: function (fn) {
            return this._off(END, fn);
        },
        offAny: function (fn) {
            return this._off(ANY, fn);
        },
        observe: function (observerOrOnValue, onError, onEnd) {
            var _this = this;
            var closed = false;
            var observer = !observerOrOnValue || typeof observerOrOnValue === 'function' ? {
                value: observerOrOnValue,
                error: onError,
                end: onEnd
            } : observerOrOnValue;
            var handler = function (event) {
                if (event.type === END) {
                    closed = true;
                }
                if (event.type === VALUE && observer.value) {
                    observer.value(event.value);
                } else if (event.type === ERROR && observer.error) {
                    observer.error(event.value);
                } else if (event.type === END && observer.end) {
                    observer.end(event.value);
                }
            };
            this.onAny(handler);
            return {
                unsubscribe: function () {
                    if (!closed) {
                        _this.offAny(handler);
                        closed = true;
                    }
                },
                get closed() {
                    return closed;
                }
            };
        },
        _ofSameType: function (A, B) {
            return A.prototype.getType() === this.getType() ? A : B;
        },
        setName: function (sourceObs, selfName) {
            this._name = selfName ? sourceObs._name + '.' + selfName : sourceObs;
            return this;
        },
        log: function () {
            var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.toString();
            var isCurrent = void 0;
            var handler = function (event) {
                var type = '<' + event.type + (isCurrent ? ':current' : '') + '>';
                if (event.type === END) {
                    console.log(name, type);
                } else {
                    console.log(name, type, event.value);
                }
            };
            if (this._alive) {
                if (!this._logHandlers) {
                    this._logHandlers = [];
                }
                this._logHandlers.push({
                    name: name,
                    handler: handler
                });
            }
            isCurrent = true;
            this.onAny(handler);
            isCurrent = false;
            return this;
        },
        offLog: function () {
            var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.toString();
            if (this._logHandlers) {
                var handlerIndex = findByPred(this._logHandlers, function (obj) {
                    return obj.name === name;
                });
                if (handlerIndex !== -1) {
                    this.offAny(this._logHandlers[handlerIndex].handler);
                    this._logHandlers.splice(handlerIndex, 1);
                }
            }
            return this;
        },
        spy: function () {
            var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.toString();
            var handler = function (event) {
                var type = '<' + event.type + '>';
                if (event.type === END) {
                    console.log(name, type);
                } else {
                    console.log(name, type, event.value);
                }
            };
            if (this._alive) {
                if (!this._spyHandlers) {
                    this._spyHandlers = [];
                }
                this._spyHandlers.push({
                    name: name,
                    handler: handler
                });
                this._dispatcher.addSpy(handler);
            }
            return this;
        },
        offSpy: function () {
            var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.toString();
            if (this._spyHandlers) {
                var handlerIndex = findByPred(this._spyHandlers, function (obj) {
                    return obj.name === name;
                });
                if (handlerIndex !== -1) {
                    this._dispatcher.removeSpy(this._spyHandlers[handlerIndex].handler);
                    this._spyHandlers.splice(handlerIndex, 1);
                }
            }
            return this;
        }
    });
    Observable.prototype.toString = function () {
        return '[' + this._name + ']';
    };
    function Stream() {
        Observable.call(this);
    }
    inherit(Stream, Observable, {
        _name: 'stream',
        getType: function () {
            return 'stream';
        }
    });
    function Property() {
        Observable.call(this);
        this._currentEvent = null;
    }
    inherit(Property, Observable, {
        _name: 'property',
        _emitValue: function (value) {
            if (this._alive) {
                this._currentEvent = {
                    type: VALUE,
                    value: value
                };
                if (!this._activating) {
                    this._dispatcher.dispatch({
                        type: VALUE,
                        value: value
                    });
                }
            }
        },
        _emitError: function (value) {
            if (this._alive) {
                this._currentEvent = {
                    type: ERROR,
                    value: value
                };
                if (!this._activating) {
                    this._dispatcher.dispatch({
                        type: ERROR,
                        value: value
                    });
                }
            }
        },
        _emitEnd: function () {
            if (this._alive) {
                this._alive = false;
                if (!this._activating) {
                    this._dispatcher.dispatch({ type: END });
                }
                this._clear();
            }
        },
        _on: function (type, fn) {
            if (this._alive) {
                this._dispatcher.add(type, fn);
                this._setActive(true);
            }
            if (this._currentEvent !== null) {
                callSubscriber(type, fn, this._currentEvent);
            }
            if (!this._alive) {
                callSubscriber(type, fn, { type: END });
            }
            return this;
        },
        getType: function () {
            return 'property';
        }
    });
    var neverS = new Stream();
    neverS._emitEnd();
    neverS._name = 'never';
    function never() {
        return neverS;
    }
    function timeBased(mixin) {
        function AnonymousStream(wait, options) {
            var _this = this;
            Stream.call(this);
            this._wait = wait;
            this._intervalId = null;
            this._$onTick = function () {
                return _this._onTick();
            };
            this._init(options);
        }
        inherit(AnonymousStream, Stream, {
            _init: function () {
            },
            _free: function () {
            },
            _onTick: function () {
            },
            _onActivation: function () {
                this._intervalId = setInterval(this._$onTick, this._wait);
            },
            _onDeactivation: function () {
                if (this._intervalId !== null) {
                    clearInterval(this._intervalId);
                    this._intervalId = null;
                }
            },
            _clear: function () {
                Stream.prototype._clear.call(this);
                this._$onTick = null;
                this._free();
            }
        }, mixin);
        return AnonymousStream;
    }
    var S = timeBased({
        _name: 'later',
        _init: function (_ref) {
            var x = _ref.x;
            this._x = x;
        },
        _free: function () {
            this._x = null;
        },
        _onTick: function () {
            this._emitValue(this._x);
            this._emitEnd();
        }
    });
    function later(wait, x) {
        return new S(wait, { x: x });
    }
    var S$1 = timeBased({
        _name: 'interval',
        _init: function (_ref) {
            var x = _ref.x;
            this._x = x;
        },
        _free: function () {
            this._x = null;
        },
        _onTick: function () {
            this._emitValue(this._x);
        }
    });
    function interval(wait, x) {
        return new S$1(wait, { x: x });
    }
    var S$2 = timeBased({
        _name: 'sequentially',
        _init: function (_ref) {
            var xs = _ref.xs;
            this._xs = cloneArray(xs);
        },
        _free: function () {
            this._xs = null;
        },
        _onTick: function () {
            if (this._xs.length === 1) {
                this._emitValue(this._xs[0]);
                this._emitEnd();
            } else {
                this._emitValue(this._xs.shift());
            }
        }
    });
    function sequentially(wait, xs) {
        return xs.length === 0 ? never() : new S$2(wait, { xs: xs });
    }
    var S$3 = timeBased({
        _name: 'fromPoll',
        _init: function (_ref) {
            var fn = _ref.fn;
            this._fn = fn;
        },
        _free: function () {
            this._fn = null;
        },
        _onTick: function () {
            var fn = this._fn;
            this._emitValue(fn());
        }
    });
    function fromPoll(wait, fn) {
        return new S$3(wait, { fn: fn });
    }
    function emitter(obs) {
        function value(x) {
            obs._emitValue(x);
            return obs._active;
        }
        function error(x) {
            obs._emitError(x);
            return obs._active;
        }
        function end() {
            obs._emitEnd();
            return obs._active;
        }
        function event(e) {
            obs._emit(e.type, e.value);
            return obs._active;
        }
        return {
            value: value,
            error: error,
            end: end,
            event: event,
            emit: value,
            emitEvent: event
        };
    }
    var S$4 = timeBased({
        _name: 'withInterval',
        _init: function (_ref) {
            var fn = _ref.fn;
            this._fn = fn;
            this._emitter = emitter(this);
        },
        _free: function () {
            this._fn = null;
            this._emitter = null;
        },
        _onTick: function () {
            var fn = this._fn;
            fn(this._emitter);
        }
    });
    function withInterval(wait, fn) {
        return new S$4(wait, { fn: fn });
    }
    function S$5(fn) {
        Stream.call(this);
        this._fn = fn;
        this._unsubscribe = null;
    }
    inherit(S$5, Stream, {
        _name: 'stream',
        _onActivation: function () {
            var fn = this._fn;
            var unsubscribe = fn(emitter(this));
            this._unsubscribe = typeof unsubscribe === 'function' ? unsubscribe : null;
            if (!this._active) {
                this._callUnsubscribe();
            }
        },
        _callUnsubscribe: function () {
            if (this._unsubscribe !== null) {
                this._unsubscribe();
                this._unsubscribe = null;
            }
        },
        _onDeactivation: function () {
            this._callUnsubscribe();
        },
        _clear: function () {
            Stream.prototype._clear.call(this);
            this._fn = null;
        }
    });
    function stream(fn) {
        return new S$5(fn);
    }
    function fromCallback(callbackConsumer) {
        var called = false;
        return stream(function (emitter) {
            if (!called) {
                callbackConsumer(function (x) {
                    emitter.emit(x);
                    emitter.end();
                });
                called = true;
            }
        }).setName('fromCallback');
    }
    function fromNodeCallback(callbackConsumer) {
        var called = false;
        return stream(function (emitter) {
            if (!called) {
                callbackConsumer(function (error, x) {
                    if (error) {
                        emitter.error(error);
                    } else {
                        emitter.emit(x);
                    }
                    emitter.end();
                });
                called = true;
            }
        }).setName('fromNodeCallback');
    }
    function spread(fn, length) {
        switch (length) {
        case 0:
            return function () {
                return fn();
            };
        case 1:
            return function (a) {
                return fn(a[0]);
            };
        case 2:
            return function (a) {
                return fn(a[0], a[1]);
            };
        case 3:
            return function (a) {
                return fn(a[0], a[1], a[2]);
            };
        case 4:
            return function (a) {
                return fn(a[0], a[1], a[2], a[3]);
            };
        default:
            return function (a) {
                return fn.apply(null, a);
            };
        }
    }
    function apply(fn, c, a) {
        var aLength = a ? a.length : 0;
        if (c == null) {
            switch (aLength) {
            case 0:
                return fn();
            case 1:
                return fn(a[0]);
            case 2:
                return fn(a[0], a[1]);
            case 3:
                return fn(a[0], a[1], a[2]);
            case 4:
                return fn(a[0], a[1], a[2], a[3]);
            default:
                return fn.apply(null, a);
            }
        } else {
            switch (aLength) {
            case 0:
                return fn.call(c);
            default:
                return fn.apply(c, a);
            }
        }
    }
    function fromSubUnsub(sub, unsub, transformer) {
        return stream(function (emitter) {
            var handler = transformer ? function () {
                emitter.emit(apply(transformer, this, arguments));
            } : function (x) {
                emitter.emit(x);
            };
            sub(handler);
            return function () {
                return unsub(handler);
            };
        }).setName('fromSubUnsub');
    }
    var pairs = [
        [
            'addEventListener',
            'removeEventListener'
        ],
        [
            'addListener',
            'removeListener'
        ],
        [
            'on',
            'off'
        ]
    ];
    function fromEvents(target, eventName, transformer) {
        var sub = void 0, unsub = void 0;
        for (var i = 0; i < pairs.length; i++) {
            if (typeof target[pairs[i][0]] === 'function' && typeof target[pairs[i][1]] === 'function') {
                sub = pairs[i][0];
                unsub = pairs[i][1];
                break;
            }
        }
        if (sub === undefined) {
            throw new Error('target don\'t support any of ' + 'addEventListener/removeEventListener, addListener/removeListener, on/off method pair');
        }
        return fromSubUnsub(function (handler) {
            return target[sub](eventName, handler);
        }, function (handler) {
            return target[unsub](eventName, handler);
        }, transformer).setName('fromEvents');
    }
    function P(value) {
        this._currentEvent = {
            type: 'value',
            value: value,
            current: true
        };
    }
    inherit(P, Property, {
        _name: 'constant',
        _active: false,
        _activating: false,
        _alive: false,
        _dispatcher: null,
        _logHandlers: null
    });
    function constant(x) {
        return new P(x);
    }
    function P$1(value) {
        this._currentEvent = {
            type: 'error',
            value: value,
            current: true
        };
    }
    inherit(P$1, Property, {
        _name: 'constantError',
        _active: false,
        _activating: false,
        _alive: false,
        _dispatcher: null,
        _logHandlers: null
    });
    function constantError(x) {
        return new P$1(x);
    }
    function createConstructor(BaseClass, name) {
        return function AnonymousObservable(source, options) {
            var _this = this;
            BaseClass.call(this);
            this._source = source;
            this._name = source._name + '.' + name;
            this._init(options);
            this._$handleAny = function (event) {
                return _this._handleAny(event);
            };
        };
    }
    function createClassMethods(BaseClass) {
        return {
            _init: function () {
            },
            _free: function () {
            },
            _handleValue: function (x) {
                this._emitValue(x);
            },
            _handleError: function (x) {
                this._emitError(x);
            },
            _handleEnd: function () {
                this._emitEnd();
            },
            _handleAny: function (event) {
                switch (event.type) {
                case VALUE:
                    return this._handleValue(event.value);
                case ERROR:
                    return this._handleError(event.value);
                case END:
                    return this._handleEnd();
                }
            },
            _onActivation: function () {
                this._source.onAny(this._$handleAny);
            },
            _onDeactivation: function () {
                this._source.offAny(this._$handleAny);
            },
            _clear: function () {
                BaseClass.prototype._clear.call(this);
                this._source = null;
                this._$handleAny = null;
                this._free();
            }
        };
    }
    function createStream(name, mixin) {
        var S = createConstructor(Stream, name);
        inherit(S, Stream, createClassMethods(Stream), mixin);
        return S;
    }
    function createProperty(name, mixin) {
        var P = createConstructor(Property, name);
        inherit(P, Property, createClassMethods(Property), mixin);
        return P;
    }
    var P$2 = createProperty('toProperty', {
        _init: function (_ref) {
            var fn = _ref.fn;
            this._getInitialCurrent = fn;
        },
        _onActivation: function () {
            if (this._getInitialCurrent !== null) {
                var getInitial = this._getInitialCurrent;
                this._emitValue(getInitial());
            }
            this._source.onAny(this._$handleAny);
        }
    });
    function toProperty(obs) {
        var fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
        if (fn !== null && typeof fn !== 'function') {
            throw new Error('You should call toProperty() with a function or no arguments.');
        }
        return new P$2(obs, { fn: fn });
    }
    var S$6 = createStream('changes', {
        _handleValue: function (x) {
            if (!this._activating) {
                this._emitValue(x);
            }
        },
        _handleError: function (x) {
            if (!this._activating) {
                this._emitError(x);
            }
        }
    });
    function changes(obs) {
        return new S$6(obs);
    }
    function fromPromise(promise) {
        var called = false;
        var result = stream(function (emitter) {
            if (!called) {
                var onValue = function (x) {
                    emitter.emit(x);
                    emitter.end();
                };
                var onError = function (x) {
                    emitter.error(x);
                    emitter.end();
                };
                var _promise = promise.then(onValue, onError);
                if (_promise && typeof _promise.done === 'function') {
                    _promise.done();
                }
                called = true;
            }
        });
        return toProperty(result, null).setName('fromPromise');
    }
    function getGlodalPromise() {
        if (typeof Promise === 'function') {
            return Promise;
        } else {
            throw new Error('There isn\'t default Promise, use shim or parameter');
        }
    }
    var toPromise = function (obs) {
        var Promise = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : getGlodalPromise();
        var last = null;
        return new Promise(function (resolve, reject) {
            obs.onAny(function (event) {
                if (event.type === END && last !== null) {
                    (last.type === VALUE ? resolve : reject)(last.value);
                    last = null;
                } else {
                    last = event;
                }
            });
        });
    };
    var commonjsGlobal = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};
    function createCommonjsModule(fn, module) {
        return module = { exports: {} }, fn(module, module.exports), module.exports;
    }
    var ponyfill = createCommonjsModule(function (module, exports) {
        'use strict';
        Object.defineProperty(exports, '__esModule', { value: true });
        exports['default'] = symbolObservablePonyfill;
        function symbolObservablePonyfill(root) {
            var result;
            var _Symbol = root.Symbol;
            if (typeof _Symbol === 'function') {
                if (_Symbol.observable) {
                    result = _Symbol.observable;
                } else {
                    result = _Symbol('observable');
                    _Symbol.observable = result;
                }
            } else {
                result = '@@observable';
            }
            return result;
        }
    });
    var index$1 = createCommonjsModule(function (module, exports) {
        'use strict';
        Object.defineProperty(exports, '__esModule', { value: true });
        var _ponyfill2 = _interopRequireDefault(ponyfill);
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { 'default': obj };
        }
        var root;
        if (typeof self !== 'undefined') {
            root = self;
        } else if (typeof window !== 'undefined') {
            root = window;
        } else if (typeof commonjsGlobal !== 'undefined') {
            root = commonjsGlobal;
        } else {
            root = module;
        }
        var result = (0, _ponyfill2['default'])(root);
        exports['default'] = result;
    });
    var index = index$1;
    var $$observable = index.default ? index.default : index;
    function fromESObservable(_observable) {
        var observable = _observable[$$observable] ? _observable[$$observable]() : _observable;
        return stream(function (emitter) {
            var unsub = observable.subscribe({
                error: function (error) {
                    emitter.error(error);
                    emitter.end();
                },
                next: function (value) {
                    emitter.emit(value);
                },
                complete: function () {
                    emitter.end();
                }
            });
            if (unsub.unsubscribe) {
                return function () {
                    unsub.unsubscribe();
                };
            } else {
                return unsub;
            }
        }).setName('fromESObservable');
    }
    function ESObservable(observable) {
        this._observable = observable.takeErrors(1);
    }
    extend(ESObservable.prototype, {
        subscribe: function (observerOrOnNext, onError, onComplete) {
            var _this = this;
            var observer = typeof observerOrOnNext === 'function' ? {
                next: observerOrOnNext,
                error: onError,
                complete: onComplete
            } : observerOrOnNext;
            var fn = function (event) {
                if (event.type === END) {
                    closed = true;
                }
                if (event.type === VALUE && observer.next) {
                    observer.next(event.value);
                } else if (event.type === ERROR && observer.error) {
                    observer.error(event.value);
                } else if (event.type === END && observer.complete) {
                    observer.complete(event.value);
                }
            };
            this._observable.onAny(fn);
            var closed = false;
            var subscription = {
                unsubscribe: function () {
                    closed = true;
                    _this._observable.offAny(fn);
                },
                get closed() {
                    return closed;
                }
            };
            return subscription;
        }
    });
    ESObservable.prototype[$$observable] = function () {
        return this;
    };
    function toESObservable() {
        return new ESObservable(this);
    }
    function collect(source, keys, values) {
        for (var prop in source) {
            if (source.hasOwnProperty(prop)) {
                keys.push(prop);
                values.push(source[prop]);
            }
        }
    }
    function defaultErrorsCombinator(errors) {
        var latestError = void 0;
        for (var i = 0; i < errors.length; i++) {
            if (errors[i] !== undefined) {
                if (latestError === undefined || latestError.index < errors[i].index) {
                    latestError = errors[i];
                }
            }
        }
        return latestError.error;
    }
    function Combine(active, passive, combinator) {
        var _this = this;
        Stream.call(this);
        this._activeCount = active.length;
        this._sources = concat(active, passive);
        this._combinator = combinator;
        this._aliveCount = 0;
        this._latestValues = new Array(this._sources.length);
        this._latestErrors = new Array(this._sources.length);
        fillArray(this._latestValues, NOTHING);
        this._emitAfterActivation = false;
        this._endAfterActivation = false;
        this._latestErrorIndex = 0;
        this._$handlers = [];
        var _loop = function (i) {
            _this._$handlers.push(function (event) {
                return _this._handleAny(i, event);
            });
        };
        for (var i = 0; i < this._sources.length; i++) {
            _loop(i);
        }
    }
    inherit(Combine, Stream, {
        _name: 'combine',
        _onActivation: function () {
            this._aliveCount = this._activeCount;
            for (var i = this._activeCount; i < this._sources.length; i++) {
                this._sources[i].onAny(this._$handlers[i]);
            }
            for (var _i = 0; _i < this._activeCount; _i++) {
                this._sources[_i].onAny(this._$handlers[_i]);
            }
            if (this._emitAfterActivation) {
                this._emitAfterActivation = false;
                this._emitIfFull();
            }
            if (this._endAfterActivation) {
                this._emitEnd();
            }
        },
        _onDeactivation: function () {
            var length = this._sources.length, i = void 0;
            for (i = 0; i < length; i++) {
                this._sources[i].offAny(this._$handlers[i]);
            }
        },
        _emitIfFull: function () {
            var hasAllValues = true;
            var hasErrors = false;
            var length = this._latestValues.length;
            var valuesCopy = new Array(length);
            var errorsCopy = new Array(length);
            for (var i = 0; i < length; i++) {
                valuesCopy[i] = this._latestValues[i];
                errorsCopy[i] = this._latestErrors[i];
                if (valuesCopy[i] === NOTHING) {
                    hasAllValues = false;
                }
                if (errorsCopy[i] !== undefined) {
                    hasErrors = true;
                }
            }
            if (hasAllValues) {
                var combinator = this._combinator;
                this._emitValue(combinator(valuesCopy));
            }
            if (hasErrors) {
                this._emitError(defaultErrorsCombinator(errorsCopy));
            }
        },
        _handleAny: function (i, event) {
            if (event.type === VALUE || event.type === ERROR) {
                if (event.type === VALUE) {
                    this._latestValues[i] = event.value;
                    this._latestErrors[i] = undefined;
                }
                if (event.type === ERROR) {
                    this._latestValues[i] = NOTHING;
                    this._latestErrors[i] = {
                        index: this._latestErrorIndex++,
                        error: event.value
                    };
                }
                if (i < this._activeCount) {
                    if (this._activating) {
                        this._emitAfterActivation = true;
                    } else {
                        this._emitIfFull();
                    }
                }
            } else {
                if (i < this._activeCount) {
                    this._aliveCount--;
                    if (this._aliveCount === 0) {
                        if (this._activating) {
                            this._endAfterActivation = true;
                        } else {
                            this._emitEnd();
                        }
                    }
                }
            }
        },
        _clear: function () {
            Stream.prototype._clear.call(this);
            this._sources = null;
            this._latestValues = null;
            this._latestErrors = null;
            this._combinator = null;
            this._$handlers = null;
        }
    });
    function combineAsArray(active) {
        var passive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
        var combinator = arguments[2];
        if (!Array.isArray(passive)) {
            throw new Error('Combine can only combine active and passive collections of the same type.');
        }
        combinator = combinator ? spread(combinator, active.length + passive.length) : function (x) {
            return x;
        };
        return active.length === 0 ? never() : new Combine(active, passive, combinator);
    }
    function combineAsObject(active) {
        var passive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        var combinator = arguments[2];
        if (typeof passive !== 'object' || Array.isArray(passive)) {
            throw new Error('Combine can only combine active and passive collections of the same type.');
        }
        var keys = [], activeObservables = [], passiveObservables = [];
        collect(active, keys, activeObservables);
        collect(passive, keys, passiveObservables);
        var objectify = function (values) {
            var event = {};
            for (var i = values.length - 1; 0 <= i; i--) {
                event[keys[i]] = values[i];
            }
            return combinator ? combinator(event) : event;
        };
        return activeObservables.length === 0 ? never() : new Combine(activeObservables, passiveObservables, objectify);
    }
    function combine(active, passive, combinator) {
        if (typeof passive === 'function') {
            combinator = passive;
            passive = undefined;
        }
        return Array.isArray(active) ? combineAsArray(active, passive, combinator) : combineAsObject(active, passive, combinator);
    }
    var Observable$2 = {
        empty: function () {
            return never();
        },
        concat: function (a, b) {
            return a.merge(b);
        },
        of: function (x) {
            return constant(x);
        },
        map: function (fn, obs) {
            return obs.map(fn);
        },
        bimap: function (fnErr, fnVal, obs) {
            return obs.mapErrors(fnErr).map(fnVal);
        },
        ap: function (obsFn, obsVal) {
            return combine([
                obsFn,
                obsVal
            ], function (fn, val) {
                return fn(val);
            });
        },
        chain: function (fn, obs) {
            return obs.flatMap(fn);
        }
    };
    var staticLand = Object.freeze({ Observable: Observable$2 });
    var mixin = {
        _init: function (_ref) {
            var fn = _ref.fn;
            this._fn = fn;
        },
        _free: function () {
            this._fn = null;
        },
        _handleValue: function (x) {
            var fn = this._fn;
            this._emitValue(fn(x));
        }
    };
    var S$7 = createStream('map', mixin);
    var P$3 = createProperty('map', mixin);
    var id = function (x) {
        return x;
    };
    function map$1(obs) {
        var fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : id;
        return new (obs._ofSameType(S$7, P$3))(obs, { fn: fn });
    }
    var mixin$1 = {
        _init: function (_ref) {
            var fn = _ref.fn;
            this._fn = fn;
        },
        _free: function () {
            this._fn = null;
        },
        _handleValue: function (x) {
            var fn = this._fn;
            if (fn(x)) {
                this._emitValue(x);
            }
        }
    };
    var S$8 = createStream('filter', mixin$1);
    var P$4 = createProperty('filter', mixin$1);
    var id$1 = function (x) {
        return x;
    };
    function filter(obs) {
        var fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : id$1;
        return new (obs._ofSameType(S$8, P$4))(obs, { fn: fn });
    }
    var mixin$2 = {
        _init: function (_ref) {
            var n = _ref.n;
            this._n = n;
            if (n <= 0) {
                this._emitEnd();
            }
        },
        _handleValue: function (x) {
            if (this._n === 0) {
                return;
            }
            this._n--;
            this._emitValue(x);
            if (this._n === 0) {
                this._emitEnd();
            }
        }
    };
    var S$9 = createStream('take', mixin$2);
    var P$5 = createProperty('take', mixin$2);
    function take(obs, n) {
        return new (obs._ofSameType(S$9, P$5))(obs, { n: n });
    }
    var mixin$3 = {
        _init: function (_ref) {
            var n = _ref.n;
            this._n = n;
            if (n <= 0) {
                this._emitEnd();
            }
        },
        _handleError: function (x) {
            if (this._n === 0) {
                return;
            }
            this._n--;
            this._emitError(x);
            if (this._n === 0) {
                this._emitEnd();
            }
        }
    };
    var S$10 = createStream('takeErrors', mixin$3);
    var P$6 = createProperty('takeErrors', mixin$3);
    function takeErrors(obs, n) {
        return new (obs._ofSameType(S$10, P$6))(obs, { n: n });
    }
    var mixin$4 = {
        _init: function (_ref) {
            var fn = _ref.fn;
            this._fn = fn;
        },
        _free: function () {
            this._fn = null;
        },
        _handleValue: function (x) {
            var fn = this._fn;
            if (fn(x)) {
                this._emitValue(x);
            } else {
                this._emitEnd();
            }
        }
    };
    var S$11 = createStream('takeWhile', mixin$4);
    var P$7 = createProperty('takeWhile', mixin$4);
    var id$2 = function (x) {
        return x;
    };
    function takeWhile(obs) {
        var fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : id$2;
        return new (obs._ofSameType(S$11, P$7))(obs, { fn: fn });
    }
    var mixin$5 = {
        _init: function () {
            this._lastValue = NOTHING;
        },
        _free: function () {
            this._lastValue = null;
        },
        _handleValue: function (x) {
            this._lastValue = x;
        },
        _handleEnd: function () {
            if (this._lastValue !== NOTHING) {
                this._emitValue(this._lastValue);
            }
            this._emitEnd();
        }
    };
    var S$12 = createStream('last', mixin$5);
    var P$8 = createProperty('last', mixin$5);
    function last(obs) {
        return new (obs._ofSameType(S$12, P$8))(obs);
    }
    var mixin$6 = {
        _init: function (_ref) {
            var n = _ref.n;
            this._n = Math.max(0, n);
        },
        _handleValue: function (x) {
            if (this._n === 0) {
                this._emitValue(x);
            } else {
                this._n--;
            }
        }
    };
    var S$13 = createStream('skip', mixin$6);
    var P$9 = createProperty('skip', mixin$6);
    function skip(obs, n) {
        return new (obs._ofSameType(S$13, P$9))(obs, { n: n });
    }
    var mixin$7 = {
        _init: function (_ref) {
            var fn = _ref.fn;
            this._fn = fn;
        },
        _free: function () {
            this._fn = null;
        },
        _handleValue: function (x) {
            var fn = this._fn;
            if (this._fn !== null && !fn(x)) {
                this._fn = null;
            }
            if (this._fn === null) {
                this._emitValue(x);
            }
        }
    };
    var S$14 = createStream('skipWhile', mixin$7);
    var P$10 = createProperty('skipWhile', mixin$7);
    var id$3 = function (x) {
        return x;
    };
    function skipWhile(obs) {
        var fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : id$3;
        return new (obs._ofSameType(S$14, P$10))(obs, { fn: fn });
    }
    var mixin$8 = {
        _init: function (_ref) {
            var fn = _ref.fn;
            this._fn = fn;
            this._prev = NOTHING;
        },
        _free: function () {
            this._fn = null;
            this._prev = null;
        },
        _handleValue: function (x) {
            var fn = this._fn;
            if (this._prev === NOTHING || !fn(this._prev, x)) {
                this._prev = x;
                this._emitValue(x);
            }
        }
    };
    var S$15 = createStream('skipDuplicates', mixin$8);
    var P$11 = createProperty('skipDuplicates', mixin$8);
    var eq = function (a, b) {
        return a === b;
    };
    function skipDuplicates(obs) {
        var fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : eq;
        return new (obs._ofSameType(S$15, P$11))(obs, { fn: fn });
    }
    var mixin$9 = {
        _init: function (_ref) {
            var fn = _ref.fn, seed = _ref.seed;
            this._fn = fn;
            this._prev = seed;
        },
        _free: function () {
            this._prev = null;
            this._fn = null;
        },
        _handleValue: function (x) {
            if (this._prev !== NOTHING) {
                var fn = this._fn;
                this._emitValue(fn(this._prev, x));
            }
            this._prev = x;
        }
    };
    var S$16 = createStream('diff', mixin$9);
    var P$12 = createProperty('diff', mixin$9);
    function defaultFn(a, b) {
        return [
            a,
            b
        ];
    }
    function diff(obs, fn) {
        var seed = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : NOTHING;
        return new (obs._ofSameType(S$16, P$12))(obs, {
            fn: fn || defaultFn,
            seed: seed
        });
    }
    var P$13 = createProperty('scan', {
        _init: function (_ref) {
            var fn = _ref.fn, seed = _ref.seed;
            this._fn = fn;
            this._seed = seed;
            if (seed !== NOTHING) {
                this._emitValue(seed);
            }
        },
        _free: function () {
            this._fn = null;
            this._seed = null;
        },
        _handleValue: function (x) {
            var fn = this._fn;
            if (this._currentEvent === null || this._currentEvent.type === ERROR) {
                this._emitValue(this._seed === NOTHING ? x : fn(this._seed, x));
            } else {
                this._emitValue(fn(this._currentEvent.value, x));
            }
        }
    });
    function scan(obs, fn) {
        var seed = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : NOTHING;
        return new P$13(obs, {
            fn: fn,
            seed: seed
        });
    }
    var mixin$10 = {
        _init: function (_ref) {
            var fn = _ref.fn;
            this._fn = fn;
        },
        _free: function () {
            this._fn = null;
        },
        _handleValue: function (x) {
            var fn = this._fn;
            var xs = fn(x);
            for (var i = 0; i < xs.length; i++) {
                this._emitValue(xs[i]);
            }
        }
    };
    var S$17 = createStream('flatten', mixin$10);
    var id$4 = function (x) {
        return x;
    };
    function flatten(obs) {
        var fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : id$4;
        return new S$17(obs, { fn: fn });
    }
    var END_MARKER = {};
    var mixin$11 = {
        _init: function (_ref) {
            var _this = this;
            var wait = _ref.wait;
            this._wait = Math.max(0, wait);
            this._buff = [];
            this._$shiftBuff = function () {
                var value = _this._buff.shift();
                if (value === END_MARKER) {
                    _this._emitEnd();
                } else {
                    _this._emitValue(value);
                }
            };
        },
        _free: function () {
            this._buff = null;
            this._$shiftBuff = null;
        },
        _handleValue: function (x) {
            if (this._activating) {
                this._emitValue(x);
            } else {
                this._buff.push(x);
                setTimeout(this._$shiftBuff, this._wait);
            }
        },
        _handleEnd: function () {
            if (this._activating) {
                this._emitEnd();
            } else {
                this._buff.push(END_MARKER);
                setTimeout(this._$shiftBuff, this._wait);
            }
        }
    };
    var S$18 = createStream('delay', mixin$11);
    var P$14 = createProperty('delay', mixin$11);
    function delay(obs, wait) {
        return new (obs._ofSameType(S$18, P$14))(obs, { wait: wait });
    }
    var now = Date.now ? function () {
        return Date.now();
    } : function () {
        return new Date().getTime();
    };
    var mixin$12 = {
        _init: function (_ref) {
            var _this = this;
            var wait = _ref.wait, leading = _ref.leading, trailing = _ref.trailing;
            this._wait = Math.max(0, wait);
            this._leading = leading;
            this._trailing = trailing;
            this._trailingValue = null;
            this._timeoutId = null;
            this._endLater = false;
            this._lastCallTime = 0;
            this._$trailingCall = function () {
                return _this._trailingCall();
            };
        },
        _free: function () {
            this._trailingValue = null;
            this._$trailingCall = null;
        },
        _handleValue: function (x) {
            if (this._activating) {
                this._emitValue(x);
            } else {
                var curTime = now();
                if (this._lastCallTime === 0 && !this._leading) {
                    this._lastCallTime = curTime;
                }
                var remaining = this._wait - (curTime - this._lastCallTime);
                if (remaining <= 0) {
                    this._cancelTrailing();
                    this._lastCallTime = curTime;
                    this._emitValue(x);
                } else if (this._trailing) {
                    this._cancelTrailing();
                    this._trailingValue = x;
                    this._timeoutId = setTimeout(this._$trailingCall, remaining);
                }
            }
        },
        _handleEnd: function () {
            if (this._activating) {
                this._emitEnd();
            } else {
                if (this._timeoutId) {
                    this._endLater = true;
                } else {
                    this._emitEnd();
                }
            }
        },
        _cancelTrailing: function () {
            if (this._timeoutId !== null) {
                clearTimeout(this._timeoutId);
                this._timeoutId = null;
            }
        },
        _trailingCall: function () {
            this._emitValue(this._trailingValue);
            this._timeoutId = null;
            this._trailingValue = null;
            this._lastCallTime = !this._leading ? 0 : now();
            if (this._endLater) {
                this._emitEnd();
            }
        }
    };
    var S$19 = createStream('throttle', mixin$12);
    var P$15 = createProperty('throttle', mixin$12);
    function throttle(obs, wait) {
        var _ref2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {}, _ref2$leading = _ref2.leading, leading = _ref2$leading === undefined ? true : _ref2$leading, _ref2$trailing = _ref2.trailing, trailing = _ref2$trailing === undefined ? true : _ref2$trailing;
        return new (obs._ofSameType(S$19, P$15))(obs, {
            wait: wait,
            leading: leading,
            trailing: trailing
        });
    }
    var mixin$13 = {
        _init: function (_ref) {
            var _this = this;
            var wait = _ref.wait, immediate = _ref.immediate;
            this._wait = Math.max(0, wait);
            this._immediate = immediate;
            this._lastAttempt = 0;
            this._timeoutId = null;
            this._laterValue = null;
            this._endLater = false;
            this._$later = function () {
                return _this._later();
            };
        },
        _free: function () {
            this._laterValue = null;
            this._$later = null;
        },
        _handleValue: function (x) {
            if (this._activating) {
                this._emitValue(x);
            } else {
                this._lastAttempt = now();
                if (this._immediate && !this._timeoutId) {
                    this._emitValue(x);
                }
                if (!this._timeoutId) {
                    this._timeoutId = setTimeout(this._$later, this._wait);
                }
                if (!this._immediate) {
                    this._laterValue = x;
                }
            }
        },
        _handleEnd: function () {
            if (this._activating) {
                this._emitEnd();
            } else {
                if (this._timeoutId && !this._immediate) {
                    this._endLater = true;
                } else {
                    this._emitEnd();
                }
            }
        },
        _later: function () {
            var last = now() - this._lastAttempt;
            if (last < this._wait && last >= 0) {
                this._timeoutId = setTimeout(this._$later, this._wait - last);
            } else {
                this._timeoutId = null;
                if (!this._immediate) {
                    this._emitValue(this._laterValue);
                    this._laterValue = null;
                }
                if (this._endLater) {
                    this._emitEnd();
                }
            }
        }
    };
    var S$20 = createStream('debounce', mixin$13);
    var P$16 = createProperty('debounce', mixin$13);
    function debounce(obs, wait) {
        var _ref2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {}, _ref2$immediate = _ref2.immediate, immediate = _ref2$immediate === undefined ? false : _ref2$immediate;
        return new (obs._ofSameType(S$20, P$16))(obs, {
            wait: wait,
            immediate: immediate
        });
    }
    var mixin$14 = {
        _init: function (_ref) {
            var fn = _ref.fn;
            this._fn = fn;
        },
        _free: function () {
            this._fn = null;
        },
        _handleError: function (x) {
            var fn = this._fn;
            this._emitError(fn(x));
        }
    };
    var S$21 = createStream('mapErrors', mixin$14);
    var P$17 = createProperty('mapErrors', mixin$14);
    var id$5 = function (x) {
        return x;
    };
    function mapErrors(obs) {
        var fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : id$5;
        return new (obs._ofSameType(S$21, P$17))(obs, { fn: fn });
    }
    var mixin$15 = {
        _init: function (_ref) {
            var fn = _ref.fn;
            this._fn = fn;
        },
        _free: function () {
            this._fn = null;
        },
        _handleError: function (x) {
            var fn = this._fn;
            if (fn(x)) {
                this._emitError(x);
            }
        }
    };
    var S$22 = createStream('filterErrors', mixin$15);
    var P$18 = createProperty('filterErrors', mixin$15);
    var id$6 = function (x) {
        return x;
    };
    function filterErrors(obs) {
        var fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : id$6;
        return new (obs._ofSameType(S$22, P$18))(obs, { fn: fn });
    }
    var mixin$16 = {
        _handleValue: function () {
        }
    };
    var S$23 = createStream('ignoreValues', mixin$16);
    var P$19 = createProperty('ignoreValues', mixin$16);
    function ignoreValues(obs) {
        return new (obs._ofSameType(S$23, P$19))(obs);
    }
    var mixin$17 = {
        _handleError: function () {
        }
    };
    var S$24 = createStream('ignoreErrors', mixin$17);
    var P$20 = createProperty('ignoreErrors', mixin$17);
    function ignoreErrors(obs) {
        return new (obs._ofSameType(S$24, P$20))(obs);
    }
    var mixin$18 = {
        _handleEnd: function () {
        }
    };
    var S$25 = createStream('ignoreEnd', mixin$18);
    var P$21 = createProperty('ignoreEnd', mixin$18);
    function ignoreEnd(obs) {
        return new (obs._ofSameType(S$25, P$21))(obs);
    }
    var mixin$19 = {
        _init: function (_ref) {
            var fn = _ref.fn;
            this._fn = fn;
        },
        _free: function () {
            this._fn = null;
        },
        _handleEnd: function () {
            var fn = this._fn;
            this._emitValue(fn());
            this._emitEnd();
        }
    };
    var S$26 = createStream('beforeEnd', mixin$19);
    var P$22 = createProperty('beforeEnd', mixin$19);
    function beforeEnd(obs, fn) {
        return new (obs._ofSameType(S$26, P$22))(obs, { fn: fn });
    }
    var mixin$20 = {
        _init: function (_ref) {
            var min = _ref.min, max = _ref.max;
            this._max = max;
            this._min = min;
            this._buff = [];
        },
        _free: function () {
            this._buff = null;
        },
        _handleValue: function (x) {
            this._buff = slide(this._buff, x, this._max);
            if (this._buff.length >= this._min) {
                this._emitValue(this._buff);
            }
        }
    };
    var S$27 = createStream('slidingWindow', mixin$20);
    var P$23 = createProperty('slidingWindow', mixin$20);
    function slidingWindow(obs, max) {
        var min = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
        return new (obs._ofSameType(S$27, P$23))(obs, {
            min: min,
            max: max
        });
    }
    var mixin$21 = {
        _init: function (_ref) {
            var fn = _ref.fn, flushOnEnd = _ref.flushOnEnd;
            this._fn = fn;
            this._flushOnEnd = flushOnEnd;
            this._buff = [];
        },
        _free: function () {
            this._buff = null;
        },
        _flush: function () {
            if (this._buff !== null && this._buff.length !== 0) {
                this._emitValue(this._buff);
                this._buff = [];
            }
        },
        _handleValue: function (x) {
            this._buff.push(x);
            var fn = this._fn;
            if (!fn(x)) {
                this._flush();
            }
        },
        _handleEnd: function () {
            if (this._flushOnEnd) {
                this._flush();
            }
            this._emitEnd();
        }
    };
    var S$28 = createStream('bufferWhile', mixin$21);
    var P$24 = createProperty('bufferWhile', mixin$21);
    var id$7 = function (x) {
        return x;
    };
    function bufferWhile(obs, fn) {
        var _ref2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {}, _ref2$flushOnEnd = _ref2.flushOnEnd, flushOnEnd = _ref2$flushOnEnd === undefined ? true : _ref2$flushOnEnd;
        return new (obs._ofSameType(S$28, P$24))(obs, {
            fn: fn || id$7,
            flushOnEnd: flushOnEnd
        });
    }
    var mixin$22 = {
        _init: function (_ref) {
            var count = _ref.count, flushOnEnd = _ref.flushOnEnd;
            this._count = count;
            this._flushOnEnd = flushOnEnd;
            this._buff = [];
        },
        _free: function () {
            this._buff = null;
        },
        _flush: function () {
            if (this._buff !== null && this._buff.length !== 0) {
                this._emitValue(this._buff);
                this._buff = [];
            }
        },
        _handleValue: function (x) {
            this._buff.push(x);
            if (this._buff.length >= this._count) {
                this._flush();
            }
        },
        _handleEnd: function () {
            if (this._flushOnEnd) {
                this._flush();
            }
            this._emitEnd();
        }
    };
    var S$29 = createStream('bufferWithCount', mixin$22);
    var P$25 = createProperty('bufferWithCount', mixin$22);
    function bufferWhile$1(obs, count) {
        var _ref2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {}, _ref2$flushOnEnd = _ref2.flushOnEnd, flushOnEnd = _ref2$flushOnEnd === undefined ? true : _ref2$flushOnEnd;
        return new (obs._ofSameType(S$29, P$25))(obs, {
            count: count,
            flushOnEnd: flushOnEnd
        });
    }
    var mixin$23 = {
        _init: function (_ref) {
            var _this = this;
            var wait = _ref.wait, count = _ref.count, flushOnEnd = _ref.flushOnEnd;
            this._wait = wait;
            this._count = count;
            this._flushOnEnd = flushOnEnd;
            this._intervalId = null;
            this._$onTick = function () {
                return _this._flush();
            };
            this._buff = [];
        },
        _free: function () {
            this._$onTick = null;
            this._buff = null;
        },
        _flush: function () {
            if (this._buff !== null) {
                this._emitValue(this._buff);
                this._buff = [];
            }
        },
        _handleValue: function (x) {
            this._buff.push(x);
            if (this._buff.length >= this._count) {
                clearInterval(this._intervalId);
                this._flush();
                this._intervalId = setInterval(this._$onTick, this._wait);
            }
        },
        _handleEnd: function () {
            if (this._flushOnEnd && this._buff.length !== 0) {
                this._flush();
            }
            this._emitEnd();
        },
        _onActivation: function () {
            this._intervalId = setInterval(this._$onTick, this._wait);
            this._source.onAny(this._$handleAny);
        },
        _onDeactivation: function () {
            if (this._intervalId !== null) {
                clearInterval(this._intervalId);
                this._intervalId = null;
            }
            this._source.offAny(this._$handleAny);
        }
    };
    var S$30 = createStream('bufferWithTimeOrCount', mixin$23);
    var P$26 = createProperty('bufferWithTimeOrCount', mixin$23);
    function bufferWithTimeOrCount(obs, wait, count) {
        var _ref2 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {}, _ref2$flushOnEnd = _ref2.flushOnEnd, flushOnEnd = _ref2$flushOnEnd === undefined ? true : _ref2$flushOnEnd;
        return new (obs._ofSameType(S$30, P$26))(obs, {
            wait: wait,
            count: count,
            flushOnEnd: flushOnEnd
        });
    }
    function xformForObs(obs) {
        return {
            '@@transducer/step': function (res, input) {
                obs._emitValue(input);
                return null;
            },
            '@@transducer/result': function () {
                obs._emitEnd();
                return null;
            }
        };
    }
    var mixin$24 = {
        _init: function (_ref) {
            var transducer = _ref.transducer;
            this._xform = transducer(xformForObs(this));
        },
        _free: function () {
            this._xform = null;
        },
        _handleValue: function (x) {
            if (this._xform['@@transducer/step'](null, x) !== null) {
                this._xform['@@transducer/result'](null);
            }
        },
        _handleEnd: function () {
            this._xform['@@transducer/result'](null);
        }
    };
    var S$31 = createStream('transduce', mixin$24);
    var P$27 = createProperty('transduce', mixin$24);
    function transduce(obs, transducer) {
        return new (obs._ofSameType(S$31, P$27))(obs, { transducer: transducer });
    }
    var mixin$25 = {
        _init: function (_ref) {
            var fn = _ref.fn;
            this._handler = fn;
            this._emitter = emitter(this);
        },
        _free: function () {
            this._handler = null;
            this._emitter = null;
        },
        _handleAny: function (event) {
            this._handler(this._emitter, event);
        }
    };
    var S$32 = createStream('withHandler', mixin$25);
    var P$28 = createProperty('withHandler', mixin$25);
    function withHandler(obs, fn) {
        return new (obs._ofSameType(S$32, P$28))(obs, { fn: fn });
    }
    var isArray = Array.isArray || function (xs) {
        return Object.prototype.toString.call(xs) === '[object Array]';
    };
    function Zip(sources, combinator) {
        var _this = this;
        Stream.call(this);
        this._buffers = map(sources, function (source) {
            return isArray(source) ? cloneArray(source) : [];
        });
        this._sources = map(sources, function (source) {
            return isArray(source) ? never() : source;
        });
        this._combinator = combinator ? spread(combinator, this._sources.length) : function (x) {
            return x;
        };
        this._aliveCount = 0;
        this._$handlers = [];
        var _loop = function (i) {
            _this._$handlers.push(function (event) {
                return _this._handleAny(i, event);
            });
        };
        for (var i = 0; i < this._sources.length; i++) {
            _loop(i);
        }
    }
    inherit(Zip, Stream, {
        _name: 'zip',
        _onActivation: function () {
            while (this._isFull()) {
                this._emit();
            }
            var length = this._sources.length;
            this._aliveCount = length;
            for (var i = 0; i < length && this._active; i++) {
                this._sources[i].onAny(this._$handlers[i]);
            }
        },
        _onDeactivation: function () {
            for (var i = 0; i < this._sources.length; i++) {
                this._sources[i].offAny(this._$handlers[i]);
            }
        },
        _emit: function () {
            var values = new Array(this._buffers.length);
            for (var i = 0; i < this._buffers.length; i++) {
                values[i] = this._buffers[i].shift();
            }
            var combinator = this._combinator;
            this._emitValue(combinator(values));
        },
        _isFull: function () {
            for (var i = 0; i < this._buffers.length; i++) {
                if (this._buffers[i].length === 0) {
                    return false;
                }
            }
            return true;
        },
        _handleAny: function (i, event) {
            if (event.type === VALUE) {
                this._buffers[i].push(event.value);
                if (this._isFull()) {
                    this._emit();
                }
            }
            if (event.type === ERROR) {
                this._emitError(event.value);
            }
            if (event.type === END) {
                this._aliveCount--;
                if (this._aliveCount === 0) {
                    this._emitEnd();
                }
            }
        },
        _clear: function () {
            Stream.prototype._clear.call(this);
            this._sources = null;
            this._buffers = null;
            this._combinator = null;
            this._$handlers = null;
        }
    });
    function zip(observables, combinator) {
        return observables.length === 0 ? never() : new Zip(observables, combinator);
    }
    var id$8 = function (x) {
        return x;
    };
    function AbstractPool() {
        var _this = this;
        var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {}, _ref$queueLim = _ref.queueLim, queueLim = _ref$queueLim === undefined ? 0 : _ref$queueLim, _ref$concurLim = _ref.concurLim, concurLim = _ref$concurLim === undefined ? -1 : _ref$concurLim, _ref$drop = _ref.drop, drop = _ref$drop === undefined ? 'new' : _ref$drop;
        Stream.call(this);
        this._queueLim = queueLim < 0 ? -1 : queueLim;
        this._concurLim = concurLim < 0 ? -1 : concurLim;
        this._drop = drop;
        this._queue = [];
        this._curSources = [];
        this._$handleSubAny = function (event) {
            return _this._handleSubAny(event);
        };
        this._$endHandlers = [];
        this._currentlyAdding = null;
        if (this._concurLim === 0) {
            this._emitEnd();
        }
    }
    inherit(AbstractPool, Stream, {
        _name: 'abstractPool',
        _add: function (obj, toObs) {
            toObs = toObs || id$8;
            if (this._concurLim === -1 || this._curSources.length < this._concurLim) {
                this._addToCur(toObs(obj));
            } else {
                if (this._queueLim === -1 || this._queue.length < this._queueLim) {
                    this._addToQueue(toObs(obj));
                } else if (this._drop === 'old') {
                    this._removeOldest();
                    this._add(obj, toObs);
                }
            }
        },
        _addAll: function (obss) {
            var _this2 = this;
            forEach(obss, function (obs) {
                return _this2._add(obs);
            });
        },
        _remove: function (obs) {
            if (this._removeCur(obs) === -1) {
                this._removeQueue(obs);
            }
        },
        _addToQueue: function (obs) {
            this._queue = concat(this._queue, [obs]);
        },
        _addToCur: function (obs) {
            if (this._active) {
                if (!obs._alive) {
                    if (obs._currentEvent) {
                        this._emit(obs._currentEvent.type, obs._currentEvent.value);
                    }
                    return;
                }
                this._currentlyAdding = obs;
                obs.onAny(this._$handleSubAny);
                this._currentlyAdding = null;
                if (obs._alive) {
                    this._curSources = concat(this._curSources, [obs]);
                    if (this._active) {
                        this._subToEnd(obs);
                    }
                }
            } else {
                this._curSources = concat(this._curSources, [obs]);
            }
        },
        _subToEnd: function (obs) {
            var _this3 = this;
            var onEnd = function () {
                return _this3._removeCur(obs);
            };
            this._$endHandlers.push({
                obs: obs,
                handler: onEnd
            });
            obs.onEnd(onEnd);
        },
        _subscribe: function (obs) {
            obs.onAny(this._$handleSubAny);
            if (this._active) {
                this._subToEnd(obs);
            }
        },
        _unsubscribe: function (obs) {
            obs.offAny(this._$handleSubAny);
            var onEndI = findByPred(this._$endHandlers, function (obj) {
                return obj.obs === obs;
            });
            if (onEndI !== -1) {
                obs.offEnd(this._$endHandlers[onEndI].handler);
                this._$endHandlers.splice(onEndI, 1);
            }
        },
        _handleSubAny: function (event) {
            if (event.type === VALUE) {
                this._emitValue(event.value);
            } else if (event.type === ERROR) {
                this._emitError(event.value);
            }
        },
        _removeQueue: function (obs) {
            var index = find(this._queue, obs);
            this._queue = remove(this._queue, index);
            return index;
        },
        _removeCur: function (obs) {
            if (this._active) {
                this._unsubscribe(obs);
            }
            var index = find(this._curSources, obs);
            this._curSources = remove(this._curSources, index);
            if (index !== -1) {
                if (this._queue.length !== 0) {
                    this._pullQueue();
                } else if (this._curSources.length === 0) {
                    this._onEmpty();
                }
            }
            return index;
        },
        _removeOldest: function () {
            this._removeCur(this._curSources[0]);
        },
        _pullQueue: function () {
            if (this._queue.length !== 0) {
                this._queue = cloneArray(this._queue);
                this._addToCur(this._queue.shift());
            }
        },
        _onActivation: function () {
            for (var i = 0, sources = this._curSources; i < sources.length && this._active; i++) {
                this._subscribe(sources[i]);
            }
        },
        _onDeactivation: function () {
            for (var i = 0, sources = this._curSources; i < sources.length; i++) {
                this._unsubscribe(sources[i]);
            }
            if (this._currentlyAdding !== null) {
                this._unsubscribe(this._currentlyAdding);
            }
        },
        _isEmpty: function () {
            return this._curSources.length === 0;
        },
        _onEmpty: function () {
        },
        _clear: function () {
            Stream.prototype._clear.call(this);
            this._queue = null;
            this._curSources = null;
            this._$handleSubAny = null;
            this._$endHandlers = null;
        }
    });
    function Merge(sources) {
        AbstractPool.call(this);
        this._addAll(sources);
        this._initialised = true;
    }
    inherit(Merge, AbstractPool, {
        _name: 'merge',
        _onEmpty: function () {
            if (this._initialised) {
                this._emitEnd();
            }
        }
    });
    function merge(observables) {
        return observables.length === 0 ? never() : new Merge(observables);
    }
    function S$33(generator) {
        var _this = this;
        Stream.call(this);
        this._generator = generator;
        this._source = null;
        this._inLoop = false;
        this._iteration = 0;
        this._$handleAny = function (event) {
            return _this._handleAny(event);
        };
    }
    inherit(S$33, Stream, {
        _name: 'repeat',
        _handleAny: function (event) {
            if (event.type === END) {
                this._source = null;
                this._getSource();
            } else {
                this._emit(event.type, event.value);
            }
        },
        _getSource: function () {
            if (!this._inLoop) {
                this._inLoop = true;
                var generator = this._generator;
                while (this._source === null && this._alive && this._active) {
                    this._source = generator(this._iteration++);
                    if (this._source) {
                        this._source.onAny(this._$handleAny);
                    } else {
                        this._emitEnd();
                    }
                }
                this._inLoop = false;
            }
        },
        _onActivation: function () {
            if (this._source) {
                this._source.onAny(this._$handleAny);
            } else {
                this._getSource();
            }
        },
        _onDeactivation: function () {
            if (this._source) {
                this._source.offAny(this._$handleAny);
            }
        },
        _clear: function () {
            Stream.prototype._clear.call(this);
            this._generator = null;
            this._source = null;
            this._$handleAny = null;
        }
    });
    var repeat = function (generator) {
        return new S$33(generator);
    };
    function concat$1(observables) {
        return repeat(function (index) {
            return observables.length > index ? observables[index] : false;
        }).setName('concat');
    }
    function Pool() {
        AbstractPool.call(this);
    }
    inherit(Pool, AbstractPool, {
        _name: 'pool',
        plug: function (obs) {
            this._add(obs);
            return this;
        },
        unplug: function (obs) {
            this._remove(obs);
            return this;
        }
    });
    function FlatMap(source, fn, options) {
        var _this = this;
        AbstractPool.call(this, options);
        this._source = source;
        this._fn = fn;
        this._mainEnded = false;
        this._lastCurrent = null;
        this._$handleMain = function (event) {
            return _this._handleMain(event);
        };
    }
    inherit(FlatMap, AbstractPool, {
        _onActivation: function () {
            AbstractPool.prototype._onActivation.call(this);
            if (this._active) {
                this._source.onAny(this._$handleMain);
            }
        },
        _onDeactivation: function () {
            AbstractPool.prototype._onDeactivation.call(this);
            this._source.offAny(this._$handleMain);
            this._hadNoEvSinceDeact = true;
        },
        _handleMain: function (event) {
            if (event.type === VALUE) {
                var sameCurr = this._activating && this._hadNoEvSinceDeact && this._lastCurrent === event.value;
                if (!sameCurr) {
                    this._add(event.value, this._fn);
                }
                this._lastCurrent = event.value;
                this._hadNoEvSinceDeact = false;
            }
            if (event.type === ERROR) {
                this._emitError(event.value);
            }
            if (event.type === END) {
                if (this._isEmpty()) {
                    this._emitEnd();
                } else {
                    this._mainEnded = true;
                }
            }
        },
        _onEmpty: function () {
            if (this._mainEnded) {
                this._emitEnd();
            }
        },
        _clear: function () {
            AbstractPool.prototype._clear.call(this);
            this._source = null;
            this._lastCurrent = null;
            this._$handleMain = null;
        }
    });
    function FlatMapErrors(source, fn) {
        FlatMap.call(this, source, fn);
    }
    inherit(FlatMapErrors, FlatMap, {
        _handleMain: function (event) {
            if (event.type === ERROR) {
                var sameCurr = this._activating && this._hadNoEvSinceDeact && this._lastCurrent === event.value;
                if (!sameCurr) {
                    this._add(event.value, this._fn);
                }
                this._lastCurrent = event.value;
                this._hadNoEvSinceDeact = false;
            }
            if (event.type === VALUE) {
                this._emitValue(event.value);
            }
            if (event.type === END) {
                if (this._isEmpty()) {
                    this._emitEnd();
                } else {
                    this._mainEnded = true;
                }
            }
        }
    });
    function createConstructor$1(BaseClass, name) {
        return function AnonymousObservable(primary, secondary, options) {
            var _this = this;
            BaseClass.call(this);
            this._primary = primary;
            this._secondary = secondary;
            this._name = primary._name + '.' + name;
            this._lastSecondary = NOTHING;
            this._$handleSecondaryAny = function (event) {
                return _this._handleSecondaryAny(event);
            };
            this._$handlePrimaryAny = function (event) {
                return _this._handlePrimaryAny(event);
            };
            this._init(options);
        };
    }
    function createClassMethods$1(BaseClass) {
        return {
            _init: function () {
            },
            _free: function () {
            },
            _handlePrimaryValue: function (x) {
                this._emitValue(x);
            },
            _handlePrimaryError: function (x) {
                this._emitError(x);
            },
            _handlePrimaryEnd: function () {
                this._emitEnd();
            },
            _handleSecondaryValue: function (x) {
                this._lastSecondary = x;
            },
            _handleSecondaryError: function (x) {
                this._emitError(x);
            },
            _handleSecondaryEnd: function () {
            },
            _handlePrimaryAny: function (event) {
                switch (event.type) {
                case VALUE:
                    return this._handlePrimaryValue(event.value);
                case ERROR:
                    return this._handlePrimaryError(event.value);
                case END:
                    return this._handlePrimaryEnd(event.value);
                }
            },
            _handleSecondaryAny: function (event) {
                switch (event.type) {
                case VALUE:
                    return this._handleSecondaryValue(event.value);
                case ERROR:
                    return this._handleSecondaryError(event.value);
                case END:
                    this._handleSecondaryEnd(event.value);
                    this._removeSecondary();
                }
            },
            _removeSecondary: function () {
                if (this._secondary !== null) {
                    this._secondary.offAny(this._$handleSecondaryAny);
                    this._$handleSecondaryAny = null;
                    this._secondary = null;
                }
            },
            _onActivation: function () {
                if (this._secondary !== null) {
                    this._secondary.onAny(this._$handleSecondaryAny);
                }
                if (this._active) {
                    this._primary.onAny(this._$handlePrimaryAny);
                }
            },
            _onDeactivation: function () {
                if (this._secondary !== null) {
                    this._secondary.offAny(this._$handleSecondaryAny);
                }
                this._primary.offAny(this._$handlePrimaryAny);
            },
            _clear: function () {
                BaseClass.prototype._clear.call(this);
                this._primary = null;
                this._secondary = null;
                this._lastSecondary = null;
                this._$handleSecondaryAny = null;
                this._$handlePrimaryAny = null;
                this._free();
            }
        };
    }
    function createStream$1(name, mixin) {
        var S = createConstructor$1(Stream, name);
        inherit(S, Stream, createClassMethods$1(Stream), mixin);
        return S;
    }
    function createProperty$1(name, mixin) {
        var P = createConstructor$1(Property, name);
        inherit(P, Property, createClassMethods$1(Property), mixin);
        return P;
    }
    var mixin$26 = {
        _handlePrimaryValue: function (x) {
            if (this._lastSecondary !== NOTHING && this._lastSecondary) {
                this._emitValue(x);
            }
        },
        _handleSecondaryEnd: function () {
            if (this._lastSecondary === NOTHING || !this._lastSecondary) {
                this._emitEnd();
            }
        }
    };
    var S$34 = createStream$1('filterBy', mixin$26);
    var P$29 = createProperty$1('filterBy', mixin$26);
    function filterBy(primary, secondary) {
        return new (primary._ofSameType(S$34, P$29))(primary, secondary);
    }
    var id2 = function (_, x) {
        return x;
    };
    function sampledBy(passive, active, combinator) {
        var _combinator = combinator ? function (a, b) {
            return combinator(b, a);
        } : id2;
        return combine([active], [passive], _combinator).setName(passive, 'sampledBy');
    }
    var mixin$27 = {
        _handlePrimaryValue: function (x) {
            if (this._lastSecondary !== NOTHING) {
                this._emitValue(x);
            }
        },
        _handleSecondaryEnd: function () {
            if (this._lastSecondary === NOTHING) {
                this._emitEnd();
            }
        }
    };
    var S$35 = createStream$1('skipUntilBy', mixin$27);
    var P$30 = createProperty$1('skipUntilBy', mixin$27);
    function skipUntilBy(primary, secondary) {
        return new (primary._ofSameType(S$35, P$30))(primary, secondary);
    }
    var mixin$28 = {
        _handleSecondaryValue: function () {
            this._emitEnd();
        }
    };
    var S$36 = createStream$1('takeUntilBy', mixin$28);
    var P$31 = createProperty$1('takeUntilBy', mixin$28);
    function takeUntilBy(primary, secondary) {
        return new (primary._ofSameType(S$36, P$31))(primary, secondary);
    }
    var mixin$29 = {
        _init: function () {
            var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {}, _ref$flushOnEnd = _ref.flushOnEnd, flushOnEnd = _ref$flushOnEnd === undefined ? true : _ref$flushOnEnd;
            this._buff = [];
            this._flushOnEnd = flushOnEnd;
        },
        _free: function () {
            this._buff = null;
        },
        _flush: function () {
            if (this._buff !== null) {
                this._emitValue(this._buff);
                this._buff = [];
            }
        },
        _handlePrimaryEnd: function () {
            if (this._flushOnEnd) {
                this._flush();
            }
            this._emitEnd();
        },
        _onActivation: function () {
            this._primary.onAny(this._$handlePrimaryAny);
            if (this._alive && this._secondary !== null) {
                this._secondary.onAny(this._$handleSecondaryAny);
            }
        },
        _handlePrimaryValue: function (x) {
            this._buff.push(x);
        },
        _handleSecondaryValue: function () {
            this._flush();
        },
        _handleSecondaryEnd: function () {
            if (!this._flushOnEnd) {
                this._emitEnd();
            }
        }
    };
    var S$37 = createStream$1('bufferBy', mixin$29);
    var P$32 = createProperty$1('bufferBy', mixin$29);
    function bufferBy(primary, secondary, options) {
        return new (primary._ofSameType(S$37, P$32))(primary, secondary, options);
    }
    var mixin$30 = {
        _init: function () {
            var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {}, _ref$flushOnEnd = _ref.flushOnEnd, flushOnEnd = _ref$flushOnEnd === undefined ? true : _ref$flushOnEnd, _ref$flushOnChange = _ref.flushOnChange, flushOnChange = _ref$flushOnChange === undefined ? false : _ref$flushOnChange;
            this._buff = [];
            this._flushOnEnd = flushOnEnd;
            this._flushOnChange = flushOnChange;
        },
        _free: function () {
            this._buff = null;
        },
        _flush: function () {
            if (this._buff !== null) {
                this._emitValue(this._buff);
                this._buff = [];
            }
        },
        _handlePrimaryEnd: function () {
            if (this._flushOnEnd) {
                this._flush();
            }
            this._emitEnd();
        },
        _handlePrimaryValue: function (x) {
            this._buff.push(x);
            if (this._lastSecondary !== NOTHING && !this._lastSecondary) {
                this._flush();
            }
        },
        _handleSecondaryEnd: function () {
            if (!this._flushOnEnd && (this._lastSecondary === NOTHING || this._lastSecondary)) {
                this._emitEnd();
            }
        },
        _handleSecondaryValue: function (x) {
            if (this._flushOnChange && !x) {
                this._flush();
            }
            this._lastSecondary = x;
        }
    };
    var S$38 = createStream$1('bufferWhileBy', mixin$30);
    var P$33 = createProperty$1('bufferWhileBy', mixin$30);
    function bufferWhileBy(primary, secondary, options) {
        return new (primary._ofSameType(S$38, P$33))(primary, secondary, options);
    }
    var f = function () {
        return false;
    };
    var t = function () {
        return true;
    };
    function awaiting(a, b) {
        var result = merge([
            map$1(a, t),
            map$1(b, f)
        ]);
        result = skipDuplicates(result);
        result = toProperty(result, f);
        return result.setName(a, 'awaiting');
    }
    var mixin$31 = {
        _init: function (_ref) {
            var fn = _ref.fn;
            this._fn = fn;
        },
        _free: function () {
            this._fn = null;
        },
        _handleValue: function (x) {
            var fn = this._fn;
            var result = fn(x);
            if (result.convert) {
                this._emitError(result.error);
            } else {
                this._emitValue(x);
            }
        }
    };
    var S$39 = createStream('valuesToErrors', mixin$31);
    var P$34 = createProperty('valuesToErrors', mixin$31);
    var defFn = function (x) {
        return {
            convert: true,
            error: x
        };
    };
    function valuesToErrors(obs) {
        var fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defFn;
        return new (obs._ofSameType(S$39, P$34))(obs, { fn: fn });
    }
    var mixin$32 = {
        _init: function (_ref) {
            var fn = _ref.fn;
            this._fn = fn;
        },
        _free: function () {
            this._fn = null;
        },
        _handleError: function (x) {
            var fn = this._fn;
            var result = fn(x);
            if (result.convert) {
                this._emitValue(result.value);
            } else {
                this._emitError(x);
            }
        }
    };
    var S$40 = createStream('errorsToValues', mixin$32);
    var P$35 = createProperty('errorsToValues', mixin$32);
    var defFn$1 = function (x) {
        return {
            convert: true,
            value: x
        };
    };
    function errorsToValues(obs) {
        var fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defFn$1;
        return new (obs._ofSameType(S$40, P$35))(obs, { fn: fn });
    }
    var mixin$33 = {
        _handleError: function (x) {
            this._emitError(x);
            this._emitEnd();
        }
    };
    var S$41 = createStream('endOnError', mixin$33);
    var P$36 = createProperty('endOnError', mixin$33);
    function endOnError(obs) {
        return new (obs._ofSameType(S$41, P$36))(obs);
    }
    Observable.prototype.toProperty = function (fn) {
        return toProperty(this, fn);
    };
    Observable.prototype.changes = function () {
        return changes(this);
    };
    Observable.prototype.toPromise = function (Promise) {
        return toPromise(this, Promise);
    };
    Observable.prototype.toESObservable = toESObservable;
    Observable.prototype[$$observable] = toESObservable;
    Observable.prototype.map = function (fn) {
        return map$1(this, fn);
    };
    Observable.prototype.filter = function (fn) {
        return filter(this, fn);
    };
    Observable.prototype.take = function (n) {
        return take(this, n);
    };
    Observable.prototype.takeErrors = function (n) {
        return takeErrors(this, n);
    };
    Observable.prototype.takeWhile = function (fn) {
        return takeWhile(this, fn);
    };
    Observable.prototype.last = function () {
        return last(this);
    };
    Observable.prototype.skip = function (n) {
        return skip(this, n);
    };
    Observable.prototype.skipWhile = function (fn) {
        return skipWhile(this, fn);
    };
    Observable.prototype.skipDuplicates = function (fn) {
        return skipDuplicates(this, fn);
    };
    Observable.prototype.diff = function (fn, seed) {
        return diff(this, fn, seed);
    };
    Observable.prototype.scan = function (fn, seed) {
        return scan(this, fn, seed);
    };
    Observable.prototype.flatten = function (fn) {
        return flatten(this, fn);
    };
    Observable.prototype.delay = function (wait) {
        return delay(this, wait);
    };
    Observable.prototype.throttle = function (wait, options) {
        return throttle(this, wait, options);
    };
    Observable.prototype.debounce = function (wait, options) {
        return debounce(this, wait, options);
    };
    Observable.prototype.mapErrors = function (fn) {
        return mapErrors(this, fn);
    };
    Observable.prototype.filterErrors = function (fn) {
        return filterErrors(this, fn);
    };
    Observable.prototype.ignoreValues = function () {
        return ignoreValues(this);
    };
    Observable.prototype.ignoreErrors = function () {
        return ignoreErrors(this);
    };
    Observable.prototype.ignoreEnd = function () {
        return ignoreEnd(this);
    };
    Observable.prototype.beforeEnd = function (fn) {
        return beforeEnd(this, fn);
    };
    Observable.prototype.slidingWindow = function (max, min) {
        return slidingWindow(this, max, min);
    };
    Observable.prototype.bufferWhile = function (fn, options) {
        return bufferWhile(this, fn, options);
    };
    Observable.prototype.bufferWithCount = function (count, options) {
        return bufferWhile$1(this, count, options);
    };
    Observable.prototype.bufferWithTimeOrCount = function (wait, count, options) {
        return bufferWithTimeOrCount(this, wait, count, options);
    };
    Observable.prototype.transduce = function (transducer) {
        return transduce(this, transducer);
    };
    Observable.prototype.withHandler = function (fn) {
        return withHandler(this, fn);
    };
    Observable.prototype.thru = function (fn) {
        return fn(this);
    };
    Observable.prototype.combine = function (other, combinator) {
        return combine([
            this,
            other
        ], combinator);
    };
    Observable.prototype.zip = function (other, combinator) {
        return zip([
            this,
            other
        ], combinator);
    };
    Observable.prototype.merge = function (other) {
        return merge([
            this,
            other
        ]);
    };
    Observable.prototype.concat = function (other) {
        return concat$1([
            this,
            other
        ]);
    };
    var pool = function () {
        return new Pool();
    };
    Observable.prototype.flatMap = function (fn) {
        return new FlatMap(this, fn).setName(this, 'flatMap');
    };
    Observable.prototype.flatMapLatest = function (fn) {
        return new FlatMap(this, fn, {
            concurLim: 1,
            drop: 'old'
        }).setName(this, 'flatMapLatest');
    };
    Observable.prototype.flatMapFirst = function (fn) {
        return new FlatMap(this, fn, { concurLim: 1 }).setName(this, 'flatMapFirst');
    };
    Observable.prototype.flatMapConcat = function (fn) {
        return new FlatMap(this, fn, {
            queueLim: -1,
            concurLim: 1
        }).setName(this, 'flatMapConcat');
    };
    Observable.prototype.flatMapConcurLimit = function (fn, limit) {
        return new FlatMap(this, fn, {
            queueLim: -1,
            concurLim: limit
        }).setName(this, 'flatMapConcurLimit');
    };
    Observable.prototype.flatMapErrors = function (fn) {
        return new FlatMapErrors(this, fn).setName(this, 'flatMapErrors');
    };
    Observable.prototype.filterBy = function (other) {
        return filterBy(this, other);
    };
    Observable.prototype.sampledBy = function (other, combinator) {
        return sampledBy(this, other, combinator);
    };
    Observable.prototype.skipUntilBy = function (other) {
        return skipUntilBy(this, other);
    };
    Observable.prototype.takeUntilBy = function (other) {
        return takeUntilBy(this, other);
    };
    Observable.prototype.bufferBy = function (other, options) {
        return bufferBy(this, other, options);
    };
    Observable.prototype.bufferWhileBy = function (other, options) {
        return bufferWhileBy(this, other, options);
    };
    var DEPRECATION_WARNINGS = true;
    function dissableDeprecationWarnings() {
        DEPRECATION_WARNINGS = false;
    }
    function warn(msg) {
        if (DEPRECATION_WARNINGS && console && typeof console.warn === 'function') {
            var msg2 = '\nHere is an Error object for you containing the call stack:';
            console.warn(msg, msg2, new Error());
        }
    }
    Observable.prototype.awaiting = function (other) {
        warn('You are using deprecated .awaiting() method, see https://github.com/kefirjs/kefir/issues/145');
        return awaiting(this, other);
    };
    Observable.prototype.valuesToErrors = function (fn) {
        warn('You are using deprecated .valuesToErrors() method, see https://github.com/kefirjs/kefir/issues/149');
        return valuesToErrors(this, fn);
    };
    Observable.prototype.errorsToValues = function (fn) {
        warn('You are using deprecated .errorsToValues() method, see https://github.com/kefirjs/kefir/issues/149');
        return errorsToValues(this, fn);
    };
    Observable.prototype.endOnError = function () {
        warn('You are using deprecated .endOnError() method, see https://github.com/kefirjs/kefir/issues/150');
        return endOnError(this);
    };
    var Kefir = {
        Observable: Observable,
        Stream: Stream,
        Property: Property,
        never: never,
        later: later,
        interval: interval,
        sequentially: sequentially,
        fromPoll: fromPoll,
        withInterval: withInterval,
        fromCallback: fromCallback,
        fromNodeCallback: fromNodeCallback,
        fromEvents: fromEvents,
        stream: stream,
        constant: constant,
        constantError: constantError,
        fromPromise: fromPromise,
        fromESObservable: fromESObservable,
        combine: combine,
        zip: zip,
        merge: merge,
        concat: concat$1,
        Pool: Pool,
        pool: pool,
        repeat: repeat,
        staticLand: staticLand
    };
    Kefir.Kefir = Kefir;
    exports.dissableDeprecationWarnings = dissableDeprecationWarnings;
    exports.Kefir = Kefir;
    exports.Observable = Observable;
    exports.Stream = Stream;
    exports.Property = Property;
    exports.never = never;
    exports.later = later;
    exports.interval = interval;
    exports.sequentially = sequentially;
    exports.fromPoll = fromPoll;
    exports.withInterval = withInterval;
    exports.fromCallback = fromCallback;
    exports.fromNodeCallback = fromNodeCallback;
    exports.fromEvents = fromEvents;
    exports.stream = stream;
    exports.constant = constant;
    exports.constantError = constantError;
    exports.fromPromise = fromPromise;
    exports.fromESObservable = fromESObservable;
    exports.combine = combine;
    exports.zip = zip;
    exports.merge = merge;
    exports.concat = concat$1;
    exports.Pool = Pool;
    exports.pool = pool;
    exports.repeat = repeat;
    exports.staticLand = staticLand;
    exports['default'] = Kefir;
    Object.defineProperty(exports, '__esModule', { value: true });
}));
/*can-kefir@1.0.1#can-kefir*/
define('can-kefir@1.0.1#can-kefir', [
    'require',
    'exports',
    'module',
    'kefir',
    'can-symbol',
    'can-reflect',
    'can-event-queue/map/map',
    'can-observation-recorder'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        var Kefir = require('kefir');
        var canSymbol = require('can-symbol');
        var canReflect = require('can-reflect');
        var mapEventsMixin = require('can-event-queue/map/map');
        var ObservationRecorder = require('can-observation-recorder');
        var metaSymbol = canSymbol.for('can.meta');
        var onKeyValueSymbol = canSymbol.for('can.onKeyValue');
        var offKeyValueSymbol = canSymbol.for('can.offKeyValue');
        var keyNames = {
            value: {
                on: 'onValue',
                off: 'offValue',
                handler: 'onValueHandler',
                handlers: 'onValueHandlers'
            },
            error: {
                on: 'onError',
                off: 'offError',
                handler: 'onErrorHandler',
                handlers: 'onErrorHandlers'
            }
        };
        function ensureMeta(obj) {
            var meta = obj[metaSymbol];
            if (!meta) {
                meta = {};
                canReflect.setKeyValue(obj, metaSymbol, meta);
            }
            return meta;
        }
        function getCurrentValue(stream, key) {
            if (stream._currentEvent && stream._currentEvent.type === key) {
                return stream._currentEvent.value;
            } else {
                var names = keyNames[key];
                if (!names) {
                    return stream[key];
                }
                var VALUE, valueHandler = function (value) {
                        VALUE = value;
                    };
                stream[names.on](valueHandler);
                stream[names.off](valueHandler);
                return VALUE;
            }
        }
        if (Kefir) {
            Kefir.Observable.prototype._eventSetup = function eventSetup() {
                var stream = this;
                var meta = ensureMeta(stream);
                meta.bound = true;
                meta.onValueHandler = function onValueHandler(newValue) {
                    var oldValue = meta.value;
                    meta.value = newValue;
                    if (newValue !== oldValue) {
                        mapEventsMixin.dispatch.call(stream, { type: 'value' }, [
                            newValue,
                            oldValue
                        ]);
                    }
                };
                meta.onErrorHandler = function onErrorHandler(error) {
                    var prevError = meta.error;
                    meta.error = error;
                    mapEventsMixin.dispatch.call(stream, { type: 'error' }, [
                        error,
                        prevError
                    ]);
                };
                stream.onValue(meta.onValueHandler);
                stream.onError(meta.onErrorHandler);
            };
            Kefir.Observable.prototype._eventTeardown = function eventTeardown() {
                var stream = this;
                var meta = ensureMeta(stream);
                meta.bound = false;
                stream.offValue(meta.onValueHandler);
                stream.offError(meta.onErrorHandler);
            };
            canReflect.assignSymbols(Kefir.Observable.prototype, {
                'can.onKeyValue': function onKeyValue() {
                    return mapEventsMixin[onKeyValueSymbol].apply(this, arguments);
                },
                'can.offKeyValue': function () {
                    return mapEventsMixin[offKeyValueSymbol].apply(this, arguments);
                },
                'can.getKeyValue': function (key) {
                    var stream = this;
                    var meta = ensureMeta(stream);
                    if (!keyNames[key]) {
                        return stream[key];
                    }
                    ObservationRecorder.add(stream, key);
                    if (meta.bound) {
                        return meta[key];
                    } else {
                        var currentValue = getCurrentValue(stream, key);
                        meta[key] = currentValue;
                        return currentValue;
                    }
                },
                'can.getValueDependencies': function getValueDependencies() {
                    var sources;
                    var stream = this;
                    if (stream._source != null) {
                        sources = [stream._source];
                    } else if (stream._sources != null) {
                        sources = stream._sources;
                    }
                    if (sources != null) {
                        return { valueDependencies: new Set(sources) };
                    }
                }
            });
            Kefir.emitterProperty = function () {
                var emitter;
                var setLastValue = false;
                var lastValue, lastError;
                var stream = Kefir.stream(function (EMITTER) {
                    emitter = EMITTER;
                    if (setLastValue) {
                        emitter.value(lastValue);
                    }
                    return function () {
                        emitter = undefined;
                    };
                });
                var property = stream.toProperty(function () {
                    return lastValue;
                });
                property.emitter = {
                    value: function (newValue) {
                        if (emitter) {
                            return emitter.emit(newValue);
                        } else {
                            setLastValue = true;
                            lastValue = newValue;
                        }
                    },
                    error: function (error) {
                        if (emitter) {
                            return emitter.error(error);
                        } else {
                            lastError = error;
                        }
                    }
                };
                property.emitter.emit = property.emitter.value;
                canReflect.assignSymbols(property, {
                    'can.setKeyValue': function setKeyValue(key, value) {
                        this.emitter[key](value);
                    }
                });
                return property;
            };
        }
        module.exports = Kefir;
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-kefir@1.0.1#can-kefir-test*/
define('can-kefir@1.0.1#can-kefir-test', [
    'require',
    'exports',
    'module',
    'can-kefir',
    'steal-qunit',
    'can-queues',
    'can-reflect'
], function (require, exports, module) {
    var Kefir = require('can-kefir');
    var QUnit = require('steal-qunit');
    var queues = require('can-queues');
    var canReflect = require('can-reflect');
    QUnit.module('can-kefir');
    QUnit.test('basics', function () {
        var EMITTER;
        QUnit.expect(5);
        var stream = Kefir.stream(function (emitter) {
            EMITTER = emitter;
        });
        var valueEventCount = 0;
        function valueHandler(value) {
            valueEventCount++;
            if (valueEventCount === 1) {
                QUnit.equal(value, 1, 'produced a value');
            } else if (valueEventCount === 2) {
                QUnit.equal(value, 2, 'produced a value');
            } else {
                QUnit.ok(false, 'should not be called');
            }
        }
        canReflect.onKeyValue(stream, 'value', valueHandler);
        EMITTER.value(1);
        QUnit.equal(canReflect.getKeyValue(stream, 'value'), 1, 'got initial value');
        EMITTER.value(2);
        canReflect.offKeyValue(stream, 'value', valueHandler);
        EMITTER.value(3);
        var errorEventCount = 0;
        function errorHandler(value) {
            errorEventCount++;
            if (errorEventCount === 1) {
                QUnit.equal(value, 'a', 'produced an error');
            } else {
                QUnit.ok(false, 'no more errors');
            }
        }
        canReflect.onKeyValue(stream, 'error', errorHandler);
        EMITTER.error('a');
        QUnit.equal(canReflect.getKeyValue(stream, 'error'), 'a', 'got initial value');
        canReflect.offKeyValue(stream, 'error', errorHandler);
        EMITTER.error('b');
    });
    QUnit.test('properties can be read without binding', function () {
        var EMITTER;
        var property = Kefir.stream(function (emitter) {
            EMITTER = emitter;
        }).toProperty();
        property.onValue(function () {
        });
        EMITTER.value(10);
        QUnit.equal(canReflect.getKeyValue(property, 'value'), 10, 'got property value');
    });
    QUnit.test('properties caches value/error correctly when unbound', function (assert) {
        var emitter;
        var stream = Kefir.stream(function (e) {
            emitter = e;
        }).toProperty();
        var handler = function noop() {
        };
        canReflect.onKeyValue(stream, 'value', handler);
        emitter.value(10);
        canReflect.offKeyValue(stream, 'value', handler);
        assert.equal(canReflect.getKeyValue(stream, 'value'), 10);
        assert.equal(canReflect.getKeyValue(stream, 'error'), undefined);
        canReflect.onKeyValue(stream, 'value', handler);
        assert.equal(canReflect.getKeyValue(stream, 'value'), 10, 'should be cached');
        canReflect.offKeyValue(stream, 'value', handler);
    });
    QUnit.test('callbacks are within a batch', function (assert) {
        var emitter;
        assert.expect(2);
        var stream = Kefir.stream(function (e) {
            emitter = e;
        });
        var valueChangeCounter = 0;
        canReflect.onKeyValue(stream, 'value', function onValueChange() {
            valueChangeCounter += 1;
        });
        queues.batch.start();
        emitter.value(1);
        assert.equal(valueChangeCounter, 0, 'handler should not be called while flushing is prevented');
        queues.batch.stop();
        assert.equal(valueChangeCounter, 1);
    });
    QUnit.test('Kefir.emitterProperty', function () {
        var stream = new Kefir.emitterProperty();
        var valueEventCount = 0;
        function valueHandler(value) {
            valueEventCount++;
            if (valueEventCount === 1) {
                QUnit.equal(value, 1, 'produced a value');
            } else if (valueEventCount === 2) {
                QUnit.equal(value, 2, 'produced a value');
            } else {
                QUnit.ok(false, 'should not be called');
            }
        }
        canReflect.onKeyValue(stream, 'value', valueHandler);
        stream.emitter.emit(1);
        QUnit.equal(canReflect.getKeyValue(stream, 'value'), 1, 'got initial value');
        canReflect.setKeyValue(stream, 'value', 2);
        canReflect.offKeyValue(stream, 'value', valueHandler);
        stream.emitter.value(3);
        var errorEventCount = 0;
        function errorHandler(value) {
            errorEventCount++;
            if (errorEventCount === 1) {
                QUnit.equal(value, 'a', 'produced an error');
            } else {
                QUnit.ok(false, 'no more errors');
            }
        }
        canReflect.onKeyValue(stream, 'error', errorHandler);
        stream.emitter.error('a');
        QUnit.equal(canReflect.getKeyValue(stream, 'error'), 'a', 'got initial value');
        canReflect.offKeyValue(stream, 'error', errorHandler);
        stream.emitter.error('b');
    });
    QUnit.test('get behavior with constant stream', function () {
        var stream = Kefir.stream(function (emit) {
            emit.value(1);
        });
        canReflect.onKeyValue(stream, 'value', function (newVal) {
            QUnit.equal(newVal, 1, 'got new Value');
        });
        QUnit.equal(canReflect.getKeyValue(stream, 'value'), 1, 'undefined');
    });
    QUnit.test('read emitter', function () {
        var stream = new Kefir.emitterProperty();
        QUnit.equal(canReflect.getKeyValue(stream, 'emitter'), stream.emitter, 'got the emitter');
    });
    QUnit.test('getValueDependencies with a single source', function (assert) {
        var source = Kefir.sequentially(750, [
            1,
            2,
            3,
            4,
            5,
            6,
            7,
            8,
            9,
            0
        ]);
        var result = source.throttle(2500);
        assert.deepEqual(canReflect.getValueDependencies(result), { valueDependencies: new Set([source]) });
    });
    QUnit.test('getValueDependencies with multiple sources', function (assert) {
        var a = Kefir.constant('a');
        var b = Kefir.constant('b');
        var c = Kefir.constant('c');
        var combined = Kefir.combine([
            a,
            b,
            c
        ], function (x, y, z) {
            return x + y + z;
        });
        assert.deepEqual(canReflect.getValueDependencies(combined), {
            valueDependencies: new Set([
                a,
                b,
                c
            ])
        });
    });
});
/*can-stream@1.0.0#can-stream*/
define('can-stream@1.0.0#can-stream', [
    'require',
    'exports',
    'module',
    'can-assign',
    'can-compute',
    'can-reflect',
    'can-namespace'
], function (require, exports, module) {
    var assign = require('can-assign');
    var compute = require('can-compute');
    var canReflect = require('can-reflect');
    var namespace = require('can-namespace');
    var toComputeFromEvent = function (observable, eventName) {
        var handler, lastSet;
        return compute(undefined, {
            on: function (updated) {
                handler = function (ev, val) {
                    lastSet = assign({ args: [].slice.call(arguments, 1) }, ev);
                    updated();
                };
                observable.on(eventName, handler);
            },
            off: function (updated) {
                observable.off(eventName, handler);
                lastSet = undefined;
            },
            get: function () {
                return lastSet;
            }
        });
    };
    var STREAM = function (canStreamInterface) {
        var canStream;
        var toStreamFromProperty = function (obs, propName) {
            return canStreamInterface.toStream(compute(obs, propName));
        };
        var toStreamFromEvent = function () {
            var obs = arguments[0];
            var eventName, propName, lastValue, internalCompute;
            if (arguments.length === 2) {
                internalCompute = toComputeFromEvent(obs, arguments[1]);
                return canStreamInterface.toStream(internalCompute);
            } else {
                propName = arguments[1];
                eventName = arguments[2];
                lastValue = obs[propName];
                var valuePropCompute = compute(obs, propName);
                var eventHandler;
                var propChangeHandler;
                internalCompute = compute(undefined, {
                    on: function (updater) {
                        eventHandler = function (ev, newVal, oldVal) {
                            lastValue = newVal;
                            updater(lastValue);
                        };
                        propChangeHandler = function (ev, newVal, oldVal) {
                            oldVal.off(eventName, eventHandler);
                            newVal.on(eventName, eventHandler);
                        };
                        valuePropCompute.on('change', propChangeHandler);
                        valuePropCompute().on(eventName, eventHandler);
                    },
                    off: function () {
                        valuePropCompute().off(eventName, eventHandler);
                        valuePropCompute.off('change', propChangeHandler);
                    },
                    get: function () {
                        return lastValue;
                    },
                    set: function (val) {
                        throw new Error('can-stream: you can\'t set this type of compute');
                    }
                });
                var stream = canStreamInterface.toStream(internalCompute);
                return stream;
            }
        };
        var toStream = function () {
            if (arguments.length === 1) {
                return canStreamInterface.toStream(arguments[0]);
            } else if (arguments.length > 1) {
                var obs = arguments[0];
                var eventNameOrPropName = arguments[1].trim();
                if (eventNameOrPropName.indexOf(' ') === -1) {
                    if (eventNameOrPropName.indexOf('.') === 0) {
                        return canStream.toStreamFromProperty(obs, eventNameOrPropName.slice(1));
                    } else {
                        return canStream.toStreamFromEvent(obs, eventNameOrPropName);
                    }
                } else {
                    var splitEventNameAndProperty = eventNameOrPropName.split(' ');
                    return canStream.toStreamFromEvent(obs, splitEventNameAndProperty[0].slice(1), splitEventNameAndProperty[1]);
                }
            }
            return undefined;
        };
        var toCompute = function (makeStream, context) {
            var args = canReflect.toArray(arguments);
            return canStreamInterface.toCompute.apply(this, args);
        };
        canStream = toStream;
        canStream.toStream = canStream;
        canStream.toStreamFromProperty = toStreamFromProperty;
        canStream.toStreamFromEvent = toStreamFromEvent;
        canStream.toCompute = toCompute;
        return canStream;
    };
    STREAM.toComputeFromEvent = toComputeFromEvent;
    module.exports = namespace.stream = STREAM;
});
/*can-stream@1.0.0#can-stream_test*/
define('can-stream@1.0.0#can-stream_test', [
    'require',
    'exports',
    'module',
    'steal-qunit',
    'can-compute',
    'can-define/map/map',
    'can-define/list/list',
    'can-stream'
], function (require, exports, module) {
    var QUnit = require('steal-qunit');
    var compute = require('can-compute');
    var DefineMap = require('can-define/map/map');
    var DefineList = require('can-define/list/list');
    var canStream = require('can-stream');
    QUnit.module('can-stream');
    test('Resolves to "toStream" function', function () {
        var c = compute(0);
        var obj;
        var streamInterface;
        var streamImplementation = {
            toStream: function (observable, propOrEvent) {
                QUnit.equal(c, observable);
                return obj = {
                    onValue: function (callback) {
                        c.on('change', function (evnt, newVal, oldVal) {
                            callback(newVal);
                        });
                        callback(c());
                    }
                };
            },
            toCompute: function (makeStream, context) {
            }
        };
        streamInterface = canStream(streamImplementation);
        var stream = streamInterface(c);
        QUnit.equal(obj, stream);
    });
    test('Compute changes can be streamed', function () {
        var c = compute(0);
        var obj;
        var canStreaming;
        var canStreamInterface = {
            toStream: function (observable, propOrEvent) {
                QUnit.equal(c, observable);
                return obj = {
                    onValue: function (callback) {
                        c.on('change', function (evnt, newVal, oldVal) {
                            callback(newVal);
                        });
                        callback(c());
                    }
                };
            },
            toCompute: function (makeStream, context) {
            }
        };
        canStreaming = canStream(canStreamInterface);
        var stream = canStreaming.toStream(c);
        QUnit.equal(obj, stream);
        var computeVal;
        stream.onValue(function (newVal) {
            computeVal = newVal;
        });
        QUnit.equal(computeVal, 0);
        c(1);
        QUnit.equal(computeVal, 1);
        c(2);
        QUnit.equal(computeVal, 2);
        c(3);
        QUnit.equal(computeVal, 3);
    });
    QUnit.test('Compute streams do not bind to the compute unless activated', function (assert) {
        var c = compute(0);
        var canStreamInterface = {
            toStream: function (observable, propOrEvent) {
                assert.equal(c, observable);
                return {
                    onValue: function (callback) {
                        c.on('change', function (evnt, newVal, oldVal) {
                            callback(newVal);
                        });
                        callback(c());
                    }
                };
            },
            toCompute: function (makeStream, context) {
            }
        };
        var canStreaming = canStream(canStreamInterface);
        var stream = canStreaming.toStream(c);
        assert.notOk(c.computeInstance.bound, 'should not be bound');
        stream.onValue(function () {
        });
        assert.ok(c.computeInstance.bound, 'should be bound');
    });
    test('Stream on a property val - toStreamFromEvent', function () {
        var expected = 'bar';
        var MyMap = DefineMap.extend({ foo: { value: 'bar' } });
        var canStreamInterface = {
            toStream: function (c) {
                return {
                    onValue: function (callback) {
                        c.on('change', function () {
                            callback.apply(null, arguments);
                        });
                    }
                };
            },
            toCompute: function (makeStream, context) {
            }
        };
        var canStreaming = canStream(canStreamInterface);
        var map = new MyMap();
        var stream = canStreaming.toStream(map, '.foo');
        stream.onValue(function (ev, newVal, oldVal) {
            QUnit.equal(newVal, expected);
        });
        expected = 'foobar';
        map.foo = 'foobar';
    });
    test('Stream on a property val - toStreamFromProperty', function () {
        var expected = 'bar';
        var MyMap = DefineMap.extend({ foo: { value: 'bar' } });
        var canStreamInterface = {
            toStream: function (c) {
                return {
                    onValue: function (callback) {
                        c.on('change', function () {
                            callback.apply(null, arguments);
                        });
                    }
                };
            },
            toCompute: function (makeStream, context) {
            }
        };
        var canStreaming = canStream(canStreamInterface);
        var map = new MyMap();
        var stream = canStreaming.toStream(map, '.foo');
        stream.onValue(function (ev, val) {
            QUnit.equal(val, expected);
        });
        expected = 'foobar';
        map.foo = 'foobar';
    });
    QUnit.test('Event streams fire change events', function (assert) {
        var expected = 0;
        var MyMap = DefineMap.extend({
            fooList: {
                Type: DefineList.List,
                value: []
            }
        });
        var canStreamInterface = {
            toStream: function (c) {
                return {
                    onValue: function (callback) {
                        c.on('change', function (ev, newValue) {
                            callback.call(null, newValue);
                        });
                    }
                };
            },
            toCompute: function (makeStream, context) {
            }
        };
        var canStreaming = canStream(canStreamInterface);
        var map = new MyMap();
        var stream = canStreaming.toStream(map.fooList, 'length');
        stream.onValue(function (lengthEvent) {
            assert.equal(lengthEvent.type, 'length');
            assert.deepEqual(lengthEvent.args, expected, 'Event stream was updated with length: ' + map.fooList.length);
        });
        expected = [
            1,
            0
        ];
        map.fooList.push(1);
        expected = [
            0,
            1
        ];
        map.fooList.pop();
    });
    test('Event streams fire change event on a property', function () {
        var expected = 0;
        var MyMap = DefineMap.extend({
            fooList: {
                Type: DefineList.List,
                value: []
            }
        });
        var canStreamInterface = {
            toStream: function (c) {
                return {
                    onValue: function (callback) {
                        c.on('change', function () {
                            callback.apply(null, arguments);
                        });
                    }
                };
            },
            toCompute: function (makeStream, context) {
            }
        };
        var canStreaming = canStream(canStreamInterface);
        var map = new MyMap();
        var stream = canStreaming.toStream(map, '.fooList add');
        stream.onValue(function (ev, length, oldLength) {
            QUnit.equal(length, expected, 'Event stream was updated with length: ' + map.fooList.length);
        });
        expected = 1;
        map.fooList.push(1);
        expected = 0;
        map.fooList.pop();
    });
    test('Stream on a property val - toStreamFromEvent', function () {
        var MyMap = DefineMap.extend({ foo: { value: 'bar' } });
        var map = new MyMap();
        var canStreamInterface = {
            toStream: function (c) {
                return {
                    onValue: function (callback) {
                        c.on('change', function (ev, newVal) {
                            callback.call(null, newVal);
                        });
                    }
                };
            },
            toCompute: function (makeStream, context) {
            }
        };
        var canStreaming = canStream(canStreamInterface);
        var stream = canStreaming.toStream(map, 'foo');
        stream.onValue(function (fooEvent) {
            QUnit.equal(fooEvent.type, 'foo');
            QUnit.deepEqual(fooEvent.args, [
                'foobar',
                'bar'
            ]);
        });
        map.foo = 'foobar';
    });
    test('Convert an observable nested property into an event stream #2b', 2, function () {
        var MyMap = DefineMap.extend({
            foo: {
                value: function () {
                    return { bar: 1 };
                }
            }
        });
        var obs = new MyMap();
        var canStreamInterface = {
            toStream: function (c) {
                return {
                    onValue: function (callback) {
                        c.on('change', function (ev, newVal) {
                            callback.call(null, newVal);
                        });
                        callback(c());
                    }
                };
            },
            toCompute: function (makeStream, context) {
            }
        };
        var canStreaming = canStream(canStreamInterface);
        var stream = canStreaming.toStream(obs, '.foo.bar');
        var expected = 1;
        stream.onValue(function (barValue) {
            QUnit.equal(barValue, expected, 'value was ' + barValue);
        });
        expected = 2;
        obs.foo.bar = 2;
    });
    test('observable nested property event', 1, function () {
        var MyMap = DefineMap.extend({
            foo: {
                value: function () {
                    return { bar: 1 };
                }
            }
        });
        var obs = new MyMap();
        var canStreamInterface = {
            toStream: function (c) {
                var handler;
                return {
                    onValue: function (callback) {
                        handler = function () {
                            callback.apply(null, arguments);
                        };
                        c.on('change', handler);
                    },
                    offValue: function (callback) {
                        c.off('change', handler);
                    }
                };
            },
            toCompute: function (makeStream, context) {
            }
        };
        var canStreaming = canStream(canStreamInterface);
        var stream = canStreaming.toStream(obs, '.foo bar');
        var expected = 1;
        stream.onValue(function (barEvent, barValue) {
            QUnit.equal(barValue, expected, 'value was ' + barValue);
        });
        expected = 2;
        obs.foo.bar = 2;
    });
    test('Event streams fire change events on a property', function () {
        var expected = 0;
        var MyMap = DefineMap.extend({
            fooList: {
                Type: DefineList.List,
                value: []
            }
        });
        var map = new MyMap();
        var canStreamInterface = {
            toStream: function (c) {
                var handler;
                return {
                    onValue: function (callback) {
                        handler = function () {
                            callback.apply(null, arguments);
                        };
                        c.on('change', handler);
                    },
                    offValue: function (callback) {
                        c.off('change', handler);
                    }
                };
            },
            toCompute: function (makeStream, context) {
            }
        };
        var canStreaming = canStream(canStreamInterface);
        var stream = canStreaming.toStream(map, '.fooList length');
        var handler = function (ev, length, lastLength) {
            QUnit.equal(length, expected, 'Event stream was updated with length: ' + map.fooList.length);
        };
        stream.onValue(handler);
        expected = 1;
        map.fooList.push(1);
        expected = 2;
        map.fooList.push(2);
        expected = 1;
        map.fooList.pop();
        expected = 0;
        map.fooList = new DefineList([]);
        stream.offValue(handler);
    });
    test('Create a stream from a observable and event with shorthand method: toStream', function () {
        var expected = 0;
        var MyMap = DefineMap.extend({
            fooList: {
                Type: DefineList.List,
                value: []
            }
        });
        var map = new MyMap();
        var canStreamInterface = {
            toStream: function (c) {
                return {
                    onValue: function (callback) {
                        c.on('change', function () {
                            callback.apply(null, arguments);
                        });
                    }
                };
            },
            toCompute: function (makeStream, context) {
            }
        };
        var canStreaming = canStream(canStreamInterface);
        var stream = canStreaming.toStream(map.fooList, 'length');
        stream.onValue(function (ev) {
            QUnit.equal(map.fooList.length, expected, 'Event stream was updated with length: ' + map.fooList.length);
        });
        expected = 1;
        map.fooList.push(1);
        expected = 0;
        map.fooList.pop();
    });
    test('Create a stream from a observable and event on property with shorthand method: toStream', function () {
        var expected = 0;
        var MyMap = DefineMap.extend({
            fooList: {
                Type: DefineList.List,
                value: []
            }
        });
        var map = new MyMap();
        var canStreamInterface = {
            toStream: function (c) {
                return {
                    onValue: function (callback) {
                        c.on('change', function () {
                            callback.apply(null, arguments);
                        });
                    }
                };
            },
            toCompute: function (makeStream, context) {
            }
        };
        var canStreaming = canStream(canStreamInterface);
        var stream = canStreaming.toStream(map, '.fooList length');
        stream.onValue(function (ev) {
            QUnit.equal(map.fooList.length, expected, 'Event stream was updated with length: ' + map.fooList.length);
        });
        expected = 1;
        map.fooList.push(1);
        expected = 0;
        map.fooList.pop();
    });
    test('Update the list to undefined', function () {
        var expected = 0;
        var MyMap = DefineMap.extend({
            fooList: {
                Type: DefineList.List,
                value: []
            }
        });
        var map = new MyMap();
        var canStreamInterface = {
            toStream: function (c) {
                return {
                    onValue: function (callback) {
                        c.on('change', function () {
                            callback.apply(null, arguments);
                        });
                    }
                };
            },
            toCompute: function (makeStream, context) {
            }
        };
        var canStreaming = canStream(canStreamInterface);
        var stream = canStreaming.toStream(map, '.fooList.length');
        stream.onValue(function (ev, newVal) {
            QUnit.equal(newVal, expected, 'Setting fooList to null');
        });
        expected = undefined;
        map.fooList = null;
    });
    test('toStreamFromEvent passes event and other arguments', 3, function () {
        var myMap = new DefineMap({ prop: 'value' });
        var c = canStream.toComputeFromEvent(myMap, 'prop');
        c.on('change', function (ev, newVal) {
            QUnit.equal(newVal.type, 'prop');
            QUnit.deepEqual(newVal.args, [
                'VALUE',
                'value'
            ]);
        });
        QUnit.equal(c(), undefined, 'no value');
        myMap.prop = 'VALUE';
    });
});
/*can-stream-kefir@1.0.0#can-stream-kefir*/
define('can-stream-kefir@1.0.0#can-stream-kefir', [
    'require',
    'exports',
    'module',
    'can-kefir',
    'can-compute',
    'can-stream',
    'can-symbol',
    'can-namespace'
], function (require, exports, module) {
    var Kefir = require('can-kefir');
    var compute = require('can-compute');
    var canStream = require('can-stream');
    var canSymbol = require('can-symbol');
    var namespace = require('can-namespace');
    var getValueDependenciesSymbol = canSymbol.for('can.getValueDependencies');
    var getKeyDependenciesSymbol = canSymbol.for('can.getKeyDependencies');
    var canStreamKefir = {};
    canStreamKefir.toStream = function (compute) {
        var stream = Kefir.stream(function (emitter) {
            var changeHandler = function (ev, newVal) {
                emitter.emit(newVal);
            };
            compute.on('change', changeHandler);
            var currentValue = compute();
            if (currentValue !== undefined) {
                emitter.emit(currentValue);
            }
            return function () {
                compute.off('change', changeHandler);
            };
        });
        stream[getValueDependenciesSymbol] = function getValueDependencies() {
            return { valueDependencies: new Set([compute]) };
        };
        return stream;
    };
    canStreamKefir.toCompute = function (makeStream, context) {
        var emitter, lastValue, streamHandler, lastSetValue;
        var setterStream = Kefir.stream(function (e) {
            emitter = e;
            if (lastSetValue !== undefined) {
                emitter.emit(lastSetValue);
            }
        });
        var valueStream = makeStream.call(context, setterStream);
        var streamCompute = compute(undefined, {
            get: function () {
                return lastValue;
            },
            set: function (val) {
                if (emitter) {
                    emitter.emit(val);
                } else {
                    lastSetValue = val;
                }
                return val;
            },
            on: function (updated) {
                streamHandler = function (val) {
                    lastValue = val;
                    updated();
                };
                valueStream.onValue(streamHandler);
            },
            off: function () {
                valueStream.offValue(streamHandler);
            }
        });
        var _compute = streamCompute.computeInstance;
        _compute[getKeyDependenciesSymbol] = function getKeyDependencies(key) {
            if (key === 'change') {
                return { valueDependencies: new Set([valueStream]) };
            }
        };
        return streamCompute;
    };
    if (!namespace.streamKefir) {
        module.exports = namespace.streamKefir = canStream(canStreamKefir);
    }
});
/*can-stream-kefir@1.0.0#can-stream-kefir_test*/
define('can-stream-kefir@1.0.0#can-stream-kefir_test', [
    'require',
    'exports',
    'module',
    'steal-qunit',
    'can-stream-kefir',
    'can-compute',
    'can-reflect',
    'can-define/list/list'
], function (require, exports, module) {
    var QUnit = require('steal-qunit');
    var canStream = require('can-stream-kefir');
    var compute = require('can-compute');
    var canReflect = require('can-reflect');
    var DefineList = require('can-define/list/list');
    QUnit.module('can-stream-kefir');
    test('Compute changes can be streamed', function () {
        var c = compute(0);
        var stream = canStream.toStream(c);
        var computeVal;
        stream.onValue(function (newVal) {
            computeVal = newVal;
        });
        QUnit.equal(computeVal, 0);
        c(1);
        QUnit.equal(computeVal, 1);
        c(2);
        QUnit.equal(computeVal, 2);
        c(3);
        QUnit.equal(computeVal, 3);
    });
    QUnit.test('Compute streams do not bind to the compute unless activated', function (assert) {
        var c = compute(0);
        var stream = canStream.toStream(c);
        assert.notOk(c.computeInstance.bound, 'should not be bound');
        stream.onValue(function () {
        });
        assert.ok(c.computeInstance.bound, 'should be bound');
    });
    test('Compute stream values can be piped into a compute', function () {
        var expected = 0;
        var c1 = compute(0);
        var c2 = compute(0);
        var resultCompute = canStream.toStream(c1).merge(canStream.toStream(c2));
        resultCompute.onValue(function (val) {
            QUnit.equal(val, expected);
        });
        expected = 1;
        c1(1);
        expected = 2;
        c2(2);
        expected = 3;
        c1(3);
    });
    test('Computed streams fire change events', function () {
        var expected = 0;
        var c1 = compute(expected);
        var c2 = compute(expected);
        var resultCompute = canStream.toStream(c1).merge(canStream.toStream(c2));
        resultCompute.onValue(function (newVal) {
            QUnit.equal(expected, newVal);
        });
        expected = 1;
        c1(expected);
        expected = 2;
        c2(expected);
        expected = 3;
        c1(expected);
    });
    test('Create a stream from a compute with shorthand method: toStream', function () {
        var expected = 0;
        var c1 = compute(0);
        var resultCompute = canStream.toStream(c1);
        resultCompute.onValue(function (val) {
            QUnit.equal(val, expected);
        });
        expected = 1;
        c1(1);
    });
    test('toCompute(streamMaker) can-define-stream#17', function () {
        var c = compute('a');
        var letterStream = canStream.toStream(c);
        var streamedCompute = canStream.toCompute(function (setStream) {
            return setStream.merge(letterStream);
        });
        streamedCompute.on('change', function (ev, newVal) {
        });
        QUnit.deepEqual(streamedCompute(), 'a');
        c(1);
        QUnit.deepEqual(streamedCompute(), 1);
        c('b');
        QUnit.deepEqual(streamedCompute(), 'b');
    });
    test('setting test', function () {
        var c = canStream.toCompute(function (setStream) {
            return setStream;
        });
        c(5);
        c.on('change', function () {
        });
        QUnit.equal(c(), 5);
    });
    test('Stream on DefineList', function () {
        var expectedLength;
        var people = new DefineList([
            {
                first: 'Justin',
                last: 'Meyer'
            },
            {
                first: 'Paula',
                last: 'Strozak'
            }
        ]);
        var stream = canStream.toStream(people, '.length');
        expectedLength = 2;
        stream.onValue(function (newLength) {
            QUnit.equal(newLength, expectedLength, 'List size changed');
        });
        expectedLength = 3;
        people.push({
            first: 'Obaid',
            last: 'Ahmed'
        });
        expectedLength = 2;
        people.pop();
    });
    test('Computes with an initial value of undefined do not emit', function () {
        var expectedLength;
        var people = new DefineList([
            {
                first: 'Justin',
                last: 'Meyer'
            },
            {
                first: 'Paula',
                last: 'Strozak'
            }
        ]);
        var stream = canStream.toStream(people, 'length');
        expectedLength = 2;
        stream.onValue(function (event) {
            QUnit.equal(event.args[0], expectedLength, 'List size changed');
        });
        expectedLength = 3;
        people.push({
            first: 'Obaid',
            last: 'Ahmed'
        });
        expectedLength = 2;
        people.pop();
    });
    QUnit.test('getValueDependencies - stream from compute', function (assert) {
        var c = compute(0);
        var stream = canStream.toStream(c);
        assert.deepEqual(canReflect.getValueDependencies(stream), { valueDependencies: new Set([c]) });
    });
    QUnit.test('getValueDependencies - streamedCompute', function (assert) {
        var mergeStream;
        var c = compute('a');
        var letterStream = canStream.toStream(c);
        var makeStream = function makeStream(setStream) {
            return mergeStream = setStream.merge(letterStream);
        };
        var streamedCompute = canStream.toCompute(makeStream);
        assert.deepEqual(canReflect.getKeyDependencies(streamedCompute.computeInstance, 'change'), { valueDependencies: new Set([mergeStream]) });
    });
});
/*can-ndjson-stream@0.1.7#can-ndjson-stream*/
define('can-ndjson-stream@0.1.7#can-ndjson-stream', [
    'require',
    'exports',
    'module',
    'can-namespace'
], function (require, exports, module) {
    var namespace = require('can-namespace');
    var ndjsonStream = function (response) {
        var is_reader, cancellationRequest = false;
        return new ReadableStream({
            start: function (controller) {
                var reader = response.getReader();
                is_reader = reader;
                var decoder = new TextDecoder();
                var data_buf = '';
                reader.read().then(function processResult(result) {
                    if (result.done) {
                        if (cancellationRequest) {
                            return;
                        }
                        data_buf = data_buf.trim();
                        if (data_buf.length !== 0) {
                            try {
                                var data_l = JSON.parse(data_buf);
                                controller.enqueue(data_l);
                            } catch (e) {
                                controller.error(e);
                                return;
                            }
                        }
                        controller.close();
                        return;
                    }
                    var data = decoder.decode(result.value, { stream: true });
                    data_buf += data;
                    var lines = data_buf.split('\n');
                    for (var i = 0; i < lines.length - 1; ++i) {
                        var l = lines[i].trim();
                        if (l.length > 0) {
                            try {
                                var data_line = JSON.parse(l);
                                controller.enqueue(data_line);
                            } catch (e) {
                                controller.error(e);
                                cancellationRequest = true;
                                reader.cancel();
                                return;
                            }
                        }
                    }
                    data_buf = lines[lines.length - 1];
                    return reader.read().then(processResult);
                });
            },
            cancel: function (reason) {
                console.log('Cancel registered due to ', reason);
                cancellationRequest = true;
                is_reader.cancel();
            }
        });
    };
    module.exports = namespace.ndjsonStream = ndjsonStream;
});
/*can-ndjson-stream@0.1.7#can-ndjson-stream-test*/
define('can-ndjson-stream@0.1.7#can-ndjson-stream-test', [
    'require',
    'exports',
    'module',
    'steal-qunit',
    'can-ndjson-stream'
], function (require, exports, module) {
    var QUnit = require('steal-qunit');
    var ndjsonStream = require('can-ndjson-stream');
    var isReadStreamSupported = true;
    try {
        new ReadableStream();
    } catch (err) {
        isReadStreamSupported = false;
    }
    var conditionalTest = isReadStreamSupported ? QUnit.test : QUnit.skip;
    var conditionalAsyncTest = isReadStreamSupported ? QUnit.asyncTest : QUnit.skip;
    function readableStreamFromString(s) {
        return new ReadableStream({
            start: function (controller) {
                var encoder = new TextEncoder();
                var pos = 0;
                var chunkSize = 1;
                function push() {
                    if (pos >= s.length) {
                        controller.close();
                        return;
                    }
                    controller.enqueue(encoder.encode(s.slice(pos, pos + chunkSize)));
                    pos += chunkSize;
                    push();
                }
                push();
            },
            cancel: function () {
            }
        });
    }
    function inputStream(objArray) {
        var jsons = objArray.map(function (obj) {
            return JSON.stringify(obj);
        });
        return readableStreamFromString(jsons.join('\n'));
    }
    QUnit.module('can-ndjson-stream');
    conditionalTest('Initialized the plugin', function () {
        QUnit.equal(typeof ndjsonStream, 'function');
    });
    conditionalAsyncTest('simple_test_from_stream', function (assert) {
        var testObject = [
            {
                'date': '2017-02-24 03:07:45',
                'user': '21109850',
                'fuel': '37',
                'ammo': '2',
                'steel': '13',
                'baux': '5',
                'seaweed': '0',
                'type': 'LOOT',
                'product': '134'
            },
            {
                'date': '2017-02-22 04:40:13',
                'user': '21109850',
                'fuel': '37',
                'ammo': '2',
                'steel': '13',
                'baux': '5',
                'seaweed': '0',
                'type': 'LOOT',
                'product': '75'
            },
            {
                'date': '2017-02-21 20:47:51',
                'user': '26464462',
                'fuel': '37',
                'ammo': '3',
                'steel': '19',
                'baux': '5',
                'seaweed': '1',
                'type': 'LOOT',
                'product': '81'
            }
        ];
        var readObjects = [];
        var todoStream = ndjsonStream(inputStream(testObject));
        function test(todosStream) {
            var reader = todosStream.getReader();
            reader.read().then(function read(result) {
                if (result.done) {
                    assert.deepEqual(readObjects, testObject, 'Two arrays should be the same in value');
                    QUnit.start();
                    return;
                }
                readObjects.push(result.value);
                reader.read().then(read);
            });
        }
        test(todoStream);
    });
    conditionalAsyncTest('malformed json', function (assert) {
        var malformed_string = '{"1":2}\n{sss: 2}';
        var readObjects = [];
        var todoStream = ndjsonStream(readableStreamFromString(malformed_string));
        var reader = todoStream.getReader();
        var errorCaught = false;
        function errCheck() {
            errorCaught = true;
        }
        var allDone = reader.read().then(function read(result) {
            if (result.done) {
                return;
            }
            readObjects.push(result.value);
            return reader.read().then(read, errCheck);
        }, errCheck);
        allDone.then(function () {
            assert.strictEqual(errorCaught, true, 'malformed json string should cause an error');
            QUnit.start();
        }, function () {
            assert.strictEqual(errorCaught, true, 'rejected: malformed json string should cause an error');
            QUnit.start();
        });
    });
});
/*can-define-stream@1.0.0#can-define-stream*/
define('can-define-stream@1.0.0#can-define-stream', [
    'require',
    'exports',
    'module',
    'can-define',
    'can-assign',
    'can-reflect'
], function (require, exports, module) {
    var define = require('can-define');
    var assign = require('can-assign');
    var canReflect = require('can-reflect');
    module.exports = function (canStream) {
        return function (DefineMapType) {
            [
                'toStream',
                'toStreamFromProperty',
                'toStreamFromEvent'
            ].forEach(function (name) {
                DefineMapType.prototype[name] = function () {
                    return canStream[name].apply(canStream, [this].concat([].slice.call(arguments)));
                };
            });
            DefineMapType.prototype.stream = DefineMapType.prototype.toStream;
            var definitions = DefineMapType.prototype._define.definitions, dataInitializers = DefineMapType.prototype._define.dataInitializers, computedInitializers = DefineMapType.prototype._define.computedInitializers;
            canReflect.eachKey(definitions, function (definition, property) {
                var streamDefinition = definition.stream;
                if (streamDefinition) {
                    var newDefinition = assign({
                        default: function () {
                            return canStream.toCompute(streamDefinition, this);
                        }
                    }, define.types.compute);
                    define.property(DefineMapType.prototype, property, newDefinition, dataInitializers, computedInitializers);
                }
            });
        };
    };
});
/*can-define-stream@1.0.0#can-define-stream_test*/
define('can-define-stream@1.0.0#can-define-stream_test', [
    'require',
    'exports',
    'module',
    'steal-qunit',
    'can-define/map/map',
    'can-define/list/list',
    'can-define-stream',
    'can-compute',
    'can-stream',
    'can-symbol'
], function (require, exports, module) {
    var QUnit = require('steal-qunit');
    var DefineMap = require('can-define/map/map');
    var DefineList = require('can-define/list/list');
    var defineStream = require('can-define-stream');
    var compute = require('can-compute');
    var canStream = require('can-stream');
    var canSymbol = require('can-symbol');
    var metaSymbol = canSymbol.for('can.meta');
    QUnit.module('can-define-stream');
    var id = 0;
    var canStreamInterface = {
        toStream: function (c) {
            return {
                id: ++id,
                onValue: function (callback) {
                    callback['_computeHandler' + this.id] = function (ev, newVal) {
                        callback(newVal);
                    };
                    c.on('change', callback['_computeHandler' + this.id]);
                    callback(c());
                },
                offValue: function (callback) {
                    c.off('change', callback['_computeHandler' + this.id]);
                }
            };
        },
        toCompute: function (makeStream, context) {
            var lastValue, streamHandler;
            var setCallbacks = [];
            var setterStream = {
                onValue: function (callback) {
                    setCallbacks.push(callback);
                },
                offValue: function (callback) {
                    var index = setCallbacks.indexOf(callback);
                    setCallbacks.splice(index, 1);
                }
            };
            var valueStream = makeStream.call(context, setterStream);
            return compute(undefined, {
                get: function () {
                    return lastValue;
                },
                set: function (val) {
                    setCallbacks.forEach(function (cb) {
                        cb(val);
                    });
                    return val;
                },
                on: function (updated) {
                    streamHandler = function (newVal, oldVal) {
                        lastValue = newVal;
                        updated(lastValue);
                    };
                    valueStream.onValue(streamHandler);
                },
                off: function () {
                    valueStream.offValue(streamHandler);
                }
            });
        }
    };
    var canStreaming = canStream(canStreamInterface);
    var poll = function poll(fn, callback, timeout, interval) {
        var endTime = Number(new Date()) + (timeout || 2000);
        interval = interval || 100;
        (function p() {
            if (fn()) {
                callback();
            } else if (Number(new Date()) < endTime) {
                setTimeout(p, interval);
            } else {
                callback();
            }
        }());
    };
    test('Stream behavior on multiple properties with merge', 8, function () {
        var expectedNewVal, expectedOldVal, caseName;
        var MyMap = DefineMap.extend('MyMap', {
            foo: 'string',
            bar: {
                type: 'string',
                value: 'bar'
            },
            baz: {
                type: 'string',
                stream: function (setStream) {
                    var mergedCompute = compute();
                    var mergeValue = function (val) {
                        mergedCompute(val);
                    };
                    this.stream('.foo').onValue(mergeValue);
                    this.stream('.bar').onValue(mergeValue);
                    setStream.onValue(mergeValue);
                    return canStreaming.toStream(mergedCompute);
                }
            }
        });
        defineStream(canStreaming)(MyMap);
        var map = new MyMap();
        map.foo = 'foo-1';
        QUnit.equal(map.baz, undefined, 'read value before binding');
        map.on('baz', function (ev, newVal, oldVal) {
            QUnit.equal(newVal, expectedNewVal, caseName + ' newVal');
            QUnit.equal(oldVal, expectedOldVal, caseName + ' oldVal');
        });
        QUnit.equal(map.baz, 'bar', 'read value immediately after binding');
        caseName = 'setting foo';
        expectedOldVal = 'bar';
        expectedNewVal = 'foo-2';
        map.foo = 'foo-2';
        caseName = 'setting bar';
        expectedOldVal = expectedNewVal;
        expectedNewVal = 'new bar';
        map.bar = 'new bar';
        caseName = 'setting baz setter';
        expectedOldVal = expectedNewVal;
        expectedNewVal = 'new baz';
        map.baz = 'new baz';
    });
    QUnit.test('Test if streams are memory safe', function (assert) {
        var done = assert.async();
        var MyMap = DefineMap.extend({
            foo: 'string',
            bar: {
                type: 'string',
                value: 'bar'
            },
            baz: {
                type: 'string',
                stream: function (setStream) {
                    var fooStream = this.stream('.foo');
                    var barStream = this.stream('.bar');
                    var lastValue;
                    var UPDATER;
                    var setLastValue = function (value) {
                        lastValue = value;
                        UPDATER(value);
                    };
                    var mergedCompute = compute(undefined, {
                        on: function (updater) {
                            UPDATER = updater;
                            fooStream.onValue(setLastValue);
                            barStream.onValue(setLastValue);
                            setStream.onValue(setLastValue);
                        },
                        off: function () {
                            fooStream.offValue(setLastValue);
                            barStream.offValue(setLastValue);
                            setStream.offValue(setLastValue);
                        },
                        get: function () {
                            return lastValue;
                        }
                    });
                    return canStreaming.toStream(mergedCompute);
                }
            }
        });
        defineStream(canStreaming)(MyMap);
        var getNumberOfBindings = function (map) {
            var meta = map[metaSymbol];
            return meta && meta.handlers && meta.handlers.get([]).length;
        };
        var map = new MyMap();
        assert.equal(getNumberOfBindings(map), undefined, 'Should have no bindings');
        var handler = function (ev, newVal, oldVal) {
        };
        map.on('baz', handler);
        assert.equal(getNumberOfBindings(map), 3, 'Should have 3 bindings');
        map.off('baz', handler);
        poll(function () {
            return getNumberOfBindings(map) === 0;
        }, function () {
            assert.equal(getNumberOfBindings(map), 0, 'Should reset the bindings');
            done();
        });
    });
    test('Stream on DefineList', function () {
        var expectedLength;
        var PeopleList = DefineList.extend({});
        var canStreamInterface = {
            toStream: function (c) {
                return {
                    onValue: function (callback) {
                        c.on('change', function () {
                            callback.apply(null, arguments);
                        });
                    }
                };
            },
            toCompute: function (makeStream, context) {
            }
        };
        var canStreaming = canStream(canStreamInterface);
        defineStream(canStreaming)(PeopleList);
        var people = new PeopleList([
            {
                first: 'Justin',
                last: 'Meyer'
            },
            {
                first: 'Paula',
                last: 'Strozak'
            }
        ]);
        var stream = people.stream('.length');
        expectedLength = 2;
        stream.onValue(function (ev, val) {
            QUnit.equal(val, expectedLength, 'List size changed');
        });
        expectedLength = 3;
        people.push({
            first: 'Obaid',
            last: 'Ahmed'
        });
        expectedLength = 2;
        people.pop();
    });
});
/*can-define-stream-kefir@1.0.0#can-define-stream-kefir*/
define('can-define-stream-kefir@1.0.0#can-define-stream-kefir', [
    'require',
    'exports',
    'module',
    'can-namespace',
    'can-define-stream',
    'can-stream-kefir'
], function (require, exports, module) {
    var namespace = require('can-namespace');
    var canDefineStream = require('can-define-stream');
    var canStreamKefir = require('can-stream-kefir');
    module.exports = namespace.defineStreamKefir = canDefineStream(canStreamKefir);
});
/*can-define-stream-kefir@1.0.0#can-define-stream-kefir_test*/
define('can-define-stream-kefir@1.0.0#can-define-stream-kefir_test', [
    'require',
    'exports',
    'module',
    'steal-qunit',
    'can-define/map/map',
    'can-define/list/list',
    'can-define-stream-kefir',
    'can-symbol'
], function (require, exports, module) {
    var QUnit = require('steal-qunit');
    var DefineMap = require('can-define/map/map');
    var DefineList = require('can-define/list/list');
    var canDefineStreamKefir = require('can-define-stream-kefir');
    var canSymbol = require('can-symbol');
    var metaSymbol = canSymbol.for('can.meta');
    var poll = function poll(fn, callback, timeout, interval) {
        var endTime = Number(new Date()) + (timeout || 2000);
        interval = interval || 100;
        (function p() {
            if (fn()) {
                callback();
            } else if (Number(new Date()) < endTime) {
                setTimeout(p, interval);
            } else {
                callback();
            }
        }());
    };
    QUnit.module('can-define-stream-kefir');
    test('Stream behavior on multiple properties with merge', 8, function () {
        var expectedNewVal, expectedOldVal, caseName;
        var MyMap = DefineMap.extend({
            foo: 'string',
            bar: {
                type: 'string',
                value: 'bar'
            },
            baz: {
                type: 'string',
                stream: function (stream) {
                    var fooStream = this.stream('.foo');
                    var barStream = this.stream('.bar');
                    return stream.merge(fooStream).merge(barStream);
                }
            }
        });
        canDefineStreamKefir(MyMap);
        var map = new MyMap();
        map.foo = 'foo-1';
        QUnit.equal(map.baz, undefined, 'read value before binding');
        map.on('baz', function (ev, newVal, oldVal) {
            QUnit.equal(newVal, expectedNewVal, caseName + ' newVal');
            QUnit.equal(oldVal, expectedOldVal, caseName + ' oldVal');
        });
        QUnit.equal(map.baz, 'bar', 'read value immediately after binding');
        caseName = 'setting foo';
        expectedOldVal = 'bar';
        expectedNewVal = 'foo-2';
        map.foo = 'foo-2';
        caseName = 'setting bar';
        expectedOldVal = expectedNewVal;
        expectedNewVal = 'new bar';
        map.bar = 'new bar';
        caseName = 'setting baz setter';
        expectedOldVal = expectedNewVal;
        expectedNewVal = 'new baz';
        map.baz = 'new baz';
    });
    QUnit.test('Test if streams are memory safe', function (assert) {
        var done = assert.async();
        var MyMap = DefineMap.extend({
            foo: 'string',
            bar: {
                type: 'string',
                value: 'bar'
            },
            baz: {
                type: 'string',
                stream: function (stream) {
                    var fooStream = this.stream('.foo');
                    var barStream = this.stream('.bar');
                    return stream.merge(fooStream).merge(barStream);
                }
            }
        });
        canDefineStreamKefir(MyMap);
        var getNumberOfBindings = function getNumberOfBindings(map) {
            var meta = map[metaSymbol];
            return meta && meta.handlers && meta.handlers.get([]).length;
        };
        var map = new MyMap();
        assert.equal(getNumberOfBindings(map), undefined, 'Should have no bindings');
        var handler = function handler(ev, newVal, oldVal) {
        };
        map.on('baz', handler);
        map.foo = 'obaid';
        assert.equal(getNumberOfBindings(map), 3, 'Should have 3 bindings');
        map.off('baz', handler);
        poll(function () {
            return getNumberOfBindings(map) === 0;
        }, function () {
            assert.equal(getNumberOfBindings(map), 0, 'Should reset the bindings');
            done();
        });
    });
    test('Keep track of change counts on stream', function () {
        var count;
        var Person = DefineMap.extend({
            first: 'string',
            last: 'string',
            fullName: {
                get: function () {
                    return this.first + ' ' + this.last;
                }
            },
            fullNameChangeCount: {
                stream: function (setStream) {
                    return this.stream('.fullName').scan(function (last) {
                        return last + 1;
                    }, 0);
                }
            }
        });
        canDefineStreamKefir(Person);
        var me = new Person({
            first: 'Justin',
            last: 'Meyer'
        });
        me.on('fullNameChangeCount', function (ev, newVal) {
            QUnit.equal(newVal, count, 'Count should be ' + count);
        });
        count = 2;
        me.first = 'Obaid';
        count = 3;
        me.last = 'Ahmed';
    });
    test('Update map property based on stream value', function () {
        var expected;
        var Person = DefineMap.extend({
            name: 'string',
            lastValidName: {
                stream: function () {
                    return this.stream('.name').filter(function (name) {
                        return name.indexOf(' ') >= 0;
                    });
                }
            }
        });
        canDefineStreamKefir(Person);
        var me = new Person({ name: 'James' });
        me.on('lastValidName', function (lastValid) {
            QUnit.equal(lastValid.target.name, expected, 'Updated name to ' + expected);
        });
        me.name = 'JamesAtherton';
        expected = 'James Atherton';
        me.name = 'James Atherton';
        me.name = 'JustinMeyer';
        expected = 'Justin Meyer';
        me.name = 'Justin Meyer';
    });
    test('Stream on DefineList', function () {
        var expectedLength;
        var People = DefineList.extend({});
        canDefineStreamKefir(People);
        var people = new People([
            {
                first: 'Justin',
                last: 'Meyer'
            },
            {
                first: 'Paula',
                last: 'Strozak'
            }
        ]);
        var stream = people.stream('length');
        stream.onValue(function (event) {
            QUnit.equal(event.args[0], expectedLength, 'List size changed');
        });
        expectedLength = 3;
        people.push({
            first: 'Obaid',
            last: 'Ahmed'
        });
        expectedLength = 2;
        people.pop();
    });
    QUnit.test('Can instantiate define-map instances with properties that have stream definitions.', function (assert) {
        var Locator = DefineMap.extend({
            state: 'string',
            city: {
                stream: function (setStream) {
                    return this.stream('.state').map(function () {
                        return null;
                    }).merge(setStream);
                }
            }
        });
        canDefineStreamKefir(Locator);
        var locator = new Locator({
            state: 'IL',
            city: 'Chitown'
        });
        assert.equal(locator.state, 'IL', 'State in tact, no errors');
        assert.equal(typeof locator.city, 'undefined', 'Derived value ignored until bound.');
        locator.on('city', function () {
        });
        assert.equal(locator.city, 'Chitown', 'can still get initial value');
        locator.state = 'FL';
        assert.equal(locator.city, null, 'Derived value set.');
    });
});
/*can-validate@1.1.3#can-validate*/
define('can-validate@1.1.3#can-validate', [
    'require',
    'exports',
    'module',
    'can-reflect'
], function (require, exports, module) {
    var canReflect = require('can-reflect');
    var validate = {};
    var helpers = {
        'object': function (normalizedErrors) {
            var errors = normalizedErrors.length > 0 ? {} : undefined;
            canReflect.eachIndex(normalizedErrors, function (error) {
                canReflect.eachIndex(error.related, function (related) {
                    if (!errors[related]) {
                        errors[related] = [];
                    }
                    errors[related].push(error.message);
                });
            });
            return errors;
        },
        'flat': function (normalizedErrors) {
            var errors = normalizedErrors.length > 0 ? [] : undefined;
            canReflect.eachIndex(normalizedErrors, function (error) {
                errors.push(error.message);
            });
            return errors;
        },
        'errors': function (normalizedErrors) {
            return normalizedErrors.length > 0 ? normalizedErrors : undefined;
        },
        'errors-object': function (normalizedErrors) {
            var errors = normalizedErrors.length > 0 ? {} : undefined;
            canReflect.eachIndex(normalizedErrors, function (error) {
                canReflect.eachIndex(error.related, function (related) {
                    if (!errors[related]) {
                        errors[related] = [];
                    }
                    errors[related].push(error);
                });
            });
            return errors;
        }
    };
    var parseErrorItem = function (rawErrors) {
        var errors = [];
        if (typeof rawErrors === 'string') {
            errors.push({
                message: rawErrors,
                related: ['*']
            });
        }
        if (typeof rawErrors === 'object' && !Array.isArray(rawErrors)) {
            if (rawErrors.related) {
                if (!Array.isArray(rawErrors.related)) {
                    rawErrors.related = [rawErrors.related];
                }
            } else {
                rawErrors.related = '*';
            }
            errors.push(rawErrors);
        }
        if (Array.isArray(rawErrors)) {
            canReflect.eachIndex(rawErrors, function (error) {
                [].push.apply(errors, parseErrorItem(error));
            });
        }
        return errors;
    };
    var normalizeErrors = function (rawErrors) {
        var normalizedErrors = [];
        if (typeof rawErrors === 'string' || typeof rawErrors === 'object' && !Array.isArray(rawErrors)) {
            rawErrors = [rawErrors];
        }
        if (rawErrors != null) {
            canReflect.eachIndex(rawErrors, function (error) {
                [].push.apply(normalizedErrors, parseErrorItem(error));
            });
        }
        return normalizedErrors;
    };
    validate.formatErrors = function (errors, format) {
        var normalized = normalizeErrors(errors);
        if (format) {
            if (helpers[format]) {
                return helpers[format](normalized);
            } else {
                return normalized;
            }
        } else {
            return normalized;
        }
    };
    module.exports = validate;
});
/*can-validate@1.1.3#test*/
define('can-validate@1.1.3#test', [
    'require',
    'exports',
    'module',
    'can-validate',
    'steal-qunit'
], function (require, exports, module) {
    var validate = require('can-validate');
    var QUnit = require('steal-qunit');
    var requireString = 'is required';
    var numberString = 'must be a number';
    var errorObject = [
        numberString,
        {
            message: requireString,
            related: ['name']
        },
        [
            requireString,
            {
                message: numberString,
                related: ['name']
            }
        ]
    ];
    QUnit.module('can-validate utilities');
    QUnit.test('fomarErrors does not throw with undefined', function (assert) {
        assert.deepEqual(validate.formatErrors(undefined), []);
    });
    QUnit.test('formatErrors to errors', function () {
        var errors = validate.formatErrors(errorObject);
        var expectedErrors = [
            {
                message: 'must be a number',
                related: ['*']
            },
            {
                message: 'is required',
                related: ['name']
            },
            {
                message: 'is required',
                related: ['*']
            },
            {
                'message': 'must be a number',
                related: ['name']
            }
        ];
        QUnit.deepEqual(errors, expectedErrors, 'errors object is converted to array of error types');
    });
    QUnit.test('formatErrors to flat', function () {
        var errors = validate.formatErrors(errorObject, 'flat');
        var expectedErrors = [
            'must be a number',
            'is required',
            'is required',
            'must be a number'
        ];
        QUnit.deepEqual(errors, expectedErrors, 'Converts errors to a list of strings');
    });
    QUnit.test('formatErrors to object', function () {
        var errors = validate.formatErrors(errorObject, 'object');
        var expectedErrors = {
            '*': [
                'must be a number',
                'is required'
            ],
            'name': [
                'is required',
                'must be a number'
            ]
        };
        QUnit.deepEqual(errors, expectedErrors, 'converts errors to object of strings');
    });
});
/*validate.js@0.11.1#validate*/
(function (exports, module, define) {
    'use strict';
    var validate = function (attributes, constraints, options) {
        options = v.extend({}, v.options, options);
        var results = v.runValidations(attributes, constraints, options), attr, validator;
        for (attr in results) {
            for (validator in results[attr]) {
                if (v.isPromise(results[attr][validator])) {
                    throw new Error('Use validate.async if you want support for promises');
                }
            }
        }
        return validate.processValidationResults(results, options);
    };
    var v = validate;
    v.extend = function (obj) {
        [].slice.call(arguments, 1).forEach(function (source) {
            for (var attr in source) {
                obj[attr] = source[attr];
            }
        });
        return obj;
    };
    v.extend(validate, {
        version: {
            major: 0,
            minor: 11,
            patch: 1,
            metadata: null,
            toString: function () {
                var version = v.format('%{major}.%{minor}.%{patch}', v.version);
                if (!v.isEmpty(v.version.metadata)) {
                    version += '+' + v.version.metadata;
                }
                return version;
            }
        },
        Promise: typeof Promise !== 'undefined' ? Promise : null,
        EMPTY_STRING_REGEXP: /^\s*$/,
        runValidations: function (attributes, constraints, options) {
            var results = [], attr, validatorName, value, validators, validator, validatorOptions, error;
            if (v.isDomElement(attributes) || v.isJqueryElement(attributes)) {
                attributes = v.collectFormValues(attributes);
            }
            for (attr in constraints) {
                value = v.getDeepObjectValue(attributes, attr);
                validators = v.result(constraints[attr], value, attributes, attr, options, constraints);
                for (validatorName in validators) {
                    validator = v.validators[validatorName];
                    if (!validator) {
                        error = v.format('Unknown validator %{name}', { name: validatorName });
                        throw new Error(error);
                    }
                    validatorOptions = validators[validatorName];
                    validatorOptions = v.result(validatorOptions, value, attributes, attr, options, constraints);
                    if (!validatorOptions) {
                        continue;
                    }
                    results.push({
                        attribute: attr,
                        value: value,
                        validator: validatorName,
                        globalOptions: options,
                        attributes: attributes,
                        options: validatorOptions,
                        error: validator.call(validator, value, validatorOptions, attr, attributes, options)
                    });
                }
            }
            return results;
        },
        processValidationResults: function (errors, options) {
            errors = v.pruneEmptyErrors(errors, options);
            errors = v.expandMultipleErrors(errors, options);
            errors = v.convertErrorMessages(errors, options);
            var format = options.format || 'grouped';
            if (typeof v.formatters[format] === 'function') {
                errors = v.formatters[format](errors);
            } else {
                throw new Error(v.format('Unknown format %{format}', options));
            }
            return v.isEmpty(errors) ? undefined : errors;
        },
        async: function (attributes, constraints, options) {
            options = v.extend({}, v.async.options, options);
            var WrapErrors = options.wrapErrors || function (errors) {
                return errors;
            };
            if (options.cleanAttributes !== false) {
                attributes = v.cleanAttributes(attributes, constraints);
            }
            var results = v.runValidations(attributes, constraints, options);
            return new v.Promise(function (resolve, reject) {
                v.waitForResults(results).then(function () {
                    var errors = v.processValidationResults(results, options);
                    if (errors) {
                        reject(new WrapErrors(errors, options, attributes, constraints));
                    } else {
                        resolve(attributes);
                    }
                }, function (err) {
                    reject(err);
                });
            });
        },
        single: function (value, constraints, options) {
            options = v.extend({}, v.single.options, options, {
                format: 'flat',
                fullMessages: false
            });
            return v({ single: value }, { single: constraints }, options);
        },
        waitForResults: function (results) {
            return results.reduce(function (memo, result) {
                if (!v.isPromise(result.error)) {
                    return memo;
                }
                return memo.then(function () {
                    return result.error.then(function (error) {
                        result.error = error || null;
                    });
                });
            }, new v.Promise(function (r) {
                r();
            }));
        },
        result: function (value) {
            var args = [].slice.call(arguments, 1);
            if (typeof value === 'function') {
                value = value.apply(null, args);
            }
            return value;
        },
        isNumber: function (value) {
            return typeof value === 'number' && !isNaN(value);
        },
        isFunction: function (value) {
            return typeof value === 'function';
        },
        isInteger: function (value) {
            return v.isNumber(value) && value % 1 === 0;
        },
        isBoolean: function (value) {
            return typeof value === 'boolean';
        },
        isObject: function (obj) {
            return obj === Object(obj);
        },
        isDate: function (obj) {
            return obj instanceof Date;
        },
        isDefined: function (obj) {
            return obj !== null && obj !== undefined;
        },
        isPromise: function (p) {
            return !!p && v.isFunction(p.then);
        },
        isJqueryElement: function (o) {
            return o && v.isString(o.jquery);
        },
        isDomElement: function (o) {
            if (!o) {
                return false;
            }
            if (!o.querySelectorAll || !o.querySelector) {
                return false;
            }
            if (v.isObject(document) && o === document) {
                return true;
            }
            if (typeof HTMLElement === 'object') {
                return o instanceof HTMLElement;
            } else {
                return o && typeof o === 'object' && o !== null && o.nodeType === 1 && typeof o.nodeName === 'string';
            }
        },
        isEmpty: function (value) {
            var attr;
            if (!v.isDefined(value)) {
                return true;
            }
            if (v.isFunction(value)) {
                return false;
            }
            if (v.isString(value)) {
                return v.EMPTY_STRING_REGEXP.test(value);
            }
            if (v.isArray(value)) {
                return value.length === 0;
            }
            if (v.isDate(value)) {
                return false;
            }
            if (v.isObject(value)) {
                for (attr in value) {
                    return false;
                }
                return true;
            }
            return false;
        },
        format: v.extend(function (str, vals) {
            if (!v.isString(str)) {
                return str;
            }
            return str.replace(v.format.FORMAT_REGEXP, function (m0, m1, m2) {
                if (m1 === '%') {
                    return '%{' + m2 + '}';
                } else {
                    return String(vals[m2]);
                }
            });
        }, { FORMAT_REGEXP: /(%?)%\{([^\}]+)\}/g }),
        prettify: function (str) {
            if (v.isNumber(str)) {
                if (str * 100 % 1 === 0) {
                    return '' + str;
                } else {
                    return parseFloat(Math.round(str * 100) / 100).toFixed(2);
                }
            }
            if (v.isArray(str)) {
                return str.map(function (s) {
                    return v.prettify(s);
                }).join(', ');
            }
            if (v.isObject(str)) {
                return str.toString();
            }
            str = '' + str;
            return str.replace(/([^\s])\.([^\s])/g, '$1 $2').replace(/\\+/g, '').replace(/[_-]/g, ' ').replace(/([a-z])([A-Z])/g, function (m0, m1, m2) {
                return '' + m1 + ' ' + m2.toLowerCase();
            }).toLowerCase();
        },
        stringifyValue: function (value) {
            return v.prettify(value);
        },
        isString: function (value) {
            return typeof value === 'string';
        },
        isArray: function (value) {
            return {}.toString.call(value) === '[object Array]';
        },
        isHash: function (value) {
            return v.isObject(value) && !v.isArray(value) && !v.isFunction(value);
        },
        contains: function (obj, value) {
            if (!v.isDefined(obj)) {
                return false;
            }
            if (v.isArray(obj)) {
                return obj.indexOf(value) !== -1;
            }
            return value in obj;
        },
        unique: function (array) {
            if (!v.isArray(array)) {
                return array;
            }
            return array.filter(function (el, index, array) {
                return array.indexOf(el) == index;
            });
        },
        forEachKeyInKeypath: function (object, keypath, callback) {
            if (!v.isString(keypath)) {
                return undefined;
            }
            var key = '', i, escape = false;
            for (i = 0; i < keypath.length; ++i) {
                switch (keypath[i]) {
                case '.':
                    if (escape) {
                        escape = false;
                        key += '.';
                    } else {
                        object = callback(object, key, false);
                        key = '';
                    }
                    break;
                case '\\':
                    if (escape) {
                        escape = false;
                        key += '\\';
                    } else {
                        escape = true;
                    }
                    break;
                default:
                    escape = false;
                    key += keypath[i];
                    break;
                }
            }
            return callback(object, key, true);
        },
        getDeepObjectValue: function (obj, keypath) {
            if (!v.isObject(obj)) {
                return undefined;
            }
            return v.forEachKeyInKeypath(obj, keypath, function (obj, key) {
                if (v.isObject(obj)) {
                    return obj[key];
                }
            });
        },
        collectFormValues: function (form, options) {
            var values = {}, i, j, input, inputs, option, value;
            if (v.isJqueryElement(form)) {
                form = form[0];
            }
            if (!form) {
                return values;
            }
            options = options || {};
            inputs = form.querySelectorAll('input[name], textarea[name]');
            for (i = 0; i < inputs.length; ++i) {
                input = inputs.item(i);
                if (v.isDefined(input.getAttribute('data-ignored'))) {
                    continue;
                }
                value = v.sanitizeFormValue(input.value, options);
                if (input.type === 'number') {
                    value = value ? +value : null;
                } else if (input.type === 'checkbox') {
                    if (input.attributes.value) {
                        if (!input.checked) {
                            value = values[input.name] || null;
                        }
                    } else {
                        value = input.checked;
                    }
                } else if (input.type === 'radio') {
                    if (!input.checked) {
                        value = values[input.name] || null;
                    }
                }
                values[input.name] = value;
            }
            inputs = form.querySelectorAll('select[name]');
            for (i = 0; i < inputs.length; ++i) {
                input = inputs.item(i);
                if (input.multiple) {
                    value = [];
                    for (j in input.options) {
                        option = input.options[j];
                        if (option.selected) {
                            value.push(v.sanitizeFormValue(option.value, options));
                        }
                    }
                } else {
                    value = v.sanitizeFormValue(input.options[input.selectedIndex].value, options);
                }
                values[input.name] = value;
            }
            return values;
        },
        sanitizeFormValue: function (value, options) {
            if (options.trim && v.isString(value)) {
                value = value.trim();
            }
            if (options.nullify !== false && value === '') {
                return null;
            }
            return value;
        },
        capitalize: function (str) {
            if (!v.isString(str)) {
                return str;
            }
            return str[0].toUpperCase() + str.slice(1);
        },
        pruneEmptyErrors: function (errors) {
            return errors.filter(function (error) {
                return !v.isEmpty(error.error);
            });
        },
        expandMultipleErrors: function (errors) {
            var ret = [];
            errors.forEach(function (error) {
                if (v.isArray(error.error)) {
                    error.error.forEach(function (msg) {
                        ret.push(v.extend({}, error, { error: msg }));
                    });
                } else {
                    ret.push(error);
                }
            });
            return ret;
        },
        convertErrorMessages: function (errors, options) {
            options = options || {};
            var ret = [];
            errors.forEach(function (errorInfo) {
                var error = v.result(errorInfo.error, errorInfo.value, errorInfo.attribute, errorInfo.options, errorInfo.attributes, errorInfo.globalOptions);
                if (!v.isString(error)) {
                    ret.push(errorInfo);
                    return;
                }
                if (error[0] === '^') {
                    error = error.slice(1);
                } else if (options.fullMessages !== false) {
                    error = v.capitalize(v.prettify(errorInfo.attribute)) + ' ' + error;
                }
                error = error.replace(/\\\^/g, '^');
                error = v.format(error, { value: v.stringifyValue(errorInfo.value) });
                ret.push(v.extend({}, errorInfo, { error: error }));
            });
            return ret;
        },
        groupErrorsByAttribute: function (errors) {
            var ret = {};
            errors.forEach(function (error) {
                var list = ret[error.attribute];
                if (list) {
                    list.push(error);
                } else {
                    ret[error.attribute] = [error];
                }
            });
            return ret;
        },
        flattenErrorsToArray: function (errors) {
            return errors.map(function (error) {
                return error.error;
            }).filter(function (value, index, self) {
                return self.indexOf(value) === index;
            });
        },
        cleanAttributes: function (attributes, whitelist) {
            function whitelistCreator(obj, key, last) {
                if (v.isObject(obj[key])) {
                    return obj[key];
                }
                return obj[key] = last ? true : {};
            }
            function buildObjectWhitelist(whitelist) {
                var ow = {}, lastObject, attr;
                for (attr in whitelist) {
                    if (!whitelist[attr]) {
                        continue;
                    }
                    v.forEachKeyInKeypath(ow, attr, whitelistCreator);
                }
                return ow;
            }
            function cleanRecursive(attributes, whitelist) {
                if (!v.isObject(attributes)) {
                    return attributes;
                }
                var ret = v.extend({}, attributes), w, attribute;
                for (attribute in attributes) {
                    w = whitelist[attribute];
                    if (v.isObject(w)) {
                        ret[attribute] = cleanRecursive(ret[attribute], w);
                    } else if (!w) {
                        delete ret[attribute];
                    }
                }
                return ret;
            }
            if (!v.isObject(whitelist) || !v.isObject(attributes)) {
                return {};
            }
            whitelist = buildObjectWhitelist(whitelist);
            return cleanRecursive(attributes, whitelist);
        },
        exposeModule: function (validate, root, exports, module, define) {
            if (exports) {
                if (module && module.exports) {
                    exports = module.exports = validate;
                }
                exports.validate = validate;
            } else {
                root.validate = validate;
                if (validate.isFunction(define) && define.amd) {
                    define('validate.js@0.11.1#validate', [], function () {
                        return validate;
                    });
                }
            }
        },
        warn: function (msg) {
            if (typeof console !== 'undefined' && console.warn) {
                console.warn('[validate.js] ' + msg);
            }
        },
        error: function (msg) {
            if (typeof console !== 'undefined' && console.error) {
                console.error('[validate.js] ' + msg);
            }
        }
    });
    validate.validators = {
        presence: function (value, options) {
            options = v.extend({}, this.options, options);
            if (options.allowEmpty ? !v.isDefined(value) : v.isEmpty(value)) {
                return options.message || this.message || 'can\'t be blank';
            }
        },
        length: function (value, options, attribute) {
            if (!v.isDefined(value)) {
                return;
            }
            options = v.extend({}, this.options, options);
            var is = options.is, maximum = options.maximum, minimum = options.minimum, tokenizer = options.tokenizer || function (val) {
                    return val;
                }, err, errors = [];
            value = tokenizer(value);
            var length = value.length;
            if (!v.isNumber(length)) {
                v.error(v.format('Attribute %{attr} has a non numeric value for `length`', { attr: attribute }));
                return options.message || this.notValid || 'has an incorrect length';
            }
            if (v.isNumber(is) && length !== is) {
                err = options.wrongLength || this.wrongLength || 'is the wrong length (should be %{count} characters)';
                errors.push(v.format(err, { count: is }));
            }
            if (v.isNumber(minimum) && length < minimum) {
                err = options.tooShort || this.tooShort || 'is too short (minimum is %{count} characters)';
                errors.push(v.format(err, { count: minimum }));
            }
            if (v.isNumber(maximum) && length > maximum) {
                err = options.tooLong || this.tooLong || 'is too long (maximum is %{count} characters)';
                errors.push(v.format(err, { count: maximum }));
            }
            if (errors.length > 0) {
                return options.message || errors;
            }
        },
        numericality: function (value, options) {
            if (!v.isDefined(value)) {
                return;
            }
            options = v.extend({}, this.options, options);
            var errors = [], name, count, checks = {
                    greaterThan: function (v, c) {
                        return v > c;
                    },
                    greaterThanOrEqualTo: function (v, c) {
                        return v >= c;
                    },
                    equalTo: function (v, c) {
                        return v === c;
                    },
                    lessThan: function (v, c) {
                        return v < c;
                    },
                    lessThanOrEqualTo: function (v, c) {
                        return v <= c;
                    },
                    divisibleBy: function (v, c) {
                        return v % c === 0;
                    }
                };
            if (v.isString(value) && options.strict) {
                var pattern = '^(0|[1-9]\\d*)';
                if (!options.onlyInteger) {
                    pattern += '(\\.\\d+)?';
                }
                pattern += '$';
                if (!new RegExp(pattern).test(value)) {
                    return options.message || options.notValid || this.notValid || this.message || 'must be a valid number';
                }
            }
            if (options.noStrings !== true && v.isString(value) && !v.isEmpty(value)) {
                value = +value;
            }
            if (!v.isNumber(value)) {
                return options.message || options.notValid || this.notValid || this.message || 'is not a number';
            }
            if (options.onlyInteger && !v.isInteger(value)) {
                return options.message || options.notInteger || this.notInteger || this.message || 'must be an integer';
            }
            for (name in checks) {
                count = options[name];
                if (v.isNumber(count) && !checks[name](value, count)) {
                    var key = 'not' + v.capitalize(name);
                    var msg = options[key] || this[key] || this.message || 'must be %{type} %{count}';
                    errors.push(v.format(msg, {
                        count: count,
                        type: v.prettify(name)
                    }));
                }
            }
            if (options.odd && value % 2 !== 1) {
                errors.push(options.notOdd || this.notOdd || this.message || 'must be odd');
            }
            if (options.even && value % 2 !== 0) {
                errors.push(options.notEven || this.notEven || this.message || 'must be even');
            }
            if (errors.length) {
                return options.message || errors;
            }
        },
        datetime: v.extend(function (value, options) {
            if (!v.isFunction(this.parse) || !v.isFunction(this.format)) {
                throw new Error('Both the parse and format functions needs to be set to use the datetime/date validator');
            }
            if (!v.isDefined(value)) {
                return;
            }
            options = v.extend({}, this.options, options);
            var err, errors = [], earliest = options.earliest ? this.parse(options.earliest, options) : NaN, latest = options.latest ? this.parse(options.latest, options) : NaN;
            value = this.parse(value, options);
            if (isNaN(value) || options.dateOnly && value % 86400000 !== 0) {
                err = options.notValid || options.message || this.notValid || 'must be a valid date';
                return v.format(err, { value: arguments[0] });
            }
            if (!isNaN(earliest) && value < earliest) {
                err = options.tooEarly || options.message || this.tooEarly || 'must be no earlier than %{date}';
                err = v.format(err, {
                    value: this.format(value, options),
                    date: this.format(earliest, options)
                });
                errors.push(err);
            }
            if (!isNaN(latest) && value > latest) {
                err = options.tooLate || options.message || this.tooLate || 'must be no later than %{date}';
                err = v.format(err, {
                    date: this.format(latest, options),
                    value: this.format(value, options)
                });
                errors.push(err);
            }
            if (errors.length) {
                return v.unique(errors);
            }
        }, {
            parse: null,
            format: null
        }),
        date: function (value, options) {
            options = v.extend({}, options, { dateOnly: true });
            return v.validators.datetime.call(v.validators.datetime, value, options);
        },
        format: function (value, options) {
            if (v.isString(options) || options instanceof RegExp) {
                options = { pattern: options };
            }
            options = v.extend({}, this.options, options);
            var message = options.message || this.message || 'is invalid', pattern = options.pattern, match;
            if (!v.isDefined(value)) {
                return;
            }
            if (!v.isString(value)) {
                return message;
            }
            if (v.isString(pattern)) {
                pattern = new RegExp(options.pattern, options.flags);
            }
            match = pattern.exec(value);
            if (!match || match[0].length != value.length) {
                return message;
            }
        },
        inclusion: function (value, options) {
            if (!v.isDefined(value)) {
                return;
            }
            if (v.isArray(options)) {
                options = { within: options };
            }
            options = v.extend({}, this.options, options);
            if (v.contains(options.within, value)) {
                return;
            }
            var message = options.message || this.message || '^%{value} is not included in the list';
            return v.format(message, { value: value });
        },
        exclusion: function (value, options) {
            if (!v.isDefined(value)) {
                return;
            }
            if (v.isArray(options)) {
                options = { within: options };
            }
            options = v.extend({}, this.options, options);
            if (!v.contains(options.within, value)) {
                return;
            }
            var message = options.message || this.message || '^%{value} is restricted';
            return v.format(message, { value: value });
        },
        email: v.extend(function (value, options) {
            options = v.extend({}, this.options, options);
            var message = options.message || this.message || 'is not a valid email';
            if (!v.isDefined(value)) {
                return;
            }
            if (!v.isString(value)) {
                return message;
            }
            if (!this.PATTERN.exec(value)) {
                return message;
            }
        }, { PATTERN: /^[a-z0-9\u007F-\uffff!#$%&'*+\/=?^_`{|}~-]+(?:\.[a-z0-9\u007F-\uffff!#$%&'*+\/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z]{2,}$/i }),
        equality: function (value, options, attribute, attributes) {
            if (!v.isDefined(value)) {
                return;
            }
            if (v.isString(options)) {
                options = { attribute: options };
            }
            options = v.extend({}, this.options, options);
            var message = options.message || this.message || 'is not equal to %{attribute}';
            if (v.isEmpty(options.attribute) || !v.isString(options.attribute)) {
                throw new Error('The attribute must be a non empty string');
            }
            var otherValue = v.getDeepObjectValue(attributes, options.attribute), comparator = options.comparator || function (v1, v2) {
                    return v1 === v2;
                };
            if (!comparator(value, otherValue, options, attribute, attributes)) {
                return v.format(message, { attribute: v.prettify(options.attribute) });
            }
        },
        url: function (value, options) {
            if (!v.isDefined(value)) {
                return;
            }
            options = v.extend({}, this.options, options);
            var message = options.message || this.message || 'is not a valid url', schemes = options.schemes || this.schemes || [
                    'http',
                    'https'
                ], allowLocal = options.allowLocal || this.allowLocal || false;
            if (!v.isString(value)) {
                return message;
            }
            var regex = '^' + '(?:(?:' + schemes.join('|') + ')://)' + '(?:\\S+(?::\\S*)?@)?' + '(?:';
            var tld = '(?:\\.(?:[a-z\\u00a1-\\uffff]{2,}))';
            if (allowLocal) {
                tld += '?';
            } else {
                regex += '(?!(?:10|127)(?:\\.\\d{1,3}){3})' + '(?!(?:169\\.254|192\\.168)(?:\\.\\d{1,3}){2})' + '(?!172\\.(?:1[6-9]|2\\d|3[0-1])(?:\\.\\d{1,3}){2})';
            }
            regex += '(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])' + '(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}' + '(?:\\.(?:[1-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))' + '|' + '(?:(?:[a-z\\u00a1-\\uffff0-9]-*)*[a-z\\u00a1-\\uffff0-9]+)' + '(?:\\.(?:[a-z\\u00a1-\\uffff0-9]-*)*[a-z\\u00a1-\\uffff0-9]+)*' + tld + ')' + '(?::\\d{2,5})?' + '(?:[/?#]\\S*)?' + '$';
            var PATTERN = new RegExp(regex, 'i');
            if (!PATTERN.exec(value)) {
                return message;
            }
        }
    };
    validate.formatters = {
        detailed: function (errors) {
            return errors;
        },
        flat: v.flattenErrorsToArray,
        grouped: function (errors) {
            var attr;
            errors = v.groupErrorsByAttribute(errors);
            for (attr in errors) {
                errors[attr] = v.flattenErrorsToArray(errors[attr]);
            }
            return errors;
        },
        constraint: function (errors) {
            var attr;
            errors = v.groupErrorsByAttribute(errors);
            for (attr in errors) {
                errors[attr] = errors[attr].map(function (result) {
                    return result.validator;
                }).sort();
            }
            return errors;
        }
    };
    validate.exposeModule(validate, this, exports, module, define);
}.call(this, typeof exports !== 'undefined' ? exports : null, typeof module !== 'undefined' ? module : null, typeof define !== 'undefined' ? define : null));
/*can-validate-validatejs@0.1.2#can-validate-validatejs*/
define('can-validate-validatejs@0.1.2#can-validate-validatejs', [
    'require',
    'exports',
    'module',
    'can-reflect',
    'validate.js'
], function (require, exports, module) {
    var canReflect = require('can-reflect');
    var validatejs = require('validate.js');
    var makeValidator = function (constraints) {
        return function (value) {
            return validatejs.single(value, constraints);
        };
    };
    makeValidator.many = function (constraints) {
        return function (values) {
            var rawErrors = validatejs(values, constraints, {
                format: 'detailed',
                fullMessages: false
            });
            var errors;
            if (rawErrors) {
                errors = [];
                canReflect.eachIndex(rawErrors, function (error) {
                    errors.push({
                        message: error.options.message || error.error,
                        related: [error.attribute]
                    });
                });
            }
            return errors;
        };
    };
    makeValidator.validatejs = validatejs;
    module.exports = makeValidator;
});
/*can-validate-validatejs@0.1.2#test*/
define('can-validate-validatejs@0.1.2#test', [
    'require',
    'exports',
    'module',
    'steal-qunit',
    'can-validate-validatejs'
], function (require, exports, module) {
    var QUnit = require('steal-qunit');
    var makeValidator = require('can-validate-validatejs');
    var constraints = {
        age: { numericality: { message: 'should be a number' } },
        name: { presence: { message: 'cannot be blank' } }
    };
    var invalidPerson = {
        name: '',
        age: 'hello'
    };
    var validPerson = {
        name: 'Juan',
        age: 35
    };
    QUnit.module('can-validate-validatejs');
    QUnit.test('makeValidator sets errors', function () {
        var validateAge = makeValidator(constraints.age);
        var errors = validateAge(invalidPerson.age);
        var expectedErrors = [constraints.age.numericality.message];
        QUnit.deepEqual(errors, expectedErrors, 'returns expected errors object');
    });
    QUnit.test('makeValidator validates', function () {
        var validateAge = makeValidator(constraints.age);
        var errors = validateAge(validPerson.age);
        QUnit.notOk(errors, 'value is valid, so no errors return');
    });
    QUnit.test('makeValidator.many sets errors', function () {
        var validatePerson = makeValidator.many(constraints);
        var errors = validatePerson(invalidPerson);
        var expectedErrors = [
            {
                message: constraints.age.numericality.message,
                related: ['age']
            },
            {
                message: constraints.name.presence.message,
                related: ['name']
            }
        ];
        QUnit.deepEqual(errors, expectedErrors, 'Many errors are set');
    });
    QUnit.test('makeValidator.many validates', function () {
        var validatePerson = makeValidator.many(constraints);
        var errors = validatePerson(validPerson);
        QUnit.notOk(errors, 'values are valid, so no errors return');
    });
});
/*can-define-validate-validatejs@1.0.0#can-define-validate-validatejs*/
define('can-define-validate-validatejs@1.0.0#can-define-validate-validatejs', [
    'require',
    'exports',
    'module',
    'can-validate-validatejs',
    'can-define',
    'can-assign',
    'can-reflect',
    'can-validate',
    'can-util/js/is-empty-object/is-empty-object'
], function (require, exports, module) {
    var validate = require('can-validate-validatejs');
    var define = require('can-define');
    var assign = require('can-assign');
    var canReflect = require('can-reflect');
    var formatErrors = require('can-validate').formatErrors;
    var isEmptyObject = require('can-util/js/is-empty-object/is-empty-object');
    var getMapConstraints = function (Map) {
        var constraints = {};
        canReflect.eachKey(Map.prototype._define.definitions, function (prop, key) {
            if (prop.validate && !isEmptyObject(prop.validate)) {
                constraints[key] = prop.validate;
            }
        });
        return constraints;
    };
    var validateMap = function (Map, validator) {
        var mapDefinition = Map.prototype._define;
        Map.prototype.testSet = function () {
            var values = {};
            var useNewObject = false;
            if (arguments.length) {
                if (typeof arguments[0] === 'object' && Boolean(arguments[0])) {
                    values = arguments[0];
                    useNewObject = Boolean(arguments[1]);
                }
                if (typeof arguments[0] === 'string') {
                    values[arguments[0]] = arguments[1];
                }
                if (useNewObject) {
                    values = new Map(values);
                } else {
                    var mapClone = this.serialize();
                    assign(mapClone, values);
                    values = mapClone;
                }
                return validator(values);
            } else {
                return this.errors();
            }
        };
        Map.prototype.errors = function () {
            var _errors = this._errors;
            var errors;
            if (arguments.length) {
                var errorsObj = formatErrors(_errors, 'errors-object');
                errors = [];
                canReflect.eachIndex(arguments, function (key) {
                    [].push.apply(errors, errorsObj ? errorsObj[key] : []);
                });
                errors = errors.length > 0 ? errors : undefined;
            } else {
                errors = _errors;
            }
            return errors;
        };
        define.property(Map.prototype, '_errors', {
            get: function () {
                var errors = validator(this);
                return errors;
            }
        }, mapDefinition.dataInitializers, mapDefinition.computedInitializers);
    };
    var decorator = function (Map) {
        var constraints = getMapConstraints(Map);
        var validator = validate.many(constraints);
        validateMap(Map, function (map) {
            var errors = validator(map);
            return formatErrors(errors, 'errors');
        });
    };
    decorator.validatejs = validate.validatejs;
    module.exports = decorator;
});
/*can-define-validate-validatejs@1.0.0#test*/
define('can-define-validate-validatejs@1.0.0#test', [
    'require',
    'exports',
    'module',
    'can-define-validate-validatejs',
    'steal-qunit',
    'can-define/map/map',
    'can-compute'
], function (require, exports, module) {
    var defineValidate = require('can-define-validate-validatejs');
    var QUnit = require('steal-qunit');
    var DefineMap = require('can-define/map/map');
    var compute = require('can-compute');
    var NoConstraints = DefineMap.extend({ name: 'string' });
    var Locator = DefineMap.extend({
        city: { validate: { presence: true } },
        state: {
            validate: {
                presence: true,
                format: /\w\w/
            }
        },
        zipCode: {
            validate: {
                presence: true,
                numericality: true
            }
        }
    });
    defineValidate(Locator);
    defineValidate(NoConstraints);
    QUnit.module('can-define-validate-validatejs');
    QUnit.test('when constraints missing', function () {
        var locator = new NoConstraints();
        QUnit.notOk(locator.errors(), 'runs but returns no errors');
    });
    QUnit.test('errors is readable when wrapped as compute', function () {
        var locator = new Locator({
            city: 'angier',
            state: 'NC'
        });
        var errors = compute(function () {
            return locator.errors();
        });
        var expectedErrors = [
            {
                message: 'is invalid',
                related: ['state']
            },
            {
                message: 'can\'t be blank',
                related: ['zipCode']
            }
        ];
        errors.on('change', function (ev, errors) {
            QUnit.deepEqual(errors, expectedErrors, 'Errors are set based on constraints');
        });
        locator.state = 'Juan';
    });
    QUnit.test('errors is readable when wrapped as compute', function () {
        var locator = new Locator({
            city: 'angier',
            state: 'NC',
            zipCode: 27501
        });
        var errors = compute(function () {
            return locator.errors();
        });
        var counter = 0;
        errors.on('change', function (ev, errors) {
            if (counter > 0) {
                QUnit.notOk(errors, 'Errors update when values change');
            }
            counter++;
        });
        locator.state = 'Juan';
        locator.state = 'CA';
    });
    QUnit.test('calling errors returns object', function () {
        var locator = new Locator({ city: 'angier' });
        var expectedErrors = [
            {
                message: 'can\'t be blank',
                related: ['state']
            },
            {
                message: 'can\'t be blank',
                related: ['zipCode']
            }
        ];
        QUnit.deepEqual(locator.errors(), expectedErrors, 'Returns error type array');
    });
    QUnit.test('calling errors with string returns error for that key', function () {
        var locator = new Locator({ city: 'angier' });
        var errors = locator.errors('state');
        QUnit.deepEqual(errors, [{
                message: 'can\'t be blank',
                related: ['state']
            }]);
    });
    QUnit.test('calling errors with string returns undefined when no errors are set', function () {
        var locator = new Locator({
            city: 'angier',
            state: 'NC',
            zipCode: 27501
        });
        var errors = locator.errors('state');
        QUnit.notOk(errors, 'Errors is undefined');
    });
    QUnit.test('errors with object returns errors for requested keys', function () {
        var locator = new Locator({ city: 'angier' });
        var expectedErrors = [
            {
                message: 'can\'t be blank',
                related: ['state']
            },
            {
                message: 'can\'t be blank',
                related: ['zipCode']
            }
        ];
        QUnit.deepEqual(locator.errors('state', 'zipCode'), expectedErrors);
    });
    QUnit.test('testSet a single value', function () {
        var locator = new Locator({
            city: 'angier',
            state: 'nc',
            zipCode: 27501
        });
        var expectedErrors = [
            {
                message: 'can\'t be blank',
                related: ['state']
            },
            {
                message: 'is invalid',
                related: ['state']
            }
        ];
        var errors = locator.testSet('state', '');
        QUnit.deepEqual(errors, expectedErrors, 'returns correct error');
        QUnit.notOk(locator.errors(), 'Does not set errors on map');
    });
    QUnit.test('testSet many values', function () {
        var locator = new Locator({
            city: 'angier',
            state: 'nc',
            zipCode: 27501
        });
        var errors = locator.testSet({
            state: '',
            zipCode: ''
        });
        var expectedErrors = [
            {
                message: 'can\'t be blank',
                related: ['state']
            },
            {
                message: 'is invalid',
                related: ['state']
            },
            {
                message: 'can\'t be blank',
                related: ['zipCode']
            },
            {
                message: 'is not a number',
                related: ['zipCode']
            }
        ];
        QUnit.deepEqual(errors, expectedErrors, 'returns correct error');
        QUnit.notOk(locator.errors(), 'Does not set errors on map');
    });
    QUnit.test('testSet many values, with clean map', function () {
        var locator = new Locator({
            city: 'angier',
            state: 'nc',
            zipCode: 27501
        });
        var errors = locator.testSet({ state: '' }, true);
        var expectedErrors = [
            {
                message: 'can\'t be blank',
                related: ['city']
            },
            {
                message: 'can\'t be blank',
                related: ['state']
            },
            {
                message: 'is invalid',
                related: ['state']
            },
            {
                message: 'can\'t be blank',
                related: ['zipCode']
            }
        ];
        QUnit.deepEqual(errors, expectedErrors, 'returns correct error');
        QUnit.notOk(locator.errors(), 'Does not set errors on map');
    });
});
/*can-view-autorender@4.0.0#can-view-autorender_test*/
define('can-view-autorender@4.0.0#can-view-autorender_test', [
    'require',
    'exports',
    'module',
    'steal-qunit'
], function (require, exports, module) {
    (function (__dirname, require, exports, module) {
        var QUnit = require('steal-qunit');
        var makeIframe = function (src) {
            var iframe = document.createElement('iframe');
            window.removeMyself = function () {
                delete window.removeMyself;
                delete window.isReady;
                delete window.hasError;
                document.body.removeChild(iframe);
                start();
            };
            window.hasError = function (error) {
                ok(false, error.message || error);
                window.removeMyself();
            };
            document.body.appendChild(iframe);
            iframe.src = src;
        };
        var get = function (map, prop) {
            return map.attr ? map.attr(prop) : map.get(prop);
        };
        var makeBasicTestIframe = function (src) {
            var iframe = document.createElement('iframe');
            window.removeMyself = function () {
                delete window.removeMyself;
                delete window.isReady;
                delete window.hasError;
                document.body.removeChild(iframe);
                start();
            };
            window.hasError = function (error) {
                ok(false, error.message || error);
                window.removeMyself();
            };
            window.isReady = function (el, scope) {
                equal(el.length, 1, 'only one my-component');
                equal(el[0].innerHTML, 'Hello World', 'template rendered');
                equal(get(scope, 'message'), 'Hello World', 'Scope correctly setup');
                window.removeMyself();
            };
            document.body.appendChild(iframe);
            iframe.src = src;
        };
        QUnit.module('can-view-autorender');
        if (__dirname !== '/') {
            QUnit.asyncTest('the basics are able to work for steal', function () {
                makeBasicTestIframe(__dirname + '/test/basics.html?' + Math.random());
            });
            QUnit.asyncTest('autoload loads a jquery viewmodel fn', function () {
                makeIframe(__dirname + '/test/steal-viewmodel.html?' + Math.random());
            });
            QUnit.asyncTest('works with a can-define/map/map', function () {
                makeBasicTestIframe(__dirname + '/test/define.html?' + Math.random());
            });
        }
    }('/', require, exports, module));
});
/*can-view-autorender@4.0.0#test/test*/
define('can-view-autorender@4.0.0#test/test', ['../can-view-autorender_test'], function () {
    'use strict';
});
/*syn@0.13.0#synthetic*/
define('syn@0.13.0#synthetic', function (require, exports, module) {
    var opts = window.syn ? window.syn : {};
    var extend = function (d, s) {
            var p;
            for (p in s) {
                d[p] = s[p];
            }
            return d;
        }, browser = {
            msie: !!(window.attachEvent && !window.opera) || navigator.userAgent.indexOf('Trident/') > -1,
            opera: !!window.opera,
            webkit: navigator.userAgent.indexOf('AppleWebKit/') > -1,
            safari: navigator.userAgent.indexOf('AppleWebKit/') > -1 && navigator.userAgent.indexOf('Chrome/') === -1,
            gecko: navigator.userAgent.indexOf('Gecko') > -1,
            mobilesafari: !!navigator.userAgent.match(/Apple.*Mobile.*Safari/),
            rhino: navigator.userAgent.match(/Rhino/) && true
        }, createEventObject = function (type, options, element) {
            var event = element.ownerDocument.createEventObject();
            return extend(event, options);
        }, data = {}, id = 1, expando = '_synthetic' + new Date().getTime(), bind, unbind, schedule, key = /keypress|keyup|keydown/, page = /load|unload|abort|error|select|change|submit|reset|focus|blur|resize|scroll/, activeElement, syn = function (type, element, options, callback) {
            return new syn.init(type, element, options, callback);
        };
    syn.config = opts;
    syn.__tryFocus = function tryFocus(element) {
        try {
            element.focus();
        } catch (e) {
        }
    };
    bind = function (el, ev, f) {
        return el.addEventListener ? el.addEventListener(ev, f, false) : el.attachEvent('on' + ev, f);
    };
    unbind = function (el, ev, f) {
        return el.addEventListener ? el.removeEventListener(ev, f, false) : el.detachEvent('on' + ev, f);
    };
    schedule = syn.config.schedule || function (fn, ms) {
        setTimeout(fn, ms);
    };
    extend(syn, {
        init: function (type, element, options, callback) {
            var args = syn.args(options, element, callback), self = this;
            this.queue = [];
            this.element = args.element;
            if (typeof this[type] === 'function') {
                this[type](args.element, args.options, function (defaults, el) {
                    if (args.callback) {
                        args.callback.apply(self, arguments);
                    }
                    self.done.apply(self, arguments);
                });
            } else {
                this.result = syn.trigger(args.element, type, args.options);
                if (args.callback) {
                    args.callback.call(this, args.element, this.result);
                }
            }
        },
        jquery: function (el, fast) {
            if (window.FuncUnit && window.FuncUnit.jQuery) {
                return window.FuncUnit.jQuery;
            }
            if (el) {
                return syn.helpers.getWindow(el).jQuery || window.jQuery;
            } else {
                return window.jQuery;
            }
        },
        args: function () {
            var res = {}, i = 0;
            for (; i < arguments.length; i++) {
                if (typeof arguments[i] === 'function') {
                    res.callback = arguments[i];
                } else if (arguments[i] && arguments[i].jquery) {
                    res.element = arguments[i][0];
                } else if (arguments[i] && arguments[i].nodeName) {
                    res.element = arguments[i];
                } else if (res.options && typeof arguments[i] === 'string') {
                    res.element = document.getElementById(arguments[i]);
                } else if (arguments[i]) {
                    res.options = arguments[i];
                }
            }
            return res;
        },
        click: function (element, options, callback) {
            syn('click!', element, options, callback);
        },
        defaults: {
            focus: function focus() {
                if (!syn.support.focusChanges) {
                    var element = this, nodeName = element.nodeName.toLowerCase();
                    syn.data(element, 'syntheticvalue', element.value);
                    if (nodeName === 'input' || nodeName === 'textarea') {
                        bind(element, 'blur', function blur() {
                            if (syn.data(element, 'syntheticvalue') !== element.value) {
                                syn.trigger(element, 'change', {});
                            }
                            unbind(element, 'blur', blur);
                        });
                    }
                }
            },
            submit: function () {
                syn.onParents(this, function (el) {
                    if (el.nodeName.toLowerCase() === 'form') {
                        el.submit();
                        return false;
                    }
                });
            }
        },
        changeOnBlur: function (element, prop, value) {
            bind(element, 'blur', function onblur() {
                if (value !== element[prop]) {
                    syn.trigger(element, 'change', {});
                }
                unbind(element, 'blur', onblur);
            });
        },
        closest: function (el, type) {
            while (el && el.nodeName.toLowerCase() !== type.toLowerCase()) {
                el = el.parentNode;
            }
            return el;
        },
        data: function (el, key, value) {
            var d;
            if (!el[expando]) {
                el[expando] = id++;
            }
            if (!data[el[expando]]) {
                data[el[expando]] = {};
            }
            d = data[el[expando]];
            if (value) {
                data[el[expando]][key] = value;
            } else {
                return data[el[expando]][key];
            }
        },
        onParents: function (el, func) {
            var res;
            while (el && res !== false) {
                res = func(el);
                el = el.parentNode;
            }
            return el;
        },
        focusable: /^(a|area|frame|iframe|label|input|select|textarea|button|html|object)$/i,
        isFocusable: function (elem) {
            var attributeNode;
            if (elem.getAttributeNode) {
                attributeNode = elem.getAttributeNode('tabIndex');
            }
            return this.focusable.test(elem.nodeName) || attributeNode && attributeNode.specified && syn.isVisible(elem);
        },
        isVisible: function (elem) {
            return elem.offsetWidth && elem.offsetHeight || elem.clientWidth && elem.clientHeight;
        },
        tabIndex: function (elem) {
            var attributeNode = elem.getAttributeNode('tabIndex');
            return attributeNode && attributeNode.specified && (parseInt(elem.getAttribute('tabIndex')) || 0);
        },
        bind: bind,
        unbind: unbind,
        schedule: schedule,
        browser: browser,
        helpers: {
            createEventObject: createEventObject,
            createBasicStandardEvent: function (type, defaults, doc) {
                var event;
                try {
                    event = doc.createEvent('Events');
                } catch (e2) {
                    event = doc.createEvent('UIEvents');
                } finally {
                    event.initEvent(type, true, true);
                    extend(event, defaults);
                }
                return event;
            },
            inArray: function (item, array) {
                var i = 0;
                for (; i < array.length; i++) {
                    if (array[i] === item) {
                        return i;
                    }
                }
                return -1;
            },
            getWindow: function (element) {
                if (element.ownerDocument) {
                    return element.ownerDocument.defaultView || element.ownerDocument.parentWindow;
                }
            },
            extend: extend,
            scrollOffset: function (win, set) {
                var doc = win.document.documentElement, body = win.document.body;
                if (set) {
                    window.scrollTo(set.left, set.top);
                } else {
                    return {
                        left: (doc && doc.scrollLeft || body && body.scrollLeft || 0) + (doc.clientLeft || 0),
                        top: (doc && doc.scrollTop || body && body.scrollTop || 0) + (doc.clientTop || 0)
                    };
                }
            },
            scrollDimensions: function (win) {
                var doc = win.document.documentElement, body = win.document.body, docWidth = doc.clientWidth, docHeight = doc.clientHeight, compat = win.document.compatMode === 'CSS1Compat';
                return {
                    height: compat && docHeight || body.clientHeight || docHeight,
                    width: compat && docWidth || body.clientWidth || docWidth
                };
            },
            addOffset: function (options, el) {
                var jq = syn.jquery(el), off;
                if (typeof options === 'object' && options.clientX === undefined && options.clientY === undefined && options.pageX === undefined && options.pageY === undefined && jq) {
                    el = jq(el);
                    off = el.offset();
                    options.pageX = off.left + el.width() / 2;
                    options.pageY = off.top + el.height() / 2;
                }
            }
        },
        key: {
            ctrlKey: null,
            altKey: null,
            shiftKey: null,
            metaKey: null
        },
        dispatch: function (event, element, type, autoPrevent) {
            if (element.dispatchEvent && event) {
                var preventDefault = event.preventDefault, prevents = autoPrevent ? -1 : 0;
                if (autoPrevent) {
                    bind(element, type, function ontype(ev) {
                        ev.preventDefault();
                        unbind(this, type, ontype);
                    });
                }
                event.preventDefault = function () {
                    prevents++;
                    if (++prevents > 0) {
                        preventDefault.apply(this, []);
                    }
                };
                element.dispatchEvent(event);
                return prevents <= 0;
            } else {
                try {
                    window.event = event;
                } catch (e) {
                }
                return element.sourceIndex <= 0 || element.fireEvent && element.fireEvent('on' + type, event);
            }
        },
        create: {
            page: {
                event: function (type, options, element) {
                    var doc = syn.helpers.getWindow(element).document || document, event;
                    if (doc.createEvent) {
                        event = doc.createEvent('Events');
                        event.initEvent(type, true, true);
                        return event;
                    } else {
                        try {
                            event = createEventObject(type, options, element);
                        } catch (e) {
                        }
                        return event;
                    }
                }
            },
            focus: {
                event: function (type, options, element) {
                    syn.onParents(element, function (el) {
                        if (syn.isFocusable(el)) {
                            if (el.nodeName.toLowerCase() !== 'html') {
                                syn.__tryFocus(el);
                                activeElement = el;
                            } else if (activeElement) {
                                var doc = syn.helpers.getWindow(element).document;
                                if (doc !== window.document) {
                                    return false;
                                } else if (doc.activeElement) {
                                    doc.activeElement.blur();
                                    activeElement = null;
                                } else {
                                    activeElement.blur();
                                    activeElement = null;
                                }
                            }
                            return false;
                        }
                    });
                    return true;
                }
            }
        },
        support: {
            clickChanges: false,
            clickSubmits: false,
            keypressSubmits: false,
            mouseupSubmits: false,
            radioClickChanges: false,
            focusChanges: false,
            linkHrefJS: false,
            keyCharacters: false,
            backspaceWorks: false,
            mouseDownUpClicks: false,
            tabKeyTabs: false,
            keypressOnAnchorClicks: false,
            optionClickBubbles: false,
            pointerEvents: false,
            touchEvents: false,
            ready: 0
        },
        trigger: function (element, type, options) {
            if (!options) {
                options = {};
            }
            var create = syn.create, setup = create[type] && create[type].setup, kind = key.test(type) ? 'key' : page.test(type) ? 'page' : 'mouse', createType = create[type] || {}, createKind = create[kind], event, ret, autoPrevent, dispatchEl = element;
            if (syn.support.ready === 2 && setup) {
                setup(type, options, element);
            }
            autoPrevent = options._autoPrevent;
            delete options._autoPrevent;
            if (createType.event) {
                ret = createType.event(type, options, element);
            } else {
                options = createKind.options ? createKind.options(type, options, element) : options;
                if (!syn.support.changeBubbles && /option/i.test(element.nodeName)) {
                    dispatchEl = element.parentNode;
                }
                event = createKind.event(type, options, dispatchEl);
                ret = syn.dispatch(event, dispatchEl, type, autoPrevent);
            }
            if (ret && syn.support.ready === 2 && syn.defaults[type]) {
                syn.defaults[type].call(element, options, autoPrevent);
            }
            return ret;
        },
        eventSupported: function (eventName) {
            var el = document.createElement('div');
            eventName = 'on' + eventName;
            var isSupported = eventName in el;
            if (!isSupported) {
                el.setAttribute(eventName, 'return;');
                isSupported = typeof el[eventName] === 'function';
            }
            el = null;
            return isSupported;
        }
    });
    extend(syn.init.prototype, {
        then: function (type, element, options, callback) {
            if (syn.autoDelay) {
                this.delay();
            }
            var args = syn.args(options, element, callback), self = this;
            this.queue.unshift(function (el, prevented) {
                if (typeof this[type] === 'function') {
                    this.element = args.element || el;
                    this[type](this.element, args.options, function (defaults, el) {
                        if (args.callback) {
                            args.callback.apply(self, arguments);
                        }
                        self.done.apply(self, arguments);
                    });
                } else {
                    this.result = syn.trigger(args.element, type, args.options);
                    if (args.callback) {
                        args.callback.call(this, args.element, this.result);
                    }
                    return this;
                }
            });
            return this;
        },
        delay: function (timeout, callback) {
            if (typeof timeout === 'function') {
                callback = timeout;
                timeout = null;
            }
            timeout = timeout || 600;
            var self = this;
            this.queue.unshift(function () {
                schedule(function () {
                    if (callback) {
                        callback.apply(self, []);
                    }
                    self.done.apply(self, arguments);
                }, timeout);
            });
            return this;
        },
        done: function (defaults, el) {
            if (el) {
                this.element = el;
            }
            if (this.queue.length) {
                this.queue.pop().call(this, this.element, defaults);
            }
        },
        '_click': function (element, options, callback, force) {
            syn.helpers.addOffset(options, element);
            if (syn.support.pointerEvents) {
                syn.trigger(element, 'pointerdown', options);
            }
            if (syn.support.touchEvents) {
                syn.trigger(element, 'touchstart', options);
            }
            syn.trigger(element, 'mousedown', options);
            schedule(function () {
                if (syn.support.pointerEvents) {
                    syn.trigger(element, 'pointerup', options);
                }
                if (syn.support.touchEvents) {
                    syn.trigger(element, 'touchend', options);
                }
                syn.trigger(element, 'mouseup', options);
                if (!syn.support.mouseDownUpClicks || force) {
                    syn.trigger(element, 'click', options);
                    callback(true);
                } else {
                    syn.create.click.setup('click', options, element);
                    syn.defaults.click.call(element);
                    schedule(function () {
                        callback(true);
                    }, 1);
                }
            }, 1);
        },
        '_rightClick': function (element, options, callback) {
            syn.helpers.addOffset(options, element);
            var mouseopts = extend(extend({}, syn.mouse.browser.right.mouseup), options);
            if (syn.support.pointerEvents) {
                syn.trigger(element, 'pointerdown', mouseopts);
            }
            syn.trigger(element, 'mousedown', mouseopts);
            schedule(function () {
                if (syn.support.pointerEvents) {
                    syn.trigger(element, 'pointerup', mouseopts);
                }
                syn.trigger(element, 'mouseup', mouseopts);
                if (syn.mouse.browser.right.contextmenu) {
                    syn.trigger(element, 'contextmenu', extend(extend({}, syn.mouse.browser.right.contextmenu), options));
                }
                callback(true);
            }, 1);
        },
        '_dblclick': function (element, options, callback) {
            syn.helpers.addOffset(options, element);
            var self = this;
            this._click(element, options, function () {
                schedule(function () {
                    self._click(element, options, function () {
                        syn.trigger(element, 'dblclick', options);
                        callback(true);
                    }, true);
                }, 2);
            });
        }
    });
    var actions = [
            'click',
            'dblclick',
            'move',
            'drag',
            'key',
            'type',
            'rightClick'
        ], makeAction = function (name) {
            syn[name] = function (element, options, callback) {
                return syn('_' + name, element, options, callback);
            };
            syn.init.prototype[name] = function (element, options, callback) {
                return this.then('_' + name, element, options, callback);
            };
        }, i = 0;
    for (; i < actions.length; i++) {
        makeAction(actions[i]);
    }
    module.exports = syn;
});
/*syn@0.13.0#mouse*/
define('syn@0.13.0#mouse', [
    'require',
    'exports',
    'module',
    './synthetic'
], function (require, exports, module) {
    var syn = require('./synthetic');
    var h = syn.helpers, getWin = h.getWindow;
    syn.mouse = {};
    h.extend(syn.defaults, {
        mousedown: function (options) {
            syn.trigger(this, 'focus', {});
        },
        click: function () {
            var element = this, href, type, createChange, radioChanged, nodeName, scope;
            try {
                href = element.href;
                type = element.type;
                createChange = syn.data(element, 'createChange');
                radioChanged = syn.data(element, 'radioChanged');
                scope = getWin(element);
                nodeName = element.nodeName.toLowerCase();
            } catch (e) {
                return;
            }
            if (!syn.support.linkHrefJS && /^\s*javascript:/.test(href)) {
                var code = href.replace(/^\s*javascript:/, '');
                if (code !== '//' && code.indexOf('void(0)') === -1) {
                    if (window.selenium) {
                        eval('with(selenium.browserbot.getCurrentWindow()){' + code + '}');
                    } else {
                        eval('with(scope){' + code + '}');
                    }
                }
            }
            if (!syn.support.clickSubmits && ((nodeName === 'input' || nodeName === 'button') && type === 'submit')) {
                var form = syn.closest(element, 'form');
                if (form) {
                    syn.trigger(form, 'submit', {});
                }
            }
            if (nodeName === 'a' && element.href && !/^\s*javascript:/.test(href)) {
                scope.location.href = href;
            }
            if (nodeName === 'input' && type === 'checkbox') {
                if (!syn.support.clickChanges) {
                    syn.trigger(element, 'change', {});
                }
            }
            if (nodeName === 'input' && type === 'radio') {
                if (radioChanged && !syn.support.radioClickChanges) {
                    syn.trigger(element, 'change', {});
                }
            }
            if (nodeName === 'option' && createChange) {
                syn.trigger(element.parentNode, 'change', {});
                syn.data(element, 'createChange', false);
            }
        }
    });
    h.extend(syn.create, {
        mouse: {
            options: function (type, options, element) {
                var doc = document.documentElement, body = document.body, center = [
                        options.pageX || 0,
                        options.pageY || 0
                    ], left = syn.mouse.browser && syn.mouse.browser.left[type], right = syn.mouse.browser && syn.mouse.browser.right[type];
                return h.extend({
                    bubbles: true,
                    cancelable: true,
                    view: window,
                    detail: 1,
                    screenX: 1,
                    screenY: 1,
                    clientX: options.clientX || center[0] - (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc.clientLeft || 0),
                    clientY: options.clientY || center[1] - (doc && doc.scrollTop || body && body.scrollTop || 0) - (doc.clientTop || 0),
                    ctrlKey: !!syn.key.ctrlKey,
                    altKey: !!syn.key.altKey,
                    shiftKey: !!syn.key.shiftKey,
                    metaKey: !!syn.key.metaKey,
                    button: left && left.button !== null ? left.button : right && right.button || (type === 'contextmenu' ? 2 : 0),
                    relatedTarget: document.documentElement
                }, options);
            },
            event: function (type, defaults, element) {
                var doc = getWin(element).document || document, event;
                if (doc.createEvent) {
                    try {
                        event = doc.createEvent('MouseEvents');
                        event.initMouseEvent(type, defaults.bubbles, defaults.cancelable, defaults.view, defaults.detail, defaults.screenX, defaults.screenY, defaults.clientX, defaults.clientY, defaults.ctrlKey, defaults.altKey, defaults.shiftKey, defaults.metaKey, defaults.button, defaults.relatedTarget);
                    } catch (e) {
                        event = h.createBasicStandardEvent(type, defaults, doc);
                    }
                    event.synthetic = true;
                    return event;
                } else {
                    try {
                        event = h.createEventObject(type, defaults, element);
                    } catch (e) {
                    }
                    return event;
                }
            }
        },
        click: {
            setup: function (type, options, element) {
                var nodeName = element.nodeName.toLowerCase();
                if (!syn.support.clickChecks && !syn.support.changeChecks && nodeName === 'input') {
                    type = element.type.toLowerCase();
                    if (type === 'checkbox') {
                        element.checked = !element.checked;
                    }
                    if (type === 'radio') {
                        if (!element.checked) {
                            try {
                                syn.data(element, 'radioChanged', true);
                            } catch (e) {
                            }
                            element.checked = true;
                        }
                    }
                }
                if (nodeName === 'a' && element.href && !/^\s*javascript:/.test(element.href)) {
                    syn.data(element, 'href', element.href);
                }
                if (/option/i.test(element.nodeName)) {
                    var child = element.parentNode.firstChild, i = -1;
                    while (child) {
                        if (child.nodeType === 1) {
                            i++;
                            if (child === element) {
                                break;
                            }
                        }
                        child = child.nextSibling;
                    }
                    if (i !== element.parentNode.selectedIndex) {
                        element.parentNode.selectedIndex = i;
                        syn.data(element, 'createChange', true);
                    }
                }
            }
        },
        mousedown: {
            setup: function (type, options, element) {
                var nn = element.nodeName.toLowerCase();
                if (syn.browser.safari && (nn === 'select' || nn === 'option')) {
                    options._autoPrevent = true;
                }
            }
        }
    });
});
/*syn@0.13.0#mouse.support*/
define('syn@0.13.0#mouse.support', [
    'require',
    'exports',
    'module',
    './synthetic',
    './mouse'
], function (require, exports, module) {
    var syn = require('./synthetic');
    require('./mouse');
    (function checkSupport() {
        if (!document.body) {
            return syn.schedule(checkSupport, 1);
        }
        window.__synthTest = function () {
            syn.support.linkHrefJS = true;
        };
        var div = document.createElement('div'), checkbox, submit, form, select;
        div.innerHTML = '<form id=\'outer\'>' + '<input name=\'checkbox\' type=\'checkbox\'/>' + '<input name=\'radio\' type=\'radio\' />' + '<input type=\'submit\' name=\'submitter\'/>' + '<input type=\'input\' name=\'inputter\'/>' + '<input name=\'one\'>' + '<input name=\'two\'/>' + '<a href=\'javascript:__synthTest()\' id=\'synlink\'></a>' + '<select><option></option></select>' + '</form>';
        document.documentElement.appendChild(div);
        form = div.firstChild;
        checkbox = form.childNodes[0];
        submit = form.childNodes[2];
        select = form.getElementsByTagName('select')[0];
        syn.trigger(form.childNodes[6], 'click', {});
        checkbox.checked = false;
        checkbox.onchange = function () {
            syn.support.clickChanges = true;
        };
        syn.trigger(checkbox, 'click', {});
        syn.support.clickChecks = checkbox.checked;
        checkbox.checked = false;
        syn.trigger(checkbox, 'change', {});
        syn.support.changeChecks = checkbox.checked;
        form.onsubmit = function (ev) {
            if (ev.preventDefault) {
                ev.preventDefault();
            }
            syn.support.clickSubmits = true;
            return false;
        };
        syn.trigger(submit, 'click', {});
        form.childNodes[1].onchange = function () {
            syn.support.radioClickChanges = true;
        };
        syn.trigger(form.childNodes[1], 'click', {});
        syn.bind(div, 'click', function onclick() {
            syn.support.optionClickBubbles = true;
            syn.unbind(div, 'click', onclick);
        });
        syn.trigger(select.firstChild, 'click', {});
        syn.support.changeBubbles = syn.eventSupported('change');
        div.onclick = function () {
            syn.support.mouseDownUpClicks = true;
        };
        syn.trigger(div, 'mousedown', {});
        syn.trigger(div, 'mouseup', {});
        document.documentElement.removeChild(div);
        syn.support.pointerEvents = syn.eventSupported('pointerdown');
        syn.support.touchEvents = syn.eventSupported('touchstart');
        syn.support.ready++;
    }());
});
/*syn@0.13.0#browsers*/
define('syn@0.13.0#browsers', [
    'require',
    'exports',
    'module',
    './synthetic',
    './mouse'
], function (require, exports, module) {
    var syn = require('./synthetic');
    require('./mouse');
    syn.key.browsers = {
        webkit: {
            'prevent': {
                'keyup': [],
                'keydown': [
                    'char',
                    'keypress'
                ],
                'keypress': ['char']
            },
            'character': {
                'keydown': [
                    0,
                    'key'
                ],
                'keypress': [
                    'char',
                    'char'
                ],
                'keyup': [
                    0,
                    'key'
                ]
            },
            'specialChars': {
                'keydown': [
                    0,
                    'char'
                ],
                'keyup': [
                    0,
                    'char'
                ]
            },
            'navigation': {
                'keydown': [
                    0,
                    'key'
                ],
                'keyup': [
                    0,
                    'key'
                ]
            },
            'special': {
                'keydown': [
                    0,
                    'key'
                ],
                'keyup': [
                    0,
                    'key'
                ]
            },
            'tab': {
                'keydown': [
                    0,
                    'char'
                ],
                'keyup': [
                    0,
                    'char'
                ]
            },
            'pause-break': {
                'keydown': [
                    0,
                    'key'
                ],
                'keyup': [
                    0,
                    'key'
                ]
            },
            'caps': {
                'keydown': [
                    0,
                    'key'
                ],
                'keyup': [
                    0,
                    'key'
                ]
            },
            'escape': {
                'keydown': [
                    0,
                    'key'
                ],
                'keyup': [
                    0,
                    'key'
                ]
            },
            'num-lock': {
                'keydown': [
                    0,
                    'key'
                ],
                'keyup': [
                    0,
                    'key'
                ]
            },
            'scroll-lock': {
                'keydown': [
                    0,
                    'key'
                ],
                'keyup': [
                    0,
                    'key'
                ]
            },
            'print': {
                'keyup': [
                    0,
                    'key'
                ]
            },
            'function': {
                'keydown': [
                    0,
                    'key'
                ],
                'keyup': [
                    0,
                    'key'
                ]
            },
            '\r': {
                'keydown': [
                    0,
                    'key'
                ],
                'keypress': [
                    'char',
                    'key'
                ],
                'keyup': [
                    0,
                    'key'
                ]
            }
        },
        gecko: {
            'prevent': {
                'keyup': [],
                'keydown': ['char'],
                'keypress': ['char']
            },
            'character': {
                'keydown': [
                    0,
                    'key'
                ],
                'keypress': [
                    'char',
                    0
                ],
                'keyup': [
                    0,
                    'key'
                ]
            },
            'specialChars': {
                'keydown': [
                    0,
                    'key'
                ],
                'keypress': [
                    0,
                    'key'
                ],
                'keyup': [
                    0,
                    'key'
                ]
            },
            'navigation': {
                'keydown': [
                    0,
                    'key'
                ],
                'keypress': [
                    0,
                    'key'
                ],
                'keyup': [
                    0,
                    'key'
                ]
            },
            'special': {
                'keydown': [
                    0,
                    'key'
                ],
                'keyup': [
                    0,
                    'key'
                ]
            },
            '\t': {
                'keydown': [
                    0,
                    'key'
                ],
                'keypress': [
                    0,
                    'key'
                ],
                'keyup': [
                    0,
                    'key'
                ]
            },
            'pause-break': {
                'keydown': [
                    0,
                    'key'
                ],
                'keypress': [
                    0,
                    'key'
                ],
                'keyup': [
                    0,
                    'key'
                ]
            },
            'caps': {
                'keydown': [
                    0,
                    'key'
                ],
                'keyup': [
                    0,
                    'key'
                ]
            },
            'escape': {
                'keydown': [
                    0,
                    'key'
                ],
                'keypress': [
                    0,
                    'key'
                ],
                'keyup': [
                    0,
                    'key'
                ]
            },
            'num-lock': {
                'keydown': [
                    0,
                    'key'
                ],
                'keyup': [
                    0,
                    'key'
                ]
            },
            'scroll-lock': {
                'keydown': [
                    0,
                    'key'
                ],
                'keyup': [
                    0,
                    'key'
                ]
            },
            'print': {
                'keyup': [
                    0,
                    'key'
                ]
            },
            'function': {
                'keydown': [
                    0,
                    'key'
                ],
                'keyup': [
                    0,
                    'key'
                ]
            },
            '\r': {
                'keydown': [
                    0,
                    'key'
                ],
                'keypress': [
                    0,
                    'key'
                ],
                'keyup': [
                    0,
                    'key'
                ]
            }
        },
        msie: {
            'prevent': {
                'keyup': [],
                'keydown': [
                    'char',
                    'keypress'
                ],
                'keypress': ['char']
            },
            'character': {
                'keydown': [
                    null,
                    'key'
                ],
                'keypress': [
                    null,
                    'char'
                ],
                'keyup': [
                    null,
                    'key'
                ]
            },
            'specialChars': {
                'keydown': [
                    null,
                    'char'
                ],
                'keyup': [
                    null,
                    'char'
                ]
            },
            'navigation': {
                'keydown': [
                    null,
                    'key'
                ],
                'keyup': [
                    null,
                    'key'
                ]
            },
            'special': {
                'keydown': [
                    null,
                    'key'
                ],
                'keyup': [
                    null,
                    'key'
                ]
            },
            'tab': {
                'keydown': [
                    null,
                    'char'
                ],
                'keyup': [
                    null,
                    'char'
                ]
            },
            'pause-break': {
                'keydown': [
                    null,
                    'key'
                ],
                'keyup': [
                    null,
                    'key'
                ]
            },
            'caps': {
                'keydown': [
                    null,
                    'key'
                ],
                'keyup': [
                    null,
                    'key'
                ]
            },
            'escape': {
                'keydown': [
                    null,
                    'key'
                ],
                'keypress': [
                    null,
                    'key'
                ],
                'keyup': [
                    null,
                    'key'
                ]
            },
            'num-lock': {
                'keydown': [
                    null,
                    'key'
                ],
                'keyup': [
                    null,
                    'key'
                ]
            },
            'scroll-lock': {
                'keydown': [
                    null,
                    'key'
                ],
                'keyup': [
                    null,
                    'key'
                ]
            },
            'print': {
                'keyup': [
                    null,
                    'key'
                ]
            },
            'function': {
                'keydown': [
                    null,
                    'key'
                ],
                'keyup': [
                    null,
                    'key'
                ]
            },
            '\r': {
                'keydown': [
                    null,
                    'key'
                ],
                'keypress': [
                    null,
                    'key'
                ],
                'keyup': [
                    null,
                    'key'
                ]
            }
        },
        opera: {
            'prevent': {
                'keyup': [],
                'keydown': [],
                'keypress': ['char']
            },
            'character': {
                'keydown': [
                    null,
                    'key'
                ],
                'keypress': [
                    null,
                    'char'
                ],
                'keyup': [
                    null,
                    'key'
                ]
            },
            'specialChars': {
                'keydown': [
                    null,
                    'char'
                ],
                'keypress': [
                    null,
                    'char'
                ],
                'keyup': [
                    null,
                    'char'
                ]
            },
            'navigation': {
                'keydown': [
                    null,
                    'key'
                ],
                'keypress': [
                    null,
                    'key'
                ]
            },
            'special': {
                'keydown': [
                    null,
                    'key'
                ],
                'keypress': [
                    null,
                    'key'
                ],
                'keyup': [
                    null,
                    'key'
                ]
            },
            'tab': {
                'keydown': [
                    null,
                    'char'
                ],
                'keypress': [
                    null,
                    'char'
                ],
                'keyup': [
                    null,
                    'char'
                ]
            },
            'pause-break': {
                'keydown': [
                    null,
                    'key'
                ],
                'keypress': [
                    null,
                    'key'
                ],
                'keyup': [
                    null,
                    'key'
                ]
            },
            'caps': {
                'keydown': [
                    null,
                    'key'
                ],
                'keyup': [
                    null,
                    'key'
                ]
            },
            'escape': {
                'keydown': [
                    null,
                    'key'
                ],
                'keypress': [
                    null,
                    'key'
                ]
            },
            'num-lock': {
                'keyup': [
                    null,
                    'key'
                ],
                'keydown': [
                    null,
                    'key'
                ],
                'keypress': [
                    null,
                    'key'
                ]
            },
            'scroll-lock': {
                'keydown': [
                    null,
                    'key'
                ],
                'keypress': [
                    null,
                    'key'
                ],
                'keyup': [
                    null,
                    'key'
                ]
            },
            'print': {},
            'function': {
                'keydown': [
                    null,
                    'key'
                ],
                'keypress': [
                    null,
                    'key'
                ],
                'keyup': [
                    null,
                    'key'
                ]
            },
            '\r': {
                'keydown': [
                    null,
                    'key'
                ],
                'keypress': [
                    null,
                    'key'
                ],
                'keyup': [
                    null,
                    'key'
                ]
            }
        }
    };
    syn.mouse.browsers = {
        webkit: {
            'right': {
                'mousedown': {
                    'button': 2,
                    'which': 3
                },
                'mouseup': {
                    'button': 2,
                    'which': 3
                },
                'contextmenu': {
                    'button': 2,
                    'which': 3
                }
            },
            'left': {
                'mousedown': {
                    'button': 0,
                    'which': 1
                },
                'mouseup': {
                    'button': 0,
                    'which': 1
                },
                'click': {
                    'button': 0,
                    'which': 1
                }
            }
        },
        opera: {
            'right': {
                'mousedown': {
                    'button': 2,
                    'which': 3
                },
                'mouseup': {
                    'button': 2,
                    'which': 3
                }
            },
            'left': {
                'mousedown': {
                    'button': 0,
                    'which': 1
                },
                'mouseup': {
                    'button': 0,
                    'which': 1
                },
                'click': {
                    'button': 0,
                    'which': 1
                }
            }
        },
        msie: {
            'right': {
                'mousedown': { 'button': 2 },
                'mouseup': { 'button': 2 },
                'contextmenu': { 'button': 0 }
            },
            'left': {
                'mousedown': { 'button': 1 },
                'mouseup': { 'button': 1 },
                'click': { 'button': 0 }
            }
        },
        chrome: {
            'right': {
                'mousedown': {
                    'button': 2,
                    'which': 3
                },
                'mouseup': {
                    'button': 2,
                    'which': 3
                },
                'contextmenu': {
                    'button': 2,
                    'which': 3
                }
            },
            'left': {
                'mousedown': {
                    'button': 0,
                    'which': 1
                },
                'mouseup': {
                    'button': 0,
                    'which': 1
                },
                'click': {
                    'button': 0,
                    'which': 1
                }
            }
        },
        gecko: {
            'left': {
                'mousedown': {
                    'button': 0,
                    'which': 1
                },
                'mouseup': {
                    'button': 0,
                    'which': 1
                },
                'click': {
                    'button': 0,
                    'which': 1
                }
            },
            'right': {
                'mousedown': {
                    'button': 2,
                    'which': 3
                },
                'mouseup': {
                    'button': 2,
                    'which': 3
                },
                'contextmenu': {
                    'button': 2,
                    'which': 3
                }
            }
        }
    };
    syn.key.browser = function () {
        if (syn.key.browsers[window.navigator.userAgent]) {
            return syn.key.browsers[window.navigator.userAgent];
        }
        for (var browser in syn.browser) {
            if (syn.browser[browser] && syn.key.browsers[browser]) {
                return syn.key.browsers[browser];
            }
        }
        return syn.key.browsers.gecko;
    }();
    syn.mouse.browser = function () {
        if (syn.mouse.browsers[window.navigator.userAgent]) {
            return syn.mouse.browsers[window.navigator.userAgent];
        }
        for (var browser in syn.browser) {
            if (syn.browser[browser] && syn.mouse.browsers[browser]) {
                return syn.mouse.browsers[browser];
            }
        }
        return syn.mouse.browsers.gecko;
    }();
});
/*syn@0.13.0#typeable*/
define('syn@0.13.0#typeable', [
    'require',
    'exports',
    'module',
    './synthetic'
], function (require, exports, module) {
    var syn = require('./synthetic');
    var typeables = [];
    var __indexOf = [].indexOf || function (item) {
        for (var i = 0, l = this.length; i < l; i++) {
            if (i in this && this[i] === item) {
                return i;
            }
        }
        return -1;
    };
    syn.typeable = function (fn) {
        if (__indexOf.call(typeables, fn) === -1) {
            typeables.push(fn);
        }
    };
    syn.typeable.test = function (el) {
        for (var i = 0, len = typeables.length; i < len; i++) {
            if (typeables[i](el)) {
                return true;
            }
        }
        return false;
    };
    var type = syn.typeable;
    var typeableExp = /input|textarea/i;
    type(function (el) {
        return typeableExp.test(el.nodeName);
    });
    type(function (el) {
        return __indexOf.call([
            '',
            'true'
        ], el.getAttribute('contenteditable')) !== -1;
    });
});
/*syn@0.13.0#key*/
define('syn@0.13.0#key', [
    'require',
    'exports',
    'module',
    './synthetic',
    './typeable',
    './browsers'
], function (require, exports, module) {
    var syn = require('./synthetic');
    require('./typeable');
    require('./browsers');
    var h = syn.helpers, formElExp = /input|textarea/i, supportsSelection = function (el) {
            var result;
            try {
                result = el.selectionStart !== undefined && el.selectionStart !== null;
            } catch (e) {
                result = false;
            }
            return result;
        }, getSelection = function (el) {
            var real, r, start;
            if (supportsSelection(el)) {
                if (document.activeElement && document.activeElement !== el && el.selectionStart === el.selectionEnd && el.selectionStart === 0) {
                    return {
                        start: el.value.length,
                        end: el.value.length
                    };
                }
                return {
                    start: el.selectionStart,
                    end: el.selectionEnd
                };
            } else {
                try {
                    if (el.nodeName.toLowerCase() === 'input') {
                        real = h.getWindow(el).document.selection.createRange();
                        r = el.createTextRange();
                        r.setEndPoint('EndToStart', real);
                        start = r.text.length;
                        return {
                            start: start,
                            end: start + real.text.length
                        };
                    } else {
                        real = h.getWindow(el).document.selection.createRange();
                        r = real.duplicate();
                        var r2 = real.duplicate(), r3 = real.duplicate();
                        r2.collapse();
                        r3.collapse(false);
                        r2.moveStart('character', -1);
                        r3.moveStart('character', -1);
                        r.moveToElementText(el);
                        r.setEndPoint('EndToEnd', real);
                        start = r.text.length - real.text.length;
                        var end = r.text.length;
                        if (start !== 0 && r2.text === '') {
                            start += 2;
                        }
                        if (end !== 0 && r3.text === '') {
                            end += 2;
                        }
                        return {
                            start: start,
                            end: end
                        };
                    }
                } catch (e) {
                    var prop = formElExp.test(el.nodeName) ? 'value' : 'textContent';
                    return {
                        start: el[prop].length,
                        end: el[prop].length
                    };
                }
            }
        }, getFocusable = function (el) {
            var document = h.getWindow(el).document, res = [];
            var els = document.getElementsByTagName('*'), len = els.length;
            for (var i = 0; i < len; i++) {
                if (syn.isFocusable(els[i]) && els[i] !== document.documentElement) {
                    res.push(els[i]);
                }
            }
            return res;
        }, textProperty = function () {
            var el = document.createElement('span');
            return el.textContent != null ? 'textContent' : 'innerText';
        }(), getText = function (el) {
            if (formElExp.test(el.nodeName)) {
                return el.value;
            }
            return el[textProperty];
        }, setText = function (el, value) {
            if (formElExp.test(el.nodeName)) {
                el.value = value;
            } else {
                el[textProperty] = value;
            }
        };
    h.extend(syn, {
        keycodes: {
            '\b': 8,
            '\t': 9,
            '\r': 13,
            'shift': 16,
            'ctrl': 17,
            'alt': 18,
            'meta': 91,
            'pause-break': 19,
            'caps': 20,
            'escape': 27,
            'num-lock': 144,
            'scroll-lock': 145,
            'print': 44,
            'page-up': 33,
            'page-down': 34,
            'end': 35,
            'home': 36,
            'left': 37,
            'up': 38,
            'right': 39,
            'down': 40,
            'insert': 45,
            'delete': 46,
            ' ': 32,
            '0': 48,
            '1': 49,
            '2': 50,
            '3': 51,
            '4': 52,
            '5': 53,
            '6': 54,
            '7': 55,
            '8': 56,
            '9': 57,
            'a': 65,
            'b': 66,
            'c': 67,
            'd': 68,
            'e': 69,
            'f': 70,
            'g': 71,
            'h': 72,
            'i': 73,
            'j': 74,
            'k': 75,
            'l': 76,
            'm': 77,
            'n': 78,
            'o': 79,
            'p': 80,
            'q': 81,
            'r': 82,
            's': 83,
            't': 84,
            'u': 85,
            'v': 86,
            'w': 87,
            'x': 88,
            'y': 89,
            'z': 90,
            'num0': 96,
            'num1': 97,
            'num2': 98,
            'num3': 99,
            'num4': 100,
            'num5': 101,
            'num6': 102,
            'num7': 103,
            'num8': 104,
            'num9': 105,
            '*': 106,
            '+': 107,
            'subtract': 109,
            'decimal': 110,
            'divide': 111,
            ';': 186,
            '=': 187,
            ',': 188,
            'dash': 189,
            '-': 189,
            'period': 190,
            '.': 190,
            'forward-slash': 191,
            '/': 191,
            '`': 192,
            '[': 219,
            '\\': 220,
            ']': 221,
            '\'': 222,
            'left window key': 91,
            'right window key': 92,
            'select key': 93,
            'f1': 112,
            'f2': 113,
            'f3': 114,
            'f4': 115,
            'f5': 116,
            'f6': 117,
            'f7': 118,
            'f8': 119,
            'f9': 120,
            'f10': 121,
            'f11': 122,
            'f12': 123
        },
        selectText: function (el, start, end) {
            if (supportsSelection(el)) {
                if (!end) {
                    syn.__tryFocus(el);
                    el.setSelectionRange(start, start);
                } else {
                    el.selectionStart = start;
                    el.selectionEnd = end;
                }
            } else if (el.createTextRange) {
                var r = el.createTextRange();
                r.moveStart('character', start);
                end = end || start;
                r.moveEnd('character', end - el.value.length);
                r.select();
            }
        },
        getText: function (el) {
            if (syn.typeable.test(el)) {
                var sel = getSelection(el);
                return el.value.substring(sel.start, sel.end);
            }
            var win = syn.helpers.getWindow(el);
            if (win.getSelection) {
                return win.getSelection().toString();
            } else if (win.document.getSelection) {
                return win.document.getSelection().toString();
            } else {
                return win.document.selection.createRange().text;
            }
        },
        getSelection: getSelection
    });
    h.extend(syn.key, {
        data: function (key) {
            if (syn.key.browser[key]) {
                return syn.key.browser[key];
            }
            for (var kind in syn.key.kinds) {
                if (h.inArray(key, syn.key.kinds[kind]) > -1) {
                    return syn.key.browser[kind];
                }
            }
            return syn.key.browser.character;
        },
        isSpecial: function (keyCode) {
            var specials = syn.key.kinds.special;
            for (var i = 0; i < specials.length; i++) {
                if (syn.keycodes[specials[i]] === keyCode) {
                    return specials[i];
                }
            }
        },
        options: function (key, event) {
            var keyData = syn.key.data(key);
            if (!keyData[event]) {
                return null;
            }
            var charCode = keyData[event][0], keyCode = keyData[event][1], result = {};
            if (keyCode === 'key') {
                result.keyCode = syn.keycodes[key];
            } else if (keyCode === 'char') {
                result.keyCode = key.charCodeAt(0);
            } else {
                result.keyCode = keyCode;
            }
            if (charCode === 'char') {
                result.charCode = key.charCodeAt(0);
            } else if (charCode !== null) {
                result.charCode = charCode;
            }
            if (result.keyCode) {
                result.which = result.keyCode;
            } else {
                result.which = result.charCode;
            }
            return result;
        },
        kinds: {
            special: [
                'shift',
                'ctrl',
                'alt',
                'meta',
                'caps'
            ],
            specialChars: ['\b'],
            navigation: [
                'page-up',
                'page-down',
                'end',
                'home',
                'left',
                'up',
                'right',
                'down',
                'insert',
                'delete'
            ],
            'function': [
                'f1',
                'f2',
                'f3',
                'f4',
                'f5',
                'f6',
                'f7',
                'f8',
                'f9',
                'f10',
                'f11',
                'f12'
            ]
        },
        getDefault: function (key) {
            if (syn.key.defaults[key]) {
                return syn.key.defaults[key];
            }
            for (var kind in syn.key.kinds) {
                if (h.inArray(key, syn.key.kinds[kind]) > -1 && syn.key.defaults[kind]) {
                    return syn.key.defaults[kind];
                }
            }
            return syn.key.defaults.character;
        },
        defaults: {
            'character': function (options, scope, key, force, sel) {
                if (/num\d+/.test(key)) {
                    key = key.match(/\d+/)[0];
                }
                if (force || !syn.support.keyCharacters && syn.typeable.test(this)) {
                    var current = getText(this), before = current.substr(0, sel.start), after = current.substr(sel.end), character = key;
                    setText(this, before + character + after);
                    var charLength = character === '\n' && syn.support.textareaCarriage ? 2 : character.length;
                    syn.selectText(this, before.length + charLength);
                }
            },
            'c': function (options, scope, key, force, sel) {
                if (syn.key.ctrlKey) {
                    syn.key.clipboard = syn.getText(this);
                } else {
                    syn.key.defaults.character.apply(this, arguments);
                }
            },
            'v': function (options, scope, key, force, sel) {
                if (syn.key.ctrlKey) {
                    syn.key.defaults.character.call(this, options, scope, syn.key.clipboard, true, sel);
                } else {
                    syn.key.defaults.character.apply(this, arguments);
                }
            },
            'a': function (options, scope, key, force, sel) {
                if (syn.key.ctrlKey) {
                    syn.selectText(this, 0, getText(this).length);
                } else {
                    syn.key.defaults.character.apply(this, arguments);
                }
            },
            'home': function () {
                syn.onParents(this, function (el) {
                    if (el.scrollHeight !== el.clientHeight) {
                        el.scrollTop = 0;
                        return false;
                    }
                });
            },
            'end': function () {
                syn.onParents(this, function (el) {
                    if (el.scrollHeight !== el.clientHeight) {
                        el.scrollTop = el.scrollHeight;
                        return false;
                    }
                });
            },
            'page-down': function () {
                syn.onParents(this, function (el) {
                    if (el.scrollHeight !== el.clientHeight) {
                        var ch = el.clientHeight;
                        el.scrollTop += ch;
                        return false;
                    }
                });
            },
            'page-up': function () {
                syn.onParents(this, function (el) {
                    if (el.scrollHeight !== el.clientHeight) {
                        var ch = el.clientHeight;
                        el.scrollTop -= ch;
                        return false;
                    }
                });
            },
            '\b': function (options, scope, key, force, sel) {
                if (!syn.support.backspaceWorks && syn.typeable.test(this)) {
                    var current = getText(this), before = current.substr(0, sel.start), after = current.substr(sel.end);
                    if (sel.start === sel.end && sel.start > 0) {
                        setText(this, before.substring(0, before.length - 1) + after);
                        syn.selectText(this, sel.start - 1);
                    } else {
                        setText(this, before + after);
                        syn.selectText(this, sel.start);
                    }
                }
            },
            'delete': function (options, scope, key, force, sel) {
                if (!syn.support.backspaceWorks && syn.typeable.test(this)) {
                    var current = getText(this), before = current.substr(0, sel.start), after = current.substr(sel.end);
                    if (sel.start === sel.end && sel.start <= getText(this).length - 1) {
                        setText(this, before + after.substring(1));
                    } else {
                        setText(this, before + after);
                    }
                    syn.selectText(this, sel.start);
                }
            },
            '\r': function (options, scope, key, force, sel) {
                var nodeName = this.nodeName.toLowerCase();
                if (nodeName === 'input') {
                    syn.trigger(this, 'change', {});
                }
                if (!syn.support.keypressSubmits && nodeName === 'input') {
                    var form = syn.closest(this, 'form');
                    if (form) {
                        syn.trigger(form, 'submit', {});
                    }
                }
                if (!syn.support.keyCharacters && nodeName === 'textarea') {
                    syn.key.defaults.character.call(this, options, scope, '\n', undefined, sel);
                }
                if (!syn.support.keypressOnAnchorClicks && nodeName === 'a') {
                    syn.trigger(this, 'click', {});
                }
            },
            '\t': function (options, scope) {
                var focusEls = getFocusable(this), current = null, i = 0, el, firstNotIndexed, orders = [];
                for (; i < focusEls.length; i++) {
                    orders.push([
                        focusEls[i],
                        i
                    ]);
                }
                var sort = function (order1, order2) {
                    var el1 = order1[0], el2 = order2[0], tab1 = syn.tabIndex(el1) || 0, tab2 = syn.tabIndex(el2) || 0;
                    if (tab1 === tab2) {
                        return order1[1] - order2[1];
                    } else {
                        if (tab1 === 0) {
                            return 1;
                        } else if (tab2 === 0) {
                            return -1;
                        } else {
                            return tab1 - tab2;
                        }
                    }
                };
                orders.sort(sort);
                var ordersLength = orders.length;
                for (i = 0; i < ordersLength; i++) {
                    el = orders[i][0];
                    if (this === el) {
                        var nextIndex = i;
                        if (syn.key.shiftKey) {
                            nextIndex--;
                            current = nextIndex >= 0 && orders[nextIndex][0] || orders[ordersLength - 1][0];
                        } else {
                            nextIndex++;
                            current = nextIndex < ordersLength && orders[nextIndex][0] || orders[0][0];
                        }
                    }
                }
                if (!current) {
                    current = firstNotIndexed;
                } else {
                    syn.__tryFocus(current);
                }
                return current;
            },
            'left': function (options, scope, key, force, sel) {
                if (syn.typeable.test(this)) {
                    if (syn.key.shiftKey) {
                        syn.selectText(this, sel.start === 0 ? 0 : sel.start - 1, sel.end);
                    } else {
                        syn.selectText(this, sel.start === 0 ? 0 : sel.start - 1);
                    }
                }
            },
            'right': function (options, scope, key, force, sel) {
                if (syn.typeable.test(this)) {
                    if (syn.key.shiftKey) {
                        syn.selectText(this, sel.start, sel.end + 1 > getText(this).length ? getText(this).length : sel.end + 1);
                    } else {
                        syn.selectText(this, sel.end + 1 > getText(this).length ? getText(this).length : sel.end + 1);
                    }
                }
            },
            'up': function () {
                if (/select/i.test(this.nodeName)) {
                    this.selectedIndex = this.selectedIndex ? this.selectedIndex - 1 : 0;
                }
            },
            'down': function () {
                if (/select/i.test(this.nodeName)) {
                    syn.changeOnBlur(this, 'selectedIndex', this.selectedIndex);
                    this.selectedIndex = this.selectedIndex + 1;
                }
            },
            'shift': function () {
                return null;
            },
            'ctrl': function () {
                return null;
            },
            'alt': function () {
                return null;
            },
            'meta': function () {
                return null;
            }
        }
    });
    h.extend(syn.create, {
        keydown: {
            setup: function (type, options, element) {
                if (h.inArray(options, syn.key.kinds.special) !== -1) {
                    syn.key[options + 'Key'] = element;
                }
            }
        },
        keypress: {
            setup: function (type, options, element) {
                if (syn.support.keyCharacters && !syn.support.keysOnNotFocused) {
                    syn.__tryFocus(element);
                }
            }
        },
        keyup: {
            setup: function (type, options, element) {
                if (h.inArray(options, syn.key.kinds.special) !== -1) {
                    syn.key[options + 'Key'] = null;
                }
            }
        },
        key: {
            options: function (type, options, element) {
                options = typeof options !== 'object' ? { character: options } : options;
                options = h.extend({}, options);
                if (options.character) {
                    h.extend(options, syn.key.options(options.character, type));
                    delete options.character;
                }
                options = h.extend({
                    ctrlKey: !!syn.key.ctrlKey,
                    altKey: !!syn.key.altKey,
                    shiftKey: !!syn.key.shiftKey,
                    metaKey: !!syn.key.metaKey
                }, options);
                return options;
            },
            event: function (type, options, element) {
                var doc = h.getWindow(element).document || document, event;
                if (doc.createEvent) {
                    try {
                        event = doc.createEvent('KeyEvents');
                        event.initKeyEvent(type, true, true, window, options.ctrlKey, options.altKey, options.shiftKey, options.metaKey, options.keyCode, options.charCode);
                    } catch (e) {
                        event = h.createBasicStandardEvent(type, options, doc);
                    }
                    event.synthetic = true;
                    return event;
                } else {
                    try {
                        event = h.createEventObject.apply(this, arguments);
                        h.extend(event, options);
                    } catch (e) {
                    }
                    return event;
                }
            }
        }
    });
    var convert = {
        'enter': '\r',
        'backspace': '\b',
        'tab': '\t',
        'space': ' '
    };
    h.extend(syn.init.prototype, {
        _key: function (element, options, callback) {
            if (/-up$/.test(options) && h.inArray(options.replace('-up', ''), syn.key.kinds.special) !== -1) {
                syn.trigger(element, 'keyup', options.replace('-up', ''));
                return callback(true, element);
            }
            var activeElement = h.getWindow(element).document.activeElement, caret = syn.typeable.test(element) && getSelection(element), key = convert[options] || options, runDefaults = syn.trigger(element, 'keydown', key), getDefault = syn.key.getDefault, prevent = syn.key.browser.prevent, defaultResult, keypressOptions = syn.key.options(key, 'keypress');
            if (runDefaults) {
                if (!keypressOptions) {
                    defaultResult = getDefault(key).call(element, keypressOptions, h.getWindow(element), key, undefined, caret);
                } else {
                    if (activeElement !== h.getWindow(element).document.activeElement) {
                        element = h.getWindow(element).document.activeElement;
                    }
                    runDefaults = syn.trigger(element, 'keypress', keypressOptions);
                    if (runDefaults) {
                        defaultResult = getDefault(key).call(element, keypressOptions, h.getWindow(element), key, undefined, caret);
                    }
                }
            } else {
                if (keypressOptions && h.inArray('keypress', prevent.keydown) === -1) {
                    if (activeElement !== h.getWindow(element).document.activeElement) {
                        element = h.getWindow(element).document.activeElement;
                    }
                    syn.trigger(element, 'keypress', keypressOptions);
                }
            }
            if (defaultResult && defaultResult.nodeName) {
                element = defaultResult;
            }
            if (defaultResult !== null) {
                syn.schedule(function () {
                    if (syn.support.oninput) {
                        syn.trigger(element, 'input', syn.key.options(key, 'input'));
                    }
                    syn.trigger(element, 'keyup', syn.key.options(key, 'keyup'));
                    callback(runDefaults, element);
                }, 1);
            } else {
                callback(runDefaults, element);
            }
            return element;
        },
        _type: function (element, options, callback) {
            var parts = (options + '').match(/(\[[^\]]+\])|([^\[])/g), self = this, runNextPart = function (runDefaults, el) {
                    var part = parts.shift();
                    if (!part) {
                        callback(runDefaults, el);
                        return;
                    }
                    el = el || element;
                    if (part.length > 1) {
                        part = part.substr(1, part.length - 2);
                    }
                    self._key(el, part, runNextPart);
                };
            runNextPart();
        }
    });
});
/*syn@0.13.0#key.support*/
define('syn@0.13.0#key.support', [
    'require',
    'exports',
    'module',
    './synthetic',
    './key'
], function (require, exports, module) {
    var syn = require('./synthetic');
    require('./key');
    if (!syn.config.support) {
        (function checkForSupport() {
            if (!document.body) {
                return syn.schedule(checkForSupport, 1);
            }
            var div = document.createElement('div'), checkbox, submit, form, anchor, textarea, inputter, one, doc;
            doc = document.documentElement;
            div.innerHTML = '<form id=\'outer\'>' + '<input name=\'checkbox\' type=\'checkbox\'/>' + '<input name=\'radio\' type=\'radio\' />' + '<input type=\'submit\' name=\'submitter\'/>' + '<input type=\'input\' name=\'inputter\'/>' + '<input name=\'one\'>' + '<input name=\'two\'/>' + '<a href=\'#abc\'></a>' + '<textarea>1\n2</textarea>' + '</form>';
            doc.insertBefore(div, doc.firstElementChild || doc.children[0]);
            form = div.firstChild;
            checkbox = form.childNodes[0];
            submit = form.childNodes[2];
            anchor = form.getElementsByTagName('a')[0];
            textarea = form.getElementsByTagName('textarea')[0];
            inputter = form.childNodes[3];
            one = form.childNodes[4];
            form.onsubmit = function (ev) {
                if (ev.preventDefault) {
                    ev.preventDefault();
                }
                syn.support.keypressSubmits = true;
                ev.returnValue = false;
                return false;
            };
            syn.__tryFocus(inputter);
            syn.trigger(inputter, 'keypress', '\r');
            syn.trigger(inputter, 'keypress', 'a');
            syn.support.keyCharacters = inputter.value === 'a';
            inputter.value = 'a';
            syn.trigger(inputter, 'keypress', '\b');
            syn.support.backspaceWorks = inputter.value === '';
            inputter.onchange = function () {
                syn.support.focusChanges = true;
            };
            syn.__tryFocus(inputter);
            syn.trigger(inputter, 'keypress', 'a');
            syn.__tryFocus(form.childNodes[5]);
            syn.trigger(inputter, 'keypress', 'b');
            syn.support.keysOnNotFocused = inputter.value === 'ab';
            syn.bind(anchor, 'click', function (ev) {
                if (ev.preventDefault) {
                    ev.preventDefault();
                }
                syn.support.keypressOnAnchorClicks = true;
                ev.returnValue = false;
                return false;
            });
            syn.trigger(anchor, 'keypress', '\r');
            syn.support.textareaCarriage = textarea.value.length === 4;
            syn.support.oninput = 'oninput' in one;
            doc.removeChild(div);
            syn.support.ready++;
        }());
    } else {
        syn.helpers.extend(syn.support, syn.config.support);
    }
});
/*syn@0.13.0#drag*/
define('syn@0.13.0#drag', [
    'require',
    'exports',
    'module',
    './synthetic'
], function (require, exports, module) {
    var syn = require('./synthetic');
    var elementFromPoint = function (point, win) {
        var clientX = point.clientX;
        var clientY = point.clientY;
        if (point == null) {
            return null;
        }
        if (syn.support.elementFromPage) {
            var off = syn.helpers.scrollOffset(win);
            clientX = clientX + off.left;
            clientY = clientY + off.top;
        }
        return win.document.elementFromPoint(Math.round(clientX), Math.round(clientY));
    };
    var DragonDrop = {
        focusWindow: null,
        dragAndDrop: function (focusWindow, fromPoint, toPoint, duration, callback) {
            this.currentDataTransferItem = null;
            this.focusWindow = focusWindow;
            this._mouseOver(fromPoint);
            this._mouseEnter(fromPoint);
            this._mouseMove(fromPoint);
            this._mouseDown(fromPoint);
            this._dragStart(fromPoint);
            this._drag(fromPoint);
            this._dragEnter(fromPoint);
            this._dragOver(fromPoint);
            DragonDrop.startMove(fromPoint, toPoint, duration, function () {
                DragonDrop._dragLeave(fromPoint);
                DragonDrop._dragEnd(fromPoint);
                DragonDrop._mouseOut(fromPoint);
                DragonDrop._mouseLeave(fromPoint);
                DragonDrop._drop(toPoint);
                DragonDrop._dragEnd(toPoint);
                DragonDrop._mouseOver(toPoint);
                DragonDrop._mouseEnter(toPoint);
                DragonDrop._mouseMove(toPoint);
                DragonDrop._mouseOut(toPoint);
                DragonDrop._mouseLeave(toPoint);
                callback();
                DragonDrop.cleanup();
            });
        },
        _dragStart: function (node, options) {
            this.createAndDispatchEvent(node, 'dragstart', options);
        },
        _drag: function (node, options) {
            this.createAndDispatchEvent(node, 'drag', options);
        },
        _dragEnter: function (node, options) {
            this.createAndDispatchEvent(node, 'dragenter', options);
        },
        _dragOver: function (node, options) {
            this.createAndDispatchEvent(node, 'dragover', options);
        },
        _dragLeave: function (node, options) {
            this.createAndDispatchEvent(node, 'dragleave', options);
        },
        _drop: function (node, options) {
            this.createAndDispatchEvent(node, 'drop', options);
        },
        _dragEnd: function (node, options) {
            this.createAndDispatchEvent(node, 'dragend', options);
        },
        _mouseDown: function (node, options) {
            this.createAndDispatchEvent(node, 'mousedown', options);
        },
        _mouseMove: function (node, options) {
            this.createAndDispatchEvent(node, 'mousemove', options);
        },
        _mouseEnter: function (node, options) {
            this.createAndDispatchEvent(node, 'mouseenter', options);
        },
        _mouseOver: function (node, options) {
            this.createAndDispatchEvent(node, 'mouseover', options);
        },
        _mouseOut: function (node, options) {
            this.createAndDispatchEvent(node, 'mouseout', options);
        },
        _mouseLeave: function (node, options) {
            this.createAndDispatchEvent(node, 'mouseleave', options);
        },
        createAndDispatchEvent: function (point, eventName, options) {
            if (point) {
                var targetElement = elementFromPoint(point, this.focusWindow);
                syn.trigger(targetElement, eventName, options);
            }
        },
        getDataTransferObject: function () {
            if (!this.currentDataTransferItem) {
                return this.currentDataTransferItem = this.createDataTransferObject();
            } else {
                return this.currentDataTransferItem;
            }
        },
        cleanup: function () {
            this.currentDataTransferItem = null;
            this.focusWindow = null;
        },
        createDataTransferObject: function () {
            var dataTransfer = {
                dropEffect: 'none',
                effectAllowed: 'uninitialized',
                files: [],
                items: [],
                types: [],
                data: [],
                setData: function (dataFlavor, value) {
                    var tempdata = {};
                    tempdata.dataFlavor = dataFlavor;
                    tempdata.val = value;
                    this.data.push(tempdata);
                },
                getData: function (dataFlavor) {
                    for (var i = 0; i < this.data.length; i++) {
                        var tempdata = this.data[i];
                        if (tempdata.dataFlavor === dataFlavor) {
                            return tempdata.val;
                        }
                    }
                }
            };
            return dataTransfer;
        },
        startMove: function (start, end, duration, callback) {
            var startTime = new Date();
            var distX = end.clientX - start.clientX;
            var distY = end.clientY - start.clientY;
            var win = this.focusWindow;
            var current = start;
            var cursor = win.document.createElement('div');
            var calls = 0;
            var move;
            move = function onmove() {
                var now = new Date();
                var scrollOffset = syn.helpers.scrollOffset(win);
                var fraction = (calls === 0 ? 0 : now - startTime) / duration;
                var options = {
                    clientX: distX * fraction + start.clientX,
                    clientY: distY * fraction + start.clientY
                };
                calls++;
                if (fraction < 1) {
                    syn.helpers.extend(cursor.style, {
                        left: options.clientX + scrollOffset.left + 2 + 'px',
                        top: options.clientY + scrollOffset.top + 2 + 'px'
                    });
                    current = DragonDrop.mouseMove(options, current);
                    syn.schedule(onmove, 15);
                } else {
                    current = DragonDrop.mouseMove(end, current);
                    win.document.body.removeChild(cursor);
                    callback();
                }
            };
            syn.helpers.extend(cursor.style, {
                height: '5px',
                width: '5px',
                backgroundColor: 'red',
                position: 'absolute',
                zIndex: 19999,
                fontSize: '1px'
            });
            win.document.body.appendChild(cursor);
            move();
        },
        mouseMove: function (thisPoint, previousPoint) {
            var thisElement = elementFromPoint(thisPoint, this.focusWindow);
            var previousElement = elementFromPoint(previousPoint, this.focusWindow);
            var options = syn.helpers.extend({}, thisPoint);
            if (thisElement !== previousElement) {
                options.relatedTarget = thisElement;
                this._dragLeave(previousPoint, options);
                options.relatedTarget = previousElement;
                this._dragEnter(thisPoint, options);
            }
            this._dragOver(thisPoint, options);
            return thisPoint;
        }
    };
    function createDragEvent(eventName, options, element) {
        var dragEvent = syn.create.mouse.event(eventName, options, element);
        dragEvent.dataTransfer = DragonDrop.getDataTransferObject();
        return syn.dispatch(dragEvent, element, eventName, false);
    }
    syn.create.dragstart = { event: createDragEvent };
    syn.create.dragenter = { event: createDragEvent };
    syn.create.dragover = { event: createDragEvent };
    syn.create.dragleave = { event: createDragEvent };
    syn.create.drag = { event: createDragEvent };
    syn.create.drop = { event: createDragEvent };
    syn.create.dragend = { event: createDragEvent };
    (function dragSupport() {
        if (!document.body) {
            syn.schedule(dragSupport, 1);
            return;
        }
        var div = document.createElement('div');
        document.body.appendChild(div);
        syn.helpers.extend(div.style, {
            width: '100px',
            height: '10000px',
            backgroundColor: 'blue',
            position: 'absolute',
            top: '10px',
            left: '0px',
            zIndex: 19999
        });
        document.body.scrollTop = 11;
        if (!document.elementFromPoint) {
            return;
        }
        var el = document.elementFromPoint(3, 1);
        if (el === div) {
            syn.support.elementFromClient = true;
        } else {
            syn.support.elementFromPage = true;
        }
        document.body.removeChild(div);
        document.body.scrollTop = 0;
    }());
    var mouseMove = function (point, win, last) {
            var el = elementFromPoint(point, win);
            if (last !== el && el && last) {
                var options = syn.helpers.extend({}, point);
                options.relatedTarget = el;
                if (syn.support.pointerEvents) {
                    syn.trigger(last, 'pointerout', options);
                }
                syn.trigger(last, 'mouseout', options);
                options.relatedTarget = last;
                if (syn.support.pointerEvents) {
                    syn.trigger(el, 'pointerover', options);
                }
                syn.trigger(el, 'mouseover', options);
            }
            if (syn.support.pointerEvents) {
                syn.trigger(el || win, 'pointermove', point);
            }
            if (syn.support.touchEvents) {
                syn.trigger(el || win, 'touchmove', point);
            }
            syn.trigger(el || win, 'mousemove', point);
            return el;
        }, createEventAtPoint = function (event, point, win) {
            var el = elementFromPoint(point, win);
            syn.trigger(el || win, event, point);
            return el;
        }, startMove = function (win, start, end, duration, callback) {
            var startTime = new Date(), distX = end.clientX - start.clientX, distY = end.clientY - start.clientY, current = elementFromPoint(start, win), cursor = win.document.createElement('div'), calls = 0, move;
            move = function onmove() {
                var now = new Date(), scrollOffset = syn.helpers.scrollOffset(win), fraction = (calls === 0 ? 0 : now - startTime) / duration, options = {
                        clientX: distX * fraction + start.clientX,
                        clientY: distY * fraction + start.clientY
                    };
                calls++;
                if (fraction < 1) {
                    syn.helpers.extend(cursor.style, {
                        left: options.clientX + scrollOffset.left + 2 + 'px',
                        top: options.clientY + scrollOffset.top + 2 + 'px'
                    });
                    current = mouseMove(options, win, current);
                    syn.schedule(onmove, 15);
                } else {
                    current = mouseMove(end, win, current);
                    win.document.body.removeChild(cursor);
                    callback();
                }
            };
            syn.helpers.extend(cursor.style, {
                height: '5px',
                width: '5px',
                backgroundColor: 'red',
                position: 'absolute',
                zIndex: 19999,
                fontSize: '1px'
            });
            win.document.body.appendChild(cursor);
            move();
        }, startDrag = function (win, fromPoint, toPoint, duration, callback) {
            if (syn.support.pointerEvents) {
                createEventAtPoint('pointerover', fromPoint, win);
                createEventAtPoint('pointerenter', fromPoint, win);
            }
            createEventAtPoint('mouseover', fromPoint, win);
            createEventAtPoint('mouseenter', fromPoint, win);
            if (syn.support.pointerEvents) {
                createEventAtPoint('pointermove', fromPoint, win);
            }
            createEventAtPoint('mousemove', fromPoint, win);
            if (syn.support.pointerEvents) {
                createEventAtPoint('pointerdown', fromPoint, win);
            }
            if (syn.support.touchEvents) {
                createEventAtPoint('touchstart', fromPoint, win);
            }
            createEventAtPoint('mousedown', fromPoint, win);
            startMove(win, fromPoint, toPoint, duration, function () {
                if (syn.support.pointerEvents) {
                    createEventAtPoint('pointerup', toPoint, win);
                }
                if (syn.support.touchEvents) {
                    createEventAtPoint('touchend', toPoint, win);
                }
                createEventAtPoint('mouseup', toPoint, win);
                if (syn.support.pointerEvents) {
                    createEventAtPoint('pointerleave', toPoint, win);
                }
                createEventAtPoint('mouseleave', toPoint, win);
                callback();
            });
        }, center = function (el) {
            var j = syn.jquery()(el), o = j.offset();
            return {
                pageX: o.left + j.outerWidth() / 2,
                pageY: o.top + j.outerHeight() / 2
            };
        }, convertOption = function (option, win, from) {
            var page = /(\d+)[x ](\d+)/, client = /(\d+)X(\d+)/, relative = /([+-]\d+)[xX ]([+-]\d+)/, parts;
            if (typeof option === 'string' && relative.test(option) && from) {
                var cent = center(from);
                parts = option.match(relative);
                option = {
                    pageX: cent.pageX + parseInt(parts[1]),
                    pageY: cent.pageY + parseInt(parts[2])
                };
            }
            if (typeof option === 'string' && page.test(option)) {
                parts = option.match(page);
                option = {
                    pageX: parseInt(parts[1]),
                    pageY: parseInt(parts[2])
                };
            }
            if (typeof option === 'string' && client.test(option)) {
                parts = option.match(client);
                option = {
                    clientX: parseInt(parts[1]),
                    clientY: parseInt(parts[2])
                };
            }
            if (typeof option === 'string') {
                option = syn.jquery()(option, win.document)[0];
            }
            if (option.nodeName) {
                option = center(option);
            }
            if (option.pageX != null) {
                var off = syn.helpers.scrollOffset(win);
                option = {
                    clientX: option.pageX - off.left,
                    clientY: option.pageY - off.top
                };
            }
            return option;
        }, adjust = function (from, to, win) {
            if (from.clientY < 0) {
                var off = syn.helpers.scrollOffset(win);
                var top = off.top + from.clientY - 100, diff = top - off.top;
                if (top > 0) {
                } else {
                    top = 0;
                    diff = -off.top;
                }
                from.clientY = from.clientY - diff;
                to.clientY = to.clientY - diff;
                syn.helpers.scrollOffset(win, {
                    top: top,
                    left: off.left
                });
            }
        };
    syn.helpers.extend(syn.init.prototype, {
        _move: function (from, options, callback) {
            var win = syn.helpers.getWindow(from);
            var sourceCoordinates = convertOption(options.from || from, win, from);
            var destinationCoordinates = convertOption(options.to || options, win, from);
            if (options.adjust !== false) {
                adjust(sourceCoordinates, destinationCoordinates, win);
            }
            startMove(win, sourceCoordinates, destinationCoordinates, options.duration || 500, callback);
        },
        _drag: function (from, options, callback) {
            var win = syn.helpers.getWindow(from);
            var sourceCoordinates = convertOption(options.from || from, win, from);
            var destinationCoordinates = convertOption(options.to || options, win, from);
            if (options.adjust !== false) {
                adjust(sourceCoordinates, destinationCoordinates, win);
            }
            var html5draggable = from.draggable;
            if (html5draggable) {
                DragonDrop.dragAndDrop(win, sourceCoordinates, destinationCoordinates, options.duration || 500, callback);
            } else {
                startDrag(win, sourceCoordinates, destinationCoordinates, options.duration || 500, callback);
            }
        }
    });
});
/*syn@0.13.0#syn*/
define('syn@0.13.0#syn', [
    'require',
    'exports',
    'module',
    './synthetic',
    './mouse.support',
    './browsers',
    './key.support',
    './drag'
], function (require, exports, module) {
    var syn = require('./synthetic');
    require('./mouse.support');
    require('./browsers');
    require('./key.support');
    require('./drag');
    window.syn = syn;
    module.exports = syn;
});
/*jquery@1.11.0#dist/jquery*/
(function (global, factory) {
    if (typeof module === 'object' && typeof module.exports === 'object') {
        module.exports = global.document ? factory(global, true) : function (w) {
            if (!w.document) {
                throw new Error('jQuery requires a window with a document');
            }
            return factory(w);
        };
    } else {
        factory(global);
    }
}(typeof window !== 'undefined' ? window : this, function (window, noGlobal) {
    var deletedIds = [];
    var slice = deletedIds.slice;
    var concat = deletedIds.concat;
    var push = deletedIds.push;
    var indexOf = deletedIds.indexOf;
    var class2type = {};
    var toString = class2type.toString;
    var hasOwn = class2type.hasOwnProperty;
    var trim = ''.trim;
    var support = {};
    var version = '1.11.0', jQuery = function (selector, context) {
            return new jQuery.fn.init(selector, context);
        }, rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, rmsPrefix = /^-ms-/, rdashAlpha = /-([\da-z])/gi, fcamelCase = function (all, letter) {
            return letter.toUpperCase();
        };
    jQuery.fn = jQuery.prototype = {
        jquery: version,
        constructor: jQuery,
        selector: '',
        length: 0,
        toArray: function () {
            return slice.call(this);
        },
        get: function (num) {
            return num != null ? num < 0 ? this[num + this.length] : this[num] : slice.call(this);
        },
        pushStack: function (elems) {
            var ret = jQuery.merge(this.constructor(), elems);
            ret.prevObject = this;
            ret.context = this.context;
            return ret;
        },
        each: function (callback, args) {
            return jQuery.each(this, callback, args);
        },
        map: function (callback) {
            return this.pushStack(jQuery.map(this, function (elem, i) {
                return callback.call(elem, i, elem);
            }));
        },
        slice: function () {
            return this.pushStack(slice.apply(this, arguments));
        },
        first: function () {
            return this.eq(0);
        },
        last: function () {
            return this.eq(-1);
        },
        eq: function (i) {
            var len = this.length, j = +i + (i < 0 ? len : 0);
            return this.pushStack(j >= 0 && j < len ? [this[j]] : []);
        },
        end: function () {
            return this.prevObject || this.constructor(null);
        },
        push: push,
        sort: deletedIds.sort,
        splice: deletedIds.splice
    };
    jQuery.extend = jQuery.fn.extend = function () {
        var src, copyIsArray, copy, name, options, clone, target = arguments[0] || {}, i = 1, length = arguments.length, deep = false;
        if (typeof target === 'boolean') {
            deep = target;
            target = arguments[i] || {};
            i++;
        }
        if (typeof target !== 'object' && !jQuery.isFunction(target)) {
            target = {};
        }
        if (i === length) {
            target = this;
            i--;
        }
        for (; i < length; i++) {
            if ((options = arguments[i]) != null) {
                for (name in options) {
                    src = target[name];
                    copy = options[name];
                    if (target === copy) {
                        continue;
                    }
                    if (deep && copy && (jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)))) {
                        if (copyIsArray) {
                            copyIsArray = false;
                            clone = src && jQuery.isArray(src) ? src : [];
                        } else {
                            clone = src && jQuery.isPlainObject(src) ? src : {};
                        }
                        target[name] = jQuery.extend(deep, clone, copy);
                    } else if (copy !== undefined) {
                        target[name] = copy;
                    }
                }
            }
        }
        return target;
    };
    jQuery.extend({
        expando: 'jQuery' + (version + Math.random()).replace(/\D/g, ''),
        isReady: true,
        error: function (msg) {
            throw new Error(msg);
        },
        noop: function () {
        },
        isFunction: function (obj) {
            return jQuery.type(obj) === 'function';
        },
        isArray: Array.isArray || function (obj) {
            return jQuery.type(obj) === 'array';
        },
        isWindow: function (obj) {
            return obj != null && obj == obj.window;
        },
        isNumeric: function (obj) {
            return obj - parseFloat(obj) >= 0;
        },
        isEmptyObject: function (obj) {
            var name;
            for (name in obj) {
                return false;
            }
            return true;
        },
        isPlainObject: function (obj) {
            var key;
            if (!obj || jQuery.type(obj) !== 'object' || obj.nodeType || jQuery.isWindow(obj)) {
                return false;
            }
            try {
                if (obj.constructor && !hasOwn.call(obj, 'constructor') && !hasOwn.call(obj.constructor.prototype, 'isPrototypeOf')) {
                    return false;
                }
            } catch (e) {
                return false;
            }
            if (support.ownLast) {
                for (key in obj) {
                    return hasOwn.call(obj, key);
                }
            }
            for (key in obj) {
            }
            return key === undefined || hasOwn.call(obj, key);
        },
        type: function (obj) {
            if (obj == null) {
                return obj + '';
            }
            return typeof obj === 'object' || typeof obj === 'function' ? class2type[toString.call(obj)] || 'object' : typeof obj;
        },
        globalEval: function (data) {
            if (data && jQuery.trim(data)) {
                (window.execScript || function (data) {
                    window['eval'].call(window, data);
                })(data);
            }
        },
        camelCase: function (string) {
            return string.replace(rmsPrefix, 'ms-').replace(rdashAlpha, fcamelCase);
        },
        nodeName: function (elem, name) {
            return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
        },
        each: function (obj, callback, args) {
            var value, i = 0, length = obj.length, isArray = isArraylike(obj);
            if (args) {
                if (isArray) {
                    for (; i < length; i++) {
                        value = callback.apply(obj[i], args);
                        if (value === false) {
                            break;
                        }
                    }
                } else {
                    for (i in obj) {
                        value = callback.apply(obj[i], args);
                        if (value === false) {
                            break;
                        }
                    }
                }
            } else {
                if (isArray) {
                    for (; i < length; i++) {
                        value = callback.call(obj[i], i, obj[i]);
                        if (value === false) {
                            break;
                        }
                    }
                } else {
                    for (i in obj) {
                        value = callback.call(obj[i], i, obj[i]);
                        if (value === false) {
                            break;
                        }
                    }
                }
            }
            return obj;
        },
        trim: trim && !trim.call('\uFEFF\xA0') ? function (text) {
            return text == null ? '' : trim.call(text);
        } : function (text) {
            return text == null ? '' : (text + '').replace(rtrim, '');
        },
        makeArray: function (arr, results) {
            var ret = results || [];
            if (arr != null) {
                if (isArraylike(Object(arr))) {
                    jQuery.merge(ret, typeof arr === 'string' ? [arr] : arr);
                } else {
                    push.call(ret, arr);
                }
            }
            return ret;
        },
        inArray: function (elem, arr, i) {
            var len;
            if (arr) {
                if (indexOf) {
                    return indexOf.call(arr, elem, i);
                }
                len = arr.length;
                i = i ? i < 0 ? Math.max(0, len + i) : i : 0;
                for (; i < len; i++) {
                    if (i in arr && arr[i] === elem) {
                        return i;
                    }
                }
            }
            return -1;
        },
        merge: function (first, second) {
            var len = +second.length, j = 0, i = first.length;
            while (j < len) {
                first[i++] = second[j++];
            }
            if (len !== len) {
                while (second[j] !== undefined) {
                    first[i++] = second[j++];
                }
            }
            first.length = i;
            return first;
        },
        grep: function (elems, callback, invert) {
            var callbackInverse, matches = [], i = 0, length = elems.length, callbackExpect = !invert;
            for (; i < length; i++) {
                callbackInverse = !callback(elems[i], i);
                if (callbackInverse !== callbackExpect) {
                    matches.push(elems[i]);
                }
            }
            return matches;
        },
        map: function (elems, callback, arg) {
            var value, i = 0, length = elems.length, isArray = isArraylike(elems), ret = [];
            if (isArray) {
                for (; i < length; i++) {
                    value = callback(elems[i], i, arg);
                    if (value != null) {
                        ret.push(value);
                    }
                }
            } else {
                for (i in elems) {
                    value = callback(elems[i], i, arg);
                    if (value != null) {
                        ret.push(value);
                    }
                }
            }
            return concat.apply([], ret);
        },
        guid: 1,
        proxy: function (fn, context) {
            var args, proxy, tmp;
            if (typeof context === 'string') {
                tmp = fn[context];
                context = fn;
                fn = tmp;
            }
            if (!jQuery.isFunction(fn)) {
                return undefined;
            }
            args = slice.call(arguments, 2);
            proxy = function () {
                return fn.apply(context || this, args.concat(slice.call(arguments)));
            };
            proxy.guid = fn.guid = fn.guid || jQuery.guid++;
            return proxy;
        },
        now: function () {
            return +new Date();
        },
        support: support
    });
    jQuery.each('Boolean Number String Function Array Date RegExp Object Error'.split(' '), function (i, name) {
        class2type['[object ' + name + ']'] = name.toLowerCase();
    });
    function isArraylike(obj) {
        var length = obj.length, type = jQuery.type(obj);
        if (type === 'function' || jQuery.isWindow(obj)) {
            return false;
        }
        if (obj.nodeType === 1 && length) {
            return true;
        }
        return type === 'array' || length === 0 || typeof length === 'number' && length > 0 && length - 1 in obj;
    }
    var Sizzle = function (window) {
        var i, support, Expr, getText, isXML, compile, outermostContext, sortInput, hasDuplicate, setDocument, document, docElem, documentIsHTML, rbuggyQSA, rbuggyMatches, matches, contains, expando = 'sizzle' + -new Date(), preferredDoc = window.document, dirruns = 0, done = 0, classCache = createCache(), tokenCache = createCache(), compilerCache = createCache(), sortOrder = function (a, b) {
                if (a === b) {
                    hasDuplicate = true;
                }
                return 0;
            }, strundefined = typeof undefined, MAX_NEGATIVE = 1 << 31, hasOwn = {}.hasOwnProperty, arr = [], pop = arr.pop, push_native = arr.push, push = arr.push, slice = arr.slice, indexOf = arr.indexOf || function (elem) {
                var i = 0, len = this.length;
                for (; i < len; i++) {
                    if (this[i] === elem) {
                        return i;
                    }
                }
                return -1;
            }, booleans = 'checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped', whitespace = '[\\x20\\t\\r\\n\\f]', characterEncoding = '(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+', identifier = characterEncoding.replace('w', 'w#'), attributes = '\\[' + whitespace + '*(' + characterEncoding + ')' + whitespace + '*(?:([*^$|!~]?=)' + whitespace + '*(?:([\'"])((?:\\\\.|[^\\\\])*?)\\3|(' + identifier + ')|)|)' + whitespace + '*\\]', pseudos = ':(' + characterEncoding + ')(?:\\((([\'"])((?:\\\\.|[^\\\\])*?)\\3|((?:\\\\.|[^\\\\()[\\]]|' + attributes.replace(3, 8) + ')*)|.*)\\)|)', rtrim = new RegExp('^' + whitespace + '+|((?:^|[^\\\\])(?:\\\\.)*)' + whitespace + '+$', 'g'), rcomma = new RegExp('^' + whitespace + '*,' + whitespace + '*'), rcombinators = new RegExp('^' + whitespace + '*([>+~]|' + whitespace + ')' + whitespace + '*'), rattributeQuotes = new RegExp('=' + whitespace + '*([^\\]\'"]*?)' + whitespace + '*\\]', 'g'), rpseudo = new RegExp(pseudos), ridentifier = new RegExp('^' + identifier + '$'), matchExpr = {
                'ID': new RegExp('^#(' + characterEncoding + ')'),
                'CLASS': new RegExp('^\\.(' + characterEncoding + ')'),
                'TAG': new RegExp('^(' + characterEncoding.replace('w', 'w*') + ')'),
                'ATTR': new RegExp('^' + attributes),
                'PSEUDO': new RegExp('^' + pseudos),
                'CHILD': new RegExp('^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(' + whitespace + '*(even|odd|(([+-]|)(\\d*)n|)' + whitespace + '*(?:([+-]|)' + whitespace + '*(\\d+)|))' + whitespace + '*\\)|)', 'i'),
                'bool': new RegExp('^(?:' + booleans + ')$', 'i'),
                'needsContext': new RegExp('^' + whitespace + '*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(' + whitespace + '*((?:-\\d)?\\d*)' + whitespace + '*\\)|)(?=[^-]|$)', 'i')
            }, rinputs = /^(?:input|select|textarea|button)$/i, rheader = /^h\d$/i, rnative = /^[^{]+\{\s*\[native \w/, rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/, rsibling = /[+~]/, rescape = /'|\\/g, runescape = new RegExp('\\\\([\\da-f]{1,6}' + whitespace + '?|(' + whitespace + ')|.)', 'ig'), funescape = function (_, escaped, escapedWhitespace) {
                var high = '0x' + escaped - 65536;
                return high !== high || escapedWhitespace ? escaped : high < 0 ? String.fromCharCode(high + 65536) : String.fromCharCode(high >> 10 | 55296, high & 1023 | 56320);
            };
        try {
            push.apply(arr = slice.call(preferredDoc.childNodes), preferredDoc.childNodes);
            arr[preferredDoc.childNodes.length].nodeType;
        } catch (e) {
            push = {
                apply: arr.length ? function (target, els) {
                    push_native.apply(target, slice.call(els));
                } : function (target, els) {
                    var j = target.length, i = 0;
                    while (target[j++] = els[i++]) {
                    }
                    target.length = j - 1;
                }
            };
        }
        function Sizzle(selector, context, results, seed) {
            var match, elem, m, nodeType, i, groups, old, nid, newContext, newSelector;
            if ((context ? context.ownerDocument || context : preferredDoc) !== document) {
                setDocument(context);
            }
            context = context || document;
            results = results || [];
            if (!selector || typeof selector !== 'string') {
                return results;
            }
            if ((nodeType = context.nodeType) !== 1 && nodeType !== 9) {
                return [];
            }
            if (documentIsHTML && !seed) {
                if (match = rquickExpr.exec(selector)) {
                    if (m = match[1]) {
                        if (nodeType === 9) {
                            elem = context.getElementById(m);
                            if (elem && elem.parentNode) {
                                if (elem.id === m) {
                                    results.push(elem);
                                    return results;
                                }
                            } else {
                                return results;
                            }
                        } else {
                            if (context.ownerDocument && (elem = context.ownerDocument.getElementById(m)) && contains(context, elem) && elem.id === m) {
                                results.push(elem);
                                return results;
                            }
                        }
                    } else if (match[2]) {
                        push.apply(results, context.getElementsByTagName(selector));
                        return results;
                    } else if ((m = match[3]) && support.getElementsByClassName && context.getElementsByClassName) {
                        push.apply(results, context.getElementsByClassName(m));
                        return results;
                    }
                }
                if (support.qsa && (!rbuggyQSA || !rbuggyQSA.test(selector))) {
                    nid = old = expando;
                    newContext = context;
                    newSelector = nodeType === 9 && selector;
                    if (nodeType === 1 && context.nodeName.toLowerCase() !== 'object') {
                        groups = tokenize(selector);
                        if (old = context.getAttribute('id')) {
                            nid = old.replace(rescape, '\\$&');
                        } else {
                            context.setAttribute('id', nid);
                        }
                        nid = '[id=\'' + nid + '\'] ';
                        i = groups.length;
                        while (i--) {
                            groups[i] = nid + toSelector(groups[i]);
                        }
                        newContext = rsibling.test(selector) && testContext(context.parentNode) || context;
                        newSelector = groups.join(',');
                    }
                    if (newSelector) {
                        try {
                            push.apply(results, newContext.querySelectorAll(newSelector));
                            return results;
                        } catch (qsaError) {
                        } finally {
                            if (!old) {
                                context.removeAttribute('id');
                            }
                        }
                    }
                }
            }
            return select(selector.replace(rtrim, '$1'), context, results, seed);
        }
        function createCache() {
            var keys = [];
            function cache(key, value) {
                if (keys.push(key + ' ') > Expr.cacheLength) {
                    delete cache[keys.shift()];
                }
                return cache[key + ' '] = value;
            }
            return cache;
        }
        function markFunction(fn) {
            fn[expando] = true;
            return fn;
        }
        function assert(fn) {
            var div = document.createElement('div');
            try {
                return !!fn(div);
            } catch (e) {
                return false;
            } finally {
                if (div.parentNode) {
                    div.parentNode.removeChild(div);
                }
                div = null;
            }
        }
        function addHandle(attrs, handler) {
            var arr = attrs.split('|'), i = attrs.length;
            while (i--) {
                Expr.attrHandle[arr[i]] = handler;
            }
        }
        function siblingCheck(a, b) {
            var cur = b && a, diff = cur && a.nodeType === 1 && b.nodeType === 1 && (~b.sourceIndex || MAX_NEGATIVE) - (~a.sourceIndex || MAX_NEGATIVE);
            if (diff) {
                return diff;
            }
            if (cur) {
                while (cur = cur.nextSibling) {
                    if (cur === b) {
                        return -1;
                    }
                }
            }
            return a ? 1 : -1;
        }
        function createInputPseudo(type) {
            return function (elem) {
                var name = elem.nodeName.toLowerCase();
                return name === 'input' && elem.type === type;
            };
        }
        function createButtonPseudo(type) {
            return function (elem) {
                var name = elem.nodeName.toLowerCase();
                return (name === 'input' || name === 'button') && elem.type === type;
            };
        }
        function createPositionalPseudo(fn) {
            return markFunction(function (argument) {
                argument = +argument;
                return markFunction(function (seed, matches) {
                    var j, matchIndexes = fn([], seed.length, argument), i = matchIndexes.length;
                    while (i--) {
                        if (seed[j = matchIndexes[i]]) {
                            seed[j] = !(matches[j] = seed[j]);
                        }
                    }
                });
            });
        }
        function testContext(context) {
            return context && typeof context.getElementsByTagName !== strundefined && context;
        }
        support = Sizzle.support = {};
        isXML = Sizzle.isXML = function (elem) {
            var documentElement = elem && (elem.ownerDocument || elem).documentElement;
            return documentElement ? documentElement.nodeName !== 'HTML' : false;
        };
        setDocument = Sizzle.setDocument = function (node) {
            var hasCompare, doc = node ? node.ownerDocument || node : preferredDoc, parent = doc.defaultView;
            if (doc === document || doc.nodeType !== 9 || !doc.documentElement) {
                return document;
            }
            document = doc;
            docElem = doc.documentElement;
            documentIsHTML = !isXML(doc);
            if (parent && parent !== parent.top) {
                if (parent.addEventListener) {
                    parent.addEventListener('unload', function () {
                        setDocument();
                    }, false);
                } else if (parent.attachEvent) {
                    parent.attachEvent('onunload', function () {
                        setDocument();
                    });
                }
            }
            support.attributes = assert(function (div) {
                div.className = 'i';
                return !div.getAttribute('className');
            });
            support.getElementsByTagName = assert(function (div) {
                div.appendChild(doc.createComment(''));
                return !div.getElementsByTagName('*').length;
            });
            support.getElementsByClassName = rnative.test(doc.getElementsByClassName) && assert(function (div) {
                div.innerHTML = '<div class=\'a\'></div><div class=\'a i\'></div>';
                div.firstChild.className = 'i';
                return div.getElementsByClassName('i').length === 2;
            });
            support.getById = assert(function (div) {
                docElem.appendChild(div).id = expando;
                return !doc.getElementsByName || !doc.getElementsByName(expando).length;
            });
            if (support.getById) {
                Expr.find['ID'] = function (id, context) {
                    if (typeof context.getElementById !== strundefined && documentIsHTML) {
                        var m = context.getElementById(id);
                        return m && m.parentNode ? [m] : [];
                    }
                };
                Expr.filter['ID'] = function (id) {
                    var attrId = id.replace(runescape, funescape);
                    return function (elem) {
                        return elem.getAttribute('id') === attrId;
                    };
                };
            } else {
                delete Expr.find['ID'];
                Expr.filter['ID'] = function (id) {
                    var attrId = id.replace(runescape, funescape);
                    return function (elem) {
                        var node = typeof elem.getAttributeNode !== strundefined && elem.getAttributeNode('id');
                        return node && node.value === attrId;
                    };
                };
            }
            Expr.find['TAG'] = support.getElementsByTagName ? function (tag, context) {
                if (typeof context.getElementsByTagName !== strundefined) {
                    return context.getElementsByTagName(tag);
                }
            } : function (tag, context) {
                var elem, tmp = [], i = 0, results = context.getElementsByTagName(tag);
                if (tag === '*') {
                    while (elem = results[i++]) {
                        if (elem.nodeType === 1) {
                            tmp.push(elem);
                        }
                    }
                    return tmp;
                }
                return results;
            };
            Expr.find['CLASS'] = support.getElementsByClassName && function (className, context) {
                if (typeof context.getElementsByClassName !== strundefined && documentIsHTML) {
                    return context.getElementsByClassName(className);
                }
            };
            rbuggyMatches = [];
            rbuggyQSA = [];
            if (support.qsa = rnative.test(doc.querySelectorAll)) {
                assert(function (div) {
                    div.innerHTML = '<select t=\'\'><option selected=\'\'></option></select>';
                    if (div.querySelectorAll('[t^=\'\']').length) {
                        rbuggyQSA.push('[*^$]=' + whitespace + '*(?:\'\'|"")');
                    }
                    if (!div.querySelectorAll('[selected]').length) {
                        rbuggyQSA.push('\\[' + whitespace + '*(?:value|' + booleans + ')');
                    }
                    if (!div.querySelectorAll(':checked').length) {
                        rbuggyQSA.push(':checked');
                    }
                });
                assert(function (div) {
                    var input = doc.createElement('input');
                    input.setAttribute('type', 'hidden');
                    div.appendChild(input).setAttribute('name', 'D');
                    if (div.querySelectorAll('[name=d]').length) {
                        rbuggyQSA.push('name' + whitespace + '*[*^$|!~]?=');
                    }
                    if (!div.querySelectorAll(':enabled').length) {
                        rbuggyQSA.push(':enabled', ':disabled');
                    }
                    div.querySelectorAll('*,:x');
                    rbuggyQSA.push(',.*:');
                });
            }
            if (support.matchesSelector = rnative.test(matches = docElem.webkitMatchesSelector || docElem.mozMatchesSelector || docElem.oMatchesSelector || docElem.msMatchesSelector)) {
                assert(function (div) {
                    support.disconnectedMatch = matches.call(div, 'div');
                    matches.call(div, '[s!=\'\']:x');
                    rbuggyMatches.push('!=', pseudos);
                });
            }
            rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join('|'));
            rbuggyMatches = rbuggyMatches.length && new RegExp(rbuggyMatches.join('|'));
            hasCompare = rnative.test(docElem.compareDocumentPosition);
            contains = hasCompare || rnative.test(docElem.contains) ? function (a, b) {
                var adown = a.nodeType === 9 ? a.documentElement : a, bup = b && b.parentNode;
                return a === bup || !!(bup && bup.nodeType === 1 && (adown.contains ? adown.contains(bup) : a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16));
            } : function (a, b) {
                if (b) {
                    while (b = b.parentNode) {
                        if (b === a) {
                            return true;
                        }
                    }
                }
                return false;
            };
            sortOrder = hasCompare ? function (a, b) {
                if (a === b) {
                    hasDuplicate = true;
                    return 0;
                }
                var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
                if (compare) {
                    return compare;
                }
                compare = (a.ownerDocument || a) === (b.ownerDocument || b) ? a.compareDocumentPosition(b) : 1;
                if (compare & 1 || !support.sortDetached && b.compareDocumentPosition(a) === compare) {
                    if (a === doc || a.ownerDocument === preferredDoc && contains(preferredDoc, a)) {
                        return -1;
                    }
                    if (b === doc || b.ownerDocument === preferredDoc && contains(preferredDoc, b)) {
                        return 1;
                    }
                    return sortInput ? indexOf.call(sortInput, a) - indexOf.call(sortInput, b) : 0;
                }
                return compare & 4 ? -1 : 1;
            } : function (a, b) {
                if (a === b) {
                    hasDuplicate = true;
                    return 0;
                }
                var cur, i = 0, aup = a.parentNode, bup = b.parentNode, ap = [a], bp = [b];
                if (!aup || !bup) {
                    return a === doc ? -1 : b === doc ? 1 : aup ? -1 : bup ? 1 : sortInput ? indexOf.call(sortInput, a) - indexOf.call(sortInput, b) : 0;
                } else if (aup === bup) {
                    return siblingCheck(a, b);
                }
                cur = a;
                while (cur = cur.parentNode) {
                    ap.unshift(cur);
                }
                cur = b;
                while (cur = cur.parentNode) {
                    bp.unshift(cur);
                }
                while (ap[i] === bp[i]) {
                    i++;
                }
                return i ? siblingCheck(ap[i], bp[i]) : ap[i] === preferredDoc ? -1 : bp[i] === preferredDoc ? 1 : 0;
            };
            return doc;
        };
        Sizzle.matches = function (expr, elements) {
            return Sizzle(expr, null, null, elements);
        };
        Sizzle.matchesSelector = function (elem, expr) {
            if ((elem.ownerDocument || elem) !== document) {
                setDocument(elem);
            }
            expr = expr.replace(rattributeQuotes, '=\'$1\']');
            if (support.matchesSelector && documentIsHTML && (!rbuggyMatches || !rbuggyMatches.test(expr)) && (!rbuggyQSA || !rbuggyQSA.test(expr))) {
                try {
                    var ret = matches.call(elem, expr);
                    if (ret || support.disconnectedMatch || elem.document && elem.document.nodeType !== 11) {
                        return ret;
                    }
                } catch (e) {
                }
            }
            return Sizzle(expr, document, null, [elem]).length > 0;
        };
        Sizzle.contains = function (context, elem) {
            if ((context.ownerDocument || context) !== document) {
                setDocument(context);
            }
            return contains(context, elem);
        };
        Sizzle.attr = function (elem, name) {
            if ((elem.ownerDocument || elem) !== document) {
                setDocument(elem);
            }
            var fn = Expr.attrHandle[name.toLowerCase()], val = fn && hasOwn.call(Expr.attrHandle, name.toLowerCase()) ? fn(elem, name, !documentIsHTML) : undefined;
            return val !== undefined ? val : support.attributes || !documentIsHTML ? elem.getAttribute(name) : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;
        };
        Sizzle.error = function (msg) {
            throw new Error('Syntax error, unrecognized expression: ' + msg);
        };
        Sizzle.uniqueSort = function (results) {
            var elem, duplicates = [], j = 0, i = 0;
            hasDuplicate = !support.detectDuplicates;
            sortInput = !support.sortStable && results.slice(0);
            results.sort(sortOrder);
            if (hasDuplicate) {
                while (elem = results[i++]) {
                    if (elem === results[i]) {
                        j = duplicates.push(i);
                    }
                }
                while (j--) {
                    results.splice(duplicates[j], 1);
                }
            }
            sortInput = null;
            return results;
        };
        getText = Sizzle.getText = function (elem) {
            var node, ret = '', i = 0, nodeType = elem.nodeType;
            if (!nodeType) {
                while (node = elem[i++]) {
                    ret += getText(node);
                }
            } else if (nodeType === 1 || nodeType === 9 || nodeType === 11) {
                if (typeof elem.textContent === 'string') {
                    return elem.textContent;
                } else {
                    for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
                        ret += getText(elem);
                    }
                }
            } else if (nodeType === 3 || nodeType === 4) {
                return elem.nodeValue;
            }
            return ret;
        };
        Expr = Sizzle.selectors = {
            cacheLength: 50,
            createPseudo: markFunction,
            match: matchExpr,
            attrHandle: {},
            find: {},
            relative: {
                '>': {
                    dir: 'parentNode',
                    first: true
                },
                ' ': { dir: 'parentNode' },
                '+': {
                    dir: 'previousSibling',
                    first: true
                },
                '~': { dir: 'previousSibling' }
            },
            preFilter: {
                'ATTR': function (match) {
                    match[1] = match[1].replace(runescape, funescape);
                    match[3] = (match[4] || match[5] || '').replace(runescape, funescape);
                    if (match[2] === '~=') {
                        match[3] = ' ' + match[3] + ' ';
                    }
                    return match.slice(0, 4);
                },
                'CHILD': function (match) {
                    match[1] = match[1].toLowerCase();
                    if (match[1].slice(0, 3) === 'nth') {
                        if (!match[3]) {
                            Sizzle.error(match[0]);
                        }
                        match[4] = +(match[4] ? match[5] + (match[6] || 1) : 2 * (match[3] === 'even' || match[3] === 'odd'));
                        match[5] = +(match[7] + match[8] || match[3] === 'odd');
                    } else if (match[3]) {
                        Sizzle.error(match[0]);
                    }
                    return match;
                },
                'PSEUDO': function (match) {
                    var excess, unquoted = !match[5] && match[2];
                    if (matchExpr['CHILD'].test(match[0])) {
                        return null;
                    }
                    if (match[3] && match[4] !== undefined) {
                        match[2] = match[4];
                    } else if (unquoted && rpseudo.test(unquoted) && (excess = tokenize(unquoted, true)) && (excess = unquoted.indexOf(')', unquoted.length - excess) - unquoted.length)) {
                        match[0] = match[0].slice(0, excess);
                        match[2] = unquoted.slice(0, excess);
                    }
                    return match.slice(0, 3);
                }
            },
            filter: {
                'TAG': function (nodeNameSelector) {
                    var nodeName = nodeNameSelector.replace(runescape, funescape).toLowerCase();
                    return nodeNameSelector === '*' ? function () {
                        return true;
                    } : function (elem) {
                        return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
                    };
                },
                'CLASS': function (className) {
                    var pattern = classCache[className + ' '];
                    return pattern || (pattern = new RegExp('(^|' + whitespace + ')' + className + '(' + whitespace + '|$)')) && classCache(className, function (elem) {
                        return pattern.test(typeof elem.className === 'string' && elem.className || typeof elem.getAttribute !== strundefined && elem.getAttribute('class') || '');
                    });
                },
                'ATTR': function (name, operator, check) {
                    return function (elem) {
                        var result = Sizzle.attr(elem, name);
                        if (result == null) {
                            return operator === '!=';
                        }
                        if (!operator) {
                            return true;
                        }
                        result += '';
                        return operator === '=' ? result === check : operator === '!=' ? result !== check : operator === '^=' ? check && result.indexOf(check) === 0 : operator === '*=' ? check && result.indexOf(check) > -1 : operator === '$=' ? check && result.slice(-check.length) === check : operator === '~=' ? (' ' + result + ' ').indexOf(check) > -1 : operator === '|=' ? result === check || result.slice(0, check.length + 1) === check + '-' : false;
                    };
                },
                'CHILD': function (type, what, argument, first, last) {
                    var simple = type.slice(0, 3) !== 'nth', forward = type.slice(-4) !== 'last', ofType = what === 'of-type';
                    return first === 1 && last === 0 ? function (elem) {
                        return !!elem.parentNode;
                    } : function (elem, context, xml) {
                        var cache, outerCache, node, diff, nodeIndex, start, dir = simple !== forward ? 'nextSibling' : 'previousSibling', parent = elem.parentNode, name = ofType && elem.nodeName.toLowerCase(), useCache = !xml && !ofType;
                        if (parent) {
                            if (simple) {
                                while (dir) {
                                    node = elem;
                                    while (node = node[dir]) {
                                        if (ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) {
                                            return false;
                                        }
                                    }
                                    start = dir = type === 'only' && !start && 'nextSibling';
                                }
                                return true;
                            }
                            start = [forward ? parent.firstChild : parent.lastChild];
                            if (forward && useCache) {
                                outerCache = parent[expando] || (parent[expando] = {});
                                cache = outerCache[type] || [];
                                nodeIndex = cache[0] === dirruns && cache[1];
                                diff = cache[0] === dirruns && cache[2];
                                node = nodeIndex && parent.childNodes[nodeIndex];
                                while (node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop()) {
                                    if (node.nodeType === 1 && ++diff && node === elem) {
                                        outerCache[type] = [
                                            dirruns,
                                            nodeIndex,
                                            diff
                                        ];
                                        break;
                                    }
                                }
                            } else if (useCache && (cache = (elem[expando] || (elem[expando] = {}))[type]) && cache[0] === dirruns) {
                                diff = cache[1];
                            } else {
                                while (node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop()) {
                                    if ((ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) && ++diff) {
                                        if (useCache) {
                                            (node[expando] || (node[expando] = {}))[type] = [
                                                dirruns,
                                                diff
                                            ];
                                        }
                                        if (node === elem) {
                                            break;
                                        }
                                    }
                                }
                            }
                            diff -= last;
                            return diff === first || diff % first === 0 && diff / first >= 0;
                        }
                    };
                },
                'PSEUDO': function (pseudo, argument) {
                    var args, fn = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] || Sizzle.error('unsupported pseudo: ' + pseudo);
                    if (fn[expando]) {
                        return fn(argument);
                    }
                    if (fn.length > 1) {
                        args = [
                            pseudo,
                            pseudo,
                            '',
                            argument
                        ];
                        return Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ? markFunction(function (seed, matches) {
                            var idx, matched = fn(seed, argument), i = matched.length;
                            while (i--) {
                                idx = indexOf.call(seed, matched[i]);
                                seed[idx] = !(matches[idx] = matched[i]);
                            }
                        }) : function (elem) {
                            return fn(elem, 0, args);
                        };
                    }
                    return fn;
                }
            },
            pseudos: {
                'not': markFunction(function (selector) {
                    var input = [], results = [], matcher = compile(selector.replace(rtrim, '$1'));
                    return matcher[expando] ? markFunction(function (seed, matches, context, xml) {
                        var elem, unmatched = matcher(seed, null, xml, []), i = seed.length;
                        while (i--) {
                            if (elem = unmatched[i]) {
                                seed[i] = !(matches[i] = elem);
                            }
                        }
                    }) : function (elem, context, xml) {
                        input[0] = elem;
                        matcher(input, null, xml, results);
                        return !results.pop();
                    };
                }),
                'has': markFunction(function (selector) {
                    return function (elem) {
                        return Sizzle(selector, elem).length > 0;
                    };
                }),
                'contains': markFunction(function (text) {
                    return function (elem) {
                        return (elem.textContent || elem.innerText || getText(elem)).indexOf(text) > -1;
                    };
                }),
                'lang': markFunction(function (lang) {
                    if (!ridentifier.test(lang || '')) {
                        Sizzle.error('unsupported lang: ' + lang);
                    }
                    lang = lang.replace(runescape, funescape).toLowerCase();
                    return function (elem) {
                        var elemLang;
                        do {
                            if (elemLang = documentIsHTML ? elem.lang : elem.getAttribute('xml:lang') || elem.getAttribute('lang')) {
                                elemLang = elemLang.toLowerCase();
                                return elemLang === lang || elemLang.indexOf(lang + '-') === 0;
                            }
                        } while ((elem = elem.parentNode) && elem.nodeType === 1);
                        return false;
                    };
                }),
                'target': function (elem) {
                    var hash = window.location && window.location.hash;
                    return hash && hash.slice(1) === elem.id;
                },
                'root': function (elem) {
                    return elem === docElem;
                },
                'focus': function (elem) {
                    return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
                },
                'enabled': function (elem) {
                    return elem.disabled === false;
                },
                'disabled': function (elem) {
                    return elem.disabled === true;
                },
                'checked': function (elem) {
                    var nodeName = elem.nodeName.toLowerCase();
                    return nodeName === 'input' && !!elem.checked || nodeName === 'option' && !!elem.selected;
                },
                'selected': function (elem) {
                    if (elem.parentNode) {
                        elem.parentNode.selectedIndex;
                    }
                    return elem.selected === true;
                },
                'empty': function (elem) {
                    for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
                        if (elem.nodeType < 6) {
                            return false;
                        }
                    }
                    return true;
                },
                'parent': function (elem) {
                    return !Expr.pseudos['empty'](elem);
                },
                'header': function (elem) {
                    return rheader.test(elem.nodeName);
                },
                'input': function (elem) {
                    return rinputs.test(elem.nodeName);
                },
                'button': function (elem) {
                    var name = elem.nodeName.toLowerCase();
                    return name === 'input' && elem.type === 'button' || name === 'button';
                },
                'text': function (elem) {
                    var attr;
                    return elem.nodeName.toLowerCase() === 'input' && elem.type === 'text' && ((attr = elem.getAttribute('type')) == null || attr.toLowerCase() === 'text');
                },
                'first': createPositionalPseudo(function () {
                    return [0];
                }),
                'last': createPositionalPseudo(function (matchIndexes, length) {
                    return [length - 1];
                }),
                'eq': createPositionalPseudo(function (matchIndexes, length, argument) {
                    return [argument < 0 ? argument + length : argument];
                }),
                'even': createPositionalPseudo(function (matchIndexes, length) {
                    var i = 0;
                    for (; i < length; i += 2) {
                        matchIndexes.push(i);
                    }
                    return matchIndexes;
                }),
                'odd': createPositionalPseudo(function (matchIndexes, length) {
                    var i = 1;
                    for (; i < length; i += 2) {
                        matchIndexes.push(i);
                    }
                    return matchIndexes;
                }),
                'lt': createPositionalPseudo(function (matchIndexes, length, argument) {
                    var i = argument < 0 ? argument + length : argument;
                    for (; --i >= 0;) {
                        matchIndexes.push(i);
                    }
                    return matchIndexes;
                }),
                'gt': createPositionalPseudo(function (matchIndexes, length, argument) {
                    var i = argument < 0 ? argument + length : argument;
                    for (; ++i < length;) {
                        matchIndexes.push(i);
                    }
                    return matchIndexes;
                })
            }
        };
        Expr.pseudos['nth'] = Expr.pseudos['eq'];
        for (i in {
                radio: true,
                checkbox: true,
                file: true,
                password: true,
                image: true
            }) {
            Expr.pseudos[i] = createInputPseudo(i);
        }
        for (i in {
                submit: true,
                reset: true
            }) {
            Expr.pseudos[i] = createButtonPseudo(i);
        }
        function setFilters() {
        }
        setFilters.prototype = Expr.filters = Expr.pseudos;
        Expr.setFilters = new setFilters();
        function tokenize(selector, parseOnly) {
            var matched, match, tokens, type, soFar, groups, preFilters, cached = tokenCache[selector + ' '];
            if (cached) {
                return parseOnly ? 0 : cached.slice(0);
            }
            soFar = selector;
            groups = [];
            preFilters = Expr.preFilter;
            while (soFar) {
                if (!matched || (match = rcomma.exec(soFar))) {
                    if (match) {
                        soFar = soFar.slice(match[0].length) || soFar;
                    }
                    groups.push(tokens = []);
                }
                matched = false;
                if (match = rcombinators.exec(soFar)) {
                    matched = match.shift();
                    tokens.push({
                        value: matched,
                        type: match[0].replace(rtrim, ' ')
                    });
                    soFar = soFar.slice(matched.length);
                }
                for (type in Expr.filter) {
                    if ((match = matchExpr[type].exec(soFar)) && (!preFilters[type] || (match = preFilters[type](match)))) {
                        matched = match.shift();
                        tokens.push({
                            value: matched,
                            type: type,
                            matches: match
                        });
                        soFar = soFar.slice(matched.length);
                    }
                }
                if (!matched) {
                    break;
                }
            }
            return parseOnly ? soFar.length : soFar ? Sizzle.error(selector) : tokenCache(selector, groups).slice(0);
        }
        function toSelector(tokens) {
            var i = 0, len = tokens.length, selector = '';
            for (; i < len; i++) {
                selector += tokens[i].value;
            }
            return selector;
        }
        function addCombinator(matcher, combinator, base) {
            var dir = combinator.dir, checkNonElements = base && dir === 'parentNode', doneName = done++;
            return combinator.first ? function (elem, context, xml) {
                while (elem = elem[dir]) {
                    if (elem.nodeType === 1 || checkNonElements) {
                        return matcher(elem, context, xml);
                    }
                }
            } : function (elem, context, xml) {
                var oldCache, outerCache, newCache = [
                        dirruns,
                        doneName
                    ];
                if (xml) {
                    while (elem = elem[dir]) {
                        if (elem.nodeType === 1 || checkNonElements) {
                            if (matcher(elem, context, xml)) {
                                return true;
                            }
                        }
                    }
                } else {
                    while (elem = elem[dir]) {
                        if (elem.nodeType === 1 || checkNonElements) {
                            outerCache = elem[expando] || (elem[expando] = {});
                            if ((oldCache = outerCache[dir]) && oldCache[0] === dirruns && oldCache[1] === doneName) {
                                return newCache[2] = oldCache[2];
                            } else {
                                outerCache[dir] = newCache;
                                if (newCache[2] = matcher(elem, context, xml)) {
                                    return true;
                                }
                            }
                        }
                    }
                }
            };
        }
        function elementMatcher(matchers) {
            return matchers.length > 1 ? function (elem, context, xml) {
                var i = matchers.length;
                while (i--) {
                    if (!matchers[i](elem, context, xml)) {
                        return false;
                    }
                }
                return true;
            } : matchers[0];
        }
        function condense(unmatched, map, filter, context, xml) {
            var elem, newUnmatched = [], i = 0, len = unmatched.length, mapped = map != null;
            for (; i < len; i++) {
                if (elem = unmatched[i]) {
                    if (!filter || filter(elem, context, xml)) {
                        newUnmatched.push(elem);
                        if (mapped) {
                            map.push(i);
                        }
                    }
                }
            }
            return newUnmatched;
        }
        function setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {
            if (postFilter && !postFilter[expando]) {
                postFilter = setMatcher(postFilter);
            }
            if (postFinder && !postFinder[expando]) {
                postFinder = setMatcher(postFinder, postSelector);
            }
            return markFunction(function (seed, results, context, xml) {
                var temp, i, elem, preMap = [], postMap = [], preexisting = results.length, elems = seed || multipleContexts(selector || '*', context.nodeType ? [context] : context, []), matcherIn = preFilter && (seed || !selector) ? condense(elems, preMap, preFilter, context, xml) : elems, matcherOut = matcher ? postFinder || (seed ? preFilter : preexisting || postFilter) ? [] : results : matcherIn;
                if (matcher) {
                    matcher(matcherIn, matcherOut, context, xml);
                }
                if (postFilter) {
                    temp = condense(matcherOut, postMap);
                    postFilter(temp, [], context, xml);
                    i = temp.length;
                    while (i--) {
                        if (elem = temp[i]) {
                            matcherOut[postMap[i]] = !(matcherIn[postMap[i]] = elem);
                        }
                    }
                }
                if (seed) {
                    if (postFinder || preFilter) {
                        if (postFinder) {
                            temp = [];
                            i = matcherOut.length;
                            while (i--) {
                                if (elem = matcherOut[i]) {
                                    temp.push(matcherIn[i] = elem);
                                }
                            }
                            postFinder(null, matcherOut = [], temp, xml);
                        }
                        i = matcherOut.length;
                        while (i--) {
                            if ((elem = matcherOut[i]) && (temp = postFinder ? indexOf.call(seed, elem) : preMap[i]) > -1) {
                                seed[temp] = !(results[temp] = elem);
                            }
                        }
                    }
                } else {
                    matcherOut = condense(matcherOut === results ? matcherOut.splice(preexisting, matcherOut.length) : matcherOut);
                    if (postFinder) {
                        postFinder(null, results, matcherOut, xml);
                    } else {
                        push.apply(results, matcherOut);
                    }
                }
            });
        }
        function matcherFromTokens(tokens) {
            var checkContext, matcher, j, len = tokens.length, leadingRelative = Expr.relative[tokens[0].type], implicitRelative = leadingRelative || Expr.relative[' '], i = leadingRelative ? 1 : 0, matchContext = addCombinator(function (elem) {
                    return elem === checkContext;
                }, implicitRelative, true), matchAnyContext = addCombinator(function (elem) {
                    return indexOf.call(checkContext, elem) > -1;
                }, implicitRelative, true), matchers = [function (elem, context, xml) {
                        return !leadingRelative && (xml || context !== outermostContext) || ((checkContext = context).nodeType ? matchContext(elem, context, xml) : matchAnyContext(elem, context, xml));
                    }];
            for (; i < len; i++) {
                if (matcher = Expr.relative[tokens[i].type]) {
                    matchers = [addCombinator(elementMatcher(matchers), matcher)];
                } else {
                    matcher = Expr.filter[tokens[i].type].apply(null, tokens[i].matches);
                    if (matcher[expando]) {
                        j = ++i;
                        for (; j < len; j++) {
                            if (Expr.relative[tokens[j].type]) {
                                break;
                            }
                        }
                        return setMatcher(i > 1 && elementMatcher(matchers), i > 1 && toSelector(tokens.slice(0, i - 1).concat({ value: tokens[i - 2].type === ' ' ? '*' : '' })).replace(rtrim, '$1'), matcher, i < j && matcherFromTokens(tokens.slice(i, j)), j < len && matcherFromTokens(tokens = tokens.slice(j)), j < len && toSelector(tokens));
                    }
                    matchers.push(matcher);
                }
            }
            return elementMatcher(matchers);
        }
        function matcherFromGroupMatchers(elementMatchers, setMatchers) {
            var bySet = setMatchers.length > 0, byElement = elementMatchers.length > 0, superMatcher = function (seed, context, xml, results, outermost) {
                    var elem, j, matcher, matchedCount = 0, i = '0', unmatched = seed && [], setMatched = [], contextBackup = outermostContext, elems = seed || byElement && Expr.find['TAG']('*', outermost), dirrunsUnique = dirruns += contextBackup == null ? 1 : Math.random() || 0.1, len = elems.length;
                    if (outermost) {
                        outermostContext = context !== document && context;
                    }
                    for (; i !== len && (elem = elems[i]) != null; i++) {
                        if (byElement && elem) {
                            j = 0;
                            while (matcher = elementMatchers[j++]) {
                                if (matcher(elem, context, xml)) {
                                    results.push(elem);
                                    break;
                                }
                            }
                            if (outermost) {
                                dirruns = dirrunsUnique;
                            }
                        }
                        if (bySet) {
                            if (elem = !matcher && elem) {
                                matchedCount--;
                            }
                            if (seed) {
                                unmatched.push(elem);
                            }
                        }
                    }
                    matchedCount += i;
                    if (bySet && i !== matchedCount) {
                        j = 0;
                        while (matcher = setMatchers[j++]) {
                            matcher(unmatched, setMatched, context, xml);
                        }
                        if (seed) {
                            if (matchedCount > 0) {
                                while (i--) {
                                    if (!(unmatched[i] || setMatched[i])) {
                                        setMatched[i] = pop.call(results);
                                    }
                                }
                            }
                            setMatched = condense(setMatched);
                        }
                        push.apply(results, setMatched);
                        if (outermost && !seed && setMatched.length > 0 && matchedCount + setMatchers.length > 1) {
                            Sizzle.uniqueSort(results);
                        }
                    }
                    if (outermost) {
                        dirruns = dirrunsUnique;
                        outermostContext = contextBackup;
                    }
                    return unmatched;
                };
            return bySet ? markFunction(superMatcher) : superMatcher;
        }
        compile = Sizzle.compile = function (selector, group) {
            var i, setMatchers = [], elementMatchers = [], cached = compilerCache[selector + ' '];
            if (!cached) {
                if (!group) {
                    group = tokenize(selector);
                }
                i = group.length;
                while (i--) {
                    cached = matcherFromTokens(group[i]);
                    if (cached[expando]) {
                        setMatchers.push(cached);
                    } else {
                        elementMatchers.push(cached);
                    }
                }
                cached = compilerCache(selector, matcherFromGroupMatchers(elementMatchers, setMatchers));
            }
            return cached;
        };
        function multipleContexts(selector, contexts, results) {
            var i = 0, len = contexts.length;
            for (; i < len; i++) {
                Sizzle(selector, contexts[i], results);
            }
            return results;
        }
        function select(selector, context, results, seed) {
            var i, tokens, token, type, find, match = tokenize(selector);
            if (!seed) {
                if (match.length === 1) {
                    tokens = match[0] = match[0].slice(0);
                    if (tokens.length > 2 && (token = tokens[0]).type === 'ID' && support.getById && context.nodeType === 9 && documentIsHTML && Expr.relative[tokens[1].type]) {
                        context = (Expr.find['ID'](token.matches[0].replace(runescape, funescape), context) || [])[0];
                        if (!context) {
                            return results;
                        }
                        selector = selector.slice(tokens.shift().value.length);
                    }
                    i = matchExpr['needsContext'].test(selector) ? 0 : tokens.length;
                    while (i--) {
                        token = tokens[i];
                        if (Expr.relative[type = token.type]) {
                            break;
                        }
                        if (find = Expr.find[type]) {
                            if (seed = find(token.matches[0].replace(runescape, funescape), rsibling.test(tokens[0].type) && testContext(context.parentNode) || context)) {
                                tokens.splice(i, 1);
                                selector = seed.length && toSelector(tokens);
                                if (!selector) {
                                    push.apply(results, seed);
                                    return results;
                                }
                                break;
                            }
                        }
                    }
                }
            }
            compile(selector, match)(seed, context, !documentIsHTML, results, rsibling.test(selector) && testContext(context.parentNode) || context);
            return results;
        }
        support.sortStable = expando.split('').sort(sortOrder).join('') === expando;
        support.detectDuplicates = !!hasDuplicate;
        setDocument();
        support.sortDetached = assert(function (div1) {
            return div1.compareDocumentPosition(document.createElement('div')) & 1;
        });
        if (!assert(function (div) {
                div.innerHTML = '<a href=\'#\'></a>';
                return div.firstChild.getAttribute('href') === '#';
            })) {
            addHandle('type|href|height|width', function (elem, name, isXML) {
                if (!isXML) {
                    return elem.getAttribute(name, name.toLowerCase() === 'type' ? 1 : 2);
                }
            });
        }
        if (!support.attributes || !assert(function (div) {
                div.innerHTML = '<input/>';
                div.firstChild.setAttribute('value', '');
                return div.firstChild.getAttribute('value') === '';
            })) {
            addHandle('value', function (elem, name, isXML) {
                if (!isXML && elem.nodeName.toLowerCase() === 'input') {
                    return elem.defaultValue;
                }
            });
        }
        if (!assert(function (div) {
                return div.getAttribute('disabled') == null;
            })) {
            addHandle(booleans, function (elem, name, isXML) {
                var val;
                if (!isXML) {
                    return elem[name] === true ? name.toLowerCase() : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;
                }
            });
        }
        return Sizzle;
    }(window);
    jQuery.find = Sizzle;
    jQuery.expr = Sizzle.selectors;
    jQuery.expr[':'] = jQuery.expr.pseudos;
    jQuery.unique = Sizzle.uniqueSort;
    jQuery.text = Sizzle.getText;
    jQuery.isXMLDoc = Sizzle.isXML;
    jQuery.contains = Sizzle.contains;
    var rneedsContext = jQuery.expr.match.needsContext;
    var rsingleTag = /^<(\w+)\s*\/?>(?:<\/\1>|)$/;
    var risSimple = /^.[^:#\[\.,]*$/;
    function winnow(elements, qualifier, not) {
        if (jQuery.isFunction(qualifier)) {
            return jQuery.grep(elements, function (elem, i) {
                return !!qualifier.call(elem, i, elem) !== not;
            });
        }
        if (qualifier.nodeType) {
            return jQuery.grep(elements, function (elem) {
                return elem === qualifier !== not;
            });
        }
        if (typeof qualifier === 'string') {
            if (risSimple.test(qualifier)) {
                return jQuery.filter(qualifier, elements, not);
            }
            qualifier = jQuery.filter(qualifier, elements);
        }
        return jQuery.grep(elements, function (elem) {
            return jQuery.inArray(elem, qualifier) >= 0 !== not;
        });
    }
    jQuery.filter = function (expr, elems, not) {
        var elem = elems[0];
        if (not) {
            expr = ':not(' + expr + ')';
        }
        return elems.length === 1 && elem.nodeType === 1 ? jQuery.find.matchesSelector(elem, expr) ? [elem] : [] : jQuery.find.matches(expr, jQuery.grep(elems, function (elem) {
            return elem.nodeType === 1;
        }));
    };
    jQuery.fn.extend({
        find: function (selector) {
            var i, ret = [], self = this, len = self.length;
            if (typeof selector !== 'string') {
                return this.pushStack(jQuery(selector).filter(function () {
                    for (i = 0; i < len; i++) {
                        if (jQuery.contains(self[i], this)) {
                            return true;
                        }
                    }
                }));
            }
            for (i = 0; i < len; i++) {
                jQuery.find(selector, self[i], ret);
            }
            ret = this.pushStack(len > 1 ? jQuery.unique(ret) : ret);
            ret.selector = this.selector ? this.selector + ' ' + selector : selector;
            return ret;
        },
        filter: function (selector) {
            return this.pushStack(winnow(this, selector || [], false));
        },
        not: function (selector) {
            return this.pushStack(winnow(this, selector || [], true));
        },
        is: function (selector) {
            return !!winnow(this, typeof selector === 'string' && rneedsContext.test(selector) ? jQuery(selector) : selector || [], false).length;
        }
    });
    var rootjQuery, document = window.document, rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/, init = jQuery.fn.init = function (selector, context) {
            var match, elem;
            if (!selector) {
                return this;
            }
            if (typeof selector === 'string') {
                if (selector.charAt(0) === '<' && selector.charAt(selector.length - 1) === '>' && selector.length >= 3) {
                    match = [
                        null,
                        selector,
                        null
                    ];
                } else {
                    match = rquickExpr.exec(selector);
                }
                if (match && (match[1] || !context)) {
                    if (match[1]) {
                        context = context instanceof jQuery ? context[0] : context;
                        jQuery.merge(this, jQuery.parseHTML(match[1], context && context.nodeType ? context.ownerDocument || context : document, true));
                        if (rsingleTag.test(match[1]) && jQuery.isPlainObject(context)) {
                            for (match in context) {
                                if (jQuery.isFunction(this[match])) {
                                    this[match](context[match]);
                                } else {
                                    this.attr(match, context[match]);
                                }
                            }
                        }
                        return this;
                    } else {
                        elem = document.getElementById(match[2]);
                        if (elem && elem.parentNode) {
                            if (elem.id !== match[2]) {
                                return rootjQuery.find(selector);
                            }
                            this.length = 1;
                            this[0] = elem;
                        }
                        this.context = document;
                        this.selector = selector;
                        return this;
                    }
                } else if (!context || context.jquery) {
                    return (context || rootjQuery).find(selector);
                } else {
                    return this.constructor(context).find(selector);
                }
            } else if (selector.nodeType) {
                this.context = this[0] = selector;
                this.length = 1;
                return this;
            } else if (jQuery.isFunction(selector)) {
                return typeof rootjQuery.ready !== 'undefined' ? rootjQuery.ready(selector) : selector(jQuery);
            }
            if (selector.selector !== undefined) {
                this.selector = selector.selector;
                this.context = selector.context;
            }
            return jQuery.makeArray(selector, this);
        };
    init.prototype = jQuery.fn;
    rootjQuery = jQuery(document);
    var rparentsprev = /^(?:parents|prev(?:Until|All))/, guaranteedUnique = {
            children: true,
            contents: true,
            next: true,
            prev: true
        };
    jQuery.extend({
        dir: function (elem, dir, until) {
            var matched = [], cur = elem[dir];
            while (cur && cur.nodeType !== 9 && (until === undefined || cur.nodeType !== 1 || !jQuery(cur).is(until))) {
                if (cur.nodeType === 1) {
                    matched.push(cur);
                }
                cur = cur[dir];
            }
            return matched;
        },
        sibling: function (n, elem) {
            var r = [];
            for (; n; n = n.nextSibling) {
                if (n.nodeType === 1 && n !== elem) {
                    r.push(n);
                }
            }
            return r;
        }
    });
    jQuery.fn.extend({
        has: function (target) {
            var i, targets = jQuery(target, this), len = targets.length;
            return this.filter(function () {
                for (i = 0; i < len; i++) {
                    if (jQuery.contains(this, targets[i])) {
                        return true;
                    }
                }
            });
        },
        closest: function (selectors, context) {
            var cur, i = 0, l = this.length, matched = [], pos = rneedsContext.test(selectors) || typeof selectors !== 'string' ? jQuery(selectors, context || this.context) : 0;
            for (; i < l; i++) {
                for (cur = this[i]; cur && cur !== context; cur = cur.parentNode) {
                    if (cur.nodeType < 11 && (pos ? pos.index(cur) > -1 : cur.nodeType === 1 && jQuery.find.matchesSelector(cur, selectors))) {
                        matched.push(cur);
                        break;
                    }
                }
            }
            return this.pushStack(matched.length > 1 ? jQuery.unique(matched) : matched);
        },
        index: function (elem) {
            if (!elem) {
                return this[0] && this[0].parentNode ? this.first().prevAll().length : -1;
            }
            if (typeof elem === 'string') {
                return jQuery.inArray(this[0], jQuery(elem));
            }
            return jQuery.inArray(elem.jquery ? elem[0] : elem, this);
        },
        add: function (selector, context) {
            return this.pushStack(jQuery.unique(jQuery.merge(this.get(), jQuery(selector, context))));
        },
        addBack: function (selector) {
            return this.add(selector == null ? this.prevObject : this.prevObject.filter(selector));
        }
    });
    function sibling(cur, dir) {
        do {
            cur = cur[dir];
        } while (cur && cur.nodeType !== 1);
        return cur;
    }
    jQuery.each({
        parent: function (elem) {
            var parent = elem.parentNode;
            return parent && parent.nodeType !== 11 ? parent : null;
        },
        parents: function (elem) {
            return jQuery.dir(elem, 'parentNode');
        },
        parentsUntil: function (elem, i, until) {
            return jQuery.dir(elem, 'parentNode', until);
        },
        next: function (elem) {
            return sibling(elem, 'nextSibling');
        },
        prev: function (elem) {
            return sibling(elem, 'previousSibling');
        },
        nextAll: function (elem) {
            return jQuery.dir(elem, 'nextSibling');
        },
        prevAll: function (elem) {
            return jQuery.dir(elem, 'previousSibling');
        },
        nextUntil: function (elem, i, until) {
            return jQuery.dir(elem, 'nextSibling', until);
        },
        prevUntil: function (elem, i, until) {
            return jQuery.dir(elem, 'previousSibling', until);
        },
        siblings: function (elem) {
            return jQuery.sibling((elem.parentNode || {}).firstChild, elem);
        },
        children: function (elem) {
            return jQuery.sibling(elem.firstChild);
        },
        contents: function (elem) {
            return jQuery.nodeName(elem, 'iframe') ? elem.contentDocument || elem.contentWindow.document : jQuery.merge([], elem.childNodes);
        }
    }, function (name, fn) {
        jQuery.fn[name] = function (until, selector) {
            var ret = jQuery.map(this, fn, until);
            if (name.slice(-5) !== 'Until') {
                selector = until;
            }
            if (selector && typeof selector === 'string') {
                ret = jQuery.filter(selector, ret);
            }
            if (this.length > 1) {
                if (!guaranteedUnique[name]) {
                    ret = jQuery.unique(ret);
                }
                if (rparentsprev.test(name)) {
                    ret = ret.reverse();
                }
            }
            return this.pushStack(ret);
        };
    });
    var rnotwhite = /\S+/g;
    var optionsCache = {};
    function createOptions(options) {
        var object = optionsCache[options] = {};
        jQuery.each(options.match(rnotwhite) || [], function (_, flag) {
            object[flag] = true;
        });
        return object;
    }
    jQuery.Callbacks = function (options) {
        options = typeof options === 'string' ? optionsCache[options] || createOptions(options) : jQuery.extend({}, options);
        var firing, memory, fired, firingLength, firingIndex, firingStart, list = [], stack = !options.once && [], fire = function (data) {
                memory = options.memory && data;
                fired = true;
                firingIndex = firingStart || 0;
                firingStart = 0;
                firingLength = list.length;
                firing = true;
                for (; list && firingIndex < firingLength; firingIndex++) {
                    if (list[firingIndex].apply(data[0], data[1]) === false && options.stopOnFalse) {
                        memory = false;
                        break;
                    }
                }
                firing = false;
                if (list) {
                    if (stack) {
                        if (stack.length) {
                            fire(stack.shift());
                        }
                    } else if (memory) {
                        list = [];
                    } else {
                        self.disable();
                    }
                }
            }, self = {
                add: function () {
                    if (list) {
                        var start = list.length;
                        (function add(args) {
                            jQuery.each(args, function (_, arg) {
                                var type = jQuery.type(arg);
                                if (type === 'function') {
                                    if (!options.unique || !self.has(arg)) {
                                        list.push(arg);
                                    }
                                } else if (arg && arg.length && type !== 'string') {
                                    add(arg);
                                }
                            });
                        }(arguments));
                        if (firing) {
                            firingLength = list.length;
                        } else if (memory) {
                            firingStart = start;
                            fire(memory);
                        }
                    }
                    return this;
                },
                remove: function () {
                    if (list) {
                        jQuery.each(arguments, function (_, arg) {
                            var index;
                            while ((index = jQuery.inArray(arg, list, index)) > -1) {
                                list.splice(index, 1);
                                if (firing) {
                                    if (index <= firingLength) {
                                        firingLength--;
                                    }
                                    if (index <= firingIndex) {
                                        firingIndex--;
                                    }
                                }
                            }
                        });
                    }
                    return this;
                },
                has: function (fn) {
                    return fn ? jQuery.inArray(fn, list) > -1 : !!(list && list.length);
                },
                empty: function () {
                    list = [];
                    firingLength = 0;
                    return this;
                },
                disable: function () {
                    list = stack = memory = undefined;
                    return this;
                },
                disabled: function () {
                    return !list;
                },
                lock: function () {
                    stack = undefined;
                    if (!memory) {
                        self.disable();
                    }
                    return this;
                },
                locked: function () {
                    return !stack;
                },
                fireWith: function (context, args) {
                    if (list && (!fired || stack)) {
                        args = args || [];
                        args = [
                            context,
                            args.slice ? args.slice() : args
                        ];
                        if (firing) {
                            stack.push(args);
                        } else {
                            fire(args);
                        }
                    }
                    return this;
                },
                fire: function () {
                    self.fireWith(this, arguments);
                    return this;
                },
                fired: function () {
                    return !!fired;
                }
            };
        return self;
    };
    jQuery.extend({
        Deferred: function (func) {
            var tuples = [
                    [
                        'resolve',
                        'done',
                        jQuery.Callbacks('once memory'),
                        'resolved'
                    ],
                    [
                        'reject',
                        'fail',
                        jQuery.Callbacks('once memory'),
                        'rejected'
                    ],
                    [
                        'notify',
                        'progress',
                        jQuery.Callbacks('memory')
                    ]
                ], state = 'pending', promise = {
                    state: function () {
                        return state;
                    },
                    always: function () {
                        deferred.done(arguments).fail(arguments);
                        return this;
                    },
                    then: function () {
                        var fns = arguments;
                        return jQuery.Deferred(function (newDefer) {
                            jQuery.each(tuples, function (i, tuple) {
                                var fn = jQuery.isFunction(fns[i]) && fns[i];
                                deferred[tuple[1]](function () {
                                    var returned = fn && fn.apply(this, arguments);
                                    if (returned && jQuery.isFunction(returned.promise)) {
                                        returned.promise().done(newDefer.resolve).fail(newDefer.reject).progress(newDefer.notify);
                                    } else {
                                        newDefer[tuple[0] + 'With'](this === promise ? newDefer.promise() : this, fn ? [returned] : arguments);
                                    }
                                });
                            });
                            fns = null;
                        }).promise();
                    },
                    promise: function (obj) {
                        return obj != null ? jQuery.extend(obj, promise) : promise;
                    }
                }, deferred = {};
            promise.pipe = promise.then;
            jQuery.each(tuples, function (i, tuple) {
                var list = tuple[2], stateString = tuple[3];
                promise[tuple[1]] = list.add;
                if (stateString) {
                    list.add(function () {
                        state = stateString;
                    }, tuples[i ^ 1][2].disable, tuples[2][2].lock);
                }
                deferred[tuple[0]] = function () {
                    deferred[tuple[0] + 'With'](this === deferred ? promise : this, arguments);
                    return this;
                };
                deferred[tuple[0] + 'With'] = list.fireWith;
            });
            promise.promise(deferred);
            if (func) {
                func.call(deferred, deferred);
            }
            return deferred;
        },
        when: function (subordinate) {
            var i = 0, resolveValues = slice.call(arguments), length = resolveValues.length, remaining = length !== 1 || subordinate && jQuery.isFunction(subordinate.promise) ? length : 0, deferred = remaining === 1 ? subordinate : jQuery.Deferred(), updateFunc = function (i, contexts, values) {
                    return function (value) {
                        contexts[i] = this;
                        values[i] = arguments.length > 1 ? slice.call(arguments) : value;
                        if (values === progressValues) {
                            deferred.notifyWith(contexts, values);
                        } else if (!--remaining) {
                            deferred.resolveWith(contexts, values);
                        }
                    };
                }, progressValues, progressContexts, resolveContexts;
            if (length > 1) {
                progressValues = new Array(length);
                progressContexts = new Array(length);
                resolveContexts = new Array(length);
                for (; i < length; i++) {
                    if (resolveValues[i] && jQuery.isFunction(resolveValues[i].promise)) {
                        resolveValues[i].promise().done(updateFunc(i, resolveContexts, resolveValues)).fail(deferred.reject).progress(updateFunc(i, progressContexts, progressValues));
                    } else {
                        --remaining;
                    }
                }
            }
            if (!remaining) {
                deferred.resolveWith(resolveContexts, resolveValues);
            }
            return deferred.promise();
        }
    });
    var readyList;
    jQuery.fn.ready = function (fn) {
        jQuery.ready.promise().done(fn);
        return this;
    };
    jQuery.extend({
        isReady: false,
        readyWait: 1,
        holdReady: function (hold) {
            if (hold) {
                jQuery.readyWait++;
            } else {
                jQuery.ready(true);
            }
        },
        ready: function (wait) {
            if (wait === true ? --jQuery.readyWait : jQuery.isReady) {
                return;
            }
            if (!document.body) {
                return setTimeout(jQuery.ready);
            }
            jQuery.isReady = true;
            if (wait !== true && --jQuery.readyWait > 0) {
                return;
            }
            readyList.resolveWith(document, [jQuery]);
            if (jQuery.fn.trigger) {
                jQuery(document).trigger('ready').off('ready');
            }
        }
    });
    function detach() {
        if (document.addEventListener) {
            document.removeEventListener('DOMContentLoaded', completed, false);
            window.removeEventListener('load', completed, false);
        } else {
            document.detachEvent('onreadystatechange', completed);
            window.detachEvent('onload', completed);
        }
    }
    function completed() {
        if (document.addEventListener || event.type === 'load' || document.readyState === 'complete') {
            detach();
            jQuery.ready();
        }
    }
    jQuery.ready.promise = function (obj) {
        if (!readyList) {
            readyList = jQuery.Deferred();
            if (document.readyState === 'complete') {
                setTimeout(jQuery.ready);
            } else if (document.addEventListener) {
                document.addEventListener('DOMContentLoaded', completed, false);
                window.addEventListener('load', completed, false);
            } else {
                document.attachEvent('onreadystatechange', completed);
                window.attachEvent('onload', completed);
                var top = false;
                try {
                    top = window.frameElement == null && document.documentElement;
                } catch (e) {
                }
                if (top && top.doScroll) {
                    (function doScrollCheck() {
                        if (!jQuery.isReady) {
                            try {
                                top.doScroll('left');
                            } catch (e) {
                                return setTimeout(doScrollCheck, 50);
                            }
                            detach();
                            jQuery.ready();
                        }
                    }());
                }
            }
        }
        return readyList.promise(obj);
    };
    var strundefined = typeof undefined;
    var i;
    for (i in jQuery(support)) {
        break;
    }
    support.ownLast = i !== '0';
    support.inlineBlockNeedsLayout = false;
    jQuery(function () {
        var container, div, body = document.getElementsByTagName('body')[0];
        if (!body) {
            return;
        }
        container = document.createElement('div');
        container.style.cssText = 'border:0;width:0;height:0;position:absolute;top:0;left:-9999px;margin-top:1px';
        div = document.createElement('div');
        body.appendChild(container).appendChild(div);
        if (typeof div.style.zoom !== strundefined) {
            div.style.cssText = 'border:0;margin:0;width:1px;padding:1px;display:inline;zoom:1';
            if (support.inlineBlockNeedsLayout = div.offsetWidth === 3) {
                body.style.zoom = 1;
            }
        }
        body.removeChild(container);
        container = div = null;
    });
    (function () {
        var div = document.createElement('div');
        if (support.deleteExpando == null) {
            support.deleteExpando = true;
            try {
                delete div.test;
            } catch (e) {
                support.deleteExpando = false;
            }
        }
        div = null;
    }());
    jQuery.acceptData = function (elem) {
        var noData = jQuery.noData[(elem.nodeName + ' ').toLowerCase()], nodeType = +elem.nodeType || 1;
        return nodeType !== 1 && nodeType !== 9 ? false : !noData || noData !== true && elem.getAttribute('classid') === noData;
    };
    var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/, rmultiDash = /([A-Z])/g;
    function dataAttr(elem, key, data) {
        if (data === undefined && elem.nodeType === 1) {
            var name = 'data-' + key.replace(rmultiDash, '-$1').toLowerCase();
            data = elem.getAttribute(name);
            if (typeof data === 'string') {
                try {
                    data = data === 'true' ? true : data === 'false' ? false : data === 'null' ? null : +data + '' === data ? +data : rbrace.test(data) ? jQuery.parseJSON(data) : data;
                } catch (e) {
                }
                jQuery.data(elem, key, data);
            } else {
                data = undefined;
            }
        }
        return data;
    }
    function isEmptyDataObject(obj) {
        var name;
        for (name in obj) {
            if (name === 'data' && jQuery.isEmptyObject(obj[name])) {
                continue;
            }
            if (name !== 'toJSON') {
                return false;
            }
        }
        return true;
    }
    function internalData(elem, name, data, pvt) {
        if (!jQuery.acceptData(elem)) {
            return;
        }
        var ret, thisCache, internalKey = jQuery.expando, isNode = elem.nodeType, cache = isNode ? jQuery.cache : elem, id = isNode ? elem[internalKey] : elem[internalKey] && internalKey;
        if ((!id || !cache[id] || !pvt && !cache[id].data) && data === undefined && typeof name === 'string') {
            return;
        }
        if (!id) {
            if (isNode) {
                id = elem[internalKey] = deletedIds.pop() || jQuery.guid++;
            } else {
                id = internalKey;
            }
        }
        if (!cache[id]) {
            cache[id] = isNode ? {} : { toJSON: jQuery.noop };
        }
        if (typeof name === 'object' || typeof name === 'function') {
            if (pvt) {
                cache[id] = jQuery.extend(cache[id], name);
            } else {
                cache[id].data = jQuery.extend(cache[id].data, name);
            }
        }
        thisCache = cache[id];
        if (!pvt) {
            if (!thisCache.data) {
                thisCache.data = {};
            }
            thisCache = thisCache.data;
        }
        if (data !== undefined) {
            thisCache[jQuery.camelCase(name)] = data;
        }
        if (typeof name === 'string') {
            ret = thisCache[name];
            if (ret == null) {
                ret = thisCache[jQuery.camelCase(name)];
            }
        } else {
            ret = thisCache;
        }
        return ret;
    }
    function internalRemoveData(elem, name, pvt) {
        if (!jQuery.acceptData(elem)) {
            return;
        }
        var thisCache, i, isNode = elem.nodeType, cache = isNode ? jQuery.cache : elem, id = isNode ? elem[jQuery.expando] : jQuery.expando;
        if (!cache[id]) {
            return;
        }
        if (name) {
            thisCache = pvt ? cache[id] : cache[id].data;
            if (thisCache) {
                if (!jQuery.isArray(name)) {
                    if (name in thisCache) {
                        name = [name];
                    } else {
                        name = jQuery.camelCase(name);
                        if (name in thisCache) {
                            name = [name];
                        } else {
                            name = name.split(' ');
                        }
                    }
                } else {
                    name = name.concat(jQuery.map(name, jQuery.camelCase));
                }
                i = name.length;
                while (i--) {
                    delete thisCache[name[i]];
                }
                if (pvt ? !isEmptyDataObject(thisCache) : !jQuery.isEmptyObject(thisCache)) {
                    return;
                }
            }
        }
        if (!pvt) {
            delete cache[id].data;
            if (!isEmptyDataObject(cache[id])) {
                return;
            }
        }
        if (isNode) {
            jQuery.cleanData([elem], true);
        } else if (support.deleteExpando || cache != cache.window) {
            delete cache[id];
        } else {
            cache[id] = null;
        }
    }
    jQuery.extend({
        cache: {},
        noData: {
            'applet ': true,
            'embed ': true,
            'object ': 'clsid:D27CDB6E-AE6D-11cf-96B8-444553540000'
        },
        hasData: function (elem) {
            elem = elem.nodeType ? jQuery.cache[elem[jQuery.expando]] : elem[jQuery.expando];
            return !!elem && !isEmptyDataObject(elem);
        },
        data: function (elem, name, data) {
            return internalData(elem, name, data);
        },
        removeData: function (elem, name) {
            return internalRemoveData(elem, name);
        },
        _data: function (elem, name, data) {
            return internalData(elem, name, data, true);
        },
        _removeData: function (elem, name) {
            return internalRemoveData(elem, name, true);
        }
    });
    jQuery.fn.extend({
        data: function (key, value) {
            var i, name, data, elem = this[0], attrs = elem && elem.attributes;
            if (key === undefined) {
                if (this.length) {
                    data = jQuery.data(elem);
                    if (elem.nodeType === 1 && !jQuery._data(elem, 'parsedAttrs')) {
                        i = attrs.length;
                        while (i--) {
                            name = attrs[i].name;
                            if (name.indexOf('data-') === 0) {
                                name = jQuery.camelCase(name.slice(5));
                                dataAttr(elem, name, data[name]);
                            }
                        }
                        jQuery._data(elem, 'parsedAttrs', true);
                    }
                }
                return data;
            }
            if (typeof key === 'object') {
                return this.each(function () {
                    jQuery.data(this, key);
                });
            }
            return arguments.length > 1 ? this.each(function () {
                jQuery.data(this, key, value);
            }) : elem ? dataAttr(elem, key, jQuery.data(elem, key)) : undefined;
        },
        removeData: function (key) {
            return this.each(function () {
                jQuery.removeData(this, key);
            });
        }
    });
    jQuery.extend({
        queue: function (elem, type, data) {
            var queue;
            if (elem) {
                type = (type || 'fx') + 'queue';
                queue = jQuery._data(elem, type);
                if (data) {
                    if (!queue || jQuery.isArray(data)) {
                        queue = jQuery._data(elem, type, jQuery.makeArray(data));
                    } else {
                        queue.push(data);
                    }
                }
                return queue || [];
            }
        },
        dequeue: function (elem, type) {
            type = type || 'fx';
            var queue = jQuery.queue(elem, type), startLength = queue.length, fn = queue.shift(), hooks = jQuery._queueHooks(elem, type), next = function () {
                    jQuery.dequeue(elem, type);
                };
            if (fn === 'inprogress') {
                fn = queue.shift();
                startLength--;
            }
            if (fn) {
                if (type === 'fx') {
                    queue.unshift('inprogress');
                }
                delete hooks.stop;
                fn.call(elem, next, hooks);
            }
            if (!startLength && hooks) {
                hooks.empty.fire();
            }
        },
        _queueHooks: function (elem, type) {
            var key = type + 'queueHooks';
            return jQuery._data(elem, key) || jQuery._data(elem, key, {
                empty: jQuery.Callbacks('once memory').add(function () {
                    jQuery._removeData(elem, type + 'queue');
                    jQuery._removeData(elem, key);
                })
            });
        }
    });
    jQuery.fn.extend({
        queue: function (type, data) {
            var setter = 2;
            if (typeof type !== 'string') {
                data = type;
                type = 'fx';
                setter--;
            }
            if (arguments.length < setter) {
                return jQuery.queue(this[0], type);
            }
            return data === undefined ? this : this.each(function () {
                var queue = jQuery.queue(this, type, data);
                jQuery._queueHooks(this, type);
                if (type === 'fx' && queue[0] !== 'inprogress') {
                    jQuery.dequeue(this, type);
                }
            });
        },
        dequeue: function (type) {
            return this.each(function () {
                jQuery.dequeue(this, type);
            });
        },
        clearQueue: function (type) {
            return this.queue(type || 'fx', []);
        },
        promise: function (type, obj) {
            var tmp, count = 1, defer = jQuery.Deferred(), elements = this, i = this.length, resolve = function () {
                    if (!--count) {
                        defer.resolveWith(elements, [elements]);
                    }
                };
            if (typeof type !== 'string') {
                obj = type;
                type = undefined;
            }
            type = type || 'fx';
            while (i--) {
                tmp = jQuery._data(elements[i], type + 'queueHooks');
                if (tmp && tmp.empty) {
                    count++;
                    tmp.empty.add(resolve);
                }
            }
            resolve();
            return defer.promise(obj);
        }
    });
    var pnum = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source;
    var cssExpand = [
        'Top',
        'Right',
        'Bottom',
        'Left'
    ];
    var isHidden = function (elem, el) {
        elem = el || elem;
        return jQuery.css(elem, 'display') === 'none' || !jQuery.contains(elem.ownerDocument, elem);
    };
    var access = jQuery.access = function (elems, fn, key, value, chainable, emptyGet, raw) {
        var i = 0, length = elems.length, bulk = key == null;
        if (jQuery.type(key) === 'object') {
            chainable = true;
            for (i in key) {
                jQuery.access(elems, fn, i, key[i], true, emptyGet, raw);
            }
        } else if (value !== undefined) {
            chainable = true;
            if (!jQuery.isFunction(value)) {
                raw = true;
            }
            if (bulk) {
                if (raw) {
                    fn.call(elems, value);
                    fn = null;
                } else {
                    bulk = fn;
                    fn = function (elem, key, value) {
                        return bulk.call(jQuery(elem), value);
                    };
                }
            }
            if (fn) {
                for (; i < length; i++) {
                    fn(elems[i], key, raw ? value : value.call(elems[i], i, fn(elems[i], key)));
                }
            }
        }
        return chainable ? elems : bulk ? fn.call(elems) : length ? fn(elems[0], key) : emptyGet;
    };
    var rcheckableType = /^(?:checkbox|radio)$/i;
    (function () {
        var fragment = document.createDocumentFragment(), div = document.createElement('div'), input = document.createElement('input');
        div.setAttribute('className', 't');
        div.innerHTML = '  <link/><table></table><a href=\'/a\'>a</a>';
        support.leadingWhitespace = div.firstChild.nodeType === 3;
        support.tbody = !div.getElementsByTagName('tbody').length;
        support.htmlSerialize = !!div.getElementsByTagName('link').length;
        support.html5Clone = document.createElement('nav').cloneNode(true).outerHTML !== '<:nav></:nav>';
        input.type = 'checkbox';
        input.checked = true;
        fragment.appendChild(input);
        support.appendChecked = input.checked;
        div.innerHTML = '<textarea>x</textarea>';
        support.noCloneChecked = !!div.cloneNode(true).lastChild.defaultValue;
        fragment.appendChild(div);
        div.innerHTML = '<input type=\'radio\' checked=\'checked\' name=\'t\'/>';
        support.checkClone = div.cloneNode(true).cloneNode(true).lastChild.checked;
        support.noCloneEvent = true;
        if (div.attachEvent) {
            div.attachEvent('onclick', function () {
                support.noCloneEvent = false;
            });
            div.cloneNode(true).click();
        }
        if (support.deleteExpando == null) {
            support.deleteExpando = true;
            try {
                delete div.test;
            } catch (e) {
                support.deleteExpando = false;
            }
        }
        fragment = div = input = null;
    }());
    (function () {
        var i, eventName, div = document.createElement('div');
        for (i in {
                submit: true,
                change: true,
                focusin: true
            }) {
            eventName = 'on' + i;
            if (!(support[i + 'Bubbles'] = eventName in window)) {
                div.setAttribute(eventName, 't');
                support[i + 'Bubbles'] = div.attributes[eventName].expando === false;
            }
        }
        div = null;
    }());
    var rformElems = /^(?:input|select|textarea)$/i, rkeyEvent = /^key/, rmouseEvent = /^(?:mouse|contextmenu)|click/, rfocusMorph = /^(?:focusinfocus|focusoutblur)$/, rtypenamespace = /^([^.]*)(?:\.(.+)|)$/;
    function returnTrue() {
        return true;
    }
    function returnFalse() {
        return false;
    }
    function safeActiveElement() {
        try {
            return document.activeElement;
        } catch (err) {
        }
    }
    jQuery.event = {
        global: {},
        add: function (elem, types, handler, data, selector) {
            var tmp, events, t, handleObjIn, special, eventHandle, handleObj, handlers, type, namespaces, origType, elemData = jQuery._data(elem);
            if (!elemData) {
                return;
            }
            if (handler.handler) {
                handleObjIn = handler;
                handler = handleObjIn.handler;
                selector = handleObjIn.selector;
            }
            if (!handler.guid) {
                handler.guid = jQuery.guid++;
            }
            if (!(events = elemData.events)) {
                events = elemData.events = {};
            }
            if (!(eventHandle = elemData.handle)) {
                eventHandle = elemData.handle = function (e) {
                    return typeof jQuery !== strundefined && (!e || jQuery.event.triggered !== e.type) ? jQuery.event.dispatch.apply(eventHandle.elem, arguments) : undefined;
                };
                eventHandle.elem = elem;
            }
            types = (types || '').match(rnotwhite) || [''];
            t = types.length;
            while (t--) {
                tmp = rtypenamespace.exec(types[t]) || [];
                type = origType = tmp[1];
                namespaces = (tmp[2] || '').split('.').sort();
                if (!type) {
                    continue;
                }
                special = jQuery.event.special[type] || {};
                type = (selector ? special.delegateType : special.bindType) || type;
                special = jQuery.event.special[type] || {};
                handleObj = jQuery.extend({
                    type: type,
                    origType: origType,
                    data: data,
                    handler: handler,
                    guid: handler.guid,
                    selector: selector,
                    needsContext: selector && jQuery.expr.match.needsContext.test(selector),
                    namespace: namespaces.join('.')
                }, handleObjIn);
                if (!(handlers = events[type])) {
                    handlers = events[type] = [];
                    handlers.delegateCount = 0;
                    if (!special.setup || special.setup.call(elem, data, namespaces, eventHandle) === false) {
                        if (elem.addEventListener) {
                            elem.addEventListener(type, eventHandle, false);
                        } else if (elem.attachEvent) {
                            elem.attachEvent('on' + type, eventHandle);
                        }
                    }
                }
                if (special.add) {
                    special.add.call(elem, handleObj);
                    if (!handleObj.handler.guid) {
                        handleObj.handler.guid = handler.guid;
                    }
                }
                if (selector) {
                    handlers.splice(handlers.delegateCount++, 0, handleObj);
                } else {
                    handlers.push(handleObj);
                }
                jQuery.event.global[type] = true;
            }
            elem = null;
        },
        remove: function (elem, types, handler, selector, mappedTypes) {
            var j, handleObj, tmp, origCount, t, events, special, handlers, type, namespaces, origType, elemData = jQuery.hasData(elem) && jQuery._data(elem);
            if (!elemData || !(events = elemData.events)) {
                return;
            }
            types = (types || '').match(rnotwhite) || [''];
            t = types.length;
            while (t--) {
                tmp = rtypenamespace.exec(types[t]) || [];
                type = origType = tmp[1];
                namespaces = (tmp[2] || '').split('.').sort();
                if (!type) {
                    for (type in events) {
                        jQuery.event.remove(elem, type + types[t], handler, selector, true);
                    }
                    continue;
                }
                special = jQuery.event.special[type] || {};
                type = (selector ? special.delegateType : special.bindType) || type;
                handlers = events[type] || [];
                tmp = tmp[2] && new RegExp('(^|\\.)' + namespaces.join('\\.(?:.*\\.|)') + '(\\.|$)');
                origCount = j = handlers.length;
                while (j--) {
                    handleObj = handlers[j];
                    if ((mappedTypes || origType === handleObj.origType) && (!handler || handler.guid === handleObj.guid) && (!tmp || tmp.test(handleObj.namespace)) && (!selector || selector === handleObj.selector || selector === '**' && handleObj.selector)) {
                        handlers.splice(j, 1);
                        if (handleObj.selector) {
                            handlers.delegateCount--;
                        }
                        if (special.remove) {
                            special.remove.call(elem, handleObj);
                        }
                    }
                }
                if (origCount && !handlers.length) {
                    if (!special.teardown || special.teardown.call(elem, namespaces, elemData.handle) === false) {
                        jQuery.removeEvent(elem, type, elemData.handle);
                    }
                    delete events[type];
                }
            }
            if (jQuery.isEmptyObject(events)) {
                delete elemData.handle;
                jQuery._removeData(elem, 'events');
            }
        },
        trigger: function (event, data, elem, onlyHandlers) {
            var handle, ontype, cur, bubbleType, special, tmp, i, eventPath = [elem || document], type = hasOwn.call(event, 'type') ? event.type : event, namespaces = hasOwn.call(event, 'namespace') ? event.namespace.split('.') : [];
            cur = tmp = elem = elem || document;
            if (elem.nodeType === 3 || elem.nodeType === 8) {
                return;
            }
            if (rfocusMorph.test(type + jQuery.event.triggered)) {
                return;
            }
            if (type.indexOf('.') >= 0) {
                namespaces = type.split('.');
                type = namespaces.shift();
                namespaces.sort();
            }
            ontype = type.indexOf(':') < 0 && 'on' + type;
            event = event[jQuery.expando] ? event : new jQuery.Event(type, typeof event === 'object' && event);
            event.isTrigger = onlyHandlers ? 2 : 3;
            event.namespace = namespaces.join('.');
            event.namespace_re = event.namespace ? new RegExp('(^|\\.)' + namespaces.join('\\.(?:.*\\.|)') + '(\\.|$)') : null;
            event.result = undefined;
            if (!event.target) {
                event.target = elem;
            }
            data = data == null ? [event] : jQuery.makeArray(data, [event]);
            special = jQuery.event.special[type] || {};
            if (!onlyHandlers && special.trigger && special.trigger.apply(elem, data) === false) {
                return;
            }
            if (!onlyHandlers && !special.noBubble && !jQuery.isWindow(elem)) {
                bubbleType = special.delegateType || type;
                if (!rfocusMorph.test(bubbleType + type)) {
                    cur = cur.parentNode;
                }
                for (; cur; cur = cur.parentNode) {
                    eventPath.push(cur);
                    tmp = cur;
                }
                if (tmp === (elem.ownerDocument || document)) {
                    eventPath.push(tmp.defaultView || tmp.parentWindow || window);
                }
            }
            i = 0;
            while ((cur = eventPath[i++]) && !event.isPropagationStopped()) {
                event.type = i > 1 ? bubbleType : special.bindType || type;
                handle = (jQuery._data(cur, 'events') || {})[event.type] && jQuery._data(cur, 'handle');
                if (handle) {
                    handle.apply(cur, data);
                }
                handle = ontype && cur[ontype];
                if (handle && handle.apply && jQuery.acceptData(cur)) {
                    event.result = handle.apply(cur, data);
                    if (event.result === false) {
                        event.preventDefault();
                    }
                }
            }
            event.type = type;
            if (!onlyHandlers && !event.isDefaultPrevented()) {
                if ((!special._default || special._default.apply(eventPath.pop(), data) === false) && jQuery.acceptData(elem)) {
                    if (ontype && elem[type] && !jQuery.isWindow(elem)) {
                        tmp = elem[ontype];
                        if (tmp) {
                            elem[ontype] = null;
                        }
                        jQuery.event.triggered = type;
                        try {
                            elem[type]();
                        } catch (e) {
                        }
                        jQuery.event.triggered = undefined;
                        if (tmp) {
                            elem[ontype] = tmp;
                        }
                    }
                }
            }
            return event.result;
        },
        dispatch: function (event) {
            event = jQuery.event.fix(event);
            var i, ret, handleObj, matched, j, handlerQueue = [], args = slice.call(arguments), handlers = (jQuery._data(this, 'events') || {})[event.type] || [], special = jQuery.event.special[event.type] || {};
            args[0] = event;
            event.delegateTarget = this;
            if (special.preDispatch && special.preDispatch.call(this, event) === false) {
                return;
            }
            handlerQueue = jQuery.event.handlers.call(this, event, handlers);
            i = 0;
            while ((matched = handlerQueue[i++]) && !event.isPropagationStopped()) {
                event.currentTarget = matched.elem;
                j = 0;
                while ((handleObj = matched.handlers[j++]) && !event.isImmediatePropagationStopped()) {
                    if (!event.namespace_re || event.namespace_re.test(handleObj.namespace)) {
                        event.handleObj = handleObj;
                        event.data = handleObj.data;
                        ret = ((jQuery.event.special[handleObj.origType] || {}).handle || handleObj.handler).apply(matched.elem, args);
                        if (ret !== undefined) {
                            if ((event.result = ret) === false) {
                                event.preventDefault();
                                event.stopPropagation();
                            }
                        }
                    }
                }
            }
            if (special.postDispatch) {
                special.postDispatch.call(this, event);
            }
            return event.result;
        },
        handlers: function (event, handlers) {
            var sel, handleObj, matches, i, handlerQueue = [], delegateCount = handlers.delegateCount, cur = event.target;
            if (delegateCount && cur.nodeType && (!event.button || event.type !== 'click')) {
                for (; cur != this; cur = cur.parentNode || this) {
                    if (cur.nodeType === 1 && (cur.disabled !== true || event.type !== 'click')) {
                        matches = [];
                        for (i = 0; i < delegateCount; i++) {
                            handleObj = handlers[i];
                            sel = handleObj.selector + ' ';
                            if (matches[sel] === undefined) {
                                matches[sel] = handleObj.needsContext ? jQuery(sel, this).index(cur) >= 0 : jQuery.find(sel, this, null, [cur]).length;
                            }
                            if (matches[sel]) {
                                matches.push(handleObj);
                            }
                        }
                        if (matches.length) {
                            handlerQueue.push({
                                elem: cur,
                                handlers: matches
                            });
                        }
                    }
                }
            }
            if (delegateCount < handlers.length) {
                handlerQueue.push({
                    elem: this,
                    handlers: handlers.slice(delegateCount)
                });
            }
            return handlerQueue;
        },
        fix: function (event) {
            if (event[jQuery.expando]) {
                return event;
            }
            var i, prop, copy, type = event.type, originalEvent = event, fixHook = this.fixHooks[type];
            if (!fixHook) {
                this.fixHooks[type] = fixHook = rmouseEvent.test(type) ? this.mouseHooks : rkeyEvent.test(type) ? this.keyHooks : {};
            }
            copy = fixHook.props ? this.props.concat(fixHook.props) : this.props;
            event = new jQuery.Event(originalEvent);
            i = copy.length;
            while (i--) {
                prop = copy[i];
                event[prop] = originalEvent[prop];
            }
            if (!event.target) {
                event.target = originalEvent.srcElement || document;
            }
            if (event.target.nodeType === 3) {
                event.target = event.target.parentNode;
            }
            event.metaKey = !!event.metaKey;
            return fixHook.filter ? fixHook.filter(event, originalEvent) : event;
        },
        props: 'altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which'.split(' '),
        fixHooks: {},
        keyHooks: {
            props: 'char charCode key keyCode'.split(' '),
            filter: function (event, original) {
                if (event.which == null) {
                    event.which = original.charCode != null ? original.charCode : original.keyCode;
                }
                return event;
            }
        },
        mouseHooks: {
            props: 'button buttons clientX clientY fromElement offsetX offsetY pageX pageY screenX screenY toElement'.split(' '),
            filter: function (event, original) {
                var body, eventDoc, doc, button = original.button, fromElement = original.fromElement;
                if (event.pageX == null && original.clientX != null) {
                    eventDoc = event.target.ownerDocument || document;
                    doc = eventDoc.documentElement;
                    body = eventDoc.body;
                    event.pageX = original.clientX + (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc && doc.clientLeft || body && body.clientLeft || 0);
                    event.pageY = original.clientY + (doc && doc.scrollTop || body && body.scrollTop || 0) - (doc && doc.clientTop || body && body.clientTop || 0);
                }
                if (!event.relatedTarget && fromElement) {
                    event.relatedTarget = fromElement === event.target ? original.toElement : fromElement;
                }
                if (!event.which && button !== undefined) {
                    event.which = button & 1 ? 1 : button & 2 ? 3 : button & 4 ? 2 : 0;
                }
                return event;
            }
        },
        special: {
            load: { noBubble: true },
            focus: {
                trigger: function () {
                    if (this !== safeActiveElement() && this.focus) {
                        try {
                            this.focus();
                            return false;
                        } catch (e) {
                        }
                    }
                },
                delegateType: 'focusin'
            },
            blur: {
                trigger: function () {
                    if (this === safeActiveElement() && this.blur) {
                        this.blur();
                        return false;
                    }
                },
                delegateType: 'focusout'
            },
            click: {
                trigger: function () {
                    if (jQuery.nodeName(this, 'input') && this.type === 'checkbox' && this.click) {
                        this.click();
                        return false;
                    }
                },
                _default: function (event) {
                    return jQuery.nodeName(event.target, 'a');
                }
            },
            beforeunload: {
                postDispatch: function (event) {
                    if (event.result !== undefined) {
                        event.originalEvent.returnValue = event.result;
                    }
                }
            }
        },
        simulate: function (type, elem, event, bubble) {
            var e = jQuery.extend(new jQuery.Event(), event, {
                type: type,
                isSimulated: true,
                originalEvent: {}
            });
            if (bubble) {
                jQuery.event.trigger(e, null, elem);
            } else {
                jQuery.event.dispatch.call(elem, e);
            }
            if (e.isDefaultPrevented()) {
                event.preventDefault();
            }
        }
    };
    jQuery.removeEvent = document.removeEventListener ? function (elem, type, handle) {
        if (elem.removeEventListener) {
            elem.removeEventListener(type, handle, false);
        }
    } : function (elem, type, handle) {
        var name = 'on' + type;
        if (elem.detachEvent) {
            if (typeof elem[name] === strundefined) {
                elem[name] = null;
            }
            elem.detachEvent(name, handle);
        }
    };
    jQuery.Event = function (src, props) {
        if (!(this instanceof jQuery.Event)) {
            return new jQuery.Event(src, props);
        }
        if (src && src.type) {
            this.originalEvent = src;
            this.type = src.type;
            this.isDefaultPrevented = src.defaultPrevented || src.defaultPrevented === undefined && (src.returnValue === false || src.getPreventDefault && src.getPreventDefault()) ? returnTrue : returnFalse;
        } else {
            this.type = src;
        }
        if (props) {
            jQuery.extend(this, props);
        }
        this.timeStamp = src && src.timeStamp || jQuery.now();
        this[jQuery.expando] = true;
    };
    jQuery.Event.prototype = {
        isDefaultPrevented: returnFalse,
        isPropagationStopped: returnFalse,
        isImmediatePropagationStopped: returnFalse,
        preventDefault: function () {
            var e = this.originalEvent;
            this.isDefaultPrevented = returnTrue;
            if (!e) {
                return;
            }
            if (e.preventDefault) {
                e.preventDefault();
            } else {
                e.returnValue = false;
            }
        },
        stopPropagation: function () {
            var e = this.originalEvent;
            this.isPropagationStopped = returnTrue;
            if (!e) {
                return;
            }
            if (e.stopPropagation) {
                e.stopPropagation();
            }
            e.cancelBubble = true;
        },
        stopImmediatePropagation: function () {
            this.isImmediatePropagationStopped = returnTrue;
            this.stopPropagation();
        }
    };
    jQuery.each({
        mouseenter: 'mouseover',
        mouseleave: 'mouseout'
    }, function (orig, fix) {
        jQuery.event.special[orig] = {
            delegateType: fix,
            bindType: fix,
            handle: function (event) {
                var ret, target = this, related = event.relatedTarget, handleObj = event.handleObj;
                if (!related || related !== target && !jQuery.contains(target, related)) {
                    event.type = handleObj.origType;
                    ret = handleObj.handler.apply(this, arguments);
                    event.type = fix;
                }
                return ret;
            }
        };
    });
    if (!support.submitBubbles) {
        jQuery.event.special.submit = {
            setup: function () {
                if (jQuery.nodeName(this, 'form')) {
                    return false;
                }
                jQuery.event.add(this, 'click._submit keypress._submit', function (e) {
                    var elem = e.target, form = jQuery.nodeName(elem, 'input') || jQuery.nodeName(elem, 'button') ? elem.form : undefined;
                    if (form && !jQuery._data(form, 'submitBubbles')) {
                        jQuery.event.add(form, 'submit._submit', function (event) {
                            event._submit_bubble = true;
                        });
                        jQuery._data(form, 'submitBubbles', true);
                    }
                });
            },
            postDispatch: function (event) {
                if (event._submit_bubble) {
                    delete event._submit_bubble;
                    if (this.parentNode && !event.isTrigger) {
                        jQuery.event.simulate('submit', this.parentNode, event, true);
                    }
                }
            },
            teardown: function () {
                if (jQuery.nodeName(this, 'form')) {
                    return false;
                }
                jQuery.event.remove(this, '._submit');
            }
        };
    }
    if (!support.changeBubbles) {
        jQuery.event.special.change = {
            setup: function () {
                if (rformElems.test(this.nodeName)) {
                    if (this.type === 'checkbox' || this.type === 'radio') {
                        jQuery.event.add(this, 'propertychange._change', function (event) {
                            if (event.originalEvent.propertyName === 'checked') {
                                this._just_changed = true;
                            }
                        });
                        jQuery.event.add(this, 'click._change', function (event) {
                            if (this._just_changed && !event.isTrigger) {
                                this._just_changed = false;
                            }
                            jQuery.event.simulate('change', this, event, true);
                        });
                    }
                    return false;
                }
                jQuery.event.add(this, 'beforeactivate._change', function (e) {
                    var elem = e.target;
                    if (rformElems.test(elem.nodeName) && !jQuery._data(elem, 'changeBubbles')) {
                        jQuery.event.add(elem, 'change._change', function (event) {
                            if (this.parentNode && !event.isSimulated && !event.isTrigger) {
                                jQuery.event.simulate('change', this.parentNode, event, true);
                            }
                        });
                        jQuery._data(elem, 'changeBubbles', true);
                    }
                });
            },
            handle: function (event) {
                var elem = event.target;
                if (this !== elem || event.isSimulated || event.isTrigger || elem.type !== 'radio' && elem.type !== 'checkbox') {
                    return event.handleObj.handler.apply(this, arguments);
                }
            },
            teardown: function () {
                jQuery.event.remove(this, '._change');
                return !rformElems.test(this.nodeName);
            }
        };
    }
    if (!support.focusinBubbles) {
        jQuery.each({
            focus: 'focusin',
            blur: 'focusout'
        }, function (orig, fix) {
            var handler = function (event) {
                jQuery.event.simulate(fix, event.target, jQuery.event.fix(event), true);
            };
            jQuery.event.special[fix] = {
                setup: function () {
                    var doc = this.ownerDocument || this, attaches = jQuery._data(doc, fix);
                    if (!attaches) {
                        doc.addEventListener(orig, handler, true);
                    }
                    jQuery._data(doc, fix, (attaches || 0) + 1);
                },
                teardown: function () {
                    var doc = this.ownerDocument || this, attaches = jQuery._data(doc, fix) - 1;
                    if (!attaches) {
                        doc.removeEventListener(orig, handler, true);
                        jQuery._removeData(doc, fix);
                    } else {
                        jQuery._data(doc, fix, attaches);
                    }
                }
            };
        });
    }
    jQuery.fn.extend({
        on: function (types, selector, data, fn, one) {
            var type, origFn;
            if (typeof types === 'object') {
                if (typeof selector !== 'string') {
                    data = data || selector;
                    selector = undefined;
                }
                for (type in types) {
                    this.on(type, selector, data, types[type], one);
                }
                return this;
            }
            if (data == null && fn == null) {
                fn = selector;
                data = selector = undefined;
            } else if (fn == null) {
                if (typeof selector === 'string') {
                    fn = data;
                    data = undefined;
                } else {
                    fn = data;
                    data = selector;
                    selector = undefined;
                }
            }
            if (fn === false) {
                fn = returnFalse;
            } else if (!fn) {
                return this;
            }
            if (one === 1) {
                origFn = fn;
                fn = function (event) {
                    jQuery().off(event);
                    return origFn.apply(this, arguments);
                };
                fn.guid = origFn.guid || (origFn.guid = jQuery.guid++);
            }
            return this.each(function () {
                jQuery.event.add(this, types, fn, data, selector);
            });
        },
        one: function (types, selector, data, fn) {
            return this.on(types, selector, data, fn, 1);
        },
        off: function (types, selector, fn) {
            var handleObj, type;
            if (types && types.preventDefault && types.handleObj) {
                handleObj = types.handleObj;
                jQuery(types.delegateTarget).off(handleObj.namespace ? handleObj.origType + '.' + handleObj.namespace : handleObj.origType, handleObj.selector, handleObj.handler);
                return this;
            }
            if (typeof types === 'object') {
                for (type in types) {
                    this.off(type, selector, types[type]);
                }
                return this;
            }
            if (selector === false || typeof selector === 'function') {
                fn = selector;
                selector = undefined;
            }
            if (fn === false) {
                fn = returnFalse;
            }
            return this.each(function () {
                jQuery.event.remove(this, types, fn, selector);
            });
        },
        trigger: function (type, data) {
            return this.each(function () {
                jQuery.event.trigger(type, data, this);
            });
        },
        triggerHandler: function (type, data) {
            var elem = this[0];
            if (elem) {
                return jQuery.event.trigger(type, data, elem, true);
            }
        }
    });
    function createSafeFragment(document) {
        var list = nodeNames.split('|'), safeFrag = document.createDocumentFragment();
        if (safeFrag.createElement) {
            while (list.length) {
                safeFrag.createElement(list.pop());
            }
        }
        return safeFrag;
    }
    var nodeNames = 'abbr|article|aside|audio|bdi|canvas|data|datalist|details|figcaption|figure|footer|' + 'header|hgroup|mark|meter|nav|output|progress|section|summary|time|video', rinlinejQuery = / jQuery\d+="(?:null|\d+)"/g, rnoshimcache = new RegExp('<(?:' + nodeNames + ')[\\s/>]', 'i'), rleadingWhitespace = /^\s+/, rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi, rtagName = /<([\w:]+)/, rtbody = /<tbody/i, rhtml = /<|&#?\w+;/, rnoInnerhtml = /<(?:script|style|link)/i, rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i, rscriptType = /^$|\/(?:java|ecma)script/i, rscriptTypeMasked = /^true\/(.*)/, rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g, wrapMap = {
            option: [
                1,
                '<select multiple=\'multiple\'>',
                '</select>'
            ],
            legend: [
                1,
                '<fieldset>',
                '</fieldset>'
            ],
            area: [
                1,
                '<map>',
                '</map>'
            ],
            param: [
                1,
                '<object>',
                '</object>'
            ],
            thead: [
                1,
                '<table>',
                '</table>'
            ],
            tr: [
                2,
                '<table><tbody>',
                '</tbody></table>'
            ],
            col: [
                2,
                '<table><tbody></tbody><colgroup>',
                '</colgroup></table>'
            ],
            td: [
                3,
                '<table><tbody><tr>',
                '</tr></tbody></table>'
            ],
            _default: support.htmlSerialize ? [
                0,
                '',
                ''
            ] : [
                1,
                'X<div>',
                '</div>'
            ]
        }, safeFragment = createSafeFragment(document), fragmentDiv = safeFragment.appendChild(document.createElement('div'));
    wrapMap.optgroup = wrapMap.option;
    wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
    wrapMap.th = wrapMap.td;
    function getAll(context, tag) {
        var elems, elem, i = 0, found = typeof context.getElementsByTagName !== strundefined ? context.getElementsByTagName(tag || '*') : typeof context.querySelectorAll !== strundefined ? context.querySelectorAll(tag || '*') : undefined;
        if (!found) {
            for (found = [], elems = context.childNodes || context; (elem = elems[i]) != null; i++) {
                if (!tag || jQuery.nodeName(elem, tag)) {
                    found.push(elem);
                } else {
                    jQuery.merge(found, getAll(elem, tag));
                }
            }
        }
        return tag === undefined || tag && jQuery.nodeName(context, tag) ? jQuery.merge([context], found) : found;
    }
    function fixDefaultChecked(elem) {
        if (rcheckableType.test(elem.type)) {
            elem.defaultChecked = elem.checked;
        }
    }
    function manipulationTarget(elem, content) {
        return jQuery.nodeName(elem, 'table') && jQuery.nodeName(content.nodeType !== 11 ? content : content.firstChild, 'tr') ? elem.getElementsByTagName('tbody')[0] || elem.appendChild(elem.ownerDocument.createElement('tbody')) : elem;
    }
    function disableScript(elem) {
        elem.type = (jQuery.find.attr(elem, 'type') !== null) + '/' + elem.type;
        return elem;
    }
    function restoreScript(elem) {
        var match = rscriptTypeMasked.exec(elem.type);
        if (match) {
            elem.type = match[1];
        } else {
            elem.removeAttribute('type');
        }
        return elem;
    }
    function setGlobalEval(elems, refElements) {
        var elem, i = 0;
        for (; (elem = elems[i]) != null; i++) {
            jQuery._data(elem, 'globalEval', !refElements || jQuery._data(refElements[i], 'globalEval'));
        }
    }
    function cloneCopyEvent(src, dest) {
        if (dest.nodeType !== 1 || !jQuery.hasData(src)) {
            return;
        }
        var type, i, l, oldData = jQuery._data(src), curData = jQuery._data(dest, oldData), events = oldData.events;
        if (events) {
            delete curData.handle;
            curData.events = {};
            for (type in events) {
                for (i = 0, l = events[type].length; i < l; i++) {
                    jQuery.event.add(dest, type, events[type][i]);
                }
            }
        }
        if (curData.data) {
            curData.data = jQuery.extend({}, curData.data);
        }
    }
    function fixCloneNodeIssues(src, dest) {
        var nodeName, e, data;
        if (dest.nodeType !== 1) {
            return;
        }
        nodeName = dest.nodeName.toLowerCase();
        if (!support.noCloneEvent && dest[jQuery.expando]) {
            data = jQuery._data(dest);
            for (e in data.events) {
                jQuery.removeEvent(dest, e, data.handle);
            }
            dest.removeAttribute(jQuery.expando);
        }
        if (nodeName === 'script' && dest.text !== src.text) {
            disableScript(dest).text = src.text;
            restoreScript(dest);
        } else if (nodeName === 'object') {
            if (dest.parentNode) {
                dest.outerHTML = src.outerHTML;
            }
            if (support.html5Clone && (src.innerHTML && !jQuery.trim(dest.innerHTML))) {
                dest.innerHTML = src.innerHTML;
            }
        } else if (nodeName === 'input' && rcheckableType.test(src.type)) {
            dest.defaultChecked = dest.checked = src.checked;
            if (dest.value !== src.value) {
                dest.value = src.value;
            }
        } else if (nodeName === 'option') {
            dest.defaultSelected = dest.selected = src.defaultSelected;
        } else if (nodeName === 'input' || nodeName === 'textarea') {
            dest.defaultValue = src.defaultValue;
        }
    }
    jQuery.extend({
        clone: function (elem, dataAndEvents, deepDataAndEvents) {
            var destElements, node, clone, i, srcElements, inPage = jQuery.contains(elem.ownerDocument, elem);
            if (support.html5Clone || jQuery.isXMLDoc(elem) || !rnoshimcache.test('<' + elem.nodeName + '>')) {
                clone = elem.cloneNode(true);
            } else {
                fragmentDiv.innerHTML = elem.outerHTML;
                fragmentDiv.removeChild(clone = fragmentDiv.firstChild);
            }
            if ((!support.noCloneEvent || !support.noCloneChecked) && (elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem)) {
                destElements = getAll(clone);
                srcElements = getAll(elem);
                for (i = 0; (node = srcElements[i]) != null; ++i) {
                    if (destElements[i]) {
                        fixCloneNodeIssues(node, destElements[i]);
                    }
                }
            }
            if (dataAndEvents) {
                if (deepDataAndEvents) {
                    srcElements = srcElements || getAll(elem);
                    destElements = destElements || getAll(clone);
                    for (i = 0; (node = srcElements[i]) != null; i++) {
                        cloneCopyEvent(node, destElements[i]);
                    }
                } else {
                    cloneCopyEvent(elem, clone);
                }
            }
            destElements = getAll(clone, 'script');
            if (destElements.length > 0) {
                setGlobalEval(destElements, !inPage && getAll(elem, 'script'));
            }
            destElements = srcElements = node = null;
            return clone;
        },
        buildFragment: function (elems, context, scripts, selection) {
            var j, elem, contains, tmp, tag, tbody, wrap, l = elems.length, safe = createSafeFragment(context), nodes = [], i = 0;
            for (; i < l; i++) {
                elem = elems[i];
                if (elem || elem === 0) {
                    if (jQuery.type(elem) === 'object') {
                        jQuery.merge(nodes, elem.nodeType ? [elem] : elem);
                    } else if (!rhtml.test(elem)) {
                        nodes.push(context.createTextNode(elem));
                    } else {
                        tmp = tmp || safe.appendChild(context.createElement('div'));
                        tag = (rtagName.exec(elem) || [
                            '',
                            ''
                        ])[1].toLowerCase();
                        wrap = wrapMap[tag] || wrapMap._default;
                        tmp.innerHTML = wrap[1] + elem.replace(rxhtmlTag, '<$1></$2>') + wrap[2];
                        j = wrap[0];
                        while (j--) {
                            tmp = tmp.lastChild;
                        }
                        if (!support.leadingWhitespace && rleadingWhitespace.test(elem)) {
                            nodes.push(context.createTextNode(rleadingWhitespace.exec(elem)[0]));
                        }
                        if (!support.tbody) {
                            elem = tag === 'table' && !rtbody.test(elem) ? tmp.firstChild : wrap[1] === '<table>' && !rtbody.test(elem) ? tmp : 0;
                            j = elem && elem.childNodes.length;
                            while (j--) {
                                if (jQuery.nodeName(tbody = elem.childNodes[j], 'tbody') && !tbody.childNodes.length) {
                                    elem.removeChild(tbody);
                                }
                            }
                        }
                        jQuery.merge(nodes, tmp.childNodes);
                        tmp.textContent = '';
                        while (tmp.firstChild) {
                            tmp.removeChild(tmp.firstChild);
                        }
                        tmp = safe.lastChild;
                    }
                }
            }
            if (tmp) {
                safe.removeChild(tmp);
            }
            if (!support.appendChecked) {
                jQuery.grep(getAll(nodes, 'input'), fixDefaultChecked);
            }
            i = 0;
            while (elem = nodes[i++]) {
                if (selection && jQuery.inArray(elem, selection) !== -1) {
                    continue;
                }
                contains = jQuery.contains(elem.ownerDocument, elem);
                tmp = getAll(safe.appendChild(elem), 'script');
                if (contains) {
                    setGlobalEval(tmp);
                }
                if (scripts) {
                    j = 0;
                    while (elem = tmp[j++]) {
                        if (rscriptType.test(elem.type || '')) {
                            scripts.push(elem);
                        }
                    }
                }
            }
            tmp = null;
            return safe;
        },
        cleanData: function (elems, acceptData) {
            var elem, type, id, data, i = 0, internalKey = jQuery.expando, cache = jQuery.cache, deleteExpando = support.deleteExpando, special = jQuery.event.special;
            for (; (elem = elems[i]) != null; i++) {
                if (acceptData || jQuery.acceptData(elem)) {
                    id = elem[internalKey];
                    data = id && cache[id];
                    if (data) {
                        if (data.events) {
                            for (type in data.events) {
                                if (special[type]) {
                                    jQuery.event.remove(elem, type);
                                } else {
                                    jQuery.removeEvent(elem, type, data.handle);
                                }
                            }
                        }
                        if (cache[id]) {
                            delete cache[id];
                            if (deleteExpando) {
                                delete elem[internalKey];
                            } else if (typeof elem.removeAttribute !== strundefined) {
                                elem.removeAttribute(internalKey);
                            } else {
                                elem[internalKey] = null;
                            }
                            deletedIds.push(id);
                        }
                    }
                }
            }
        }
    });
    jQuery.fn.extend({
        text: function (value) {
            return access(this, function (value) {
                return value === undefined ? jQuery.text(this) : this.empty().append((this[0] && this[0].ownerDocument || document).createTextNode(value));
            }, null, value, arguments.length);
        },
        append: function () {
            return this.domManip(arguments, function (elem) {
                if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
                    var target = manipulationTarget(this, elem);
                    target.appendChild(elem);
                }
            });
        },
        prepend: function () {
            return this.domManip(arguments, function (elem) {
                if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
                    var target = manipulationTarget(this, elem);
                    target.insertBefore(elem, target.firstChild);
                }
            });
        },
        before: function () {
            return this.domManip(arguments, function (elem) {
                if (this.parentNode) {
                    this.parentNode.insertBefore(elem, this);
                }
            });
        },
        after: function () {
            return this.domManip(arguments, function (elem) {
                if (this.parentNode) {
                    this.parentNode.insertBefore(elem, this.nextSibling);
                }
            });
        },
        remove: function (selector, keepData) {
            var elem, elems = selector ? jQuery.filter(selector, this) : this, i = 0;
            for (; (elem = elems[i]) != null; i++) {
                if (!keepData && elem.nodeType === 1) {
                    jQuery.cleanData(getAll(elem));
                }
                if (elem.parentNode) {
                    if (keepData && jQuery.contains(elem.ownerDocument, elem)) {
                        setGlobalEval(getAll(elem, 'script'));
                    }
                    elem.parentNode.removeChild(elem);
                }
            }
            return this;
        },
        empty: function () {
            var elem, i = 0;
            for (; (elem = this[i]) != null; i++) {
                if (elem.nodeType === 1) {
                    jQuery.cleanData(getAll(elem, false));
                }
                while (elem.firstChild) {
                    elem.removeChild(elem.firstChild);
                }
                if (elem.options && jQuery.nodeName(elem, 'select')) {
                    elem.options.length = 0;
                }
            }
            return this;
        },
        clone: function (dataAndEvents, deepDataAndEvents) {
            dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
            deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;
            return this.map(function () {
                return jQuery.clone(this, dataAndEvents, deepDataAndEvents);
            });
        },
        html: function (value) {
            return access(this, function (value) {
                var elem = this[0] || {}, i = 0, l = this.length;
                if (value === undefined) {
                    return elem.nodeType === 1 ? elem.innerHTML.replace(rinlinejQuery, '') : undefined;
                }
                if (typeof value === 'string' && !rnoInnerhtml.test(value) && (support.htmlSerialize || !rnoshimcache.test(value)) && (support.leadingWhitespace || !rleadingWhitespace.test(value)) && !wrapMap[(rtagName.exec(value) || [
                        '',
                        ''
                    ])[1].toLowerCase()]) {
                    value = value.replace(rxhtmlTag, '<$1></$2>');
                    try {
                        for (; i < l; i++) {
                            elem = this[i] || {};
                            if (elem.nodeType === 1) {
                                jQuery.cleanData(getAll(elem, false));
                                elem.innerHTML = value;
                            }
                        }
                        elem = 0;
                    } catch (e) {
                    }
                }
                if (elem) {
                    this.empty().append(value);
                }
            }, null, value, arguments.length);
        },
        replaceWith: function () {
            var arg = arguments[0];
            this.domManip(arguments, function (elem) {
                arg = this.parentNode;
                jQuery.cleanData(getAll(this));
                if (arg) {
                    arg.replaceChild(elem, this);
                }
            });
            return arg && (arg.length || arg.nodeType) ? this : this.remove();
        },
        detach: function (selector) {
            return this.remove(selector, true);
        },
        domManip: function (args, callback) {
            args = concat.apply([], args);
            var first, node, hasScripts, scripts, doc, fragment, i = 0, l = this.length, set = this, iNoClone = l - 1, value = args[0], isFunction = jQuery.isFunction(value);
            if (isFunction || l > 1 && typeof value === 'string' && !support.checkClone && rchecked.test(value)) {
                return this.each(function (index) {
                    var self = set.eq(index);
                    if (isFunction) {
                        args[0] = value.call(this, index, self.html());
                    }
                    self.domManip(args, callback);
                });
            }
            if (l) {
                fragment = jQuery.buildFragment(args, this[0].ownerDocument, false, this);
                first = fragment.firstChild;
                if (fragment.childNodes.length === 1) {
                    fragment = first;
                }
                if (first) {
                    scripts = jQuery.map(getAll(fragment, 'script'), disableScript);
                    hasScripts = scripts.length;
                    for (; i < l; i++) {
                        node = fragment;
                        if (i !== iNoClone) {
                            node = jQuery.clone(node, true, true);
                            if (hasScripts) {
                                jQuery.merge(scripts, getAll(node, 'script'));
                            }
                        }
                        callback.call(this[i], node, i);
                    }
                    if (hasScripts) {
                        doc = scripts[scripts.length - 1].ownerDocument;
                        jQuery.map(scripts, restoreScript);
                        for (i = 0; i < hasScripts; i++) {
                            node = scripts[i];
                            if (rscriptType.test(node.type || '') && !jQuery._data(node, 'globalEval') && jQuery.contains(doc, node)) {
                                if (node.src) {
                                    if (jQuery._evalUrl) {
                                        jQuery._evalUrl(node.src);
                                    }
                                } else {
                                    jQuery.globalEval((node.text || node.textContent || node.innerHTML || '').replace(rcleanScript, ''));
                                }
                            }
                        }
                    }
                    fragment = first = null;
                }
            }
            return this;
        }
    });
    jQuery.each({
        appendTo: 'append',
        prependTo: 'prepend',
        insertBefore: 'before',
        insertAfter: 'after',
        replaceAll: 'replaceWith'
    }, function (name, original) {
        jQuery.fn[name] = function (selector) {
            var elems, i = 0, ret = [], insert = jQuery(selector), last = insert.length - 1;
            for (; i <= last; i++) {
                elems = i === last ? this : this.clone(true);
                jQuery(insert[i])[original](elems);
                push.apply(ret, elems.get());
            }
            return this.pushStack(ret);
        };
    });
    var iframe, elemdisplay = {};
    function actualDisplay(name, doc) {
        var elem = jQuery(doc.createElement(name)).appendTo(doc.body), display = window.getDefaultComputedStyle ? window.getDefaultComputedStyle(elem[0]).display : jQuery.css(elem[0], 'display');
        elem.detach();
        return display;
    }
    function defaultDisplay(nodeName) {
        var doc = document, display = elemdisplay[nodeName];
        if (!display) {
            display = actualDisplay(nodeName, doc);
            if (display === 'none' || !display) {
                iframe = (iframe || jQuery('<iframe frameborder=\'0\' width=\'0\' height=\'0\'/>')).appendTo(doc.documentElement);
                doc = (iframe[0].contentWindow || iframe[0].contentDocument).document;
                doc.write();
                doc.close();
                display = actualDisplay(nodeName, doc);
                iframe.detach();
            }
            elemdisplay[nodeName] = display;
        }
        return display;
    }
    (function () {
        var a, shrinkWrapBlocksVal, div = document.createElement('div'), divReset = '-webkit-box-sizing:content-box;-moz-box-sizing:content-box;box-sizing:content-box;' + 'display:block;padding:0;margin:0;border:0';
        div.innerHTML = '  <link/><table></table><a href=\'/a\'>a</a><input type=\'checkbox\'/>';
        a = div.getElementsByTagName('a')[0];
        a.style.cssText = 'float:left;opacity:.5';
        support.opacity = /^0.5/.test(a.style.opacity);
        support.cssFloat = !!a.style.cssFloat;
        div.style.backgroundClip = 'content-box';
        div.cloneNode(true).style.backgroundClip = '';
        support.clearCloneStyle = div.style.backgroundClip === 'content-box';
        a = div = null;
        support.shrinkWrapBlocks = function () {
            var body, container, div, containerStyles;
            if (shrinkWrapBlocksVal == null) {
                body = document.getElementsByTagName('body')[0];
                if (!body) {
                    return;
                }
                containerStyles = 'border:0;width:0;height:0;position:absolute;top:0;left:-9999px';
                container = document.createElement('div');
                div = document.createElement('div');
                body.appendChild(container).appendChild(div);
                shrinkWrapBlocksVal = false;
                if (typeof div.style.zoom !== strundefined) {
                    div.style.cssText = divReset + ';width:1px;padding:1px;zoom:1';
                    div.innerHTML = '<div></div>';
                    div.firstChild.style.width = '5px';
                    shrinkWrapBlocksVal = div.offsetWidth !== 3;
                }
                body.removeChild(container);
                body = container = div = null;
            }
            return shrinkWrapBlocksVal;
        };
    }());
    var rmargin = /^margin/;
    var rnumnonpx = new RegExp('^(' + pnum + ')(?!px)[a-z%]+$', 'i');
    var getStyles, curCSS, rposition = /^(top|right|bottom|left)$/;
    if (window.getComputedStyle) {
        getStyles = function (elem) {
            return elem.ownerDocument.defaultView.getComputedStyle(elem, null);
        };
        curCSS = function (elem, name, computed) {
            var width, minWidth, maxWidth, ret, style = elem.style;
            computed = computed || getStyles(elem);
            ret = computed ? computed.getPropertyValue(name) || computed[name] : undefined;
            if (computed) {
                if (ret === '' && !jQuery.contains(elem.ownerDocument, elem)) {
                    ret = jQuery.style(elem, name);
                }
                if (rnumnonpx.test(ret) && rmargin.test(name)) {
                    width = style.width;
                    minWidth = style.minWidth;
                    maxWidth = style.maxWidth;
                    style.minWidth = style.maxWidth = style.width = ret;
                    ret = computed.width;
                    style.width = width;
                    style.minWidth = minWidth;
                    style.maxWidth = maxWidth;
                }
            }
            return ret === undefined ? ret : ret + '';
        };
    } else if (document.documentElement.currentStyle) {
        getStyles = function (elem) {
            return elem.currentStyle;
        };
        curCSS = function (elem, name, computed) {
            var left, rs, rsLeft, ret, style = elem.style;
            computed = computed || getStyles(elem);
            ret = computed ? computed[name] : undefined;
            if (ret == null && style && style[name]) {
                ret = style[name];
            }
            if (rnumnonpx.test(ret) && !rposition.test(name)) {
                left = style.left;
                rs = elem.runtimeStyle;
                rsLeft = rs && rs.left;
                if (rsLeft) {
                    rs.left = elem.currentStyle.left;
                }
                style.left = name === 'fontSize' ? '1em' : ret;
                ret = style.pixelLeft + 'px';
                style.left = left;
                if (rsLeft) {
                    rs.left = rsLeft;
                }
            }
            return ret === undefined ? ret : ret + '' || 'auto';
        };
    }
    function addGetHookIf(conditionFn, hookFn) {
        return {
            get: function () {
                var condition = conditionFn();
                if (condition == null) {
                    return;
                }
                if (condition) {
                    delete this.get;
                    return;
                }
                return (this.get = hookFn).apply(this, arguments);
            }
        };
    }
    (function () {
        var a, reliableHiddenOffsetsVal, boxSizingVal, boxSizingReliableVal, pixelPositionVal, reliableMarginRightVal, div = document.createElement('div'), containerStyles = 'border:0;width:0;height:0;position:absolute;top:0;left:-9999px', divReset = '-webkit-box-sizing:content-box;-moz-box-sizing:content-box;box-sizing:content-box;' + 'display:block;padding:0;margin:0;border:0';
        div.innerHTML = '  <link/><table></table><a href=\'/a\'>a</a><input type=\'checkbox\'/>';
        a = div.getElementsByTagName('a')[0];
        a.style.cssText = 'float:left;opacity:.5';
        support.opacity = /^0.5/.test(a.style.opacity);
        support.cssFloat = !!a.style.cssFloat;
        div.style.backgroundClip = 'content-box';
        div.cloneNode(true).style.backgroundClip = '';
        support.clearCloneStyle = div.style.backgroundClip === 'content-box';
        a = div = null;
        jQuery.extend(support, {
            reliableHiddenOffsets: function () {
                if (reliableHiddenOffsetsVal != null) {
                    return reliableHiddenOffsetsVal;
                }
                var container, tds, isSupported, div = document.createElement('div'), body = document.getElementsByTagName('body')[0];
                if (!body) {
                    return;
                }
                div.setAttribute('className', 't');
                div.innerHTML = '  <link/><table></table><a href=\'/a\'>a</a><input type=\'checkbox\'/>';
                container = document.createElement('div');
                container.style.cssText = containerStyles;
                body.appendChild(container).appendChild(div);
                div.innerHTML = '<table><tr><td></td><td>t</td></tr></table>';
                tds = div.getElementsByTagName('td');
                tds[0].style.cssText = 'padding:0;margin:0;border:0;display:none';
                isSupported = tds[0].offsetHeight === 0;
                tds[0].style.display = '';
                tds[1].style.display = 'none';
                reliableHiddenOffsetsVal = isSupported && tds[0].offsetHeight === 0;
                body.removeChild(container);
                div = body = null;
                return reliableHiddenOffsetsVal;
            },
            boxSizing: function () {
                if (boxSizingVal == null) {
                    computeStyleTests();
                }
                return boxSizingVal;
            },
            boxSizingReliable: function () {
                if (boxSizingReliableVal == null) {
                    computeStyleTests();
                }
                return boxSizingReliableVal;
            },
            pixelPosition: function () {
                if (pixelPositionVal == null) {
                    computeStyleTests();
                }
                return pixelPositionVal;
            },
            reliableMarginRight: function () {
                var body, container, div, marginDiv;
                if (reliableMarginRightVal == null && window.getComputedStyle) {
                    body = document.getElementsByTagName('body')[0];
                    if (!body) {
                        return;
                    }
                    container = document.createElement('div');
                    div = document.createElement('div');
                    container.style.cssText = containerStyles;
                    body.appendChild(container).appendChild(div);
                    marginDiv = div.appendChild(document.createElement('div'));
                    marginDiv.style.cssText = div.style.cssText = divReset;
                    marginDiv.style.marginRight = marginDiv.style.width = '0';
                    div.style.width = '1px';
                    reliableMarginRightVal = !parseFloat((window.getComputedStyle(marginDiv, null) || {}).marginRight);
                    body.removeChild(container);
                }
                return reliableMarginRightVal;
            }
        });
        function computeStyleTests() {
            var container, div, body = document.getElementsByTagName('body')[0];
            if (!body) {
                return;
            }
            container = document.createElement('div');
            div = document.createElement('div');
            container.style.cssText = containerStyles;
            body.appendChild(container).appendChild(div);
            div.style.cssText = '-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;' + 'position:absolute;display:block;padding:1px;border:1px;width:4px;' + 'margin-top:1%;top:1%';
            jQuery.swap(body, body.style.zoom != null ? { zoom: 1 } : {}, function () {
                boxSizingVal = div.offsetWidth === 4;
            });
            boxSizingReliableVal = true;
            pixelPositionVal = false;
            reliableMarginRightVal = true;
            if (window.getComputedStyle) {
                pixelPositionVal = (window.getComputedStyle(div, null) || {}).top !== '1%';
                boxSizingReliableVal = (window.getComputedStyle(div, null) || { width: '4px' }).width === '4px';
            }
            body.removeChild(container);
            div = body = null;
        }
    }());
    jQuery.swap = function (elem, options, callback, args) {
        var ret, name, old = {};
        for (name in options) {
            old[name] = elem.style[name];
            elem.style[name] = options[name];
        }
        ret = callback.apply(elem, args || []);
        for (name in options) {
            elem.style[name] = old[name];
        }
        return ret;
    };
    var ralpha = /alpha\([^)]*\)/i, ropacity = /opacity\s*=\s*([^)]*)/, rdisplayswap = /^(none|table(?!-c[ea]).+)/, rnumsplit = new RegExp('^(' + pnum + ')(.*)$', 'i'), rrelNum = new RegExp('^([+-])=(' + pnum + ')', 'i'), cssShow = {
            position: 'absolute',
            visibility: 'hidden',
            display: 'block'
        }, cssNormalTransform = {
            letterSpacing: 0,
            fontWeight: 400
        }, cssPrefixes = [
            'Webkit',
            'O',
            'Moz',
            'ms'
        ];
    function vendorPropName(style, name) {
        if (name in style) {
            return name;
        }
        var capName = name.charAt(0).toUpperCase() + name.slice(1), origName = name, i = cssPrefixes.length;
        while (i--) {
            name = cssPrefixes[i] + capName;
            if (name in style) {
                return name;
            }
        }
        return origName;
    }
    function showHide(elements, show) {
        var display, elem, hidden, values = [], index = 0, length = elements.length;
        for (; index < length; index++) {
            elem = elements[index];
            if (!elem.style) {
                continue;
            }
            values[index] = jQuery._data(elem, 'olddisplay');
            display = elem.style.display;
            if (show) {
                if (!values[index] && display === 'none') {
                    elem.style.display = '';
                }
                if (elem.style.display === '' && isHidden(elem)) {
                    values[index] = jQuery._data(elem, 'olddisplay', defaultDisplay(elem.nodeName));
                }
            } else {
                if (!values[index]) {
                    hidden = isHidden(elem);
                    if (display && display !== 'none' || !hidden) {
                        jQuery._data(elem, 'olddisplay', hidden ? display : jQuery.css(elem, 'display'));
                    }
                }
            }
        }
        for (index = 0; index < length; index++) {
            elem = elements[index];
            if (!elem.style) {
                continue;
            }
            if (!show || elem.style.display === 'none' || elem.style.display === '') {
                elem.style.display = show ? values[index] || '' : 'none';
            }
        }
        return elements;
    }
    function setPositiveNumber(elem, value, subtract) {
        var matches = rnumsplit.exec(value);
        return matches ? Math.max(0, matches[1] - (subtract || 0)) + (matches[2] || 'px') : value;
    }
    function augmentWidthOrHeight(elem, name, extra, isBorderBox, styles) {
        var i = extra === (isBorderBox ? 'border' : 'content') ? 4 : name === 'width' ? 1 : 0, val = 0;
        for (; i < 4; i += 2) {
            if (extra === 'margin') {
                val += jQuery.css(elem, extra + cssExpand[i], true, styles);
            }
            if (isBorderBox) {
                if (extra === 'content') {
                    val -= jQuery.css(elem, 'padding' + cssExpand[i], true, styles);
                }
                if (extra !== 'margin') {
                    val -= jQuery.css(elem, 'border' + cssExpand[i] + 'Width', true, styles);
                }
            } else {
                val += jQuery.css(elem, 'padding' + cssExpand[i], true, styles);
                if (extra !== 'padding') {
                    val += jQuery.css(elem, 'border' + cssExpand[i] + 'Width', true, styles);
                }
            }
        }
        return val;
    }
    function getWidthOrHeight(elem, name, extra) {
        var valueIsBorderBox = true, val = name === 'width' ? elem.offsetWidth : elem.offsetHeight, styles = getStyles(elem), isBorderBox = support.boxSizing() && jQuery.css(elem, 'boxSizing', false, styles) === 'border-box';
        if (val <= 0 || val == null) {
            val = curCSS(elem, name, styles);
            if (val < 0 || val == null) {
                val = elem.style[name];
            }
            if (rnumnonpx.test(val)) {
                return val;
            }
            valueIsBorderBox = isBorderBox && (support.boxSizingReliable() || val === elem.style[name]);
            val = parseFloat(val) || 0;
        }
        return val + augmentWidthOrHeight(elem, name, extra || (isBorderBox ? 'border' : 'content'), valueIsBorderBox, styles) + 'px';
    }
    jQuery.extend({
        cssHooks: {
            opacity: {
                get: function (elem, computed) {
                    if (computed) {
                        var ret = curCSS(elem, 'opacity');
                        return ret === '' ? '1' : ret;
                    }
                }
            }
        },
        cssNumber: {
            'columnCount': true,
            'fillOpacity': true,
            'fontWeight': true,
            'lineHeight': true,
            'opacity': true,
            'order': true,
            'orphans': true,
            'widows': true,
            'zIndex': true,
            'zoom': true
        },
        cssProps: { 'float': support.cssFloat ? 'cssFloat' : 'styleFloat' },
        style: function (elem, name, value, extra) {
            if (!elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style) {
                return;
            }
            var ret, type, hooks, origName = jQuery.camelCase(name), style = elem.style;
            name = jQuery.cssProps[origName] || (jQuery.cssProps[origName] = vendorPropName(style, origName));
            hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];
            if (value !== undefined) {
                type = typeof value;
                if (type === 'string' && (ret = rrelNum.exec(value))) {
                    value = (ret[1] + 1) * ret[2] + parseFloat(jQuery.css(elem, name));
                    type = 'number';
                }
                if (value == null || value !== value) {
                    return;
                }
                if (type === 'number' && !jQuery.cssNumber[origName]) {
                    value += 'px';
                }
                if (!support.clearCloneStyle && value === '' && name.indexOf('background') === 0) {
                    style[name] = 'inherit';
                }
                if (!hooks || !('set' in hooks) || (value = hooks.set(elem, value, extra)) !== undefined) {
                    try {
                        style[name] = '';
                        style[name] = value;
                    } catch (e) {
                    }
                }
            } else {
                if (hooks && 'get' in hooks && (ret = hooks.get(elem, false, extra)) !== undefined) {
                    return ret;
                }
                return style[name];
            }
        },
        css: function (elem, name, extra, styles) {
            var num, val, hooks, origName = jQuery.camelCase(name);
            name = jQuery.cssProps[origName] || (jQuery.cssProps[origName] = vendorPropName(elem.style, origName));
            hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];
            if (hooks && 'get' in hooks) {
                val = hooks.get(elem, true, extra);
            }
            if (val === undefined) {
                val = curCSS(elem, name, styles);
            }
            if (val === 'normal' && name in cssNormalTransform) {
                val = cssNormalTransform[name];
            }
            if (extra === '' || extra) {
                num = parseFloat(val);
                return extra === true || jQuery.isNumeric(num) ? num || 0 : val;
            }
            return val;
        }
    });
    jQuery.each([
        'height',
        'width'
    ], function (i, name) {
        jQuery.cssHooks[name] = {
            get: function (elem, computed, extra) {
                if (computed) {
                    return elem.offsetWidth === 0 && rdisplayswap.test(jQuery.css(elem, 'display')) ? jQuery.swap(elem, cssShow, function () {
                        return getWidthOrHeight(elem, name, extra);
                    }) : getWidthOrHeight(elem, name, extra);
                }
            },
            set: function (elem, value, extra) {
                var styles = extra && getStyles(elem);
                return setPositiveNumber(elem, value, extra ? augmentWidthOrHeight(elem, name, extra, support.boxSizing() && jQuery.css(elem, 'boxSizing', false, styles) === 'border-box', styles) : 0);
            }
        };
    });
    if (!support.opacity) {
        jQuery.cssHooks.opacity = {
            get: function (elem, computed) {
                return ropacity.test((computed && elem.currentStyle ? elem.currentStyle.filter : elem.style.filter) || '') ? 0.01 * parseFloat(RegExp.$1) + '' : computed ? '1' : '';
            },
            set: function (elem, value) {
                var style = elem.style, currentStyle = elem.currentStyle, opacity = jQuery.isNumeric(value) ? 'alpha(opacity=' + value * 100 + ')' : '', filter = currentStyle && currentStyle.filter || style.filter || '';
                style.zoom = 1;
                if ((value >= 1 || value === '') && jQuery.trim(filter.replace(ralpha, '')) === '' && style.removeAttribute) {
                    style.removeAttribute('filter');
                    if (value === '' || currentStyle && !currentStyle.filter) {
                        return;
                    }
                }
                style.filter = ralpha.test(filter) ? filter.replace(ralpha, opacity) : filter + ' ' + opacity;
            }
        };
    }
    jQuery.cssHooks.marginRight = addGetHookIf(support.reliableMarginRight, function (elem, computed) {
        if (computed) {
            return jQuery.swap(elem, { 'display': 'inline-block' }, curCSS, [
                elem,
                'marginRight'
            ]);
        }
    });
    jQuery.each({
        margin: '',
        padding: '',
        border: 'Width'
    }, function (prefix, suffix) {
        jQuery.cssHooks[prefix + suffix] = {
            expand: function (value) {
                var i = 0, expanded = {}, parts = typeof value === 'string' ? value.split(' ') : [value];
                for (; i < 4; i++) {
                    expanded[prefix + cssExpand[i] + suffix] = parts[i] || parts[i - 2] || parts[0];
                }
                return expanded;
            }
        };
        if (!rmargin.test(prefix)) {
            jQuery.cssHooks[prefix + suffix].set = setPositiveNumber;
        }
    });
    jQuery.fn.extend({
        css: function (name, value) {
            return access(this, function (elem, name, value) {
                var styles, len, map = {}, i = 0;
                if (jQuery.isArray(name)) {
                    styles = getStyles(elem);
                    len = name.length;
                    for (; i < len; i++) {
                        map[name[i]] = jQuery.css(elem, name[i], false, styles);
                    }
                    return map;
                }
                return value !== undefined ? jQuery.style(elem, name, value) : jQuery.css(elem, name);
            }, name, value, arguments.length > 1);
        },
        show: function () {
            return showHide(this, true);
        },
        hide: function () {
            return showHide(this);
        },
        toggle: function (state) {
            if (typeof state === 'boolean') {
                return state ? this.show() : this.hide();
            }
            return this.each(function () {
                if (isHidden(this)) {
                    jQuery(this).show();
                } else {
                    jQuery(this).hide();
                }
            });
        }
    });
    function Tween(elem, options, prop, end, easing) {
        return new Tween.prototype.init(elem, options, prop, end, easing);
    }
    jQuery.Tween = Tween;
    Tween.prototype = {
        constructor: Tween,
        init: function (elem, options, prop, end, easing, unit) {
            this.elem = elem;
            this.prop = prop;
            this.easing = easing || 'swing';
            this.options = options;
            this.start = this.now = this.cur();
            this.end = end;
            this.unit = unit || (jQuery.cssNumber[prop] ? '' : 'px');
        },
        cur: function () {
            var hooks = Tween.propHooks[this.prop];
            return hooks && hooks.get ? hooks.get(this) : Tween.propHooks._default.get(this);
        },
        run: function (percent) {
            var eased, hooks = Tween.propHooks[this.prop];
            if (this.options.duration) {
                this.pos = eased = jQuery.easing[this.easing](percent, this.options.duration * percent, 0, 1, this.options.duration);
            } else {
                this.pos = eased = percent;
            }
            this.now = (this.end - this.start) * eased + this.start;
            if (this.options.step) {
                this.options.step.call(this.elem, this.now, this);
            }
            if (hooks && hooks.set) {
                hooks.set(this);
            } else {
                Tween.propHooks._default.set(this);
            }
            return this;
        }
    };
    Tween.prototype.init.prototype = Tween.prototype;
    Tween.propHooks = {
        _default: {
            get: function (tween) {
                var result;
                if (tween.elem[tween.prop] != null && (!tween.elem.style || tween.elem.style[tween.prop] == null)) {
                    return tween.elem[tween.prop];
                }
                result = jQuery.css(tween.elem, tween.prop, '');
                return !result || result === 'auto' ? 0 : result;
            },
            set: function (tween) {
                if (jQuery.fx.step[tween.prop]) {
                    jQuery.fx.step[tween.prop](tween);
                } else if (tween.elem.style && (tween.elem.style[jQuery.cssProps[tween.prop]] != null || jQuery.cssHooks[tween.prop])) {
                    jQuery.style(tween.elem, tween.prop, tween.now + tween.unit);
                } else {
                    tween.elem[tween.prop] = tween.now;
                }
            }
        }
    };
    Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
        set: function (tween) {
            if (tween.elem.nodeType && tween.elem.parentNode) {
                tween.elem[tween.prop] = tween.now;
            }
        }
    };
    jQuery.easing = {
        linear: function (p) {
            return p;
        },
        swing: function (p) {
            return 0.5 - Math.cos(p * Math.PI) / 2;
        }
    };
    jQuery.fx = Tween.prototype.init;
    jQuery.fx.step = {};
    var fxNow, timerId, rfxtypes = /^(?:toggle|show|hide)$/, rfxnum = new RegExp('^(?:([+-])=|)(' + pnum + ')([a-z%]*)$', 'i'), rrun = /queueHooks$/, animationPrefilters = [defaultPrefilter], tweeners = {
            '*': [function (prop, value) {
                    var tween = this.createTween(prop, value), target = tween.cur(), parts = rfxnum.exec(value), unit = parts && parts[3] || (jQuery.cssNumber[prop] ? '' : 'px'), start = (jQuery.cssNumber[prop] || unit !== 'px' && +target) && rfxnum.exec(jQuery.css(tween.elem, prop)), scale = 1, maxIterations = 20;
                    if (start && start[3] !== unit) {
                        unit = unit || start[3];
                        parts = parts || [];
                        start = +target || 1;
                        do {
                            scale = scale || '.5';
                            start = start / scale;
                            jQuery.style(tween.elem, prop, start + unit);
                        } while (scale !== (scale = tween.cur() / target) && scale !== 1 && --maxIterations);
                    }
                    if (parts) {
                        start = tween.start = +start || +target || 0;
                        tween.unit = unit;
                        tween.end = parts[1] ? start + (parts[1] + 1) * parts[2] : +parts[2];
                    }
                    return tween;
                }]
        };
    function createFxNow() {
        setTimeout(function () {
            fxNow = undefined;
        });
        return fxNow = jQuery.now();
    }
    function genFx(type, includeWidth) {
        var which, attrs = { height: type }, i = 0;
        includeWidth = includeWidth ? 1 : 0;
        for (; i < 4; i += 2 - includeWidth) {
            which = cssExpand[i];
            attrs['margin' + which] = attrs['padding' + which] = type;
        }
        if (includeWidth) {
            attrs.opacity = attrs.width = type;
        }
        return attrs;
    }
    function createTween(value, prop, animation) {
        var tween, collection = (tweeners[prop] || []).concat(tweeners['*']), index = 0, length = collection.length;
        for (; index < length; index++) {
            if (tween = collection[index].call(animation, prop, value)) {
                return tween;
            }
        }
    }
    function defaultPrefilter(elem, props, opts) {
        var prop, value, toggle, tween, hooks, oldfire, display, dDisplay, anim = this, orig = {}, style = elem.style, hidden = elem.nodeType && isHidden(elem), dataShow = jQuery._data(elem, 'fxshow');
        if (!opts.queue) {
            hooks = jQuery._queueHooks(elem, 'fx');
            if (hooks.unqueued == null) {
                hooks.unqueued = 0;
                oldfire = hooks.empty.fire;
                hooks.empty.fire = function () {
                    if (!hooks.unqueued) {
                        oldfire();
                    }
                };
            }
            hooks.unqueued++;
            anim.always(function () {
                anim.always(function () {
                    hooks.unqueued--;
                    if (!jQuery.queue(elem, 'fx').length) {
                        hooks.empty.fire();
                    }
                });
            });
        }
        if (elem.nodeType === 1 && ('height' in props || 'width' in props)) {
            opts.overflow = [
                style.overflow,
                style.overflowX,
                style.overflowY
            ];
            display = jQuery.css(elem, 'display');
            dDisplay = defaultDisplay(elem.nodeName);
            if (display === 'none') {
                display = dDisplay;
            }
            if (display === 'inline' && jQuery.css(elem, 'float') === 'none') {
                if (!support.inlineBlockNeedsLayout || dDisplay === 'inline') {
                    style.display = 'inline-block';
                } else {
                    style.zoom = 1;
                }
            }
        }
        if (opts.overflow) {
            style.overflow = 'hidden';
            if (!support.shrinkWrapBlocks()) {
                anim.always(function () {
                    style.overflow = opts.overflow[0];
                    style.overflowX = opts.overflow[1];
                    style.overflowY = opts.overflow[2];
                });
            }
        }
        for (prop in props) {
            value = props[prop];
            if (rfxtypes.exec(value)) {
                delete props[prop];
                toggle = toggle || value === 'toggle';
                if (value === (hidden ? 'hide' : 'show')) {
                    if (value === 'show' && dataShow && dataShow[prop] !== undefined) {
                        hidden = true;
                    } else {
                        continue;
                    }
                }
                orig[prop] = dataShow && dataShow[prop] || jQuery.style(elem, prop);
            }
        }
        if (!jQuery.isEmptyObject(orig)) {
            if (dataShow) {
                if ('hidden' in dataShow) {
                    hidden = dataShow.hidden;
                }
            } else {
                dataShow = jQuery._data(elem, 'fxshow', {});
            }
            if (toggle) {
                dataShow.hidden = !hidden;
            }
            if (hidden) {
                jQuery(elem).show();
            } else {
                anim.done(function () {
                    jQuery(elem).hide();
                });
            }
            anim.done(function () {
                var prop;
                jQuery._removeData(elem, 'fxshow');
                for (prop in orig) {
                    jQuery.style(elem, prop, orig[prop]);
                }
            });
            for (prop in orig) {
                tween = createTween(hidden ? dataShow[prop] : 0, prop, anim);
                if (!(prop in dataShow)) {
                    dataShow[prop] = tween.start;
                    if (hidden) {
                        tween.end = tween.start;
                        tween.start = prop === 'width' || prop === 'height' ? 1 : 0;
                    }
                }
            }
        }
    }
    function propFilter(props, specialEasing) {
        var index, name, easing, value, hooks;
        for (index in props) {
            name = jQuery.camelCase(index);
            easing = specialEasing[name];
            value = props[index];
            if (jQuery.isArray(value)) {
                easing = value[1];
                value = props[index] = value[0];
            }
            if (index !== name) {
                props[name] = value;
                delete props[index];
            }
            hooks = jQuery.cssHooks[name];
            if (hooks && 'expand' in hooks) {
                value = hooks.expand(value);
                delete props[name];
                for (index in value) {
                    if (!(index in props)) {
                        props[index] = value[index];
                        specialEasing[index] = easing;
                    }
                }
            } else {
                specialEasing[name] = easing;
            }
        }
    }
    function Animation(elem, properties, options) {
        var result, stopped, index = 0, length = animationPrefilters.length, deferred = jQuery.Deferred().always(function () {
                delete tick.elem;
            }), tick = function () {
                if (stopped) {
                    return false;
                }
                var currentTime = fxNow || createFxNow(), remaining = Math.max(0, animation.startTime + animation.duration - currentTime), temp = remaining / animation.duration || 0, percent = 1 - temp, index = 0, length = animation.tweens.length;
                for (; index < length; index++) {
                    animation.tweens[index].run(percent);
                }
                deferred.notifyWith(elem, [
                    animation,
                    percent,
                    remaining
                ]);
                if (percent < 1 && length) {
                    return remaining;
                } else {
                    deferred.resolveWith(elem, [animation]);
                    return false;
                }
            }, animation = deferred.promise({
                elem: elem,
                props: jQuery.extend({}, properties),
                opts: jQuery.extend(true, { specialEasing: {} }, options),
                originalProperties: properties,
                originalOptions: options,
                startTime: fxNow || createFxNow(),
                duration: options.duration,
                tweens: [],
                createTween: function (prop, end) {
                    var tween = jQuery.Tween(elem, animation.opts, prop, end, animation.opts.specialEasing[prop] || animation.opts.easing);
                    animation.tweens.push(tween);
                    return tween;
                },
                stop: function (gotoEnd) {
                    var index = 0, length = gotoEnd ? animation.tweens.length : 0;
                    if (stopped) {
                        return this;
                    }
                    stopped = true;
                    for (; index < length; index++) {
                        animation.tweens[index].run(1);
                    }
                    if (gotoEnd) {
                        deferred.resolveWith(elem, [
                            animation,
                            gotoEnd
                        ]);
                    } else {
                        deferred.rejectWith(elem, [
                            animation,
                            gotoEnd
                        ]);
                    }
                    return this;
                }
            }), props = animation.props;
        propFilter(props, animation.opts.specialEasing);
        for (; index < length; index++) {
            result = animationPrefilters[index].call(animation, elem, props, animation.opts);
            if (result) {
                return result;
            }
        }
        jQuery.map(props, createTween, animation);
        if (jQuery.isFunction(animation.opts.start)) {
            animation.opts.start.call(elem, animation);
        }
        jQuery.fx.timer(jQuery.extend(tick, {
            elem: elem,
            anim: animation,
            queue: animation.opts.queue
        }));
        return animation.progress(animation.opts.progress).done(animation.opts.done, animation.opts.complete).fail(animation.opts.fail).always(animation.opts.always);
    }
    jQuery.Animation = jQuery.extend(Animation, {
        tweener: function (props, callback) {
            if (jQuery.isFunction(props)) {
                callback = props;
                props = ['*'];
            } else {
                props = props.split(' ');
            }
            var prop, index = 0, length = props.length;
            for (; index < length; index++) {
                prop = props[index];
                tweeners[prop] = tweeners[prop] || [];
                tweeners[prop].unshift(callback);
            }
        },
        prefilter: function (callback, prepend) {
            if (prepend) {
                animationPrefilters.unshift(callback);
            } else {
                animationPrefilters.push(callback);
            }
        }
    });
    jQuery.speed = function (speed, easing, fn) {
        var opt = speed && typeof speed === 'object' ? jQuery.extend({}, speed) : {
            complete: fn || !fn && easing || jQuery.isFunction(speed) && speed,
            duration: speed,
            easing: fn && easing || easing && !jQuery.isFunction(easing) && easing
        };
        opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === 'number' ? opt.duration : opt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[opt.duration] : jQuery.fx.speeds._default;
        if (opt.queue == null || opt.queue === true) {
            opt.queue = 'fx';
        }
        opt.old = opt.complete;
        opt.complete = function () {
            if (jQuery.isFunction(opt.old)) {
                opt.old.call(this);
            }
            if (opt.queue) {
                jQuery.dequeue(this, opt.queue);
            }
        };
        return opt;
    };
    jQuery.fn.extend({
        fadeTo: function (speed, to, easing, callback) {
            return this.filter(isHidden).css('opacity', 0).show().end().animate({ opacity: to }, speed, easing, callback);
        },
        animate: function (prop, speed, easing, callback) {
            var empty = jQuery.isEmptyObject(prop), optall = jQuery.speed(speed, easing, callback), doAnimation = function () {
                    var anim = Animation(this, jQuery.extend({}, prop), optall);
                    if (empty || jQuery._data(this, 'finish')) {
                        anim.stop(true);
                    }
                };
            doAnimation.finish = doAnimation;
            return empty || optall.queue === false ? this.each(doAnimation) : this.queue(optall.queue, doAnimation);
        },
        stop: function (type, clearQueue, gotoEnd) {
            var stopQueue = function (hooks) {
                var stop = hooks.stop;
                delete hooks.stop;
                stop(gotoEnd);
            };
            if (typeof type !== 'string') {
                gotoEnd = clearQueue;
                clearQueue = type;
                type = undefined;
            }
            if (clearQueue && type !== false) {
                this.queue(type || 'fx', []);
            }
            return this.each(function () {
                var dequeue = true, index = type != null && type + 'queueHooks', timers = jQuery.timers, data = jQuery._data(this);
                if (index) {
                    if (data[index] && data[index].stop) {
                        stopQueue(data[index]);
                    }
                } else {
                    for (index in data) {
                        if (data[index] && data[index].stop && rrun.test(index)) {
                            stopQueue(data[index]);
                        }
                    }
                }
                for (index = timers.length; index--;) {
                    if (timers[index].elem === this && (type == null || timers[index].queue === type)) {
                        timers[index].anim.stop(gotoEnd);
                        dequeue = false;
                        timers.splice(index, 1);
                    }
                }
                if (dequeue || !gotoEnd) {
                    jQuery.dequeue(this, type);
                }
            });
        },
        finish: function (type) {
            if (type !== false) {
                type = type || 'fx';
            }
            return this.each(function () {
                var index, data = jQuery._data(this), queue = data[type + 'queue'], hooks = data[type + 'queueHooks'], timers = jQuery.timers, length = queue ? queue.length : 0;
                data.finish = true;
                jQuery.queue(this, type, []);
                if (hooks && hooks.stop) {
                    hooks.stop.call(this, true);
                }
                for (index = timers.length; index--;) {
                    if (timers[index].elem === this && timers[index].queue === type) {
                        timers[index].anim.stop(true);
                        timers.splice(index, 1);
                    }
                }
                for (index = 0; index < length; index++) {
                    if (queue[index] && queue[index].finish) {
                        queue[index].finish.call(this);
                    }
                }
                delete data.finish;
            });
        }
    });
    jQuery.each([
        'toggle',
        'show',
        'hide'
    ], function (i, name) {
        var cssFn = jQuery.fn[name];
        jQuery.fn[name] = function (speed, easing, callback) {
            return speed == null || typeof speed === 'boolean' ? cssFn.apply(this, arguments) : this.animate(genFx(name, true), speed, easing, callback);
        };
    });
    jQuery.each({
        slideDown: genFx('show'),
        slideUp: genFx('hide'),
        slideToggle: genFx('toggle'),
        fadeIn: { opacity: 'show' },
        fadeOut: { opacity: 'hide' },
        fadeToggle: { opacity: 'toggle' }
    }, function (name, props) {
        jQuery.fn[name] = function (speed, easing, callback) {
            return this.animate(props, speed, easing, callback);
        };
    });
    jQuery.timers = [];
    jQuery.fx.tick = function () {
        var timer, timers = jQuery.timers, i = 0;
        fxNow = jQuery.now();
        for (; i < timers.length; i++) {
            timer = timers[i];
            if (!timer() && timers[i] === timer) {
                timers.splice(i--, 1);
            }
        }
        if (!timers.length) {
            jQuery.fx.stop();
        }
        fxNow = undefined;
    };
    jQuery.fx.timer = function (timer) {
        jQuery.timers.push(timer);
        if (timer()) {
            jQuery.fx.start();
        } else {
            jQuery.timers.pop();
        }
    };
    jQuery.fx.interval = 13;
    jQuery.fx.start = function () {
        if (!timerId) {
            timerId = setInterval(jQuery.fx.tick, jQuery.fx.interval);
        }
    };
    jQuery.fx.stop = function () {
        clearInterval(timerId);
        timerId = null;
    };
    jQuery.fx.speeds = {
        slow: 600,
        fast: 200,
        _default: 400
    };
    jQuery.fn.delay = function (time, type) {
        time = jQuery.fx ? jQuery.fx.speeds[time] || time : time;
        type = type || 'fx';
        return this.queue(type, function (next, hooks) {
            var timeout = setTimeout(next, time);
            hooks.stop = function () {
                clearTimeout(timeout);
            };
        });
    };
    (function () {
        var a, input, select, opt, div = document.createElement('div');
        div.setAttribute('className', 't');
        div.innerHTML = '  <link/><table></table><a href=\'/a\'>a</a><input type=\'checkbox\'/>';
        a = div.getElementsByTagName('a')[0];
        select = document.createElement('select');
        opt = select.appendChild(document.createElement('option'));
        input = div.getElementsByTagName('input')[0];
        a.style.cssText = 'top:1px';
        support.getSetAttribute = div.className !== 't';
        support.style = /top/.test(a.getAttribute('style'));
        support.hrefNormalized = a.getAttribute('href') === '/a';
        support.checkOn = !!input.value;
        support.optSelected = opt.selected;
        support.enctype = !!document.createElement('form').enctype;
        select.disabled = true;
        support.optDisabled = !opt.disabled;
        input = document.createElement('input');
        input.setAttribute('value', '');
        support.input = input.getAttribute('value') === '';
        input.value = 't';
        input.setAttribute('type', 'radio');
        support.radioValue = input.value === 't';
        a = input = select = opt = div = null;
    }());
    var rreturn = /\r/g;
    jQuery.fn.extend({
        val: function (value) {
            var hooks, ret, isFunction, elem = this[0];
            if (!arguments.length) {
                if (elem) {
                    hooks = jQuery.valHooks[elem.type] || jQuery.valHooks[elem.nodeName.toLowerCase()];
                    if (hooks && 'get' in hooks && (ret = hooks.get(elem, 'value')) !== undefined) {
                        return ret;
                    }
                    ret = elem.value;
                    return typeof ret === 'string' ? ret.replace(rreturn, '') : ret == null ? '' : ret;
                }
                return;
            }
            isFunction = jQuery.isFunction(value);
            return this.each(function (i) {
                var val;
                if (this.nodeType !== 1) {
                    return;
                }
                if (isFunction) {
                    val = value.call(this, i, jQuery(this).val());
                } else {
                    val = value;
                }
                if (val == null) {
                    val = '';
                } else if (typeof val === 'number') {
                    val += '';
                } else if (jQuery.isArray(val)) {
                    val = jQuery.map(val, function (value) {
                        return value == null ? '' : value + '';
                    });
                }
                hooks = jQuery.valHooks[this.type] || jQuery.valHooks[this.nodeName.toLowerCase()];
                if (!hooks || !('set' in hooks) || hooks.set(this, val, 'value') === undefined) {
                    this.value = val;
                }
            });
        }
    });
    jQuery.extend({
        valHooks: {
            option: {
                get: function (elem) {
                    var val = jQuery.find.attr(elem, 'value');
                    return val != null ? val : jQuery.text(elem);
                }
            },
            select: {
                get: function (elem) {
                    var value, option, options = elem.options, index = elem.selectedIndex, one = elem.type === 'select-one' || index < 0, values = one ? null : [], max = one ? index + 1 : options.length, i = index < 0 ? max : one ? index : 0;
                    for (; i < max; i++) {
                        option = options[i];
                        if ((option.selected || i === index) && (support.optDisabled ? !option.disabled : option.getAttribute('disabled') === null) && (!option.parentNode.disabled || !jQuery.nodeName(option.parentNode, 'optgroup'))) {
                            value = jQuery(option).val();
                            if (one) {
                                return value;
                            }
                            values.push(value);
                        }
                    }
                    return values;
                },
                set: function (elem, value) {
                    var optionSet, option, options = elem.options, values = jQuery.makeArray(value), i = options.length;
                    while (i--) {
                        option = options[i];
                        if (jQuery.inArray(jQuery.valHooks.option.get(option), values) >= 0) {
                            try {
                                option.selected = optionSet = true;
                            } catch (_) {
                                option.scrollHeight;
                            }
                        } else {
                            option.selected = false;
                        }
                    }
                    if (!optionSet) {
                        elem.selectedIndex = -1;
                    }
                    return options;
                }
            }
        }
    });
    jQuery.each([
        'radio',
        'checkbox'
    ], function () {
        jQuery.valHooks[this] = {
            set: function (elem, value) {
                if (jQuery.isArray(value)) {
                    return elem.checked = jQuery.inArray(jQuery(elem).val(), value) >= 0;
                }
            }
        };
        if (!support.checkOn) {
            jQuery.valHooks[this].get = function (elem) {
                return elem.getAttribute('value') === null ? 'on' : elem.value;
            };
        }
    });
    var nodeHook, boolHook, attrHandle = jQuery.expr.attrHandle, ruseDefault = /^(?:checked|selected)$/i, getSetAttribute = support.getSetAttribute, getSetInput = support.input;
    jQuery.fn.extend({
        attr: function (name, value) {
            return access(this, jQuery.attr, name, value, arguments.length > 1);
        },
        removeAttr: function (name) {
            return this.each(function () {
                jQuery.removeAttr(this, name);
            });
        }
    });
    jQuery.extend({
        attr: function (elem, name, value) {
            var hooks, ret, nType = elem.nodeType;
            if (!elem || nType === 3 || nType === 8 || nType === 2) {
                return;
            }
            if (typeof elem.getAttribute === strundefined) {
                return jQuery.prop(elem, name, value);
            }
            if (nType !== 1 || !jQuery.isXMLDoc(elem)) {
                name = name.toLowerCase();
                hooks = jQuery.attrHooks[name] || (jQuery.expr.match.bool.test(name) ? boolHook : nodeHook);
            }
            if (value !== undefined) {
                if (value === null) {
                    jQuery.removeAttr(elem, name);
                } else if (hooks && 'set' in hooks && (ret = hooks.set(elem, value, name)) !== undefined) {
                    return ret;
                } else {
                    elem.setAttribute(name, value + '');
                    return value;
                }
            } else if (hooks && 'get' in hooks && (ret = hooks.get(elem, name)) !== null) {
                return ret;
            } else {
                ret = jQuery.find.attr(elem, name);
                return ret == null ? undefined : ret;
            }
        },
        removeAttr: function (elem, value) {
            var name, propName, i = 0, attrNames = value && value.match(rnotwhite);
            if (attrNames && elem.nodeType === 1) {
                while (name = attrNames[i++]) {
                    propName = jQuery.propFix[name] || name;
                    if (jQuery.expr.match.bool.test(name)) {
                        if (getSetInput && getSetAttribute || !ruseDefault.test(name)) {
                            elem[propName] = false;
                        } else {
                            elem[jQuery.camelCase('default-' + name)] = elem[propName] = false;
                        }
                    } else {
                        jQuery.attr(elem, name, '');
                    }
                    elem.removeAttribute(getSetAttribute ? name : propName);
                }
            }
        },
        attrHooks: {
            type: {
                set: function (elem, value) {
                    if (!support.radioValue && value === 'radio' && jQuery.nodeName(elem, 'input')) {
                        var val = elem.value;
                        elem.setAttribute('type', value);
                        if (val) {
                            elem.value = val;
                        }
                        return value;
                    }
                }
            }
        }
    });
    boolHook = {
        set: function (elem, value, name) {
            if (value === false) {
                jQuery.removeAttr(elem, name);
            } else if (getSetInput && getSetAttribute || !ruseDefault.test(name)) {
                elem.setAttribute(!getSetAttribute && jQuery.propFix[name] || name, name);
            } else {
                elem[jQuery.camelCase('default-' + name)] = elem[name] = true;
            }
            return name;
        }
    };
    jQuery.each(jQuery.expr.match.bool.source.match(/\w+/g), function (i, name) {
        var getter = attrHandle[name] || jQuery.find.attr;
        attrHandle[name] = getSetInput && getSetAttribute || !ruseDefault.test(name) ? function (elem, name, isXML) {
            var ret, handle;
            if (!isXML) {
                handle = attrHandle[name];
                attrHandle[name] = ret;
                ret = getter(elem, name, isXML) != null ? name.toLowerCase() : null;
                attrHandle[name] = handle;
            }
            return ret;
        } : function (elem, name, isXML) {
            if (!isXML) {
                return elem[jQuery.camelCase('default-' + name)] ? name.toLowerCase() : null;
            }
        };
    });
    if (!getSetInput || !getSetAttribute) {
        jQuery.attrHooks.value = {
            set: function (elem, value, name) {
                if (jQuery.nodeName(elem, 'input')) {
                    elem.defaultValue = value;
                } else {
                    return nodeHook && nodeHook.set(elem, value, name);
                }
            }
        };
    }
    if (!getSetAttribute) {
        nodeHook = {
            set: function (elem, value, name) {
                var ret = elem.getAttributeNode(name);
                if (!ret) {
                    elem.setAttributeNode(ret = elem.ownerDocument.createAttribute(name));
                }
                ret.value = value += '';
                if (name === 'value' || value === elem.getAttribute(name)) {
                    return value;
                }
            }
        };
        attrHandle.id = attrHandle.name = attrHandle.coords = function (elem, name, isXML) {
            var ret;
            if (!isXML) {
                return (ret = elem.getAttributeNode(name)) && ret.value !== '' ? ret.value : null;
            }
        };
        jQuery.valHooks.button = {
            get: function (elem, name) {
                var ret = elem.getAttributeNode(name);
                if (ret && ret.specified) {
                    return ret.value;
                }
            },
            set: nodeHook.set
        };
        jQuery.attrHooks.contenteditable = {
            set: function (elem, value, name) {
                nodeHook.set(elem, value === '' ? false : value, name);
            }
        };
        jQuery.each([
            'width',
            'height'
        ], function (i, name) {
            jQuery.attrHooks[name] = {
                set: function (elem, value) {
                    if (value === '') {
                        elem.setAttribute(name, 'auto');
                        return value;
                    }
                }
            };
        });
    }
    if (!support.style) {
        jQuery.attrHooks.style = {
            get: function (elem) {
                return elem.style.cssText || undefined;
            },
            set: function (elem, value) {
                return elem.style.cssText = value + '';
            }
        };
    }
    var rfocusable = /^(?:input|select|textarea|button|object)$/i, rclickable = /^(?:a|area)$/i;
    jQuery.fn.extend({
        prop: function (name, value) {
            return access(this, jQuery.prop, name, value, arguments.length > 1);
        },
        removeProp: function (name) {
            name = jQuery.propFix[name] || name;
            return this.each(function () {
                try {
                    this[name] = undefined;
                    delete this[name];
                } catch (e) {
                }
            });
        }
    });
    jQuery.extend({
        propFix: {
            'for': 'htmlFor',
            'class': 'className'
        },
        prop: function (elem, name, value) {
            var ret, hooks, notxml, nType = elem.nodeType;
            if (!elem || nType === 3 || nType === 8 || nType === 2) {
                return;
            }
            notxml = nType !== 1 || !jQuery.isXMLDoc(elem);
            if (notxml) {
                name = jQuery.propFix[name] || name;
                hooks = jQuery.propHooks[name];
            }
            if (value !== undefined) {
                return hooks && 'set' in hooks && (ret = hooks.set(elem, value, name)) !== undefined ? ret : elem[name] = value;
            } else {
                return hooks && 'get' in hooks && (ret = hooks.get(elem, name)) !== null ? ret : elem[name];
            }
        },
        propHooks: {
            tabIndex: {
                get: function (elem) {
                    var tabindex = jQuery.find.attr(elem, 'tabindex');
                    return tabindex ? parseInt(tabindex, 10) : rfocusable.test(elem.nodeName) || rclickable.test(elem.nodeName) && elem.href ? 0 : -1;
                }
            }
        }
    });
    if (!support.hrefNormalized) {
        jQuery.each([
            'href',
            'src'
        ], function (i, name) {
            jQuery.propHooks[name] = {
                get: function (elem) {
                    return elem.getAttribute(name, 4);
                }
            };
        });
    }
    if (!support.optSelected) {
        jQuery.propHooks.selected = {
            get: function (elem) {
                var parent = elem.parentNode;
                if (parent) {
                    parent.selectedIndex;
                    if (parent.parentNode) {
                        parent.parentNode.selectedIndex;
                    }
                }
                return null;
            }
        };
    }
    jQuery.each([
        'tabIndex',
        'readOnly',
        'maxLength',
        'cellSpacing',
        'cellPadding',
        'rowSpan',
        'colSpan',
        'useMap',
        'frameBorder',
        'contentEditable'
    ], function () {
        jQuery.propFix[this.toLowerCase()] = this;
    });
    if (!support.enctype) {
        jQuery.propFix.enctype = 'encoding';
    }
    var rclass = /[\t\r\n\f]/g;
    jQuery.fn.extend({
        addClass: function (value) {
            var classes, elem, cur, clazz, j, finalValue, i = 0, len = this.length, proceed = typeof value === 'string' && value;
            if (jQuery.isFunction(value)) {
                return this.each(function (j) {
                    jQuery(this).addClass(value.call(this, j, this.className));
                });
            }
            if (proceed) {
                classes = (value || '').match(rnotwhite) || [];
                for (; i < len; i++) {
                    elem = this[i];
                    cur = elem.nodeType === 1 && (elem.className ? (' ' + elem.className + ' ').replace(rclass, ' ') : ' ');
                    if (cur) {
                        j = 0;
                        while (clazz = classes[j++]) {
                            if (cur.indexOf(' ' + clazz + ' ') < 0) {
                                cur += clazz + ' ';
                            }
                        }
                        finalValue = jQuery.trim(cur);
                        if (elem.className !== finalValue) {
                            elem.className = finalValue;
                        }
                    }
                }
            }
            return this;
        },
        removeClass: function (value) {
            var classes, elem, cur, clazz, j, finalValue, i = 0, len = this.length, proceed = arguments.length === 0 || typeof value === 'string' && value;
            if (jQuery.isFunction(value)) {
                return this.each(function (j) {
                    jQuery(this).removeClass(value.call(this, j, this.className));
                });
            }
            if (proceed) {
                classes = (value || '').match(rnotwhite) || [];
                for (; i < len; i++) {
                    elem = this[i];
                    cur = elem.nodeType === 1 && (elem.className ? (' ' + elem.className + ' ').replace(rclass, ' ') : '');
                    if (cur) {
                        j = 0;
                        while (clazz = classes[j++]) {
                            while (cur.indexOf(' ' + clazz + ' ') >= 0) {
                                cur = cur.replace(' ' + clazz + ' ', ' ');
                            }
                        }
                        finalValue = value ? jQuery.trim(cur) : '';
                        if (elem.className !== finalValue) {
                            elem.className = finalValue;
                        }
                    }
                }
            }
            return this;
        },
        toggleClass: function (value, stateVal) {
            var type = typeof value;
            if (typeof stateVal === 'boolean' && type === 'string') {
                return stateVal ? this.addClass(value) : this.removeClass(value);
            }
            if (jQuery.isFunction(value)) {
                return this.each(function (i) {
                    jQuery(this).toggleClass(value.call(this, i, this.className, stateVal), stateVal);
                });
            }
            return this.each(function () {
                if (type === 'string') {
                    var className, i = 0, self = jQuery(this), classNames = value.match(rnotwhite) || [];
                    while (className = classNames[i++]) {
                        if (self.hasClass(className)) {
                            self.removeClass(className);
                        } else {
                            self.addClass(className);
                        }
                    }
                } else if (type === strundefined || type === 'boolean') {
                    if (this.className) {
                        jQuery._data(this, '__className__', this.className);
                    }
                    this.className = this.className || value === false ? '' : jQuery._data(this, '__className__') || '';
                }
            });
        },
        hasClass: function (selector) {
            var className = ' ' + selector + ' ', i = 0, l = this.length;
            for (; i < l; i++) {
                if (this[i].nodeType === 1 && (' ' + this[i].className + ' ').replace(rclass, ' ').indexOf(className) >= 0) {
                    return true;
                }
            }
            return false;
        }
    });
    jQuery.each(('blur focus focusin focusout load resize scroll unload click dblclick ' + 'mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave ' + 'change select submit keydown keypress keyup error contextmenu').split(' '), function (i, name) {
        jQuery.fn[name] = function (data, fn) {
            return arguments.length > 0 ? this.on(name, null, data, fn) : this.trigger(name);
        };
    });
    jQuery.fn.extend({
        hover: function (fnOver, fnOut) {
            return this.mouseenter(fnOver).mouseleave(fnOut || fnOver);
        },
        bind: function (types, data, fn) {
            return this.on(types, null, data, fn);
        },
        unbind: function (types, fn) {
            return this.off(types, null, fn);
        },
        delegate: function (selector, types, data, fn) {
            return this.on(types, selector, data, fn);
        },
        undelegate: function (selector, types, fn) {
            return arguments.length === 1 ? this.off(selector, '**') : this.off(types, selector || '**', fn);
        }
    });
    var nonce = jQuery.now();
    var rquery = /\?/;
    var rvalidtokens = /(,)|(\[|{)|(}|])|"(?:[^"\\\r\n]|\\["\\\/bfnrt]|\\u[\da-fA-F]{4})*"\s*:?|true|false|null|-?(?!0\d)\d+(?:\.\d+|)(?:[eE][+-]?\d+|)/g;
    jQuery.parseJSON = function (data) {
        if (window.JSON && window.JSON.parse) {
            return window.JSON.parse(data + '');
        }
        var requireNonComma, depth = null, str = jQuery.trim(data + '');
        return str && !jQuery.trim(str.replace(rvalidtokens, function (token, comma, open, close) {
            if (requireNonComma && comma) {
                depth = 0;
            }
            if (depth === 0) {
                return token;
            }
            requireNonComma = open || comma;
            depth += !close - !open;
            return '';
        })) ? Function('return ' + str)() : jQuery.error('Invalid JSON: ' + data);
    };
    jQuery.parseXML = function (data) {
        var xml, tmp;
        if (!data || typeof data !== 'string') {
            return null;
        }
        try {
            if (window.DOMParser) {
                tmp = new DOMParser();
                xml = tmp.parseFromString(data, 'text/xml');
            } else {
                xml = new ActiveXObject('Microsoft.XMLDOM');
                xml.async = 'false';
                xml.loadXML(data);
            }
        } catch (e) {
            xml = undefined;
        }
        if (!xml || !xml.documentElement || xml.getElementsByTagName('parsererror').length) {
            jQuery.error('Invalid XML: ' + data);
        }
        return xml;
    };
    var ajaxLocParts, ajaxLocation, rhash = /#.*$/, rts = /([?&])_=[^&]*/, rheaders = /^(.*?):[ \t]*([^\r\n]*)\r?$/mg, rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/, rnoContent = /^(?:GET|HEAD)$/, rprotocol = /^\/\//, rurl = /^([\w.+-]+:)(?:\/\/(?:[^\/?#]*@|)([^\/?#:]*)(?::(\d+)|)|)/, prefilters = {}, transports = {}, allTypes = '*/'.concat('*');
    try {
        ajaxLocation = location.href;
    } catch (e) {
        ajaxLocation = document.createElement('a');
        ajaxLocation.href = '';
        ajaxLocation = ajaxLocation.href;
    }
    ajaxLocParts = rurl.exec(ajaxLocation.toLowerCase()) || [];
    function addToPrefiltersOrTransports(structure) {
        return function (dataTypeExpression, func) {
            if (typeof dataTypeExpression !== 'string') {
                func = dataTypeExpression;
                dataTypeExpression = '*';
            }
            var dataType, i = 0, dataTypes = dataTypeExpression.toLowerCase().match(rnotwhite) || [];
            if (jQuery.isFunction(func)) {
                while (dataType = dataTypes[i++]) {
                    if (dataType.charAt(0) === '+') {
                        dataType = dataType.slice(1) || '*';
                        (structure[dataType] = structure[dataType] || []).unshift(func);
                    } else {
                        (structure[dataType] = structure[dataType] || []).push(func);
                    }
                }
            }
        };
    }
    function inspectPrefiltersOrTransports(structure, options, originalOptions, jqXHR) {
        var inspected = {}, seekingTransport = structure === transports;
        function inspect(dataType) {
            var selected;
            inspected[dataType] = true;
            jQuery.each(structure[dataType] || [], function (_, prefilterOrFactory) {
                var dataTypeOrTransport = prefilterOrFactory(options, originalOptions, jqXHR);
                if (typeof dataTypeOrTransport === 'string' && !seekingTransport && !inspected[dataTypeOrTransport]) {
                    options.dataTypes.unshift(dataTypeOrTransport);
                    inspect(dataTypeOrTransport);
                    return false;
                } else if (seekingTransport) {
                    return !(selected = dataTypeOrTransport);
                }
            });
            return selected;
        }
        return inspect(options.dataTypes[0]) || !inspected['*'] && inspect('*');
    }
    function ajaxExtend(target, src) {
        var deep, key, flatOptions = jQuery.ajaxSettings.flatOptions || {};
        for (key in src) {
            if (src[key] !== undefined) {
                (flatOptions[key] ? target : deep || (deep = {}))[key] = src[key];
            }
        }
        if (deep) {
            jQuery.extend(true, target, deep);
        }
        return target;
    }
    function ajaxHandleResponses(s, jqXHR, responses) {
        var firstDataType, ct, finalDataType, type, contents = s.contents, dataTypes = s.dataTypes;
        while (dataTypes[0] === '*') {
            dataTypes.shift();
            if (ct === undefined) {
                ct = s.mimeType || jqXHR.getResponseHeader('Content-Type');
            }
        }
        if (ct) {
            for (type in contents) {
                if (contents[type] && contents[type].test(ct)) {
                    dataTypes.unshift(type);
                    break;
                }
            }
        }
        if (dataTypes[0] in responses) {
            finalDataType = dataTypes[0];
        } else {
            for (type in responses) {
                if (!dataTypes[0] || s.converters[type + ' ' + dataTypes[0]]) {
                    finalDataType = type;
                    break;
                }
                if (!firstDataType) {
                    firstDataType = type;
                }
            }
            finalDataType = finalDataType || firstDataType;
        }
        if (finalDataType) {
            if (finalDataType !== dataTypes[0]) {
                dataTypes.unshift(finalDataType);
            }
            return responses[finalDataType];
        }
    }
    function ajaxConvert(s, response, jqXHR, isSuccess) {
        var conv2, current, conv, tmp, prev, converters = {}, dataTypes = s.dataTypes.slice();
        if (dataTypes[1]) {
            for (conv in s.converters) {
                converters[conv.toLowerCase()] = s.converters[conv];
            }
        }
        current = dataTypes.shift();
        while (current) {
            if (s.responseFields[current]) {
                jqXHR[s.responseFields[current]] = response;
            }
            if (!prev && isSuccess && s.dataFilter) {
                response = s.dataFilter(response, s.dataType);
            }
            prev = current;
            current = dataTypes.shift();
            if (current) {
                if (current === '*') {
                    current = prev;
                } else if (prev !== '*' && prev !== current) {
                    conv = converters[prev + ' ' + current] || converters['* ' + current];
                    if (!conv) {
                        for (conv2 in converters) {
                            tmp = conv2.split(' ');
                            if (tmp[1] === current) {
                                conv = converters[prev + ' ' + tmp[0]] || converters['* ' + tmp[0]];
                                if (conv) {
                                    if (conv === true) {
                                        conv = converters[conv2];
                                    } else if (converters[conv2] !== true) {
                                        current = tmp[0];
                                        dataTypes.unshift(tmp[1]);
                                    }
                                    break;
                                }
                            }
                        }
                    }
                    if (conv !== true) {
                        if (conv && s['throws']) {
                            response = conv(response);
                        } else {
                            try {
                                response = conv(response);
                            } catch (e) {
                                return {
                                    state: 'parsererror',
                                    error: conv ? e : 'No conversion from ' + prev + ' to ' + current
                                };
                            }
                        }
                    }
                }
            }
        }
        return {
            state: 'success',
            data: response
        };
    }
    jQuery.extend({
        active: 0,
        lastModified: {},
        etag: {},
        ajaxSettings: {
            url: ajaxLocation,
            type: 'GET',
            isLocal: rlocalProtocol.test(ajaxLocParts[1]),
            global: true,
            processData: true,
            async: true,
            contentType: 'application/x-www-form-urlencoded; charset=UTF-8',
            accepts: {
                '*': allTypes,
                text: 'text/plain',
                html: 'text/html',
                xml: 'application/xml, text/xml',
                json: 'application/json, text/javascript'
            },
            contents: {
                xml: /xml/,
                html: /html/,
                json: /json/
            },
            responseFields: {
                xml: 'responseXML',
                text: 'responseText',
                json: 'responseJSON'
            },
            converters: {
                '* text': String,
                'text html': true,
                'text json': jQuery.parseJSON,
                'text xml': jQuery.parseXML
            },
            flatOptions: {
                url: true,
                context: true
            }
        },
        ajaxSetup: function (target, settings) {
            return settings ? ajaxExtend(ajaxExtend(target, jQuery.ajaxSettings), settings) : ajaxExtend(jQuery.ajaxSettings, target);
        },
        ajaxPrefilter: addToPrefiltersOrTransports(prefilters),
        ajaxTransport: addToPrefiltersOrTransports(transports),
        ajax: function (url, options) {
            if (typeof url === 'object') {
                options = url;
                url = undefined;
            }
            options = options || {};
            var parts, i, cacheURL, responseHeadersString, timeoutTimer, fireGlobals, transport, responseHeaders, s = jQuery.ajaxSetup({}, options), callbackContext = s.context || s, globalEventContext = s.context && (callbackContext.nodeType || callbackContext.jquery) ? jQuery(callbackContext) : jQuery.event, deferred = jQuery.Deferred(), completeDeferred = jQuery.Callbacks('once memory'), statusCode = s.statusCode || {}, requestHeaders = {}, requestHeadersNames = {}, state = 0, strAbort = 'canceled', jqXHR = {
                    readyState: 0,
                    getResponseHeader: function (key) {
                        var match;
                        if (state === 2) {
                            if (!responseHeaders) {
                                responseHeaders = {};
                                while (match = rheaders.exec(responseHeadersString)) {
                                    responseHeaders[match[1].toLowerCase()] = match[2];
                                }
                            }
                            match = responseHeaders[key.toLowerCase()];
                        }
                        return match == null ? null : match;
                    },
                    getAllResponseHeaders: function () {
                        return state === 2 ? responseHeadersString : null;
                    },
                    setRequestHeader: function (name, value) {
                        var lname = name.toLowerCase();
                        if (!state) {
                            name = requestHeadersNames[lname] = requestHeadersNames[lname] || name;
                            requestHeaders[name] = value;
                        }
                        return this;
                    },
                    overrideMimeType: function (type) {
                        if (!state) {
                            s.mimeType = type;
                        }
                        return this;
                    },
                    statusCode: function (map) {
                        var code;
                        if (map) {
                            if (state < 2) {
                                for (code in map) {
                                    statusCode[code] = [
                                        statusCode[code],
                                        map[code]
                                    ];
                                }
                            } else {
                                jqXHR.always(map[jqXHR.status]);
                            }
                        }
                        return this;
                    },
                    abort: function (statusText) {
                        var finalText = statusText || strAbort;
                        if (transport) {
                            transport.abort(finalText);
                        }
                        done(0, finalText);
                        return this;
                    }
                };
            deferred.promise(jqXHR).complete = completeDeferred.add;
            jqXHR.success = jqXHR.done;
            jqXHR.error = jqXHR.fail;
            s.url = ((url || s.url || ajaxLocation) + '').replace(rhash, '').replace(rprotocol, ajaxLocParts[1] + '//');
            s.type = options.method || options.type || s.method || s.type;
            s.dataTypes = jQuery.trim(s.dataType || '*').toLowerCase().match(rnotwhite) || [''];
            if (s.crossDomain == null) {
                parts = rurl.exec(s.url.toLowerCase());
                s.crossDomain = !!(parts && (parts[1] !== ajaxLocParts[1] || parts[2] !== ajaxLocParts[2] || (parts[3] || (parts[1] === 'http:' ? '80' : '443')) !== (ajaxLocParts[3] || (ajaxLocParts[1] === 'http:' ? '80' : '443'))));
            }
            if (s.data && s.processData && typeof s.data !== 'string') {
                s.data = jQuery.param(s.data, s.traditional);
            }
            inspectPrefiltersOrTransports(prefilters, s, options, jqXHR);
            if (state === 2) {
                return jqXHR;
            }
            fireGlobals = s.global;
            if (fireGlobals && jQuery.active++ === 0) {
                jQuery.event.trigger('ajaxStart');
            }
            s.type = s.type.toUpperCase();
            s.hasContent = !rnoContent.test(s.type);
            cacheURL = s.url;
            if (!s.hasContent) {
                if (s.data) {
                    cacheURL = s.url += (rquery.test(cacheURL) ? '&' : '?') + s.data;
                    delete s.data;
                }
                if (s.cache === false) {
                    s.url = rts.test(cacheURL) ? cacheURL.replace(rts, '$1_=' + nonce++) : cacheURL + (rquery.test(cacheURL) ? '&' : '?') + '_=' + nonce++;
                }
            }
            if (s.ifModified) {
                if (jQuery.lastModified[cacheURL]) {
                    jqXHR.setRequestHeader('If-Modified-Since', jQuery.lastModified[cacheURL]);
                }
                if (jQuery.etag[cacheURL]) {
                    jqXHR.setRequestHeader('If-None-Match', jQuery.etag[cacheURL]);
                }
            }
            if (s.data && s.hasContent && s.contentType !== false || options.contentType) {
                jqXHR.setRequestHeader('Content-Type', s.contentType);
            }
            jqXHR.setRequestHeader('Accept', s.dataTypes[0] && s.accepts[s.dataTypes[0]] ? s.accepts[s.dataTypes[0]] + (s.dataTypes[0] !== '*' ? ', ' + allTypes + '; q=0.01' : '') : s.accepts['*']);
            for (i in s.headers) {
                jqXHR.setRequestHeader(i, s.headers[i]);
            }
            if (s.beforeSend && (s.beforeSend.call(callbackContext, jqXHR, s) === false || state === 2)) {
                return jqXHR.abort();
            }
            strAbort = 'abort';
            for (i in {
                    success: 1,
                    error: 1,
                    complete: 1
                }) {
                jqXHR[i](s[i]);
            }
            transport = inspectPrefiltersOrTransports(transports, s, options, jqXHR);
            if (!transport) {
                done(-1, 'No Transport');
            } else {
                jqXHR.readyState = 1;
                if (fireGlobals) {
                    globalEventContext.trigger('ajaxSend', [
                        jqXHR,
                        s
                    ]);
                }
                if (s.async && s.timeout > 0) {
                    timeoutTimer = setTimeout(function () {
                        jqXHR.abort('timeout');
                    }, s.timeout);
                }
                try {
                    state = 1;
                    transport.send(requestHeaders, done);
                } catch (e) {
                    if (state < 2) {
                        done(-1, e);
                    } else {
                        throw e;
                    }
                }
            }
            function done(status, nativeStatusText, responses, headers) {
                var isSuccess, success, error, response, modified, statusText = nativeStatusText;
                if (state === 2) {
                    return;
                }
                state = 2;
                if (timeoutTimer) {
                    clearTimeout(timeoutTimer);
                }
                transport = undefined;
                responseHeadersString = headers || '';
                jqXHR.readyState = status > 0 ? 4 : 0;
                isSuccess = status >= 200 && status < 300 || status === 304;
                if (responses) {
                    response = ajaxHandleResponses(s, jqXHR, responses);
                }
                response = ajaxConvert(s, response, jqXHR, isSuccess);
                if (isSuccess) {
                    if (s.ifModified) {
                        modified = jqXHR.getResponseHeader('Last-Modified');
                        if (modified) {
                            jQuery.lastModified[cacheURL] = modified;
                        }
                        modified = jqXHR.getResponseHeader('etag');
                        if (modified) {
                            jQuery.etag[cacheURL] = modified;
                        }
                    }
                    if (status === 204 || s.type === 'HEAD') {
                        statusText = 'nocontent';
                    } else if (status === 304) {
                        statusText = 'notmodified';
                    } else {
                        statusText = response.state;
                        success = response.data;
                        error = response.error;
                        isSuccess = !error;
                    }
                } else {
                    error = statusText;
                    if (status || !statusText) {
                        statusText = 'error';
                        if (status < 0) {
                            status = 0;
                        }
                    }
                }
                jqXHR.status = status;
                jqXHR.statusText = (nativeStatusText || statusText) + '';
                if (isSuccess) {
                    deferred.resolveWith(callbackContext, [
                        success,
                        statusText,
                        jqXHR
                    ]);
                } else {
                    deferred.rejectWith(callbackContext, [
                        jqXHR,
                        statusText,
                        error
                    ]);
                }
                jqXHR.statusCode(statusCode);
                statusCode = undefined;
                if (fireGlobals) {
                    globalEventContext.trigger(isSuccess ? 'ajaxSuccess' : 'ajaxError', [
                        jqXHR,
                        s,
                        isSuccess ? success : error
                    ]);
                }
                completeDeferred.fireWith(callbackContext, [
                    jqXHR,
                    statusText
                ]);
                if (fireGlobals) {
                    globalEventContext.trigger('ajaxComplete', [
                        jqXHR,
                        s
                    ]);
                    if (!--jQuery.active) {
                        jQuery.event.trigger('ajaxStop');
                    }
                }
            }
            return jqXHR;
        },
        getJSON: function (url, data, callback) {
            return jQuery.get(url, data, callback, 'json');
        },
        getScript: function (url, callback) {
            return jQuery.get(url, undefined, callback, 'script');
        }
    });
    jQuery.each([
        'get',
        'post'
    ], function (i, method) {
        jQuery[method] = function (url, data, callback, type) {
            if (jQuery.isFunction(data)) {
                type = type || callback;
                callback = data;
                data = undefined;
            }
            return jQuery.ajax({
                url: url,
                type: method,
                dataType: type,
                data: data,
                success: callback
            });
        };
    });
    jQuery.each([
        'ajaxStart',
        'ajaxStop',
        'ajaxComplete',
        'ajaxError',
        'ajaxSuccess',
        'ajaxSend'
    ], function (i, type) {
        jQuery.fn[type] = function (fn) {
            return this.on(type, fn);
        };
    });
    jQuery._evalUrl = function (url) {
        return jQuery.ajax({
            url: url,
            type: 'GET',
            dataType: 'script',
            async: false,
            global: false,
            'throws': true
        });
    };
    jQuery.fn.extend({
        wrapAll: function (html) {
            if (jQuery.isFunction(html)) {
                return this.each(function (i) {
                    jQuery(this).wrapAll(html.call(this, i));
                });
            }
            if (this[0]) {
                var wrap = jQuery(html, this[0].ownerDocument).eq(0).clone(true);
                if (this[0].parentNode) {
                    wrap.insertBefore(this[0]);
                }
                wrap.map(function () {
                    var elem = this;
                    while (elem.firstChild && elem.firstChild.nodeType === 1) {
                        elem = elem.firstChild;
                    }
                    return elem;
                }).append(this);
            }
            return this;
        },
        wrapInner: function (html) {
            if (jQuery.isFunction(html)) {
                return this.each(function (i) {
                    jQuery(this).wrapInner(html.call(this, i));
                });
            }
            return this.each(function () {
                var self = jQuery(this), contents = self.contents();
                if (contents.length) {
                    contents.wrapAll(html);
                } else {
                    self.append(html);
                }
            });
        },
        wrap: function (html) {
            var isFunction = jQuery.isFunction(html);
            return this.each(function (i) {
                jQuery(this).wrapAll(isFunction ? html.call(this, i) : html);
            });
        },
        unwrap: function () {
            return this.parent().each(function () {
                if (!jQuery.nodeName(this, 'body')) {
                    jQuery(this).replaceWith(this.childNodes);
                }
            }).end();
        }
    });
    jQuery.expr.filters.hidden = function (elem) {
        return elem.offsetWidth <= 0 && elem.offsetHeight <= 0 || !support.reliableHiddenOffsets() && (elem.style && elem.style.display || jQuery.css(elem, 'display')) === 'none';
    };
    jQuery.expr.filters.visible = function (elem) {
        return !jQuery.expr.filters.hidden(elem);
    };
    var r20 = /%20/g, rbracket = /\[\]$/, rCRLF = /\r?\n/g, rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i, rsubmittable = /^(?:input|select|textarea|keygen)/i;
    function buildParams(prefix, obj, traditional, add) {
        var name;
        if (jQuery.isArray(obj)) {
            jQuery.each(obj, function (i, v) {
                if (traditional || rbracket.test(prefix)) {
                    add(prefix, v);
                } else {
                    buildParams(prefix + '[' + (typeof v === 'object' ? i : '') + ']', v, traditional, add);
                }
            });
        } else if (!traditional && jQuery.type(obj) === 'object') {
            for (name in obj) {
                buildParams(prefix + '[' + name + ']', obj[name], traditional, add);
            }
        } else {
            add(prefix, obj);
        }
    }
    jQuery.param = function (a, traditional) {
        var prefix, s = [], add = function (key, value) {
                value = jQuery.isFunction(value) ? value() : value == null ? '' : value;
                s[s.length] = encodeURIComponent(key) + '=' + encodeURIComponent(value);
            };
        if (traditional === undefined) {
            traditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional;
        }
        if (jQuery.isArray(a) || a.jquery && !jQuery.isPlainObject(a)) {
            jQuery.each(a, function () {
                add(this.name, this.value);
            });
        } else {
            for (prefix in a) {
                buildParams(prefix, a[prefix], traditional, add);
            }
        }
        return s.join('&').replace(r20, '+');
    };
    jQuery.fn.extend({
        serialize: function () {
            return jQuery.param(this.serializeArray());
        },
        serializeArray: function () {
            return this.map(function () {
                var elements = jQuery.prop(this, 'elements');
                return elements ? jQuery.makeArray(elements) : this;
            }).filter(function () {
                var type = this.type;
                return this.name && !jQuery(this).is(':disabled') && rsubmittable.test(this.nodeName) && !rsubmitterTypes.test(type) && (this.checked || !rcheckableType.test(type));
            }).map(function (i, elem) {
                var val = jQuery(this).val();
                return val == null ? null : jQuery.isArray(val) ? jQuery.map(val, function (val) {
                    return {
                        name: elem.name,
                        value: val.replace(rCRLF, '\r\n')
                    };
                }) : {
                    name: elem.name,
                    value: val.replace(rCRLF, '\r\n')
                };
            }).get();
        }
    });
    jQuery.ajaxSettings.xhr = window.ActiveXObject !== undefined ? function () {
        return !this.isLocal && /^(get|post|head|put|delete|options)$/i.test(this.type) && createStandardXHR() || createActiveXHR();
    } : createStandardXHR;
    var xhrId = 0, xhrCallbacks = {}, xhrSupported = jQuery.ajaxSettings.xhr();
    if (window.ActiveXObject) {
        jQuery(window).on('unload', function () {
            for (var key in xhrCallbacks) {
                xhrCallbacks[key](undefined, true);
            }
        });
    }
    support.cors = !!xhrSupported && 'withCredentials' in xhrSupported;
    xhrSupported = support.ajax = !!xhrSupported;
    if (xhrSupported) {
        jQuery.ajaxTransport(function (options) {
            if (!options.crossDomain || support.cors) {
                var callback;
                return {
                    send: function (headers, complete) {
                        var i, xhr = options.xhr(), id = ++xhrId;
                        xhr.open(options.type, options.url, options.async, options.username, options.password);
                        if (options.xhrFields) {
                            for (i in options.xhrFields) {
                                xhr[i] = options.xhrFields[i];
                            }
                        }
                        if (options.mimeType && xhr.overrideMimeType) {
                            xhr.overrideMimeType(options.mimeType);
                        }
                        if (!options.crossDomain && !headers['X-Requested-With']) {
                            headers['X-Requested-With'] = 'XMLHttpRequest';
                        }
                        for (i in headers) {
                            if (headers[i] !== undefined) {
                                xhr.setRequestHeader(i, headers[i] + '');
                            }
                        }
                        xhr.send(options.hasContent && options.data || null);
                        callback = function (_, isAbort) {
                            var status, statusText, responses;
                            if (callback && (isAbort || xhr.readyState === 4)) {
                                delete xhrCallbacks[id];
                                callback = undefined;
                                xhr.onreadystatechange = jQuery.noop;
                                if (isAbort) {
                                    if (xhr.readyState !== 4) {
                                        xhr.abort();
                                    }
                                } else {
                                    responses = {};
                                    status = xhr.status;
                                    if (typeof xhr.responseText === 'string') {
                                        responses.text = xhr.responseText;
                                    }
                                    try {
                                        statusText = xhr.statusText;
                                    } catch (e) {
                                        statusText = '';
                                    }
                                    if (!status && options.isLocal && !options.crossDomain) {
                                        status = responses.text ? 200 : 404;
                                    } else if (status === 1223) {
                                        status = 204;
                                    }
                                }
                            }
                            if (responses) {
                                complete(status, statusText, responses, xhr.getAllResponseHeaders());
                            }
                        };
                        if (!options.async) {
                            callback();
                        } else if (xhr.readyState === 4) {
                            setTimeout(callback);
                        } else {
                            xhr.onreadystatechange = xhrCallbacks[id] = callback;
                        }
                    },
                    abort: function () {
                        if (callback) {
                            callback(undefined, true);
                        }
                    }
                };
            }
        });
    }
    function createStandardXHR() {
        try {
            return new window.XMLHttpRequest();
        } catch (e) {
        }
    }
    function createActiveXHR() {
        try {
            return new window.ActiveXObject('Microsoft.XMLHTTP');
        } catch (e) {
        }
    }
    jQuery.ajaxSetup({
        accepts: { script: 'text/javascript, application/javascript, application/ecmascript, application/x-ecmascript' },
        contents: { script: /(?:java|ecma)script/ },
        converters: {
            'text script': function (text) {
                jQuery.globalEval(text);
                return text;
            }
        }
    });
    jQuery.ajaxPrefilter('script', function (s) {
        if (s.cache === undefined) {
            s.cache = false;
        }
        if (s.crossDomain) {
            s.type = 'GET';
            s.global = false;
        }
    });
    jQuery.ajaxTransport('script', function (s) {
        if (s.crossDomain) {
            var script, head = document.head || jQuery('head')[0] || document.documentElement;
            return {
                send: function (_, callback) {
                    script = document.createElement('script');
                    script.async = true;
                    if (s.scriptCharset) {
                        script.charset = s.scriptCharset;
                    }
                    script.src = s.url;
                    script.onload = script.onreadystatechange = function (_, isAbort) {
                        if (isAbort || !script.readyState || /loaded|complete/.test(script.readyState)) {
                            script.onload = script.onreadystatechange = null;
                            if (script.parentNode) {
                                script.parentNode.removeChild(script);
                            }
                            script = null;
                            if (!isAbort) {
                                callback(200, 'success');
                            }
                        }
                    };
                    head.insertBefore(script, head.firstChild);
                },
                abort: function () {
                    if (script) {
                        script.onload(undefined, true);
                    }
                }
            };
        }
    });
    var oldCallbacks = [], rjsonp = /(=)\?(?=&|$)|\?\?/;
    jQuery.ajaxSetup({
        jsonp: 'callback',
        jsonpCallback: function () {
            var callback = oldCallbacks.pop() || jQuery.expando + '_' + nonce++;
            this[callback] = true;
            return callback;
        }
    });
    jQuery.ajaxPrefilter('json jsonp', function (s, originalSettings, jqXHR) {
        var callbackName, overwritten, responseContainer, jsonProp = s.jsonp !== false && (rjsonp.test(s.url) ? 'url' : typeof s.data === 'string' && !(s.contentType || '').indexOf('application/x-www-form-urlencoded') && rjsonp.test(s.data) && 'data');
        if (jsonProp || s.dataTypes[0] === 'jsonp') {
            callbackName = s.jsonpCallback = jQuery.isFunction(s.jsonpCallback) ? s.jsonpCallback() : s.jsonpCallback;
            if (jsonProp) {
                s[jsonProp] = s[jsonProp].replace(rjsonp, '$1' + callbackName);
            } else if (s.jsonp !== false) {
                s.url += (rquery.test(s.url) ? '&' : '?') + s.jsonp + '=' + callbackName;
            }
            s.converters['script json'] = function () {
                if (!responseContainer) {
                    jQuery.error(callbackName + ' was not called');
                }
                return responseContainer[0];
            };
            s.dataTypes[0] = 'json';
            overwritten = window[callbackName];
            window[callbackName] = function () {
                responseContainer = arguments;
            };
            jqXHR.always(function () {
                window[callbackName] = overwritten;
                if (s[callbackName]) {
                    s.jsonpCallback = originalSettings.jsonpCallback;
                    oldCallbacks.push(callbackName);
                }
                if (responseContainer && jQuery.isFunction(overwritten)) {
                    overwritten(responseContainer[0]);
                }
                responseContainer = overwritten = undefined;
            });
            return 'script';
        }
    });
    jQuery.parseHTML = function (data, context, keepScripts) {
        if (!data || typeof data !== 'string') {
            return null;
        }
        if (typeof context === 'boolean') {
            keepScripts = context;
            context = false;
        }
        context = context || document;
        var parsed = rsingleTag.exec(data), scripts = !keepScripts && [];
        if (parsed) {
            return [context.createElement(parsed[1])];
        }
        parsed = jQuery.buildFragment([data], context, scripts);
        if (scripts && scripts.length) {
            jQuery(scripts).remove();
        }
        return jQuery.merge([], parsed.childNodes);
    };
    var _load = jQuery.fn.load;
    jQuery.fn.load = function (url, params, callback) {
        if (typeof url !== 'string' && _load) {
            return _load.apply(this, arguments);
        }
        var selector, response, type, self = this, off = url.indexOf(' ');
        if (off >= 0) {
            selector = url.slice(off, url.length);
            url = url.slice(0, off);
        }
        if (jQuery.isFunction(params)) {
            callback = params;
            params = undefined;
        } else if (params && typeof params === 'object') {
            type = 'POST';
        }
        if (self.length > 0) {
            jQuery.ajax({
                url: url,
                type: type,
                dataType: 'html',
                data: params
            }).done(function (responseText) {
                response = arguments;
                self.html(selector ? jQuery('<div>').append(jQuery.parseHTML(responseText)).find(selector) : responseText);
            }).complete(callback && function (jqXHR, status) {
                self.each(callback, response || [
                    jqXHR.responseText,
                    status,
                    jqXHR
                ]);
            });
        }
        return this;
    };
    jQuery.expr.filters.animated = function (elem) {
        return jQuery.grep(jQuery.timers, function (fn) {
            return elem === fn.elem;
        }).length;
    };
    var docElem = window.document.documentElement;
    function getWindow(elem) {
        return jQuery.isWindow(elem) ? elem : elem.nodeType === 9 ? elem.defaultView || elem.parentWindow : false;
    }
    jQuery.offset = {
        setOffset: function (elem, options, i) {
            var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition, position = jQuery.css(elem, 'position'), curElem = jQuery(elem), props = {};
            if (position === 'static') {
                elem.style.position = 'relative';
            }
            curOffset = curElem.offset();
            curCSSTop = jQuery.css(elem, 'top');
            curCSSLeft = jQuery.css(elem, 'left');
            calculatePosition = (position === 'absolute' || position === 'fixed') && jQuery.inArray('auto', [
                curCSSTop,
                curCSSLeft
            ]) > -1;
            if (calculatePosition) {
                curPosition = curElem.position();
                curTop = curPosition.top;
                curLeft = curPosition.left;
            } else {
                curTop = parseFloat(curCSSTop) || 0;
                curLeft = parseFloat(curCSSLeft) || 0;
            }
            if (jQuery.isFunction(options)) {
                options = options.call(elem, i, curOffset);
            }
            if (options.top != null) {
                props.top = options.top - curOffset.top + curTop;
            }
            if (options.left != null) {
                props.left = options.left - curOffset.left + curLeft;
            }
            if ('using' in options) {
                options.using.call(elem, props);
            } else {
                curElem.css(props);
            }
        }
    };
    jQuery.fn.extend({
        offset: function (options) {
            if (arguments.length) {
                return options === undefined ? this : this.each(function (i) {
                    jQuery.offset.setOffset(this, options, i);
                });
            }
            var docElem, win, box = {
                    top: 0,
                    left: 0
                }, elem = this[0], doc = elem && elem.ownerDocument;
            if (!doc) {
                return;
            }
            docElem = doc.documentElement;
            if (!jQuery.contains(docElem, elem)) {
                return box;
            }
            if (typeof elem.getBoundingClientRect !== strundefined) {
                box = elem.getBoundingClientRect();
            }
            win = getWindow(doc);
            return {
                top: box.top + (win.pageYOffset || docElem.scrollTop) - (docElem.clientTop || 0),
                left: box.left + (win.pageXOffset || docElem.scrollLeft) - (docElem.clientLeft || 0)
            };
        },
        position: function () {
            if (!this[0]) {
                return;
            }
            var offsetParent, offset, parentOffset = {
                    top: 0,
                    left: 0
                }, elem = this[0];
            if (jQuery.css(elem, 'position') === 'fixed') {
                offset = elem.getBoundingClientRect();
            } else {
                offsetParent = this.offsetParent();
                offset = this.offset();
                if (!jQuery.nodeName(offsetParent[0], 'html')) {
                    parentOffset = offsetParent.offset();
                }
                parentOffset.top += jQuery.css(offsetParent[0], 'borderTopWidth', true);
                parentOffset.left += jQuery.css(offsetParent[0], 'borderLeftWidth', true);
            }
            return {
                top: offset.top - parentOffset.top - jQuery.css(elem, 'marginTop', true),
                left: offset.left - parentOffset.left - jQuery.css(elem, 'marginLeft', true)
            };
        },
        offsetParent: function () {
            return this.map(function () {
                var offsetParent = this.offsetParent || docElem;
                while (offsetParent && (!jQuery.nodeName(offsetParent, 'html') && jQuery.css(offsetParent, 'position') === 'static')) {
                    offsetParent = offsetParent.offsetParent;
                }
                return offsetParent || docElem;
            });
        }
    });
    jQuery.each({
        scrollLeft: 'pageXOffset',
        scrollTop: 'pageYOffset'
    }, function (method, prop) {
        var top = /Y/.test(prop);
        jQuery.fn[method] = function (val) {
            return access(this, function (elem, method, val) {
                var win = getWindow(elem);
                if (val === undefined) {
                    return win ? prop in win ? win[prop] : win.document.documentElement[method] : elem[method];
                }
                if (win) {
                    win.scrollTo(!top ? val : jQuery(win).scrollLeft(), top ? val : jQuery(win).scrollTop());
                } else {
                    elem[method] = val;
                }
            }, method, val, arguments.length, null);
        };
    });
    jQuery.each([
        'top',
        'left'
    ], function (i, prop) {
        jQuery.cssHooks[prop] = addGetHookIf(support.pixelPosition, function (elem, computed) {
            if (computed) {
                computed = curCSS(elem, prop);
                return rnumnonpx.test(computed) ? jQuery(elem).position()[prop] + 'px' : computed;
            }
        });
    });
    jQuery.each({
        Height: 'height',
        Width: 'width'
    }, function (name, type) {
        jQuery.each({
            padding: 'inner' + name,
            content: type,
            '': 'outer' + name
        }, function (defaultExtra, funcName) {
            jQuery.fn[funcName] = function (margin, value) {
                var chainable = arguments.length && (defaultExtra || typeof margin !== 'boolean'), extra = defaultExtra || (margin === true || value === true ? 'margin' : 'border');
                return access(this, function (elem, type, value) {
                    var doc;
                    if (jQuery.isWindow(elem)) {
                        return elem.document.documentElement['client' + name];
                    }
                    if (elem.nodeType === 9) {
                        doc = elem.documentElement;
                        return Math.max(elem.body['scroll' + name], doc['scroll' + name], elem.body['offset' + name], doc['offset' + name], doc['client' + name]);
                    }
                    return value === undefined ? jQuery.css(elem, type, extra) : jQuery.style(elem, type, value, extra);
                }, type, chainable ? margin : undefined, chainable, null);
            };
        });
    });
    jQuery.fn.size = function () {
        return this.length;
    };
    jQuery.fn.andSelf = jQuery.fn.addBack;
    if (typeof define === 'function' && define.amd) {
        define('jquery@1.11.0#dist/jquery', [], function () {
            return jQuery;
        });
    }
    var _jQuery = window.jQuery, _$ = window.$;
    jQuery.noConflict = function (deep) {
        if (window.$ === jQuery) {
            window.$ = _$;
        }
        if (deep && window.jQuery === jQuery) {
            window.jQuery = _jQuery;
        }
        return jQuery;
    };
    if (typeof noGlobal === strundefined) {
        window.jQuery = window.$ = jQuery;
    }
    return jQuery;
}));
/*funcunit@3.5.0#browser/jquery*/
define('funcunit@3.5.0#browser/jquery', [
    'require',
    'exports',
    'module',
    'jquery'
], function (require, exports, module) {
    var $ = require('jquery');
    module.exports = $.noConflict(true);
});
/*funcunit@3.5.0#browser/init*/
define('funcunit@3.5.0#browser/init', [
    'require',
    'exports',
    'module',
    'funcunit/browser/jquery'
], function (require, exports, module) {
    var jQuery = require('funcunit/browser/jquery');
    var FuncUnit = window.FuncUnit || {};
    jQuery.sub = function () {
        function jQuerySub(selector, context) {
            return new jQuerySub.fn.init(selector, context);
        }
        jQuery.extend(true, jQuerySub, this);
        jQuerySub.superclass = this;
        jQuerySub.fn = jQuerySub.prototype = this();
        jQuerySub.fn.constructor = jQuerySub;
        jQuerySub.sub = this.sub;
        jQuerySub.fn.init = function init(selector, context) {
            if (context && context instanceof jQuery && !(context instanceof jQuerySub)) {
                context = jQuerySub(context);
            }
            return jQuery.fn.init.call(this, selector, context, rootjQuerySub);
        };
        jQuerySub.fn.init.prototype = jQuerySub.fn;
        var rootjQuerySub = jQuerySub(document);
        return jQuerySub;
    };
    FuncUnit.jQuery = jQuery;
    module.exports = FuncUnit;
});
/*funcunit@3.5.0#browser/core*/
define('funcunit@3.5.0#browser/core', [
    'require',
    'exports',
    'module',
    'funcunit/browser/jquery',
    'funcunit/browser/init'
], function (require, exports, module) {
    var jQuery = require('funcunit/browser/jquery');
    var oldFuncUnit = require('funcunit/browser/init');
    var FuncUnit = oldFuncUnit.jQuery.sub();
    var origFuncUnit = FuncUnit;
    FuncUnit = function (selector, frame) {
        var frame, forceSync, isSyncOnly = false;
        if (frame && frame.forceSync) {
            forceSync = frame.forceSync;
        }
        if (frame && typeof frame.frame !== 'undefined') {
            frame = frame.frame;
        }
        isSyncOnly = typeof forceSync === 'boolean' ? forceSync : isSyncOnly;
        if (typeof selector == 'function') {
            return FuncUnit.wait(0, selector);
        }
        this.selector = selector;
        if (isSyncOnly === true) {
            var collection = performSyncQuery(selector, frame);
            return collection;
        } else {
            performAsyncQuery(selector, frame, this);
            var collection = performSyncQuery(selector, frame);
            return collection;
        }
    };
    var getContext = function (context) {
            if (typeof context === 'number' || typeof context === 'string') {
                var sel = typeof context === 'number' ? 'iframe:eq(' + context + ')' : 'iframe[name=\'' + context + '\']', frames = new origFuncUnit.fn.init(sel, FuncUnit.win.document.documentElement, true);
                var frame = (frames.length ? frames.get(0).contentWindow : FuncUnit.win).document.documentElement;
            } else {
                frame = FuncUnit.win.document.documentElement;
            }
            return frame;
        }, performAsyncQuery = function (selector, frame, self) {
            FuncUnit.add({
                method: function (success, error) {
                    this.frame = frame;
                    if (FuncUnit.win) {
                        frame = getContext(frame);
                    }
                    this.selector = selector;
                    this.bind = new origFuncUnit.fn.init(selector, frame, true);
                    success();
                    return this;
                },
                error: 'selector failed: ' + selector,
                type: 'query'
            });
        }, performSyncQuery = function (selector, frame) {
            var origFrame = frame;
            if (FuncUnit.win) {
                frame = getContext(frame);
            }
            var obj = new origFuncUnit.fn.init(selector, frame, true);
            obj.frame = origFrame;
            return obj;
        };
    oldFuncUnit.jQuery.extend(FuncUnit, oldFuncUnit, origFuncUnit);
    FuncUnit.prototype = origFuncUnit.prototype;
    module.exports = FuncUnit;
});
/*funcunit@3.5.0#browser/adapters/jasmine*/
define('funcunit@3.5.0#browser/adapters/jasmine', function (require, exports, module) {
    module.exports = function (jasmine) {
        var paused = false;
        return {
            pauseTest: function () {
                paused = true;
                waitsFor(function () {
                    return paused === false;
                }, 60000);
            },
            resumeTest: function () {
                paused = false;
            },
            assertOK: function (assertion, message) {
                expect(assertion).toBeTruthy();
            },
            equiv: function (expected, actual) {
                return jasmine.getEnv().equals_(expected, actual);
            }
        };
    };
});
/*funcunit@3.5.0#browser/adapters/jasmine2*/
define('funcunit@3.5.0#browser/adapters/jasmine2', [
    'require',
    'exports',
    'module',
    'funcunit/browser/core'
], function (require, exports, module) {
    var FuncUnit = require('funcunit/browser/core');
    module.exports = function (jasmine) {
        FuncUnit.timeout = 4900;
        return {
            pauseTest: function () {
            },
            resumeTest: function () {
            },
            assertOK: function (assertion, message) {
                expect(assertion).toBeTruthy();
            },
            equiv: function (expected, actual) {
                return expected == actual;
            }
        };
    };
});
/*funcunit@3.5.0#browser/adapters/qunit*/
define('funcunit@3.5.0#browser/adapters/qunit', function (require, exports, module) {
    module.exports = function (QUnit) {
        return {
            pauseTest: function () {
                QUnit.stop();
            },
            resumeTest: function () {
                QUnit.start();
            },
            assertOK: function (assertion, message) {
                QUnit.ok(assertion, message);
            },
            equiv: function (expected, actual) {
                return QUnit.equiv(expected, actual);
            }
        };
    };
});
/*funcunit@3.5.0#browser/adapters/qunit2*/
define('funcunit@3.5.0#browser/adapters/qunit2', [
    'require',
    'exports',
    'module',
    'funcunit/browser/core'
], function (require, exports, module) {
    var FuncUnit = require('funcunit/browser/core');
    module.exports = function (QUnit) {
        var done;
        var currentTestAssert;
        var originalTest = QUnit.test;
        QUnit.test = function funcunitTest(title, test) {
            return originalTest(title, function (assert) {
                currentTestAssert = assert;
                return test.apply(this, arugments);
            });
        };
        return {
            pauseTest: function () {
                done = currentTestAssert.async();
            },
            resumeTest: function () {
                done();
            },
            assertOK: function (assertion, message) {
                currentTestAssert.ok(assertion, message);
            },
            equiv: function (expected, actual) {
                return QUnit.equiv(expected, actual);
            }
        };
    };
});
/*funcunit@3.5.0#browser/adapters/mocha*/
define('funcunit@3.5.0#browser/adapters/mocha', [
    'require',
    'exports',
    'module',
    'funcunit/browser/core'
], function (require, exports, module) {
    var FuncUnit = require('funcunit/browser/core');
    var ok = function (expr, msg) {
        if (!expr)
            throw new Error(msg);
    };
    module.exports = function (mocha) {
        FuncUnit.timeout = 1900;
        return {
            pauseTest: function () {
            },
            resumeTest: function () {
            },
            assertOK: function (assertion, message) {
                ok(assertion, message);
            },
            equiv: function (expected, actual) {
                return expected == actual;
            }
        };
    };
});
/*funcunit@3.5.0#browser/adapters/adapters*/
define('funcunit@3.5.0#browser/adapters/adapters', [
    'require',
    'exports',
    'module',
    'funcunit/browser/adapters/jasmine',
    'funcunit/browser/adapters/jasmine2',
    'funcunit/browser/adapters/qunit',
    'funcunit/browser/adapters/qunit2',
    'funcunit/browser/adapters/mocha',
    'funcunit/browser/core'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        var jasmineAdapter = require('funcunit/browser/adapters/jasmine');
        var jasmine2Adapter = require('funcunit/browser/adapters/jasmine2');
        var qunitAdapter = require('funcunit/browser/adapters/qunit');
        var qunit2Adapter = require('funcunit/browser/adapters/qunit2');
        var mochaAdapter = require('funcunit/browser/adapters/mocha');
        var FuncUnit = require('funcunit/browser/core');
        var noop = function () {
        };
        var defaultAdapter = {
            pauseTest: noop,
            resumeTest: noop,
            assertOK: noop,
            equiv: function (expected, actual) {
                return expected == actual;
            }
        };
        FuncUnit.unit = defaultAdapter;
        FuncUnit.attach = function (runner) {
            var unit;
            if (isQUnit(runner)) {
                unit = qunitAdapter(runner);
            } else if (isQUnit2(runner)) {
                unit = qunit2Adapter(runner);
            } else if (isMocha(runner)) {
                unit = mochaAdapter(runner);
            } else if (isJasmine(runner)) {
                unit = jasmineAdapter(runner);
            } else if (isJasmine2(runner)) {
                unit = jasmine2Adapter(runner);
            } else {
                unit = defaultAdapter;
            }
            FuncUnit.unit = unit;
        };
        function isQUnit(runner) {
            return !!(runner.ok && runner.start && runner.stop);
        }
        function isQUnit2(runner) {
            return !!(runner.assert && runner.assert.ok && runner.assert.async);
        }
        function isMocha(runner) {
            return !!(runner.setup && runner.globals && runner.reporter);
        }
        function isJasmine(runner) {
            return !!(runner.getEnv && typeof window.waitsFor === 'function');
        }
        function isJasmine2(runner) {
            return !!(runner.getEnv && typeof runner.clock === 'function' && !window.waitsFor);
        }
        FuncUnit.detach = function () {
            FuncUnit.unit = defaultAdapter;
        };
    }(function () {
        return this;
    }(), require, exports, module));
});
/*funcunit@3.5.0#browser/open*/
define('funcunit@3.5.0#browser/open', [
    'require',
    'exports',
    'module',
    'funcunit/browser/jquery',
    'funcunit/browser/core',
    'syn'
], function (require, exports, module) {
    var $ = require('funcunit/browser/jquery');
    var FuncUnit = require('funcunit/browser/core');
    var syn = require('syn');
    if (FuncUnit.frameMode) {
        var ifrm = document.createElement('iframe');
        ifrm.id = 'funcunit_app';
        document.body.insertBefore(ifrm, document.body.firstChild);
    }
    var confirms = [], prompts = [], currentDocument, currentHref, appWin, lookingForNewDocument = false, urlWithoutHash = function (url) {
            return url.replace(/\#.*$/, '');
        }, isCurrentPage = function (url) {
            var pathname = urlWithoutHash(FuncUnit.win.location.pathname), href = urlWithoutHash(FuncUnit.win.location.href), url = urlWithoutHash(url);
            if (pathname === url || href === url) {
                return true;
            }
            return false;
        };
    $.extend(FuncUnit, {
        open: function (path, success, timeout) {
            if (typeof success != 'function') {
                timeout = success;
                success = undefined;
            }
            FuncUnit.add({
                method: function (success, error) {
                    if (typeof path === 'string') {
                        var fullPath = FuncUnit.getAbsolutePath(path);
                        FuncUnit._open(fullPath, error);
                        FuncUnit._onload(function () {
                            success();
                        }, error);
                    } else {
                        FuncUnit.win = path;
                        success();
                    }
                },
                success: success,
                error: 'Page ' + path + ' not loaded in time!',
                timeout: timeout || 30000
            });
        },
        _open: function (url) {
            FuncUnit.win = appWin;
            hasSteal = false;
            FuncUnit.frame = $('#funcunit_app').length ? $('#funcunit_app')[0] : null;
            if (newPage) {
                if (FuncUnit.frame) {
                    FuncUnit.win = FuncUnit.frame.contentWindow;
                    FuncUnit.win.location = url;
                } else {
                    var width = $(window).width();
                    FuncUnit.win = window.open(url, 'funcunit', 'height=1000,toolbar=yes,status=yes,width=' + width / 2 + ',left=' + width / 2);
                    if (FuncUnit.win && FuncUnit.win.___FUNCUNIT_OPENED) {
                        FuncUnit.win.close();
                        FuncUnit.win = window.open(url, 'funcunit', 'height=1000,toolbar=yes,status=yes,left=' + width / 2);
                    }
                    if (!FuncUnit.win) {
                        throw 'Could not open a popup window.  Your popup blocker is probably on.  Please turn it off and try again';
                    }
                }
                appWin = FuncUnit.win;
            } else {
                lookingForNewDocument = true;
                if (isCurrentPage(url)) {
                    FuncUnit.win.document.body.parentNode.removeChild(FuncUnit.win.document.body);
                    FuncUnit.win.location.hash = url.split('#')[1] || '';
                    FuncUnit.win.location.reload(true);
                } else {
                    FuncUnit.win.location = url;
                }
                currentDocument = null;
            }
            lookingForNewDocument = true;
        },
        confirm: function (answer) {
            confirms.push(!!answer);
        },
        prompt: function (answer) {
            prompts.push(answer);
        },
        _opened: function () {
            if (!this._isOverridden('alert')) {
                FuncUnit.win.alert = function () {
                };
            }
            if (!this._isOverridden('confirm')) {
                FuncUnit.win.confirm = function () {
                    var res = confirms.shift();
                    return res;
                };
            }
            if (!this._isOverridden('prompt')) {
                FuncUnit.win.prompt = function () {
                    return prompts.shift();
                };
            }
        },
        _isOverridden: function (type) {
            return !/(native code)|(source code not available)/.test(FuncUnit.win[type]);
        },
        _onload: function (success, error) {
            loadSuccess = function () {
                if (FuncUnit.win.steal) {
                    hasSteal = true;
                }
                if (!hasSteal) {
                    return success();
                }
                FuncUnit.win.steal.done().then(success);
            };
            if (!newPage) {
                return;
            }
            newPage = false;
            if (FuncUnit.support.readystate) {
                poller();
            } else {
                unloadLoader();
            }
        },
        getAbsolutePath: function (path) {
            if (/^\/\//.test(path)) {
                path = path.substr(2);
            }
            return path;
        },
        win: window,
        support: { readystate: 'readyState' in document },
        eval: function (str) {
            return FuncUnit.win.eval(str);
        },
        documentLoaded: function () {
            var loaded = FuncUnit.win.document.readyState === 'complete' && FuncUnit.win.location.href != 'about:blank' && FuncUnit.win.document.body;
            return loaded;
        },
        checkForNewDocument: function () {
            var documentFound = false;
            try {
                documentFound = (FuncUnit.win.document !== currentDocument && !FuncUnit.win.___FUNCUNIT_OPENED || currentHref != FuncUnit.win.location.href) && FuncUnit.documentLoaded();
            } catch (e) {
            }
            if (documentFound) {
                lookingForNewDocument = false;
                currentDocument = FuncUnit.win.document;
                currentHref = FuncUnit.win.location.href;
                FuncUnit.win.___FUNCUNIT_OPENED = true;
                FuncUnit._opened();
            }
            return documentFound;
        }
    });
    var newPage = true, hasSteal = false, unloadLoader, loadSuccess, firstLoad = true, onload = function () {
            FuncUnit.win.document.documentElement.tabIndex = 0;
            setTimeout(function () {
                FuncUnit.win.focus();
                var ls = loadSuccess;
                loadSuccess = null;
                if (ls) {
                    ls();
                }
            }, 0);
            syn.unbind(FuncUnit.win, 'load', onload);
        }, onunload = function () {
            FuncUnit.stop = true;
            removeListeners();
            setTimeout(unloadLoader, 0);
        }, removeListeners = function () {
            syn.unbind(FuncUnit.win, 'unload', onunload);
            Syn.unbind(FuncUnit.win, 'load', onload);
        };
    unloadLoader = function () {
        if (!firstLoad)
            removeListeners();
        syn.bind(FuncUnit.win, 'load', onload);
        syn.bind(FuncUnit.win, 'unload', onunload);
    };
    var newDocument = false, poller = function () {
            var ls;
            if (lookingForNewDocument && FuncUnit.checkForNewDocument()) {
                ls = loadSuccess;
                loadSuccess = null;
                if (ls) {
                    FuncUnit.win.focus();
                    FuncUnit.win.document.documentElement.tabIndex = 0;
                    ls();
                }
            }
            setTimeout(arguments.callee, 500);
        };
    $(window).unload(function () {
        if (FuncUnit.win && FuncUnit.win !== window.top) {
            FuncUnit.win.close();
        }
    });
    module.exports = FuncUnit;
});
/*funcunit@3.5.0#browser/actions*/
define('funcunit@3.5.0#browser/actions', [
    'require',
    'exports',
    'module',
    'funcunit/browser/jquery',
    'funcunit/browser/core',
    'syn'
], function (require, exports, module) {
    var $ = require('funcunit/browser/jquery');
    var FuncUnit = require('funcunit/browser/core');
    var syn = window.syn = require('syn');
    var clicks = [
            'click',
            'dblclick',
            'rightClick'
        ], makeClick = function (name) {
            FuncUnit.prototype[name] = function (options, success) {
                this._addExists();
                if (typeof options == 'function') {
                    success = options;
                    options = {};
                }
                var selector = this.selector;
                FuncUnit.add({
                    method: function (success, error) {
                        options = options || {};
                        syn('_' + name, this.bind[0], options, success);
                    },
                    success: success,
                    error: 'Could not ' + name + ' \'' + this.selector + '\'',
                    bind: this,
                    type: 'action'
                });
                return this;
            };
        };
    for (var i = 0; i < clicks.length; i++) {
        makeClick(clicks[i]);
    }
    $.extend(FuncUnit.prototype, {
        _addExists: function () {
            this.exists(false);
        },
        type: function (text, success) {
            this._addExists();
            this.click();
            var selector = this.selector;
            if (text === '') {
                text = '[ctrl]a[ctrl-up]\b';
            }
            FuncUnit.add({
                method: function (success, error) {
                    syn('_type', this.bind[0], text, success);
                },
                success: success,
                error: 'Could not type ' + text + ' into ' + this.selector,
                bind: this,
                type: 'action'
            });
            return this;
        },
        sendKeys: function (keys, success) {
            this._addExists();
            var selector = this.selector;
            if (keys === '') {
                keys = '[ctrl]a[ctrl-up]\b';
            }
            FuncUnit.add({
                method: function (success, error) {
                    syn('_type', this.bind[0], keys, success);
                },
                success: success,
                error: 'Could not send the keys ' + keys + ' into ' + this.selector,
                bind: this,
                type: 'action'
            });
            return this;
        },
        trigger: function (evName, success) {
            this._addExists();
            FuncUnit.add({
                method: function (success, error) {
                    if (!FuncUnit.win.jQuery) {
                        throw 'Can not trigger custom event, no jQuery found on target page.';
                    }
                    FuncUnit.win.jQuery(this.bind.selector).trigger(evName);
                    success();
                },
                success: success,
                error: 'Could not trigger ' + evName,
                bind: this,
                type: 'action'
            });
            return this;
        },
        drag: function (options, success) {
            this._addExists();
            if (typeof options == 'string') {
                options = { to: options };
            }
            options.from = this.selector;
            var selector = this.selector;
            FuncUnit.add({
                method: function (success, error) {
                    syn('_drag', this.bind[0], options, success);
                },
                success: success,
                error: 'Could not drag ' + this.selector,
                bind: this,
                type: 'action'
            });
            return this;
        },
        move: function (options, success) {
            this._addExists();
            if (typeof options == 'string') {
                options = { to: options };
            }
            options.from = this.selector;
            var selector = this.selector;
            FuncUnit.add({
                method: function (success, error) {
                    syn('_move', this.bind[0], options, success);
                },
                success: success,
                error: 'Could not move ' + this.selector,
                bind: this,
                type: 'action'
            });
            return this;
        },
        scroll: function (direction, amount, success) {
            this._addExists();
            var selector = this.selector, direction;
            if (direction == 'left' || direction == 'right') {
                direction = 'Left';
            } else if (direction == 'top' || direction == 'bottom') {
                direction = 'Top';
            }
            FuncUnit.add({
                method: function (success, error) {
                    this.bind.each(function (i, el) {
                        this['scroll' + direction] = amount;
                    });
                    success();
                },
                success: success,
                error: 'Could not scroll ' + this.selector,
                bind: this,
                type: 'action'
            });
            return this;
        }
    });
    module.exports = FuncUnit;
});
/*funcunit@3.5.0#browser/getters*/
define('funcunit@3.5.0#browser/getters', [
    'require',
    'exports',
    'module',
    'funcunit/browser/jquery',
    'funcunit/browser/core'
], function (require, exports, module) {
    var $ = require('funcunit/browser/jquery');
    var FuncUnit = require('funcunit/browser/core');
    FuncUnit.funcs = {
        'size': 0,
        'attr': 1,
        'hasClass': 1,
        'html': 0,
        'text': 0,
        'val': 0,
        'css': 1,
        'prop': 1,
        'offset': 0,
        'position': 0,
        'scrollTop': 0,
        'scrollLeft': 0,
        'height': 0,
        'width': 0,
        'innerHeight': 0,
        'innerWidth': 0,
        'outerHeight': 0,
        'outerWidth': 0
    };
    FuncUnit.makeFunc = function (fname, argIndex) {
        var orig = FuncUnit.fn[fname];
        FuncUnit.prototype[fname] = function () {
            var args = FuncUnit.makeArray(arguments), isWait = args.length > argIndex, success, self = this;
            args.unshift(this.selector, this.frame, fname);
            if (isWait) {
                var tester = args[argIndex + 3], timeout = args[argIndex + 4], success = args[argIndex + 5], message = args[argIndex + 6], testVal = tester, errorMessage = 'waiting for ' + fname + ' on ' + this.selector, frame = this.frame, logMessage = 'Checking ' + fname + ' on \'' + this.selector + '\'', ret;
                if (typeof tester == 'object' && !(tester instanceof RegExp)) {
                    timeout = tester.timeout;
                    success = tester.success;
                    message = tester.message;
                    if (tester.errorMessage) {
                        errorMessage = tester.errorMessage;
                    }
                    if (typeof tester.logMessage !== 'undefined') {
                        logMessage = tester.logMessage;
                    }
                    tester = tester.condition;
                }
                if (typeof timeout == 'function') {
                    message = success;
                    success = timeout;
                    timeout = undefined;
                }
                if (typeof timeout == 'string') {
                    message = timeout;
                    timeout = undefined;
                    success = undefined;
                }
                if (typeof message !== 'string') {
                    message = undefined;
                }
                args.splice(argIndex + 3, args.length - argIndex - 3);
                if (typeof tester != 'function') {
                    errorMessage += ' !== ' + testVal;
                    tester = function (val) {
                        return FuncUnit.unit.equiv(val, testVal) || testVal instanceof RegExp && testVal.test(val);
                    };
                }
                if (message) {
                    errorMessage = message;
                }
                FuncUnit.repeat({
                    method: function (print) {
                        if (this.bind.prevObject && this.bind.prevTraverser) {
                            var prev = this.bind;
                            this.bind = this.bind.prevObject[this.bind.prevTraverser](this.bind.prevTraverserSelector);
                            this.bind.prevTraverser = prev.prevTraverser;
                            this.bind.prevTraverserSelector = prev.prevTraverserSelector;
                        } else {
                            this.bind = F(this.selector, {
                                frame: frame,
                                forceSync: true
                            });
                        }
                        if (logMessage) {
                            print(logMessage);
                        }
                        var methodArgs = [];
                        if (argIndex > 0) {
                            methodArgs.push(args[3]);
                        }
                        FuncUnit._ignoreGetterError = true;
                        ret = this.bind[fname].apply(this.bind, methodArgs);
                        FuncUnit._ignoreGetterError = false;
                        var passed = tester.call(this.bind, ret);
                        if (this.bind.length === 0 && fname !== 'size') {
                            passed = false;
                        }
                        if (passed) {
                            if (!FuncUnit.documentLoaded()) {
                                passed = false;
                            } else {
                                FuncUnit.checkForNewDocument();
                            }
                        }
                        return passed;
                    },
                    success: function () {
                        if (message) {
                            FuncUnit.unit.assertOK(true, message);
                        }
                        success && success.apply(this, arguments);
                    },
                    error: function () {
                        var msg = errorMessage;
                        if (ret) {
                            msg += ', actual value: ' + ret;
                        }
                        FuncUnit.unit.assertOK(false, msg);
                    },
                    timeout: timeout,
                    bind: this,
                    type: 'wait'
                });
                return this;
            } else {
                if (!FuncUnit._ignoreGetterError && !FuncUnit._incallback && FuncUnit._haveAsyncQueries()) {
                    console && console.error('You can\'t run getters after actions and waits. Please put your getters in a callback or at the beginning of the test.');
                }
                var methodArgs = [];
                if (argIndex > 0) {
                    methodArgs.push(args[3]);
                }
                return orig.apply(this, methodArgs);
            }
        };
    };
    for (var prop in FuncUnit.funcs) {
        FuncUnit.makeFunc(prop, FuncUnit.funcs[prop]);
    }
    module.exports = FuncUnit;
});
/*funcunit@3.5.0#browser/traversers*/
define('funcunit@3.5.0#browser/traversers', [
    'require',
    'exports',
    'module',
    'funcunit/browser/jquery',
    'funcunit/browser/core'
], function (require, exports, module) {
    var $ = require('funcunit/browser/jquery');
    var FuncUnit = require('funcunit/browser/core');
    var traversers = [
            'closest',
            'next',
            'prev',
            'siblings',
            'last',
            'first',
            'find'
        ], makeTraverser = function (name) {
            var orig = FuncUnit.prototype[name];
            FuncUnit.prototype[name] = function (selector) {
                var args = arguments;
                if (FuncUnit.win && this[0] && this[0].parentNode && this[0].parentNode.nodeType !== 9) {
                    FuncUnit.add({
                        method: function (success, error) {
                            var newBind = orig.apply(this.bind, args);
                            newBind.prevTraverser = name;
                            newBind.prevTraverserSelector = selector;
                            success(newBind);
                        },
                        error: 'Could not traverse: ' + name + ' ' + selector,
                        bind: this
                    });
                }
                return orig.apply(this, arguments);
            };
        };
    for (var i = 0; i < traversers.length; i++) {
        makeTraverser(traversers[i]);
    }
    module.exports = FuncUnit;
});
/*funcunit@3.5.0#browser/queue*/
define('funcunit@3.5.0#browser/queue', [
    'require',
    'exports',
    'module',
    'funcunit/browser/core'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        var FuncUnit = require('funcunit/browser/core');
        FuncUnit._incallback = false;
        var currentPosition = 0, startedQueue = false;
        FuncUnit.speed = 0;
        FuncUnit.timeout = 10000;
        FuncUnit._queue = [];
        FuncUnit._needSyncQuery = function () {
            if (FuncUnit._queue.length === 1) {
                if (FuncUnit._queue[0].type === 'query') {
                    FuncUnit._queue = [];
                    return true;
                }
            }
            if (FuncUnit._queue.length === 0) {
                return true;
            }
            return false;
        };
        FuncUnit._lastQueuedItem = function () {
            if (!FuncUnit._queue.length) {
                return null;
            }
            return FuncUnit._queue[FuncUnit._queue.length - 1];
        };
        FuncUnit._haveAsyncQueries = function () {
            for (var i = 0; i < FuncUnit._queue.length; i++) {
                if (FuncUnit._queue[i].type === 'action' || FuncUnit._queue[i].type === 'wait')
                    return true;
            }
            return false;
        };
        FuncUnit.add = function (handler, error, context) {
            if (handler instanceof Function) {
                if (typeof error === 'object') {
                    context = error;
                    delete error;
                }
                error = error && error.toString() || 'Custom method has failed.';
                var cb = handler;
                handler = {
                    method: function (success, error) {
                        success();
                    },
                    success: cb,
                    error: error,
                    bind: context
                };
            }
            if (FuncUnit._incallback) {
                FuncUnit._queue.splice(currentPosition, 0, handler);
                currentPosition++;
            } else {
                FuncUnit._queue.push(handler);
            }
            if (FuncUnit._queue.length == 1 && !FuncUnit._incallback) {
                FuncUnit.unit.pauseTest();
                setTimeout(FuncUnit._done, 13);
            }
        };
        var currentEl;
        FuncUnit._done = function (el, selector) {
            var next, timer, speed = FuncUnit.speed || 0;
            if (FuncUnit.speed === 'slow') {
                speed = 500;
            }
            if (FuncUnit._queue.length > 0) {
                next = FuncUnit._queue.shift();
                currentPosition = 0;
                setTimeout(function () {
                    timer = setTimeout(function () {
                        next.stop && next.stop();
                        if (typeof next.error === 'function') {
                            next.error();
                        } else {
                            FuncUnit.unit.assertOK(false, next.error);
                        }
                        FuncUnit._done();
                    }, (next.timeout || FuncUnit.timeout) + speed);
                    if (el && el.jquery) {
                        currentEl = el;
                    }
                    if (currentEl) {
                        next.bind = currentEl;
                    }
                    next.selector = selector;
                    next.method(function (el) {
                        if (el && el.jquery) {
                            next.bind = el;
                        }
                        clearTimeout(timer);
                        FuncUnit._incallback = true;
                        if (next.success) {
                            next.success.apply(next.bind, arguments);
                        }
                        FuncUnit._incallback = false;
                        FuncUnit._done(next.bind, next.selector);
                    }, function (message) {
                        clearTimeout(timer);
                        FuncUnit.unit.assertOK(false, message);
                        FuncUnit._done();
                    });
                }, speed);
            } else {
                FuncUnit.unit.resumeTest();
            }
        };
        module.exports = FuncUnit;
    }(function () {
        return this;
    }(), require, exports, module));
});
/*funcunit@3.5.0#browser/waits*/
define('funcunit@3.5.0#browser/waits', [
    'require',
    'exports',
    'module',
    'funcunit/browser/jquery',
    'funcunit/browser/core'
], function (require, exports, module) {
    var $ = require('funcunit/browser/jquery');
    var FuncUnit = require('funcunit/browser/core');
    FuncUnit.wait = function (time, success) {
        if (typeof time == 'function') {
            success = time;
            time = undefined;
        }
        time = time != null ? time : 5000;
        FuncUnit.add({
            method: function (success, error) {
                setTimeout(success, time);
            },
            success: success,
            error: 'Couldn\'t wait!',
            timeout: time + 1000
        });
        return this;
    };
    FuncUnit.branch = function (check1, success1, check2, success2, timeout) {
        FuncUnit.repeat({
            method: function (print) {
                print('Running a branch statement');
                if (check1()) {
                    success1();
                    return true;
                }
                if (check2()) {
                    success2();
                    return true;
                }
            },
            error: 'no branch condition was ever true',
            timeout: timeout,
            type: 'branch'
        });
    };
    FuncUnit.repeat = function (options) {
        var interval, stopped = false, stop = function () {
                clearTimeout(interval);
                stopped = true;
            };
        FuncUnit.add({
            method: function (success, error) {
                options.bind = this.bind;
                options.selector = this.selector;
                var printed = false, print = function (msg) {
                        if (!printed) {
                            printed = true;
                        }
                    };
                interval = setTimeout(function () {
                    var result = null;
                    try {
                        result = options.method(print);
                    } catch (e) {
                    }
                    if (result) {
                        success(options.bind);
                    } else if (!stopped) {
                        interval = setTimeout(arguments.callee, 10);
                    }
                }, 10);
            },
            success: options.success,
            error: options.error,
            timeout: options.timeout,
            stop: stop,
            bind: options.bind,
            type: options.type
        });
    };
    FuncUnit.animationEnd = function () {
        F('body').wait(200).size(function () {
            return F.win.$(':animated').length === 0;
        });
    };
    FuncUnit.animationsDone = FuncUnit.animationEnd;
    $.extend(FuncUnit.prototype, {
        exists: function (timeout, success, message) {
            var logMessage = 'Waiting for \'' + this.selector + '\' to exist';
            if (timeout === false) {
                logMessage = false;
            }
            return this.size({
                condition: function (size) {
                    return size > 0;
                },
                timeout: timeout,
                success: success,
                message: message,
                errorMessage: 'Exist failed: element with selector \'' + this.selector + '\' not found',
                logMessage: logMessage
            });
        },
        missing: function (timeout, success, message) {
            return this.size(0, timeout, success, message);
        },
        visible: function (timeout, success, message) {
            var self = this, sel = this.selector, ret;
            return this.size(function (size) {
                return this.is(':visible') === true;
            }, timeout, success, message);
        },
        invisible: function (timeout, success, message) {
            var self = this, sel = this.selector, ret;
            return this.size(function (size) {
                return this.is(':visible') === false;
            }, timeout, success, message);
        },
        wait: function (checker, timeout, success, message) {
            if (typeof checker === 'number') {
                timeout = checker;
                FuncUnit.wait(timeout, success);
                return this;
            } else {
                return this.size(checker, timeout, success, message);
            }
        },
        then: function (success) {
            var self = this;
            FuncUnit.wait(0, function () {
                success.call(this, this);
            });
            return this;
        }
    });
    module.exports = FuncUnit;
});
/*funcunit@3.5.0#funcunit*/
define('funcunit@3.5.0#funcunit', [
    'require',
    'exports',
    'module',
    'syn',
    'funcunit/browser/core',
    'funcunit/browser/adapters/',
    'funcunit/browser/open',
    'funcunit/browser/actions',
    'funcunit/browser/getters',
    'funcunit/browser/traversers',
    'funcunit/browser/queue',
    'funcunit/browser/waits'
], function (require, exports, module) {
    var syn = require('syn');
    var FuncUnit = require('funcunit/browser/core');
    require('funcunit/browser/adapters/');
    require('funcunit/browser/open');
    require('funcunit/browser/actions');
    require('funcunit/browser/getters');
    require('funcunit/browser/traversers');
    require('funcunit/browser/queue');
    require('funcunit/browser/waits');
    window.FuncUnit = window.S = window.F = FuncUnit;
    module.exports = FuncUnit;
});
/*can@4.0.0-pre.14#docs/can-guides/experiment/todomvc/test*/
define('can@4.0.0-pre.14#docs/can-guides/experiment/todomvc/test', [
    'steal-qunit',
    'funcunit'
], function (_stealQunit, _funcunit) {
    'use strict';
    var _stealQunit2 = _interopRequireDefault(_stealQunit);
    var _funcunit2 = _interopRequireDefault(_funcunit);
    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
    }
    _funcunit2.default.attach(_stealQunit2.default);
    _stealQunit2.default.module('todomvc', {
        beforeEach: function beforeEach(assert) {
            localStorage.clear();
        }
    });
    _stealQunit2.default.test('basics work', function () {
        (0, _funcunit2.default)('li.todo', 0).size(3, 'there are 3 todos');
        (0, _funcunit2.default)('#new-todo', 0).type('new thing\r');
        (0, _funcunit2.default)('li.todo', 0).size(4, 'new todo added');
    });
});
/*can@4.0.0-pre.14#test/integration/all/test*/
define('can@4.0.0-pre.14#test/integration/all/test', [
    'require',
    'exports',
    'module',
    'steal-qunit'
], function (require, exports, module) {
    (function (global, __dirname, require, exports, module) {
        var QUnit = require('steal-qunit');
        var makeIframe = function (src) {
            var iframe = document.createElement('iframe');
            window.removeMyself = function () {
                delete window.removeMyself;
                document.body.removeChild(iframe);
                QUnit.start();
            };
            document.body.appendChild(iframe);
            iframe.src = src;
        };
        QUnit.module('can.all.js');
        if (__dirname !== '/') {
            QUnit.asyncTest('works without globals (jquery, kefir, etc)', function () {
                makeIframe(__dirname + '/no-globals.html?' + Math.random());
            });
        }
    }(function () {
        return this;
    }(), '/', require, exports, module));
});
/*can@4.0.0-pre.14#test/test*/
define('can@4.0.0-pre.14#test/test', [
    'require',
    'exports',
    'module',
    'can-component/test/tests',
    'can-define/test/test',
    'can-stache-bindings/test/tests',
    'can-set/test/test',
    'can-ajax/can-ajax-test',
    'can-assign/can-assign-test',
    'can-construct/can-construct_test',
    'can-construct-super/test/can-construct-super_test',
    'can-control/can-control_test',
    'can-define-lazy-value/define-lazy-value-test',
    'can-deparam/can-deparam-test',
    'can-dom-events/can-dom-events-test',
    'can-event-dom-enter/can-event-dom-enter-test',
    'can-event-dom-radiochange/can-event-dom-radiochange-test',
    'can-event-queue/can-event-queue-test',
    'can-globals/can-globals-test',
    'can-key-tree/can-key-tree-test',
    'can-param/can-param-test',
    'can-parse-uri/can-parse-uri-test',
    'can-queues/can-queues-test',
    'can-reflect/can-reflect-test',
    'can-reflect-dependencies/test',
    'can-reflect-promise/test/can-reflect-promise_test',
    'can-simple-dom/test/test',
    'can-simple-observable/can-simple-observable-test',
    'can-stache-key/can-stache-key-test',
    'can-symbol/can-symbol-test',
    'can-util/js/tests',
    'can-validate-interface/test',
    'can-view-live/test/test',
    'can-view-model/test/test',
    'can-view-nodelist/test/can-view-nodelist-test',
    'can-view-parser/test/can-view-parser-test',
    'can-view-scope/test/scope-test',
    'can-view-target/test/test',
    'can-stache-converters/test/test',
    'can-compute/can-compute_test',
    'can-list/can-list_test',
    'can-map/can-map_test',
    'can-fixture/test/fixture_test',
    'can-kefir/can-kefir-test',
    'can-stream/can-stream_test',
    'can-stream-kefir/can-stream-kefir_test',
    'can-ndjson-stream/can-ndjson-stream-test',
    'can-define-stream/can-define-stream_test',
    'can-define-stream-kefir/can-define-stream-kefir_test',
    'can-validate/test',
    'can-validate-validatejs/test',
    'can-define-validate-validatejs/test',
    'react-view-model/test/test#?can/test/browser-supports-react',
    'can-view-autorender/test/test',
    '../docs/can-guides/experiment/todomvc/test',
    './integration/all/test'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        require('can-component/test/tests');
        require('can-define/test/test');
        require('can-stache-bindings/test/tests');
        require('can-set/test/test');
        require('can-ajax/can-ajax-test');
        require('can-assign/can-assign-test');
        require('can-construct/can-construct_test');
        require('can-construct-super/test/can-construct-super_test');
        require('can-control/can-control_test');
        require('can-define-lazy-value/define-lazy-value-test');
        require('can-deparam/can-deparam-test');
        require('can-dom-events/can-dom-events-test');
        require('can-event-dom-enter/can-event-dom-enter-test');
        require('can-event-dom-radiochange/can-event-dom-radiochange-test');
        require('can-event-queue/can-event-queue-test');
        require('can-globals/can-globals-test');
        require('can-key-tree/can-key-tree-test');
        require('can-param/can-param-test');
        require('can-parse-uri/can-parse-uri-test');
        require('can-queues/can-queues-test');
        require('can-reflect/can-reflect-test');
        require('can-reflect-dependencies/test');
        require('can-reflect-promise/test/can-reflect-promise_test');
        require('can-simple-dom/test/test');
        require('can-simple-observable/can-simple-observable-test');
        require('can-stache-key/can-stache-key-test');
        require('can-symbol/can-symbol-test');
        require('can-util/js/tests');
        require('can-validate-interface/test');
        require('can-view-live/test/test');
        require('can-view-model/test/test');
        require('can-view-nodelist/test/can-view-nodelist-test');
        require('can-view-parser/test/can-view-parser-test');
        require('can-view-scope/test/scope-test');
        require('can-view-target/test/test');
        require('can-stache-converters/test/test');
        require('can-compute/can-compute_test');
        require('can-list/can-list_test');
        require('can-map/can-map_test');
        require('can-fixture/test/fixture_test');
        require('can-kefir/can-kefir-test');
        require('can-stream/can-stream_test');
        require('can-stream-kefir/can-stream-kefir_test');
        require('can-ndjson-stream/can-ndjson-stream-test');
        require('can-define-stream/can-define-stream_test');
        require('can-define-stream-kefir/can-define-stream-kefir_test');
        require('can-validate/test');
        require('can-validate-validatejs/test');
        require('can-define-validate-validatejs/test');
        require('react-view-model/test/test#?can/test/browser-supports-react');
        require('can-view-autorender/test/test');
        require('../docs/can-guides/experiment/todomvc/test');
        require('./integration/all/test');
    }(function () {
        return this;
    }(), require, exports, module));
});