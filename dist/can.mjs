if (typeof process === "undefined") {
	(function(global) {
		global.process = { env: { NODE_ENV: "development" } };
	})(typeof self !== "undefined" ? self : global);
}

var canNamespace_1_0_0_canNamespace = {};

var CanSymbol;
if(typeof Symbol !== "undefined" && typeof Symbol.for === "function") {
	CanSymbol = Symbol;
} else {

	var symbolNum = 0;
	CanSymbol = function CanSymbolPolyfill(description){
		var symbolValue = "@@symbol"+(symbolNum++)+(description);

		var symbol = {}; // make it object type

		Object.defineProperties(symbol, {
			toString: {
				value: function(){
					return symbolValue;
				}
			}
		});

		return symbol;
	};

	var descriptionToSymbol = {};
	var symbolToDescription = {};

	/**
	 * @function can-symbol.for for
	 * @parent  can-symbol/methods
	 * @description  Get a symbol based on a known string identifier, or create it if it doesn't exist.
	 *
	 * @signature `canSymbol.for(String)`
	 *
	 * @param { String } description  The string value of the symbol
	 * @return { CanSymbol } The globally unique and consistent symbol with the given string value.
	 */
	CanSymbol.for = function(description){
		var symbol = descriptionToSymbol[description];
		if(!symbol) {
			symbol = descriptionToSymbol[description] = CanSymbol(description);
			symbolToDescription[symbol] = description;
		}
		return symbol;
	};
	/**
	 * @function can-symbol.keyFor keyFor
	 * @parent  can-symbol
	 * @description  Get the description for a symbol.
	 *
	 * @signature `canSymbol.keyFor(CanSymbol)`
	 *
	 * @param { String } description  The string value of the symbol
	 * @return { CanSymbol } The globally unique and consistent symbol with the given string value.
	 */
	CanSymbol.keyFor = function(symbol) {
		return symbolToDescription[symbol];
	};
	["hasInstance","isConcatSpreadable",
		"iterator","match","prototype","replace","search","species","split",
	"toPrimitive","toStringTag","unscopables"].forEach(function(name){
		CanSymbol[name] = CanSymbol("Symbol."+name);
	});
}

// Generate can. symbols.
[
	// ======= Type detection ==========
	"isMapLike",
	"isListLike",
	"isValueLike",
	"isFunctionLike",
	// ======= Shape detection =========
	"getOwnKeys",
	"getOwnKeyDescriptor",
	"proto",
	// optional
	"getOwnEnumerableKeys",
	"hasOwnKey",
	"hasKey",
	"size",
	"getName",
	"getIdentity",

	// shape manipulation
	"assignDeep",
	"updateDeep",

	// ======= GET / SET
	"getValue",
	"setValue",
	"getKeyValue",
	"setKeyValue",
	"updateValues",
	"addValue",
	"removeValues",
	// ======= Call =========
	"apply",
	"new",
	// ======= Observe =========
	"onValue",
	"offValue",
	"onKeyValue",
	"offKeyValue",
	"getKeyDependencies",
	"getValueDependencies",
	"keyHasDependencies",
	"valueHasDependencies",
	"onKeys",
	"onKeysAdded",
	"onKeysRemoved",
	"onPatches"
	].forEach(function(name){
	CanSymbol.for("can."+name);
});

var canSymbol_1_6_1_canSymbol = canNamespace_1_0_0_canNamespace.Symbol = CanSymbol;

var helpers = {
	makeGetFirstSymbolValue: function(symbolNames){
		var symbols = symbolNames.map(function(name){
			return canSymbol_1_6_1_canSymbol.for(name);
		});
		var length = symbols.length;

		return function getFirstSymbol(obj){
			var index = -1;

			while (++index < length) {
				if(obj[symbols[index]] !== undefined) {
					return obj[symbols[index]];
				}
			}
		};
	},
	// The `in` check is from jQueryâ€™s fix for an iOS 8 64-bit JIT object length bug:
	// https://github.com/jquery/jquery/pull/2185
	hasLength: function(list){
		var type = typeof list;
		if(type === "string" || Array.isArray(list)) {
			return true;
		}
		var length = list && (type !== 'boolean' && type !== 'number' && "length" in list) && list.length;

		// var length = "length" in obj && obj.length;
		return typeof list !== "function" &&
			( length === 0 || typeof length === "number" && length > 0 && ( length - 1 ) in list );
	}
};

var plainFunctionPrototypePropertyNames = Object.getOwnPropertyNames((function(){}).prototype);
var plainFunctionPrototypeProto = Object.getPrototypeOf( (function(){}).prototype );
/**
 * @function can-reflect.isConstructorLike isConstructorLike
 * @parent can-reflect/type
 *
 * @description Test if a value looks like a constructor function.
 *
 * @signature `isConstructorLike(func)`
 *
 * Return `true` if `func` is a function and has a non-empty prototype, or implements
 *  [can-symbol/symbols/new `@@@@can.new`]; `false` otherwise.
 *
 * ```
 * canReflect.isConstructorLike(function() {}); // -> false
 *
 * function Construct() {}
 * Construct.prototype = { foo: "bar" };
 * canReflect.isConstructorLike(Construct); // -> true
 *
 * canReflect.isConstructorLike({}); // -> false
 * !!canReflect.isConstructorLike({ [canSymbol.for("can.new")]: function() {} }); // -> true
 * ```
 *
 * @param  {*}  func maybe a function
 * @return {Boolean} `true` if a constructor; `false` if otherwise.
 */
function isConstructorLike(func){
	/* jshint unused: false */
	// if you can new it ... it's a constructor
	var value = func[canSymbol_1_6_1_canSymbol.for("can.new")];
	if(value !== undefined) {
		return value;
	}

	if(typeof func !== "function") {
		return false;
	}
	// If there are any properties on the prototype that don't match
	// what is normally there, assume it's a constructor
	var prototype = func.prototype;
	if(!prototype) {
		return false;
	}
	// Check if the prototype's proto doesn't point to what it normally would.
	// If it does, it means someone is messing with proto chains
	if( plainFunctionPrototypeProto !== Object.getPrototypeOf( prototype ) ) {
		return true;
	}

	var propertyNames = Object.getOwnPropertyNames(prototype);
	if(propertyNames.length === plainFunctionPrototypePropertyNames.length) {
		for(var i = 0, len = propertyNames.length; i < len; i++) {
			if(propertyNames[i] !== plainFunctionPrototypePropertyNames[i]) {
				return true;
			}
		}
		return false;
	} else {
		return true;
	}
}

/**
 * @function can-reflect.isFunctionLike isFunctionLike
 * @parent can-reflect/type
 * @description Test if a value looks like a function.
 * @signature `isFunctionLike(obj)`
 *
 *  Return `true` if `func` is a function, or implements
 *  [can-symbol/symbols/new `@@@@can.new`] or [can-symbol/symbols/apply `@@@@can.apply`]; `false` otherwise.
 *
 * ```
 * canReflect.isFunctionLike(function() {}); // -> true
 * canReflect.isFunctionLike({}); // -> false
 * canReflect.isFunctionLike({ [canSymbol.for("can.apply")]: function() {} }); // -> true
 * ```
 *
 * @param  {*}  obj maybe a function
 * @return {Boolean}
 */
var getNewOrApply = helpers.makeGetFirstSymbolValue(["can.new","can.apply"]);
function isFunctionLike(obj){
	var result,
		symbolValue = obj[canSymbol_1_6_1_canSymbol.for("can.isFunctionLike")];

	if (symbolValue !== undefined) {
		return symbolValue;
	}

	result = getNewOrApply(obj);
	if(result !== undefined) {
		return !!result;
	}

	return typeof obj === "function";
}

/**
 * @function can-reflect.isPrimitive isPrimitive
 * @parent can-reflect/type
 * @description Test if a value is a JavaScript primitive.
 * @signature `isPrimitive(obj)`
 *
 * Return `true` if `obj` is not a function nor an object via `typeof`, or is null; `false` otherwise.
 *
 * ```
 * canReflect.isPrimitive(null); // -> true
 * canReflect.isPrimitive({}); // -> false
 * canReflect.isPrimitive(undefined); // -> true
 * canReflect.isPrimitive(1); // -> true
 * canReflect.isPrimitive([]); // -> false
 * canReflect.isPrimitive(function() {}); // -> false
 * canReflect.isPrimitive("foo"); // -> true
 *
 * ```
 *
 * @param  {*}  obj maybe a primitive value
 * @return {Boolean}
 */
function isPrimitive(obj){
	var type = typeof obj;
	if(obj == null || (type !== "function" && type !== "object") ) {
		return true;
	}
	else {
		return false;
	}
}

/**
 * @function can-reflect.isBuiltIn isBuiltIn
 * @parent can-reflect/type
 * @description Test if a value is a JavaScript built-in type.
 * @signature `isBuiltIn(obj)`
 *
 * Return `true` if `obj` is some type of JavaScript native built-in; `false` otherwise.
 *
 * ```
 * canReflect.isBuiltIn(null); // -> true
 * canReflect.isBuiltIn({}); // -> true
 * canReflect.isBuiltIn(1); // -> true
 * canReflect.isBuiltIn([]); // -> true
 * canReflect.isBuiltIn(function() {}); // -> true
 * canReflect.isBuiltIn("foo"); // -> true
 * canReflect.isBuiltIn(new Date()); // -> true
 * canReflect.isBuiltIn(/[foo].[bar]/); // -> true
 * canReflect.isBuiltIn(new DefineMap); // -> false
 *
 * ```
 *
 * Not supported in browsers that have implementations of Map/Set where
 * `toString` is not properly implemented to return `[object Map]`/`[object Set]`.
 *
 * @param  {*}  obj maybe a built-in value
 * @return {Boolean}
 */
function isBuiltIn(obj) {

	// If primitive, array, or POJO return true. Also check if
	// it is not a POJO but is some type like [object Date] or
	// [object Regex] and return true.
	if (isPrimitive(obj) ||
		Array.isArray(obj) ||
		isPlainObject(obj) ||
		(Object.prototype.toString.call(obj) !== '[object Object]' &&
			Object.prototype.toString.call(obj).indexOf('[object ') !== -1)) {
		return true;
	}
	else {
		return false;
	}
}

/**
 * @function can-reflect.isValueLike isValueLike
 * @parent can-reflect/type
 * @description Test if a value represents a single value (as opposed to several values).
 *
 * @signature `isValueLike(obj)`
 *
 * Return `true` if `obj` is a primitive or implements [can-symbol/symbols/getValue `@@can.getValue`],
 * `false` otherwise.
 *
 * ```
 * canReflect.isValueLike(null); // -> true
 * canReflect.isValueLike({}); // -> false
 * canReflect.isValueLike(function() {}); // -> false
 * canReflect.isValueLike({ [canSymbol.for("can.isValueLike")]: true}); // -> true
 * canReflect.isValueLike({ [canSymbol.for("can.getValue")]: function() {} }); // -> true
 * canReflect.isValueLike(canCompute()); // -> true
 * canReflect.isValueLike(new DefineMap()); // -> false
 *
 * ```
 *
 * @param  {*}  obj maybe a primitive or an object that yields a value
 * @return {Boolean}
 */
function isValueLike(obj) {
	var symbolValue;
	if(isPrimitive(obj)) {
		return true;
	}
	symbolValue = obj[canSymbol_1_6_1_canSymbol.for("can.isValueLike")];
	if( typeof symbolValue !== "undefined") {
		return symbolValue;
	}
	var value = obj[canSymbol_1_6_1_canSymbol.for("can.getValue")];
	if(value !== undefined) {
		return !!value;
	}
}

/**
 * @function can-reflect.isMapLike isMapLike
 * @parent can-reflect/type
 *
 * @description Test if a value represents multiple values.
 *
 * @signature `isMapLike(obj)`
 *
 * Return `true` if `obj` is _not_ a primitive, does _not_ have a falsy value for
 * [can-symbol/symbols/isMapLike `@@@@can.isMapLike`], or alternately implements
 * [can-symbol/symbols/getKeyValue `@@@@can.getKeyValue`]; `false` otherwise.
 *
 * ```
 * canReflect.isMapLike(null); // -> false
 * canReflect.isMapLike(1); // -> false
 * canReflect.isMapLike("foo"); // -> false
 * canReflect.isMapLike({}); // -> true
 * canReflect.isMapLike(function() {}); // -> true
 * canReflect.isMapLike([]); // -> false
 * canReflect.isMapLike({ [canSymbol.for("can.isMapLike")]: false }); // -> false
 * canReflect.isMapLike({ [canSymbol.for("can.getKeyValue")]: null }); // -> false
 * canReflect.isMapLike(canCompute()); // -> false
 * canReflect.isMapLike(new DefineMap()); // -> true
 *
 * ```
 *
 * @param  {*}  obj maybe a Map-like
 * @return {Boolean}
 */
function isMapLike(obj) {
	if(isPrimitive(obj)) {
		return false;
	}
	var isMapLike = obj[canSymbol_1_6_1_canSymbol.for("can.isMapLike")];
	if(typeof isMapLike !== "undefined") {
		return !!isMapLike;
	}
	var value = obj[canSymbol_1_6_1_canSymbol.for("can.getKeyValue")];
	if(value !== undefined) {
		return !!value;
	}
	// everything else in JS is MapLike
	return true;
}

/**
 * @function can-reflect.isObservableLike isObservableLike
 * @parent can-reflect/type
 * @description Test if a value (or its keys) can be observed for changes.
 *
 * @signature `isObservableLike(obj)`
 *
 * Return  `true` if `obj` is _not_ a primitive and implements any of
 * [can-symbol/symbols/onValue `@@@@can.onValue`], [can-symbol/symbols/onKeyValue `@@@@can.onKeyValue`], or
 * [can-symbol/symbols/onPatches `@@@@can.onKeys`]; `false` otherwise.
 *
 * ```
 * canReflect.isObservableLike(null); // -> false
 * canReflect.isObservableLike({}); // -> false
 * canReflect.isObservableLike([]); // -> false
 * canReflect.isObservableLike(function() {}); // -> false
 * canReflect.isObservableLike({ [canSymbol.for("can.onValue")]: function() {} }); // -> true
 * canReflect.isObservableLike({ [canSymbol.for("can.onKeyValue")]: function() {} }); // -> true
 * canReflect.isObservableLike(canCompute())); // -> true
 * canReflect.isObservableLike(new DefineMap())); // -> true
 * ```
 *
 * @param  {*}  obj maybe an observable
 * @return {Boolean}
 */

// Specially optimized
var onValueSymbol = canSymbol_1_6_1_canSymbol.for("can.onValue"),
	onKeyValueSymbol = canSymbol_1_6_1_canSymbol.for("can.onKeyValue"),
	onPatchesSymbol = canSymbol_1_6_1_canSymbol.for("can.onPatches");
function isObservableLike( obj ) {
	if(isPrimitive(obj)) {
		return false;
	}
	return Boolean(obj[onValueSymbol] || obj[onKeyValueSymbol] || obj[onPatchesSymbol]);
}

/**
 * @function can-reflect.isListLike isListLike
 * @parent can-reflect/type
 *
 * @description Test if a value looks like a constructor function.
 *
 * @signature `isListLike(list)`
 *
 * Return `true` if `list` is a `String`, <br>OR `list` is _not_ a primitive and implements `@@@@iterator`,
 * <br>OR `list` is _not_ a primitive and returns `true` for `Array.isArray()`, <br>OR `list` is _not_ a primitive and has a
 * numerical length and is either empty (`length === 0`) or has a last element at index `length - 1`; <br>`false` otherwise
 *
 * ```
 * canReflect.isListLike(null); // -> false
 * canReflect.isListLike({}); // -> false
 * canReflect.isListLike([]); // -> true
 * canReflect.isListLike("foo"); // -> true
 * canReflect.isListLike(1); // -> false
 * canReflect.isListLike({ [canSymbol.for("can.isListLike")]: true }); // -> true
 * canReflect.isListLike({ [canSymbol.iterator]: function() {} }); // -> true
 * canReflect.isListLike({ length: 0 }); // -> true
 * canReflect.isListLike({ length: 3 }); // -> false
 * canReflect.isListLike({ length: 3, "2": true }); // -> true
 * canReflect.isListLike(new DefineMap()); // -> false
 * canReflect.isListLike(new DefineList()); // -> true
 * ```
 *
 * @param  {*}  list maybe a List-like
 * @return {Boolean}
 */
function isListLike( list ) {
	var symbolValue,
		type = typeof list;
	if(type === "string") {
		return true;
	}
	if( isPrimitive(list) ) {
		return false;
	}
	symbolValue = list[canSymbol_1_6_1_canSymbol.for("can.isListLike")];
	if( typeof symbolValue !== "undefined") {
		return symbolValue;
	}
	var value = list[canSymbol_1_6_1_canSymbol.iterator];
	if(value !== undefined) {
		return !!value;
	}
	if(Array.isArray(list)) {
		return true;
	}
	return helpers.hasLength(list);
}

/**
 * @function can-reflect.isSymbolLike isSymbolLike
 * @parent can-reflect/type
 *
 * @description Test if a value is a symbol or a [can-symbol].
 *
 * @signature `isSymbolLike(symbol)`
 *
 * Return `true` if `symbol` is a native Symbol, or evaluates to a String with a prefix
 * equal to that of CanJS's symbol polyfill; `false` otherwise.
 *
 * ```
 * /* ES6 *\/ canReflect.isSymbolLike(Symbol.iterator); // -> true
 * canReflect.isSymbolLike(canSymbol.for("foo")); // -> true
 * canReflect.isSymbolLike("@@symbol.can.isSymbol"); // -> true (due to polyfill for non-ES6)
 * canReflect.isSymbolLike("foo"); // -> false
 * canReflect.isSymbolLike(null); // -> false
 * canReflect.isSymbolLike(1); // -> false
 * canReflect.isSymbolLike({}); // -> false
 * canReflect.isSymbolLike({ toString: function() { return "@@symbol.can.isSymbol"; } }); // -> true
 * ```
 *
 * @param  {*}  symbol maybe a symbol
 * @return {Boolean}
 */

var supportsSymbols = typeof Symbol !== "undefined" && typeof Symbol.for === "function";
var isSymbolLike;
if(supportsSymbols) {
	isSymbolLike = function(symbol) {
		return typeof symbol === "symbol";
	};
} else {
	var symbolStart = "@@symbol";
	isSymbolLike = function(symbol) {
		if(typeof symbol === "object" && !Array.isArray(symbol)){
			return symbol.toString().substr(0, symbolStart.length) === symbolStart;
		} else {
			return false;
		}
	};
}

var coreHasOwn = Object.prototype.hasOwnProperty;
var funcToString = Function.prototype.toString;
var objectCtorString = funcToString.call(Object);

function isPlainObject(obj) {
	// Must be an Object.
	// Because of IE, we also have to check the presence of the constructor property.
	// Make sure that DOM nodes and window objects don't pass through, as well
	if (!obj || typeof obj !== 'object' ) {
		return false;
	}
	var proto = Object.getPrototypeOf(obj);
	if(proto === Object.prototype || proto === null) {
		return true;
	}
	// partially inspired by lodash: https://github.com/lodash/lodash
	var Constructor = coreHasOwn.call(proto, 'constructor') && proto.constructor;
	return typeof Constructor === 'function' && Constructor instanceof Constructor &&
    	funcToString.call(Constructor) === objectCtorString;
}

var type = {
	isConstructorLike: isConstructorLike,
	isFunctionLike: isFunctionLike,
	isListLike: isListLike,
	isMapLike: isMapLike,
	isObservableLike: isObservableLike,
	isPrimitive: isPrimitive,
	isBuiltIn: isBuiltIn,
	isValueLike: isValueLike,
	isSymbolLike: isSymbolLike,
	/**
	 * @function can-reflect.isMoreListLikeThanMapLike isMoreListLikeThanMapLike
	 * @parent can-reflect/type
	 *
	 * @description Test if a value should be treated as a list instead of a map.
	 *
	 * @signature `isMoreListLikeThanMapLike(obj)`
	 *
	 * Return  `true` if `obj` is an Array, declares itself to be more ListLike with
	 * `@@@@can.isMoreListLikeThanMapLike`, or self-reports as ListLike but not as MapLike; `false` otherwise.
	 *
	 * ```
	 * canReflect.isMoreListLikeThanMapLike([]); // -> true
	 * canReflect.isMoreListLikeThanMapLike(null); // -> false
	 * canReflect.isMoreListLikeThanMapLike({}); // -> false
	 * canReflect.isMoreListLikeThanMapLike(new DefineList()); // -> true
	 * canReflect.isMoreListLikeThanMapLike(new DefineMap()); // -> false
	 * canReflect.isMoreListLikeThanMapLike(function() {}); // -> false
	 * ```
	 *
	 * @param  {Object}  obj the object to test for ListLike against MapLike traits.
	 * @return {Boolean}
	 */
	isMoreListLikeThanMapLike: function(obj){
		if(Array.isArray(obj)) {
			return true;
		}
		if(obj instanceof Array) {
			return true;
		}
		if( obj == null ) {
			return false;
		}
		var value = obj[canSymbol_1_6_1_canSymbol.for("can.isMoreListLikeThanMapLike")];
		if(value !== undefined) {
			return value;
		}
		var isListLike = this.isListLike(obj),
			isMapLike = this.isMapLike(obj);
		if(isListLike && !isMapLike) {
			return true;
		} else if(!isListLike && isMapLike) {
			return false;
		}
	},
	/**
	 * @function can-reflect.isIteratorLike isIteratorLike
	 * @parent can-reflect/type
	 * @description Test if a value looks like an iterator.
	 * @signature `isIteratorLike(obj)`
	 *
	 * Return `true` if `obj` has a key `"next"` pointing to a zero-argument function; `false` otherwise
	 *
	 * ```
	 * canReflect.isIteratorLike([][Symbol.iterator]()); // -> true
	 * canReflect.isIteratorLike(new DefineList()[canSymbol.iterator]()); // -> true
	 * canReflect.isIteratorLike(new DefineMap()[canSymbol.iterator]()); // -> true
	 * canReflect.isIteratorLike(null); // -> false
	 * canReflect.isIteratorLike({ next: function() {} }); // -> true
	 * canReflect.isIteratorLike({ next: function(foo) {} }); // -> false (iterator nexts do not take arguments)
	 * ```
	 *
	 * @param  {Object}  obj the object to test for Iterator traits
	 * @return {Boolean}
	 */
	isIteratorLike: function(obj){
		return obj &&
			typeof obj === "object" &&
			typeof obj.next === "function" &&
			obj.next.length === 0;
	},
	/**
	 * @function can-reflect.isPromise isPromise
	 * @parent can-reflect/type
	 * @description Test if a value is a promise.
	 *
	 * @signature `isPromise(obj)`
	 *
	 * Return `true` if `obj` is an instance of promise or `.toString` returns `"[object Promise]"`.
	 *
	 * ```
	 * canReflect.isPromise(Promise.resolve()); // -> true
	 * ```
	 *
	 * @param  {*}  obj the object to test for Promise traits.
	 * @return {Boolean}
	 */
	isPromise: function(obj){
		return (obj instanceof Promise || (Object.prototype.toString.call(obj) === '[object Promise]'));
	},
	/**
	 * @function can-reflect.isPlainObject isPlainObject
	 * @parent can-reflect/type
	 * @description Test if a value is an object created with `{}` or `new Object()`.
	 *
	 * @signature `isPlainObject(obj)`
	 *
	 * Attempts to determine if an object is a plain object like those you would create using the curly braces syntax: `{}`. The following are not plain objects:
	 *
	 * 1. Objects with prototypes (created using the `new` keyword).
	 * 2. Booleans.
	 * 3. Numbers.
	 * 4. NaN.
	 *
	 * ```js
	 * var isPlainObject = require("can-reflect").isPlainObject;
	 *
	 * // Created with {}
	 * console.log(isPlainObject({})); // -> true
	 *
	 * // new Object
	 * console.log(isPlainObject(new Object())); // -> true
	 *
	 * // Custom object
	 * var Ctr = function(){};
	 * var obj = new Ctr();
	 *
	 * console.log(isPlainObject(obj)); // -> false
	 * ```
	 *
	 * @param  {Object}  obj the object to test.
	 * @return {Boolean}
	 */
	isPlainObject: isPlainObject
};

var call = {
	/**
	 * @function {function(...), Object, ...} can-reflect/call.call call
	 * @parent can-reflect/call
	 * @description  Call a callable, with a context object and parameters
	 *
	 * @signature `call(func, context, ...rest)`
	 *
	 * Call the callable `func` as if it were a function, bound to `context` and with any additional parameters
	 * occurring after `context` set to the positional parameters.
	 *
	 * Note that `func` *must* either be natively callable, implement [can-symbol/symbols/apply @@@@can.apply],
	 * or have a callable `apply` property to work with `canReflect.call`
	 *
	 * ```
	 * var compute = canCompute("foo");
	 *
	 * canReflect.call(compute, null, "bar");
	 * canReflect.call(compute, null); // -> "bar"
	 * ```
	 *
	 * @param  {function(...)} func the function to call with the supplied arguments
	 * @param  {Object} context the context object to set as `this` on the function call
	 * @param  {*} rest any arguments after `context` will be passed to the function call
	 * @return {*}  return types and values are determined by the call to `func`
	 */
	call: function(func, context){
		var args = [].slice.call(arguments, 2);
		var apply = func[canSymbol_1_6_1_canSymbol.for("can.apply")];
		if(apply) {
			return apply.call(func, context, args);
		} else {
			return func.apply(context, args);
		}
	},
	/**
	 * @function {function(...), Object, ...} can-reflect/call.apply apply
	 * @parent can-reflect/call
	 * @description  Call a callable, with a context object and a list of parameters
	 *
	 * @signature `apply(func, context, args)`
	 *
	 * Call the callable `func` as if it were a function, bound to `context` and with any additional parameters
	 * contained in the Array-like `args`
	 *
	 * Note that `func` *must* either be natively callable, implement [can-symbol/symbols/apply @@@@can.apply],
	 * or have a callable `apply` property to work with `canReflect.apply`
	 *
	 * ```
	 * var compute = canCompute("foo");
	 *
	 * canReflect.apply(compute, null, ["bar"]);
	 * canReflect.apply(compute, null, []); // -> "bar"
	 * ```
	 *
	 * @param  {function(...)} func the function to call
	 * @param  {Object} context the context object to set as `this` on the function call
	 * @param  {*} args arguments to be passed to the function call
	 * @return {*}  return types and values are determined by the call to `func`
	 */
	apply: function(func, context, args){
		var apply = func[canSymbol_1_6_1_canSymbol.for("can.apply")];
		if(apply) {
			return apply.call(func, context, args);
		} else {
			return func.apply(context, args);
		}
	},
	/**
	 * @function {function(...), ...} can-reflect/call.new new
	 * @parent can-reflect/call
	 * @description  Construct a new instance of a callable constructor
	 *
	 * @signature `new(func, ...rest)`
	 *
	 * Call the callable `func` as if it were a function, bound to a new instance of `func`, and with any additional
	 * parameters occurring after `func` set to the positional parameters.
	 *
	 * Note that `func` *must* either implement [can-symbol/symbols/new @@@@can.new],
	 * or have a callable `apply` property *and* a prototype to work with `canReflect.new`
	 *
	 * ```
	 * canReflect.new(DefineList, ["foo"]); // -> ["foo"]<DefineList>
	 * ```
	 *
	 * @param  {function(...)} func a constructor
	 * @param  {*} rest arguments to be passed to the constructor
	 * @return {Object}  if `func` returns an Object, that returned Object; otherwise a new instance of `func`
	 */
	"new": function(func){
		var args = [].slice.call(arguments, 1);
		var makeNew = func[canSymbol_1_6_1_canSymbol.for("can.new")];
		if(makeNew) {
			return makeNew.apply(func, args);
		} else {
			var context = Object.create(func.prototype);
			var ret = func.apply(context, args);
			if(type.isPrimitive(ret)) {
				return context;
			} else {
				return ret;
			}
		}
	}
};

var setKeyValueSymbol = canSymbol_1_6_1_canSymbol.for("can.setKeyValue"),
	getKeyValueSymbol = canSymbol_1_6_1_canSymbol.for("can.getKeyValue"),
	getValueSymbol = canSymbol_1_6_1_canSymbol.for("can.getValue"),
	setValueSymbol = canSymbol_1_6_1_canSymbol.for("can.setValue");

var reflections = {
	/**
	 * @function {Object, String, *} can-reflect.setKeyValue setKeyValue
	 * @parent can-reflect/get-set
	 * @description Set the value of a named property on a MapLike object.
	 *
	 * @signature `setKeyValue(obj, key, value)`
	 *
	 * Set the property on Map-like `obj`, identified by the String, Symbol or Object value `key`, to the value `value`.
	 * The default behavior can be overridden on `obj` by implementing [can-symbol/symbols/setKeyValue @@@@can.setKeyValue],
	 * otherwise native named property access is used for string keys, and `Object.defineProperty` is used to set symbols.
	 *
	 * ```
	 * var foo = new DefineMap({ bar: "baz" });
	 *
	 * canReflect.setKeyValue(foo, "bar", "quux");
	 * foo[bar]; // -> "quux"
	 * ```
	 * @param  {Object} obj   the object to set on
	 * @param  {String} key   the key for the property to set
	 * @param  {*} value      the value to set on the object
	 */
	setKeyValue: function(obj, key, value){
		if( type.isSymbolLike(key) ) {
			if(typeof key === "symbol") {
				obj[key] = value;
			} else {
				Object.defineProperty(obj, key, {
					enumerable: false,
					configurable: true,
					value: value,
					writable: true
				});
			}
			return;
		}
		var setKeyValue = obj[setKeyValueSymbol];
		if(setKeyValue !== undefined) {
			return setKeyValue.call(obj, key, value);
		} else {
			obj[key] = value;
		}
	},
	/**
	 * @function {Object, String} can-reflect.getKeyValue getKeyValue
	 * @parent can-reflect/get-set
	 * @description Get the value of a named property on a MapLike object.
	 *
	 * @signature `getKeyValue(obj, key)`
	 *
	 * Retrieve the property on Map-like `obj` identified by the String or Symbol value `key`.  The default behavior
	 * can be overridden on `obj` by implementing [can-symbol/symbols/getKeyValue @@@@can.getKeyValue],
	 * otherwise native named property access is used.
	 *
	 * ```
	 * var foo = new DefineMap({ bar: "baz" });
	 *
	 * canReflect.getKeyValue(foo, "bar"); // -> "baz"
	 * ```
	 *
	 * @param  {Object} obj   the object to get from
	 * @param  {String} key   the key of the property to get
	 */
	getKeyValue: function(obj, key) {
		var getKeyValue = obj[getKeyValueSymbol];
		if(getKeyValue) {
			return getKeyValue.call(obj, key);
		}
		return obj[key];
	},
	/**
	 * @function {Object, String} can-reflect.deleteKeyValue deleteKeyValue
	 * @parent can-reflect/get-set
	 * @description Delete a named property from a MapLike object.
	 *
	 * @signature `deleteKeyValue(obj, key)`
	 *
	 * Remove the property identified by the String or Symbol `key` from the Map-like object `obj`, if possible.
	 * Property definitions may interfere with deleting key values; the behavior on `obj` if `obj[key]` cannot
	 * be deleted is undefined.  The default use of the native `delete` keyword can be overridden by `obj` if it
	 * implements [can-symbol/symbols/deleteKeyValue @@@@can.deleteKeyValue].
	 *
	 * ```
	 * var foo = new DefineMap({ bar: "baz" });
	 * var quux = new CanMap({ thud: "jeek" });
	 *
	 * canReflect.deleteKeyValue(foo, "bar");
	 * canReflect.deleteKeyValue(quux, "thud");
	 *
	 * "bar" in foo; // ->  true  -- DefineMaps use property defs which cannot be un-defined
	 * foo.bar // -> undefined    --  but set values to undefined when deleting
	 *
	 * "thud" in quux; // -> false
	 * quux.thud; // -> undefined
	 * ```
	 *
	 * @param  {Object} obj   the object to delete on
	 * @param  {String} key   the key for the property to delete
	 */
	deleteKeyValue: function(obj, key) {
		var deleteKeyValue = obj[canSymbol_1_6_1_canSymbol.for("can.deleteKeyValue")];
		if(deleteKeyValue) {
			return deleteKeyValue.call(obj, key);
		}
		delete obj[key];
	},
	/**
	 * @function {Object} can-reflect.getValue getValue
	 * @parent can-reflect/get-set
	 * @description Get the value of an object with a gettable value
	 *
	 * @signature `getValue(obj)`
	 *
	 * Return the value of the Value-like object `obj`.  Unless `obj` implements
	 * [can-symbol/symbols/getValue @@@@can.getValue], the result of `getValue` on
	 * `obj` will always be `obj`.  Observable Map-like objects may want to implement
	 * `@@@@can.getValue` to return non-observable or plain representations of themselves.
	 *
	 * ```
	 * var compute = canCompute("foo");
	 * var primitive = "bar";
	 *
	 * canReflect.getValue(compute); // -> "foo"
	 * canReflect.getValue(primitive); // -> "bar"
	 * ```
	 *
	 * @param  {Object} obj   the object to get from
	 * @return {*} the value of the object via `@@can.getValue`, or the value itself.
	 */
	getValue: function(value){
		if(type.isPrimitive(value)) {
			return value;
		}
		var getValue = value[getValueSymbol];
		if(getValue) {
			return getValue.call(value);
		}
		return value;
	},
	/**
	 * @function {Object, *} can-reflect.setValue setValue
	 * @parent can-reflect/get-set
	 * @description Set the value of a mutable object.
	 *
	 * @signature `setValue(obj, value)`
	 *
	 * Set the value of a Value-like object `obj` to the value `value`.  `obj` *must* implement
	 * [can-symbol/symbols/setValue @@@@can.setValue] to be used with `canReflect.setValue`.
	 * Map-like objects may want to implement `@@@@can.setValue` to merge objects of properties
	 * into themselves.
	 *
	 * ```
	 * var compute = canCompute("foo");
	 * var plain = {};
	 *
	 * canReflect.setValue(compute, "bar");
	 * compute(); // -> bar
	 *
	 * canReflect.setValue(plain, { quux: "thud" }); // throws "can-reflect.setValue - Can not set value."
	 * ```
	 *
	 * @param  {Object} obj   the object to set on
	 * @param  {*} value      the value to set for the object
	 */
	setValue: function(item, value){
		var setValue = item && item[setValueSymbol];
		if(setValue) {
			return setValue.call(item, value);
		} else {
			throw new Error("can-reflect.setValue - Can not set value.");
		}
	},

	splice: function(obj, index, removing, adding){
		var howMany;
		if(typeof removing !== "number") {
			var updateValues = obj[canSymbol_1_6_1_canSymbol.for("can.updateValues")];
			if(updateValues) {
				return updateValues.call(obj, index, removing, adding);
			}
			howMany = removing.length;
		} else {
			howMany = removing;
		}

		if(arguments.length <= 3){
			adding = [];
		}

		var splice = obj[canSymbol_1_6_1_canSymbol.for("can.splice")];
		if(splice) {
			return splice.call(obj, index, howMany, adding);
		}
		return [].splice.apply(obj, [index, howMany].concat(adding) );
	},
	addValues: function(obj, adding, index) {
		var add = obj[canSymbol_1_6_1_canSymbol.for("can.addValues")];
		if(add) {
			return add.call(obj, adding, index);
		}
		if(Array.isArray(obj) && index === undefined) {
			return obj.push.apply(obj, adding);
		}
		return reflections.splice(obj, index, [], adding);
	},
	removeValues: function(obj, removing, index) {
		var removeValues = obj[canSymbol_1_6_1_canSymbol.for("can.removeValues")];
		if(removeValues) {
			return removeValues.call(obj, removing, index);
		}
		if(Array.isArray(obj) && index === undefined) {
			removing.forEach(function(item){
				var index = obj.indexOf(item);
				if(index >=0) {
					obj.splice(index, 1);
				}
			});
			return;
		}
		return reflections.splice(obj, index, removing, []);
	}
};
/**
 * @function {Object, String} can-reflect.get get
 * @hide
 * @description an alias for [can-reflect.getKeyValue getKeyValue]
 */
reflections.get = reflections.getKeyValue;
/**
 * @function {Object, String} can-reflect.set set
 * @hide
 * @description an alias for [can-reflect.setKeyValue setKeyValue]
 */
reflections.set = reflections.setKeyValue;
/**
 * @function {Object, String} can-reflect.delete delete
 * @hide
 * @description an alias for [can-reflect.deleteKeyValue deleteKeyValue]
 */
reflections["delete"] = reflections.deleteKeyValue;

var getSet = reflections;

var slice = [].slice;

function makeFallback(symbolName, fallbackName) {
	return function(obj, event, handler, queueName){
		var method = obj[canSymbol_1_6_1_canSymbol.for(symbolName)];
		if(method !== undefined) {
			return method.call(obj, event, handler, queueName);
		}
		return this[fallbackName].apply(this, arguments);
	};
}

function makeErrorIfMissing(symbolName, errorMessage){
	return function(obj){
		var method = obj[canSymbol_1_6_1_canSymbol.for(symbolName)];
		if(method !== undefined) {
			var args = slice.call(arguments, 1);
			return method.apply(obj, args);
		}
		throw new Error(errorMessage);
	};
}

var observe = {
	// KEY
	/**
	 * @function {Object, String, function(*, *), String} can-reflect/observe.onKeyValue onKeyValue
	 * @parent can-reflect/observe
	 * @description  Register an event handler on a MapLike object, based on a key change
	 *
	 * @signature `onKeyValue(obj, key, handler, [queueName])`
	 *
	 * Register a handler on the Map-like object `obj` to trigger when the property key `key` changes.
	 * `obj` *must* implement [can-symbol/symbols/onKeyValue @@@@can.onKeyValue] to be compatible with
	 * can-reflect.onKeyValue.  The function passed as `handler` will receive the new value of the property
	 * as the first argument, and the previous value of the property as the second argument.
	 *
	 * ```js
	 * var obj = new DefineMap({ foo: "bar" });
	 * canReflect.onKeyValue(obj, "foo", function(newVal, oldVal) {
	 * 	console.log("foo is now", newVal, ", was", oldVal);
	 * });
	 *
	 * obj.foo = "baz";  // -> logs "foo is now baz , was bar"
	 * ```
	 *
	 * @param {Object} obj an observable MapLike that can listen to changes in named properties.
	 * @param {String} key  the key to listen to
	 * @param {function(*, *)} handler a callback function that recieves the new value
	 * @param {String} [queueName]  the queue to dispatch events to
	 */
	onKeyValue: makeFallback("can.onKeyValue", "onEvent"),
	/**
	 * @function {Object, String, function(*), String} can-reflect/observe.offKeyValue offKeyValue
	 * @parent can-reflect/observe
	 * @description  Unregister an event handler on a MapLike object, based on a key change
	 *
	 * @signature `offKeyValue(obj, key, handler, [queueName])`
	 *
	 * Unregister a handler from the Map-like object `obj` that had previously been registered with
	 * [can-reflect/observe.onKeyValue onKeyValue]. The function passed as `handler` will no longer be called
	 * when the value of `key` on `obj` changes.
	 *
	 * ```js
	 * var obj = new DefineMap({ foo: "bar" });
	 * var handler = function(newVal, oldVal) {
	 * 	console.log("foo is now", newVal, ", was", oldVal);
	 * };
	 *
	 * canReflect.onKeyValue(obj, "foo", handler);
	 * canReflect.offKeyValue(obj, "foo", handler);
	 *
	 * obj.foo = "baz";  // -> nothing is logged
	 * ```
	 *
	 * @param {Object} obj an observable MapLike that can listen to changes in named properties.
	 * @param {String} key  the key to stop listening to
	 * @param {function(*)} handler the callback function that should be removed from the event handlers for `key`
	 * @param {String} [queueName]  the queue that the handler was set to receive events from
	 */
	offKeyValue: makeFallback("can.offKeyValue","offEvent"),

	/**
	 * @function {Object, function(Array)} can-reflect/observe.onKeys onKeys
	 * @parent can-reflect/observe
	 * @description  Register an event handler on a MapLike object, triggered on the key set changing
	 *
	 * @signature `onKeys(obj, handler)`
	 *
	 * Register an event handler on the Map-like object `obj` to trigger when `obj`'s keyset changes.
	 * `obj` *must* implement [can-symbol/symbols/onKeys @@@@can.onKeys] to be compatible with
	 * can-reflect.onKeys.  The function passed as `handler` will receive an Array of object diffs (see
	 * [can-util/js/diff-object/diff-object diffObject] for the format) as its one argument.
	 *
	 * ```js
	 * var obj = new DefineMap({ foo: "bar" });
	 * canReflect.onKeys(obj, function(diffs) {
	 * 	console.log(diffs);
	 * });
	 *
	 * obj.set("baz", "quux");  // -> logs '[{"property": "baz", "type": "add", "value": "quux"}]'
	 * ```
	 *
	 * @param {Object} obj an observable MapLike that can listen to changes in named properties.
	 * @param {function(Array)} handler the callback function to receive the diffs in the key set
	 */
	// any key change (diff would normally happen)
	onKeys: makeErrorIfMissing("can.onKeys","can-reflect: can not observe an onKeys event"),
	/**
	 * @function {Object, function(Array)} can-reflect/observe.onKeysAdded onKeysAdded
	 * @parent can-reflect/observe
	 * @description  Register an event handler on a MapLike object, triggered on new keys being added.
	 *
	 * @signature `onKeysAdded(obj, handler)`
	 *
	 * Register an event handler on the Map-like object `obj` to trigger when a new key or keys are set on
	 * `obj`. `obj` *must* implement [can-symbol/symbols/onKeysAdded @@@@can.onKeysAdded] to be compatible with
	 * can-reflect.onKeysAdded.  The function passed as `handler` will receive an Array of Strings as its one
	 * argument.
	 *
	 * ```
	 * var obj = new DefineMap({ foo: "bar" });
	 * canReflect.onKeysAded(obj, function(newKeys) {
	 * 	console.log(newKeys);
	 * });
	 *
	 * foo.set("baz", "quux");  // -> logs '["baz"]'
	 * ```
	 *
	 * @param {Object} obj an observable MapLike that can listen to changes in named properties.
	 * @param {function(Array)} handler the callback function to receive the array of added keys
	 */
	// keys added at a certain point {key: 1}, index
	onKeysAdded: makeErrorIfMissing("can.onKeysAdded","can-reflect: can not observe an onKeysAdded event"),
	/**
	 * @function {Object, function(Array)} can-reflect/observe.onKeysRemoved onKeysRemoved
	 * @parent can-reflect/observe
	 * @description  Register an event handler on a MapLike object, triggered on keys being deleted.
	 *
	 * @signature `onKeysRemoved(obj, handler)`
	 *
	 * Register an event handler on the Map-like object `obj` to trigger when a key or keys are removed from
	 * `obj`'s keyset. `obj` *must* implement [can-symbol/symbols/onKeysRemoved @@@@can.onKeysRemoved] to be
	 * compatible with can-reflect.onKeysAdded.  The function passed as `handler` will receive an Array of
	 * Strings as its one argument.
	 *
	 * ```
	 * var obj = new CanMap({ foo: "bar" });
	 * canReflect.onKeys(obj, function(diffs) {
	 * 	console.log(JSON.stringify(diffs));
	 * });
	 *
	 * foo.removeAttr("foo");  // -> logs '["foo"]'
	 * ```
	 *
	 * @param {Object} obj an observable MapLike that can listen to changes in named properties.
	 * @param {function(Array)} handler the callback function to receive the array of removed keys
	 */
	onKeysRemoved: makeErrorIfMissing("can.onKeysRemoved","can-reflect: can not unobserve an onKeysRemoved event"),

	/**
	 * @function {Object, String} can-reflect/observe.getKeyDependencies getKeyDependencies
	 * @parent can-reflect/observe
	 * @description  Return the observable objects that compute to the value of a named property on an object
	 *
	 * @signature `getKeyDependencies(obj, key)`
	 *
	 * Return the observable objects that provide input values to generate the computed value of the
	 * property `key` on Map-like object `obj`.  If `key` does not have dependencies on `obj`, returns `undefined`.
	 * Otherwise returns an object with up to two keys: `keyDependencies` is a [can-util/js/cid-map/cid-map CIDMap] that
	 * maps each Map-like object providing keyed values to an Array of the relevant keys; `valueDependencies` is a
	 * [can-util/js/cid-set/cid-set CIDSet] that contains all Value-like dependencies providing their own values.
	 *
	 * `obj` *must* implement [can-symbol/symbols/getKeyDependencies @@@@can.getKeyDependencies] to work with
	 * `canReflect.getKeyDependencies`.
	 *
	 *
	 * ```
	 * var foo = new DefineMap({ "bar": "baz" })
	 * var obj = new (DefineMap.extend({
	 * 	 baz: {
	 * 	   get: function() {
	 * 	     return foo.bar;
	 * 	   }
	 * 	 }
	 * }))();
	 *
	 * canReflect.getKeyDependencies(obj, "baz");  // -> { valueDependencies: CIDSet }
	 * ```
	 *
	 * @param {Object} obj the object to check for key dependencies
	 * @param {String} key the key on the object to check
	 * @return {Object} the observable values that this keyed value depends on
	 */
	getKeyDependencies: makeErrorIfMissing("can.getKeyDependencies", "can-reflect: can not determine dependencies"),

	/**
	 * @function {Object, String} can-reflect/observe.getWhatIChange getWhatIChange
	 * @hide
	 * @parent can-reflect/observe
	 * @description Return the observable objects that derive their value from the
	 * obj, passed in.
	 *
	 * @signature `getWhatIChange(obj, key)`
	 *
	 * `obj` *must* implement `@@@@can.getWhatIChange` to work with
	 * `canReflect.getWhatIChange`.
	 *
	 * @param {Object} obj the object to check for what it changes
	 * @param {String} [key] the key on the object to check
	 * @return {Object} the observable values that derive their value from `obj`
	 */
	getWhatIChange: makeErrorIfMissing(
		"can.getWhatIChange",
		"can-reflect: can not determine dependencies"
	),

	/**
	 * @function {Function} can-reflect/observe.getChangesDependencyRecord getChangesDependencyRecord
	 * @hide
	 * @parent can-reflect/observe
	 * @description Return the observable objects that are mutated by the handler
	 * passed in as argument.
	 *
	 * @signature `getChangesDependencyRecord(handler)`
	 *
	 * `handler` *must* implement `@@@@can.getChangesDependencyRecord` to work with
	 * `canReflect.getChangesDependencyRecord`.
	 *
	 * ```
	 * var one = new SimpleObservable("one");
	 * var two = new SimpleObservable("two");
	 *
	 * var handler = function() {
	 *	two.set("2");
	 * };
	 *
	 * canReflect.onValue(one, handler);
	 * canReflect.getChangesDependencyRecord(handler); // -> { valueDependencies: new Set([two]) }
	 * ```
	 *
	 * @param {Function} handler the event handler to check for what it changes
	 * @return {Object} the observable values that are mutated by the handler
	 */
	getChangesDependencyRecord: function getChangesDependencyRecord(handler) {
		var fn = handler[canSymbol_1_6_1_canSymbol.for("can.getChangesDependencyRecord")];

		if (typeof fn === "function") {
			return fn();
		}
	},

	/**
	 * @function {Object, String} can-reflect/observe.keyHasDependencies keyHasDependencies
	 * @parent can-reflect/observe
	 * @description  Determine whether the value for a named property on an object is bound to other events
	 *
	 * @signature `keyHasDependencies(obj, key)`
	 *
	 * Returns `true` if the computed value of the property `key` on Map-like object `obj` derives from other values.
	 * Returns `false` if `key` is computed on `obj` but does not have dependencies on other objects. If `key` is not
	 * a computed value on `obj`, returns `undefined`.
	 *
	 * `obj` *must* implement [can-symbol/symbols/keyHasDependencies @@@@can.keyHasDependencies] to work with
	 * `canReflect.keyHasDependencies`.
	 *
	 * ```
	 * var foo = new DefineMap({ "bar": "baz" })
	 * var obj = new (DefineMap.extend({
	 * 	 baz: {
	 * 	   get: function() {
	 * 	     return foo.bar;
	 * 	   }
	 * 	 },
	 * 	 quux: {
	 * 	 	 get: function() {
	 * 	 	   return "thud";
	 * 	 	 }
	 * 	 }
	 * }))();
	 *
	 * canReflect.keyHasDependencies(obj, "baz");  // -> true
	 * canReflect.keyHasDependencies(obj, "quux");  // -> false
	 * canReflect.keyHasDependencies(foo, "bar");  // -> undefined
	 * ```
	 *
	 * @param {Object} obj the object to check for key dependencies
	 * @param {String} key the key on the object to check
	 * @return {Boolean} `true` if there are other objects that may update the keyed value; `false` otherwise
	 *
	 */
	// TODO: use getKeyDeps once we know what that needs to look like
	keyHasDependencies: makeErrorIfMissing("can.keyHasDependencies","can-reflect: can not determine if this has key dependencies"),

	// VALUE
	/**
	 * @function {Object, function(*)} can-reflect/observe.onValue onValue
	 * @parent can-reflect/observe
	 * @description  Register an event handler on an observable ValueLike object, based on a change in its value
	 *
	 * @signature `onValue(handler, [queueName])`
	 *
	 * Register an event handler on the Value-like object `obj` to trigger when its value changes.
	 * `obj` *must* implement [can-symbol/symbols/onValue @@@@can.onValue] to be compatible with
	 * can-reflect.onKeyValue.  The function passed as `handler` will receive the new value of `obj`
	 * as the first argument, and the previous value of `obj` as the second argument.
	 *
	 * ```
	 * var obj = canCompute("foo");
	 * canReflect.onValue(obj, function(newVal, oldVal) {
	 * 	console.log("compute is now", newVal, ", was", oldVal);
	 * });
	 *
	 * obj("bar");  // -> logs "compute is now bar , was foo"
	 * ```
	 *
	 * @param {*} obj  any object implementing @@can.onValue
	 * @param {function(*, *)} handler  a callback function that receives the new and old values
	 */
	onValue: makeErrorIfMissing("can.onValue","can-reflect: can not observe value change"),
	/**
	 * @function {Object, function(*)} can-reflect/observe.offValue offValue
	 * @parent can-reflect/observe
	 * @description  Unregister an value change handler from an observable ValueLike object
	 *
	 * @signature `offValue(handler, [queueName])`
	 *
	 * Unregister an event handler from the Value-like object `obj` that had previously been registered with
	 * [can-reflect/observe.onValue onValue]. The function passed as `handler` will no longer be called
	 * when the value of `obj` changes.
	 *
	 * ```
	 * var obj = canCompute( "foo" );
	 * var handler = function(newVal, oldVal) {
	 * 	console.log("compute is now", newVal, ", was", oldVal);
	 * };
	 *
	 * canReflect.onKeyValue(obj, handler);
	 * canReflect.offKeyValue(obj, handler);
	 *
	 * obj("baz");  // -> nothing is logged
	 * ```
	 *
	 * @param {*} obj
	 * @param {function(*)} handler
	 */
	offValue: makeErrorIfMissing("can.offValue","can-reflect: can not unobserve value change"),

	/**
	 * @function {Object} can-reflect/observe.getValueDependencies getValueDependencies
	 * @parent can-reflect/observe
	 * @description  Return all the events that bind to the value of an observable, Value-like object
	 *
	 * @signature `getValueDependencies(obj)`
	 *
	 * Return the observable objects that provide input values to generate the computed value of the
	 * Value-like object `obj`.  If `obj` does not have dependencies, returns `undefined`.
	 * Otherwise returns an object with up to two keys: `keyDependencies` is a [can-util/js/cid-map/cid-map CIDMap] that
	 * maps each Map-like object providing keyed values to an Array of the relevant keys; `valueDependencies` is a
	 * [can-util/js/cid-set/cid-set CIDSet] that contains all Value-like dependencies providing their own values.
	 *
	 * `obj` *must* implement [can-symbol/symbols/getValueDependencies @@@@can.getValueDependencies] to work with
	 * `canReflect.getValueDependencies`.
	 *
	 *
	 * ```
	 * var foo = new DefineMap({ "bar": "baz" })
	 * var obj = canCompute(function() {
	 * 	 return foo.bar;
	 * });
	 *
	 * canReflect.getValueDependencies(obj);  // -> { valueDependencies: CIDSet } because `obj` is internally backed by
	 * a [can-observation]
	 * ```
	 *
	 * @param {Object} obj the object to check for value dependencies
	 * @return {Object} the observable objects that `obj`'s value depends on
	 *
	 */
	getValueDependencies: makeErrorIfMissing("can.getValueDependencies","can-reflect: can not determine dependencies"),

	/**
	 * @function {Object} can-reflect/observe.valueHasDependencies valueHasDependencies
	 * @parent can-reflect/observe
	 * @description  Determine whether the value of an observable object is bound to other events
	 *
	 * @signature `valueHasDependencies(obj)`
	 *
	 * Returns `true` if the computed value of the Value-like object `obj` derives from other values.
	 * Returns `false` if `obj` is computed but does not have dependencies on other objects. If `obj` is not
	 * a computed value, returns `undefined`.
	 *
	 * `obj` *must* implement [can-symbol/symbols/valueHasDependencies @@@@can.valueHasDependencies] to work with
	 * `canReflect.valueHasDependencies`.
	 *
	 * ```
	 * var foo = canCompute( "bar" );
	 * var baz = canCompute(function() {
	 * 	 return foo();
	 * });
	 * var quux = "thud";
	 * var jeek = canCompute(function(plonk) {
	 * 	 if(argument.length) {
	 * 	 	  quux = plonk;
	 * 	 }
	 * 	 return quux;
	 * });
	 *
	 * canReflect.valueHasDependencies(baz);  // -> true
	 * canReflect.valueHasDependencies(jeek);  // -> false
	 * canReflect.valueHasDependencies(foo);  // -> undefined
	 * ```
	 *
	 * @param {Object} obj the object to check for dependencies
	 * @return {Boolean} `true` if there are other dependencies that may update the object's value; `false` otherwise
	 *
	 */
	valueHasDependencies: makeErrorIfMissing("can.valueHasDependencies","can-reflect: can not determine if value has dependencies"),

	// PATCHES
	/**
	 * @function {Object, function(*), String} can-reflect/observe.onPatches onPatches
	 * @parent can-reflect/observe
	 * @description  Register an handler on an observable that listens to any key changes
	 *
	 * @signature `onPatches(obj, handler, [queueName])`
	 *
	 * Register an event handler on the object `obj` that fires when anything changes on an object: a key value is added,
	 * an existing key has is value changed, or a key is deleted from the object.
	 *
	 * If object is an array-like and the changed property includes numeric indexes, patch sets will include array-specific
	 * patches in addition to object-style patches
	 *
	 * For more on the patch formats, see [can-util/js/diff-object/diff-object] and [can-util/js/diff-array/diff-array].
	 *
	 * ```
	 * var obj = new DefineMap({});
	 * var handler = function(patches) {
	 * 	console.log(patches);
	 * };
	 *
	 * canReflect.onPatches(obj, handler);
	 * obj.set("foo", "bar");  // logs [{ type: "add", property: "foo", value: "bar" }]
	 * obj.set("foo", "baz");  // logs [{ type: "set", property: "foo", value: "baz" }]
	 *
	 * var arr = new DefineList([]);
	 * canReflect.onPatches(arr, handler);
	 * arr.push("foo");  // logs [{type: "add", property:"0", value: "foo"},
	 *                            {index: 0, deleteCount: 0, insert: ["foo"]}]
   * arr.pop();  // logs [{type: "remove", property:"0"},
	 *                            {index: 0, deleteCount: 1, insert: []}]
	 * ```
	 *
	 * @param {*} obj
	 * @param {function(*)} handler
	 * @param {String} [queueName] the name of a queue in [can-queues]; dispatches to `handler` will happen on this queue
	 */
	onPatches: makeErrorIfMissing("can.onPatches", "can-reflect: can not observe patches on object"),
	/**
	 * @function {Object, function(*), String} can-reflect/observe.offPatches offPatches
	 * @parent can-reflect/observe
	 * @description  Unregister an object patches handler from an observable object
	 *
	 * @signature `offPatches(obj, handler, [queueName])`
	 *
	 * Unregister an event handler from the object `obj` that had previously been registered with
	 * [can-reflect/observe.onPatches onPatches]. The function passed as `handler` will no longer be called
	 * when `obj` has key or index changes.
	 *
	 * ```
	 * var obj = new DefineMap({});
	 * var handler = function(patches) {
	 * 	console.log(patches);
	 * };
	 *
	 * canReflect.onPatches(obj, handler);
	 * canReflect.offPatches(obj, handler);
	 *
	 * obj.set("foo", "bar");  // nothing is logged
	 * ```
	 *
	 * @param {*} obj
	 * @param {function(*)} handler
	 * @param {String} [queueName] the name of the queue in [can-queues] the handler was registered under
	 */
	offPatches: makeErrorIfMissing("can.offPatches", "can-reflect: can not unobserve patches on object"),

	/**
	 * @function {Object, function(*)} can-reflect/observe.onInstancePatches onInstancePatches
	 * @parent can-reflect/observe
	 *
	 * @description Registers a handler that listens to patch events on any instance
	 *
	 * @signature `onInstancePatches(Type, handler(instance, patches))`
	 *
	 * Listens to patch changes on any instance of `Type`. This is used by [can-connect]
	 * to know when a potentially `unbound` instance's `id` changes. If the `id` changes,
	 * the instance can be moved into the store while it is being saved. E.g:
	 *
	 * ```js
	 * canReflect.onInstancePatches(Map, function onInstancePatches(instance, patches) {
	 *	patches.forEach(function(patch) {
	 *		if (
	 *			(patch.type === "add" || patch.type === "set") &&
	 *			patch.key === connection.idProp &&
	 *			canReflect.isBound(instance)
	 *		) {
	 *			connection.addInstanceReference(instance);
	 *		}
	 *	});
	 *});
	 * ```
	 *
	 * @param {*} Type
	 * @param {function(*)} handler
	 */
	onInstancePatches: makeErrorIfMissing(
		"can.onInstancePatches",
		"can-reflect: can not observe onInstancePatches on Type"
	),

	/**
	 * @function {Object, function(*)} can-reflect/observe.offInstancePatches offInstancePatches
	 * @parent can-reflect/observe
	 *
	 * @description Unregisters a handler registered through [can-reflect/observe.onInstancePatches]
	 *
	 * @signature `offInstancePatches(Type, handler(instance, patches))`
	 *
	 * ```js
	 * canReflect.offInstancePatches(Map, onInstancePatches);
	 * ```
	 *
	 * @param {*} Type
	 * @param {function(*)} handler
	 */
	offInstancePatches: makeErrorIfMissing(
		"can.offInstancePatches",
		"can-reflect: can not unobserve onInstancePatches on Type"
	),

	// HAS BINDINGS VS DOES NOT HAVE BINDINGS
	/**
	 * @function {Object, function(*), String} can-reflect/observe.onInstanceBoundChange onInstanceBoundChange
	 * @parent can-reflect/observe
	 * @description Listen to when observables of a type are bound and unbound.
	 *
	 * @signature `onInstanceBoundChange(Type, handler, [queueName])`
	 *
	 * Register an event handler on the object `Type` that fires when instances of the type become bound (the first handler is added)
	 * or unbound (the last remaining handler is removed). The function passed as `handler` will be called
	 * with the `instance` as the first argument and `true` as the second argument when `instance` gains its first binding,
	 * and called with `false` when `instance` loses its
	 * last binding.
	 *
	 * ```
	 * Person = DefineMap.extend({ ... });
	 *
	 * var person = Person({});
	 * var handler = function(instance, newVal) {
	 * 	console.log(instance, "bound state is now", newVal);
	 * };
	 * var keyHandler = function() {};
	 *
	 * canReflect.onInstanceBoundChange(Person, handler);
	 * canReflect.onKeyValue(obj, "name", keyHandler);  // logs person Bound state is now true
	 * canReflect.offKeyValue(obj, "name", keyHandler);  // logs person Bound state is now false
	 * ```
	 *
	 * @param {function} Type A constructor function
	 * @param {function(*,Boolean)} handler(instance,isBound) A function called with the `instance` whose bound status changed and the state of the bound status.
	 * @param {String} [queueName] the name of a queue in [can-queues]; dispatches to `handler` will happen on this queue
	 */
	onInstanceBoundChange: makeErrorIfMissing("can.onInstanceBoundChange", "can-reflect: can not observe bound state change in instances."),
	/**
	 * @function {Object, function(*), String} can-reflect/observe.offInstanceBoundChange offInstanceBoundChange
	 * @parent can-reflect/observe
	 * @description Stop listening to when observables of a type are bound and unbound.
	 *
	 * @signature `offInstanceBoundChange(Type, handler, [queueName])`
	 *
	 * Unregister an event handler from the type `Type` that had previously been registered with
	 * [can-reflect/observe.onInstanceBoundChange onInstanceBoundChange]. The function passed as `handler` will no longer be called
	 * when instances of `Type` gains its first or loses its last binding.
	 *
	 * ```
	 * Person = DefineMap.extend({ ... });
	 *
	 * var person = Person({});
	 * var handler = function(instance, newVal) {
	 * 	console.log(instance, "bound state is now", newVal);
	 * };
	 * var keyHandler = function() {};
	 *
	 * canReflect.onInstanceBoundChange(Person, handler);
	 * canReflect.offInstanceBoundChange(Person, handler);
	 * canReflect.onKeyValue(obj, "name", keyHandler);  // nothing is logged
	 * canReflect.offKeyValue(obj, "name", keyHandler); // nothing is logged
	 * ```
	 *
	 * @param {function} Type A constructor function
	 * @param {function(*,Boolean)} handler(instance,isBound) The `handler` passed to `canReflect.onInstanceBoundChange`.
	 * @param {String} [queueName] the name of the queue in [can-queues] the handler was registered under
	 */
	offInstanceBoundChange: makeErrorIfMissing("can.offInstanceBoundChange", "can-reflect: can not unobserve bound state change"),
	/**
	 * @function {Object} can-reflect/observe.isBound isBound
	 * @parent can-reflect/observe
	 * @description  Determine whether any listeners are bound to the observable object
	 *
	 * @signature `isBound(obj)`
	 *
	 * `isBound` queries an observable object to find out whether any listeners have been set on it using
	 * [can-reflect/observe.onKeyValue onKeyValue] or [can-reflect/observe.onValue onValue]
	 *
	 * ```
	 * var obj = new DefineMap({});
	 * var handler = function() {};
	 * canReflect.isBound(obj); // -> false
	 * canReflect.onKeyValue(obj, "foo", handler);
	 * canReflect.isBound(obj); // -> true
	 * canReflect.offKeyValue(obj, "foo", handler);
	 * canReflect.isBound(obj); // -> false
	 * ```
	 *
	 * @param {*} obj
	 * @return {Boolean} `true` if obj has at least one key-value or value listener, `false` otherwise
	 */
	isBound: makeErrorIfMissing("can.isBound", "can-reflect: cannot determine if object is bound"),

	// EVENT
	/**
	 * @function {Object, String, function(*)} can-reflect/observe.onEvent onEvent
	 * @parent can-reflect/observe
	 * @description  Register a named event handler on an observable object
	 *
	 * @signature `onEvent(obj, eventName, callback)`
	 *
	 *
	 * Register an event handler on the object `obj` to trigger when the event `eventName` is dispatched.
	 * `obj` *must* implement [can-symbol/symbols/onKeyValue @@@@can.onEvent] or `.addEventListener()` to be compatible
	 * with can-reflect.onKeyValue.  The function passed as `callback` will receive the event descriptor as the first
	 * argument, and any data passed to the event dispatch as subsequent arguments.
	 *
	 * ```
	 * var obj = new DefineMap({ foo: "bar" });
	 * canReflect.onEvent(obj, "foo", function(ev, newVal, oldVal) {
	 * 	console.log("foo is now", newVal, ", was", oldVal);
	 * });
	 *
	 * canEvent.dispatch.call(obj, "foo", ["baz", "quux"]);  // -> logs "foo is now baz , was quux"
	 * ```
	 *
	 * @param {Object} obj the object to bind a new event handler to
	 * @param {String} eventName the name of the event to bind the handler to
	 * @param {function(*)} callback  the handler function to bind to the event
	 */
	onEvent: function(obj, eventName, callback, queue){
		if(obj) {
			var onEvent = obj[canSymbol_1_6_1_canSymbol.for("can.onEvent")];
			if(onEvent !== undefined) {
				return onEvent.call(obj, eventName, callback, queue);
			} else if(obj.addEventListener) {
				obj.addEventListener(eventName, callback, queue);
			}
		}
	},
	/**
	 * @function {Object, String, function(*)} can-reflect/observe.offValue offEvent
	 * @parent can-reflect/observe
	 * @description  Unregister an event handler on a MapLike object, based on a key change
	 *
	 * @signature `offEvent(obj, eventName, callback)`
	 *
	 * Unregister an event handler from the object `obj` that had previously been registered with
	 * [can-reflect/observe.onEvent onEvent]. The function passed as `callback` will no longer be called
	 * when the event named `eventName` is dispatched on `obj`.
	 *
	 * ```js
	 * var obj = new DefineMap({ foo: "bar" });
	 * var handler = function(ev, newVal, oldVal) {
	 * 	console.log("foo is now", newVal, ", was", oldVal);
	 * };
	 *
	 * canReflect.onEvent(obj, "foo", handler);
	 * canReflect.offEvent(obj, "foo", handler);
	 *
	 * canEvent.dispatch.call(obj, "foo", ["baz", "quux"]);  // -> nothing is logged
	 * ```
	 *
	 * @param {Object} obj the object to unbind an event handler from
	 * @param {String} eventName the name of the event to unbind the handler from
	 * @param {function(*)} callback the handler function to unbind from the event
	 */
	offEvent: function(obj, eventName, callback, queue){
		if(obj) {
			var offEvent = obj[canSymbol_1_6_1_canSymbol.for("can.offEvent")];
			if(offEvent !== undefined) {
				return offEvent.call(obj, eventName, callback, queue);
			}  else if(obj.removeEventListener) {
				obj.removeEventListener(eventName, callback, queue);
			}
		}

	},
	/**
	 * @function {function} can-reflect/setPriority setPriority
	 * @parent can-reflect/observe
	 * @description  Provide a priority for when an observable that derives its
	 * value should be re-evaluated.
	 *
	 * @signature `setPriority(obj, priority)`
	 *
	 * Calls an underlying `@@can.setPriority` symbol on `obj` if it exists with `priorty`.
	 * Returns `true` if a priority was set, `false` if otherwise.
	 *
	 * Lower priorities (`0` being the lowest), will be an indication to run earlier than
	 * higher priorities.
	 *
	 * ```js
	 * var obj = canReflect.assignSymbols({},{
	 *   "can.setPriority": function(priority){
	 *     return this.priority = priority;
	 *   }
	 * });
	 *
	 * canReflect.setPriority(obj, 0) //-> true
	 * obj.priority //-> 0
	 *
	 * canReflect.setPriority({},20) //-> false
	 * ```
	 *
	 * @param {Object} obj An observable that will update its priority.
	 * @param {Number} priority The priority number.  Lower priorities (`0` being the lowest),
	 * indicate to run earlier than higher priorities.
	 * @return {Boolean} `true` if a priority was able to be set, `false` if otherwise.
	 *
	 * @body
	 *
	 * ## Use
	 *
	 * There's often a need to specify the order of re-evaluation for
	 * __observables__ that derive (or compute) their value from other observables.
	 *
	 * This is needed by templates to avoid unnecessary re-evaluation.  Say we had the following template:
	 *
	 * ```js
	 * {{#if value}}
	 *   {{value}}
	 * {{/if}}
	 * ```
	 *
	 * If `value` became falsey, we'd want the `{{#if}}` to be aware of it before
	 * the `{{value}}` magic tags updated. We can do that by setting priorities:
	 *
	 * ```js
	 * canReflect.setPriority(magicIfObservable, 0);
	 * canReflect.setPriority(magicValueObservable,1);
	 * ```
	 *
	 * Internally, those observables will use that `priority` to register their
	 * re-evaluation with the `derive` queue in [can-queues].
	 *
	 */
	setPriority: function(obj, priority) {
		if(obj) {
			var setPriority =  obj[canSymbol_1_6_1_canSymbol.for("can.setPriority")];
			if(setPriority !== undefined) {
				setPriority.call(obj, priority);
			 	return true;
			}
		}
		return false;
	},
	/**
	 * @function {function} can-reflect/getPriority getPriority
	 * @parent can-reflect/observe
	 * @description  Read the priority for an observable that derives its
	 * value.
	 *
	 * @signature `getPriority(obj)`
	 *
	 * Calls an underlying `@@can.getPriority` symbol on `obj` if it exists
	 * and returns its value. Read [can-reflect/setPriority] for more information.
	 *
	 *
	 *
	 * @param {Object} obj An observable.
	 * @return {Undefined|Number} Returns the priority number if
	 * available, undefined if this object does not support the `can.getPriority`
	 * symbol.
	 *
	 * @body
	 *
	 */
	getPriority: function(obj) {
		if(obj) {
			var getPriority =  obj[canSymbol_1_6_1_canSymbol.for("can.getPriority")];
			if(getPriority !== undefined) {
				return getPriority.call(obj);
			}
		}
		return undefined;
	}
};

// IE-remove-start
var getPrototypeOfWorksWithPrimitives = true;
try {
} catch(e) {
	getPrototypeOfWorksWithPrimitives = false;
}
// IE-remove-end

var ArrayMap;
if(typeof Map === "function") {
	ArrayMap = Map;
} else {
	// IE-remove-start
	function isEven(num) {
		return !(num % 2);
	}

	// A simple map that stores items in an array.
	// like [key, value]
	// You can find the value by searching for the key and then +1.
	ArrayMap = function(){
		this.contents = [];
	};

	ArrayMap.prototype = {
		/**
		 * Get an index of a key. Because we store boths keys and values in
		 * a flat array, we ensure we are getting a key by checking that it is an
		 * even number index (all keys are even number indexed).
		 **/
		_getIndex: function(key) {
			var idx;
			do {
				idx = this.contents.indexOf(key, idx);
			} while(idx !== -1 && !isEven(idx));
			return idx;
		},
		has: function(key){
			return this._getIndex(key) !== -1;
		},
		get: function(key){
			var idx = this._getIndex(key);
			if(idx !== -1) {
				return this.contents[idx + 1];
			}
		},
		set: function(key, value){
			var idx = this._getIndex(key);
			if(idx !== -1) {
				// Key already exists, replace the value.
				this.contents[idx + 1] = value;
			} else {
				this.contents.push(key);
				this.contents.push(value);
			}
		},
		"delete": function(key){
			var idx = this._getIndex(key);
			if(idx !== -1) {
				// Key already exists, replace the value.
				this.contents.splice(idx, 2);
			}
		}
	};
	// IE-remove-end
}

var shapeReflections;

var shiftFirstArgumentToThis = function(func){
	return function(){
		var args = [this];
		args.push.apply(args, arguments);
		return func.apply(null,args);
	};
};

var getKeyValueSymbol$1 = canSymbol_1_6_1_canSymbol.for("can.getKeyValue");
var shiftedGetKeyValue = shiftFirstArgumentToThis(getSet.getKeyValue);
var setKeyValueSymbol$1 = canSymbol_1_6_1_canSymbol.for("can.setKeyValue");
var shiftedSetKeyValue = shiftFirstArgumentToThis(getSet.setKeyValue);

var sizeSymbol = canSymbol_1_6_1_canSymbol.for("can.size");

var hasUpdateSymbol = helpers.makeGetFirstSymbolValue(["can.updateDeep","can.assignDeep","can.setKeyValue"]);
var shouldUpdateOrAssign = function(obj){
	return type.isPlainObject(obj) || Array.isArray(obj) || !!hasUpdateSymbol(obj);
};

// is the value itself its serialized value
function isSerializedHelper(obj){
	if (type.isPrimitive(obj)) {
		return true;
	}
	if(hasUpdateSymbol(obj)) {
		return false;
	}
	return type.isBuiltIn(obj) && !type.isPlainObject(obj) && !Array.isArray(obj);
}

// IE11 doesn't support primitives
var Object_Keys;
try{
	Object_Keys = Object.keys;
} catch(e) {
	Object_Keys = function(obj){
		if(type.isPrimitive(obj)) {
			return [];
		} else {
			return Object.keys(obj);
		}
	};
}

function makeSerializer(methodName, symbolsToCheck){
	// A local variable that is shared with all operations that occur withing a single
	// outer call to serialize()
	var serializeMap = null;

	// Holds the value of running serialize(), preserving the same map for all
	// internal instances.
	function SerializeOperation(MapType) {
		this.first = !serializeMap;

		if(this.first) {
			serializeMap = createSerializeMap(MapType);
		}

		this.map = serializeMap;
		this.result = null;
	}

	SerializeOperation.prototype.end = function(){
		// If this is the first, outer call, clean up the serializeMap.
		if(this.first) {
			serializeMap = null;
		}
		return this.result;
	};

	function createSerializeMap(Type) {
		var MapType = Type || ArrayMap;
		return {
			unwrap: new MapType(),
			serialize: new MapType() ,
			isSerializing: {
				unwrap: new MapType(),
				serialize: new MapType()
			},
			circularReferenceIsSerializing: {
				unwrap: new MapType(),
				serialize: new MapType()
			}
		};
	}

	return function serializer(value, MapType){
		if (isSerializedHelper(value)) {
			return value;
		}

		var operation = new SerializeOperation(MapType);

		if(type.isValueLike(value)) {
			operation.result = this[methodName](getSet.getValue(value));

		} else {
			// Date, RegEx and other Built-ins are handled above
			// only want to do something if it's intended to be serialized
			// or do nothing for a POJO

			var isListLike = type.isIteratorLike(value) || type.isMoreListLikeThanMapLike(value);
			operation.result = isListLike ? [] : {};

			// handle maping to what is serialized
			if( operation.map[methodName].has(value) ) {
				// if we are in the process of serializing the first time, setup circular reference detection.
				if(operation.map.isSerializing[methodName].has(value)) {
					operation.map.circularReferenceIsSerializing[methodName].set(value, true);
				}
				return operation.map[methodName].get(value);
			} else {
				operation.map[methodName].set(value, operation.result);
			}

			for(var i = 0, len = symbolsToCheck.length ; i< len;i++) {
				var serializer = value[symbolsToCheck[i]];
				if(serializer) {
					// mark that we are serializing
					operation.map.isSerializing[methodName].set(value, true);
					var oldResult = operation.result;
					operation.result = serializer.call(value, oldResult);
					operation.map.isSerializing[methodName].delete(value);

					// if the result differs, but this was circular, blow up.
					if(operation.result !== oldResult) {
						// jshint -W073
						if(operation.map.circularReferenceIsSerializing[methodName].has(value)) {
							// Circular references should use a custom serializer
							// that sets the serialized value on the object
							// passed to it as the first argument e.g.
							// function(proto){
							//   return proto.a = canReflect.serialize(this.a);
							// }
							operation.end();
							throw new Error("Cannot serialize cirular reference!");
						}
						operation.map[methodName].set(value, operation.result);
					}
					return operation.end();
				}
			}

			if (typeof obj ==='function') {
				operation.map[methodName].set(value, value);

				operation.result = value;
			} else if( isListLike ) {
				this.eachIndex(value,function(childValue, index){
					operation.result[index] = this[methodName](childValue);
				},this);
			} else {
				this.eachKey(value,function(childValue, prop){
					operation.result[prop] = this[methodName](childValue);
				},this);
			}
		}

		return operation.end();
	};
}

// returns a Map type of the keys mapped to true
var makeMap;
if(typeof Map !== "undefined") {
	makeMap = function(keys) {
		var map = new Map();
		shapeReflections.eachIndex(keys, function(key){
			map.set(key, true);
		});
		return map;
	};
} else {
	makeMap = function(keys) {
		var map = {};
		keys.forEach(function(key){
			map[key] = true;
		});

		return {
			get: function(key){
				return map[key];
			},
			set: function(key, value) {
				map[key] = value;
			},
			keys: function(){
				return keys;
			}
		};
	};
}

// creates an optimized hasOwnKey lookup.
// If the object has hasOwnKey, then we just use that.
// Otherwise, try to put all keys in a map.
var fastHasOwnKey = function(obj){
	var hasOwnKey = obj[canSymbol_1_6_1_canSymbol.for("can.hasOwnKey")];
	if(hasOwnKey) {
		return hasOwnKey.bind(obj);
	} else {
		var map = makeMap( shapeReflections.getOwnEnumerableKeys(obj) );
		return function(key) {
			return map.get(key);
		};
	}
};


// combines patches if it makes sense
function addPatch(patches, patch) {
	var lastPatch = patches[patches.length -1];
	if(lastPatch) {
		// same number of deletes and counts as the index is back
		if(lastPatch.deleteCount === lastPatch.insert.length && (patch.index - lastPatch.index === lastPatch.deleteCount) ) {
			lastPatch.insert.push.apply(lastPatch.insert, patch.insert);
			lastPatch.deleteCount += patch.deleteCount;
			return;
		}
	}
	patches.push(patch);
}

function updateDeepList(target, source, isAssign) {
	var sourceArray = this.toArray(source);

	var patches = [],
		lastIndex = -1;
	this.eachIndex(target, function(curVal, index){
		lastIndex = index;
		// If target has more items than the source.
		if(index >= sourceArray.length) {
			if(!isAssign) {
				// add a patch that removes the last items
				addPatch(patches, {index: index, deleteCount: target.length - index + 1, insert: []});
			}
			return false;
		}
		var newVal = sourceArray[index];
		if( type.isPrimitive(curVal) || type.isPrimitive(newVal) || shouldUpdateOrAssign(curVal) === false ) {
			addPatch(patches, {index: index, deleteCount: 1, insert: [newVal]});
		} else {
			this.updateDeep(curVal, newVal);
		}
	}, this);
	// add items at the end
	if(sourceArray.length > lastIndex) {
		addPatch(patches, {index: lastIndex+1, deleteCount: 0, insert: sourceArray.slice(lastIndex+1)});
	}
	for(var i = 0, patchLen = patches.length; i < patchLen; i++) {
		var patch = patches[i];
		getSet.splice(target, patch.index, patch.deleteCount, patch.insert);
	}
	return target;
}

shapeReflections = {
	/**
	 * @function {Object, function(*), [Object]} can-reflect.each each
	 * @parent can-reflect/shape
	 * @description  Iterate a List-like or Map-like, calling `callback` on each keyed or indexed property
	 *
	 * @signature `each(obj, callback, context)`
	 *
	 * If `obj` is a List-like or an Iterator-like, `each` functions as [can-reflect.eachIndex eachIndex],
	 * iterating over numeric indexes from 0 to `obj.length - 1` and calling `callback` with each property and
	 * index, optionally with `context` as `this` (defaulting to `obj`).  If not, `each` functions as
	 * [can-reflect.eachKey eachKey],
	 * iterating over every key on `obj` and calling `callback` on each one.
	 *
	 * ```
	 * var foo = new DefineMap({ bar: "baz" });
	 * var quux = new DefineList([ "thud", "jeek" ]);
	 *
	 * canReflect.each(foo, console.log, console); // -> logs 'baz bar {foo}'
	 * canReflect.each(quux, console.log, console); // -> logs 'thud 0 {quux}'; logs 'jeek 1 {quux}'
	 * ```
	 *
	 * @param  {Object}   obj     The object to iterate over
	 * @param  {Function(*, ValueLike)} callback a function that receives each item in the ListLike or MapLike
	 * @param  {[Object]}   context  an optional `this` context for calling the callback
	 * @return {Array} the result of calling [can-reflect.eachIndex `eachIndex`] if `obj` is a ListLike,
	 * or [can-reflect.eachKey `eachKey`] if a MapLike.
	 */
	each: function(obj, callback, context){

		// if something is more "list like" .. use eachIndex
		if(type.isIteratorLike(obj) || type.isMoreListLikeThanMapLike(obj) ) {
			return shapeReflections.eachIndex(obj,callback,context);
		} else {
			return shapeReflections.eachKey(obj,callback,context);
		}
	},

	/**
	 * @function {ListLike, function(*), [Object]} can-reflect.eachIndex eachIndex
	 * @parent can-reflect/shape
	 * @description  Iterate a ListLike calling `callback` on each numerically indexed element
	 *
	 * @signature `eachIndex(list, callback, context)`
	 *
	 * For each numeric index from 0 to `list.length - 1`, call `callback`, passing the current
	 * property value, the current index, and `list`, and optionally setting `this` as `context`
	 * if specified (otherwise use the current property value).
	 *
	 * ```
	 * var foo = new DefineList([ "bar", "baz" ]);
	 *
	 * canReflect.eachIndex(foo, console.log, console); // -> logs 'bar 0 {foo}'; logs 'baz 1 {foo}'
	 * ```
	 *
	 * @param  {ListLike}   list     The list to iterate over
	 * @param  {Function(*, Number)} callback a function that receives each item
	 * @param  {[Object]}   context  an optional `this` context for calling the callback
	 * @return {ListLike}   the original list
	 */
	eachIndex: function(list, callback, context){
		// each index in something list-like. Uses iterator if it has it.
		if(Array.isArray(list)) {
			return shapeReflections.eachListLike(list, callback, context);
		} else {
			var iter, iterator = list[canSymbol_1_6_1_canSymbol.iterator];
			if(type.isIteratorLike(list)) {
				// we are looping through an iterator
				iter = list;
			} else if(iterator) {
				iter = iterator.call(list);
			}
			// fast-path arrays
			if(iter) {
				var res, index = 0;

				while(!(res = iter.next()).done) {
					if( callback.call(context || list, res.value, index++, list) === false ){
						break;
					}
				}
			} else {
				shapeReflections.eachListLike(list, callback, context);
			}
		}
		return list;
	},
	eachListLike: function(list, callback, context){
		var index = -1;
		var length = list.length;
		if( length === undefined ) {
			var size = list[sizeSymbol];
			if(size) {
				length = size.call(list);
			} else {
				throw new Error("can-reflect: unable to iterate.");
			}
		}

		while (++index < length) {
			var item = list[index];
			if (callback.call(context || item, item, index, list) === false) {
				break;
			}
		}

		return list;
	},
	/**
	 * @function can-reflect.toArray toArray
	 * @parent can-reflect/shape
	 * @description  convert the values of any MapLike or ListLike into an array
	 *
	 * @signature `toArray(obj)`
	 *
	 * Convert the values of any Map-like or List-like into a JavaScript Array.  If a Map-like,
	 * key data is discarded and only value data is preserved.
	 *
	 * ```
	 * var foo = new DefineList(["bar", "baz"]);
	 * var quux = new DefineMap({ thud: "jeek" });
	 * ```
	 *
	 * canReflect.toArray(foo); // -> ["bar", "baz"]
	 * canReflect.toArray(quux): // -> ["jeek"]
	 *
	 * @param  {Object} obj Any object, whether MapLike or ListLike
	 * @return {Array}  an array of the values of `obj`
	 */
	toArray: function(obj){
		var arr = [];
		shapeReflections.each(obj, function(value){
			arr.push(value);
		});
		return arr;
	},
	/**
	 * @function can-reflect.eachKey eachKey
	 * @parent can-reflect/shape
	 * @description Iterate over a MapLike, calling `callback` on each enumerable property
	 *
	 * @signature `eachKey(obj, callback, context)`
	 *
	 * Iterate all own enumerable properties on Map-like `obj`
	 * (using [can-reflect/shape/getOwnEnumerableKeys canReflect.getOwnEnumerableKeys]), and call
	 * `callback` with the property value, the property key, and `obj`, and optionally setting
	 * `this` on the callback as `context` if provided, `obj` otherwise.
	 *
	 * ```
	 * var foo = new DefineMap({ bar: "baz" });
	 *
	 * canReflect.eachKey(foo, console.log, console); // logs 'baz bar {foo}'
	 * ```
	 *
	 * @param  {Object}   obj   The object to iterate over
	 * @param  {Function(*, String)} callback The callback to call on each enumerable property value
	 * @param  {[Object]}   context  an optional `this` context for calling `callback`
	 * @return {Array}    the enumerable keys of `obj` as an Array
	 */
	eachKey: function(obj, callback, context){
		// each key in something map like
		// eachOwnEnumerableKey
		if(obj) {
			var enumerableKeys = shapeReflections.getOwnEnumerableKeys(obj);

			// cache getKeyValue method if we can
			var getKeyValue = obj[getKeyValueSymbol$1] || shiftedGetKeyValue;

			return shapeReflections.eachIndex(enumerableKeys, function(key){
				var value = getKeyValue.call(obj, key);
				return callback.call(context || obj, value, key, obj);
			});
		}
		return obj;
	},
	/**
	 * @function can-reflect.hasOwnKey hasOwnKey
	 * @parent can-reflect/shape
	 * @description  Determine whether an object contains a key on itself, not only on its prototype chain
	 *
	 * @signature `hasOwnKey(obj, key)`
	 *
	 * Return `true` if an object's own properties include the property key `key`, `false` otherwise.
	 * An object may implement [can-symbol/symbols/hasOwnKey @@@@can.hasOwnKey] to override default behavior.
	 * By default, `canReflect.hasOwnKey` will first look for
	 * [can-symbol/symbols/getOwnKey @@@@can.getOwnKey] on `obj`. If present, it will call `@@@@can.getOwnKey` and
	 * test `key` against the returned Array of keys.  If absent, `Object.prototype.hasOwnKey()` is used.
	 *
	 * ```
	 * var foo = new DefineMap({ "bar": "baz" });
	 *
	 * canReflect.hasOwnKey(foo, "bar"); // -> true
	 * canReflect.hasOwnKey(foo, "each"); // -> false
	 * foo.each // -> function each() {...}
	 * ```
	 *
	 * @param  {Object} obj Any MapLike object
	 * @param  {String} key The key to look up on `obj`
	 * @return {Boolean} `true` if `obj`'s key set contains `key`, `false` otherwise
	 */
	"hasOwnKey": function(obj, key){
		// if a key or index
		// like has own property
		var hasOwnKey = obj[canSymbol_1_6_1_canSymbol.for("can.hasOwnKey")];
		if(hasOwnKey) {
			return hasOwnKey.call(obj, key);
		}
		var getOwnKeys = obj[canSymbol_1_6_1_canSymbol.for("can.getOwnKeys")];
		if( getOwnKeys ) {
			var found = false;
			shapeReflections.eachIndex(getOwnKeys.call(obj), function(objKey){
				if(objKey === key) {
					found = true;
					return false;
				}
			});
			return found;
		}
		return obj.hasOwnProperty(key);
	},
	/**
	 * @function can-reflect.getOwnEnumerableKeys getOwnEnumerableKeys
	 * @parent can-reflect/shape
	 * @description Return the list of keys which can be iterated over on an object
	 *
	 * @signature `getOwnEnumerableKeys(obj)`
	 *
	 * Return all keys on `obj` which have been defined as enumerable, either from explicitly setting
	 * `enumerable` on the property descriptor, or by using `=` to set the value of the property without
	 * a key descriptor, but excluding properties that only exist on `obj`'s prototype chain.  The
	 * default behavior can be overridden by implementing
	 * [can-symbol/symbols/getOwnEnumerableKeys @@@@can.getOwnEnumerableKeys] on `obj`.  By default,
	 * `canReflect.getOwnEnumerableKeys` will use [can-symbol/symbols/getOwnKeys @@@@can.getOwnKeys] to
	 * retrieve the set of keys and [can-symbol/symbols/getOwnKeyDescriptor @@@@can.getOwnKeyDescriptor]
	 * to filter for those which are enumerable.  If either symbol is absent from `obj`, `Object.keys`
	 * is used.
	 *
	 * ```
	 * var foo = new DefineMap({ bar: "baz", [canSymbol.for("quux")]: "thud" });
	 * Object.defineProperty(foo, "jeek", {
	 *   enumerable: true,
	 *   value: "plonk"
	 * });
	 *
	 * canReflect.getOwnEnumerableKeys(foo); // -> ["bar", "jeek"]
	 * ```
	 *
	 * @param  {Object} obj Any Map-like object
	 * @return {Array} the Array of all enumerable keys from the object, either using
	 * [can-symbol/symbols/getOwnEnumerableKeys `@@@@can.getOwnEnumerableKeys`] from `obj`, or filtering
	 * `obj`'s own keys for those which are enumerable.
	 */
	getOwnEnumerableKeys: function(obj){
		// own enumerable keys (aliased as keys)
		var getOwnEnumerableKeys = obj[canSymbol_1_6_1_canSymbol.for("can.getOwnEnumerableKeys")];
		if(getOwnEnumerableKeys) {
			return getOwnEnumerableKeys.call(obj);
		}
		if( obj[canSymbol_1_6_1_canSymbol.for("can.getOwnKeys")] && obj[canSymbol_1_6_1_canSymbol.for("can.getOwnKeyDescriptor")] ) {
			var keys = [];
			shapeReflections.eachIndex(shapeReflections.getOwnKeys(obj), function(key){
				var descriptor =  shapeReflections.getOwnKeyDescriptor(obj, key);
				if(descriptor.enumerable) {
					keys.push(key);
				}
			}, this);

			return keys;
		} /*else if(obj[canSymbol.iterator]){
			var iter = obj[canSymbol.iterator](obj);
			var index = 0;
			var keys;
			return {
				next: function(){
					var res = iter.next();
					if(index++)
				}
			}
			while(!().done) {

				if( callback.call(context || list, res.value, index++, list) === false ){
					break;
				}
			}
		}*/ else {
			return Object_Keys(obj);
		}
	},
	/**
	 * @function can-reflect.getOwnKeys getOwnKeys
	 * @parent can-reflect/shape
	 * @description Return the list of keys on an object, whether or not they can be iterated over
	 *
	 * @signature `getOwnKeys(obj)`
	 *
	 * Return the Array of all String (not Symbol) keys from `obj`, whether they are enumerable or not.  If
	 * [can-symbol/symbols/getOwnKeys @@@@can.getOwnKeys] exists on `obj`, it is called to return
	 * the keys; otherwise, `Object.getOwnPropertyNames()` is used.
	 *
	 * ```
	 * var foo = new DefineMap({ bar: "baz", [canSymbol.for("quux")]: "thud" });
	 * Object.defineProperty(foo, "jeek", {
	 *   enumerable: false,
	 *   value: "plonk"
	 * });
	 *
	 * canReflect.getOwnKeys(foo); // -> ["bar", "jeek"]
	 * ```
	 *
	 * @param  {Object} obj Any MapLike object
	 * @return {Array} the Array of all String keys from the object.
	 */
	getOwnKeys: function(obj){
		// own enumerable&non-enumerable keys (Object.getOwnPropertyNames)
		var getOwnKeys = obj[canSymbol_1_6_1_canSymbol.for("can.getOwnKeys")];
		if(getOwnKeys) {
			return getOwnKeys.call(obj);
		} else {
			return Object.getOwnPropertyNames(obj);
		}
	},
	/**
	 * @function can-reflect.getOwnKeyDescriptor getOwnKeyDescriptor
	 * @parent can-reflect/shape
	 * @description Return a property descriptor for a named property on an object.
	 *
	 * @signature `getOwnKeyDescriptor(obj, key)`
	 *
	 *	Return the key descriptor for the property key `key` on the Map-like object `obj`. A key descriptor
	 *	is specified in ECMAScript 5 and contains keys for the property's `configurable` and `enumerable` states,
	 *	as well as either `value` and `writable` for value properties, or `get` and `set` for getter/setter properties.
	 *
	 * The default behavior can be overridden by implementing [can-symbol/symbols/getOwnKeyDescriptor @@@@can.getOwnKeyDescriptor]
	 * on `obj`; otherwise the default is to call `Object.getOwnKeyDescriptor()`.
	 *
	 * ```
	 * var foo = new DefineMap({ bar: "baz" });
	 *
	 * getOwnKeyDescriptor(foo, "bar"); // -> {configurable: true, writable: true, enumerable: true, value: "baz"}
	 * ```
	 *
	 * @param  {Object} obj Any object with named properties
	 * @param  {String} key The property name to look up on `obj`
	 * @return {Object}   A key descriptor object
	 */
	getOwnKeyDescriptor: function(obj, key){
		var getOwnKeyDescriptor = obj[canSymbol_1_6_1_canSymbol.for("can.getOwnKeyDescriptor")];
		if(getOwnKeyDescriptor) {
			return getOwnKeyDescriptor.call(obj, key);
		} else {
			return Object.getOwnPropertyDescriptor(obj, key);
		}
	},
	/**
	 * @function can-reflect.unwrap unwrap
	 * @parent can-reflect/shape
	 * @description Unwraps a map-like or array-like value into an object or array.
	 *
	 *
	 * @signature `unwrap(obj)`
	 *
	 * Recursively unwraps a map-like or list-like object.
	 *
	 * ```js
	 * import canReflect from "can-reflect";
	 *
	 * var map = new DefineMap({foo: "bar"});
	 * canReflect.unwrap(map) //-> {foo: "bar"}
	 * ```
	 *
	 * `unwrap` is similar to [can-reflect.serialize] except it does not try to provide `JSON.stringify()`-safe
	 * objects.  For example, an object with a `Date` instance property value will not be expected to
	 * serialize the date instance:
	 *
	 * ```js
	 * var date = new Date();
	 * var map = new DefineMap({date: date});
	 * canReflect.unwrap(map) //-> {date: date}
	 * ```
	 *
	 * @param {Object} obj A map-like or array-like object.
	 * @return {Object} Returns objects and arrays.
	 */
	unwrap: makeSerializer("unwrap",[canSymbol_1_6_1_canSymbol.for("can.unwrap")]),
	/**
	 * @function can-reflect.serialize serialize
	 * @parent can-reflect/shape
	 * @description Serializes an object to a value that can be passed to JSON.stringify.
	 *
	 *
	 * @signature `serialize(obj)`
	 *
	 * Recursively serializes a map-like or list-like object.
	 *
	 * ```js
	 * import canReflect from "can-reflect";
	 * canReflect.serialize({foo: "bar"}) //-> {foo: "bar"}
	 * ```
	 *
	 * It does this by recursively:
	 *
	 *  - Checking if `obj` is a primitive, if it is, returns the value.
	 *  - If `obj` is an object:
	 *    - calling the `@can.serialize` property on the value if it exists.
	 *    - If the `@can.serialize` value doesn't exist, walks through every key-value
	 *      on `obj` and copy to a new object.
	 *
	 * @param {Object} obj A map-like or array-like object.
	 * @return {Object} Returns a plain object or array.
	 */
	serialize: makeSerializer("serialize",[canSymbol_1_6_1_canSymbol.for("can.serialize"), canSymbol_1_6_1_canSymbol.for("can.unwrap")]),

	assignMap: function(target, source) {
		// read each key and set it on target
		var hasOwnKey = fastHasOwnKey(target);
		var getKeyValue = target[getKeyValueSymbol$1] || shiftedGetKeyValue;
		var setKeyValue = target[setKeyValueSymbol$1] || shiftedSetKeyValue;
		shapeReflections.eachKey(source,function(value, key){
			// if the target doesn't have this key or the keys are not the same
			if(!hasOwnKey(key) || getKeyValue.call(target, key) !==  value) {
				setKeyValue.call(target, key, value);
			}
		});
		return target;
	},
	assignList: function(target, source) {
		var inserting = shapeReflections.toArray(source);
		getSet.splice(target, 0, inserting, inserting );
		return target;
	},
	/**
	 * @function can-reflect.assign assign
	 * @parent can-reflect/shape
	 * @description Assign one objects values to another
	 *
	 * @signature `.assign(target, source)`
	 *
	 * Copies the values (and properties if map-like) from `source` onto `target`.
	 *
	 * For map-like objects, every enumerable property on `target` is copied:
	 *
	 * ```js
	 * var target = {};
	 * var source = {key : "value"};
	 * var restult = canReflect.assign(target, source);
	 * result === target //-> true
	 * target //-> {key : "value"}
	 * ```
	 *
	 * For Arrays, enumerated values are copied over, but the length of the array will not be
	 * trunkated.  Use [can-reflect.update] for trunkating.
	 *
	 * ```js
	 * var target = ["a","b","c"];
	 * var source = ["A","B"];
	 * canReflect.assign(target, source);
	 * target //-> ["A","B","c"]
	 * ```
	 *
	 * @param  {Object} target The value that will be updated with `source`'s values.
	 * @param  {Object} source A source of values to copy to `target`.
	 * @return {Object} The target.
	 */
	assign: function(target, source) {
		if(type.isIteratorLike(source) || type.isMoreListLikeThanMapLike(source) ) {
			// copy to array and add these keys in place
			shapeReflections.assignList(target, source);
		} else {
			shapeReflections.assignMap(target, source);
		}
		return target;
	},
	assignDeepMap: function(target, source) {

		var hasOwnKey = fastHasOwnKey(target);
		var getKeyValue = target[getKeyValueSymbol$1] || shiftedGetKeyValue;
		var setKeyValue = target[setKeyValueSymbol$1] || shiftedSetKeyValue;

		shapeReflections.eachKey(source, function(newVal, key){
			if(!hasOwnKey(key)) {
				// set no matter what
				getSet.setKeyValue(target, key, newVal);
			} else {
				var curVal = getKeyValue.call(target, key);

				// if either was primitive, no recursive update possible
				if(newVal === curVal) {
					// do nothing
				} else if(type.isPrimitive(curVal) || type.isPrimitive(newVal) || shouldUpdateOrAssign(curVal) === false ) {
					setKeyValue.call(target, key, newVal);
				} else {
					shapeReflections.assignDeep(curVal, newVal);
				}
			}
		}, this);
		return target;
	},
	assignDeepList: function(target, source) {
		return updateDeepList.call(this,target, source, true);
	},
	/**
	 * @function can-reflect.assignDeep assignDeep
	 * @parent can-reflect/shape
	 * @description Assign one objects values to another, and performs the same action for all child values.
	 *
	 * @signature `.assignDeep(target, source)`
	 *
	 * Copies the values (and properties if map-like) from `source` onto `target` and repeates for all child
	 * values.
	 *
	 * For map-like objects, every enumerable property on `target` is copied:
	 *
	 * ```js
	 * var target = {name: {first: "Justin"}};
	 * var source = {name: {last: "Meyer"}};
	 * var restult = canReflect.assignDeep(target, source);
	 * target //->  {name: {first: "Justin", last: "Meyer"}}
	 * ```
	 *
	 * An object can control the behavior of `assignDeep` using the [can-symbol/symbols/assignDeep] symbol.
	 *
	 * @param  {Object} target The value that will be updated with `source`'s values.
	 * @param  {Object} source A source of values to copy to `target`.
	 * @return {Object} The target.
	 */
	assignDeep: function(target, source){
		var assignDeep = target[canSymbol_1_6_1_canSymbol.for("can.assignDeep")];
		if(assignDeep) {
			assignDeep.call(target, source);
		} else if( type.isMoreListLikeThanMapLike(source) ) {
			// list-like
			shapeReflections.assignDeepList(target, source);
		} else {
			// map-like
			shapeReflections.assignDeepMap(target, source);
		}
		return target;
	},
	updateMap: function(target, source) {
		var sourceKeyMap = makeMap( shapeReflections.getOwnEnumerableKeys(source) );

		var sourceGetKeyValue = source[getKeyValueSymbol$1] || shiftedGetKeyValue;
		var targetSetKeyValue = target[setKeyValueSymbol$1] || shiftedSetKeyValue;

		shapeReflections.eachKey(target, function(curVal, key){
			if(!sourceKeyMap.get(key)) {
				getSet.deleteKeyValue(target, key);
				return;
			}
			sourceKeyMap.set(key, false);
			var newVal = sourceGetKeyValue.call(source, key);

			// if either was primitive, no recursive update possible
			if(newVal !== curVal) {
				targetSetKeyValue.call(target, key, newVal);
			}
		}, this);

		shapeReflections.eachIndex(sourceKeyMap.keys(), function(key){
			if(sourceKeyMap.get(key)) {
				targetSetKeyValue.call(target, key, sourceGetKeyValue.call(source, key) );
			}
		});

		return target;
	},
	updateList: function(target, source) {
		var inserting = shapeReflections.toArray(source);

		getSet.splice(target, 0, target, inserting );
		return target;
	},
	/**
	 * @function can-reflect.update update
	 * @parent can-reflect/shape
	 * @description Updates the values of an object match the values of an other object.
	 *
	 * @signature `.update(target, source)`
	 *
	 * Updates the values (and properties if map-like) of `target` to match the values of `source`. This does
	 * not recursively update.  For that, use [can-reflect.updateDeep].
	 *
	 * For map-like objects, every enumerable property on `target` is copied:
	 *
	 * ```js
	 * var target = {name: {first: "Justin"}, age: 34};
	 * var source = {name: {last: "Meyer"}};
	 * var restult = canReflect.assignDeep(target, source);
	 * target //->  {name: {last: "Meyer"}}
	 * ```
	 *
	 * With Arrays all items of the source will be replaced with the new items.
	 *
	 * ```js
	 * var target = ["a","b","c"];
	 * var source = ["A","B"];
	 * canReflect.assign(target, source);
	 * target //-> ["A","B"]
	 * ```
	 *
	 * @param  {Object} target The value that will be updated with `source`'s values.
	 * @param  {Object} source A source of values to copy to `target`.
	 * @return {Object} The target.
	 */
	update: function(target, source) {
		if(type.isIteratorLike(source) || type.isMoreListLikeThanMapLike(source) ) {
			// copy to array and add these keys in place
			shapeReflections.updateList(target, source);
		} else {
			shapeReflections.updateMap(target, source);
		}
		return target;
	},
	updateDeepMap: function(target, source) {
		var sourceKeyMap = makeMap( shapeReflections.getOwnEnumerableKeys(source) );

		var sourceGetKeyValue = source[getKeyValueSymbol$1] || shiftedGetKeyValue;
		var targetSetKeyValue = target[setKeyValueSymbol$1] || shiftedSetKeyValue;

		shapeReflections.eachKey(target, function(curVal, key){

			if(!sourceKeyMap.get(key)) {
				getSet.deleteKeyValue(target, key);
				return;
			}
			sourceKeyMap.set(key, false);
			var newVal = sourceGetKeyValue.call(source, key);

			// if either was primitive, no recursive update possible
			if(type.isPrimitive(curVal) || type.isPrimitive(newVal) || shouldUpdateOrAssign(curVal) === false ) {
				targetSetKeyValue.call(target, key, newVal);
			} else {
				shapeReflections.updateDeep(curVal, newVal);
			}

		}, this);

		shapeReflections.eachIndex(sourceKeyMap.keys(), function(key){
			if(sourceKeyMap.get(key)) {
				targetSetKeyValue.call(target, key, sourceGetKeyValue.call(source, key) );
			}
		});
		return target;
	},
	updateDeepList: function(target, source) {
		return updateDeepList.call(this,target, source);
	},
	/**
	 * @function can-reflect.updateDeep updateDeep
	 * @parent can-reflect/shape
	 * @description Makes the values of an object match the values of an other object including all children values.
	 *
	 * @signature `.updateDeep(target, source)`
	 *
	 * Updates the values (and properties if map-like) of `target` to match the values of `source`.
	 *
	 * For map-like objects, every enumerable property on `target` is copied:
	 *
	 * ```js
	 * var target = {name: {first: "Justin"}, age: 34};
	 * var source = {name: {last: "Meyer"}};
	 * var restult = canReflect.assignDeep(target, source);
	 * target //->  {name: {last: "Meyer"}}
	 * ```
	 *
	 * An object can control the behavior of `assignDeep` using the [can-symbol/symbols/updateDeep] symbol.
	 *
	 * For list-like objects, a diff and patch strategy is used.  This attempts to limit the number of changes.
	 *
	 * @param  {Object} target The value that will be updated with `source`'s values.
	 * @param  {Object} source A source of values to copy to `target`.
	 * @return {Object} The target.
	 */
	updateDeep: function(target, source){
		var updateDeep = target[canSymbol_1_6_1_canSymbol.for("can.updateDeep")];
		if(updateDeep) {
			updateDeep.call(target, source);
		} else if( type.isMoreListLikeThanMapLike(source) ) {
			// list-like
			shapeReflections.updateDeepList(target, source);
		} else {
			// map-like
			shapeReflections.updateDeepMap(target, source);
		}
		return target;
	},
	// walks up the whole prototype chain
	/**
	 * @function can-reflect.hasKey hasKey
	 * @parent can-reflect/shape
	 * @description Determine whether an object contains a key on itself or its prototype chain
	 *
	 * @signature `hasKey(obj, key)`
	 *
	 * Return `true` if an object's properties include the property key `key` or an object on its prototype
	 * chain's properties include the key `key`, `false` otherwise.
	 * An object may implement [can-symbol/symbols/hasKey @@@@can.hasKey] to override default behavior.
	 * By default, `canReflect.hasKey` will use [can-reflect.hasOwnKey] and return true if the key is present.
	 * If `hasOwnKey` returns false, the [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/in in Operator] will be used.
	 *
	 * ```
	 * var foo = new DefineMap({ "bar": "baz" });
	 *
	 * canReflect.in(foo, "bar"); // -> true
	 * canReflect.in(foo, "each"); // -> true
	 * foo.each // -> function each() {...}
	 * ```
	 *
	 * @param  {Object} obj Any MapLike object
	 * @param  {String} key The key to look up on `obj`
	 * @return {Boolean} `true` if `obj`'s key set contains `key` or an object on its prototype chain's key set contains `key`, `false` otherwise
	 */
	hasKey: function(obj, key) {
		if( obj == null ) {
			return false;
		}
		if (type.isPrimitive(obj)) {
			if (Object.prototype.hasOwnProperty.call(obj, key)) {
				return true;
			} else {
				var proto;
				if(getPrototypeOfWorksWithPrimitives) {
					proto = Object.getPrototypeOf(obj);
				} else {
					// IE-remove-start
					proto = obj.__proto__;
					// IE-remove-end
				}				if(proto !== undefined) {
					return key in proto;
				} else {
					// IE-remove-start
					return obj[key] !== undefined;
					// IE-remove-end
				}
			}
		}
		var hasKey = obj[canSymbol_1_6_1_canSymbol.for("can.hasKey")];
		if(hasKey) {
			return hasKey.call(obj, key);
		}

		var found = shapeReflections.hasOwnKey(obj, key);

		return found || key in obj;
	},
	getAllEnumerableKeys: function(){},
	getAllKeys: function(){},
	/**
	 * @function can-reflect.assignSymbols assignSymbols
	 * @parent can-reflect/shape
	 * @description Assign well known symbols and values to an object.
	 *
	 * @signature `.assignSymbols(target, source)`
	 *
	 * Converts each property name on the `source` object to a [can-symbol.for well known symbol]
	 * and uses that symbol to set the corresponding value on target.
	 *
	 * This is used to easily set symbols correctly even when symbol isn't natively supported.
	 *
	 * ```js
	 * canReflect.assignSymbols(Map.prototype, {
	 *   "can.getKeyValue": Map.prototype.get
	 * })
	 * ```
	 *
	 * If a `source` property name matches a symbol on `Symbol` (like `iterator` on `Symbol.iterator`),
	 * that symbol will be used:
	 *
	 * ```js
	 * canReflect.assignSymbols(ArrayLike.prototype, {
	 *   "iterator": function() { ... }
	 * })
	 * ArrayLike.prototype[Symbol.iterator] = function(){ ... }
	 * ```
	 *
	 * @param  {Object} target The value that will be updated with `source`'s symbols and values.
	 * @param  {Object<name,value>} source A source of symbol names and values to copy to `target`.
	 * @return {Object} The target.
	 */
	assignSymbols: function(target, source){
		shapeReflections.eachKey(source, function(value, key){
			var symbol = type.isSymbolLike(canSymbol_1_6_1_canSymbol[key]) ? canSymbol_1_6_1_canSymbol[key] : canSymbol_1_6_1_canSymbol.for(key);
			getSet.setKeyValue(target, symbol, value);
		});
		return target;
	},
	isSerialized: isSerializedHelper,
	/**
	 * @function can-reflect.size size
	 * @parent can-reflect/shape
	 * @description Return the number of items in the collection.
	 *
	 * @signature `.size(target)`
	 *
	 * Returns the number of items contained in `target`. Target can
	 * provide the size using the [can-symbol/symbols/size] symbol.
	 *
	 * If the `target` has a numeric `length` property that is greater than or equal to 0, that
	 * `length` will be returned.
	 *
	 * ```js
	 * canReflect.size([1,2,3]) //-> 3
	 * ```
	 *
	 * If the `target` is [can-reflect.isListLike], the values of the list will be counted.
	 *
	 * If the `target` is a plain JS object, the number of enumerable properties will be returned.
	 *
	 * ```js
	 * canReflect.size({foo:"bar"}) //-> 1
	 * ```
	 *
	 * If the `target` is anything else, `undefined` is returned.
	 *
	 * @param  {Object} target The container object.
	 * @return {Number} The number of values in the target.
	 */
	size: function(obj){
		if(obj == null) {
			return 0;
		}
		var size = obj[sizeSymbol];
		var count = 0;
		if(size) {
			return size.call(obj);
		}
		else if(helpers.hasLength(obj)){
			return obj.length;
		}
		else if(type.isListLike(obj)){

			shapeReflections.eachIndex(obj, function(){
				count++;
			});
			return count;
		}
		else if( obj ) {
			return shapeReflections.getOwnEnumerableKeys(obj).length;
		}
		else {
			return undefined;
		}
	},
	/**
	 * @function {Function, String|Symbol, Object} can-reflect.defineInstanceKey defineInstanceKey
	 * @parent can-reflect/shape
	 * @description Create a key for all instances of a constructor.
	 *
	 * @signature `defineInstanceKey(cls, key, properties)`
	 *
	 * Define the property `key` on the prototype of the constructor `cls` using the symbolic
	 * property [can-symbol/symbols/defineInstanceKey @@can.defineInstanceKey] if it exists; otherwise
	 * use `Object.defineProperty()` to define the property.  The property definition
	 *
	 * @param  {Function} cls  a Constructor function
	 * @param  {String} key     the String or Symbol key to set.
	 * @param  {Object} properties a JavaScript property descriptor
	 */
	defineInstanceKey: function(cls, key, properties) {
		var defineInstanceKey = cls[canSymbol_1_6_1_canSymbol.for("can.defineInstanceKey")];
		if(defineInstanceKey) {
			return defineInstanceKey.call(cls, key, properties);
		}
		var proto = cls.prototype;
		defineInstanceKey = proto[canSymbol_1_6_1_canSymbol.for("can.defineInstanceKey")];
		if(defineInstanceKey) {
			defineInstanceKey.call(proto, key, properties);
		} else {
			Object.defineProperty(
				proto,
				key,
				shapeReflections.assign({
					configurable: true,
					enumerable: !type.isSymbolLike(key),
					writable: true
				}, properties)
			);
		}
	}
};

shapeReflections.isSerializable = shapeReflections.isSerialized;
shapeReflections.keys = shapeReflections.getOwnEnumerableKeys;
var shape = shapeReflections;

var getSchemaSymbol = canSymbol_1_6_1_canSymbol.for("can.getSchema"),
    isMemberSymbol = canSymbol_1_6_1_canSymbol.for("can.isMember"),
    newSymbol = canSymbol_1_6_1_canSymbol.for("can.new");

function comparator(a, b) {
    return a.localeCompare(b);
}

function sort(obj) {
    if(type.isPrimitive(obj)) {
        return obj;
    }
    var out;
    if (type.isListLike(obj)) {
        out = [];
        shape.eachKey(obj, function(item){
            out.push(sort(item));
        });
        return out;
    }
    if( type.isMapLike(obj) ) {

        out = {};

        shape.getOwnKeys(obj).sort(comparator).forEach(function (key) {
            out[key] = sort( getSet.getKeyValue(obj, key) );
        });

        return out;
    }


    return obj;
}

function isPrimitiveConverter(Type){
    return Type === Number || Type === String || Type === Boolean;
}

var schemaReflections =  {
    /**
	 * @function can-reflect.getSchema getSchema
	 * @parent can-reflect/shape
	 * @description Returns the schema for a type or value.
	 *
	 * @signature `getSchema(valueOrType)`
	 *
     * Calls the `@can.getSchema` property on the `valueOrType` argument. If it's not available and
     * `valueOrType` has a `constructor` property, calls the `constructor[@can.getSchema]`
     * and returns the result.
     *
     * ```js
     * import canReflect from "can-reflect";
     *
     * var Type = DefineMap.extend({
     *   name: "string",
     *   id: "number"
     * });
     *
     * canReflect.getSchema( Type ) //-> {
     * //   type: "map",
     * //   keys: {
     * //     name: MaybeString
     * //     id: MaybeNumber
     * //   }
     * // }
     * ```
	 *
	 *
	 * @param  {Object|Function} valueOrType A value, constructor function, or class to get the schema from.
	 * @return {Object} A schema. A schema for a [can-reflect.isMapLike] looks like:
     *
     *
     * ```js
     * {
     *   type: "map",
     *   identity: ["id"],
     *   keys: {
     *     id: Number,
     *     name: String,
     *     complete: Boolean,
     *     owner: User
     *   }
     * }
     * ```
     *
     * A schema for a list looks like:
     *
     * ```js
     * {
     *   type: "list",
     *   values: String
     *   keys: {
     *     count: Number
     *   }
     * }
     * ```
     *
	 */
    getSchema: function(type$$1){
        var getSchema = type$$1[getSchemaSymbol];
        if(getSchema === undefined ) {
            type$$1 = type$$1.constructor;
            getSchema = type$$1 && type$$1[getSchemaSymbol];
        }
        return getSchema !== undefined ? getSchema.call(type$$1) : undefined;
    },
    /**
	 * @function can-reflect.getIdentity getIdentity
	 * @parent can-reflect/shape
	 * @description Get a unique primitive representing an object.
	 *
	 * @signature `getIdentity( object [,schema] )`
	 *
	 * This uses the object's schema, or the provided schema to return a unique string or number that
     * represents the object.
     *
     * ```js
     * import canReflect from "can-reflect";
     *
     * canReflect.getIdentity({id: 5}, {identity: ["id"]}) //-> 5
     * ```
     *
     * If the schema has multiple identity keys, the identity keys and values
     * are return stringified (and sorted):
     *
     * ```js
     * canReflect.getIdentity(
     *   {z: "Z", a: "A", foo: "bar"},
     *   {identity: ["a","b"]}) //-> '{"a":"A","b":"B"}'
     * ```
	 *
	 * @param  {Object|Function} object A map-like object.
     * @param {Object} [schema] A schema object with an `identity` array of the unique
     * keys of the object like:
     *   ```js
     *   {identity: ["id"]}
     *   ```
	 * @return {Number|String} A value that uniquely represents the object.
	 */
    getIdentity: function(value, schema){
        schema = schema || schemaReflections.getSchema(value);
        if(schema === undefined) {
            throw new Error("can-reflect.getIdentity - Unable to find a schema for the given value.");
        }

        var identity = schema.identity;
        if(!identity || identity.length === 0) {
            throw new Error("can-reflect.getIdentity - Provided schema lacks an identity property.");
        } else if(identity.length === 1) {
            return getSet.getKeyValue(value, identity[0]);
        } else {
            var id = {};
            identity.forEach(function(key){
                id[key] = getSet.getKeyValue(value, key);
            });
            return JSON.stringify(schemaReflections.cloneKeySort(id));
        }
    },
    /**
	 * @function can-reflect.cloneKeySort cloneKeySort
	 * @parent can-reflect/shape
	 * @description Copy a value while sorting its keys.
	 *
	 * @signature `cloneKeySort(value)`
	 *
     * `cloneKeySort` returns a copy of `value` with its [can-reflect.isMapLike]
     * key values sorted. If you just want a copy of a value,
     * use [can-reflect.serialize].
     *
     * ```js
     * import canRefect from "can-reflect";
     *
     * canReflect.cloneKeySort({z: "Z", a: "A"}) //-> {a:"A",z:"Z"}
     * ```
     *
     * Nested objects are also sorted.
	 *
     * This is useful if you need to store a representation of an object that can be used as a
     * key.
	 *
	 * @param  {Object} value An object or array.
	 * @return {Object} A copy of the object with its keys sorted.
	 */
    cloneKeySort: function(obj) {
        return sort(obj);
    },
    /**
	 * @function can-reflect.convert convert
	 * @parent can-reflect/shape
	 * @description Convert one value to another type.
	 *
	 * @signature `convert(value, Type)`
	 *
     * `convert` attempts to convert `value` to the type specified by `Type`.
     *
     * ```js
     * import canRefect from "can-reflect";
     *
     * canReflect.convert("1", Number) //-> 1
     * ```
     *
     * `convert` works by performing the following logic:
     *
     * 1. If the `Type` is a primitive like `Number`, `String`, `Boolean`, the
     *    `value` will be passed to the `Type` function and the result returned.
     *    ```js
     *    return Type(value);
     *    ```
     * 2. The value will be checked if it is already an instance of the type
     *    by performing the following:
     *    1. If the `Type` has a `can.isMember` symbol value, that value will be used
     *       to determine if the `value` is already an instance.
     *    2. If the `Type` is a [can-reflect.isConstructorLike] function, `instanceof Type`
     *       will be used to check if `value` is already an instance.
     * 3. If `value` is already an instance, `value` will be returned.
     * 4. If `Type` has a `can.new` symbol, `value` will be passed to it and the result
     *    returned.
     * 5. If `Type` is a [can-reflect.isConstructorLike] function, `new Type(value)` will be
     *    called the the result returned.
     * 6. If `Type` is a regular function, `Type(value)` will be called and the result returned.
     * 7. If a value hasn't been returned, an error is thrown.
	 *
	 * @param  {Object|Primitive} value A value to be converted.
     * @param  {Object|Function} Type A constructor function or an object that implements the
     * necessary symbols.
	 * @return {Object} The `value` converted to a member of `Type`.
	 */
    convert: function(value, Type){
        if(isPrimitiveConverter(Type)) {
            return Type(value);
        }
        // check if value is already a member
        var isMemberTest = Type[isMemberSymbol],
            isMember = false,
            type$$1 = typeof Type,
            createNew = Type[newSymbol];
        if(isMemberTest !== undefined) {
            isMember = isMemberTest.call(Type, value);
        } else if(type$$1 === "function") {
            if(type.isConstructorLike(Type)) {
                isMember = (value instanceof Type);
            }
        }
        if(isMember) {
            return value;
        }
        if(createNew !== undefined) {
            return createNew.call(Type, value);
        } else if(type$$1 === "function") {
            if(type.isConstructorLike(Type)) {
                return new Type(value);
            } else {
                // call it like a normal function
                return Type(value);
            }
        } else {
            throw new Error("can-reflect: Can not convert values into type. Type must provide `can.new` symbol.");
        }
    }
};
var schema = schemaReflections;

var getNameSymbol = canSymbol_1_6_1_canSymbol.for("can.getName");

/**
 * @function {Object, String} can-reflect.setName setName
 * @parent can-reflect/shape
 * @description Set a human-readable name of an object.
 *
 * @signature `setName(obj, value)`
 *
 * ```
 * var f = function() {};
 *
 * canReflect.setName(f, "myFunction")
 * f.name //-> "myFunction"
 * ```
 *
 * @param {Object} obj   the object to set on
 * @param {String} value the value to set for the object
 */
function setName(obj, nameGetter) {
	if (typeof nameGetter !== "function") {
		var value = nameGetter;
		nameGetter = function() {
			return value;
		};
	}

	Object.defineProperty(obj, getNameSymbol, {
		value: nameGetter
	});
}

/**
 * @function {Object} can-reflect.getName getName
 * @parent can-reflect/shape
 * @description Get the name of an object.
 *
 * @signature `getValue(obj)`
 *
 * @body
 *
 * The [@@@can.getName](can-symbol/symbols/getName.html) symbol is used to
 * provide objects human readable names; the main goal of these names is to help
 * users get a glance of what the object does and what it is used for.
 *
 * There are no hard rules to define names but CanJS uses the following convention
 * for consistent names across its observable types:
 *
 * - The name starts with the observable constructor name
 * - The constructor name is decorated with the following characters based on its type:
 *		- `<>`: for [value-like](can-reflect.isValueLike.html) observables, e.g: `SimpleObservable<>`
 *		- `[]`: for [list-like](can-reflect.isListLike.html) observables, e.g: `DefineList[]`
 *		- `{}`: for [map-like](can-reflect.isMapLike.html) observables, e.g: `DefineMap{}`
 * - Any property that makes the instance unique (like ids) are printed inside
 *    the chars mentioned before.
 *
 * The example below shows how to implement [@@@can.getName](can-symbol/symbols/getName.html),
 * in a value-like observable (similar to [can-simple-observable]).
 *
 * ```js
 * var canReflect = require("can-reflect");
 *
 * function MySimpleObservable(value) {
 *		this.value = value;
 * }
 *
 * canReflect.assignSymbols(MySimpleObservable.prototype, {
 *		"can.getName": function() {
 *			//!steal-remove-start
 *			var value = JSON.stringify(this.value);
 *			return canReflect.getName(this.constructor) + "<" + value + ">";
 *			//!steal-remove-end
 *		}
 * });
 * ```
 *
 * With that in place, `MySimpleObservable` can be used like this:
 *
 * ```js
 * var one = new MySimpleObservable(1);
 * canReflect.getName(one); // MySimpleObservable<1>
 * ```
 *
 * @param  {Object} obj The object to get from
 * @return {String} The human-readable name of the object
 */
function getName(obj) {
	var type$$1 = typeof obj;
	if(obj === null || (type$$1 !== "object" && type$$1 !== "function")) {
		return ""+obj;
	}
	var nameGetter = obj[getNameSymbol];
	if (nameGetter) {
		return nameGetter.call(obj);
	}

	if (type$$1 === "function") {
		return obj.name; // + "()" // should we do this?
	}

	if (obj.constructor && obj !== obj.constructor) {
		var parent = getName(obj.constructor);
		if (parent) {
			if (type.isValueLike(obj)) {
				return parent + "<>";
			}

			if (type.isMoreListLikeThanMapLike(obj)) {
				return parent + "[]";
			}

			if (type.isMapLike(obj)) {
				return parent + "{}";
			}
		}
	}

	return undefined;
}

var getName_1 = {
	setName: setName,
	getName: getName
};

function keysPolyfill() {
  var keys = [];
  var currentIndex = 0;

  this.forEach(function(val, key) {
    keys.push(key);
  });

  return {
    next: function() {
      return {
        value: keys[currentIndex],
        done: (currentIndex++ === keys.length)
      };
    }
  }
}

if (typeof Map !== "undefined") {
  shape.assignSymbols(Map.prototype, {
    "can.getOwnEnumerableKeys": Map.prototype.keys,
    "can.setKeyValue": Map.prototype.set,
    "can.getKeyValue": Map.prototype.get,
    "can.deleteKeyValue": Map.prototype["delete"],
    "can.hasOwnKey": Map.prototype.has
  });

  if (typeof Map.prototype.keys !== "function") {
    Map.prototype.keys = Map.prototype[canSymbol_1_6_1_canSymbol.for("can.getOwnEnumerableKeys")] = keysPolyfill;
  }
}

if (typeof WeakMap !== "undefined") {
  shape.assignSymbols(WeakMap.prototype, {
    "can.getOwnEnumerableKeys": function() {
      throw new Error("can-reflect: WeakMaps do not have enumerable keys.");
    },
    "can.setKeyValue": WeakMap.prototype.set,
    "can.getKeyValue": WeakMap.prototype.get,
    "can.deleteKeyValue": WeakMap.prototype["delete"],
    "can.hasOwnKey": WeakMap.prototype.has
  });
}

if (typeof Set !== "undefined") {
  shape.assignSymbols(Set.prototype, {
    "can.isMoreListLikeThanMapLike": true,
    "can.updateValues": function(index, removing, adding) {
      if (removing !== adding) {
        shape.each(
          removing,
          function(value) {
            this.delete(value);
          },
          this
        );
      }
      shape.each(
        adding,
        function(value) {
          this.add(value);
        },
        this
      );
    },
    "can.size": function() {
      return this.size;
    }
  });

  // IE11 doesn't support Set.prototype[@@iterator]
  if (typeof Set.prototype[canSymbol_1_6_1_canSymbol.iterator] !== "function") {
	  Set.prototype[canSymbol_1_6_1_canSymbol.iterator] = function() {
		  var arr = [];
		  var currentIndex = 0;

		  this.forEach(function(val) {
			  arr.push(val);
		  });

		  return {
			  next: function() {
				  return {
					  value: arr[currentIndex],
					  done: (currentIndex++ === arr.length)
				  };
			  }
		  }
	  };
  }
}
if (typeof WeakSet !== "undefined") {
  shape.assignSymbols(WeakSet.prototype, {
    "can.isListLike": true,
    "can.isMoreListLikeThanMapLike": true,
    "can.updateValues": function(index, removing, adding) {
      if (removing !== adding) {
        shape.each(
          removing,
          function(value) {
            this.delete(value);
          },
          this
        );
      }
      shape.each(
        adding,
        function(value) {
          this.add(value);
        },
        this
      );
    },
    "can.size": function() {
      throw new Error("can-reflect: WeakSets do not have enumerable keys.");
    }
  });
}

var reflect = {};
[
	call,
	getSet,
	observe,
	shape,
	type,
	getName_1,
	schema
].forEach(function(reflections){
	for(var prop in reflections) {
		reflect[prop] = reflections[prop];
		//!steal-remove-start
		if(typeof reflections[prop] === "function") {
			var propDescriptor = Object.getOwnPropertyDescriptor(reflections[prop], 'name');
			if (!propDescriptor || propDescriptor.writable && propDescriptor.configurable) {
				Object.defineProperty(reflections[prop],"name",{
					value: "canReflect."+prop
				});
			}
		}
		//!steal-remove-end
	}
});




var canReflect_1_16_7_canReflect = canNamespace_1_0_0_canNamespace.Reflect = reflect;

var commonjsGlobal = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function commonjsRequire () {
	throw new Error('Dynamic requires are not currently supported by rollup-plugin-commonjs');
}

function unwrapExports (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

var warnTimeout = 5000;
var logLevel = 0;

/**
 * @module {{}} can-log log
 * @parent can-js-utilities
 * @collection can-infrastructure
 * @hide
 *
 * Utilities for logging to the console.
 */

/**
 * @function can-log.warn warn
 * @parent can-log
 * @description
 *
 * Adds a warning message to the console.
 *
 * ```
 * var canLog = require("can-log");
 *
 * canLog.warn("something evil");
 * ```
 *
 * @signature `canLog.warn(msg)`
 * @param {String} msg the message to be logged.
 */
var warn = function() {
	var ll = this.logLevel;
	if (ll < 2) {
		if (typeof console !== "undefined" && console.warn) {
			this._logger("warn", Array.prototype.slice.call(arguments));
		} else if (typeof console !== "undefined" && console.log) {
			this._logger("log", Array.prototype.slice.call(arguments));
		}
	}
};

/**
 * @function can-log.log log
 * @parent can-log
 * @description
 * Adds a message to the console.
 * @hide
 *
 * ```
 * var canLog = require("can-log");
 *
 * canLog.log("hi");
 * ```
 *
 * @signature `canLog.log(msg)`
 * @param {String} msg the message
 */
var log = function() {
	var ll = this.logLevel;
	if (ll < 1) {
		if (typeof console !== "undefined" && console.log) {
			this._logger("log", Array.prototype.slice.call(arguments));
		}
	}
};

/**
 * @function can-log.error error
 * @parent can-log
 * @description
 * Adds an error message to the console.
 * @hide
 *
 * ```
 * var canLog = require("can-log");
 *
 * canLog.error(new Error("Oh no!"));
 * ```
 *
 * @signature `canLog.error(err)`
 * @param {String|Error} err The error to be logged.
 */
var error = function() {
	var ll = this.logLevel;
	if (ll < 1) {
		if (typeof console !== "undefined" && console.error) {
			this._logger("error", Array.prototype.slice.call(arguments));
		}
	}
};

var _logger = function (type, arr) {
	try {
		console[type].apply(console, arr);
	} catch(e) {
		console[type](arr);
	}
};

var canLog_1_0_0_canLog = {
	warnTimeout: warnTimeout,
	logLevel: logLevel,
	warn: warn,
	log: log,
	error: error,
	_logger: _logger
};

/**
 * @module {{}} can-log/dev dev
 * @parent can-log
 * @hide
 * 
 * Utilities for logging development-mode messages. Use this module for
 * anything that should be shown to the user during development but isn't
 * needed in production. In production these functions become noops.
 */
var dev = {
	warnTimeout: 5000,
	logLevel: 0,
	/**
	 * @function can-log/dev.stringify stringify
	 * @parent can-log
	 * @description
	 * @hide
	 *
	 * JSON stringifies a value, but unlike JSON, will output properties with
	 * a value of `undefined` (e.g. `{ "prop": undefined }`, not `{}`).
	 *
	 * ```
	 * var dev = require('can-log/dev');
	 * var query = { where: undefined };
	 * 
	 * dev.warn('No records found: ' + dev.stringify(query));
	 * ```
	 *
	 * @signature `dev.stringify(value)`
	 * @param {Any} value A value to stringify.
	 * @return {String} A stringified representation of the passed in value.
	 */
	stringify: function(value) {
		var flagUndefined = function flagUndefined(key, value) {
			return value === undefined ?
				 "/* void(undefined) */" : value;
		};
		
		return JSON.stringify(value, flagUndefined, "  ").replace(
			/"\/\* void\(undefined\) \*\/"/g, "undefined");
	},
	/**
	 * @function can-log/dev.warn warn
	 * @parent can-log
	 * @description
	 * @hide
	 *
	 * Adds a warning message to the console.
	 *
	 * ```
	 * var dev = require('can-log/dev');
	 * 
	 * dev.warn("something evil");
	 * ```
	 *
	 * @signature `dev.warn(msg)`
	 * @param {String} msg The warning message.
	 */
	warn: function() {
		//!steal-remove-start
		canLog_1_0_0_canLog.warn.apply(this, arguments);
		//!steal-remove-end
	},
	/**
	 * @function can-log/dev.log log
	 * @parent can-log
	 * @description
	 * @hide
	 *
	 * Adds a message to the console.
	 *
	 * ```
	 * var dev = require('can-log/dev');
	 * 
	 * dev.log("hi");
	 * ```
	 *
	 * @signature `dev.log(msg)`
	 * @param {String} msg The message.
	 */
	log: function() {
		//!steal-remove-start
		canLog_1_0_0_canLog.log.apply(this, arguments);
		//!steal-remove-end
	},
	/**
	 * @function can-log/dev.error error
	 * @parent can-log
	 * @description
	 * @hide
	 *
	 * Adds an error message to the console.
	 *
	 * ```
	 * var dev = require("can-log/dev");
	 * 
	 * dev.error(new Error("Oh no!"));
	 * ```
	 *
	 * @signature `dev.error(err)`
	 * @param {String|Error} err The error to be logged.
	 */
	error: function() {
		//!steal-remove-start
		canLog_1_0_0_canLog.error.apply(this, arguments);
		//!steal-remove-end
	},
	_logger: canLog_1_0_0_canLog._logger
};

var canQueues_1_1_0_queueState = {
	lastTask: null
};

/**
 * @module {function} can-assign can-assign
 * @parent can-js-utilities
 * @collection can-infrastructure
 * @signature `assign(target, source)`
 *
 * A simplified version of [Object.assign](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign), which only accepts a single source argument.
 *
 * ```js
 * var assign = require("can-assign");
 *
 * var obj = {};
 *
 * assign(obj, {
 *   foo: "bar"
 * });
 *
 * console.log(obj.foo); // -> "bar"
 * ```
 *
 * @param {Object} target The destination object. This object's properties will be mutated based on the object provided as `source`.
 * @param {Object} source The source object whose own properties will be applied to `target`.
 *
 * @return {Object} Returns the `target` argument.
 */

var canAssign_1_1_1_canAssign = function (d, s) {
	for (var prop in s) {
		d[prop] = s[prop];
	}
	return d;
};

function noOperation () {}

var Queue = function ( name, callbacks ) {
	this.callbacks = canAssign_1_1_1_canAssign( {
		onFirstTask: noOperation,
		// The default behavior is to clear the lastTask state.
		// This is overwritten by `can-queues.js`.
		onComplete: function () {
			canQueues_1_1_0_queueState.lastTask = null;
		}
	}, callbacks || {});
	this.name = name;
	this.index = 0;
	this.tasks = [];
	this._log = false;
};

Queue.prototype.constructor = Queue;

Queue.noop = noOperation;

Queue.prototype.enqueue = function ( fn, context, args, meta ) {
	var len = this.tasks.push({
		fn: fn,
		context: context,
		args: args,
		meta: meta || {}
	});
	//!steal-remove-start
	this._logEnqueue( this.tasks[len - 1] );
	//!steal-remove-end

	if ( len === 1 ) {
		this.callbacks.onFirstTask( this );
	}
};

Queue.prototype.flush = function () {
	while ( this.index < this.tasks.length ) {
		var task = this.tasks[this.index++];
		//!steal-remove-start
		this._logFlush( task );
		//!steal-remove-end
		task.fn.apply( task.context, task.args );
	}
	this.index = 0;
	this.tasks = [];
	this.callbacks.onComplete( this );
};

Queue.prototype.log = function () {
	this._log = arguments.length ? arguments[0] : true;
};

//The following are removed in production.
//!steal-remove-start
Queue.prototype._logEnqueue = function ( task ) {
	// For debugging, set the parentTask to the last
	// run task.
	task.meta.parentTask = canQueues_1_1_0_queueState.lastTask;
	// Also let the task know which stack it was run within.
	task.meta.stack = this;

	if ( this._log === true || this._log === "enqueue" ) {
		var log = task.meta.log ? task.meta.log.concat( task ) : [task.fn.name, task];
		dev.log.apply( dev, [this.name + " enqueuing:"].concat( log ));
	}
};
// `_logFlush` MUST be called by all queues prior to flushing in
// development.
Queue.prototype._logFlush = function ( task ) {
	if ( this._log === true || this._log === "flush" ) {
		var log = task.meta.log ? task.meta.log.concat( task ) : [task.fn.name, task];
		dev.log.apply( dev, [this.name + " running  :"].concat( log ));
	}
	// Update the state to mark this as the task that was run last.
	canQueues_1_1_0_queueState.lastTask = task;
};
//!steal-remove-end

var canQueues_1_1_0_queue = Queue;

var PriorityQueue = function () {
	canQueues_1_1_0_queue.apply( this, arguments );
	// A map of a task's function to the task for that function.
	// This is so we can prevent duplicate functions from being enqueued
	// and so `flushQueuedTask` can find the task and run it.
	this.taskMap = new Map();
	// An "array-of-arrays"-ish data structure that stores
	// each task organized by its priority.  Each object in this list
	// looks like `{tasks: [...], index: 0}` where:
	// - `tasks` - the tasks for a particular priority.
	// - `index` - the index of the task waiting to be prioritized.
	this.taskContainersByPriority = [];

	// The index within `taskContainersByPriority` of the first `taskContainer`
	// which has tasks that have not been run.
	this.curPriorityIndex = Infinity;
	// The index within `taskContainersByPriority` of the last `taskContainer`
	// which has tasks that have not been run.
	this.curPriorityMax = 0;

	this.isFlushing = false;

	// Manage the number of tasks remaining to keep
	// this lookup fast.
	this.tasksRemaining = 0;
};
PriorityQueue.prototype = Object.create( canQueues_1_1_0_queue.prototype );
PriorityQueue.prototype.constructor = PriorityQueue;

PriorityQueue.prototype.enqueue = function ( fn, context, args, meta ) {
	// Only allow the enqueing of a given function once.
	if ( !this.taskMap.has( fn ) ) {

		this.tasksRemaining++;

		var isFirst = this.taskContainersByPriority.length === 0;

		var task = {
			fn: fn,
			context: context,
			args: args,
			meta: meta || {}
		};

		var taskContainer = this.getTaskContainerAndUpdateRange( task );
		taskContainer.tasks.push( task );
		this.taskMap.set( fn, task );

		//!steal-remove-start
		this._logEnqueue( task );
		//!steal-remove-end

		if ( isFirst ) {
			this.callbacks.onFirstTask( this );
		}
	}
};

// Given a task, updates the queue's cursors so that `flush`
// will be able to run the task.
PriorityQueue.prototype.getTaskContainerAndUpdateRange = function ( task ) {
	var priority = task.meta.priority || 0;

	if ( priority < this.curPriorityIndex ) {
		this.curPriorityIndex = priority;
	}

	if ( priority > this.curPriorityMax ) {
		this.curPriorityMax = priority;
	}

	var tcByPriority = this.taskContainersByPriority;
	var taskContainer = tcByPriority[priority];
	if ( !taskContainer ) {
		taskContainer = tcByPriority[priority] = {tasks: [], index: 0};
	}
	return taskContainer;
};

PriorityQueue.prototype.flush = function () {
	// Only allow one task to run at a time.
	if ( this.isFlushing ) {
		return;
	}
	this.isFlushing = true;
	while ( true ) {
		// If the first prioritized taskContainer with tasks remaining
		// is before the last prioritized taskContainer ...
		if ( this.curPriorityIndex <= this.curPriorityMax ) {
			var taskContainer = this.taskContainersByPriority[this.curPriorityIndex];

			// If that task container actually has tasks remaining ...
			if ( taskContainer && ( taskContainer.tasks.length > taskContainer.index ) ) {

				// Run the task.
				var task = taskContainer.tasks[taskContainer.index++];
				//!steal-remove-start
				this._logFlush( task );
				//!steal-remove-end
				this.tasksRemaining--;
				this.taskMap["delete"]( task.fn );
				task.fn.apply( task.context, task.args );

			} else {
				// Otherwise, move to the next taskContainer.
				this.curPriorityIndex++;
			}
		} else {
			// Otherwise, reset the state for the next `.flush()`.
			this.taskMap = new Map();
			this.curPriorityIndex = Infinity;
			this.curPriorityMax = 0;
			this.taskContainersByPriority = [];
			this.isFlushing = false;
			this.callbacks.onComplete( this );
			return;
		}
	}
};

PriorityQueue.prototype.isEnqueued = function ( fn ) {
	return this.taskMap.has( fn );
};

PriorityQueue.prototype.flushQueuedTask = function ( fn ) {
	var task = this.dequeue(fn);
	if(task) {
		//!steal-remove-start
		this._logFlush( task );
		//!steal-remove-end
		task.fn.apply( task.context, task.args );
	}
};
PriorityQueue.prototype.dequeue = function(fn){
	var task = this.taskMap.get( fn );
	if ( task ) {
		var priority = task.meta.priority || 0;
		var taskContainer = this.taskContainersByPriority[priority];
		var index = taskContainer.tasks.indexOf( task, taskContainer.index );

		if ( index >= 0 ) {
			taskContainer.tasks.splice( index, 1 );
			this.tasksRemaining--;
			this.taskMap["delete"]( task.fn );
			return task;
		} else {
			console.warn("Task", fn, "has already run");
		}
	}
};

PriorityQueue.prototype.tasksRemainingCount = function () {
	return this.tasksRemaining;
};

var canQueues_1_1_0_priorityQueue = PriorityQueue;

// This queue does not allow another task to run until this one is complete
var CompletionQueue = function () {
	canQueues_1_1_0_queue.apply( this, arguments );
	this.flushCount = 0;
};
CompletionQueue.prototype = Object.create( canQueues_1_1_0_queue.prototype );
CompletionQueue.prototype.constructor = CompletionQueue;

CompletionQueue.prototype.flush = function () {
	if ( this.flushCount === 0 ) {
		this.flushCount ++;
		while ( this.index < this.tasks.length ) {
			var task = this.tasks[this.index++];
			//!steal-remove-start
			this._logFlush( task );
			//!steal-remove-end
			task.fn.apply( task.context, task.args );
		}
		this.index = 0;
		this.tasks = [];
		this.flushCount--;
		this.callbacks.onComplete( this );
	}
};

var canQueues_1_1_0_completionQueue = CompletionQueue;

var canQueues_1_1_0_canQueues = createCommonjsModule(function (module) {
// How many `batch.start` - `batch.stop` calls have been made.
var batchStartCounter = 0;
// If a task was added since the last flush caused by `batch.stop`.
var addedTask = false;

// Legacy values for the old batchNum.
var batchNum = 0;
var batchData;

// Used by `.enqueueByQueue` to know the property names that might be passed.
var queueNames = ["notify", "derive", "domUI", "mutate"];
// Create all the queues so that when one is complete,
// the next queue is flushed.
var NOTIFY_QUEUE, DERIVE_QUEUE, DOM_UI_QUEUE, MUTATE_QUEUE;

NOTIFY_QUEUE = new canQueues_1_1_0_queue( "NOTIFY", {
	onComplete: function () {
		DERIVE_QUEUE.flush();
	},
	onFirstTask: function () {
		// Flush right away if we aren't in a batch.
		if ( !batchStartCounter ) {
			NOTIFY_QUEUE.flush();
		} else {
			addedTask = true;
		}
	}
});

DERIVE_QUEUE = new canQueues_1_1_0_priorityQueue( "DERIVE", {
	onComplete: function () {
		DOM_UI_QUEUE.flush();
	},
	onFirstTask: function () {
		addedTask = true;
	}
});

DOM_UI_QUEUE = new canQueues_1_1_0_completionQueue( "DOM_UI", {
	onComplete: function () {
		MUTATE_QUEUE.flush();
	},
	onFirstTask: function () {
		addedTask = true;
	}
});

MUTATE_QUEUE = new canQueues_1_1_0_queue( "MUTATE", {
	onComplete: function () {
		canQueues_1_1_0_queueState.lastTask = null;
	},
	onFirstTask: function () {
		addedTask = true;
	}
});

var queues = {
	Queue: canQueues_1_1_0_queue,
	PriorityQueue: canQueues_1_1_0_priorityQueue,
	CompletionQueue: canQueues_1_1_0_completionQueue,
	notifyQueue: NOTIFY_QUEUE,
	deriveQueue: DERIVE_QUEUE,
	domUIQueue: DOM_UI_QUEUE,
	mutateQueue: MUTATE_QUEUE,
	batch: {
		start: function () {
			batchStartCounter++;
			if ( batchStartCounter === 1 ) {
				batchNum++;
				batchData = {number: batchNum};
			}
		},
		stop: function () {
			batchStartCounter--;
			if ( batchStartCounter === 0 ) {
				if ( addedTask ) {
					addedTask = false;
					NOTIFY_QUEUE.flush();
				}
			}
		},
		// Legacy method to return if we are between start and stop calls.
		isCollecting: function () {
			return batchStartCounter > 0;
		},
		// Legacy method provide a number for each batch.
		number: function () {
			return batchNum;
		},
		// Legacy method to provide batch information.
		data: function () {
			return batchData;
		}
	},
	enqueueByQueue: function enqueueByQueue ( fnByQueue, context, args, makeMeta, reasonLog ) {
		if ( fnByQueue ) {
			queues.batch.start();
			// For each queue, check if there are tasks for it.
			queueNames.forEach( function ( queueName ) {
				var name = queueName + "Queue";
				var QUEUE = queues[name];
				var tasks = fnByQueue[queueName];
				if ( tasks !== undefined ) {
					// For each task function, setup the meta and enqueue it.
					tasks.forEach( function ( fn ) {
						var meta = makeMeta != null ? makeMeta( fn, context, args ) : {};
						meta.reasonLog = reasonLog;
						QUEUE.enqueue( fn, context, args, meta );
					});
				}
			});
			queues.batch.stop();
		}
	},
	// Currently an internal method that provides the task stack.
	// Returns an array with the first task as the first item.
	stack: function () {
		var current = canQueues_1_1_0_queueState.lastTask;
		var stack = [];
		while ( current ) {
			stack.unshift( current );
			// Queue.prototype._logEnqueue ensures
			// that the `parentTask` is always set.
			current = current.meta.parentTask;
		}
		return stack;
	},
	logStack: function () {
		var stack = this.stack();
		stack.forEach( function ( task, i ) {
			var meta = task.meta;
			if( i === 0 && meta && meta.reasonLog) {
				dev.log.apply( dev, meta.reasonLog);
			}
			var log = meta && meta.log ? meta.log : [task.fn.name, task];
			dev.log.apply( dev, [task.meta.stack.name + " ran task:"].concat( log ));
		});
	},
	// A method that is not used.  It should return the number of tasks
	// remaining, but doesn't seem to actually work.
	taskCount: function () {
		return NOTIFY_QUEUE.tasks.length + DERIVE_QUEUE.tasks.length + DOM_UI_QUEUE.tasks.length + MUTATE_QUEUE.tasks.length;
	},
	// A shortcut for flushign the notify queue.  `batch.start` and `batch.stop` should be
	// used instead.
	flush: function () {
		NOTIFY_QUEUE.flush();
	},
	log: function () {
		NOTIFY_QUEUE.log.apply( NOTIFY_QUEUE, arguments );
		DERIVE_QUEUE.log.apply( DERIVE_QUEUE, arguments );
		DOM_UI_QUEUE.log.apply( DOM_UI_QUEUE, arguments );
		MUTATE_QUEUE.log.apply( MUTATE_QUEUE, arguments );
	}
};

if ( canNamespace_1_0_0_canNamespace.queues ) {
	throw new Error( "You can't have two versions of can-queues, check your dependencies" );
} else {
	module.exports = canNamespace_1_0_0_canNamespace.queues = queues;
}
});

var canObservationRecorder_1_1_2_canObservationRecorder = createCommonjsModule(function (module) {
// Contains stack of observation records created by pushing with `.start`
// and popping with `.stop()`.
// The top of the stack is the "target" observation record - the record that calls
// to `ObservationRecorder.add` get added to.
var stack = [];

var addParentSymbol = canSymbol_1_6_1_canSymbol.for("can.addParent");

var ObservationRecorder = {
    stack: stack,
    start: function(){
    	var deps = {
            keyDependencies: new Map(),
            valueDependencies: new Set(),
						childDependencies: new Set(),

            // `traps` and `ignore` are here only for performance
            // reasons. They work with `ObservationRecorder.ignore` and `ObservationRecorder.trap`.
            traps: null,
            ignore: 0
    	};

        stack.push(deps);

        return deps;
    },
    stop: function() {
    	return stack.pop();
    },

    add: function(obj, event) {
        var top = stack[stack.length-1];
    	if (top && top.ignore === 0) {

    		if(top.traps) {
    			top.traps.push([obj, event]);
    		}
    		else {
                // Use `=== undefined` instead of `arguments.length` for performance.
                if(event === undefined) {
                    top.valueDependencies.add(obj);
                } else {
                    var eventSet = top.keyDependencies.get(obj);
        			if(!eventSet) {
        				eventSet = new Set();
        				top.keyDependencies.set(obj, eventSet);
        			}
        			eventSet.add(event);
                }
    		}
    	}
    },

    addMany: function(observes){
        var top = stack[stack.length-1];
    	if (top) {
    		if(top.traps) {
    			top.traps.push.apply(top.traps, observes);
    		} else {
    			for(var i =0, len = observes.length; i < len; i++) {
                    this.add(observes[i][0],observes[i][1]);
    			}
    		}
    	}
    },
		created: function(obs){
			var top = stack[stack.length - 1];
			if(top) {
				top.childDependencies.add(obs);
				if(obs[addParentSymbol]) {
					obs[addParentSymbol](top);
				}
			}
		},
    ignore: function(fn){
    	return function(){
    		if (stack.length) {
    			var top = stack[stack.length-1];
    			top.ignore++;
    			var res = fn.apply(this, arguments);
    			top.ignore--;
    			return res;
    		} else {
    			return fn.apply(this, arguments);
    		}
    	};
    },
    isRecording: function(){
    	var len = stack.length;
    	var last = len && stack[len-1];
    	return last && (last.ignore === 0) && last;
    },
    // `can-observation` uses this to do diffs more easily.
    makeDependenciesRecord: function(){
        return {
            traps: null,
            keyDependencies: new Map(),
            valueDependencies: new Set(),
						//childDependencies: new Set(),
            ignore: 0
        };
    },
    // The following are legacy methods we should do away with.
    makeDependenciesRecorder: function(){
        return ObservationRecorder.makeDependenciesRecord();
    },
    // Traps should be replace by calling `.start()` and `.stop()`.
    // To do this, we'd need a method that accepts a dependency record.
    trap: function(){
    	if (stack.length) {
    		var top = stack[stack.length-1];
    		var oldTraps = top.traps;
    		var traps = top.traps = [];
    		return function(){
    			top.traps = oldTraps;
    			return traps;
    		};
    	} else {
    		return function(){return [];};
    	}
    },
    trapsCount: function(){
    	if (stack.length) {
    		var top = stack[stack.length-1];
    		return top.traps.length;
    	} else {
    		return 0;
    	}
    }
};

if (canNamespace_1_0_0_canNamespace.ObservationRecorder) {
	throw new Error("You can't have two versions of can-observation-recorder, check your dependencies");
} else {
	module.exports = canNamespace_1_0_0_canNamespace.ObservationRecorder = ObservationRecorder;
}
});

// ## Helpers
// The following implement helper functions useful to `can-key-tree`'s main methods.

// ### isBuiltInPrototype
// Returns if `obj` is the prototype of a built-in JS type like `Map`.
// Built in types' `toString` returns `[object TYPENAME]`.
function isBuiltInPrototype ( obj ) {
	if ( obj === Object.prototype ) {
		return true;
	}
	var protoString = Object.prototype.toString.call( obj );
	var isNotObjObj = protoString !== '[object Object]';
	var isObjSomething = protoString.indexOf( '[object ' ) !== -1;
	return isNotObjObj && isObjSomething;
}

// ### getDeepSize
// Recursively returns the number of leaf values below `root` node.
function getDeepSize ( root, level ) {
	if ( level === 0 ) {
		return canReflect_1_16_7_canReflect.size( root );
	} else if ( canReflect_1_16_7_canReflect.size( root ) === 0 ) {
		return 0;
	} else {
		var count = 0;
		canReflect_1_16_7_canReflect.each( root, function ( value ) {
			count += getDeepSize( value, level - 1 );
		});
		return count;
	}
}

// ### getDeep
// Adds all leaf values under `node` to `items`.
// `depth` is how deep `node` is in the tree.
// `maxDepth` is the total depth of the tree structure.
function getDeep ( node, items, depth, maxDepth ) {
	if ( !node ) {
		return;
	}
	if ( maxDepth === depth ) {
		if ( canReflect_1_16_7_canReflect.isMoreListLikeThanMapLike( node ) ) {
			canReflect_1_16_7_canReflect.addValues( items, canReflect_1_16_7_canReflect.toArray( node ) );
		} else {
			throw new Error( "can-key-tree: Map-type leaf containers are not supported yet." );
		}
	} else {
		canReflect_1_16_7_canReflect.each( node, function ( value ) {
			getDeep( value, items, depth + 1, maxDepth );
		});
	}
}

// ### clearDeep
// Recursively removes value from all child nodes of `node`.
function clearDeep ( node, keys, maxDepth, deleteHandler ) {
	if ( maxDepth === keys.length ) {
		if ( canReflect_1_16_7_canReflect.isMoreListLikeThanMapLike( node ) ) {
			var valuesToRemove = canReflect_1_16_7_canReflect.toArray( node );
			if(deleteHandler) {
				valuesToRemove.forEach(function(value){
					deleteHandler.apply(null, keys.concat(value));
				});
			}
			canReflect_1_16_7_canReflect.removeValues( node, valuesToRemove );
		} else {
			throw new Error( "can-key-tree: Map-type leaf containers are not supported yet." );
		}
	} else {
		canReflect_1_16_7_canReflect.each( node, function ( value, key ) {
			clearDeep( value, keys.concat(key), maxDepth, deleteHandler );
			canReflect_1_16_7_canReflect.deleteKeyValue( node, key );
		});
	}
}

// ## KeyTree
// Creates an instance of the KeyTree.
var KeyTree = function ( treeStructure, callbacks ) {
	this.callbacks = callbacks || {};

	this.treeStructure = treeStructure;
	var FirstConstructor = treeStructure[0];
	if ( canReflect_1_16_7_canReflect.isConstructorLike( FirstConstructor ) ) {
		this.root = new FirstConstructor();
	} else {
		this.root = FirstConstructor;
	}
};

// ## Methods
canReflect_1_16_7_canReflect.assign(KeyTree.prototype,{
    // ### Add
    add: function ( keys ) {
    	if ( keys.length > this.treeStructure.length ) {
    		throw new Error( "can-key-tree: Can not add path deeper than tree." );
    	}
        // The place we will add the final leaf value.
    	var place = this.root;

        // Record if the root was empty so we know to call `onFirst`.
    	var rootWasEmpty = canReflect_1_16_7_canReflect.size( this.root ) === 0;

        // For each key, try to get the corresponding childNode.
        for ( var i = 0; i < keys.length - 1; i++ ) {
    		var key = keys[i];
    		var childNode = canReflect_1_16_7_canReflect.getKeyValue( place, key );
    		if ( !childNode ) {
                // If there is no childNode, create it and add it to the parent node.
    			var Constructor = this.treeStructure[i + 1];
    			if ( isBuiltInPrototype( Constructor.prototype ) ) {
    				childNode = new Constructor();
    			} else {
    				childNode = new Constructor( key );
    			}
    			canReflect_1_16_7_canReflect.setKeyValue( place, key, childNode );
    		}
    		place = childNode;
    	}

        // Add the final leaf value in the tree.
    	if ( canReflect_1_16_7_canReflect.isMoreListLikeThanMapLike( place ) ) {
    		canReflect_1_16_7_canReflect.addValues( place, [keys[keys.length - 1]] );
    	} else {
    		throw new Error( "can-key-tree: Map types are not supported yet." );
    	}

        // Callback `onFirst` if appropriate.
    	if ( rootWasEmpty && this.callbacks.onFirst ) {
    		this.callbacks.onFirst.call( this );
    	}

    	return this;
    },
    // ### getNode
    getNode: function ( keys ) {
        var node = this.root;
        // For each key, try to read the child node.
        // If a child is not found, return `undefined`.
        for ( var i = 0; i < keys.length; i++ ) {
            var key = keys[i];
            node = canReflect_1_16_7_canReflect.getKeyValue( node, key );
            if ( !node ) {
                return;
            }
        }
        return node;
    },
    // ### get
    get: function ( keys ) {
        // Get the node specified by keys.
    	var node = this.getNode( keys );

        // If it's a leaf, return it.
    	if ( this.treeStructure.length === keys.length ) {
    		return node;
    	} else {
    		// Otherwise, create a container for leaf values and
            // recursively walk the node's children.
    		var Type = this.treeStructure[this.treeStructure.length - 1];
    		var items = new Type();
    		getDeep( node, items, keys.length, this.treeStructure.length - 1 );
    		return items;
    	}
    },
    // ### delete
    delete: function ( keys, deleteHandler ) {

        // `parentNode` will eventually be the parent nodde of the
        // node specified by keys.
        var parentNode = this.root,
            // The nodes traversed to the node specified by `keys`.
            path = [this.root],
            lastKey = keys[keys.length - 1];

        // Set parentNode to the node specified by keys
        // and record the nodes in `path`.
        for ( var i = 0; i < keys.length - 1; i++ ) {
    		var key = keys[i];
    		var childNode = canReflect_1_16_7_canReflect.getKeyValue( parentNode, key );
    		if ( childNode === undefined ) {
    			return false;
    		} else {
    			path.push( childNode );
    		}
    		parentNode = childNode;
    	}


        // Depending on which keys were specified and the content of the
        // key, do various cleanups ...
        if ( !keys.length ) {
            // If there are no keys, recursively clear the entire tree.
    		clearDeep( parentNode, [], this.treeStructure.length - 1, deleteHandler );
    	}
        else if ( keys.length === this.treeStructure.length ) {
            // If removing a leaf, remove that value.
    		if ( canReflect_1_16_7_canReflect.isMoreListLikeThanMapLike( parentNode ) ) {
				if(deleteHandler) {
					deleteHandler.apply(null, keys.concat(lastKey));
				}
    			canReflect_1_16_7_canReflect.removeValues( parentNode, [lastKey] );
    		} else {
    			throw new Error( "can-key-tree: Map types are not supported yet." );
    		}
    	}
        else {
            // If removing a node 'within' the tree, recursively clear
            // that node and then delete the key from parent to node.
            var nodeToRemove = canReflect_1_16_7_canReflect.getKeyValue( parentNode, lastKey );
    		if ( nodeToRemove !== undefined ) {
    			clearDeep( nodeToRemove, keys, this.treeStructure.length - 1, deleteHandler );
    			canReflect_1_16_7_canReflect.deleteKeyValue( parentNode, lastKey );
    		} else {
    			return false;
    		}
    	}

        // After deleting the node, check if its parent is empty and
        // recursively prune parent nodes that are now empty.
    	for ( i = path.length - 2; i >= 0; i-- ) {
    		if ( canReflect_1_16_7_canReflect.size( parentNode ) === 0 ) {
    			parentNode = path[i];
    			canReflect_1_16_7_canReflect.deleteKeyValue( parentNode, keys[i] );
    		} else {
    			break;
    		}
    	}
        // Call `onEmpty` if the tree is now empty.
    	if ( this.callbacks.onEmpty && canReflect_1_16_7_canReflect.size( this.root ) === 0 ) {
    		this.callbacks.onEmpty.call( this );
    	}
    	return true;
    },
    // ### size
    // Recursively count the number of leaf values.
    size: function () {
    	return getDeepSize( this.root, this.treeStructure.length - 1 );
    }
});

var canKeyTree_1_0_2_canKeyTree = KeyTree;

/**
 * @module {function} can-define-lazy-value
 * @parent can-js-utilities
 * @collection can-infrastructure
 * @package ./package.json
 * @signature `defineLazyValue(obj, prop, fn, writable)`
 *
 * Use Object.defineProperty to define properties whose values will be created lazily when they are first read.
 *
 * ```js
 * var _id = 1;
 * function getId() {
 *     return _id++;
 * }
 *
 * function MyObj(name) {
 *     this.name = name;
 * }
 *
 * defineLazyValue(MyObj.prototype, 'id', getId);
 *
 * var obj1 = new MyObj('obj1');
 * var obj2 = new MyObj('obj2');
 *
 * console.log( obj2 ); // -> { name: "obj2" }
 * console.log( obj1 ); // -> { name: "obj1" }
 *
 * // the first `id` read will get id `1`
 * console( obj2.id ); // -> 1
 * console( obj1.id ); // -> 2
 *
 * console.log( obj2 ); // -> { name: "obj2", id: 1 }
 * console.log( obj1 ); // -> { name: "obj1", id: 2 }
 *
 * ```
 *
 * @param {Object} object The object to add the property to.
 * @param {String} prop   The name of the property.
 * @param {Function} fn   A function to get the value the property should be set to.
 * @param {boolean} writable   Whether the field should be writable (false by default).
 */
var canDefineLazyValue_1_0_2_defineLazyValue = function defineLazyValue(obj, prop, initializer, writable) {
	Object.defineProperty(obj, prop, {
		configurable: true,
		get: function() {
			// make the property writable
			Object.defineProperty(this, prop, {
				value: undefined,
				writable: true
			});

			// get the value from the initializer function
			var value = initializer.call(this, obj, prop);

			// redefine the property to the value property
			// and reset the writable flag
			Object.defineProperty(this, prop, {
				value: value,
				writable: !!writable
			});

			// return the value
			return value;
		},
		set: function(value){
			Object.defineProperty(this, prop, {
				value: value,
				writable: !!writable
			});

			return value;
		}
	});
};

var mergeValueDependencies = function mergeValueDependencies(obj, source) {
	var sourceValueDeps = source.valueDependencies;

	if (sourceValueDeps) {
		var destValueDeps = obj.valueDependencies;

		// make sure there is a valueDependencies Set
		// in the [obj] dependency record
		if (!destValueDeps) {
			destValueDeps = new Set();
			obj.valueDependencies = destValueDeps;
		}

		canReflect_1_16_7_canReflect.eachIndex(sourceValueDeps, function(dep) {
			destValueDeps.add(dep);
		});
	}
};

var mergeKeyDependencies = function mergeKeyDependencies(obj, source) {
	var sourcekeyDeps = source.keyDependencies;

	if (sourcekeyDeps) {
		var destKeyDeps = obj.keyDependencies;

		// make sure there is a keyDependencies Map
		// in the [obj] dependency record
		if (!destKeyDeps) {
			destKeyDeps = new Map();
			obj.keyDependencies = destKeyDeps;
		}

		canReflect_1_16_7_canReflect.eachKey(sourcekeyDeps, function(keys, obj) {
			var entry = destKeyDeps.get(obj);

			if (!entry) {
				entry = new Set();
				destKeyDeps.set(obj, entry);
			}

			canReflect_1_16_7_canReflect.eachIndex(keys, function(key) {
				entry.add(key);
			});
		});
	}
};

// Merges the key and value dependencies of the source object into the
// destination object
var merge = function mergeDependencyRecords(object, source) {
	mergeKeyDependencies(object, source);
	mergeValueDependencies(object, source);
	return object;
};

var properties = {
	/**
	 * @function can-event-queue/value/value.on on
	 * @parent can-event-queue/value/value
	 *
	 * @description Listen to changes in the observable's value.
	 *
	 * @signature `.on( handler[, queue='mutate'] )`
	 *
	 * This adds an event handler in the observable's [can-event-queue/value/value.handlers]
	 * tree. If this is the first handler, the observable's [can-event-queue/value/value.onBound] method is called.
	 *
	 * ```js
	 * observable.on(function(newVal){ ... });
	 * observable.on(function(newVal){ ... }, "notify");
	 * ```
	 *
	 * @param {function(*)} handler(newValue,oldValue) A handler that will be called with the new value of the
	 * observable and optionally the old value of the observable.
	 * @param {String} [queue] The [can-queues] queue this event handler should be bound to.  By default the handler will
	 * be called within the `mutate` queue.
	 */
	on: function(handler, queue) {
		this.handlers.add([queue || "mutate", handler]);
	},
	/**
	 * @function can-event-queue/value/value.off off
	 * @parent can-event-queue/value/value
	 *
	 * @description Stop listening to changes in the observable's value.
	 *
	 * @signature `.off( [handler [, queue='mutate']] )`
	 *
	 * Removes one or more event handler in the observable's [can-event-queue/value/value.handlers]
	 * tree. If the las handler is removed, the observable's [can-event-queue/value/value.onUnbound] method is called.
	 *
	 * ```js
	 * observable.off(function(newVal){ ... });
	 * observable.off(function(newVal){ ... }, "notify");
	 * observable.off();
	 * observable.off(undefined, "mutate");
	 * ```
	 *
	 * @param {function(*)} handler(newValue,oldValue) The handler to be removed.  If no handler is provided and no
	 * `queue` is provided, all handlers will be removed.
	 * @param {String} [queue] The [can-queues] queue this event handler should be removed from.
	 *
	 *  If a `handler` is
	 *  provided and no `queue` is provided, the `queue` will default to `"mutate"`.
	 *
	 *   If a `handler` is not provided, but a `queue` is provided, all handlers for the provided queue will be
	 *   removed.
	 */
	off: function(handler, queueName) {
		if (handler === undefined) {
			if (queueName === undefined) {
				this.handlers.delete([]);
			} else {
				this.handlers.delete([queueName]);
			}
		} else {
			this.handlers.delete([queueName || "mutate", handler]);
		}
	}
};

var symbols = {
	/**
	 * @function can-event-queue/value/value.can.onValue @can.onValue
	 * @parent can-event-queue/value/value
	 *
	 * @description Listen to changes in this observable value.
	 *
	 * This is an alias for [can-event-queue/value/value.on].  It satisfies [can-reflect].[can-reflect/observe.onValue].
	 */
	"can.onValue": properties.on,
	/**
	 * @function can-event-queue/value/value.can.offValue @can.offValue
	 * @parent can-event-queue/value/value
	 *
	 * @description Stop listening to changes in this observable value.
	 *
	 * This is an alias for [can-event-queue/value/value.off].  It satisfies [can-reflect].[can-reflect/observe.offValue].
	 */
	"can.offValue": properties.off,
	/**
	 * @function can-event-queue/value/value.can.dispatch @can.dispatch
	 * @parent can-event-queue/value/value
	 *
	 * @description Dispatch all event handlers within their appropriate queues.
	 *
	 * @signature `@can.dispatch(newValue, oldValue)`
	 *
	 * This is a helper method that will dispatch all [can-event-queue/value/value.handlers] within
	 * their appropriate [can-queues] queue.
	 *
	 * Furthermore, it will make sure the handlers include useful meta data for debugging.
	 *
	 * ```js
	 * var observable = mixinValueBindings({});
	 * observable[canSymbol.for("can.dispatch")]( 2, 1 );
	 * ```
	 *
	 * @param {Any} newValue The new value of the observable.
	 * @param {Any} oldValue The old value of the observable.
	 */
	"can.dispatch": function(value, old) {
		canQueues_1_1_0_canQueues.enqueueByQueue(
			this.handlers.getNode([]),
			this,
			[value, old]
			//!steal-remove-start
			/* jshint laxcomma: true */
			, null
			, [canReflect_1_16_7_canReflect.getName(this), "changed to", value, "from", old]
			/* jshint laxcomma: false */
			//!steal-remove-end
		);
		//!steal-remove-start
		if (typeof this._log === "function") {
			this._log(old, value);
		}
		//!steal-remove-end
	},
	/**
	 * @function can-event-queue/value/value.can.getWhatIChange @can.getWhatIChange
	 * @parent can-event-queue/value/value
	 *
	 * @description Return observables whose values are affected by attached event handlers
	 * @signature `@can.getWhatIChange()`
	 *
	 * The `@@can.getWhatIChange` symbol is added to make sure [can-debug] can report
	 * all the observables whose values are set by value-like observables.
	 *
	 * This function iterates over the event handlers attached to  the observable's value
	 * event and collects the result of calling `@@can.getChangesDependencyRecord` on each
	 * handler; this symbol allows the caller to tell what observables are being mutated
	 * by the event handler when it is executed.
	 *
	 * In the following example a [can-simple-observable] instance named `month` is
	 * created and when its value changes the `age` property of the `map` [can-simple-map]
	 * instance is set. The event handler that causes the mutation is then decatorated with
	 * `@@can.getChangesDependencyRecord` to register the mutation dependency.
	 *
	 * ```js
	 * var month = new SimpleObservable(11);
	 * var map = new SimpleMap({ age: 30 });
	 * var canReflect = require("can-reflect");
	 *
	 * var onValueChange = function onValueChange() {
	 *	map.set("age", 31);
	 * };
	 *
	 * onValueChange[canSymbol.for("can.getChangesDependencyRecord")] = function() {
	 *	return {
	 *		keyDependencies: new Map([ [map, new Set(["age"])] ])
	 *	}
	 * };
	 *
	 * canReflect.onValue(month, onValueChange);
	 * month[canSymbol.for("can.getWhatIChange")]();
	 * ```
	 *
	 * The dependency records collected from the event handlers are divided into
	 * two categories:
	 *
	 * - mutate: Handlers in the mutate/domUI queues
	 * - derive: Handlers in the notify queue
	 *
	 * Since event handlers are added by default to the "mutate" queue, calling
	 * `@@can.getWhatIChange` on the `month` instance returns an object with a mutate
	 * property and the `keyDependencies` Map registered on the `onValueChange` handler.
	 *
	 * If multiple event handlers were attached to `month`, the dependency records
	 * of each handler are merged by `@@can.getWhatIChange`. Please check out the
	 * [can-reflect-dependencies] docs to learn more about how this symbol is used
	 * to keep track of custom observable dependencies.
	 */
	"can.getWhatIChange": function getWhatIChange() {
		//!steal-remove-start
		var whatIChange = {};

		var notifyHandlers = this.handlers.get(["notify"]);
		var mutateHandlers = [].concat(
			this.handlers.get(["mutate"]),
			this.handlers.get(["domUI"])
		);

		if (notifyHandlers.length) {
			notifyHandlers.forEach(function(handler) {
				var changes = canReflect_1_16_7_canReflect.getChangesDependencyRecord(handler);

				if (changes) {
					var record = whatIChange.derive;
					if (!record) {
						record = (whatIChange.derive = {});
					}
					merge(record, changes);
				}
			});
		}

		if (mutateHandlers.length) {
			mutateHandlers.forEach(function(handler) {
				var changes = canReflect_1_16_7_canReflect.getChangesDependencyRecord(handler);

				if (changes) {
					var record = whatIChange.mutate;
					if (!record) {
						record = (whatIChange.mutate = {});
					}
					merge(record, changes);
				}
			});
		}

		return Object.keys(whatIChange).length ? whatIChange : undefined;
		//!steal-remove-end
	},

	/**
	 * @function can-event-queue/value/value.can.isBound @can.isBound
	 * @parent can-event-queue/value/value
	 */
	"can.isBound": function isBound() {
		return this.handlers.size() > 0;
	}
};

/**
 * @property {can-key-tree} can-event-queue/value/value.handlers handlers
 * @parent can-event-queue/value/value
 *
 * @description Access the handlers tree directly.
 *
 * @type {can-key-tree}
 *
 *  The handlers property is a [can-define-lazy-value lazily] defined property containing
 *  all handlers bound with [can-event-queue/value/value.on] and
 *  [can-event-queue/value/value.can.onValue].  It is a [can-key-tree] defined like:
 *
 *  ```js
 *  this.handlers = new KeyTree([Object, Array])
 *  ```
 *
 *  It is configured to call [can-event-queue/value/value.onBound] and
 *  [can-event-queue/value/value.onUnbound] on the instances when the first item is
 *  added to the tree and when the tree is emptied.
 */
function defineLazyHandlers(){
	return new canKeyTree_1_0_2_canKeyTree([Object, Array], {
		onFirst: this.onBound !== undefined && this.onBound.bind(this),
		onEmpty: this.onUnbound !== undefined && this.onUnbound.bind(this)
	});
}

/**
 * @function can-event-queue/value/value.onBound onBound
 * @parent can-event-queue/value/value
 *
 * @description Perform operations when an observable is gains its first event handler.
 *
 * @signature `.onBound()`
 *
 * This method is not implemented by `can-event-queue/value/value`. Instead, the object
 * should implement it if it wants to perform some actions when it becomes bound.
 *
 * ```js
 * var mixinValueBindings = require("can-event-queue/value/value");
 *
 * var observable = mixinValueBindings({
 *   onBound: function(){
 *     console.log("I AM BOUND!");
 *   }
 * });
 *
 * observable.on(function(){});
 * // Logs: "I AM BOUND!"
 * ```
 *
 */

 /**
  * @function can-event-queue/value/value.onUnbound onUnbound
  * @parent can-event-queue/value/value
  *
  * @description Perform operations when an observable loses all of its event handlers.
  *
  * @signature `.onBound()`
  *
  * This method is not implemented by `can-event-queue/value/value`. Instead, the object
  * should implement it if it wants to perform some actions when it becomes unbound.
  *
  * ```js
  * var mixinValueBindings = require("can-event-queue/value/value");
  *
  * var observable = mixinValueBindings({
  *   onUnbound: function(){
  *     console.log("I AM UNBOUND!");
  *   }
  * });
  * var handler = function(){}
  * observable.on(function(){});
  * observable.off(function(){});
  * // Logs: "I AM UNBOUND!"
  * ```
  */

/**
 * @module {function} can-event-queue/value/value
 * @parent can-event-queue
 *
 * @description Mixin methods and symbols to make this object or prototype object
 * behave like a single-value observable.
 *
 * @signature `mixinValueBindings( obj )`
 *
 * Adds symbols and methods that make `obj` or instances having `obj` on their prototype
 * behave like single-value observables.
 *
 * When `mixinValueBindings` is called on an `obj` like:
 *
 * ```js
 * var mixinValueBindings = require("can-event-queue/value/value");
 *
 * var observable = mixinValueBindings({});
 *
 * observable.on(function(newVal, oldVal){
 *   console.log(newVal);
 * });
 *
 * observable[canSymbol.for("can.dispatch")](2,1);
 * // Logs: 2
 * ```
 *
 * `mixinValueBindings` adds the following properties and symbols to the object:
 *
 * - [can-event-queue/value/value.on]
 * - [can-event-queue/value/value.off]
 * - [can-event-queue/value/value.can.dispatch]
 * - [can-event-queue/value/value.can.getWhatIChange]
 * - [can-event-queue/value/value.handlers]
 *
 * When the object is bound to for the first time with `.on` or `@can.onValue`, it will look for an [can-event-queue/value/value.onBound]
 * function on the object and call it.
 *
 * When the object is has no more handlers, it will look for an [can-event-queue/value/value.onUnbound]
 * function on the object and call it.
 */
var mixinValueEventBindings = function(obj) {
	canReflect_1_16_7_canReflect.assign(obj, properties);
	canReflect_1_16_7_canReflect.assignSymbols(obj, symbols);
	canDefineLazyValue_1_0_2_defineLazyValue(obj,"handlers",defineLazyHandlers, true);
	return obj;
};

// callbacks is optional
mixinValueEventBindings.addHandlers = function(obj, callbacks) {
	console.warn("can-event-queue/value: Avoid using addHandlers. Add onBound and onUnbound methods instead.");
	obj.handlers = new canKeyTree_1_0_2_canKeyTree([Object, Array], callbacks);
	return obj;
};

var value = mixinValueEventBindings;

// # Recorder Dependency Helpers
// This exposes two helpers:
// - `updateObservations` - binds and unbinds a diff of two observation records
//   (see can-observation-recorder for details on this data type).
// - `stopObserving` - unbinds an observation record.




// ## Helpers
// The following helpers all use `this` to pass additional arguments. This
// is for performance reasons as it avoids creating new functions.

function addNewKeyDependenciesIfNotInOld(event) {
    // Expects `this` to have:
    // - `.observable` - the observable we might be binding to.
    // - `.oldEventSet` - the bound keys on the old dependency record for `observable`.
    // - `.onDependencyChange` - the handler we will call back when the key is changed.
    // If there wasn't any keys, or when we tried to delete we couldn't because the key
    // wasn't in the set, start binding.
    if(this.oldEventSet === undefined || this.oldEventSet["delete"](event) === false) {
        canReflect_1_16_7_canReflect.onKeyValue(this.observable, event, this.onDependencyChange,"notify");
    }
}

// ### addObservablesNewKeyDependenciesIfNotInOld
// For each event in the `eventSet` of new observables,
// setup a binding (or delete the key).
function addObservablesNewKeyDependenciesIfNotInOld(eventSet, observable){
    eventSet.forEach(addNewKeyDependenciesIfNotInOld, {
        onDependencyChange: this.onDependencyChange,
        observable: observable,
        oldEventSet: this.oldDependencies.keyDependencies.get(observable)
    });
}

function removeKeyDependencies(event) {
    canReflect_1_16_7_canReflect.offKeyValue(this.observable, event, this.onDependencyChange,"notify");
}

function removeObservablesKeyDependencies(oldEventSet, observable){
    oldEventSet.forEach(removeKeyDependencies, {onDependencyChange: this.onDependencyChange, observable: observable});
}

function addValueDependencies(observable) {
    // If we were unable to delete the key in the old set, setup a binding.
    if(this.oldDependencies.valueDependencies.delete(observable) === false) {
        canReflect_1_16_7_canReflect.onValue(observable, this.onDependencyChange,"notify");
    }
}
function removeValueDependencies(observable) {
    canReflect_1_16_7_canReflect.offValue(observable, this.onDependencyChange,"notify");
}


var canObservation_4_0_1_recorderDependencyHelpers = {
    // ## updateObservations
    //
    // Binds `observationData.onDependencyChange` to dependencies in `observationData.newDependencies` that are not currently in
    // `observationData.oldDependencies`.  Anything in `observationData.oldDependencies`
    // left over is unbound.
    //
    // The algorthim works by:
    // 1. Loop through the `new` dependencies, checking if an equivalent is in the `old` bindings.
    //    - If there is an equivalent binding, delete that dependency from `old`.
    //    - If there is __not__ an equivalent binding, setup a binding from that dependency to `.onDependencyChange`.
    // 2. Loop through the remaining `old` dependencies, teardown bindings.
    //
    // For performance, this method mutates the values in `.oldDependencies`.
    updateObservations: function(observationData){
        observationData.newDependencies.keyDependencies.forEach(addObservablesNewKeyDependenciesIfNotInOld, observationData);
        observationData.oldDependencies.keyDependencies.forEach(removeObservablesKeyDependencies, observationData);
        observationData.newDependencies.valueDependencies.forEach(addValueDependencies, observationData);
        observationData.oldDependencies.valueDependencies.forEach(removeValueDependencies, observationData);
    },
    stopObserving: function(observationReciever, onDependencyChange){
        observationReciever.keyDependencies.forEach(removeObservablesKeyDependencies, {onDependencyChange: onDependencyChange});
        observationReciever.valueDependencies.forEach(removeValueDependencies, {onDependencyChange: onDependencyChange});
    }
};

var temporarilyBoundNoOperation = function(){};
// A list of temporarily bound computes
var observables;
// Unbinds all temporarily bound computes.
var unbindTemporarilyBoundValue = function () {
	for (var i = 0, len = observables.length; i < len; i++) {
		canReflect_1_16_7_canReflect.offValue(observables[i], temporarilyBoundNoOperation);
	}
	observables = null;
};

// ### temporarilyBind
// Binds computes for a moment to cache their value and prevent re-calculating it.
function temporarilyBind(compute) {
	var computeInstance = compute.computeInstance || compute;
	canReflect_1_16_7_canReflect.onValue(computeInstance, temporarilyBoundNoOperation);
	if (!observables) {
		observables = [];
		setTimeout(unbindTemporarilyBoundValue, 10);
	}
	observables.push(computeInstance);
}

var canObservation_4_0_1_temporarilyBind = temporarilyBind;

/* global require */
// # can-observation












var dispatchSymbol = canSymbol_1_6_1_canSymbol.for("can.dispatch");
var getChangesSymbol = canSymbol_1_6_1_canSymbol.for("can.getChangesDependencyRecord");
var getValueDependenciesSymbol = canSymbol_1_6_1_canSymbol.for("can.getValueDependencies");

// ## Observation constructor
function Observation(func, context, options){
	this.func = func;
	this.context = context;
	this.options = options || {priority: 0, isObservable: true};
	// A flag if we are bound or not
	this.bound = false;

	// These properties will manage what our new and old dependencies are.
	this.newDependencies = canObservationRecorder_1_1_2_canObservationRecorder.makeDependenciesRecord();
	this.oldDependencies = null;

	// Make functions we need to pass around and maintain `this`.
	var self = this;
	this.onDependencyChange = function(newVal){
		self.dependencyChange(this, newVal);
	};
	this.update = this.update.bind(this);


	// Add debugging names.
	//!steal-remove-start
	this.onDependencyChange[getChangesSymbol] = function getChanges() {
		return {
			valueDependencies: new Set([self])
		};
	};
	Object.defineProperty(this.onDependencyChange, "name", {
		value: canReflect_1_16_7_canReflect.getName(this) + ".onDependencyChange",
	});
	Object.defineProperty(this.update, "name", {
		value: canReflect_1_16_7_canReflect.getName(this) + ".update",
	});
	//!steal-remove-end
}

// ## Observation prototype methods

// Mixin value event bindings. This is where the following are added:
// - `.handlers` which call `onBound` and `onUnbound`
// - `.on` / `.off`
// - `can.onValue` `can.offValue`
// - `can.getWhatIChange`
value(Observation.prototype);

canReflect_1_16_7_canReflect.assign(Observation.prototype, {
	// Starts observing changes and adds event listeners.
	onBound: function(){
		this.bound = true;

		// Store the old dependencies
		this.oldDependencies = this.newDependencies;
		// Start recording dependencies.
		canObservationRecorder_1_1_2_canObservationRecorder.start();
		// Call the observation's function and update the new value.
		this.value = this.func.call(this.context);
		// Get the new dependencies.
		this.newDependencies = canObservationRecorder_1_1_2_canObservationRecorder.stop();

		// Diff and update the bindings. On change, everything will call
		// `this.onDependencyChange`, which calls `this.dependencyChange`.
		canObservation_4_0_1_recorderDependencyHelpers.updateObservations(this);
	},
	// This is called when any of the dependencies change.
	// It queues up an update in the `deriveQueue` to be run after all source
	// observables have had time to notify all observables that "derive" their value.
	dependencyChange: function(context, args){
		if(this.bound === true) {
			// Update this observation after all `notify` tasks have been run.
			canQueues_1_1_0_canQueues.deriveQueue.enqueue(
				this.update,
				this,
				[],
				{
					priority: this.options.priority
					//!steal-remove-start
					/* jshint laxcomma: true */
					, log: [ canReflect_1_16_7_canReflect.getName(this.update) ]
					/* jshint laxcomma: false */
					//!steal-remove-end
				}
				//!steal-remove-start
				/* jshint laxcomma: true */
				, [canReflect_1_16_7_canReflect.getName(context), "changed"]
				/* jshint laxcomma: false */
				//!steal-remove-end
			);
		}
	},
	// Called to update its value as part of the `derive` queue.
	update: function() {
		if (this.bound === true) {
			// Keep the old value.
			var oldValue = this.value;
			this.oldValue = null;
			// Re-run `this.func` and update dependency bindings.
			this.onBound();
			// If our value changed, call the `dispatch` method provided by `can-event-queue/value/value`.
			if (oldValue !== this.value) {
				this[dispatchSymbol](this.value, oldValue);
			}
		}
	},
	// Called when nothing is bound to this observation.
	// Removes all event listeners on all dependency observables.
	onUnbound: function(){
		this.bound = false;
		canObservation_4_0_1_recorderDependencyHelpers.stopObserving(this.newDependencies, this.onDependencyChange);
		// Setup newDependencies in case someone binds again to this observable.
		this.newDependencies = canObservationRecorder_1_1_2_canObservationRecorder.makeDependenciesRecorder();
	},
	// Reads the value of the observation.
	get: function(){

		// If an external observation is tracking observables and
		// this compute can be listened to by "function" based computes ....
		if( this.options.isObservable && canObservationRecorder_1_1_2_canObservationRecorder.isRecording() ) {

			// ... tell the tracking compute to listen to change on this observation.
			canObservationRecorder_1_1_2_canObservationRecorder.add(this);
			// ... if we are not bound, we should bind so that
			// we don't have to re-read to get the value of this observation.
			if (!this.bound) {
				Observation.temporarilyBind(this);
			}

		}


		if(this.bound === true ) {
			// It's possible that a child dependency of this observable might be queued
			// to change. Check all child dependencies and make sure they are up-to-date by
			// possibly running what they have registered in the derive queue.
			if(canQueues_1_1_0_canQueues.deriveQueue.tasksRemainingCount() > 0) {
				Observation.updateChildrenAndSelf(this);
			}

			return this.value;
		} else {
			// If we are not bound, just call the function.
			return this.func.call(this.context);
		}
	},

	hasDependencies: function(){
		var newDependencies = this.newDependencies;
		return this.bound ?
			(newDependencies.valueDependencies.size + newDependencies.keyDependencies.size) > 0  :
			undefined;
	},
	/**
	 * @function can-observation.prototype.log log
	 * @parent can-observation.prototype prototype
	 *
	 * @signature `observation.log()`
	 *
	 * Turns on logging of changes to the browser console.
	 */
	log: function() {
		//!steal-remove-start
		var quoteString = function quoteString(x) {
			return typeof x === "string" ? JSON.stringify(x) : x;
		};
		this._log = function(previous, current) {
			dev.log(
				canReflect_1_16_7_canReflect.getName(this),
				"\n is  ", quoteString(current),
				"\n was ", quoteString(previous)
			);
		};
		//!steal-remove-end
	}
});

canReflect_1_16_7_canReflect.assignSymbols(Observation.prototype, {
	"can.getValue": Observation.prototype.get,
	"can.isValueLike": true,
	"can.isMapLike": false,
	"can.isListLike": false,
	"can.valueHasDependencies": Observation.prototype.hasDependencies,
	"can.getValueDependencies": function(){
		if (this.bound === true) {
			// Only provide `keyDependencies` and `valueDependencies` properties
			// if there's actually something there.
			var deps = this.newDependencies,
				result = {};

			if (deps.keyDependencies.size) {
				result.keyDependencies = deps.keyDependencies;
			}

			if (deps.valueDependencies.size) {
				result.valueDependencies = deps.valueDependencies;
			}

			return result;
		}
		return undefined;
	},
	"can.getPriority": function(){
		return this.options.priority;
	},
	"can.setPriority": function(priority){
		this.options.priority = priority;
	},
	//!steal-remove-start
	"can.getName": function() {
		return canReflect_1_16_7_canReflect.getName(this.constructor) + "<" + canReflect_1_16_7_canReflect.getName(this.func) + ">";
	}
	//!steal-remove-end
});

// ## Observation.updateChildrenAndSelf
// This recursively checks if an observation's dependencies might be in the `derive` queue.
// If it is, we need to update that value so the reading of this value will be correct.
// This can happen if an observation suddenly switches to depending on something that has higher
// priority than itself.  We need to make sure that value is completely updated.
Observation.updateChildrenAndSelf = function(observation){
	// If the observable has an `update` method and it's enqueued, flush that task immediately so
	// the value is right.
	// > NOTE: This only works for `Observation` right now.  We need a way of knowing how
	// > to find what an observable might have in the `deriveQueue`.
	if(observation.update !== undefined && canQueues_1_1_0_canQueues.deriveQueue.isEnqueued( observation.update ) === true) {
		// TODO: In the future, we should be able to send log information
		// to explain why this needed to be updated.
		canQueues_1_1_0_canQueues.deriveQueue.flushQueuedTask(observation.update);
		return true;
	}

	// If we can get dependency values from this observable ...
	if(observation[getValueDependenciesSymbol]) {
		// ... Loop through each dependency and see if any of them (or their children) needed an update.
		var childHasChanged = false;
		var valueDependencies = observation[getValueDependenciesSymbol]().valueDependencies || [];
		valueDependencies.forEach(function(observable){
			if( Observation.updateChildrenAndSelf( observable ) === true) {
				childHasChanged = true;
			}
		});
		return childHasChanged;
	} else {
		return false;
	}
};

// ## Legacy Stuff
// Warn when `ObservationRecorder` methods are called on `Observation`.
var alias = {addAll: "addMany"};
["add","addAll","ignore","trap","trapsCount","isRecording"].forEach(function(methodName){
	Observation[methodName] = function(){
		var name = alias[methodName] ? alias[methodName] : methodName;
		console.warn("can-observation: Call "+name+"() on can-observation-recorder.");
		return canObservationRecorder_1_1_2_canObservationRecorder[name].apply(this, arguments);
	};
});
Observation.prototype.start = function(){
	console.warn("can-observation: Use .on and .off to bind.");
	return this.onBound();
};
Observation.prototype.stop = function(){
	console.warn("can-observation: Use .on and .off to bind.");
	return this.onUnbound();
};

// ### temporarilyBind
// Will bind an observable value temporarily.  This should be part of queues probably.
Observation.temporarilyBind = canObservation_4_0_1_temporarilyBind;


var canObservation_4_0_1_canObservation = canNamespace_1_0_0_canNamespace.Observation = Observation;

// when printing out strings to the console, quotes are not included which
// makes it confusing to tell the actual output from static string messages
function quoteString(x) {
	return typeof x === "string" ? JSON.stringify(x) : x;
}

// To add the `.log` function to a observable
// a.- Add the log function to the propotype:
//	   `Observable.propotype.log = log`
// b.- Make sure `._log` is called by the observable when mutation happens
//     `_.log` should be passed the current value and the value before the mutation
var canSimpleObservable_2_0_5_log = function log() {
	//!steal-remove-start
	this._log = function(previous, current) {
		dev.log(
			canReflect_1_16_7_canReflect.getName(this),
			"\n is  ", quoteString(current),
			"\n was ", quoteString(previous)
		);
	};
	//!steal-remove-end
};

var dispatchSymbol$1 = canSymbol_1_6_1_canSymbol.for("can.dispatch");

/**
 * @module {function} can-simple-observable
 * @parent can-observables
 * @collection can-infrastructure
 * @package ./package.json
 * @description Create an observable value.
 *
 * @signature `new SimpleObservable(initialValue)`
 *
 * Creates an observable value that can be read, written, and observed using [can-reflect].
 *
 * @param {*} initialValue The initial value of the observable.
 *
 * @return {can-simple-observable} An observable instance
 *
 * @body
 *
 * ## Use
 *
 * ```js
 *  var obs = new SimpleObservable('one');
 *
 *  canReflect.getValue(obs); // -> "one"
 *
 *  canReflect.setValue(obs, 'two');
 *  canReflect.getValue(obs); // -> "two"
 *
 *  function handler(newValue) {
 *    // -> "three"
 *  };
 *  canReflect.onValue(obs, handler);
 *  canReflect.setValue(obs, 'three');
 *
 *  canReflect.offValue(obs, handler);
 * ```
 */
function SimpleObservable(initialValue) {
	this.value = initialValue;
}

// mix in the value-like object event bindings
value(SimpleObservable.prototype);

Object.assign(SimpleObservable.prototype, {
	log: canSimpleObservable_2_0_5_log,
	get: function(){
		canObservationRecorder_1_1_2_canObservationRecorder.add(this);
		return this.value;
	},
	set: function(value$$1){
		var old = this.value;
		this.value = value$$1;

		this[dispatchSymbol$1](value$$1, old);
	}
});

canReflect_1_16_7_canReflect.assignSymbols(SimpleObservable.prototype, {
	"can.getValue": SimpleObservable.prototype.get,
	"can.setValue": SimpleObservable.prototype.set,
	"can.isMapLike": false,
	"can.valueHasDependencies": function(){
		return true;
	},
	//!steal-remove-start
	"can.getName": function() {
		var value$$1 = this.value;
		if (typeof value$$1 !== 'object' || value$$1 === null) {
			value$$1 = JSON.stringify(value$$1);
		}
		else {
			value$$1 = '';
		}

		return canReflect_1_16_7_canReflect.getName(this.constructor) + "<" + value$$1 + ">";
	},
	//!steal-remove-end
});

var canSimpleObservable_2_0_5_canSimpleObservable = canNamespace_1_0_0_canNamespace.SimpleObservable = SimpleObservable;

var peek = canObservationRecorder_1_1_2_canObservationRecorder.ignore(canReflect_1_16_7_canReflect.getValue.bind(canReflect_1_16_7_canReflect));

// This supports an "internal" settable value that the `fn` can derive its value from.
// It's useful to `can-define`.
// ```
// new SettableObservable(function(lastSet){
//   return lastSet * 5;
// }, null, 5)
// ```
function SettableObservable(fn, context, initialValue) {

	this.lastSetValue = new canSimpleObservable_2_0_5_canSimpleObservable(initialValue);
	function observe() {
		return fn.call(context, this.lastSetValue.get());
	}
	this.handler = this.handler.bind(this);

	//!steal-remove-start
	canReflect_1_16_7_canReflect.assignSymbols(this, {
		"can.getName": function() {
			return (
				canReflect_1_16_7_canReflect.getName(this.constructor) +
				"<" +
				canReflect_1_16_7_canReflect.getName(fn) +
				">"
			);
		}
	});
	Object.defineProperty(this.handler, "name", {
		value: canReflect_1_16_7_canReflect.getName(this) + ".handler"
	});
	Object.defineProperty(observe, "name", {
		value: canReflect_1_16_7_canReflect.getName(fn) + "::" + canReflect_1_16_7_canReflect.getName(this.constructor)
	});
	//!steal-remove-end

	this.observation = new canObservation_4_0_1_canObservation(observe, this);
}

value(SettableObservable.prototype);

Object.assign(SettableObservable.prototype, {
	// call `obs.log()` to log observable changes to the browser console
	// The observable has to be bound for `.log` to be called
	log: canSimpleObservable_2_0_5_log,
	constructor: SettableObservable,
	handler: function(newVal) {
		var old = this.value;
		this.value = newVal;

		//!steal-remove-start
		if (typeof this._log === "function") {
			this._log(old, newVal);
		}
		//!steal-remove-end

		// adds callback handlers to be called w/i their respective queue.
		canQueues_1_1_0_canQueues.enqueueByQueue(
			this.handlers.getNode([]),
			this,
			[newVal, old],
			function() {
				return {};
			}
		);
	},
	onBound: function() {
		// onBound can be called by `.get` and then later called through
		// a keyTree binding.
		if(!this.bound) {
			this.bound = true;
			this.activate();
		}
	},
	activate: function(){
		canReflect_1_16_7_canReflect.onValue(this.observation, this.handler, "notify");
		this.value = peek(this.observation);
	},
	onUnbound: function() {
		this.bound = false;
		canReflect_1_16_7_canReflect.offValue(this.observation, this.handler, "notify");
	},
	set: function(newVal) {
		var oldVal =  this.lastSetValue.get();

		if (
			canReflect_1_16_7_canReflect.isObservableLike(oldVal) &&
			canReflect_1_16_7_canReflect.isValueLike(oldVal) &&
			!canReflect_1_16_7_canReflect.isObservableLike(newVal)
		) {
			canReflect_1_16_7_canReflect.setValue(oldVal, newVal);
		} else {
			if (newVal !== oldVal) {
				this.lastSetValue.set(newVal);
			}
		}
	},
	get: function() {
		if (canObservationRecorder_1_1_2_canObservationRecorder.isRecording()) {
			canObservationRecorder_1_1_2_canObservationRecorder.add(this);
			if (!this.bound) {
				// proactively setup bindings
				this.onBound();
			}
		}

		if (this.bound === true) {
			return this.value;
		} else {
			return this.observation.get();
		}
	},
	hasDependencies: function() {
		return canReflect_1_16_7_canReflect.valueHasDependencies(this.observation);
	},
	getValueDependencies: function() {
		return canReflect_1_16_7_canReflect.getValueDependencies(this.observation);
	}
});

canReflect_1_16_7_canReflect.assignSymbols(SettableObservable.prototype, {
	"can.getValue": SettableObservable.prototype.get,
	"can.setValue": SettableObservable.prototype.set,
	"can.isMapLike": false,
	"can.getPriority": function() {
		return canReflect_1_16_7_canReflect.getPriority(this.observation);
	},
	"can.setPriority": function(newPriority) {
		canReflect_1_16_7_canReflect.setPriority(this.observation, newPriority);
	},
	"can.valueHasDependencies": SettableObservable.prototype.hasDependencies,
	"can.getValueDependencies": SettableObservable.prototype.getValueDependencies
});

var settable = SettableObservable;

// This is an observable that is like `settable`, but passed a `resolve`
// function that can resolve the value of this observable late.
function AsyncObservable(fn, context, initialValue) {
	this.resolve = this.resolve.bind(this);
	this.lastSetValue = new canSimpleObservable_2_0_5_canSimpleObservable(initialValue);
	this.handler = this.handler.bind(this);

	function observe() {
		this.resolveCalled = false;

		// set inGetter flag to avoid calling `resolve` redundantly if it is called
		// synchronously in the getter
		this.inGetter = true;
		var newVal = fn.call(
			context,
			this.lastSetValue.get(),
			this.bound === true ? this.resolve : undefined
		);
		this.inGetter = false;

		// if the getter returned a value, resolve with the value
		if (newVal !== undefined) {
			this.resolve(newVal);
		}
		// otherwise, if `resolve` was called synchronously in the getter,
		// resolve with the value passed to `resolve`
		else if (this.resolveCalled) {
			this.resolve(this.value);
		}

		// if bound, the handlers will be called by `resolve`
		// returning here would cause a duplicate event
		if (this.bound !== true) {
			return newVal;
		}
	}

	//!steal-remove-start
	canReflect_1_16_7_canReflect.assignSymbols(this, {
		"can.getName": function() {
			return (
				canReflect_1_16_7_canReflect.getName(this.constructor) +
				"<" +
				canReflect_1_16_7_canReflect.getName(fn) +
				">"
			);
		}
	});
	Object.defineProperty(this.handler, "name", {
		value: canReflect_1_16_7_canReflect.getName(this) + ".handler"
	});
	Object.defineProperty(observe, "name", {
		value: canReflect_1_16_7_canReflect.getName(fn) + "::" + canReflect_1_16_7_canReflect.getName(this.constructor)
	});
	//!steal-remove-end

	this.observation = new canObservation_4_0_1_canObservation(observe, this);
}
AsyncObservable.prototype = Object.create(settable.prototype);
AsyncObservable.prototype.constructor = AsyncObservable;

AsyncObservable.prototype.handler = function(newVal) {
	if (newVal !== undefined) {
		settable.prototype.handler.apply(this, arguments);
	}
};

var peek$1 = canObservationRecorder_1_1_2_canObservationRecorder.ignore(canReflect_1_16_7_canReflect.getValue.bind(canReflect_1_16_7_canReflect));
AsyncObservable.prototype.activate = function() {
	canReflect_1_16_7_canReflect.onValue(this.observation, this.handler, "notify");
	if (!this.resolveCalled) {
		this.value = peek$1(this.observation);
	}
};

AsyncObservable.prototype.resolve = function resolve(newVal) {
	this.resolveCalled = true;
	var old = this.value;
	this.value = newVal;

	//!steal-remove-start
	if (typeof this._log === "function") {
		this._log(old, newVal);
	}
	//!steal-remove-end

	// if resolve was called synchronously from the getter, do not enqueue changes
	// the observation will handle calling resolve again if required
	if (!this.inGetter) {
		// adds callback handlers to be called w/i their respective queue.
		canQueues_1_1_0_canQueues.enqueueByQueue(
			this.handlers.getNode([]),
			this,
			[newVal, old],
			null
			//!steal-remove-start
			/* jshint laxcomma: true */
			, [canReflect_1_16_7_canReflect.getName(this), "resolved with", newVal]
			/* jshint laxcomma: false */
			//!steal-remove-end
		);
	}
};

var async = AsyncObservable;

function dispatch(key) {
	// jshint -W040
	var handlers = this.eventHandlers[key];
	if (handlers) {
		var handlersCopy = handlers.slice();
		var value = this.getKeyValue(key);
		for (var i = 0; i < handlersCopy.length; i++) {
			handlersCopy[i](value);
		}
	}
}

function Globals() {
	this.eventHandlers = {};
	this.properties = {};
}

/**
 * @function define 
 * @parent can-globals/methods
 * 
 * Create a new global environment variable.
 * 
 * @signature `globals.define(key, value[, cache])`
 * 
 * Defines a new global called `key`, who's value defaults to `value`.
 * 
 * The following example defines the `global` key's default value to the [`window`](https://developer.mozilla.org/en-US/docs/Web/API/Window) object:
 * ```javascript
 * globals.define('global', window);
 * globals.getKeyValue('window') //-> window
 * ```
 * 
 * If a function is provided and `cache` is falsy, that function is run every time the key value is read:
 * ```javascript
 * globals.define('isBrowserWindow', function() {
 *   console.log('EVALUATING')
 *   return typeof window !== 'undefined' &&
 *     typeof document !== 'undefined' && typeof SimpleDOM === 'undefined'
 * }, false);
 * globals.get('isBrowserWindow') // logs 'EVALUATING'
 *                                // -> true
 * globals.get('isBrowserWindow') // logs 'EVALUATING' again
 *                                // -> true
 * ```
 * 
 * If a function is provided and `cache` is truthy, that function is run only the first time the value is read:
 * ```javascript
 * globals.define('isWebkit', function() {
 *   console.log('EVALUATING')
 *   var div = document.createElement('div')
 *   return 'WebkitTransition' in div.style
 * })
 * globals.getKeyValue('isWebkit') // logs 'EVALUATING'
 * 								   // -> true
 * globals.getKeyValue('isWebkit') // Does NOT log again!
 * 								   // -> true
 * ```
 * 
 * @param {String} key
 * The key value to create.
 * 
 * @param {*} value
 * The default value. If this is a function, its return value will be used.
 * 
 * @param {Boolean} [cache=true]
 * Enable cache. If false the `value` function is run every time the key value is read.
 * 
 * @return {can-globals}
 * Returns the instance of `can-globals` for chaining.
 */
Globals.prototype.define = function (key, value, enableCache) {
	if (enableCache === undefined) {
		enableCache = true;
	}
	if (!this.properties[key]) {
		this.properties[key] = {
			default: value,
			value: value,
			enableCache: enableCache
		};
	}
	return this;
};

/**
 * @function getKeyValue 
 * @parent can-globals/methods
 * 
 * Get a global environment variable by name.
 * 
 * @signature `globals.getKeyValue(key)`
 * 
 * Returns the current value at `key`. If no value has been set, it will return the default value (if it is not a function). If the default value is a function, it will return the output of the function. This execution is cached if the cache flag was set on initialization.
 * 
 * ```javascript
 * globals.define('foo', 'bar');
 * globals.getKeyValue('foo'); //-> 'bar'
 * ```
 * 
 * @param {String} key
 * The key value to access.
 * 
 * @return {*}
 * Returns the value of a given key.
 */
Globals.prototype.getKeyValue = function (key) {
	var property = this.properties[key];
	if (property) {
		if (typeof property.value === 'function') {
			if (property.cachedValue) {
				return property.cachedValue;
			}
			if (property.enableCache) {
				property.cachedValue = property.value();
				return property.cachedValue;
			} else {
				return property.value();
			}
		}
		return property.value;
	}
};

Globals.prototype.makeExport = function (key) {
	return function (value) {
		if (arguments.length === 0) {
			return this.getKeyValue(key);
		}

		if (typeof value === 'undefined' || value === null) {
			this.deleteKeyValue(key);
		} else {
			if (typeof value === 'function') {
				this.setKeyValue(key, function () {
					return value;
				});
			} else {
				this.setKeyValue(key, value);
			}
			return value;
		}
	}.bind(this);
};

/**
 * @function offKeyValue 
 * @parent can-globals/methods
 * 
 * Remove handler from event queue.
 * 
 * @signature `globals.offKeyValue(key, handler)`
 * 
 * Removes `handler` from future change events for `key`.
 * 
 * 
 * ```javascript
 * var handler = (value) => {
 *   value === 'baz' //-> true
 * };
 * globals.define('foo', 'bar');
 * globals.onKeyValue('foo', handler);
 * globals.setKeyValue('foo', 'baz');
 * globals.offKeyValue('foo', handler);
 * ```
 * 
 * @param {String} key
 * The key value to observe.
 * 
 * @param {Function} handler([value])
 * The observer callback.
 * 
 * @return {can-globals}
 * Returns the instance of `can-globals` for chaining.
 */
Globals.prototype.offKeyValue = function (key, handler) {
	if (this.properties[key]) {
		var handlers = this.eventHandlers[key];
		if (handlers) {
			var i = handlers.indexOf(handler);
			handlers.splice(i, 1);
		}
	}
	return this;
};

/**
 * @function onKeyValue 
 * @parent can-globals/methods
 * 
 * Add handler to event queue.
 * 
 * @signature `globals.onKeyValue(key, handler)`
 * 
 * Calls `handler` each time the value of `key` is set or reset.
 * 
 * ```javascript
 * globals.define('foo', 'bar');
 * globals.onKeyValue('foo', (value) => {
 *   value === 'baz' //-> true
 * });
 * globals.setKeyValue('foo', 'baz');
 * ```
 * 
 * @param {String} key
 * The key value to observe.
 * 
 * @param {function(*)} handler([value])
 * The observer callback.
 * 
 * @return {can-globals}
 * Returns the instance of `can-globals` for chaining.
 */
Globals.prototype.onKeyValue = function (key, handler) {
	if (this.properties[key]) {
		if (!this.eventHandlers[key]) {
			this.eventHandlers[key] = [];
		}
		this.eventHandlers[key].push(handler);
	}
	return this;
};

/**
 * @function deleteKeyValue 
 * @parent can-globals/methods
 * 
 * Reset global environment variable.
 * 
 * @signature `globals.deleteKeyValue(key)`
 * 
 * Deletes the current value at `key`. Future `get`s will use the default value.
 * 
 * ```javascript
 * globals.define('global', window);
 * globals.setKeyValue('global', {});
 * globals.deleteKeyValue('global');
 * globals.getKeyValue('global') === window; //-> true
 * ```
 * 
 * @param {String} key
 * The key value to access.
 * 
 * @return {can-globals}
 * Returns the instance of `can-globals` for chaining.
 */
Globals.prototype.deleteKeyValue = function (key) {
	var property = this.properties[key];
	if (property !== undefined) {
		property.value = property.default;
		property.cachedValue = undefined;
		dispatch.call(this, key);
	}
	return this;
};

/**
 * @function setKeyValue 
 * @parent can-globals/methods
 * 
 * Overwrite an existing global environment variable.
 * 
 * @signature `globals.setKeyValue(key, value)`
 * 
 * ```javascript
 * globals.define('foo', 'bar');
 * globals.setKeyValue('foo', 'baz');
 * globals.getKeyValue('foo'); //-> 'baz'
 * ```
 * 
 * Sets the new value at `key`. Will override previously set values, but preserves the default (see `deleteKeyValue`).
 * 
 * Setting a key which was not previously defined will call `define` with the key and value.
 * 
 * @param {String} key
 * The key value to access.
 * 
 * @param {*} value
 * The new value.
 * 
 * @return {can-globals}
 * Returns the instance of `can-globals` for chaining.
 */
Globals.prototype.setKeyValue = function (key, value) {
	if (!this.properties[key]) {
		return this.define(key, value);
	}
	var property = this.properties[key];
	property.value = value;
	property.cachedValue = undefined;
	dispatch.call(this, key);
	return this;
};

/**
 * @function reset 
 * @parent can-globals/methods
 * 
 * Reset all keys to their default value and clear their caches.
 * 
 * @signature `globals.setKeyValue(key, value)`
 * 
 * ```javascript
 * globals.define('foo', 'bar');
 * globals.setKeyValue('foo', 'baz');
 * globals.getKeyValue('foo'); //-> 'baz'
 * globals.reset();
 * globals.getKeyValue('foo'); //-> 'bar'
 * ```
 * 
 * @return {can-globals}
 * Returns the instance of `can-globals` for chaining.
 */
Globals.prototype.reset = function () {
	for (var key in this.properties) {
		if (this.properties.hasOwnProperty(key)) {
			this.properties[key].value = this.properties[key].default;
			this.properties[key].cachedValue = undefined;
			dispatch.call(this, key);
		}
	}
	return this;
};

canReflect_1_16_7_canReflect.assignSymbols(Globals.prototype, {
	'can.getKeyValue': Globals.prototype.getKeyValue,
	'can.setKeyValue': Globals.prototype.setKeyValue,
	'can.deleteKeyValue': Globals.prototype.deleteKeyValue,
	'can.onKeyValue': Globals.prototype.onKeyValue,
	'can.offKeyValue': Globals.prototype.offKeyValue
});

var canGlobals_1_1_1_canGlobalsProto = Globals;

var canGlobals_1_1_1_canGlobalsInstance = createCommonjsModule(function (module) {


var globals = new canGlobals_1_1_1_canGlobalsProto();

if (canNamespace_1_0_0_canNamespace.globals) {
	throw new Error("You can't have two versions of can-globals, check your dependencies");
} else {
	module.exports = canNamespace_1_0_0_canNamespace.globals = globals;
}
});

/* global self */
/* global WorkerGlobalScope */



/**
 * @module {function} can-globals/global/global global
 * @parent can-globals/modules
 * 
 * Get the global object for the current context.
 * 
 * @signature `GLOBAL([newGlobal])`
 *
 * Optionally sets, and returns the global that this environment provides. It will be one of:
 * 
 * ```js
 * var GLOBAL = require('can-globals/global/global');
 * var g = GLOBAL();
 * // In a browser
 * console.log(g === window); // -> true
 * ```
 *
 * - **Browser**: [`window`](https://developer.mozilla.org/en-US/docs/Web/API/window)
 * - **Web Worker**: [`self`](https://developer.mozilla.org/en-US/docs/Web/API/Window/self)
 * - **Node.js**: [`global`](https://nodejs.org/api/globals.html#globals_global)
 * 
 * @param {Object} [newGlobal] An optional global-like object to set as the context's global 
 *
 * @return {Object} The global object for this JavaScript environment.
 */
canGlobals_1_1_1_canGlobalsInstance.define('global', function(){
	// Web Worker
	return (typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope) ? self :

		// Node.js
		typeof process === 'object' &&
		{}.toString.call(process) === '[object process]' ? commonjsGlobal :

		// Browser window
		window;
});

var global_1 = canGlobals_1_1_1_canGlobalsInstance.makeExport('global');

/**
 * @module {function} can-globals/document/document document
 * @parent can-globals/modules
 * 
 * Get the global [`document`](https://developer.mozilla.org/en-US/docs/Web/API/document) object for the current context.
 * 
 * @signature `DOCUMENT([newDocument])`
 * 
 * Optionally sets, and returns, the [`document`](https://developer.mozilla.org/en-US/docs/Web/API/document) object for the context.
 * 
 * ```js
 * var documentShim = { getElementById() {...} };
 * var DOCUMENT = require('can-globals/document/document');
 * DOCUMENT(documentShim); //-> document
 * DOCUMENT().getElementById('foo');
 * ```
 *
 * @param {Object} [newDocument] An optional document-like object to set as the context's document 
 * 
 * @return {Object} The window object for this JavaScript environment.
 */
canGlobals_1_1_1_canGlobalsInstance.define('document', function(){
	return canGlobals_1_1_1_canGlobalsInstance.getKeyValue('global').document;
});

var document$1 = canGlobals_1_1_1_canGlobalsInstance.makeExport('document');

/**
 * @module {function} can-globals/is-node/is-node is-node
 * @parent can-globals/modules
 * @description Determines if your code is running in [Node.js](https://nodejs.org).
 * @signature `isNode()`
 *
 * ```js
 * var isNode = require("can-globals/is-node/is-node");
 * var GLOBAL = require("can-globals/global/global");
 *
 * if(isNode()) {
 *   console.log(GLOBAL() === global); // -> true
 * }
 * ```
 *
 * @return {Boolean} True if running in Node.js
 */

canGlobals_1_1_1_canGlobalsInstance.define('isNode', function(){
	return typeof process === "object" &&
		{}.toString.call(process) === "[object process]";
});

var isNode = canGlobals_1_1_1_canGlobalsInstance.makeExport('isNode');

// This module depends on isNode being defined


/**
 * @module {function} can-globals/is-browser-window/is-browser-window is-browser-window
 * @parent can-globals/modules
 * @signature `isBrowserWindow()`
 *
 * Returns `true` if the code is running within a Browser window. Use this function if you need special code paths for when running in a Browser window, a Web Worker, or another environment (such as Node.js).
 *
 * ```js
 * var isBrowserWindow = require("can-globals/is-browser-window/is-browser-window");
 * var GLOBAL = require("can-globals/global/global");
 *
 * if(isBrowserWindow()) {
 *   console.log(GLOBAL() === window); // -> true
 * }
 * ```
 *
 * @return {Boolean} True if the environment is a Browser window.
 */

canGlobals_1_1_1_canGlobalsInstance.define('isBrowserWindow', function(){
	var isNode = canGlobals_1_1_1_canGlobalsInstance.getKeyValue('isNode');
	return typeof window !== "undefined" &&
		typeof document !== "undefined" &&
		isNode === false;
});

var isBrowserWindow = canGlobals_1_1_1_canGlobalsInstance.makeExport('isBrowserWindow');

function getTargetDocument (target) {
	return target.ownerDocument || document$1();
}

function createEvent (target, eventData, bubbles, cancelable) {
	var doc = getTargetDocument(target);
	var event = doc.createEvent('HTMLEvents');
	var eventType;
	if (typeof eventData === 'string') {
		eventType = eventData;
	} else {
		eventType = eventData.type;
		for (var prop in eventData) {
			if (event[prop] === undefined) {
				event[prop] = eventData[prop];
			}
		}
	}
	if (bubbles === undefined) {
		bubbles = true;
	}
	event.initEvent(eventType, bubbles, cancelable);
	return event;
}

// We do not account for all EventTarget classes,
// only EventTarget DOM nodes, fragments, and the window.
function isDomEventTarget (obj) {
	if (!(obj && obj.nodeName)) {
		return obj === window;
	}
	var nodeType = obj.nodeType;
	return (
		nodeType === 1 || // Node.ELEMENT_NODE
		nodeType === 9 || // Node.DOCUMENT_NODE
		nodeType === 11 // Node.DOCUMENT_FRAGMENT_NODE
	);
}

function addDomContext (context, args) {
	if (isDomEventTarget(context)) {
		args = Array.prototype.slice.call(args, 0);
		args.unshift(context);
	}
	return args;
}

function removeDomContext (context, args) {
	if (!isDomEventTarget(context)) {
		args = Array.prototype.slice.call(args, 0);
		context = args.shift();
	}
	return {
		context: context,
		args: args
	};
}

var fixSyntheticEventsOnDisabled = false;
// In FireFox, dispatching a synthetic event on a disabled element throws an error.
// Other browsers, like IE 10 do not dispatch synthetic events on disabled elements at all.
// This determines if we have to work around that when dispatching events.
// https://bugzilla.mozilla.org/show_bug.cgi?id=329509
(function() {
	if(!isBrowserWindow()) {
		return;
	}

	var testEventName = 'fix_synthetic_events_on_disabled_test';
	var input = document.createElement("input");
	input.disabled = true;
	var timer = setTimeout(function() {
		fixSyntheticEventsOnDisabled = true;
	}, 50);
	var onTest = function onTest (){
		clearTimeout(timer);
		input.removeEventListener(testEventName, onTest);
	};
	input.addEventListener(testEventName, onTest);
	try {
		var event = document.create('HTMLEvents');
		event.initEvent(testEventName, false);
		input.dispatchEvent(event);
	} catch(e) {
		onTest();
		fixSyntheticEventsOnDisabled = true;
	}
})();

function isDispatchingOnDisabled(element, event) {
	var eventType = event.type;
	var isInsertedOrRemoved = eventType === 'inserted' || eventType === 'removed';
	var isDisabled = !!element.disabled;
	return isInsertedOrRemoved && isDisabled;
}

function forceEnabledForDispatch (element, event) {
	return fixSyntheticEventsOnDisabled && isDispatchingOnDisabled(element, event);
}

var util = {
	createEvent: createEvent,
	addDomContext: addDomContext,
	removeDomContext: removeDomContext,
	isDomEventTarget: isDomEventTarget,
	getTargetDocument: getTargetDocument,
	forceEnabledForDispatch: forceEnabledForDispatch
};

function EventRegistry () {
	this._registry = {};
}

/**
 * @module can-dom-events/helpers/make-event-registry
 * @parent can-dom-events.helpers
 * @description Create an event registry.
 * @signature `makeEventRegistry()`
 *   @return {can-dom-events/EventRegistry}
 * @hide
 * 
 * @body
 *
 * ```js
 * var makeEventRegistry = require('can-dom-events/helpers/make-event-registry');
 * var registry = makeEventRegistry();
 *
 * var radioChange = require('can-events-dom-radiochange');
 * var removeRadioChange = registry.add(radioChange);
 *
 * registry.has('radiochange'); // => true
 * registry.get('radiochange'); // => radioChange
 *
 * removeRadioChange();
 * ```
 */
var makeEventRegistry = function makeEventRegistry () {
	return new EventRegistry();
};

/**
 * @function make-event-registry.has eventRegistry.has
 *
 * Check whether an event type has already been registered.
 *
 * @signature `eventRegistry.has( eventType )`
 * @parent can-dom-events/EventRegistry
 * @param {String} eventType The event type for which to check.
 * @return {Boolean} Whether the event type is registered.
*/
EventRegistry.prototype.has = function (eventType) {
	return !!this._registry[eventType];
};

/**
 * @function make-event-registry.get eventRegistry.get
 *
 * Retrieve an event type which has already been registered.
 *
 * @signature `eventRegistry.get( eventType )`
 * @parent can-dom-events/EventRegistry
 * @param {String} eventType The event type for which to retrieve.
 * @return {EventDefinition} The registered event definition, or undefined if unregistered.
*/
EventRegistry.prototype.get = function (eventType) {
	return this._registry[eventType];
};

/**
 * @function make-event-registry.add eventRegistry.add
 *
 * Add an event to the registry.
 *
 * @signature `eventRegistry.add( event [, eventType ] )`
 * @parent can-dom-events/EventRegistry
 * @param {EventDefinition} event The event definition to register.
 * @param {String} eventType The event type with which to register the event.
 * @return {function} The callback to remove the event from the registry.
*/
EventRegistry.prototype.add = function (event, eventType) {
	if (!event) {
		throw new Error('An EventDefinition must be provided');
	}
	if (typeof event.addEventListener !== 'function') {
		throw new TypeError('EventDefinition addEventListener must be a function');
	}
	if (typeof event.removeEventListener !== 'function') {
		throw new TypeError('EventDefinition removeEventListener must be a function');
	}

	eventType = eventType || event.defaultEventType;
	if (typeof eventType !== 'string') {
		throw new TypeError('Event type must be a string, not ' + eventType);
	}

	if (this.has(eventType)) {
		throw new Error('Event "' + eventType + '" is already registered');
	}

	this._registry[eventType] = event;
	var self = this;
	return function remove () {
		self._registry[eventType] = undefined;
	};
};

// Some events do not bubble, so delegating them requires registering the handler in the
// capturing phase.
// http://www.quirksmode.org/blog/archives/2008/04/delegating_the.html
var useCapture = function(eventType) {
	return eventType === 'focus' || eventType === 'blur';
};

function makeDelegator (domEvents) {
	var Delegator = function Delegator (parentKey){
		this.element = parentKey; // HTMLElement
		this.events = {}; // {[eventType: string]: Array<(event) -> void>}
		this.delegated = {}; // {[eventType: string]: (event) -> void}
	};

	canReflect_1_16_7_canReflect.assignSymbols( Delegator.prototype, {
		"can.setKeyValue": function(eventType, handlersBySelector){
			var handler = this.delegated[eventType] = function(ev){
				canReflect_1_16_7_canReflect.each(handlersBySelector, function(handlers, selector){
					var cur = ev.target;
					do {
						// document does not implement `.matches` but documentElement does
						var el = cur === document ? document.documentElement : cur;
						var matches = el.matches || el.msMatchesSelector;

						if (matches.call(el, selector)) {
							handlers.forEach(function(handler){
								handler.call(el, ev);
							});
						}
						// since `el` points to `documentElement` when `cur` === document,
						// we need to continue using `cur` as the loop pointer, otherwhise
						// it will never end as documentElement.parentNode === document
						cur = cur.parentNode;
					} while (cur && cur !== ev.currentTarget);
				});
			};
			this.events[eventType] = handlersBySelector;
			domEvents.addEventListener(this.element, eventType, handler, useCapture(eventType));
		},
		"can.getKeyValue": function(eventType) {
			return this.events[eventType];
		},
		"can.deleteKeyValue": function(eventType) {
			domEvents.removeEventListener(this.element, eventType, this.delegated[eventType], useCapture(eventType));
			delete this.delegated[eventType];
			delete this.events[eventType];
		},
		"can.getOwnEnumerableKeys": function() {
			return Object.keys(this.events);
		}
	});

	return Delegator;
}

var MakeDelegateEventTree = function makeDelegateEventTree (domEvents) {
	var Delegator = makeDelegator(domEvents);
	return new canKeyTree_1_0_2_canKeyTree([Map, Delegator, Object, Array]);
};

var domEvents = {
	_eventRegistry: makeEventRegistry(),

	/**
	* @function can-dom-events.addEvent addEvent
	* @parent can-dom-events.static
	*
	* Add a custom event to the global event registry.
	*
	* @signature `addEvent( event [, eventType ] )`
	*
	* ```js
	* var removeReturnEvent = domEvents.addEvent(enterEvent, "return");
	* ```
	*
	* @param {can-dom-events/EventDefinition} event The custom event definition.
	* @param {String} eventType The event type to associated with the custom event.
	* @return {function} The callback to remove the custom event from the registry.
	*/
	addEvent: function(event, eventType) {
		return this._eventRegistry.add(event, eventType);
	},

	/**
	* @function can-dom-events.addEventListener addEventListener
	*
	* Add an event listener for eventType to the target.
	*
	* @signature `addEventListener( target, eventType, ...eventArgs )`
	* @parent can-dom-events.static
	* @param {DomEventTarget} target The object to which to add the listener.
	* @param {String} eventType The event type with which to register.
	* @param {*} eventArgs The arguments which configure the associated event's behavior. This is usually a
	* function event handler.
	*/
	addEventListener: function(target, eventType) {
		var hasCustomEvent = domEvents._eventRegistry.has(eventType);
		if (hasCustomEvent) {
			var event = domEvents._eventRegistry.get(eventType);
			return event.addEventListener.apply(domEvents, arguments);
		}

		var eventArgs = Array.prototype.slice.call(arguments, 1);
		return target.addEventListener.apply(target, eventArgs);
	},

	/**
	* @function can-dom-events.removeEventListener removeEventListener
	*
	* Remove an event listener for eventType to the target.
	*
	* @signature `removeEventListener( target, eventType, ...eventArgs )`
	* @parent can-dom-events.static
	* @param {DomEventTarget} target The object to which to add the listener.
	* @param {String} eventType The event type with which to unregister.
	* @param {*} eventArgs The arguments which configure the associated event's behavior. This is usually a
	* function event handler.
	*/
	removeEventListener: function(target, eventType) {
		var hasCustomEvent = domEvents._eventRegistry.has(eventType);
		if (hasCustomEvent) {
			var event = domEvents._eventRegistry.get(eventType);
			return event.removeEventListener.apply(domEvents, arguments);
		}

		var eventArgs = Array.prototype.slice.call(arguments, 1);
		return target.removeEventListener.apply(target, eventArgs);
	},

	/**
	* @function can-dom-events.addDelegateListener addDelegateListener
	*
	* Attach a handler for an event for all elements that match the selector,
	* now or in the future, based on a root element.
	*
	* @signature `addDelegateListener( target, eventType, selector, handler )`
	*
	* ```js
	* // Prevents all anchor elements from changing the page
	* domEvents.addDelegateListener(document.body,"click", "a", function(event){
	*   event.preventDefault();
	* })
	* ```
	* @parent can-dom-events.static
	* @param {DomEventTarget} root The html element to listen to events that match selector within.
	* @param {String} eventType The event name to listen to.
	* @param {String} selector A selector to filter the elements that trigger the event.
	* @param {function} handler A function to execute at the time the event is triggered.
	*/
	addDelegateListener: function(root, eventType, selector, handler) {
		domEvents._eventTree.add([root, eventType, selector, handler]);
	},
	/**
	* @function can-dom-events.removeDelegateListener removeDelegateListener
	*
	* Remove a handler for an event for all elements that match the selector.
	*
	* @signature `removeDelegateListener( target, eventType, selector, handler )`
	*
	* ```js
	* // Prevents all anchor elements from changing the page
	* function handler(event) {
	*   event.preventDefault();
	* }
	* domEvents.addDelegateListener(document.body,"click", "a", handler);
	*
	* domEvents.removeDelegateListener(document.body,"click", "a", handler);
	* ```
	* @parent can-dom-events.static
	* @param {DomEventTarget} root The html element to listen to events that match selector within.
	* @param {String} eventType The event name to listen to.
	* @param {String} selector A selector to filter the elements that trigger the event.
	* @param {function} handler A function that was previously passed to `addDelegateListener`.
	*/
	removeDelegateListener: function(target, eventType, selector, handler) {
		domEvents._eventTree.delete([target, eventType, selector, handler]);
	},

	/**
	* @function can-dom-events.dispatch dispatch
	*
	* Create and dispatch a configured event on the target.
	*
	* @signature `dispatch( target, eventData [, bubbles ][, cancelable ] )`
	* @parent can-dom-events.static
	* @param {DomEventTarget} target The object to which to add the listener.
	* @param {Object | String} eventData The data to be assigned to the event. If it is a string, that will be the event type.
	* @param {Boolean} bubbles Whether the event should bubble; defaults to true.
	* @param {Boolean} cancelable Whether the event can be cancelled; defaults to false.
	* @return {Boolean} notCancelled Whether the event dispatched without being cancelled.
	*/
	dispatch: function(target, eventData, bubbles, cancelable) {
		var event = util.createEvent(target, eventData, bubbles, cancelable);
		var enableForDispatch = util.forceEnabledForDispatch(target, event);
		if(enableForDispatch) {
			target.disabled = false;
		}

		var ret = target.dispatchEvent(event);
		if(enableForDispatch) {
			target.disabled = true;
		}

		return ret;
	}
};

domEvents._eventTree = MakeDelegateEventTree(domEvents);





var canDomEvents_1_2_0_canDomEvents = canNamespace_1_0_0_canNamespace.domEvents = domEvents;

/**
 * @module {function} can-event-queue/map/map
 * @parent can-event-queue
 * @templateRender true
 *
 * @description Mixin methods and symbols to make this object or prototype object
 * behave like a key-value observable.
 *
 * @signature `mixinMapBindings( obj )`
 *
 * Adds symbols and methods that make `obj` or instances having `obj` on their prototype
 * behave like key-value observables.
 *
 * When `mixinMapBindings` is called on an `obj` like:
 *
 * ```js
 * var mixinMapBindings = require("can-event-queue/map/map");
 *
 * var observable = mixinValueBindings({});
 *
 * observable.on("prop",function(ev, newVal, oldVal){
 *   console.log(newVal);
 * });
 *
 * observable[canSymbol.for("can.dispatch")]("prop",[2,1]);
 * // Logs: 2
 * ```
 *
 * `mixinMapBindings` adds the following properties and symbols to the object:
 *
 * {{#each (getChildren [can-event-queue/map/map])}}
 * - [{{name}}] - {{description}}{{/each}}
 *
 * Furthermore, `mixinMapBindings` looks for the following symbols on the object's `.constructor`
 * property:
 *
 * - `@can.dispatchInstanceBoundChange` - Called when the bind status of an instance changes.
 * - `@can.dispatchInstanceOnPatches` - Called if [can-event-queue/map/map.dispatch] is called with `event.patches` as an array of
 *   patches.
 */







var isDomEventTarget$1 = util.isDomEventTarget;



var metaSymbol = canSymbol_1_6_1_canSymbol.for("can.meta"),
	dispatchBoundChangeSymbol = canSymbol_1_6_1_canSymbol.for("can.dispatchInstanceBoundChange"),
	dispatchInstanceOnPatchesSymbol = canSymbol_1_6_1_canSymbol.for("can.dispatchInstanceOnPatches"),
	onKeyValueSymbol$1 = canSymbol_1_6_1_canSymbol.for("can.onKeyValue"),
	offKeyValueSymbol = canSymbol_1_6_1_canSymbol.for("can.offKeyValue"),
	onEventSymbol = canSymbol_1_6_1_canSymbol.for("can.onEvent"),
	offEventSymbol = canSymbol_1_6_1_canSymbol.for("can.offEvent"),
	onValueSymbol$1 = canSymbol_1_6_1_canSymbol.for("can.onValue"),
	offValueSymbol = canSymbol_1_6_1_canSymbol.for("can.offValue");

var legacyMapBindings;

function addHandlers(obj, meta) {
	if (!meta.handlers) {
		// Handlers are organized by:
		// event name - the type of event bound to
		// binding type - "event" for things that expect an event object (legacy), "onKeyValue" for reflective bindings.
		// queue name - mutate, queue, etc
		// handlers - the handlers.
		meta.handlers = new canKeyTree_1_0_2_canKeyTree([Object, Object, Object, Array], {
			onFirst: function() {
				if (obj._eventSetup !== undefined) {
					obj._eventSetup();
				}
				if(obj.constructor[dispatchBoundChangeSymbol]) {
					obj.constructor[dispatchBoundChangeSymbol](obj, true);
				}
				//queues.enqueueByQueue(getLifecycleHandlers(obj).getNode([]), obj, [true]);
			},
			onEmpty: function() {
				if (obj._eventTeardown !== undefined) {
					obj._eventTeardown();
				}
				if(obj.constructor[dispatchBoundChangeSymbol]) {
					obj.constructor[dispatchBoundChangeSymbol](obj, false);
				}
				//queues.enqueueByQueue(getLifecycleHandlers(obj).getNode([]), obj, [false]);
			}
		});
	}

	if (!meta.listenHandlers) {
		// context, eventName (might be undefined), queue, handlers
		meta.listenHandlers = new canKeyTree_1_0_2_canKeyTree([Map, Map, Object, Array]);
	}
}


// getHandlers returns a KeyTree used for event handling.
// `handlers` will be on the `can.meta` symbol on the object.
// Ensure the "obj" passed as an argument has an object on @@can.meta
var ensureMeta = function ensureMeta(obj) {
	var meta = obj[metaSymbol];

	if (!meta) {
		meta = {};
		canReflect_1_16_7_canReflect.setKeyValue(obj, metaSymbol, meta);
	}
	addHandlers(obj, meta);

	return meta;
};

function stopListeningArgumentsToKeys(bindTarget, event, handler, queueName) {
	if(arguments.length && canReflect_1_16_7_canReflect.isPrimitive(bindTarget)) {
		queueName = handler;
		handler = event;
		event = bindTarget;
		bindTarget = this.context;
	}
	if(typeof event === "function") {
		queueName = handler;
		handler = event;
		event = undefined;
	}
	if(typeof handler === "string") {
		queueName = handler;
		handler = undefined;
	}
	var keys = [];
	if(bindTarget) {
		keys.push(bindTarget);
		if(event || handler || queueName) {
			keys.push(event);
			if(queueName || handler) {
				keys.push(queueName || this.defaultQueue);
				if(handler) {
					keys.push(handler);
				}
			}
		}
	}
	return keys;
}


// These are the properties we are going to add to objects
var props = {
	/**
	 * @function can-event-queue/map/map.dispatch dispatch
	 * @parent can-event-queue/map/map
	 *
	 * @description Dispatch event and key binding handlers.
	 *
	 * @signature `obj.dispatch(event, [args])`
	 *
	 * Dispatches registered [can-event-queue/map/map.addEventListener] and
	 * [can-event-queue/map/map.can.onKeyValue] value binding handlers.
	 *
	 * The following shows dispatching the `property` event and
	 * `keyValue` handlers:
	 *
	 *
	 * ```js
	 * var mixinMapBindings = require("can-event-queue/map/map");
	 *
	 * var obj = mixinMapBindings({});
	 *
	 * obj.addEventListener("property", function(event, newVal){
	 *   event.type //-> "property"
	 *   newVal     //-> 5
	 * });
	 *
	 * canReflect.onKeyValue("property", function(newVal){
	 *   newVal     //-> 5
	 * })
	 *
	 * obj.dispatch("property", [5]);
	 * ```
	 *
	 * > NOTE: Event handlers have an additional `event` argument.
	 *
	 * @param {String|Object} event The event to dispatch. If a string is passed,
	 *   it will be used as the `type` of the event that will be dispatched and dispatch matching
	 *   [can-event-queue/map/map.can.onKeyValue] bindings:
	 *
	 *   ```js
	 *   obs.dispatch("key")
	 *   ```
	 *
	 *   If `event` is an object, it __MUST__ have a `type` property. The If a string is passed,
	 *   it will be used as the `type` of the event that will be dispatched and dispatch matching
	 *   [can-event-queue/map/map.can.onKeyValue] bindings:
	 *
	 *   ```js
	 *   obs.dispatch({type: "key"})
	 *   ```
	 *
	 *   The `event` object can also have the following properties and values:
	 *   - __reasonLog__ `{Array}` - The reason this event happened. This will be passed to
	 *     [can-queues.enqueueByQueue] for debugging purposes.
	 *   - __makeMeta__ `{function}` - Details about the handler being called. This will be passed to
	 *     [can-queues.enqueueByQueue] for debugging purposes.
	 *   - __patches__ `{Array<Patch>}` - The patch objects this event represents.  The `.patches` value will be
	 *     passed to the object's `.constructor`'s `@can.dispatchInstanceOnPatches` method.
	 *
	 * @param {Array} [args] Additional arguments to pass to event handlers.
	 * @return {Object} event The resulting event object.
	 */
	dispatch: function(event, args) {
		//!steal-remove-start
		if (arguments.length > 4) {
			dev.warn('Arguments to dispatch should be an array, not multiple arguments.');
			args = Array.prototype.slice.call(arguments, 1);
		}

		if (args && !Array.isArray(args)) {
			dev.warn('Arguments to dispatch should be an array.');
			args = [args];
		}
		//!steal-remove-end

		// Don't send events if initalizing.
		if (!this.__inSetup) {
			if (typeof event === 'string') {
				event = {
					type: event
				};
			}

			var meta = ensureMeta(this);

			//!steal-remove-start
			if (!event.reasonLog) {
				event.reasonLog = [canReflect_1_16_7_canReflect.getName(this), "dispatched", '"' + event.type + '"', "with"].concat(args);
			}

			if (typeof meta._log === "function") {
				meta._log.call(this, event, args);
			}
			//!steal-remove-end
			var handlers = meta.handlers;
			var handlersByType = event.type !== undefined && handlers.getNode([event.type]);
			var dispatchConstructorPatches = event.patches && this.constructor[dispatchInstanceOnPatchesSymbol];
			var patchesNode = event.patches !== undefined && handlers.getNode(["can.patches","onKeyValue"]);
			var keysNode = event.keyChanged !== undefined && handlers.getNode(["can.keys","onKeyValue"]);
			var batch = dispatchConstructorPatches || handlersByType || patchesNode || keysNode;
			if ( batch ) {
				canQueues_1_1_0_canQueues.batch.start();
			}
			if(handlersByType) {
				if (handlersByType.onKeyValue) {
					canQueues_1_1_0_canQueues.enqueueByQueue(handlersByType.onKeyValue, this, args, event.makeMeta, event.reasonLog);
				}
				if (handlersByType.event) {
					event.batchNum = canQueues_1_1_0_canQueues.batch.number();
					var eventAndArgs = [event].concat(args);
					canQueues_1_1_0_canQueues.enqueueByQueue(handlersByType.event, this, eventAndArgs, event.makeMeta, event.reasonLog);
				}
			}
			if(keysNode) {
				canQueues_1_1_0_canQueues.enqueueByQueue(keysNode, this, [event.keyChanged], event.makeMeta, event.reasonLog);
			}
			if(patchesNode) {
				canQueues_1_1_0_canQueues.enqueueByQueue(patchesNode, this, [event.patches], event.makeMeta, event.reasonLog);
			}
			if(dispatchConstructorPatches) {
				this.constructor[dispatchInstanceOnPatchesSymbol](this, event.patches);
			}
			if ( batch ) {
				canQueues_1_1_0_canQueues.batch.stop();
			}
		}
		return event;
	},
	/**
	 * @function can-event-queue/map/map.addEventListener addEventListener
	 * @parent can-event-queue/map/map
	 *
	 * @description Register an event handler to be called when an event is dispatched.
	 *
	 * @signature `obj.addEventListener(eventName, handler(event, ...) [,queueName] )`
	 *
	 * Add a event listener to an object.  Handlers attached by `.addEventListener` get
	 * called back with the [can-event-queue/map/map.dispatch]
	 * `event` object and any arguments used to dispatch. [can-event-queue/map/map.can.onKeyValue] bindings do
	 * not get the event object.
	 *
	 * ```js
	 * var mixinMapBindings = require("can-event-queue/map/map");
	 *
	 * var obj = mixinMapBindings({});
	 *
	 * obj.addEventListener("foo", function(event){ ... });
	 * ```
	 *
	 * @param {String} eventName The name of the event to listen for.
	 * @param {Function} handler(event,arg...) The handler that will be executed to handle the event.  The handler will be called
	 *   with the dispatched `event` and `args`.
	 * @param {String} [queueName='mutate'] The name of the [can-queues] queue the handler will called
	 *   back within. Defaults to `"mutate"`.
	 * @return {Object} Returns the object `.addEventListener` was called on.
	 *
	 */
	addEventListener: function(key, handler, queueName) {
		ensureMeta(this).handlers.add([key, "event", queueName || "mutate", handler]);
		return this;
	},
	/**
	 * @function can-event-queue/map/map.removeEventListener removeEventListener
	 * @parent can-event-queue/map/map
	 *
	 * @description Unregister an event handler to be called when an event is dispatched.
	 *
	 * @signature `obj.removeEventListener(eventName, [handler [,queueName]] )`
	 *
	 * Removes one or more handlers from being called when `eventName`
	 * is [can-event-queue/map/map.dispatch]ed.
	 *
	 * ```js
	 * // Removes `handler` if it is in the notify queue.
	 * obj.removeEventListener("closed", handler, "notify")
	 *
	 * // Removes `handler` if it is in the mutate queue.
	 * obj.removeEventListener("closed", handler)
	 *
	 * // Removes all "closed" handlers.
	 * obj.removeEventListener("closed")
	 * ```
	 *
	 * @param {String} eventName The name of the event to remove. If not specified, all events are removed.
	 * @param {Function} [handler] The handler that will be removed from the event. If not specified, all handlers for the event are removed.
	 * @param {String} [queueName='mutate'] The name of the [can-queues] queue the handler was registered on. Defaults to `"mutate"`.
	 * @return {Object} Returns the object `.removeEventListener` was called on.
	 */
	removeEventListener: function(key, handler, queueName) {
		if(key === undefined) {
			// This isn't super fast, but this pattern isn't used much.
			// We could re-arrange the tree so it would be faster.
			var handlers = ensureMeta(this).handlers;
			var keyHandlers = handlers.getNode([]);
			Object.keys(keyHandlers).forEach(function(key){
				handlers.delete([key,"event"]);
			});
		} else if (!handler && !queueName) {
			ensureMeta(this).handlers.delete([key, "event"]);
		} else if (!handler) {
			ensureMeta(this).handlers.delete([key, "event", queueName || "mutate"]);
		} else {
			ensureMeta(this).handlers.delete([key, "event", queueName || "mutate", handler]);
		}
		return this;
	},
	/**
	 * @function can-event-queue/map/map.one one
	 * @parent can-event-queue/map/map
	 *
	 * @description Register an event handler that gets called only once.
	 *
	 * @signature `obj.one(event, handler(event, args...) )`
	 *
	 * Adds a basic event listener that listens to an event once and only once.
	 *
	 * ```js
	 * obj.one("prop", function(){
	 *   console.log("prop dispatched");
	 * })
	 *
	 * obj[canSymbol.for("prop")]("prop") //-> logs "prop dispatched"
	 * obj[canSymbol.for("prop")]("prop")
	 * ```
	 *
	 * @param {String} eventName The name of the event to listen to.
	 * @param {Function} handler(event, args...) The handler that will be run when the
	 *   event is dispached.
	 * @return {Object} this
	 */
	one: function(event, handler) {
		// Unbind the listener after it has been executed
		var one = function() {
			legacyMapBindings.off.call(this, event, one);
			return handler.apply(this, arguments);
		};

		// Bind the altered listener
		legacyMapBindings.on.call(this, event, one);
		return this;
	},
	/**
	 * @function can-event-queue/map/map.listenTo listenTo
	 * @parent can-event-queue/map/map
	 *
	 * @description Listen to an event and register the binding for simplified unbinding.
	 *
	 * @signature `obj.listenTo([bindTarget,] event, handler)`
	 *
	 * `.listenTo` is useful for creating bindings that can can be torn down with
	 * [can-event-queue/map/map.stopListening].  This is useful when creating
	 * rich behaviors that can't be accomplished using computed values, or if you are trying to
	 * avoid streams.
	 *
	 * For example, the following creates an observable that counts how many times its
	 * `name` property has changed:
	 *
	 * ```js
	 * class Person {
	 *   constructor(){
	 *     this.nameChanged = 0;
	 *     this.listenTo("name", function(){
	 *       this.nameChanged++;
	 *     })
	 *   },
	 *   setName(newVal) {
	 *     this.name = newVal;
	 *     this.dispatch("name",[newVal])
	 *   }
	 * }
	 * mixinMapBindings(Person.prototype);
	 *
	 * var person = new Person();
	 * person.setName("Justin");
	 * person.setName("Ramiya");
	 * person.nameChanged //-> 2
	 * ```
	 *
	 * `.listenTo` event bindings are stored on an observable and MUST be unbound using
	 * [can-event-queue/map/map.stopListening]. `.stopListening` make it easy to unbind
	 * all of the `.listenTo` event bindings when the observable is no longer needed:
	 *
	 * ```js
	 * person.stopListening();
	 * ```
	 *
	 * If no `bindTarget` is passed, `.listenTo` binds to the current
	 * observable.
	 *
	 * [can-component]'s `connectedCallback` lifecyle hook is often used to call
	 * `.listenTo` to setup bindings that update viewmodel properties.
	 *
	 *
	 * @param {Object} [bindTarget] The object to listen for events on.  If `bindTarget` is not provided,
	 * the observable `.listenTo` was called on will be the `bindTarget`.
	 * @param {String} event The name of the event to listen for.
	 * @param {Function} handler The handler that will be executed to handle the event.
	 * @return {Object} this
	 */
	listenTo: function (bindTarget, event, handler, queueName) {

		if(canReflect_1_16_7_canReflect.isPrimitive(bindTarget)) {
			queueName = handler;
			handler = event;
			event = bindTarget;
			bindTarget = this;
		}

		if(typeof event === "function") {
			queueName = handler;
			handler = event;
			event = undefined;
		}

		// Initialize event cache
		ensureMeta(this).listenHandlers.add([bindTarget, event, queueName || "mutate", handler]);

		legacyMapBindings.on.call(bindTarget, event, handler, queueName || "mutate");
		return this;
	},
	/**
	 * @function can-event-queue/map/map.stopListening stopListening
	 * @parent can-event-queue/map/map
	 * @description Stops listening for registered event handlers.
	 *
	 * @signature `obj.stopListening( [bindTarget], [event,] handler]] )`
	 *
	 * `.stopListening` unbinds on event handlers registered through
	 * [can-event-queue/map/map.listenTo]. All event handlers
	 * that match the arguments will be unbound. For example:
	 *
	 * ```js
	 * // Unbinds all .listenTo registered handlers
	 * obj.stopListening()
	 *
	 * // Unbinds all .listenTo registered with `bindTarget`
	 * obj.stopListening(bindTarget)
	 *
	 * // Unbinds all .listenTo registered with `bindTarget`, `event`
	 * obj.stopListening(bindTarget, event)
	 *
	 * // Unbinds the handler registered with `bindTarget`, `event`, `handler`
	 * obj.stopListening(bindTarget, event, handler)
	 * ```
	 *
	 * `.listenTo` is often returned by [can-component]'s `connectedCallback` lifecyle hook.
	 *
	 * @param {Object} [bindTarget] The object we will stop listening to event on. If `bindTarget` is
	 * not provided, the observable `.stopListening` was called on will be the `bindTarget`.
	 * @param {String} [event] The name of the event to listen for.
	 * @param {Function} [handler] The handler that will be executed to handle the event.
	 * @return {Object} this
	 *
	 */
	stopListening: function () {
		var keys = stopListeningArgumentsToKeys.apply({context: this, defaultQueue: "mutate"}, arguments);

		var listenHandlers = ensureMeta(this).listenHandlers;

		function deleteHandler(bindTarget, event, queue, handler){
			legacyMapBindings.off.call(bindTarget, event, handler, queue);
		}
		listenHandlers.delete(keys, deleteHandler);

		return this;
	},
	/**
	 * @function can-event-queue/map/map.on on
	 * @parent can-event-queue/map/map
	 *
	 * @description A shorthand method for listening to event.
	 *
	 * @signature `obj.on( event, handler [, queue] )`
	 *
	 * Listen to when `obj` dispatches an event, a [can-reflect/observe.onKeyValue]
	 * change, or a [can-reflect/observe.onValue] change in that order.
	 *
	 * As this is the __legacy__ `.on`, it will look for an `.addEventListener`
	 * method on the `obj` first, before looking for the [can-symbol/symbols/onKeyValue]
	 * and then [can-symbol/symbols/onValue] symbol.
	 *
	 * @param {String} eventName
	 * @param {Function} handler
	 * @param {String} [queue]
	 * @return {Any} The object `on` was called on.
	 */
	on: function(eventName, handler, queue) {
		var listenWithDOM = isDomEventTarget$1(this);
		if (listenWithDOM) {
			if (typeof handler === 'string') {
				canDomEvents_1_2_0_canDomEvents.addDelegateListener(this, eventName, handler, queue);
			} else {
				canDomEvents_1_2_0_canDomEvents.addEventListener(this, eventName, handler, queue);
			}
		} else {
			if ("addEventListener" in this) {
				this.addEventListener(eventName, handler, queue);
			} else if (this[onKeyValueSymbol$1]) {
				canReflect_1_16_7_canReflect.onKeyValue(this, eventName, handler, queue);
			} else if (this[onEventSymbol]) {
				this[onEventSymbol](eventName, handler, queue);
			} else {
				if (!eventName && this[onValueSymbol$1]) {
					canReflect_1_16_7_canReflect.onValue(this, handler, queue);
				} else {
					throw new Error("can-event-queue: Unable to bind " + eventName);
				}
			}
		}
		return this;
	},
	/**
	 * @function can-event-queue/map/map.off off
	 * @parent can-event-queue/map/map
	 *
	 * @description A shorthand method for unbinding an event.
	 *
	 * @signature `obj.on( event, handler [, queue] )`
	 *
	 * Listen to when `obj` dispatches an event, a [can-reflect/observe.onKeyValue]
	 * change, or a [can-reflect/observe.onValue] change in that order.
	 *
	 * As this is the __legacy__ `.on`, it will look for an `.addEventListener`
	 * method on the `obj` first, before looking for the [can-symbol/symbols/onKeyValue]
	 * and then [can-symbol/symbols/onValue] symbol.
	 *
	 * @param {String} eventName
	 * @param {Function} handler
	 * @param {String} [queue]
	 * @return {Any} The object `on` was called on.
	 */
	off: function(eventName, handler, queue) {
		var listenWithDOM = isDomEventTarget$1(this);
		if (listenWithDOM) {
			if (typeof handler === 'string') {
				canDomEvents_1_2_0_canDomEvents.removeDelegateListener(this, eventName, handler, queue);
			} else {
				canDomEvents_1_2_0_canDomEvents.removeEventListener(this, eventName, handler, queue);
			}
		} else {
			if ("removeEventListener" in this) {
				this.removeEventListener(eventName, handler, queue);
			} else if (this[offKeyValueSymbol]) {
				canReflect_1_16_7_canReflect.offKeyValue(this, eventName, handler, queue);
			} else if (this[offEventSymbol]) {
				this[offEventSymbol](eventName, handler, queue);
			} else {
				if (!eventName && this[offValueSymbol]) {
					canReflect_1_16_7_canReflect.offValue(this, handler, queue);
				} else {
					throw new Error("can-event-queue: Unable to unbind " + eventName);
				}

			}
		}
		return this;
	}
};

// The symbols we'll add to objects
var symbols$1 = {
	/**
	 * @function can-event-queue/map/map.can.onKeyValue @can.onKeyValue
	 * @parent can-event-queue/map/map
	 *
	 * @description Register an event handler to be called when a key value changes.
	 *
	 * @signature `canReflect.onKeyValue( obj, key, handler(newVal) [,queueName] )`
	 *
	 * Add a key change handler to an object.  Handlers attached by `.onKeyValue` get
	 * called back with the new value of the `key`. Handlers attached with [can-event-queue/map/map.can.addEventListener]
	 * get the event object.
	 *
	 * ```js
	 * var mixinMapBindings = require("can-event-queue/map/map");
	 *
	 * var obj = mixinMapBindings({});
	 *
	 * canReflect.onKeyValue( obj, "prop", function(newPropValue){ ... });
	 * ```
	 *
	 * @param {String} key The name of property to listen to changes in values.
	 * @param {Function} handler(newVal, oldValue) The handler that will be called
	 *   back with the new and old value of the key.
	 * @param {String} [queueName='mutate'] The name of the [can-queues] queue the handler will called
	 *   back within. Defaults to `"mutate"`.
	 */
	"can.onKeyValue": function(key, handler, queueName) {
		ensureMeta(this).handlers.add([key, "onKeyValue", queueName || "mutate", handler]);
	},
	/**
	 * @function can-event-queue/map/map.can.offKeyValue @can.offKeyValue
	 * @parent can-event-queue/map/map
	 *
	 * @description Unregister an event handler to be called when an event is dispatched.
	 *
	 * @signature `canReflect.offKeyValue( obj, key, handler, queueName )`
	 *
	 * Removes a handlers from being called when `key` changes are
	 * [can-event-queue/map/map.dispatch]ed.
	 *
	 * ```js
	 * // Removes `handler` if it is in the notify queue.
	 * canReflect.offKeyValue( obj, "prop", handler, "notify" )
	 * ```
	 *
	 * @param {String} eventName The name of the event to remove. If not specified, all events are removed.
	 * @param {Function} [handler] The handler that will be removed from the event. If not specified, all handlers for the event are removed.
	 * @param {String} [queueName='mutate'] The name of the [can-queues] queue the handler was registered on. Defaults to `"mutate"`.
	 */
	"can.offKeyValue": function(key, handler, queueName) {
		ensureMeta(this).handlers.delete([key, "onKeyValue", queueName || "mutate", handler]);
	},
	/**
	 * @function can-event-queue/map/map.can.isBound @can.isBound
	 * @parent can-event-queue/map/map
	 *
	 * @description Return if the observable is bound to.
	 *
	 * @signature `canReflect.isBound(obj)`
	 *
	 * The `@can.isBound` symbol is added to make [can-reflect/observe.isBound]
	 * return if `obj` is bound or not.
	 *
	 * @return {Boolean} True if the observable has been bound to with `.onKeyValue` or `.addEventListener`.
	 */
	"can.isBound": function() {
		return ensureMeta(this).handlers.size() > 0;
	},
	/**
	 * @function can-event-queue/map/map.can.getWhatIChange @can.getWhatIChange
	 * @parent can-event-queue/map/map
	 *
	 * @description Return observables whose values are affected by attached event handlers
	 * @signature `@can.getWhatIChange(key)`
	 *
	 * The `@@can.getWhatIChange` symbol is added to make sure [can-debug] can report
	 * all the observables whose values are set by a given observable's key.
	 *
	 * This function iterates over the event handlers attached to a given `key` and
	 * collects the result of calling `@@can.getChangesDependencyRecord` on each handler;
	 * this symbol allows the caller to tell what observables are being mutated by
	 * the event handler when it is executed.
	 *
	 * In the following example a [can-simple-map] instance named `me` is created
	 * and when its `age` property changes, the value of a [can-simple-observable]
	 * instance is set. The event handler that causes the mutation is then decatorated
	 * with `@@can.getChangesDependencyRecord` to register the mutation dependency.
	 *
	 * ```js
	 * var obs = new SimpleObservable("a");
	 * var me = new SimpleMap({ age: 30 });
	 * var canReflect = require("can-reflect");
	 *
	 * var onAgeChange = function onAgeChange() {
	 *	canReflect.setValue(obs, "b");
	 * };
	 *
	 * onAgeChange[canSymbol.for("can.getChangesDependencyRecord")] = function() {
	 *	return {
	 *		valueDependencies: new Set([ obs ]);
	 *	}
	 * };
	 *
	 * canReflect.onKeyValue(me, "age", onAgeChange);
	 * me[canSymbol.for("can.getWhatIChange")]("age");
	 * ```
	 *
	 * The dependency records collected from the event handlers are divided into
	 * two categories:
	 *
	 * - mutate: Handlers in the mutate/domUI queues
	 * - derive: Handlers in the notify queue
	 *
	 * Since event handlers are added by default to the "mutate" queue, calling
	 * `@@can.getWhatIChange` on the `me` instance returns an object with a mutate
	 * property and the `valueDependencies` Set registered on the `onAgeChange`
	 * handler.
	 *
	 * Please check out the [can-reflect-dependencies] docs to learn more about
	 * how this symbol is used to keep track of custom observable dependencies.
	 */
	"can.getWhatIChange": function getWhatIChange(key) {
		//!steal-remove-start
		var whatIChange = {};
		var meta = ensureMeta(this);

		var notifyHandlers = [].concat(
			meta.handlers.get([key, "event", "notify"]),
			meta.handlers.get([key, "onKeyValue", "notify"])
		);

		var mutateHandlers = [].concat(
			meta.handlers.get([key, "event", "mutate"]),
			meta.handlers.get([key, "event", "domUI"]),
			meta.handlers.get([key, "onKeyValue", "mutate"]),
			meta.handlers.get([key, "onKeyValue", "domUI"])
		);

		if (notifyHandlers.length) {
			notifyHandlers.forEach(function(handler) {
				var changes = canReflect_1_16_7_canReflect.getChangesDependencyRecord(handler);

				if (changes) {
					var record = whatIChange.derive;
					if (!record) {
						record = (whatIChange.derive = {});
					}
					merge(record, changes);
				}
			});
		}

		if (mutateHandlers.length) {
			mutateHandlers.forEach(function(handler) {
				var changes = canReflect_1_16_7_canReflect.getChangesDependencyRecord(handler);

				if (changes) {
					var record = whatIChange.mutate;
					if (!record) {
						record = (whatIChange.mutate = {});
					}
					merge(record, changes);
				}
			});
		}

		return Object.keys(whatIChange).length ? whatIChange : undefined;
		//!steal-remove-end
	},
	"can.onPatches": function(handler, queue) {
		var handlers = ensureMeta(this).handlers;
		handlers.add(["can.patches", "onKeyValue", queue || "notify", handler]);
	},
	"can.offPatches": function(handler, queue) {
		var handlers = ensureMeta(this).handlers;
		handlers.delete(["can.patches", "onKeyValue", queue || "notify", handler]);
	}
};

// This can be removed in a future version.
function defineNonEnumerable(obj, prop, value) {
	Object.defineProperty(obj, prop, {
		enumerable: false,
		value: value
	});
}

// The actual legacyMapBindings mixin function
legacyMapBindings = function(obj) {
	// add properties
	canReflect_1_16_7_canReflect.assignMap(obj, props);
	// add symbols
	return canReflect_1_16_7_canReflect.assignSymbols(obj, symbols$1);
};

defineNonEnumerable(legacyMapBindings, "addHandlers", addHandlers);
defineNonEnumerable(legacyMapBindings, "stopListeningArgumentsToKeys", stopListeningArgumentsToKeys);



// ## LEGACY
// The following is for compatability with the old can-event
props.bind = props.addEventListener;
props.unbind = props.removeEventListener;



// Adds methods directly to method so it can be used like `can-event` used to be used.
canReflect_1_16_7_canReflect.assignMap(legacyMapBindings, props);
canReflect_1_16_7_canReflect.assignSymbols(legacyMapBindings, symbols$1);

defineNonEnumerable(legacyMapBindings, "start", function() {
	console.warn("use can-queues.batch.start()");
	canQueues_1_1_0_canQueues.batch.start();
});
defineNonEnumerable(legacyMapBindings, "stop", function() {
	console.warn("use can-queues.batch.stop()");
	canQueues_1_1_0_canQueues.batch.stop();
});
defineNonEnumerable(legacyMapBindings, "flush", function() {
	console.warn("use can-queues.flush()");
	canQueues_1_1_0_canQueues.flush();
});

defineNonEnumerable(legacyMapBindings, "afterPreviousEvents", function(handler) {
	console.warn("don't use afterPreviousEvents");
	canQueues_1_1_0_canQueues.mutateQueue.enqueue(function afterPreviousEvents() {
		canQueues_1_1_0_canQueues.mutateQueue.enqueue(handler);
	});
	canQueues_1_1_0_canQueues.flush();
});

defineNonEnumerable(legacyMapBindings, "after", function(handler) {
	console.warn("don't use after");
	canQueues_1_1_0_canQueues.mutateQueue.enqueue(handler);
	canQueues_1_1_0_canQueues.flush();
});

var map$1 = legacyMapBindings;

var getChangesSymbol$1 = canSymbol_1_6_1_canSymbol.for("can.getChangesDependencyRecord");

function ResolverObservable(resolver, context) {
	// we don't want reads leaking out.  We should be binding to all of this ourselves.
	this.resolver = canObservationRecorder_1_1_2_canObservationRecorder.ignore(resolver);
	this.context = context;
	this.valueOptions = {
		resolve: this.resolve.bind(this),
		listenTo: this.listenTo.bind(this),
		stopListening: this.stopListening.bind(this),
		lastSet: new canSimpleObservable_2_0_5_canSimpleObservable(undefined)
	};

	this.update = this.update.bind(this);

	this.contextHandlers = new WeakMap();
	this.teardown = null;
	// a place holder for remembering where we bind
	this.binder = {};
	//!steal-remove-start
	canReflect_1_16_7_canReflect.assignSymbols(this, {
		"can.getName": function() {
			return (
				canReflect_1_16_7_canReflect.getName(this.constructor) +
				"<" +
				canReflect_1_16_7_canReflect.getName(resolver) +
				">"
			);
		}
	});
	Object.defineProperty(this.update, "name", {
		value: canReflect_1_16_7_canReflect.getName(this) + ".update"
	});

	canReflect_1_16_7_canReflect.assignSymbols(this.valueOptions.lastSet, {
		"can.getName": function() {
			return (
				canReflect_1_16_7_canReflect.getName(this.constructor)  +"::lastSet"+
				"<" +
				canReflect_1_16_7_canReflect.getName(resolver) +
				">"
			);
		}
	});
	//!steal-remove-end
}
ResolverObservable.prototype = Object.create(settable.prototype);

function deleteHandler(bindTarget, event, queue, handler){
	map$1.off.call(bindTarget, event, handler, queue);
}

canReflect_1_16_7_canReflect.assignMap(ResolverObservable.prototype, {
	constructor: ResolverObservable,
	listenTo: function(bindTarget, event, handler, queueName) {
		//Object.defineProperty(this.handler, "name", {
		//	value: canReflect.getName(this) + ".handler"
		//});
		if(canReflect_1_16_7_canReflect.isPrimitive(bindTarget)) {
			handler = event;
			event = bindTarget;
			bindTarget = this.context;
		}
		if(typeof event === "function") {
			handler = event;
			event = undefined;
		}

		var resolverInstance = this;

		//!steal-remove-start
		if(!handler.name) {
			Object.defineProperty(handler, "name", {
				value:
					(bindTarget ?
						 canReflect_1_16_7_canReflect.getName(bindTarget) : "")+
					 (event ? ".on('"+event+"',handler)" : ".on(handler)")+
					 "::"+canReflect_1_16_7_canReflect.getName(this)
			});
		}
		//!steal-remove-end

		var contextHandler = handler.bind(this.context);
		contextHandler[getChangesSymbol$1] = function getChangesDependencyRecord() {
			return {
				valueDependencies: new Set([ resolverInstance ])
			};
		};

		this.contextHandlers.set(handler, contextHandler);
		map$1.listenTo.call(this.binder, bindTarget, event, contextHandler, queueName || "notify");
	},
	stopListening: function(){

		var meta = this.binder[canSymbol_1_6_1_canSymbol.for("can.meta")];
		var listenHandlers = meta && meta.listenHandlers;
		if(listenHandlers) {
			var keys = map$1.stopListeningArgumentsToKeys.call({context: this.context, defaultQueue: "notify"});

			listenHandlers.delete(keys, deleteHandler);
		}
		return this;
	},
	resolve: function(newVal) {
		this.value = newVal;
		// if we are setting up the initial binding and we get a resolved value
		// do not emit events for it.

		if(this.isBinding) {
			this.lastValue = this.value;
			return newVal;
		}

		if(this.value !== this.lastValue) {
			canQueues_1_1_0_canQueues.batch.start();
			canQueues_1_1_0_canQueues.deriveQueue.enqueue(
				this.update,
				this,
				[],
				{
					//!steal-remove-start
					/* jshint laxcomma: true */
					log: [canReflect_1_16_7_canReflect.getName(this.update)],
					reasonLog: [canReflect_1_16_7_canReflect.getName(this), "resolved with", newVal]
					/* jshint laxcomma: false */
					//!steal-remove-end
				}
			);
			canQueues_1_1_0_canQueues.batch.stop();
		}
		return newVal;
	},
	update: function(){

		if(this.lastValue !== this.value) {

			var old = this.lastValue;
			this.lastValue = this.value;
			//!steal-remove-start
			if (typeof this._log === "function") {
				this._log(old, this.value);
			}
			//!steal-remove-end

			// adds callback handlers to be called w/i their respective queue.
			canQueues_1_1_0_canQueues.enqueueByQueue(
				this.handlers.getNode([]),
				this,
				[this.value, old]
			);
		}
	},
	activate: function() {
		this.isBinding = true;
		this.teardown = this.resolver.call(this.context, this.valueOptions);
		this.isBinding = false;
	},
	onUnbound: function() {
		this.bound = false;
		map$1.stopListening.call(this.binder);
		if(this.teardown != null) {
			this.teardown();
			this.teardown = null;
		}
	},
	set: function(value) {
		this.valueOptions.lastSet.set(value);

		/*if (newVal !== this.lastSetValue.get()) {
			this.lastSetValue.set(newVal);
		}*/
	},
	get: function() {
		if (canObservationRecorder_1_1_2_canObservationRecorder.isRecording()) {
			canObservationRecorder_1_1_2_canObservationRecorder.add(this);
			if (!this.bound) {
				this.onBound();
			}
		}

		if (this.bound === true) {
			return this.value;
		} else {
			var handler = function(){};
			this.on(handler);
			var val = this.value;
			this.off(handler);
			return val;
		}
	},
	hasDependencies: function hasDependencies() {
		var hasDependencies = false;

		if (this.bound) {
			var meta = this.binder[canSymbol_1_6_1_canSymbol.for("can.meta")];
			var listenHandlers = meta && meta.listenHandlers;
			hasDependencies = !!listenHandlers.size();
		}

		return hasDependencies;
	},
	getValueDependencies: function getValueDependencies() {
		if (this.bound) {
			var meta = this.binder[canSymbol_1_6_1_canSymbol.for("can.meta")];
			var listenHandlers = meta && meta.listenHandlers;

			var keyDeps = new Map();
			var valueDeps = new Set();

			if (listenHandlers) {
				canReflect_1_16_7_canReflect.each(listenHandlers.root, function(events, obj) {
					canReflect_1_16_7_canReflect.each(events, function(queues, eventName) {
						if (eventName === undefined) {
							valueDeps.add(obj);
						} else {
							var entry = keyDeps.get(obj);
							if (!entry) {
								entry = new Set();
								keyDeps.set(obj, entry);
							}
							entry.add(eventName);
						}
					});
				});

				if (valueDeps.size || keyDeps.size) {
					var result = {};

					if (keyDeps.size) {
						result.keyDependencies = keyDeps;
					}
					if (valueDeps.size) {
						result.valueDependencies = valueDeps;
					}

					return result;
				}
			}
		}
	}
});

canReflect_1_16_7_canReflect.assignSymbols(ResolverObservable.prototype, {
	"can.getValue": ResolverObservable.prototype.get,
	"can.setValue": ResolverObservable.prototype.set,
	"can.isMapLike": false,
	"can.getPriority": function() {
		// TODO: the priority should come from any underlying values
		return this.priority || 0;
	},
	"can.setPriority": function(newPriority) {
		this.priority = newPriority;
	},
	"can.valueHasDependencies": ResolverObservable.prototype.hasDependencies,
	"can.getValueDependencies": ResolverObservable.prototype.getValueDependencies
});


var resolver = ResolverObservable;

/**
 * @module {function} can-event-queue/type/type
 * @parent can-event-queue
 *
 * @description Mixin methods and symbols to make a type constructor function able to
 * broadcast changes in its instances.
 *
 * @signature `mixinTypeBindings( type )`
 *
 * Adds symbols and methods that make `type` work with the following [can-reflect] APIs:
 *
 * - [can-reflect/observe.onInstanceBoundChange] - Observe when instances are bound.
 * - [can-reflect/observe.onInstancePatches] - Observe patche events on all instances.
 *
 * When `mixinTypeBindings` is called on an `Person` _type_ like:
 *
 * ```js
 * var mixinTypeBindings = require("can-event-queue/type/type");
 * var mixinLegacyMapBindings = require("can-event-queue/map/map");
 *
 * class Person {
 *   constructor(data){
 *     this.data = data;
 *   }
 * }
 * mixinTypeBindings(Person);
 * mixinLegacyMapBindings(Person.prototype);
 *
 * var me = new Person({first: "Justin", last: "Meyer"});
 *
 * // mixinTypeBindings allows you to listen to
 * // when a person instance's bind stache changes
 * canReflect.onInstanceBoundChange(Person, function(person, isBound){
 *    console.log("isBound");
 * });
 *
 * // mixinTypeBindings allows you to listen to
 * // when a patch change happens.
 * canReflect.onInstancePatches(Person, function(person, patches){
 *    console.log(patches[0]);
 * });
 *
 * me.on("name",function(ev, newVal, oldVal){}) //-> logs: "isBound"
 *
 * me.dispatch({
 *   type: "first",
 *   patches: [{type: "set", key: "first", value: "Ramiya"}]
 * }, ["Ramiya","Justin"])
 * //-> logs: {type: "set", key: "first", value: "Ramiya"}
 * ```
 *
 */





var metaSymbol$1 = canSymbol_1_6_1_canSymbol.for("can.meta");

function addHandlers$1(obj, meta) {
    if (!meta.lifecycleHandlers) {
        meta.lifecycleHandlers = new canKeyTree_1_0_2_canKeyTree([Object, Array]);
    }
    if (!meta.instancePatchesHandlers) {
        meta.instancePatchesHandlers = new canKeyTree_1_0_2_canKeyTree([Object, Array]);
    }
}

function ensureMeta$1(obj) {
    var meta = obj[metaSymbol$1];

    if (!meta) {
        meta = {};
        canReflect_1_16_7_canReflect.setKeyValue(obj, metaSymbol$1, meta);
    }

    addHandlers$1(obj, meta);
    return meta;
}

var props$1 = {
    /**
     * @function can-event-queue/type/type.can.onInstanceBoundChange @can.onInstanceBoundChange
     * @parent can-event-queue/type/type
     * @description Listen to when any instance is bound for the first time or all handlers are removed.
     *
     * @signature `canReflect.onInstanceBoundChange(Type, handler(instance, isBound) )`
     *
     * ```js
     * canReflect.onInstanceBoundChange(Person, function(person, isBound){
     *    console.log("isBound");
     * });
     * ```
     *
     * @param {function(Any,Boolean)} handler(instance,isBound) A function is called
     * when an instance is bound or unbound.  `isBound` will be `true` when the instance
     * becomes bound and `false` when unbound.
     */

    /**
     * @function can-event-queue/type/type.can.offInstanceBoundChange @can.offInstanceBoundChange
     * @parent can-event-queue/type/type
     *
     * @description Stop listening to when an instance's bound status changes.
     *
     * @signature `canReflect.offInstanceBoundChange(Type, handler )`
     *
     * Stop listening to a handler bound with
     * [can-event-queue/type/type.can.onInstanceBoundChange].
     */


    /**
     * @function can-event-queue/type/type.can.onInstancePatches @can.onInstancePatches
     * @parent can-event-queue/type/type
     *
     * @description Listen to patch changes on any isntance.
     *
     * @signature `canReflect.onInstancePatches(Type, handler(instance, patches) )`
     *
     * Listen to patch changes on any instance of `Type`. This is used by
     * [can-connect] to know when a potentially `unbound` instance's `id`
     * changes. If the `id` changes, the instance can be moved into the store
     * while it is being saved.
     *
     */

    /**
     * @function can-event-queue/type/type.can.offInstancePatches @can.offInstancePatches
     * @parent can-event-queue/type/type
     *
     * @description Stop listening to patch changes on any instance.
     *
     * @signature `canReflect.onInstancePatches(Type, handler )`
     *
     * Stop listening to a handler bound with [can-event-queue/type/type.can.onInstancePatches].
     */
};

function onOffAndDispatch(symbolName, dispatchName, handlersName){
    props$1["can.on"+symbolName] = function(handler, queueName) {
        ensureMeta$1(this)[handlersName].add([queueName || "mutate", handler]);
    };
    props$1["can.off"+symbolName] = function(handler, queueName) {
        ensureMeta$1(this)[handlersName].delete([queueName || "mutate", handler]);
    };
    props$1["can."+dispatchName] = function(instance, arg){
        canQueues_1_1_0_canQueues.enqueueByQueue(ensureMeta$1(this)[handlersName].getNode([]), this, [instance, arg]);
    };
}

onOffAndDispatch("InstancePatches","dispatchInstanceOnPatches","instancePatchesHandlers");
onOffAndDispatch("InstanceBoundChange","dispatchInstanceBoundChange","lifecycleHandlers");

function mixinTypeBindings(obj){
    return canReflect_1_16_7_canReflect.assignSymbols(obj,props$1);
}

Object.defineProperty(mixinTypeBindings, "addHandlers", {
    enumerable: false,
    value: addHandlers$1
});

var type$1 = mixinTypeBindings;

var canStringToAny_1_0_1_canStringToAny = function(str){
	switch(str) {
		case "NaN":
		case "Infinity":
			return +str;
		case "null":
			return null;
		case "undefined":
			return undefined;
		case "true":
		case "false":
			return str === "true";
		default:
			var val = +str;
			if(!isNaN(val)) {
				return val;
			} else {
				return str;
			}
	}
};

function toBoolean(val) {
	if(val == null) {
		return val;
	}
	if (val === 'false' || val === '0' || !val) {
		return false;
	}
	return true;
}

var maybeBoolean = canReflect_1_16_7_canReflect.assignSymbols(toBoolean,{
	"can.new": toBoolean,
	"can.getSchema": function(){
		return {
			type: "Or",
			values: [true, false, undefined, null]
		};
	},
    "can.getName": function(){
        return "MaybeBoolean";
    },
	"can.isMember": function(value) {
		return value == null || typeof value === "boolean";
	}
});

function toDate(str) {
	var type = typeof str;
	if (type === 'string') {
		str = Date.parse(str);
		return isNaN(str) ? null : new Date(str);
	} else if (type === 'number') {
		return new Date(str);
	} else {
		return str;
	}
}

function DateStringSet(dateStr){
	this.setValue = dateStr;
	var date = toDate(dateStr);
	this.value = date == null ? date : date.getTime();
}
DateStringSet.prototype.valueOf = function(){
	return this.value;
};
canReflect_1_16_7_canReflect.assignSymbols(DateStringSet.prototype,{
	"can.serialize": function(){
		return this.setValue;
	}
});

var maybeDate = canReflect_1_16_7_canReflect.assignSymbols(toDate,{
	"can.new": toDate,
	"can.getSchema": function(){
		return {
			type: "Or",
			values: [Date, undefined, null]
		};
	},
	"can.ComparisonSetType": DateStringSet,
    "can.getName": function(){
        return "MaybeDate";
    },
	"can.isMember": function(value) {
		return value == null || (value instanceof Date);
	}
});

function toNumber(val) {
	if (val == null) {
		return val;
	}
	return +(val);
}

var maybeNumber = canReflect_1_16_7_canReflect.assignSymbols(toNumber,{
	"can.new": toNumber,
	"can.getSchema": function(){
		return {
			type: "Or",
			values: [Number, undefined, null]
		};
	},
    "can.getName": function(){
        return "MaybeNumber";
    },
	"can.isMember": function(value) {
		return value == null || typeof value === "number";
	}
});

function toString(val) {
	if (val == null) {
		return val;
	}
	return '' + val;
}

var maybeString = canReflect_1_16_7_canReflect.assignSymbols(toString,{
	"can.new": toString,
	"can.getSchema": function(){
		return {
			type: "Or",
			values: [String, undefined, null]
		};
	},
    "can.getName": function(){
        return "MaybeString";
    },
	"can.isMember": function(value) {
		return value == null || typeof value === "string";
	}
});

var newSymbol$1 = canSymbol_1_6_1_canSymbol.for("can.new"),
	serializeSymbol = canSymbol_1_6_1_canSymbol.for("can.serialize");

var eventsProto, define,
	make, makeDefinition, getDefinitionsAndMethods, getDefinitionOrMethod;

// UTILITIES
function isDefineType(func){
	return func && (func.canDefineType === true || func[newSymbol$1] );
}

var peek$2 = canObservationRecorder_1_1_2_canObservationRecorder.ignore(canReflect_1_16_7_canReflect.getValue.bind(canReflect_1_16_7_canReflect));

var Object_defineNamedPrototypeProperty = Object.defineProperty;
//!steal-remove-start
Object_defineNamedPrototypeProperty = function(obj, prop, definition) {
	if (definition.get) {
		Object.defineProperty(definition.get, "name", {
			value: "get "+canReflect_1_16_7_canReflect.getName(obj) + "."+prop,
			writable: true
		});
	}
	if (definition.set) {
		Object.defineProperty(definition.set, "name", {
			value:  "set "+canReflect_1_16_7_canReflect.getName(obj) + "."+prop
		});
	}
	return Object.defineProperty(obj, prop, definition);
};
//!steal-remove-end


function defineConfigurableAndNotEnumerable(obj, prop, value) {
	Object.defineProperty(obj, prop, {
		configurable: true,
		enumerable: false,
		writable: true,
		value: value
	});
}

function eachPropertyDescriptor(map, cb){
	for(var prop in map) {
		if(map.hasOwnProperty(prop)) {
			cb.call(map, prop, Object.getOwnPropertyDescriptor(map,prop));
		}
	}
}

function cleanUpDefinition(prop, definition, shouldWarn){
	// cleanup `value` -> `default`
	if(definition.value !== undefined && ( typeof definition.value !== "function" || definition.value.length === 0) ){

		//!steal-remove-start
		if(shouldWarn) {
			dev.warn(
				"can-define: Change the 'value' definition for " + prop + " to 'default'."
			);
		}
		//!steal-remove-end

		definition.default = definition.value;
		delete definition.value;
	}
	// cleanup `Value` -> `DEFAULT`
	if(definition.Value !== undefined  ){
		//!steal-remove-start
		if(shouldWarn) {
			dev.warn(
				"can-define: Change the 'Value' definition for " + prop + " to 'Default'."
			);
		}
		//!steal-remove-end
		definition.Default = definition.Value;
		delete definition.Value;
	}
}

function isValueResolver(definition) {
	// there's a function and it has one argument
	return typeof definition.value === "function" && definition.value.length;
}

var canDefine_2_3_5_canDefine = define = canNamespace_1_0_0_canNamespace.define = function(typePrototype, defines, baseDefine) {
	// default property definitions on _data
	var prop,
		dataInitializers = Object.create(baseDefine ? baseDefine.dataInitializers : null),
		// computed property definitions on _computed
		computedInitializers = Object.create(baseDefine ? baseDefine.computedInitializers : null);

	var result = getDefinitionsAndMethods(defines, baseDefine);
	result.dataInitializers = dataInitializers;
	result.computedInitializers = computedInitializers;


	// Goes through each property definition and creates
	// a `getter` and `setter` function for `Object.defineProperty`.
	canReflect_1_16_7_canReflect.eachKey(result.definitions, function(definition, property){
		define.property(typePrototype, property, definition, dataInitializers, computedInitializers, result.defaultDefinition);
	});

	// Places a `_data` on the prototype that when first called replaces itself
	// with a `_data` object local to the instance.  It also defines getters
	// for any value that has a default value.
	if(typePrototype.hasOwnProperty("_data")) {
		for (prop in dataInitializers) {
			canDefineLazyValue_1_0_2_defineLazyValue(typePrototype._data, prop, dataInitializers[prop].bind(typePrototype), true);
		}
	} else {
		canDefineLazyValue_1_0_2_defineLazyValue(typePrototype, "_data", function() {
			var map = this;
			var data = {};
			for (var prop in dataInitializers) {
				canDefineLazyValue_1_0_2_defineLazyValue(data, prop, dataInitializers[prop].bind(map), true);
			}
			return data;
		});
	}

	// Places a `_computed` on the prototype that when first called replaces itself
	// with a `_computed` object local to the instance.  It also defines getters
	// that will create the property's compute when read.
	if(typePrototype.hasOwnProperty("_computed")) {
		for (prop in computedInitializers) {
			canDefineLazyValue_1_0_2_defineLazyValue(typePrototype._computed, prop, computedInitializers[prop].bind(typePrototype));
		}
	} else {
		canDefineLazyValue_1_0_2_defineLazyValue(typePrototype, "_computed", function() {
			var map = this;
			var data = Object.create(null);
			for (var prop in computedInitializers) {
				canDefineLazyValue_1_0_2_defineLazyValue(data, prop, computedInitializers[prop].bind(map));
			}
			return data;
		});
	}

	// Add necessary event methods to this object.
	for (prop in eventsProto) {
		Object.defineProperty(typePrototype, prop, {
			enumerable: false,
			value: eventsProto[prop],
			configurable: true,
			writable: true
		});
	}
	// add so instance defs can be dynamically added
	Object.defineProperty(typePrototype,"_define",{
		enumerable: false,
		value: result,
		configurable: true,
		writable: true
	});

	// Places Symbol.iterator or @@iterator on the prototype
	// so that this can be iterated with for/of and canReflect.eachIndex
	var iteratorSymbol = canSymbol_1_6_1_canSymbol.iterator || canSymbol_1_6_1_canSymbol.for("iterator");
	if(!typePrototype[iteratorSymbol]) {
		defineConfigurableAndNotEnumerable(typePrototype, iteratorSymbol, function(){
			return new define.Iterator(this);
		});
	}

	return result;
};

var onlyType = function(obj){
	for(var prop in obj) {
		if(prop !== "type") {
			return false;
		}
	}
	return true;
};

define.extensions = function () {};

// typePrototype - the prototype of the type we are defining `prop` on.
// `definition` - the user provided definition
define.property = function(typePrototype, prop, definition, dataInitializers, computedInitializers, defaultDefinition) {
	var propertyDefinition = define.extensions.apply(this, arguments);

	if (propertyDefinition) {
		definition = makeDefinition(prop, propertyDefinition, defaultDefinition || {});
	}

	var type = definition.type;

	//!steal-remove-start
	if (type && canReflect_1_16_7_canReflect.isConstructorLike(type) && !isDefineType(type)) {
		dev.warn(
			"can-define: the definition for " +
			prop +
			(typePrototype.constructor.shortName ? " on " + typePrototype.constructor.shortName : "") +
			" uses a constructor for \"type\". Did you mean \"Type\"?"
		);
	}
	//!steal-remove-end

	// Special case definitions that have only `type: "*"`.
	if (type && onlyType(definition) && type === define.types["*"]) {
		Object_defineNamedPrototypeProperty(typePrototype, prop, {
			get: make.get.data(prop),
			set: make.set.events(prop, make.get.data(prop), make.set.data(prop), make.eventType.data(prop)),
			enumerable: true,
			configurable: true
		});
		return;
	}
	definition.type = type;

	// Where the value is stored.  If there is a `get` the source of the value
	// will be a compute in `this._computed[prop]`.  If not, the source of the
	// value will be in `this._data[prop]`.
	var dataProperty = definition.get || isValueResolver(definition) ? "computed" : "data",

		// simple functions that all read/get/set to the right place.
		// - reader - reads the value but does not observe.
		// - getter - reads the value and notifies observers.
		// - setter - sets the value.
		reader = make.read[dataProperty](prop),
		getter = make.get[dataProperty](prop),
		setter = make.set[dataProperty](prop),
		getInitialValue;

	//!steal-remove-start
	if (definition.get) {
		Object.defineProperty(definition.get, "name", {
			value: canReflect_1_16_7_canReflect.getName(typePrototype) + "'s " + prop + " getter",
		});
	}
	if (definition.set) {
		Object.defineProperty(definition.set, "name", {
			value: canReflect_1_16_7_canReflect.getName(typePrototype) + "'s " + prop + " setter",
		});
	}
	if(isValueResolver(definition)) {
		Object.defineProperty(definition.value, "name", {
			value: canReflect_1_16_7_canReflect.getName(typePrototype) + "'s " + prop + " value",
		});
	}
	//!steal-remove-end

	// Determine the type converter
	var typeConvert = function(val) {
		return val;
	};

	if (definition.Type) {
		typeConvert = make.set.Type(prop, definition.Type, typeConvert);
	}
	if (type) {
		typeConvert = make.set.type(prop, type, typeConvert);
	}

	// make a setter that's going to fire of events
	var eventsSetter = make.set.events(prop, reader, setter, make.eventType[dataProperty](prop));
	if(isValueResolver(definition)) {
		computedInitializers[prop] = make.valueResolver(prop, definition, typeConvert);
	}
	// Determine a function that will provide the initial property value.
	else if ((definition.default !== undefined || definition.Default !== undefined)) {

		//!steal-remove-start
		// If value is an object or array, give a warning
		if (definition.default !== null && typeof definition.default === 'object') {
			dev.warn("can-define: The default value for " + prop + " is set to an object. This will be shared by all instances of the DefineMap. Use a function that returns the object instead.");
		}
		// If value is a constructor, give a warning
		if (definition.default && canReflect_1_16_7_canReflect.isConstructorLike(definition.default)) {
			dev.warn("can-define: The \"default\" for " + prop + " is set to a constructor. Did you mean \"Default\" instead?");
		}
		//!steal-remove-end

		getInitialValue = canObservationRecorder_1_1_2_canObservationRecorder.ignore(make.get.defaultValue(prop, definition, typeConvert, eventsSetter));
	}

	// If property has a getter, create the compute that stores its data.
	if (definition.get) {
		computedInitializers[prop] = make.compute(prop, definition.get, getInitialValue);
	}
	// If the property isn't a getter, but has an initial value, setup a
	// default value on `this._data[prop]`.
	else if (getInitialValue) {
		dataInitializers[prop] = getInitialValue;
	}


	// Define setter behavior.

	// If there's a `get` and `set`, make the setter get the `lastSetValue` on the
	// `get`'s compute.
	if (definition.get && definition.set) {
		// the compute will set off events, so we can use the basic setter
		setter = make.set.setter(prop, definition.set, make.read.lastSet(prop), setter, true);
	}
	// If there's a `set` and no `get`,
	else if (definition.set) {
		// Add `set` functionality to the eventSetter.
		setter = make.set.setter(prop, definition.set, reader, eventsSetter, false);
	}
	// If there's neither `set` or `get` or `value` (resolver)
	else if (dataProperty === "data") {
		// make a set that produces events.
		setter = eventsSetter;
	}
	// If there's zero-arg `get` but not `set`, warn on all sets in dev mode
	else if (definition.get && definition.get.length < 1) {
		setter = function() {
			//!steal-remove-start
			dev.warn("can-define: Set value for property " +
				prop +
				(typePrototype.constructor.shortName ? " on " + typePrototype.constructor.shortName : "") +
				" ignored, as its definition has a zero-argument getter and no setter");
			//!steal-remove-end
		};
	}


	// Add type behavior to the setter.
	if (type) {
		setter = make.set.type(prop, type, setter);
	}
	if (definition.Type) {
		setter = make.set.Type(prop, definition.Type, setter);
	}

	// Define the property.
	Object_defineNamedPrototypeProperty(typePrototype, prop, {
		get: getter,
		set: setter,
		enumerable: "serialize" in definition ? !!definition.serialize : !definition.get,
		configurable: true
	});
};
define.makeDefineInstanceKey = function(constructor) {
	constructor[canSymbol_1_6_1_canSymbol.for("can.defineInstanceKey")] = function(property, value) {
		var defineResult = this.prototype._define;
		if(typeof value === "object") {
			// change `value` to default.
			cleanUpDefinition(property, value, false);
		}
		var definition = getDefinitionOrMethod(property, value, defineResult.defaultDefinition);
		if(definition && typeof definition === "object") {
			define.property(constructor.prototype, property, definition, defineResult.dataInitializers, defineResult.computedInitializers, defineResult.defaultDefinition);
			defineResult.definitions[property] = definition;
		} else {
			defineResult.methods[property] = definition;
		}
	};
};

// Makes a simple constructor function.
define.Constructor = function(defines, sealed) {
	var constructor = function(props) {
		Object.defineProperty(this,"__inSetup",{
			configurable: true,
			enumerable: false,
			value: true,
			writable: true
		});
		define.setup.call(this, props, sealed);
		this.__inSetup = false;
	};
	var result = define(constructor.prototype, defines);
	type$1(constructor);
	define.makeDefineInstanceKey(constructor, result);
	return constructor;
};

// A bunch of helper functions that are used to create various behaviors.
make = {

	computeObj: function(map, prop, observable) {
		var computeObj = {
			oldValue: undefined,
			compute: observable,
			count: 0,
			handler: function(newVal) {
				var oldValue = computeObj.oldValue;
				computeObj.oldValue = newVal;

				map.dispatch({
					type: prop,
					target: map
				}, [newVal, oldValue]);
			}
		};
		return computeObj;
	},
	valueResolver: function(prop, definition, typeConvert) {
		return function(){
			var map = this;
			var computeObj = make.computeObj(map, prop, new resolver(definition.value, map));
			//!steal-remove-start
			Object.defineProperty(computeObj.handler, "name", {
				value: canReflect_1_16_7_canReflect.getName(definition.value).replace('value', 'event emitter')
			});
			//!steal-remove-end
			return computeObj;
		};
	},
	// Returns a function that creates the `_computed` prop.
	compute: function(prop, get, defaultValueFn) {

		return function() {
			var map = this,
				defaultValue = defaultValueFn && defaultValueFn.call(this),
				observable, computeObj;

			if(get.length === 0) {
				observable = new canObservation_4_0_1_canObservation(get, map);
			} else if(get.length === 1) {
				observable = new settable(get, map, defaultValue);
			} else {
				observable = new async(get, map, defaultValue);
			}

			computeObj = make.computeObj(map, prop, observable);

			//!steal-remove-start
			Object.defineProperty(computeObj.handler, "name", {
				value: canReflect_1_16_7_canReflect.getName(get).replace('getter', 'event emitter')
			});
			//!steal-remove-end

			return computeObj;
		};
	},
	// Set related helpers.
	set: {
		data: function(prop) {
			return function(newVal) {
				this._data[prop] = newVal;
			};
		},
		computed: function(prop) {
			return function(val) {
				canReflect_1_16_7_canReflect.setValue( this._computed[prop].compute, val );
			};
		},
		events: function(prop, getCurrent, setData, eventType) {
			return function(newVal) {
				if (this.__inSetup) {
					setData.call(this, newVal);
				}
				else {
					var current = getCurrent.call(this);
					if (newVal !== current) {
						setData.call(this, newVal);

						this.dispatch({
							patches: [{type: "set", key: prop, value: newVal}],
							type: prop,
							target: this,
							//!steal-remove-start
							reasonLog: [ canReflect_1_16_7_canReflect.getName(this) + "'s", prop, "changed to", newVal, "from", current ],
							//!steal-remove-end
						}, [newVal, current]);
					}
				}
			};
		},
		setter: function(prop, setter, getCurrent, setEvents, hasGetter) {
			return function(value) {
				//!steal-remove-start
				var asyncTimer;
				//!steal-remove-end

				var self = this;

				// call the setter, if returned value is undefined,
				// this means the setter is async so we
				// do not call update property and return right away

				canQueues_1_1_0_canQueues.batch.start();
				var setterCalled = false,
					current = getCurrent.call(this),
					setValue = setter.call(this, value, function(value) {
						setEvents.call(self, value);

						setterCalled = true;
						//!steal-remove-start
						clearTimeout(asyncTimer);
						//!steal-remove-end
					}, current);

				if (setterCalled) {
					canQueues_1_1_0_canQueues.batch.stop();
				} else {
					if (hasGetter) {
						// we got a return value
						if (setValue !== undefined) {
							// if the current `set` value is returned, don't set
							// because current might be the `lastSetVal` of the internal compute.
							if (current !== setValue) {
								setEvents.call(this, setValue);
							}
							canQueues_1_1_0_canQueues.batch.stop();
						}
						// this is a side effect, it didn't take a value
						// so use the original set value
						else if (setter.length === 0) {
							setEvents.call(this, value);
							canQueues_1_1_0_canQueues.batch.stop();
							return;
						}
						// it took a value
						else if (setter.length === 1) {
							// if we have a getter, and undefined was returned,
							// we should assume this is setting the getters properties
							// and we shouldn't do anything.
							canQueues_1_1_0_canQueues.batch.stop();
						}
						// we are expecting something
						else {
							//!steal-remove-start
							asyncTimer = setTimeout(function() {
								dev.warn('can/map/setter.js: Setter "' + prop + '" did not return a value or call the setter callback.');
							}, dev.warnTimeout);
							//!steal-remove-end
							canQueues_1_1_0_canQueues.batch.stop();
							return;
						}
					} else {
						// we got a return value
						if (setValue !== undefined) {
							// if the current `set` value is returned, don't set
							// because current might be the `lastSetVal` of the internal compute.
							setEvents.call(this, setValue);
							canQueues_1_1_0_canQueues.batch.stop();
						}
						// this is a side effect, it didn't take a value
						// so use the original set value
						else if (setter.length === 0) {
							setEvents.call(this, value);
							canQueues_1_1_0_canQueues.batch.stop();
							return;
						}
						// it took a value
						else if (setter.length === 1) {
							// if we don't have a getter, we should probably be setting the
							// value to undefined
							setEvents.call(this, undefined);
							canQueues_1_1_0_canQueues.batch.stop();
						}
						// we are expecting something
						else {
							//!steal-remove-start
							asyncTimer = setTimeout(function() {
								dev.warn('can/map/setter.js: Setter "' + prop + '" did not return a value or call the setter callback.');
							}, dev.warnTimeout);
							//!steal-remove-end
							canQueues_1_1_0_canQueues.batch.stop();
							return;
						}
					}


				}
			};
		},
		type: function(prop, type, set) {
			function setter(newValue) {
				return set.call(this, type.call(this, newValue, prop));
			}
			if(isDefineType(type)) {
				// TODO: remove this `canDefineType` check in a future release.
				if(type.canDefineType) {
					return setter;
				} else {
					return function setter(newValue){
						return set.call(this, canReflect_1_16_7_canReflect.convert(newValue, type));
					};
				}
			}
			// If type is a nested object: `type: {foo: "string", bar: "number"}`
			if (typeof type === "object") {
				return make.set.Type(prop, type, set);
			} else {
				return setter;
			}
		},
		Type: function(prop, Type, set) {
			// `type`: {foo: "string"}
			if(Array.isArray(Type) && define.DefineList) {
				Type = define.DefineList.extend({
					"#": Type[0]
				});
			} else if (typeof Type === "object") {
				if(define.DefineMap) {
					Type = define.DefineMap.extend(Type);
				} else {
					Type = define.Constructor(Type);
				}
			}
			return function(newValue) {
				if (newValue instanceof Type || newValue == null) {
					return set.call(this, newValue);
				} else {
					return set.call(this, new Type(newValue));
				}
			};
		}
	},
	// Helpes that indicate what the event type should be.  These probably aren't needed.
	eventType: {
		data: function(prop) {
			return function(newVal, oldVal) {
				return oldVal !== undefined || this._data.hasOwnProperty(prop) ? "set" : "add";
			};
		},
		computed: function() {
			return function() {
				return "set";
			};
		}
	},
	// Helpers that read the data in a non-observable way.
	read: {
		data: function(prop) {
			return function() {
				return this._data[prop];
			};
		},
		computed: function(prop) {
			// might want to protect this
			return function() {
				return canReflect_1_16_7_canReflect.getValue( this._computed[prop].compute );
			};
		},
		lastSet: function(prop) {
			return function() {
				var observable = this._computed[prop].compute;
				if(observable.lastSetValue) {
					return canReflect_1_16_7_canReflect.getValue(observable.lastSetValue);
				}
			};
		}
	},
	// Helpers that read the data in an observable way.
	get: {
		// uses the default value
		defaultValue: function(prop, definition, typeConvert, callSetter) {
			return function() {
				var value = definition.default;
				if (value !== undefined) {
					if (typeof value === "function") {
						value = value.call(this);
					}
					value = typeConvert(value);
				}
				else {
					var Default = definition.Default;
					if (Default) {
						value = typeConvert(new Default());
					}
				}
				if(definition.set) {
					// TODO: there's almost certainly a faster way of making this happen
					// But this is maintainable.

					var VALUE;
					var sync = true;

					var setter = make.set.setter(prop, definition.set, function(){}, function(value){
						if(sync) {
							VALUE = value;
						} else {
							callSetter.call(this, value);
						}
					}, definition.get);

					setter.call(this,value);
					sync= false;

					// VALUE will be undefined if the callback is never called.
					return VALUE;


				}
				return value;
			};
		},
		data: function(prop) {
			return function() {
				if (!this.__inSetup) {
					canObservationRecorder_1_1_2_canObservationRecorder.add(this, prop);
				}

				return this._data[prop];
			};
		},
		computed: function(prop) {
			return function(val) {
				var compute = this._computed[prop].compute;
				if (canObservationRecorder_1_1_2_canObservationRecorder.isRecording()) {
					canObservationRecorder_1_1_2_canObservationRecorder.add(this, prop);
					if (!canReflect_1_16_7_canReflect.isBound(compute)) {
						canObservation_4_0_1_canObservation.temporarilyBind(compute);
					}
				}

				return peek$2(compute);
			};
		}
	}
};

define.behaviors = ["get", "set", "value", "Value", "type", "Type", "serialize"];

// This cleans up a particular behavior and adds it to the definition
var addBehaviorToDefinition = function(definition, behavior, value) {
	if(behavior === "enumerable") {
		// treat enumerable like serialize
		definition.serialize = !!value;
	}
	else if(behavior === "type") {
		var behaviorDef = value;
		if(typeof behaviorDef === "string") {
			behaviorDef = define.types[behaviorDef];
			if(typeof behaviorDef === "object" && !isDefineType(behaviorDef)) {
				canAssign_1_1_1_canAssign(definition, behaviorDef);
				behaviorDef = behaviorDef[behavior];
			}
		}
		if (typeof behaviorDef !== 'undefined') {
			definition[behavior] = behaviorDef;
		}
	}
	else {
		definition[behavior] = value;
	}
};

// This is called by `define.property` AND `getDefinitionOrMethod` (which is called by `define`)
// Currently, this is adding default behavior
// copying `type` over, and even cleaning up the final definition object
makeDefinition = function(prop, def, defaultDefinition) {
	var definition = {};

	canReflect_1_16_7_canReflect.eachKey(def, function(value, behavior) {
		addBehaviorToDefinition(definition, behavior, value);
	});
	// only add default if it doesn't exist
	canReflect_1_16_7_canReflect.eachKey(defaultDefinition, function(value, prop){
		if(definition[prop] === undefined) {
			if(prop !== "type" && prop !== "Type") {
				definition[prop] = value;
			}
		}
	});

	// normalize Type that implements can.new
	if(def.Type) {
		var value = def.Type;

		var serialize = value[serializeSymbol];
		if(serialize) {
			definition.serialize = function(val){
				return serialize.call(val);
			};
		}
		if(value[newSymbol$1]) {
			definition.type = value[newSymbol$1];
			delete definition.Type;
		}
	}

	// We only want to add a defaultDefinition if def.type is not a string
	// if def.type is a string it is handled in addDefinition
	if(typeof def.type !== 'string') {
		// if there's no type definition, take it from the defaultDefinition
		if(!definition.type && !definition.Type) {
            var defaultsCopy = canReflect_1_16_7_canReflect.assignMap({},defaultDefinition);
            definition = canReflect_1_16_7_canReflect.assignMap(defaultsCopy, definition);
		}

		if( canReflect_1_16_7_canReflect.size(definition) === 0 ) {
			definition.type = define.types["*"];
		}
	}
	cleanUpDefinition(prop, definition, true);
	return definition;
};

// called by `can.defineInstanceKey` and `getDefinitionsAndMethods`
// returns the value or the definition object.
// calls makeDefinition
// This is dealing with a string value
getDefinitionOrMethod = function(prop, value, defaultDefinition){
	// Clean up the value to make it a definition-like object
	var definition;
	if(typeof value === "string") {
		definition = {type: value};
	}
    // copies a `Type`'s methods over
	else if(value && (value[serializeSymbol] || value[newSymbol$1]) ) {
		definition = { Type: value };
	}
	else if(typeof value === "function") {
		if(canReflect_1_16_7_canReflect.isConstructorLike(value)) {
			definition = {Type: value};
		}
		// or leaves as a function
	} else if( Array.isArray(value) ) {
		definition = {Type: value};
	} else if( canReflect_1_16_7_canReflect.isPlainObject(value) ){
		definition = value;
	}

	if(definition) {
		return makeDefinition(prop, definition, defaultDefinition);
	}
	else {
		return value;
	}
};
// called by can.define
getDefinitionsAndMethods = function(defines, baseDefines) {
	// make it so the definitions include base definitions on the proto
	var definitions = Object.create(baseDefines ? baseDefines.definitions : null);
	var methods = {};
	// first lets get a default if it exists
	var defaults = defines["*"],
		defaultDefinition;
	if(defaults) {
		delete defines["*"];
		defaultDefinition = getDefinitionOrMethod("*", defaults, {});
	} else {
		defaultDefinition = Object.create(null);
	}

	eachPropertyDescriptor(defines, function( prop, propertyDescriptor ) {

		var value;
		if(propertyDescriptor.get || propertyDescriptor.set) {
			value = {get: propertyDescriptor.get, set: propertyDescriptor.set};
		} else {
			value = propertyDescriptor.value;
		}

		if(prop === "constructor") {
			methods[prop] = value;
			return;
		} else {
			var result = getDefinitionOrMethod(prop, value, defaultDefinition);
			if(result && typeof result === "object" && canReflect_1_16_7_canReflect.size(result) > 0) {
				definitions[prop] = result;
			}
			else {
				// Removed adding raw values that are not functions
				if (typeof result === 'function') {
					methods[prop] = result;
				}
				//!steal-remove-start
				else if (typeof result !== 'undefined') {
                    // Ex: {prop: 0}
					dev.error(prop + (this.constructor.shortName ? " on " + this.constructor.shortName : "") + " does not match a supported propDefinition. See: https://canjs.com/doc/can-define.types.propDefinition.html");
				}
				//!steal-remove-end
			}
		}
	});
	if(defaults) {
		defines["*"] = defaults;
	}
	return {definitions: definitions, methods: methods, defaultDefinition: defaultDefinition};
};

eventsProto = map$1({});

function setupComputed(instance, eventName) {
	var computedBinding = instance._computed && instance._computed[eventName];
	if (computedBinding && computedBinding.compute) {
		if (!computedBinding.count) {
			computedBinding.count = 1;
			canReflect_1_16_7_canReflect.onValue(computedBinding.compute, computedBinding.handler, "notify");
			computedBinding.oldValue = canReflect_1_16_7_canReflect.getValue(computedBinding.compute);
		} else {
			computedBinding.count++;
		}

	}
}
function teardownComputed(instance, eventName){
	var computedBinding = instance._computed && instance._computed[eventName];
	if (computedBinding) {
		if (computedBinding.count === 1) {
			computedBinding.count = 0;
			canReflect_1_16_7_canReflect.offValue(computedBinding.compute, computedBinding.handler,"notify");
		} else {
			computedBinding.count--;
		}
	}
}

var canMetaSymbol = canSymbol_1_6_1_canSymbol.for("can.meta");
canAssign_1_1_1_canAssign(eventsProto, {
	_eventSetup: function() {},
	_eventTeardown: function() {},
	addEventListener: function(eventName, handler, queue) {
		setupComputed(this, eventName);
		return map$1.addEventListener.apply(this, arguments);
	},

	// ### unbind
	// Stops listening to an event.
	// If this is the last listener of a computed property,
	// stop forwarding events of the computed property to this map.
	removeEventListener: function(eventName, handler) {
		teardownComputed(this, eventName);
		return map$1.removeEventListener.apply(this, arguments);

	}
});
eventsProto.on = eventsProto.bind = eventsProto.addEventListener;
eventsProto.off = eventsProto.unbind = eventsProto.removeEventListener;


var onKeyValueSymbol$2 = canSymbol_1_6_1_canSymbol.for("can.onKeyValue");
var offKeyValueSymbol$1 = canSymbol_1_6_1_canSymbol.for("can.offKeyValue");

canReflect_1_16_7_canReflect.assignSymbols(eventsProto,{
	"can.onKeyValue": function(key){
		setupComputed(this, key);
		return map$1[onKeyValueSymbol$2].apply(this, arguments);
	},
	"can.offKeyValue": function(key){
		teardownComputed(this, key);
		return map$1[offKeyValueSymbol$1].apply(this, arguments);
	}
});

delete eventsProto.one;

define.setup = function(props, sealed) {
	Object.defineProperty(this,"constructor", {value: this.constructor, enumerable: false, writable: false});
	Object.defineProperty(this,canMetaSymbol, {value: Object.create(null), enumerable: false, writable: false});

	/* jshint -W030 */

	var definitions = this._define.definitions;
	var instanceDefinitions = Object.create(null);
	var map = this;
	canReflect_1_16_7_canReflect.eachKey(props, function(value, prop){
		if(definitions[prop] !== undefined) {
			map[prop] = value;
		} else {
			var def = define.makeSimpleGetterSetter(prop);
			instanceDefinitions[prop] = {};
			Object_defineNamedPrototypeProperty(map, prop, def);
			// possibly convert value to List or DefineMap
			map[prop] = define.types.observable(value);
		}
	});
	if(canReflect_1_16_7_canReflect.size(instanceDefinitions) > 0) {
		defineConfigurableAndNotEnumerable(this, "_instanceDefinitions", instanceDefinitions);
	}
	// only seal in dev mode for performance reasons.
	//!steal-remove-start
	this._data;
	this._computed;
	if(sealed !== false) {
		Object.seal(this);
	}
	//!steal-remove-end
};
define.replaceWith = canDefineLazyValue_1_0_2_defineLazyValue;
define.eventsProto = eventsProto;
define.defineConfigurableAndNotEnumerable = defineConfigurableAndNotEnumerable;
define.make = make;
define.getDefinitionOrMethod = getDefinitionOrMethod;
var simpleGetterSetters = {};
define.makeSimpleGetterSetter = function(prop){
	if(simpleGetterSetters[prop] === undefined) {

		var setter = make.set.events(prop, make.get.data(prop), make.set.data(prop), make.eventType.data(prop) );

		simpleGetterSetters[prop] = {
			get: make.get.data(prop),
			set: function(newVal){
				return setter.call(this, define.types.observable(newVal));
			},
			enumerable: true
		};
	}
	return simpleGetterSetters[prop];
};

define.Iterator = function(obj){
	this.obj = obj;
	this.definitions = Object.keys(obj._define.definitions);
	this.instanceDefinitions = obj._instanceDefinitions ?
		Object.keys(obj._instanceDefinitions) :
		Object.keys(obj);
	this.hasGet = typeof obj.get === "function";
};

define.Iterator.prototype.next = function(){
	var key;
	if(this.definitions.length) {
		key = this.definitions.shift();

		// Getters should not be enumerable
		var def = this.obj._define.definitions[key];
		if(def.get) {
			return this.next();
		}
	} else if(this.instanceDefinitions.length) {
		key = this.instanceDefinitions.shift();
	} else {
		return {
			value: undefined,
			done: true
		};
	}

	return {
		value: [
			key,
			this.hasGet ? this.obj.get(key) : this.obj[key]
		],
		done: false
	};
};



function isObservableValue(obj){
	return canReflect_1_16_7_canReflect.isValueLike(obj) && canReflect_1_16_7_canReflect.isObservableLike(obj);
}

define.types = {
	// To be made into a type ... this is both lazy {time: '123-456'}
	'date': maybeDate,
	'number': maybeNumber,
	'boolean': maybeBoolean,
	'observable': function(newVal) {
			if(Array.isArray(newVal) && define.DefineList) {
					newVal = new define.DefineList(newVal);
			}
			else if(canReflect_1_16_7_canReflect.isPlainObject(newVal) &&  define.DefineMap) {
					newVal = new define.DefineMap(newVal);
			}
			return newVal;
	},
	'stringOrObservable': function(newVal) {
		if(Array.isArray(newVal)) {
			return new define.DefaultList(newVal);
		}
		else if(canReflect_1_16_7_canReflect.isPlainObject(newVal)) {
			return new define.DefaultMap(newVal);
		}
		else {
			return canReflect_1_16_7_canReflect.convert( newVal, define.types.string);
		}
	},
	/**
	 * Implements HTML-style boolean logic for attribute strings, where
	 * any string, including "", is truthy.
	 */
	'htmlbool': function(val) {
		if (val === '') {
			return true;
		}
		return !!canStringToAny_1_0_1_canStringToAny(val);
	},
	'*': function(val) {
		return val;
	},
	'any': function(val) {
		return val;
	},
	'string': maybeString,

	'compute': {
		set: function(newValue, setVal, setErr, oldValue) {
			if (isObservableValue(newValue) ) {
				return newValue;
			}
			if (isObservableValue(oldValue)) {
				canReflect_1_16_7_canReflect.setValue(oldValue,newValue);
				return oldValue;
			}
			return newValue;
		},
		get: function(value) {
			return isObservableValue(value) ? canReflect_1_16_7_canReflect.getValue(value) : value;
		}
	}
};

define.updateSchemaKeys = function(schema, definitions) {
	for(var prop in definitions) {
		var definition = definitions[prop];
		if(definition.serialize !== false ) {
			if(definition.type) {
				schema.keys[prop] = definition.type;
			} else {
				schema.keys[prop] = function(val){ return val; };
			}
			 // some unknown type
			if(definitions[prop].identity === true) {
				schema.identity.push(prop);
			}
		}
	}
	return schema;
};

// ##string.js
// _Miscellaneous string utility functions._
// Several of the methods in this plugin use code adapted from Prototype
// Prototype JavaScript framework, version 1.6.0.1.
// Â© 2005-2007 Sam Stephenson
var strUndHash = /_|-/,
	strColons = /\=\=/,
	strWords = /([A-Z]+)([A-Z][a-z])/g,
	strLowUp = /([a-z\d])([A-Z])/g,
	strDash = /([a-z\d])([A-Z])/g,
	strQuote = /"/g,
	strSingleQuote = /'/g,
	strHyphenMatch = /-+(.)?/g,
	strCamelMatch = /[a-z][A-Z]/g,
	convertBadValues = function (content) {
		// Convert bad values into empty strings
		var isInvalid = content === null || content === undefined || isNaN(content) && '' + content === 'NaN';
		return '' + (isInvalid ? '' : content);
	};

var string = {
	/**
	 * @function can-string.esc esc
	 * @signature `string.esc(content)`
	 * @param  {String} content a string
	 * @return {String}         the string safely HTML-escaped
	 *
	 * ```js
	 * var string = require("can-string");
	 *
	 * string.esc("<div>&nbsp;</div>"); //-> "&lt;div&gt;&amp;nbsp;&lt;/div&gt;"
	 * ```
	 */
	esc: function (content) {
		return convertBadValues(content)
			.replace(/&/g, '&amp;')
			.replace(/</g, '&lt;')
			.replace(/>/g, '&gt;')
			.replace(strQuote, '&#34;')
			.replace(strSingleQuote, '&#39;');
	},
	/**
	 * @function can-string.capitalize capitalize
	 * @signature `string.capitalize(s)`
	 * @param  {String} s     the string to capitalize
	 * @return {String}       the supplied string with the first character uppercased if it is a letter
	 *
	 * ```js
	 * var string = require("can-string");
	 *
	 * console.log(string.capitalize("foo")); // -> "Foo"
	 * console.log(string.capitalize("123")); // -> "123"
	 * ```
	 */
	capitalize: function (s) {
		// Used to make newId.
		return s.charAt(0)
			.toUpperCase() + s.slice(1);
	},
	/**
	 * @function can-string.camelize camelize
	 * @signature `string.camelize(s)`
	 * @param  {String} str   the string to camelCase
	 * @return {String}       the supplied string with hyphens removed and following letters capitalized.
	 *
	 * ```js
	 * var string = require("can-string");
	 *
	 * console.log(string.camelize("foo-bar")); // -> "fooBar"
	 * console.log(string.camelize("-webkit-flex-flow")); // -> "WebkitFlexFlow"
	 * ```
	 */
	camelize: function (str) {
		return convertBadValues(str)
			.replace(strHyphenMatch, function (match, chr) {
				return chr ? chr.toUpperCase() : '';
			});
	},
	/**
	 * @function can-string.hyphenate hyphenate
	 * @signature `string.hyphenate(s)`
	 * @param  {String} str   a string in camelCase
	 * @return {String}       the supplied string with camelCase converted to hyphen-lowercase digraphs
	 *
	 * ```js
	 * var string = require("can-string");
	 *
	 * console.log(string.hyphenate("fooBar")); // -> "foo-bar"
	 * console.log(string.hyphenate("WebkitFlexFlow")); // -> "Webkit-flex-flow"
	 * ```
	 */
	hyphenate: function (str) {
		return convertBadValues(str)
			.replace(strCamelMatch, function (str) {
				return str.charAt(0) + '-' + str.charAt(1)
					.toLowerCase();
			});
	},
	/**
	 * @function can-string.underscore underscore
	 * @signature `string.underscore(s)`
	 * @param  {String} str   a string in camelCase
	 * @return {String}       the supplied string with camelCase converted to underscore-lowercase digraphs
	 *
	 * ```js
	 * var string = require("can-string");
	 *
	 * console.log(string.underscore("fooBar")); // -> "foo_bar"
	 * console.log(string.underscore("HTMLElement")); // -> "html_element"
	 * ```
	 */
	underscore: function (s) {
		return s.replace(strColons, '/')
			.replace(strWords, '$1_$2')
			.replace(strLowUp, '$1_$2')
			.replace(strDash, '_')
			.toLowerCase();
	},
	/**
	 * @property {RegExp} can-string.strUndHash strUndHash
	 *
	 * A regex which matches an underscore or hyphen character
	 */
	undHash: strUndHash
};
var canString_0_0_5_canString = string;

//!steal-remove-start

var reservedWords = {
	"abstract": true,
	"boolean": true,
	"break": true,
	"byte": true,
	"case": true,
	"catch": true,
	"char": true,
	"class": true,
	"const": true,
	"continue": true,
	"debugger": true,
	"default": true,
	"delete": true,
	"do": true,
	"double": true,
	"else": true,
	"enum": true,
	"export": true,
	"extends": true,
	"false": true,
	"final": true,
	"finally": true,
	"float": true,
	"for": true,
	"function": true,
	"goto": true,
	"if": true,
	"implements": true,
	"import": true,
	"in": true,
	"instanceof": true,
	"int": true,
	"interface": true,
	"let": true,
	"long": true,
	"native": true,
	"new": true,
	"null": true,
	"package": true,
	"private": true,
	"protected": true,
	"public": true,
	"return": true,
	"short": true,
	"static": true,
	"super": true,
	"switch": true,
	"synchronized": true,
	"this": true,
	"throw": true,
	"throws": true,
	"transient": true,
	"true": true,
	"try": true,
	"typeof": true,
	"var": true,
	"void": true,
	"volatile": true,
	"while": true,
	"with": true
};
var constructorNameRegex = /[^A-Z0-9_]/gi;
//!steal-remove-end

// ## construct.js
// `Construct`
// _This is a modified version of
// [John Resig's class](http://ejohn.org/blog/simple-javascript-inheritance/).
// It provides class level inheritance and callbacks._
// A private flag used to initialize a new class instance without
// initializing it's bindings.
var initializing = 0;

//!steal-remove-start
var namedCtor = (function(cache){
	return function(name, fn) {
		return ((name in cache) ? cache[name] : cache[name] = new Function(
			"__", "function "+name+"(){return __.apply(this,arguments)};return "+name
		))( fn );
	};
}({}));
//!steal-remove-end

/**
 * @add can-construct
 */
var Construct = function () {
	if (arguments.length) {
		return Construct.extend.apply(Construct, arguments);
	}
};

var canGetDescriptor;
try {
	canGetDescriptor = true;
} catch(e) {
	canGetDescriptor = false;
}

var getDescriptor = function(newProps, name) {
		var descriptor = Object.getOwnPropertyDescriptor(newProps, name);
		if(descriptor && (descriptor.get || descriptor.set)) {
			return descriptor;
		}
		return null;
	},
	inheritGetterSetter = function(newProps, oldProps, addTo) {
		addTo = addTo || newProps;
		var descriptor;

		for (var name in newProps) {
			if( (descriptor = getDescriptor(newProps, name)) ) {
				this._defineProperty(addTo, oldProps, name, descriptor);
			} else {
				Construct._overwrite(addTo, oldProps, name, newProps[name]);
			}
		}
	},
	simpleInherit = function (newProps, oldProps, addTo) {
		addTo = addTo || newProps;

		for (var name in newProps) {
			Construct._overwrite(addTo, oldProps, name, newProps[name]);
		}
	};
/**
 * @static
 */
canReflect_1_16_7_canReflect.assignMap(Construct, {
	/**
	 * @property {Boolean} can-construct.constructorExtends constructorExtends
	 * @parent can-construct.static
	 *
	 * @description
	 * Toggles the behavior of a constructor function called
	 * without the `new` keyword to extend the constructor function or
	 * create a new instance.
	 *
	 * ```js
	 * var animal = Animal();
	 * // vs
	 * var animal = new Animal();
	 * ```
	 *
	 * @body
	 *
	 * If `constructorExtends` is:
	 *
	 *  - `true` - the constructor extends
	 *  - `false` - a new instance of the constructor is created
	 *
	 * This property defaults to false.
	 *
	 * Example of constructExtends as `true`:
	 *
	 * ```js
	 * var Animal = Construct.extend({
	 *   constructorExtends: true // the constructor extends
	 * },{
	 *   sayHi: function() {
	 *     console.log("hai!");
	 *   }
	 * });
	 *
	 * var Pony = Animal({
	 *   gallop: function () {
	 *      console.log("Galloping!!");
	 *   }
	 * }); // Pony is now a constructor function extended from Animal
	 *
	 * var frank = new Animal(); // frank is a new instance of Animal
	 *
	 * var gertrude = new Pony(); // gertrude is a new instance of Pony
	 * gertrude.sayHi(); // "hai!" - sayHi is "inherited" from Animal
	 * gertrude.gallop(); // "Galloping!!" - gallop is unique to instances of Pony
	 *```
	 *
	 * The default behavior is shown in the example below:
	 *
	 * ```js
	 * var Animal = Construct.extend({
	 *   constructorExtends: false // the constructor does NOT extend
	 * },{
	 *   sayHi: function() {
	 *     console.log("hai!");
	 *   }
	 * });
	 *
	 * var pony = Animal(); // pony is a new instance of Animal
	 * var frank = new Animal(); // frank is a new instance of Animal
	 *
	 * pony.sayHi() // "hai!"
	 * frank.sayHi() // "hai!"
	 *```
	 * By default to extend a constructor, you must use [can-construct.extend extend].
	 */
	constructorExtends: true,
	/**
	 * @function can-construct.newInstance newInstance
	 * @parent can-construct.static
	 *
	 * @description Returns an instance of `Construct`. This method
	 * can be overridden to return a cached instance.
	 *
	 * @signature `Construct.newInstance([...args])`
	 *
	 * @param {*} [args] arguments that get passed to [can-construct::setup] and [can-construct::init]. Note
	 * that if [can-construct::setup] returns an array, those arguments will be passed to [can-construct::init]
	 * instead.
	 * @return {class} instance of the class
	 *
	 * @body
	 * Creates a new instance of the constructor function. This method is useful for creating new instances
	 * with arbitrary parameters. Typically, however, you will simply want to call the constructor with the
	 * __new__ operator.
	 *
	 * ## Example
	 *
	 * The following creates a `Person` Construct and overrides `newInstance` to cache all
	 * instances of Person to prevent duplication. If the properties of a new Person match an existing one it
	 * will return a reference to the previously created object, otherwise it returns a new object entirely.
	 *
	 * ```js
	 * // define and create the Person constructor
	 * var Person = Construct.extend({
	 *   init : function(first, middle, last) {
	 *     this.first = first;
	 *     this.middle = middle;
	 *     this.last = last;
	 *   }
	 * });
	 *
	 * // store a reference to the original newInstance function
	 * var _newInstance = Person.newInstance;
	 *
	 * // override Person's newInstance function
	 * Person.newInstance = function() {
	 *   // if cache does not exist make it an new object
	 *   this.__cache = this.__cache || {};
	 *   // id is a stingified version of the passed arguments
	 *   var id = JSON.stringify(arguments);
	 *
	 *   // look in the cache to see if the object already exists
	 *   var cachedInst = this.__cache[id];
	 *   if(cachedInst) {
	 *     return cachedInst;
	 *   }
	 *
	 *   //otherwise call the original newInstance function and return a new instance of Person.
	 *   var newInst = _newInstance.apply(this, arguments);
	 *   this.__cache[id] = newInst;
	 *   return newInst;
	 * };
	 *
	 * // create two instances with the same arguments
	 * var justin = new Person('Justin', 'Barry', 'Meyer'),
	 *		brian = new Person('Justin', 'Barry', 'Meyer');
	 *
	 * console.log(justin === brian); // true - both are references to the same instance
	 * ```
	 *
	 */
	newInstance: function () {
		// Get a raw instance object (`init` is not called).
		var inst = this.instance(),
			args;
		// Call `setup` if there is a `setup`
		if (inst.setup) {
			Object.defineProperty(inst,"__inSetup",{
				configurable: true,
				enumerable: false,
				value: true,
				writable: true
			});
			args = inst.setup.apply(inst, arguments);
			if (args instanceof Construct.ReturnValue){
				return args.value;
			}
			inst.__inSetup = false;
		}
		// Call `init` if there is an `init`
		// If `setup` returned `args`, use those as the arguments
		if (inst.init) {
			inst.init.apply(inst, args || arguments);
		}
		return inst;
	},
	// Overwrites an object with methods. Used in the `super` plugin.
	// `newProps` - New properties to add.
	// `oldProps` - Where the old properties might be (used with `super`).
	// `addTo` - What we are adding to.
	_inherit: canGetDescriptor ? inheritGetterSetter : simpleInherit,

	// Adds a `defineProperty` with the given name and descriptor
	// Will only ever be called if ES5 is supported
	_defineProperty: function(what, oldProps, propName, descriptor) {
		Object.defineProperty(what, propName, descriptor);
	},

	// used for overwriting a single property.
	// this should be used for patching other objects
	// the super plugin overwrites this
	_overwrite: function (what, oldProps, propName, val) {
		Object.defineProperty(what, propName, {value: val, configurable: true, enumerable: true, writable: true});
	},
	// Set `defaults` as the merger of the parent `defaults` and this
	// object's `defaults`. If you overwrite this method, make sure to
	// include option merging logic.
	/**
	 * @function can-construct.setup setup
	 * @parent can-construct.static
	 *
	 * @description Perform initialization logic for a constructor function.
	 *
	 * @signature `Construct.setup(base, fullName, staticProps, protoProps)`
	 *
	 * A static `setup` method provides inheritable setup functionality
	 * for a Constructor function. The following example
	 * creates a Group constructor function.  Any constructor
	 * functions that inherit from Group will be added to
	 * `Group.childGroups`.
	 *
	 *
	 *     Group = Construct.extend({
	 *       setup: function(Construct, fullName, staticProps, protoProps){
	 *         this.childGroups = [];
	 *         if(Construct !== Construct){
	 *           this.childGroups.push(Construct)
	 *         }
	 *         Construct.setup.apply(this, arguments)
	 *       }
	 *     },{})
	 *     var Flock = Group.extend(...)
	 *     Group.childGroups[0] //-> Flock
	 *
	 * @param {constructor} base The base constructor that is being inherited from.
	 * @param {String} fullName The name of the new constructor.
	 * @param {Object} staticProps The static properties of the new constructor.
	 * @param {Object} protoProps The prototype properties of the new constructor.
	 *
	 * @body
	 * The static `setup` method is called immediately after a constructor
	 * function is created and
	 * set to inherit from its base constructor. It is useful for setting up
	 * additional inheritance work.
	 * Do not confuse this with the prototype `[can-construct::setup]` method.
	 *
	 * ## Example
	 *
	 * This `Parent` class adds a reference to its base class to itself, and
	 * so do all the classes that inherit from it.
	 *
	 * ```js
	 * Parent = Construct.extend({
	 *   setup : function(base, fullName, staticProps, protoProps){
	 *     this.base = base;
	 *
	 *     // call base functionality
	 *     Construct.setup.apply(this, arguments)
	 *   }
	 * },{});
	 *
	 * Parent.base; // Construct
	 *
	 * Child = Parent({});
	 *
	 * Child.base; // Parent
	 * ```
	 */
	setup: function (base) {
		var defaults = canReflect_1_16_7_canReflect.assignDeepMap({},base.defaults);
		this.defaults = canReflect_1_16_7_canReflect.assignDeepMap(defaults,this.defaults);
	},
	// Create's a new `class` instance without initializing by setting the
	// `initializing` flag.
	instance: function () {
		// Prevents running `init`.
		initializing = 1;
		var inst = new this();
		// Allow running `init`.
		initializing = 0;
		return inst;
	},
	// Extends classes.
	/**
	 * @function can-construct.extend extend
	 * @parent can-construct.static
	 *
	 * @signature `Construct.extend([name,] [staticProperties,] instanceProperties)`
	 *
	 * Extends `Construct`, or constructor functions derived from `Construct`,
	 * to create a new constructor function. Example:
	 *
	 * ```js
	 * var Animal = Construct.extend({
	 *   sayHi: function(){
	 *     console.log("hi")
	 *   }
	 * });
	 *
	 * var animal = new Animal()
	 * animal.sayHi();
	 * ```
	 *
	 * @param {String} [name] Adds a name to the constructor function so
	 * it is nicely labeled in the developer tools. The following:
	 *
	 *     Construct.extend("ConstructorName",{})
	 *
	 * returns a constructur function that will show up as `ConstructorName`
	 * in the developer tools.
	 * It also sets "ConstructorName" as [can-construct.shortName shortName].
	 *
	 * @param {Object} [staticProperties] Properties that are added the constructor
	 * function directly. For example:
	 *
	 * ```js
	 * var Animal = Construct.extend({
	 *   findAll: function(){
	 *     return can.ajax({url: "/animals"})
	 *   }
	 * },{}); // need to pass an empty instanceProperties object
	 *
	 * Animal.findAll().then(function(json){ ... })
	 * ```
	 *
	 * The [can-construct.setup static setup] method can be used to
	 * specify inheritable behavior when a Constructor function is created.
	 *
	 * @param {Object} instanceProperties Properties that belong to
	 * instances made with the constructor. These properties are added to the
	 * constructor's `prototype` object. Example:
	 *
	 *     var Animal = Construct.extend({
	 *		  findAll: function() {
	 *			return can.ajax({url: "/animals"});
	 *		  }
	 *     },{
	 *       init: function(name) {
	 *         this.name = name;
	 *       },
	 *       sayHi: function() {
	 *         console.log(this.name," says hai!");
	 *       }
	 *     })
	 *     var pony = new Animal("Gertrude");
	 *     pony.sayHi(); // "Gertrude says hai!"
	 *
	 * The [can-construct::init init] and [can-construct::setup setup] properties
	 * are used for initialization.
	 *
	 * @return {function} The constructor function.
	 *
	 * ```js
	 *	var Animal = Construct.extend(...);
	 *	var pony = new Animal(); // Animal is a constructor function
	 * ```
	 * @body
	 * ## Inheritance
	 * Creating "subclasses" with `Construct` is simple. All you need to do is call the base constructor
	 * with the new function's static and instance properties. For example, we want our `Snake` to
	 * be an `Animal`, but there are some differences:
	 *
	 *
	 *     var Snake = Animal.extend({
	 *         legs: 0
	 *     }, {
	 *         init: function() {
	 *             Animal.prototype.init.call(this, 'ssssss');
	 *         },
	 *         slither: function() {
	 *             console.log('slithering...');
	 *         }
	 *     });
	 *
	 *     var baslisk = new Snake();
	 *     baslisk.speak();   // "ssssss"
	 *     baslisk.slither(); // "slithering..."
	 *     baslisk instanceof Snake;  // true
	 *     baslisk instanceof Animal; // true
	 *
	 *
	 * ## Static properties and inheritance
	 *
	 * If you pass all three arguments to Construct, the second one will be attached directy to the
	 * constructor, allowing you to imitate static properties and functions. You can access these
	 * properties through the `[can-construct::constructor this.constructor]` property.
	 *
	 * Static properties can get overridden through inheritance just like instance properties. In the example below,
	 * we override both the legs static property as well as the the init function for each instance:
	 *
	 * ```js
	 * var Animal = Construct.extend({
	 *     legs: 4
	 * }, {
	 *     init: function(sound) {
	 *         this.sound = sound;
	 *     },
	 *     speak: function() {
	 *         console.log(this.sound);
	 *     }
	 * });
	 *
	 * var Snake = Animal.extend({
	 *     legs: 0
	 * }, {
	 *     init: function() {
	 *         this.sound = 'ssssss';
	 *     },
	 *     slither: function() {
	 *         console.log('slithering...');
	 *     }
	 * });
	 *
	 * Animal.legs; // 4
	 * Snake.legs; // 0
	 * var dog = new Animal('woof');
	 * var blackMamba = new Snake();
	 * dog.speak(); // 'woof'
	 * blackMamba.speak(); // 'ssssss'
	 * ```
	 *
	 * ## Alternative value for a new instance
	 *
	 * Sometimes you may want to return some custom value instead of a new object when creating an instance of your class.
	 * For example, you want your class to act as a singleton, or check whether an item with the given id was already
	 * created and return an existing one from your cache store (e.g. using [can-connect/constructor/store/store]).
	 *
	 * To achieve this you can return [can-construct.ReturnValue] from `setup` method of your class.
	 *
	 * Lets say you have `myStore` to cache all newly created instances. And if an item already exists you want to merge
	 * the new data into the existing instance and return the updated instance.
	 *
	 * ```
	 * var myStore = {};
	 *
	 * var Item = Construct.extend({
	 *     setup: function(params){
	 *         if (myStore[params.id]){
	 *             var item = myStore[params.id];
	 *
	 *             // Merge new data to the existing instance:
	 *             Object.assign(item, params);
	 *
	 *             // Return the updated item:
	 *             return new Construct.ReturnValue( item );
	 *         } else {
	 *             // Save to cache store:
	 *             myStore[this.id] = this;
	 *
	 *             return [params];
	 *         }
	 *     },
	 *     init: function(params){
	 *         Object.assign(this, params);
	 *     }
	 * });
	 *
	 * var item_1  = new Item( {id: 1, name: "One"} );
	 * var item_1a = new Item( {id: 1, name: "OnePlus"} )
	 * ```
	 */
	extend: function (name, staticProperties, instanceProperties) {
		var shortName = name,
			klass = staticProperties,
			proto = instanceProperties;

		// Figure out what was passed and normalize it.
		if (typeof shortName !== 'string') {
			proto = klass;
			klass = shortName;
			shortName = null;
		}
		if (!proto) {
			proto = klass;
			klass = null;
		}
		proto = proto || {};
		var _super_class = this,
			_super = this.prototype,
			Constructor, prototype;
		// Instantiate a base class (but only create the instance,
		// don't run the init constructor).
		prototype = this.instance();
		// Copy the properties over onto the new prototype.
		Construct._inherit(proto, _super, prototype);

		if(shortName) {

		} else if(klass && klass.shortName) {
			shortName = klass.shortName;
		} else if(this.shortName) {
			shortName = this.shortName;
		}
		// We want constructor.name to be the same as shortName, within
		// the bounds of what the JS VM will allow (meaning no non-word characters).
		// new Function() is significantly faster than eval() here.

		// Strip semicolons
		//!steal-remove-start
		var constructorName = shortName ? shortName.replace(constructorNameRegex, '_') : 'Constructor';
		if(reservedWords[constructorName]) {
			constructorName = canString_0_0_5_canString.capitalize(constructorName);
		}
		//!steal-remove-end

		// The dummy class constructor.
		function init() {
			/* jshint validthis: true */
			// All construction is actually done in the init method.
			if (!initializing) {
				//!steal-remove-start
				if(!this || (this.constructor !== Constructor) &&
				// We are being called without `new` or we are extending.
				arguments.length && Constructor.constructorExtends) {
					dev.warn('can/construct/construct.js: extending a Construct without calling extend');
				}
				//!steal-remove-end

				return (!this || this.constructor !== Constructor) &&
				// We are being called without `new` or we are extending.
				arguments.length && Constructor.constructorExtends ? Constructor.extend.apply(Constructor, arguments) :
				// We are being called with `new`.
				Constructor.newInstance.apply(Constructor, arguments);
			}
		}
		Constructor = typeof namedCtor === "function" ?
			namedCtor( constructorName, init ) :
			function() { return init.apply(this, arguments); };

		// Copy old stuff onto class (can probably be merged w/ inherit)
		for (var propName in _super_class) {
			if (_super_class.hasOwnProperty(propName)) {
				Constructor[propName] = _super_class[propName];
			}
		}
		// Copy new static properties on class.
		Construct._inherit(klass, _super_class, Constructor);

		// Set things that shouldn't be overwritten.
		canReflect_1_16_7_canReflect.assignMap(Constructor, {
			constructor: Constructor,
			prototype: prototype
			/**
			 * @property {String} can-construct.shortName shortName
			 * @parent can-construct.static
			 *
			 * If you pass a name when creating a Construct, the `shortName` property will be set to the
			 * name.
			 *
			 * ```js
			 * var MyConstructor = Construct.extend("MyConstructor",{},{});
			 * MyConstructor.shortName // "MyConstructor"
			 * ```
			 */
		});

		if (shortName !== undefined) {
			if (Object.getOwnPropertyDescriptor) {
				var desc = Object.getOwnPropertyDescriptor(Constructor, 'name');
				if (!desc || desc.configurable) {
					Object.defineProperty(
						Constructor,
						'name',
						{ writable: true, value: shortName, configurable: true }
					);
				}
			}
			Constructor.shortName = shortName;
		}
		// Make sure our prototype looks nice.
		Constructor.prototype.constructor = Constructor;
		// Call the class `setup` and `init`
		var t = [_super_class].concat(Array.prototype.slice.call(arguments)),
			args = Constructor.setup.apply(Constructor, t);
		if (Constructor.init) {
			Constructor.init.apply(Constructor, args || t);
		}
		/**
		 * @prototype
		 */
		return Constructor; //
		/**
		 * @property {Object} can-construct.prototype.constructor constructor
		 * @parent can-construct.prototype
		 *
		 * A reference to the constructor function that created the instance. This allows you to access
		 * the constructor's static properties from an instance.
		 *
		 * @body
		 * ## Example
		 *
		 * This Construct has a static counter that counts how many instances have been created:
		 *
		 * ```js
		 * var Counter = Construct.extend({
		 *     count: 0
		 * }, {
		 *     init: function() {
		 *         this.constructor.count++;
		 *     }
		 * });
		 *
		 * var childCounter = new Counter();
		 * console.log(childCounter.constructor.count); // 1
		 * console.log(Counter.count); // 1
		 * ```
		 */
	},
	/**
	 * @function can-construct.ReturnValue ReturnValue
	 * @parent can-construct.static
	 *
	 * Use to overwrite the return value of new Construct(...).
	 *
	 * @signature `new Construct.ReturnValue( value )`
	 *
	 *   This constructor function can be used for creating a return value of the `setup` method.
	 *   [can-construct] will check if the return value is an instance of `Construct.ReturnValue`.
	 *   If it is then its `value` will be used as the new instance.
	 *
	 *   @param {Object} value A value to be used for a new instance instead of a new object.
	 *
	 *   ```
	 *   var Student = function( name, school ){
	 *       this.name = name;
	 *       this.school = school;
	 *   }
	 *
	 *   var Person = Construct.extend({
	 *       setup: function( options ){
	 *           if (options.school){
	 *               return new Constructor.ReturnValue( new Student( options.name, options.school ) );
	 *           } else {
	 *               return [options];
	 *           }
	 *       }
	 *   });
	 *
	 *   var myPerson = new Person( {name: "Ilya", school: "PetrSU"} );
	 *
	 *   myPerson instanceof Student // => true
	 *   ```
   */
	ReturnValue: function(value){
		this.value = value;
	}
});
/**
 * @function can-construct.prototype.setup setup
 * @parent can-construct.prototype
 *
 * @signature `construct.setup(...args)`
 *
 * A setup function for the instantiation of a constructor function.
 *
 * @param {*} args The arguments passed to the constructor.
 *
 * @return {Array|undefined|can-construct.ReturnValue} If an array is returned, the array's items are passed as
 * arguments to [can-construct::init init]. If a [can-construct.ReturnValue] instance is returned, the ReturnValue
 * instance's value will be returned as the result of calling new Construct(). The following example always makes
 * sure that init is called with a jQuery wrapped element:
 *
 * ```js
 * 	WidgetFactory = Construct.extend({
 * 			setup: function(element){
 * 					return [$(element)]
 * 			}
 * 	});
 *
 * 	MyWidget = WidgetFactory.extend({
 * 			init: function($el){
 * 					$el.html("My Widget!!")
 * 			}
 * 	});
 *  ```
 *
 * Otherwise, the arguments to the
 * constructor are passed to [can-construct::init] and the return value of `setup` is discarded.
 *
 * @body
 *
 * ## Deciding between `setup` and `init`
 *
 *
 * Usually, you should use [can-construct::init init] to do your constructor function's initialization.
 * You should, instead, use `setup` when:
 *
 *   - there is initialization code that you want to run before the inheriting constructor's
 *     `init` method is called.
 *   - there is initialization code that should run whether or not inheriting constructors
 *     call their base's `init` methods.
 *   - you want to modify the arguments that will get passed to `init`.
 *
 */
Construct.prototype.setup = function () {};
/**
 * @function can-construct.prototype.init init
 * @parent can-construct.prototype
 *
 * @description Called when a new instance of a Construct is created.
 *
 * @signature `construct.init(...args)`
 * @param {*} args the arguments passed to the constructor (or the items of the array returned from [can-construct::setup])
 *
 * @body
 * If a prototype `init` method is provided, `init` is called when a new Construct is created---
 * after [can-construct::setup]. The `init` method is where the bulk of your initialization code
 * should go. A common thing to do in `init` is save the arguments passed into the constructor.
 *
 * ## Examples
 *
 * First, we'll make a Person constructor that has a first and last name:
 *
 * ```js
 * var Person = Construct.extend({
 *     init: function(first, last) {
 *         this.first = first;
 *         this.last  = last;
 *     }
 * });
 *
 * var justin = new Person("Justin", "Meyer");
 * justin.first; // "Justin"
 * justin.last; // "Meyer"
 * ```
 *
 * Then, we'll extend Person into Programmer, and add a favorite language:
 *
 * ```js
 * var Programmer = Person.extend({
 *     init: function(first, last, language) {
 *         // call base's init
 *         Person.prototype.init.apply(this, arguments);
 *
 *         // other initialization code
 *         this.language = language;
 *     },
 *     bio: function() {
 *         return "Hi! I'm " + this.first + " " + this.last +
 *             " and I write " + this.language + ".";
 *     }
 * });
 *
 * var brian = new Programmer("Brian", "Moschel", 'ECMAScript');
 * brian.bio(); // "Hi! I'm Brian Moschel and I write ECMAScript.";
 * ```
 *
 * ## Modified Arguments
 *
 * [can-construct::setup] is able to modify the arguments passed to `init`.
 * If you aren't receiving the arguments you passed to `new Construct(args)`,
 * check that they aren't being changed by `setup` along
 * the inheritance chain.
 */
Construct.prototype.init = function () {};

var canConstruct_3_4_4_canConstruct = canNamespace_1_0_0_canNamespace.Construct = Construct;

var returnFirstArg = function(arg){
	return arg;
};
var defineHelpers = {
	// returns `true` if the value was defined and set
	defineExpando: function(map, prop, value) {
		// first check if it's already a constructor define
		var constructorDefines = map._define.definitions;
		if(constructorDefines && constructorDefines[prop]) {
			return;
		}
		// next if it's already on this instances
		var instanceDefines = map._instanceDefinitions;
		if(!instanceDefines) {
			if(Object.isSealed(map)) {
				return;
			}
			Object.defineProperty(map, "_instanceDefinitions", {
				configurable: true,
				enumerable: false,
				value: {}
			});
			instanceDefines = map._instanceDefinitions;
		}
		if(!instanceDefines[prop]) {
			var defaultDefinition = map._define.defaultDefinition || {type: canDefine_2_3_5_canDefine.types.observable};
			canDefine_2_3_5_canDefine.property(map, prop, defaultDefinition, {},{});
			// possibly convert value to List or DefineMap
			if(defaultDefinition.type) {
				map._data[prop] = canDefine_2_3_5_canDefine.make.set.type(prop, defaultDefinition.type, returnFirstArg).call(map, value);
			} else {
				map._data[prop] = canDefine_2_3_5_canDefine.types.observable(value);
			}

			instanceDefines[prop] = defaultDefinition;
			canQueues_1_1_0_canQueues.batch.start();
			map.dispatch({
				type: "can.keys",
				target: map
			});
			if(map._data[prop] !== undefined) {
				map.dispatch({
					type: prop,
					target: map,
					patches: [{type: "set", key: prop, value: map._data[prop]}],
				},[map._data[prop], undefined]);
			}
			canQueues_1_1_0_canQueues.batch.stop();
			return true;
		}
	},
	reflectSerialize: function(unwrapped){
		var constructorDefinitions = this._define.definitions;
		var defaultDefinition = this._define.defaultDefinition;
		this.forEach(function(val, name){
			var propDef = constructorDefinitions[name];

			if(propDef && typeof propDef.serialize === "function") {
				val = propDef.serialize.call(this, val, name);
			}
			else if(defaultDefinition && typeof defaultDefinition.serialize === "function") {
				val =  defaultDefinition.serialize.call(this, val, name);
			} else {
				val = canReflect_1_16_7_canReflect.serialize(val);
			}
			if(val !== undefined) {
				unwrapped[name] = val;
			}
		}, this);
		return unwrapped;
	},
	reflectUnwrap: function(unwrapped){
		this.forEach(function(value, key){
			if(value !== undefined) {
				unwrapped[key] = canReflect_1_16_7_canReflect.unwrap(value);
			}
		});
		return unwrapped;
	}
};
var defineHelpers_1 = defineHelpers;

// Ensure the "obj" passed as an argument has an object on @@can.meta
var canDefine_2_3_5_ensureMeta = function ensureMeta(obj) {
	var metaSymbol = canSymbol_1_6_1_canSymbol.for("can.meta");
	var meta = obj[metaSymbol];

	if (!meta) {
		meta = {};
		canReflect_1_16_7_canReflect.setKeyValue(obj, metaSymbol, meta);
	}

	return meta;
};

var dev$1 = dev;


var keysForDefinition = function(definitions) {
	var keys = [];
	for(var prop in definitions) {
		var definition = definitions[prop];
		if(typeof definition !== "object" || ("serialize" in definition ? !!definition.serialize : !definition.get)) {
			keys.push(prop);
		}
	}
	return keys;
};

function assign(source) {
	canQueues_1_1_0_canQueues.batch.start();
	canReflect_1_16_7_canReflect.assignMap(this, source || {});
	canQueues_1_1_0_canQueues.batch.stop();
}
function update(source) {
	canQueues_1_1_0_canQueues.batch.start();
	canReflect_1_16_7_canReflect.updateMap(this, source || {});
	canQueues_1_1_0_canQueues.batch.stop();
}
function assignDeep(source){
	canQueues_1_1_0_canQueues.batch.start();
	// TODO: we should probably just throw an error instead of cleaning
	canReflect_1_16_7_canReflect.assignDeepMap(this, source || {});
	canQueues_1_1_0_canQueues.batch.stop();
}
function updateDeep(source){
	canQueues_1_1_0_canQueues.batch.start();
	// TODO: we should probably just throw an error instead of cleaning
	canReflect_1_16_7_canReflect.updateDeepMap(this, source || {});
	canQueues_1_1_0_canQueues.batch.stop();
}
function setKeyValue(key, value) {
	var defined = defineHelpers_1.defineExpando(this, key, value);
	if(!defined) {
		this[key] = value;
	}
}
function getKeyValue(key) {
	var value = this[key];
	if(value !== undefined || key in this || Object.isSealed(this)) {
		return value;
	} else {
		canObservationRecorder_1_1_2_canObservationRecorder.add(this, key);
		return this[key];
	}
}

var getSchemaSymbol$1 = canSymbol_1_6_1_canSymbol.for("can.getSchema");

function getSchema() {
	var def = this.prototype._define;
	var definitions = def ? def.definitions : {};
	var schema = {
		type: "map",
		identity: [],
		keys: {}
	};
	return canDefine_2_3_5_canDefine.updateSchemaKeys(schema, definitions);
}

var DefineMap = canConstruct_3_4_4_canConstruct.extend("DefineMap",{
	setup: function(base){
		var key,
			prototype = this.prototype;
		if(DefineMap) {
			// we have already created
			var result = canDefine_2_3_5_canDefine(prototype, prototype, base.prototype._define);
				canDefine_2_3_5_canDefine.makeDefineInstanceKey(this, result);

			type$1(this);
			for(key in DefineMap.prototype) {
				canDefine_2_3_5_canDefine.defineConfigurableAndNotEnumerable(prototype, key, prototype[key]);
			}

			this.prototype.setup = function(props){
				canDefine_2_3_5_canDefine.setup.call(
					this,
					props || {},
					this.constructor.seal
				);
			};
		} else {
			for(key in prototype) {
				canDefine_2_3_5_canDefine.defineConfigurableAndNotEnumerable(prototype, key, prototype[key]);
			}
		}
		canDefine_2_3_5_canDefine.defineConfigurableAndNotEnumerable(prototype, "constructor", this);
		this[getSchemaSymbol$1] = getSchema;
	}
},{
	// setup for only dynamic DefineMap instances
	setup: function(props, sealed){
		if(!this._define) {
			Object.defineProperty(this,"_define",{
				enumerable: false,
				value: {
					definitions: {}
				}
			});
			Object.defineProperty(this,"_data",{
				enumerable: false,
				value: {}
			});
		}
		canDefine_2_3_5_canDefine.setup.call(
			this,
			props || {},
			sealed === true
		);
	},
	/**
	 * @function can-define/map/map.prototype.get get
	 * @parent can-define/map/map.prototype
	 *
	 * @description Get a value or all values from a DefineMap.
	 *
	 * @signature `map.get()`
	 *
	 * Returns a plain JavaScript object that contains the properties and values of the map instance.  Any property values
	 * that also have a `get` method will have their `get` method called and the resulting value will be used as
	 * the property value.  This can be used to recursively convert a map instance to an object of other plain
	 * JavaScript objects.  Cycles are supported and only create one object.
	 *
	 * `.get()` can still return other non plain JS objects like Date.
	 * Use [can-define/map/map.prototype.serialize] when a form proper for `JSON.stringify` is needed.
	 *
	 * ```js
	 * var map = new DefineMap({foo: new DefineMap({bar: "zed"})});
	 * map.get() //-> {foo: {bar: "zed"}};
	 * ```
	 *
	 *   @return {Object} A plain JavaScript `Object` that contains all the properties and values of the map instance.
	 *
	 * @signature `map.get(propName)`
	 *
	 * Get a single property on a DefineMap instance.
	 *
	 * `.get(propName)` only should be used when reading properties that might not have been defined yet, but
	 * will be later via [can-define/map/map.prototype.set].
	 *
	 * ```js
	 * var map = new DefineMap();
	 * map.get("name") //-> undefined;
	 * ```
	 *
	 *   @param {String} propName The property name of a property that may not have been defined yet.
	 *   @return {*} The value of that property.
	 */
	get: function(prop){
		if(prop) {
			return getKeyValue.call(this, prop);
		} else {
			return canReflect_1_16_7_canReflect.unwrap(this, Map);
		}
	},
	/**
	 * @function can-define/map/map.prototype.set set
	 * @parent can-define/map/map.prototype
	 *
	 * @deprecated {3.10.1} Passing an {Object} to `.set` has been deprecated in favor of [can-define/map/map.prototype.assign] or [can-define/map/map.prototype.update]. `map.set(propName, value)` is _not_ deprecated.
	 *
	 * @description Sets multiple properties on a map instance or a property that wasn't predefined.
	 *
	 * @signature `map.set(props [,removeProps])`
	 *
	 * Assigns each value in `props` to a property on this map instance named after the
	 * corresponding key in `props`, effectively merging `props` into the Map. If `removeProps` is true, properties not in
	 * `props` will be set to `undefined`.
	 *
	 *   @param {Object} props A collection of key-value pairs to set.
	 *   If any properties already exist on the map, they will be overwritten.
	 *
	 *   @param {Boolean} [removeProps=false] Whether to set keys not present in `props` to `undefined`.
	 *
	 *   @return {can-define/map/map} The map instance for chaining.
	 *
	 * @signature `map.set(propName, value)`
	 *
	 * Assigns _value_ to a property on this map instance called _propName_.  This will define
	 * the property if it hasn't already been predefined.
	 *
	 *   @param {String} propName The property to set.
	 *   @param {*} value The value to assign to `propName`.
	 *   @return {can-define/map/map} This map instance, for chaining.
	 */
	set: function(prop, value){
		if(typeof prop === "object") {
			//!steal-remove-start
			dev.warn('can-define/map/map.prototype.set is deprecated; please use can-define/map/map.prototype.assign or can-define/map/map.prototype.update instead');
			//!steal-remove-end
			if(value === true) {
				updateDeep.call(this, prop);
			} else {
				assignDeep.call(this, prop);
			}

		} else {
			setKeyValue.call(this, prop, value);
		}

		return this;
	},
	/**
	 * @function can-define/map/map.prototype.assignDeep assignDeep
	 * @parent can-define/map/map.prototype
	 *
	 * @description Sets multiple properties on a map instance or a property that wasn't predefined.
	 *
	 * @signature `map.assignDeep(props)`
	 *
	 * Assigns each value in `props` to a property on this map instance named after the
	 * corresponding key in `props`, effectively replacing `props` into the Map.
	 * Properties not in `props` will not be changed.
	 *
	 * ```js
	 * var MyMap = DefineMap.extend({
	 * 	list: DefineList,
	 * 	name: 'string'
	 * });
	 * var obj = new MyMap({
	 * 	list: ['1', '2', '3'],
	 * 	foo: 'bar'
	 * });
	 * obj.assignDeep({
	 * 	list: ['first']
 	 * });
	 *
	 * obj.list //-> ['first']
	 * obj.foo //-> 'bar'
	 * ```
	 *   @param {Object} props A collection of key-value pairs to set.
	 *   If any properties already exist on the map, they will be overwritten.
	 *
	 *   @return {can-define/map/map} The map instance for chaining.
	 *
	 */
	assignDeep: function(prop) {
		assignDeep.call(this, prop);
		return this;
	},
	/**
	 * @function can-define/map/map.prototype.updateDeep updateDeep
	 * @parent can-define/map/map.prototype
	 *
	 * @description Sets multiple properties on a map instance or a property that wasn't predefined.
	 *
	 * @signature `map.updateDeep(props)`
	 *
	 * Assigns each value in `props` to a property on this map instance named after the
	 * corresponding key in `props`, effectively merging `props` into the Map.
	 * Properties not in `props` will be set to `undefined`.
	 *
	 * ```js
	 * var MyMap = DefineMap.extend({
	 * 	list: DefineList,
	 * 	name: 'string'
	 * });
	 * var obj = new MyMap({
	 * 	list: ['1', '2', '3'],
	 * 	name: 'bar',
	 * 	foo: {
	 * 		bar: 'zed',
	 * 		boo: 'goo'
	 * 	}
	 * });
	 * obj.updateDeep({
	 * 	list: ['first'],
	 * 	foo: {
	 * 		bar: 'abc'
	 * 	}
 	 * });
	 *
	 * obj.list //-> ['first', '2', '3']
	 * obj.foo	//-> { bar: 'abc', boo: undefined }
	 * obj.name //-> 'undefined'
	 * ```
	 *   @param {Object} props A collection of key-value pairs to set.
	 *   If any properties already exist on the map, they will be overwritten.
	 *
	 *   @return {can-define/map/map} The map instance for chaining.
	 *
	 */
	updateDeep: function(prop) {
		updateDeep.call(this, prop);
		return this;
	},
	/**
	 * @function can-define/map/map.prototype.assign assign
	 * @parent can-define/map/map.prototype
	 *
	 * @description Sets multiple properties on a map instance or a property that wasn't predefined.
	 *
	 * @signature `map.assign(props)`
	 *
	 * ```js
	 * var MyMap = DefineMap.extend({
	 * 	list: DefineList,
	 * 	name: 'string'
	 * });
	 * var obj = new MyMap({
	 * 	list: ['1', '2', '3'],
	 * 	foo: 'bar'
	 * });
	 * obj.assign({
	 * 	list: ['first']
 	 * });
	 *
	 * obj.list //-> ['first']
	 * obj.foo //-> 'bar'
	 * ```
	 * Assigns each value in `props` to a property on this map instance named after the
	 * corresponding key in `props`, effectively replacing `props` into the Map.
	 * Properties not in `props` will not be changed.
	 *
	 *   @param {Object} props A collection of key-value pairs to set.
	 *   If any properties already exist on the map, they will be overwritten.
	 *
	 *   @return {can-define/map/map} The map instance for chaining.
	 *
	 */
	assign: function(prop) {
		assign.call(this, prop);
		return this;
	},
	/**
	 * @function can-define/map/map.prototype.update update
	 * @parent can-define/map/map.prototype
	 *
	 * @description Sets multiple properties on a map instance or a property that wasn't predefined.
	 *
	 * @signature `map.update(props)`
	 *
	 * ```js
	 * var MyMap = DefineMap.extend({
	 * 	list: DefineList,
	 * 	name: 'string'
	 * });
	 * var obj = new MyMap({
	 * 	list: ['1', '2', '3'],
	 * 	foo: 'bar'
	 * });
	 * obj.update({
	 * 	list: ['first']
 	 * });
	 *
	 * obj.list //-> ['first', '2', '3']
	 * obj.foo //-> 'undefined'
	 * ```
	 * Assigns each value in `props` to a property on this map instance named after the
	 * corresponding key in `props`, effectively merging `props` into the Map.
	 * Properties not in `props` will be set to `undefined`.
	 *
	 *   @param {Object} props A collection of key-value pairs to set.
	 *   If any properties already exist on the map, they will be overwritten.
	 *
	 *   @return {can-define/map/map} The map instance for chaining.
	 *
	 */
	update: function(prop) {
		update.call(this, prop);
		return this;
	},
	/**
	 * @function can-define/map/map.prototype.serialize serialize
	 * @parent can-define/map/map.prototype
	 *
	 * @description Get a serialized representation of the map instance and its children.
	 *
	 * @signature `map.serialize()`
	 *
	 * Get the serialized Object form of the map.  Serialized
	 * data is typically used to send back to a server.  Use [can-define.types.serialize]
	 * to customize a property's serialized value or if the property should be added to
	 * the result or not.
	 *
	 * `undefined` serialized values are not added to the result.
	 *
	 * ```js
	 * var MyMap = DefineMap.extend({
	 *   date: {
	 *     type: "date",
	 *     serialize: function(date){
	 *       return date.getTime()
	 *     }
	 *   }
	 * });
	 *
	 * var myMap = new MyMap({date: new Date(), count: 5});
	 * myMap.serialize() //-> {date: 1469566698504, count: 5}
	 * ```
	 *
	 *   @return {Object} A JavaScript Object that can be serialized with `JSON.stringify` or other methods.
	 *
	 */
	serialize: function () {
		return canReflect_1_16_7_canReflect.serialize(this, Map);
	},

	forEach: (function(){

		var forEach = function(list, cb, thisarg){
			return canReflect_1_16_7_canReflect.eachKey(list, cb, thisarg);
		},
			noObserve = canObservationRecorder_1_1_2_canObservationRecorder.ignore(forEach);

		return function(cb, thisarg, observe) {
			return observe === false ? noObserve(this, cb, thisarg) : forEach(this, cb, thisarg);
		};

	})(),
	"*": {
		type: canDefine_2_3_5_canDefine.types.observable
	},

	// call `map.log()` to log all event changes
	// pass `key` to only log the matching property, e.g: `map.log("foo")`
	log: function(key) {
		//!steal-remove-start
		var instance = this;

		var quoteString = function quoteString(x) {
			return typeof x === "string" ? JSON.stringify(x) : x;
		};

		var meta = canDefine_2_3_5_ensureMeta(instance);
		var allowed = meta.allowedLogKeysSet || new Set();
		meta.allowedLogKeysSet = allowed;

		if (key) {
			allowed.add(key);
		}

		meta._log = function(event, data) {
			var type = event.type;
			if (type === "can.keys" || (key && !allowed.has(type))) {
				return;
			}
			dev$1.log(
				canReflect_1_16_7_canReflect.getName(instance),
				"\n key ", quoteString(type),
				"\n is  ", quoteString(data[0]),
				"\n was ", quoteString(data[1])
			);
		};
		//!steal-remove-end
	}
});

canReflect_1_16_7_canReflect.assignSymbols(DefineMap.prototype,{
	// -type-
	"can.isMapLike": true,
	"can.isListLike":  false,
	"can.isValueLike": false,

	// -get/set-
	"can.getKeyValue": getKeyValue,
	"can.setKeyValue": setKeyValue,
	"can.deleteKeyValue": function(prop) {
		this.set(prop, undefined);
		return this;
	},

	// -shape
	"can.getOwnKeys": function() {
		var keys = canReflect_1_16_7_canReflect.getOwnEnumerableKeys(this);
		if(this._computed) {
			var computedKeys = canReflect_1_16_7_canReflect.getOwnKeys(this._computed);

			var key;
			for (var i=0; i<computedKeys.length; i++) {
				key = computedKeys[i];
				if (keys.indexOf(key) < 0) {
					keys.push(key);
				}
			}
		}

		return keys;
	},
	"can.getOwnEnumerableKeys": function(){
		canObservationRecorder_1_1_2_canObservationRecorder.add(this, 'can.keys');
		return keysForDefinition(this._define.definitions).concat(keysForDefinition(this._instanceDefinitions) );
	},
	"can.hasOwnKey": function(key) {
		return Object.hasOwnProperty.call(this._define.definitions, key);
	},
	"can.hasKey": function(key) {
		return !!this._define.definitions[key];
	},

	// -shape get/set-
	"can.assignDeep": assignDeep,
	"can.updateDeep": updateDeep,
	"can.unwrap": defineHelpers_1.reflectUnwrap,
	"can.serialize": defineHelpers_1.reflectSerialize,

	// observable
	"can.keyHasDependencies": function(key) {
		return !!(this._computed && this._computed[key] && this._computed[key].compute);
	},
	"can.getKeyDependencies": function(key) {
		var ret;
		if(this._computed && this._computed[key] && this._computed[key].compute) {
			ret = {};
			ret.valueDependencies = new Set([
				this._computed[key].compute
			]);
		}
		return ret;
	},

	//!steal-remove-start
	"can.getName": function() {
		return canReflect_1_16_7_canReflect.getName(this.constructor) + "{}";
	},
	//!steal-remove-end
});

canReflect_1_16_7_canReflect.setKeyValue(DefineMap.prototype, canSymbol_1_6_1_canSymbol.iterator, function() {
	return new canDefine_2_3_5_canDefine.Iterator(this);
});

// Add necessary event methods to this object.
for(var prop in canDefine_2_3_5_canDefine.eventsProto) {
	DefineMap[prop] = canDefine_2_3_5_canDefine.eventsProto[prop];
	Object.defineProperty(DefineMap.prototype, prop, {
		enumerable:false,
		value: canDefine_2_3_5_canDefine.eventsProto[prop],
		writable: true
	});
}
// @@can.onKeyValue and @@can.offKeyValue are also on define.eventsProto
//  but symbols are not enumerated in for...in loops
var eventsProtoSymbols = ("getOwnPropertySymbols" in Object) ?
  Object.getOwnPropertySymbols(canDefine_2_3_5_canDefine.eventsProto) :
  [canSymbol_1_6_1_canSymbol.for("can.onKeyValue"), canSymbol_1_6_1_canSymbol.for("can.offKeyValue")];

eventsProtoSymbols.forEach(function(sym) {
  Object.defineProperty(DefineMap.prototype, sym, {
    enumerable:false,
    value: canDefine_2_3_5_canDefine.eventsProto[sym],
    writable: true
  });
});

// tells `can-define` to use this
canDefine_2_3_5_canDefine.DefineMap = DefineMap;

Object.defineProperty(DefineMap.prototype, "toObject", {
	enumerable: false,
	writable: true,
	value: function(){
		canLog_1_0_0_canLog.warn("Use DefineMap::get instead of DefineMap::toObject");
		return this.get();
	}
});

var map$2 = canNamespace_1_0_0_canNamespace.DefineMap = DefineMap;

var slice$1 = [].slice;
// a b c
// a b c d
// [[2,0, d]]


function defaultIdentity(a, b){
    return a === b;
}

function makeIdentityFromMapSchema(typeSchema) {
    if(typeSchema.identity && typeSchema.identity.length) {
        return function identityCheck(a, b) {
            var aId = canReflect_1_16_7_canReflect.getIdentity(a, typeSchema),
                bId = canReflect_1_16_7_canReflect.getIdentity(b, typeSchema);
            return aId === bId;
        };
    } else {
        return defaultIdentity;
    }
}

function makeIdentityFromListSchema(listSchema) {
    return listSchema.values != null ?
        makeIdentityFromMapSchema( canReflect_1_16_7_canReflect.getSchema(listSchema.values) ) :
        defaultIdentity;
}

function makeIdentity(oldList, oldListLength) {
    var listSchema = canReflect_1_16_7_canReflect.getSchema(oldList),
        typeSchema;
    if(listSchema != null) {
        if(listSchema.values != null) {
            typeSchema = canReflect_1_16_7_canReflect.getSchema(listSchema.values);
        } else {
            return defaultIdentity;
        }
    }
    if(typeSchema == null && oldListLength > 0) {
        typeSchema = canReflect_1_16_7_canReflect.getSchema( canReflect_1_16_7_canReflect.getKeyValue(oldList, 0) );
    }
    if(typeSchema) {
        return makeIdentityFromMapSchema(typeSchema);
    } else {
        return defaultIdentity;
    }
}



function reverseDiff(oldDiffStopIndex, newDiffStopIndex, oldList, newList, identity) {
	var oldIndex = oldList.length - 1,
		newIndex =  newList.length - 1;

	while( oldIndex > oldDiffStopIndex && newIndex > newDiffStopIndex) {
		var oldItem = oldList[oldIndex],
			newItem = newList[newIndex];

		if( identity( oldItem, newItem ) ) {
			oldIndex--;
			newIndex--;
			continue;
		} else {
			// use newIndex because it reflects any deletions
			return [{
                type: "splice",
				index: newDiffStopIndex,
			 	deleteCount: (oldIndex-oldDiffStopIndex+1),
			 	insert: slice$1.call(newList, newDiffStopIndex,newIndex+1)
			}];
		}
	}
	// if we've reached of either the new or old list
	// we simply return
	return [{
        type: "splice",
		index: newDiffStopIndex,
		deleteCount: (oldIndex-oldDiffStopIndex+1),
		insert: slice$1.call(newList, newDiffStopIndex,newIndex+1)
	}];

}

/**
 * @module {function} can-diff/list/list
 * @parent can-diff
 *
 * @description Return a difference of two lists.
 *
 * @signature `diffList( oldList, newList, [identity] )`
 *
 * Compares two lists and produces a sequence of patches that can be applied to make `oldList` take
 * the shape of `newList`.
 *
 * ```js
 * var diffList = require("can-diff/list/list");
 *
 * console.log(diff([1], [1, 2])); // -> [{type: "splice", index: 1, deleteCount: 0, insert: [2]}]
 * console.log(diff([1, 2], [1])); // -> [{type: "splice", index: 1, deleteCount: 1, insert: []}]
 *
 * // with an optional identity function:
 * diffList(
 *     [{id:1},{id:2}],
 *     [{id:1},{id:3}],
 *     (a,b) => a.id === b.id
 * ); // -> [{type: "splice", index: 1, deleteCount: 1, insert: [{id:3}]}]
 * ```
 *
 * The patch algorithm is linear with respect to the length of the lists and therefore does not produce a
 * [perfect edit distance](https://en.wikipedia.org/wiki/Edit_distance) (which would be at least quadratic).
 *
 * It is designed to work with most common list change scenarios, when items are inserted or removed
 * to a list (as opposed to moved with in the last).
 *
 * For example, it is able to produce the following patches:
 *
 * ```js
 * diffList(
 *     ["a","b","c","d"],
 *     ["a","b","X","Y","c","d"]
 * ); // -> [{type: "splice", index: 2, deleteCount: 0, insert: ["X","Y"]}]
 * ```
 *
 * @param  {ArrayLike} oldList The source array or list to diff from.
 * @param  {ArrayLike} newList The array or list to diff to.
 * @param  {function|can-reflect.getSchema} schemaOrIdentity An optional identity function or a schema with
 * an identity property for comparing elements.  If a `schemaOrIdentity` is not provided, the schema of
 * the `oldList` will be used.  If a schema can not be found, items a default identity function will be created
 * that checks if the two values are strictly equal `===`.
 * @return {Array} An array of [can-symbol/types/Patch] objects representing the differences
 *
 * Returns the difference between two ArrayLike objects (that have nonnegative
 * integer keys and the `length` property) as an array of patch objects.
 *
 * A patch object returned by this function has the following properties:
 * - **type**: the type of patch (`"splice"`).
 * - **index**:  the index of newList where the patch begins
 * - **deleteCount**: the number of items deleted from that index in newList
 * - **insert**: an Array of items newly inserted at that index in newList
 *
 * Patches should be applied in the order they are returned.
 */

var list = function(oldList, newList, schemaOrIdentity){
    var oldIndex = 0,
		newIndex =  0,
		oldLength = canReflect_1_16_7_canReflect.size( oldList ),
		newLength = canReflect_1_16_7_canReflect.size( newList ),
		patches = [];

    var schemaType = typeof schemaOrIdentity,
        identity;
    if(schemaType === "function") {
        identity = schemaOrIdentity;
    } else if(schemaOrIdentity != null) {
        if(schemaOrIdentity.type === "map") {
            identity = makeIdentityFromMapSchema(schemaOrIdentity);
        } else {
            identity = makeIdentityFromListSchema(schemaOrIdentity);
        }
    } else {
        identity = makeIdentity(oldList, oldLength);
    }



	while(oldIndex < oldLength && newIndex < newLength) {
		var oldItem = oldList[oldIndex],
			newItem = newList[newIndex];

		if( identity( oldItem, newItem ) ) {
			oldIndex++;
			newIndex++;
			continue;
		}
		// look for single insert, does the next newList item equal the current oldList.
		// 1 2 3
		// 1 2 4 3
		if(  newIndex+1 < newLength && identity( oldItem, newList[newIndex+1] ) ) {
			patches.push({index: newIndex, deleteCount: 0, insert: [ newList[newIndex] ], type: "splice"});
			oldIndex++;
			newIndex += 2;
			continue;
		}
		// look for single removal, does the next item in the oldList equal the current newList item.
		// 1 2 3
		// 1 3
		else if( oldIndex+1 < oldLength  && identity( oldList[oldIndex+1], newItem ) ) {
			patches.push({index: newIndex, deleteCount: 1, insert: [], type: "splice"});
			oldIndex += 2;
			newIndex++;
			continue;
		}
		// just clean up the rest and exit
		// 1 2 3
		// 1 2 5 6 7
		else {
			// iterate backwards to `newIndex`
			// "a", "b", "c", "d", "e"
			// "a", "x", "y", "z", "e"
			// -> {}
			patches.push.apply(patches, reverseDiff(oldIndex, newIndex , oldList, newList, identity) );


			return patches;
		}
	}
	if( (newIndex === newLength) && (oldIndex === oldLength) ) {
		return patches;
	}
	// a b
	// a b c d e
	patches.push(
				{type: "splice", index: newIndex,
				 deleteCount: oldLength-oldIndex,
				 insert: slice$1.call(newList, newIndex) } );

	return patches;
};

var canCid_1_1_2_canCid = createCommonjsModule(function (module) {
/**
 * @module {function} can-cid
 * @parent can-typed-data
 * @collection can-infrastructure
 * @package ./package.json
 * @description Utility for getting a unique identifier for an object.
 * @signature `cid(object, optionalObjectType)`
 *
 * Get a unique identifier for the object, optionally prefixed by a type name.
 *
 * Once set, the unique identifier does not change, even if the type name
 * changes on subsequent calls.
 *
 * ```js
 * var cid = require("can-cid");
 * var x = {};
 * var y = {};
 *
 * console.log(cid(x, "demo")); // -> "demo1"
 * console.log(cid(x, "prod")); // -> "demo1"
 * console.log(cid(y));         // -> "2"
 * ```
 *
 * @param {Object} object The object to uniquely identify.
 * @param {String} name   An optional type name with which to prefix the identifier
 *
 * @return {String} Returns the unique identifier
 */
var _cid = 0;
// DOM nodes shouldn't all use the same property
var domExpando = "can" + new Date();
var cid = function (object, name) {
	var propertyName = object.nodeName ? domExpando : "_cid";

	if (!object[propertyName]) {
		_cid++;
		object[propertyName] = (name || '') + _cid;
	}
	return object[propertyName];
};
cid.domExpando = domExpando;
cid.get = function(object){
	var type = typeof object;
	var isObject = type !== null && (type === "object" || type === "function");
	return isObject ? cid(object) : (type + ":" + object);
};

if (canNamespace_1_0_0_canNamespace.cid) {
	throw new Error("You can't have two versions of can-cid, check your dependencies");
} else {
	module.exports = canNamespace_1_0_0_canNamespace.cid = cid;
}
});

var singleReference;

function getKeyName(key, extraKey) {
	var keyName = extraKey ? canCid_1_1_2_canCid(key) + ":" + extraKey : canCid_1_1_2_canCid(key);
	return keyName || key;
}

// weak maps are slow
/* if(typeof WeakMap !== "undefined") {
	var globalMap = new WeakMap();
	singleReference = {
		set: function(obj, key, value){
			var localMap = globalMap.get(obj);
			if( !localMap ) {
				globalMap.set(obj, localMap = new WeakMap());
			}
			localMap.set(key, value);
		},
		getAndDelete: function(obj, key){
			return globalMap.get(obj).get(key);
		},
		references: globalMap
	};
} else {*/
	singleReference = {
		// obj is a function ... we need to place `value` on it so we can retreive it
		// we can't use a global map
		set: function(obj, key, value, extraKey){
			// check if it has a single reference map
			obj[getKeyName(key, extraKey)] = value;
		},

		getAndDelete: function(obj, key, extraKey){
			var keyName = getKeyName(key, extraKey);
			var value = obj[keyName];
			delete obj[keyName];
			return value;
		}
	};
/*}*/

var canSingleReference_1_0_0_canSingleReference = singleReference;

var make$1 = canDefine_2_3_5_canDefine.make;







var dev$2 = dev;









var splice = [].splice;
var runningNative = false;

var identity = function(x) {
	return x;
};

// symbols aren't enumerable ... we'd need a version of Object that treats them that way
var localOnPatchesSymbol = "can.patches";

var makeFilterCallback = function(props) {
	return function(item) {
		for (var prop in props) {
			if (item[prop] !== props[prop]) {
				return false;
			}
		}
		return true;
	};
};

var onKeyValue = canDefine_2_3_5_canDefine.eventsProto[canSymbol_1_6_1_canSymbol.for("can.onKeyValue")];
var offKeyValue = canDefine_2_3_5_canDefine.eventsProto[canSymbol_1_6_1_canSymbol.for("can.offKeyValue")];
var getSchemaSymbol$2 = canSymbol_1_6_1_canSymbol.for("can.getSchema");

function getSchema$1() {
	var definitions = this.prototype._define.definitions;
	var schema = {
		type: "list",
		keys: {}
	};
	schema = canDefine_2_3_5_canDefine.updateSchemaKeys(schema, definitions);
	if(schema.keys["#"]) {
		schema.values = definitions["#"].Type;
		delete schema.keys["#"];
	}

	return schema;
}


/** @add can-define/list/list */
var DefineList = canConstruct_3_4_4_canConstruct.extend("DefineList",
	/** @static */
	{
		setup: function(base) {
			if (DefineList) {
				type$1(this);
				var prototype = this.prototype;
				var result = canDefine_2_3_5_canDefine(prototype, prototype, base.prototype._define);
				canDefine_2_3_5_canDefine.makeDefineInstanceKey(this, result);

				var itemsDefinition = result.definitions["#"] || result.defaultDefinition;

				if (itemsDefinition) {
					if (itemsDefinition.Type) {
						this.prototype.__type = make$1.set.Type("*", itemsDefinition.Type, identity);
					} else if (itemsDefinition.type) {
						this.prototype.__type = make$1.set.type("*", itemsDefinition.type, identity);
					}
				}
				this[getSchemaSymbol$2] = getSchema$1;
			}
		}
	},
	/** @prototype */
	{
		// setup for only dynamic DefineMap instances
		setup: function(items) {
			if (!this._define) {
				Object.defineProperty(this, "_define", {
					enumerable: false,
					value: {
						definitions: {
							length: { type: "number" },
							_length: { type: "number" }
						}
					}
				});
				Object.defineProperty(this, "_data", {
					enumerable: false,
					value: {}
				});
			}
			canDefine_2_3_5_canDefine.setup.call(this, {}, false);
			Object.defineProperty(this, "_length", {
				enumerable: false,
				configurable: true,
				writable: true,
				value: 0
			});
			if (items) {
				this.splice.apply(this, [ 0, 0 ].concat(canReflect_1_16_7_canReflect.toArray(items)));
			}
		},
		__type: canDefine_2_3_5_canDefine.types.observable,
		_triggerChange: function(attr, how, newVal, oldVal) {

			var index = +attr;
			// `batchTrigger` direct add and remove events...

			// Make sure this is not nested and not an expando
			if ( !isNaN(index)) {
				var itemsDefinition = this._define.definitions["#"];
				var patches;
				if (how === 'add') {
					if (itemsDefinition && typeof itemsDefinition.added === 'function') {
						canObservationRecorder_1_1_2_canObservationRecorder.ignore(itemsDefinition.added).call(this, newVal, index);
					}

					patches = [{type: "splice", insert: newVal, index: index, deleteCount: 0}];
					this.dispatch({
						type: how,
						patches: patches,
						//!steal-remove-start
						reasonLog: [ canReflect_1_16_7_canReflect.getName(this), "added", newVal, "at", index ],
						//!steal-remove-end
					}, [ newVal, index ]);

				} else if (how === 'remove') {
					if (itemsDefinition && typeof itemsDefinition.removed === 'function') {
						canObservationRecorder_1_1_2_canObservationRecorder.ignore(itemsDefinition.removed).call(this, oldVal, index);
					}

					patches = [{type: "splice", index: index, deleteCount: oldVal.length}];
					this.dispatch({
						type: how,
						patches: patches,
						//!steal-remove-start
						reasonLog: [ canReflect_1_16_7_canReflect.getName(this), "remove", oldVal, "at", index ],
						//!steal-remove-end
					}, [ oldVal, index ]);

				} else {
					this.dispatch(how, [ newVal, index ]);
				}
			} else {
				this.dispatch({
					type: "" + attr,
					target: this
				}, [ newVal, oldVal ]);
			}

		},
		/**
		 * @function can-define/list/list.prototype.get get
		 * @parent can-define/list/list.prototype
		 *
		 * Gets an item or all items from a DefineList.
		 *
		 * @signature `list.get()`
		 *
		 * Returns the list converted into a plain JS array. Any items that also have a
		 * `get` method will have their `get` method called and the resulting value will be used as item value.
		 *
		 * This can be used to recursively convert a list instance to an Array of other plain JavaScript objects.
		 * Cycles are supported and only create one object.
		 *
		 * `get()` can still return other non-plain JS objects like Dates.
		 * Use [can-define/map/map.prototype.serialize] when a form proper for `JSON.stringify` is needed.
		 *
		 * ```js
		 * var list = new DefineList(["A","B"]);
		 * list.get() //-> ["A","B"]
		 * ```
		 *
		 *   @return {Array} A plain JavaScript `Array` that contains each item in the list.
		 *
		 * @signature `list.get(index)`
		 *
		 * Gets the item at `index`. `list.get(index)` should be used instead of
		 * `list[index]` if the list's items are going to be updated via [can-define/list/list.prototype.set list.set(index, value)]
		 * (as opposed to [can-define/list/list.prototype.splice] which is the better way).
		 *
		 * ```js
		 * var list = new DefineList(["A","B"]);
		 * list.get(1) //-> "B"
		 * ```
		 *
		 *   @param {Number} index A numeric position in the list.
		 *
		 *   @return {*} The value at index.
		 *
		 * @signature `list.get(prop)`
		 *
		 * Gets the property at `prop` if it might not have already been defined.
		 *
		 *
		 * ```js
		 * var list = new DefineList(["A","B"]);
		 * list.set("count",1000)
		 * list.get("count") //-> 1000
		 * ```
		 *
		 *   @param {String} prop A property on the list.
		 *
		 *   @return {*} The value at `prop`.
		 */
		get: function(index) {
			if (arguments.length) {
				if(isNaN(index)) {
					canObservationRecorder_1_1_2_canObservationRecorder.add(this, index);
				} else {
					canObservationRecorder_1_1_2_canObservationRecorder.add(this, "length");
				}
				return this[index];
			} else {
				return canReflect_1_16_7_canReflect.unwrap(this, Map);
			}
		},
		/**
		 * @function can-define/list/list.prototype.set set
		 * @parent can-define/list/list.prototype
		 *
		 * @deprecated {3.10.1} Using .set with {Object} `props` has been deprecated in favour of `assign` and `update`
		 *
		 * @description Sets an item or property or items or properties on a list.
		 *
		 * @signature `list.set(prop, value)`
		 *
		 * Sets the property at `prop`. This should be used when the property
		 * isn't already defined.
		 *
		 * ```js
		 * var list = new DefineList(["A","B"]);
		 * list.set("count",1000);
		 * list.get("count") //-> 1000;
		 * ```
		 *
		 *   @param {Number} prop A property name.
		 *   @param {*} value The value to add to the list.
		 *   @return {can-define/list/list} The list instance.
		 *
		 * @signature `list.set(newProps)`
		 *
		 * Updates the properties on the list with `newProps`.
		 *
		 * ```js
		 * var list = new DefineList(["A","B"]);
		 * list.set({count: 1000, skip: 2});
		 * list.get("count") //-> 1000
		 * ```
		 *
		 *   @param {Object} newProps An object of properties and values to set on the list.
		 *   @return {can-define/list/list} The list instance.
		 *
		 * @signature `list.set(index, value)`
		 *
		 * Sets the item at `index`.  Typically, [can-define/list/list::splice] should be used instead.
		 *
		 * ```js
		 * var list = new DefineList(["A","B"]);
		 * list.set(2,"C");
		 * ```
		 *
		 *   @param {Number} index A numeric position in the list.
		 *   @param {*} value The value to add to the list.
		 *   @return {can-define/list/list} The list instance.
		 *
		 * @signature `list.set(newItems [,replaceAll])`
		 *
		 * Replaces items in the list with `newItems`
		 *
		 * ```js
		 * var list = new DefineList(["A","B"]);
		 * list.set(["c"])        //-> DefineList["c","B"]
		 * list.set(["x"], true)  //-> DefineList["x"]
		 * ```
		 *
		 *   @param {Array} newItems Items used to replace existing items in the list.
		 *   @param {Boolean} [replaceAll] If true, will remove items at the end of the list.
		 *   @return {can-define/list/list} The list instance.
		 */
		set: function(prop, value) {
			// if we are setting a single value
			if (typeof prop !== "object") {
				// We want change events to notify using integers if we're
				// setting an integer index. Note that <float> % 1 !== 0;
				prop = isNaN(+prop) || (prop % 1) ? prop : +prop;
				if (typeof prop === "number") {
					// Check to see if we're doing a .attr() on an out of
					// bounds index property.
					if (typeof prop === "number" &&
						prop > this._length - 1) {
						var newArr = new Array((prop + 1) - this._length);
						newArr[newArr.length - 1] = value;
						this.push.apply(this, newArr);
						return newArr;
					}
					this.splice(prop, 1, value);
				} else {
					var defined = defineHelpers_1.defineExpando(this, prop, value);
					if (!defined) {
						this[prop] = value;
					}
				}

			}
			// otherwise we are setting multiple
			else {
				//!steal-remove-start
				dev.warn('can-define/list/list.prototype.set is deprecated; please use can-define/list/list.prototype.assign or can-define/list/list.prototype.update instead');
				//!steal-remove-end

				//we are deprecating this in #245
				if (canReflect_1_16_7_canReflect.isListLike(prop)) {
					if (value) {
						this.replace(prop);
					} else {
						canReflect_1_16_7_canReflect.assignList(this, prop);
					}
				} else {
					canReflect_1_16_7_canReflect.assignMap(this, prop);
				}
			}
			return this;
		},
		/**
		 * @function can-define/list/list.prototype.assign assign
		 * @parent can-define/list/list.prototype
		 *
		 * Sets items or properties on a list.
		 *
		 * @signature `list.assign(newProps)`
		 *
		 * Assigns the properties on the list with `newProps`. Properties not present in `newProps` will be left unchanged.
		 *
		 * ```js
		 * var list = new DefineList(["A","B"]);
		 * list.assign({count: 1000, skip: 2});
		 * list.get("count") //-> 1000
		 * ```
		 *   @param {Array} newProps Properties that need to be assigned to the list instance
		 *   @return {can-define/list/list} The list instance.
		 */
		assign: function(prop) {
			if (canReflect_1_16_7_canReflect.isListLike(prop)) {
				canReflect_1_16_7_canReflect.assignList(this, prop);
			} else {
				canReflect_1_16_7_canReflect.assignMap(this, prop);
			}
			return this;
		},
		/**
		 * @function can-define/list/list.prototype.update update
		 * @parent can-define/list/list.prototype
		 *
		 * Sets an item or property or items or properties on a list.
		 *
		 * @signature `list.update(newProps)`
		 *
		 * Updates the properties on the list with `newProps`. Properties not in `newProps` will be set to `undefined`.
		 *
		 * ```js
		 * var list = new DefineList(["A","B"]);
		 * list.assign({count: 0, skip: 2});
		 * list.update({count: 1000});
		 * list.get("count") //-> 1000
		 * list.get("skip") //-> undefined
		 * ```
		 *   @param {Array} newProps Properties that need to be updated to the list instance
		 *   @return {can-define/list/list} The list instance.
		 */
		update: function(prop) {
			if (canReflect_1_16_7_canReflect.isListLike(prop)) {
				canReflect_1_16_7_canReflect.updateList(this, prop);
			} else {
				canReflect_1_16_7_canReflect.updateMap(this, prop);
			}
			return this;
		},
		/**
		 * @function can-define/list/list.prototype.assignDeep assignDeep
		 * @parent can-define/list/list.prototype
		 *
		 * Sets an item or property or items or properties on a list.
		 *
		 * @signature `list.assignDeep(newProps)`
		 *
		 * Updates the properties on the list with `newProps`. Properties not in `newProps` will be left unchanged.
		 *
		 * ```js
		 * var list = new DefineList(["A","B"]);
		 * list.assign({count: 1, skip: 2});
		 * list.get("count") //-> 1
		 *
		 * list.assignDeep({count: 1000});
		 * list.get("count") //-> 1000
		 * list.get("skip") //-> 2
		 * ```
		 *
		 *   @param {Array} newProps Properties that need to be assigned to the list instance
		 *   @return {can-define/list/list} The list instance.
		 */
		assignDeep: function(prop) {
			if (canReflect_1_16_7_canReflect.isListLike(prop)) {
				canReflect_1_16_7_canReflect.assignDeepList(this, prop);
			} else {
				canReflect_1_16_7_canReflect.assignDeepMap(this, prop);
			}
			return this;
		},
		/**
		 * @function can-define/list/list.prototype.updateDeep updateDeep
		 * @parent can-define/list/list.prototype
		 *
		 * Sets an item or property or items or properties on a list.
		 *
		 * @signature `list.updateDeep(newProps)`
		 *
		 * Recursively updates the properties on the list with `newProps`. Properties not in `newProps` will be set to `undefined`.
		 *
		 * ```js
		 * var list = new DefineList(["A","B"]);
		 * list.assign({count: 0, skip: 2, foo: {bar: 'zed', a: 'b'}});
		 * list.updateDeep({foo: {bar: 'yay'}});
		 *
		 * list.get("count") //-> undefined
		 * list.get("skip") //-> undefined
		 * list.get("foo") // -> {bar: 'yay', a: undefined}
		 * ```
		 *   @param {Array} newProps Properties that need to be updated on the list instance
		 *   @return {can-define/list/list} The list instance.
		 */
		updateDeep: function(prop) {
			if (canReflect_1_16_7_canReflect.isListLike(prop)) {
				canReflect_1_16_7_canReflect.updateDeepList(this, prop);
			} else {
				canReflect_1_16_7_canReflect.updateDeepMap(this, prop);
			}
			return this;
		},
		_items: function() {
			var arr = [];
			this._each(function(item) {
				arr.push(item);
			});
			return arr;
		},
		_each: function(callback) {
			for (var i = 0, len = this._length; i < len; i++) {
				callback(this[i], i);
			}
		},

		/**
		 * @function can-define/list/list.prototype.splice splice
		 * @parent can-define/list/list.prototype
		 * @description Insert and remove elements from a DefineList.
		 * @signature `list.splice(index[, howMany[, ...newItems]])`
		 *
		 * Removes `howMany` items at `index` and adds `newItems` in their place.
		 *
		 *
		 *
		 * @param {Number} index Where to start removing or inserting elements.
		 *
		 * @param {Number} [howMany] The number of elements to remove
		 * If _howMany_ is not provided, `splice` will remove all elements from `index` to the end of the DefineList.
		 *
		 * @param {*} newItems Items to insert into the DefineList
		 *
		 * @return {Array} The elements removed by `splice`.
		 *
		 * @body
		 *
		 * ## Use
		 *
		 * `splice` lets you remove elements from and insert elements into a DefineList.
		 *
		 * This example demonstrates how to do surgery on a list of numbers:
		 *
		 * ```
		 * var list = new DefineList([0, 1, 2, 3]);
		 *
		 * // starting at index 2, remove one element and insert 'Alice' and 'Bob':
		 * list.splice(2, 1, 'Alice', 'Bob');
		 * list.get(); // [0, 1, 'Alice', 'Bob', 3]
		 * ```
		 *
		 * ## Events
		 *
		 * `splice` causes the DefineList it's called on to emit
		 * _add_ events, _remove_ events, and _length_ events. If there are
		 * any elements to remove, a _remove_ event, and a
		 * _length_ event will be fired. If there are any elements to insert, a
		 * separate _add_ event, and a separate _length_ event
		 * will be fired.
		 *
		 */
		splice: function(index, howMany) {
			var args = canReflect_1_16_7_canReflect.toArray(arguments),
				added = [],
				i, len, listIndex,
				allSame = args.length > 2,
				oldLength = this._length;

			index = index || 0;

			// converting the arguments to the right type
			for (i = 0, len = args.length - 2; i < len; i++) {
				listIndex = i + 2;
				args[listIndex] = this.__type(args[listIndex], listIndex);
				added.push(args[listIndex]);

				// Now lets check if anything will change
				if (this[i + index] !== args[listIndex]) {
					allSame = false;
				}
			}

			// if nothing has changed, then return
			if (allSame && this._length <= added.length) {
				return added;
			}

			// default howMany if not provided
			if (howMany === undefined) {
				howMany = args[1] = this._length - index;
			}

			runningNative = true;
			var removed = splice.apply(this, args);
			runningNative = false;

			canQueues_1_1_0_canQueues.batch.start();
			if (howMany > 0) {
				// tears down bubbling
				this._triggerChange("" + index, "remove", undefined, removed);
			}
			if (args.length > 2) {
				this._triggerChange("" + index, "add", added, removed);
			}

			this.dispatch('length', [ this._length, oldLength ]);

			canQueues_1_1_0_canQueues.batch.stop();
			return removed;
		},

		/**
		 * @function can-define/list/list.prototype.serialize serialize
		 * @parent can-define/list/list.prototype
		 *
		 * Returns the a serialized version of this list.
		 *
		 * @signature `list.serialize()`
		 *
		 * Goes through each item in the list and gets its serialized
		 * value and returns them in a plain Array.
		 *
		 * Each items serialized value is the result of calling `.serialize()`
		 * on the item or if the item doesn't have a `serialize` method,
		 * the item itself.
		 *
		 * ```
		 * var list = new DefineList(["first", {foo: "bar"}]);
		 * var serializedList = list.serialize();
		 *
		 * serializedList //-> ["first", {foo: "bar"}]
		 * ```
		 *
		 *   @return {Array} An array with each item's serialied value.
		 */
		serialize: function() {
			return canReflect_1_16_7_canReflect.serialize(this, Map);
		},

		// call `list.log()` to log all event changes
		// pass `key` to only log the matching event, e.g: `list.log("add")`
		log: function(key) {
			//!steal-remove-start
			var instance = this;

			var quoteString = function quoteString(x) {
				return typeof x === "string" ? JSON.stringify(x) : x;
			};

			var meta = canDefine_2_3_5_ensureMeta(instance);
			var allowed = meta.allowedLogKeysSet || new Set();
			meta.allowedLogKeysSet = allowed;

			if (key) {
				allowed.add(key);
			}

			meta._log = function(event, data) {
				var type = event.type;

				if (type === "can.onPatches" || (key && !allowed.has(type))) {
					return;
				}

				if (type === "add" || type === "remove") {
					dev$2.log(
						canReflect_1_16_7_canReflect.getName(instance),
						"\n how   ", quoteString(type),
						"\n what  ", quoteString(data[0]),
						"\n index ", quoteString(data[1])
					);
				} else {
					// log `length` and `propertyName` events
					dev$2.log(
						canReflect_1_16_7_canReflect.getName(instance),
						"\n key ", quoteString(type),
						"\n is  ", quoteString(data[0]),
						"\n was ", quoteString(data[1])
					);
				}
			};
			//!steal-remove-end
		}
	}
);

for(var prop$1 in canDefine_2_3_5_canDefine.eventsProto) {
	Object.defineProperty(DefineList.prototype, prop$1, {
		enumerable:false,
		value: canDefine_2_3_5_canDefine.eventsProto[prop$1],
		writable: true
	});
}

var eventsProtoSymbols$1 = ("getOwnPropertySymbols" in Object) ?
  Object.getOwnPropertySymbols(canDefine_2_3_5_canDefine.eventsProto) :
  [canSymbol_1_6_1_canSymbol.for("can.onKeyValue"), canSymbol_1_6_1_canSymbol.for("can.offKeyValue")];

eventsProtoSymbols$1.forEach(function(sym) {
  Object.defineProperty(DefineList.prototype, sym, {
    enumerable:false,
    value: canDefine_2_3_5_canDefine.eventsProto[sym],
    writable: true
  });
});

// Converts to an `array` of arguments.
var getArgs = function(args) {
	return args[0] && Array.isArray(args[0]) ?
		args[0] :
		canReflect_1_16_7_canReflect.toArray(args);
};
// Create `push`, `pop`, `shift`, and `unshift`
canReflect_1_16_7_canReflect.eachKey({
		/**
		 * @function can-define/list/list.prototype.push push
		 * @description Add elements to the end of a list.
		 * @signature `list.push(...elements)`
		 *
		 * `push` adds elements onto the end of a DefineList.
		 *
		 * ```
		 * var names = new DefineList(['Alice']);
		 * names.push('Bob', 'Eve');
		 * names //-> DefineList['Alice','Bob', 'Eve']
		 * ```
		 *
		 *   @param {*} elements the elements to add to the DefineList
		 *
		 *   @return {Number} the new length of the DefineList
		 *
		 * @body
		 *
		 * ## Use
		 *
		 * `push` adds elements onto the end of a DefineList here is an example:
		 *
		 * ```
		 * var list = new DefineList(['Alice']);
		 *
		 * list.push('Bob', 'Eve');
		 * list.get(); // ['Alice', 'Bob', 'Eve']
		 * ```
		 *
		 * If you have an array you want to concatenate to the end
		 * of the DefineList, you can use `apply`:
		 *
		 * ```
		 * var names = ['Bob', 'Eve'],
		 *     list = new DefineList(['Alice']);
		 *
		 * list.push.apply(list, names);
		 * list.get(); // ['Alice', 'Bob', 'Eve']
		 * ```
		 *
		 * ## Events
		 *
		 * `push` causes _add_, and _length_ events to be fired.
		 *
		 * ## See also
		 *
		 * `push` has a counterpart in [can-define/list/list::pop pop], or you may be
		 * looking for [can-define/list/list::unshift unshift] and its counterpart [can-define/list/list::shift shift].
		 */
	push: "length",
		/**
		 * @function can-define/list/list.prototype.unshift unshift
		 * @description Add items to the beginning of a DefineList.
		 * @signature `list.unshift(...items)`
		 *
		 * `unshift` adds items onto the beginning of a DefineList.
		 *
		 * ```
		 * var list = new DefineList(['Alice']);
		 *
		 * list.unshift('Bob', 'Eve');
		 * list; // DefineList['Bob', 'Eve', 'Alice']
		 * ```
		 *
		 * @param {*} items The items to add to the DefineList.
		 *
		 * @return {Number} The new length of the DefineList.
		 *
		 * @body
		 *
		 * ## Use
		 *
		 *
		 *
		 * If you have an array you want to concatenate to the beginning
		 * of the DefineList, you can use `apply`:
		 *
		 * ```
		 * var names = ['Bob', 'Eve'],
		 *     list = new DefineList(['Alice']);
		 *
		 * list.unshift.apply(list, names);
		 * list.get(); // ['Bob', 'Eve', 'Alice']
		 * ```
		 *
		 * ## Events
		 *
		 * `unshift` causes _add_ and _length_ events to be fired.
		 *
		 * ## See also
		 *
		 * `unshift` has a counterpart in [can-define/list/list::shift shift], or you may be
		 * looking for [can-define/list/list::push push] and its counterpart [can-define/list/list::pop pop].
		 */
	unshift: 0
},
	// Adds a method
	// `name` - The method name.
	// `where` - Where items in the `array` should be added.
	function(where, name) {
		var orig = [][name];
		DefineList.prototype[name] = function() {
			// Get the items being added.
			var args = [],
				// Where we are going to add items.
				len = where ? this._length : 0,
				i = arguments.length,
				res, val;

			// Go through and convert anything to a `map` that needs to be converted.
			while (i--) {
				val = arguments[i];
				args[i] = this.__type(val, i);
			}

			// Call the original method.
			runningNative = true;
			res = orig.apply(this, args);
			runningNative = false;

			if (!this.comparator || args.length) {
				canQueues_1_1_0_canQueues.batch.start();
				this._triggerChange("" + len, "add", args, undefined);
				this.dispatch('length', [ this._length, len ]);
				canQueues_1_1_0_canQueues.batch.stop();
			}

			return res;
		};
	});

canReflect_1_16_7_canReflect.eachKey({
		/**
		 * @function can-define/list/list.prototype.pop pop
		 * @description Remove an element from the end of a DefineList.
		 * @signature `list.pop()`
		 *
		 * `pop` removes an element from the end of a DefineList.
		 *
		 * ```js
		 * var names = new DefineList(['Alice', 'Bob', 'Eve']);
		 * names.pop() //-> 'Eve'
		 * ```
		 *
		 *   @return {*} The element just popped off the DefineList, or `undefined` if the DefineList was empty
		 *
		 * @body
		 *
		 * ## Use
		 *
		 * `pop` is the opposite action from [can-define/list/list::push push]:
		 *
		 * ```
		 * var list = new DefineList(['Alice', 'Bob', 'Eve']);
		 *
		 * list.pop(); // 'Eve'
		 * list.pop(); // 'Bob'
		 * list.pop(); // 'Alice'
		 * list.pop(); // undefined
		 * ```
		 *
		 * ## Events
		 *
		 * `pop` causes _remove_ and _length_ events to be fired if the DefineList is not empty
		 * when it is called.
		 *
		 * ## See also
		 *
		 * `pop` has its counterpart in [can-define/list/list::push push], or you may be
		 * looking for [can-define/list/list::unshift unshift] and its counterpart [can-define/list/list::shift shift].
		 */
	pop: "length",
		/**
		 * @function can-define/list/list.prototype.shift shift
		 * @description Remove an item from the front of a list.
		 * @signature `list.shift()`
		 *
		 * `shift` removes an element from the beginning of a DefineList.
		 *
		 * ```
		 * var list = new DefineList(['Alice','Adam']);
		 * list.shift(); //-> 'Alice'
		 * list.shift(); //-> 'Adam'
		 * list.shift(); //-> undefined
		 * ```
		 *
		 * @return {*} The element just shifted off the DefineList, or `undefined` if the DefineList is empty
		 *
		 * @body
		 *
		 * ## Use
		 *
		 * `shift` is the opposite action from `[can-define/list/list::unshift unshift]`:
		 *
		 * ## Events
		 *
		 * `pop` causes _remove_ and _length_ events to be fired if the DefineList is not empty
		 * when it is called.
		 *
		 * ## See also
		 *
		 * `shift` has a counterpart in [can-define/list/list::unshift unshift], or you may be
		 * looking for [can-define/list/list::push push] and its counterpart [can-define/list/list::pop pop].
		 */
	shift: 0
},
	// Creates a `remove` type method
	function(where, name) {
		var orig = [][name];
		DefineList.prototype[name] = function() {
			if (!this._length) {
				// For shift and pop, we just return undefined without
				// triggering events.
				return undefined;
			}

			var args = getArgs(arguments),
				len = where && this._length ? this._length - 1 : 0,
				oldLength = this._length ? this._length : 0,
				res;

			// Call the original method.
			runningNative = true;
			res = orig.apply(this, args);
			runningNative = false;

			// Create a change where the args are
			// `len` - Where these items were removed.
			// `remove` - Items removed.
			// `undefined` - The new values (there are none).
			// `res` - The old, removed values (should these be unbound).
			canQueues_1_1_0_canQueues.batch.start();
			this._triggerChange("" + len, "remove", undefined, [ res ]);
			this.dispatch('length', [ this._length, oldLength ]);
			canQueues_1_1_0_canQueues.batch.stop();

			return res;
		};
	});

canReflect_1_16_7_canReflect.eachKey({
	/**
	 * @function can-define/list/list.prototype.map map
	 * @description Map the values in this list to another list.
	 *
	 * @signature `list.map(callback[, thisArg])`
	 *
	 * Loops through the values of the list, calling `callback` for each one until the list
	 * ends.  The return values of `callback` are used to populate the returned list.
	 *
	 * ```js
	 * var todos = new DefineList([
	 *   {name: "dishes", complete: false},
	 *   {name: "lawn", complete: true}
	 * ]);
	 * var names = todos.map(function(todo){
	 *   return todo.name;
	 * });
	 * names //-> DefineList["dishes","lawn"]
	 * ```
	 *
	 * @param {function(item, index, list)} callback A function to call with each element of the DefineList.
	 * The three parameters that callback gets passed are:
	 *    - item (*) - the element at index.
	 *    - index (Integer) - the index of the current element of the list.
	 *    - list (DefineList) - the `DefineList` the elements are coming from.
	 *
	 * The return value of `callback`, including `undefined` values are used to populate the resulting list.
	 *
	 * @param {Object} [thisArg] The object to use as `this` inside the callback.
	 * @return {can-define/list/list} a new `DefineList` with the results of the map transform.
	 * @body
	 *
	 */
	"map": 3,
	/**
	 * @function can-define/list/list.prototype.filter filter
	 *
	 * Filter a list to a new list of the matched items.
	 *
	 * @signature `list.filter( callback [,thisArg] )`
	 *
	 * Filters `list` based on the return value of `callback`.
	 *
	 * ```
	 * var names = new DefineList(["alice","adam","zack","zeffer"]);
	 * var aNames = names.filter(function(name){
	 *   return name[0] === "a"
	 * });
	 * aNames //-> DefineList["alice","adam"]
	 * ```
	 *
	 *   @param  {function(*, Number, can-define/list/list)} callback(item, index, list) A
	 *   function to call with each element of the DefineList. The three parameters that callback gets passed are:
	 *    - item (*) - the element at index.
	 *    - index (Integer) - the index of the current element of the list.
	 *    - list (DefineList) - the `DefineList` the elements are coming from.
	 *
	 *   If `callback` returns a truthy result, `item` will be added to the result.  Otherwise, the `item` will be
	 *   excluded.
	 *
	 *   @param  {Object}  thisArg  What `this` should be in the `callback`.
	 *   @return {can-define/list/list} A new instance of this `DefineList` (may be a subclass), containing the items that passed the filter.
	 *
	 * @signature `list.filter( props )`
	 *
	 * Filters items in `list` based on the property values in `props`.
	 *
	 * ```
	 * var todos = new DefineList([
	 *   {name: "dishes", complete: false},
	 *   {name: "lawn", complete: true}
	 * ]);
	 * var complete = todos.filter({complete: true});
	 * complete //-> DefineList[{name: "lawn", complete: true}]
	 * ```
	 *
	 *    @param  {Object}  props An object of key-value properties.  Each key and value in
	 *    `props` must be present on an `item` for the `item` to be in the returned list.
	 *    @return {can-define/list/list} A new `DefineList` of the same type.
	 */
	"filter": 3,
	/**
	 * @function can-define/list/list.prototype.reduce reduce
	 * @description Map the values in this list to a single value
	 *
	 * @signature `list.reduce(callback, initialValue, [, thisArg])`
	 *
	 * Loops through the values of the list, calling `callback` for each one until the list
	 * ends.  The return value of `callback` is passed to the next iteration as the first argument,
	 * and finally returned by `reduce`.
	 *
	 * ```js
	 * var todos = new DefineList([
	 *   {name: "dishes", complete: false},
	 *   {name: "lawn", complete: true}
	 * ]);
	 * var todosAsOneObject = todos.reduce(function(todos, todo){
	 *   todos[todo.name] = todo.complete;
	 *   return todos;
	 * }, {});
	 * todosAsOneObject //-> { dishes: false, lawn: true }
	 * ```
	 *
	 * @param {function(item, index, list)} callback A function to call with each element of the DefineList.
	 * The four parameters that callback gets passed are:
	 *    - current (*) - the current aggregate value of reducing over the list -- the initial value if the first iteration
	 *    - item (*) - the element at index.
	 *    - index (Integer) - the index of the current element of the list.
	 *    - list (DefineList) - the `DefineList` the elements are coming from.
	 *
	 * The return value of `callback` is passed to the next iteration as the first argument, and returned from
	 * `reduce` if the last iteration.
	 *
	 * @param {*} [initialValue] The initial value to use as `current` in the first iteration
	 * @param {Object} [thisArg] The object to use as `this` inside the callback.
	 * @return {*} The result of the final call of `callback` on the list.
	 * @body
	 *
	 */
	"reduce": 4,
	/**
	 * @function can-define/list/list.prototype.reduceRight reduceRight
	 * @description Map the values in this list to a single value from right to left
	 *
	 * @signature `list.reduceRight(callback, initialValue, [, thisArg])`
	 *
	 * Loops through the values of the list in reverse order, calling `callback` for each one until the list
	 * ends.  The return value of `callback` is passed to the next iteration as the first argument,
	 * and finally returned by `reduce`.
	 *
	 * ```js
	 * var todos = new DefineList([
	 *   {name: "dishes", complete: false},
	 *   {name: "lawn", complete: true}
	 * ]);
	 * var todosAsOneObject = todos.reduce(function(todos, todo){
	 *   todos[todo.name] = todo.complete;
	 *   return todos;
	 * }, {});
	 * todosAsOneObject //-> { dishes: false, lawn: true }
	 * ```
	 *
	 * @param {function(item, index, list)} callback A function to call with each element of the DefineList.
	 * The four parameters that callback gets passed are:
	 *    - current (*) - the current aggregate value of reducing over the list -- the initial value if the first iteration
	 *    - item (*) - the element at index.
	 *    - index (Integer) - the index of the current element of the list.
	 *    - list (DefineList) - the `DefineList` the elements are coming from.
	 *
	 * The return value of `callback` is passed to the next iteration as the first argument, and returned from
	 * `reduce` if the last iteration.
	 *
	 * @param {*} [initialValue] The initial value to use as `current` in the first iteration
	 * @param {Object} [thisArg] The object to use as `this` inside the callback.
	 * @return {*} The result of the final call of `callback` on the list.
	 * @body
	 *
	 */
	"reduceRight": 4,
	/**
	 * @function can-define/list/list.prototype.every every
	 *
	 * Return true if every item in a list matches a predicate.
	 *
	 * @signature `list.every( callback [,thisArg] )`
	 *
	 * Tests each item in `list` by calling `callback` on it.  If `callback` returns truthy for every element in
	 * `list`, `every` returns `true`.
	 *
	 * ```
	 * var names = new DefineList(["alice","adam","zack","zeffer"]);
	 * var aNames = names.every(function(name){
	 *   return name[0] === "a"
	 * });
	 * aNames //-> false
	 * ```
	 *
	 *   @param  {function(*, Number, can-define/list/list)} callback(item, index, list) A
	 *   function to call with each element of the DefineList. The three parameters that callback gets passed are:
	 *    - item (*) - the element at index.
	 *    - index (Integer) - the index of the current element of the list.
	 *    - list (DefineList) - the `DefineList` the elements are coming from.
	 *
	 *   If `callback` returns a truthy result, `every` will evaluate the callback on the next element.  Otherwise, `every`
	 *   will return `false`.
	 *
	 *   @param  {Object}  thisArg  What `this` should be in the `callback`.
	 *   @return {Boolean} `true` if calling the callback on every element in `list` returns a truthy value, `false` otherwise.
	 *
	 * @signature `list.every( props )`
	 *
	 * Tests each item in `list` by comparing its properties to `props`.  If `props` match for every element in
	 * `list`, `every` returns `true`.
	 *
	 * ```
	 * var todos = new DefineList([
	 *   {name: "dishes", complete: false},
	 *   {name: "lawn", complete: true}
	 * ]);
	 * var complete = todos.every({complete: true});
	 * complete //-> false
	 * ```
	 *
	 *    @param  {Object}  props An object of key-value properties.  Each key and value in
	 *    `props` must be present on an `item` for the `item` to match.
	 *    @return {Boolean} `true` if every element in `list` matches `props`, `false` otherwise
	 */
	"every": 3,
	/**
	 * @function can-define/list/list.prototype.some some
	 *
	 * Return true if at least one item in a list matches a predicate.
	 *
	 * @signature `list.some( callback [,thisArg] )`
	 *
	 * Tests each item in `list` by calling `callback` on it.  If `callback` returns truthy for some element in
	 * `list`, `some` returns `true`.
	 *
	 * ```
	 * var names = new DefineList(["alice","adam","zack","zeffer"]);
	 * var aNames = names.some(function(name){
	 *   return name[0] === "a"
	 * });
	 * aNames //-> false
	 * ```
	 *
	 *   @param  {function(*, Number, can-define/list/list)} callback(item, index, list) A
	 *   function to call with each element of the DefineList. The three parameters that callback gets passed are:
	 *    - item (*) - the element at index.
	 *    - index (Integer) - the index of the current element of the list.
	 *    - list (DefineList) - the DefineList the elements are coming from.
	 *
	 *   If `callback` returns a falsy result, `some` will evaluate the callback on the next element.  Otherwise, `some`
	 *   will return `true`.
	 *
	 *   @param  {Object}  thisArg  What `this` should be in the `callback`.
	 *   @return {Boolean} `false` if calling the callback on some element in `list` returns a falsy value, `true` otherwise.
	 *
	 * @signature `list.some( props )`
	 *
	 * Tests each item in `list` by comparing its properties to `props`.  If `props` match for some element in
	 * `list`, `some` returns `true`.
	 *
	 * ```
	 * var todos = new DefineList([
	 *   {name: "dishes", complete: false},
	 *   {name: "lawn", complete: true}
	 * ]);
	 * var complete = todos.some({complete: true});
	 * complete //-> false
	 * ```
	 *
	 *    @param  {Object}  props An object of key-value properties.  Each key and value in
	 *    `props` must be present on an `item` for the `item` to match.
	 *    @return {Boolean} `false` if every element in `list` fails to match `props`, `true` otherwise
	 */
	"some": 3
},
function a(fnLength, fnName) {
	DefineList.prototype[fnName] = function() {
		var self = this;
		var args = [].slice.call(arguments, 0);
		var callback = args[0];
		var thisArg = args[fnLength - 1] || self;

		if (typeof callback === "object") {
			callback = makeFilterCallback(callback);
		}

		args[0] = function() {
			var cbArgs = [].slice.call(arguments, 0);
			// use .get(index) to ensure observation added.
			// the arguments are (item, index) or (result, item, index)
			cbArgs[fnLength - 3] = self.get(cbArgs[fnLength - 2]);
			return callback.apply(thisArg, cbArgs);
		};
		var ret = Array.prototype[fnName].apply(this, args);

		if(fnName === "map") {
			return new DefineList(ret);
		}
		else if(fnName === "filter") {
			return new self.constructor(ret);
		} else {
			return ret;
		}
	};
});


canAssign_1_1_1_canAssign(DefineList.prototype, {
	/**
	 * @function can-define/list/list.prototype.indexOf indexOf
	 * @description Look for an item in a DefineList.
	 * @signature `list.indexOf(item)`
	 *
	 * `indexOf` finds the position of a given item in the DefineList.
	 *
	 * ```
	 * var list = new DefineList(['Alice', 'Bob', 'Eve']);
	 * list.indexOf('Alice');   // 0
	 * list.indexOf('Charlie'); // -1
	 * ```
	 *
	 *   @param {*} item The item to find.
	 *
	 *   @return {Number} The position of the item in the DefineList, or -1 if the item is not found.
	 *
	 * @body
	 *
	 */
	indexOf: function(item, fromIndex) {
		for (var i = fromIndex || 0, len = this.length; i < len; i++) {
			if (this.get(i) === item) {
				return i;
			}
		}
		return -1;
	},

		/**
	 * @function can-define/list/list.prototype.lastIndexOf lastIndexOf
	 * @description Look for an item in a DefineList starting from the end.
	 * @signature `list.lastIndexOf(item)`
	 *
	 * `lastIndexOf` finds the last position of a given item in the DefineList.
	 *
	 * ```
	 * var list = new DefineList(['Alice', 'Bob', 'Alice', 'Eve']);
	 * list.lastIndexOf('Alice');   // 2
	 * list.lastIndexOf('Charlie'); // -1
	 * ```
	 *
	 *   @param {*} item The item to find.
	 *
	 *   @return {Number} The position of the item in the DefineList, or -1 if the item is not found.
	 *
	 * @body
	 *
	 */
	lastIndexOf: function(item, fromIndex) {
		fromIndex = typeof fromIndex === "undefined" ? this.length - 1: fromIndex;
		for (var i = fromIndex; i >= 0; i--) {
			if (this.get(i) === item) {
				return i;
			}
		}
		return -1;
	},

	/**
	 * @function can-define/list/list.prototype.join join
	 * @description Join a DefineList's elements into a string.
	 * @signature `list.join(separator)`
	 *
	 * `join` turns a DefineList into a string by inserting _separator_ between the string representations
	 * of all the elements of the DefineList.
	 *
	 * ```
	 * var list = new DefineList(['Alice', 'Bob', 'Eve']);
	 * list.join(', '); // 'Alice, Bob, Eve'
	 * ```
	 *
	 * @param {String} separator The string to seperate elements.
	 *
	 * @return {String} The joined string.
	 *
	 */
	join: function() {
		canObservationRecorder_1_1_2_canObservationRecorder.add(this, "length");
		return [].join.apply(this, arguments);
	},

	/**
	 * @function can-define/list/list.prototype.reverse reverse
	 * @description Reverse the order of a DefineList.
	 * @signature `list.reverse()`
	 *
	 * Reverses the elements of the DefineList in place.
	 *
	 * ```
	 * var list = new DefineList(['Alice', 'Bob', 'Eve']);
	 * var reversedList = list.reverse();
	 *
	 * reversedList; //-> DefineList['Eve', 'Bob', 'Alice'];
	 * list === reversedList; // true
	 * ```
	 *
	 * @return {can-define/list/list} The DefineList, for chaining.
	 *
	 * @body
	 *
	 */
	reverse: function() {
		// this shouldn't be observable
		var list$$1 = [].reverse.call(this._items());
		return this.replace(list$$1);
	},

	/**
	 * @function can-define/list/list.prototype.slice slice
	 * @description Make a copy of a part of a DefineList.
	 * @signature `list.slice([start[, end]])`
	 *
	 * `slice` creates a copy of a portion of the DefineList.
	 *
	 * ```js
	 * var list = new DefineList(['Alice', 'Bob', 'Charlie', 'Daniel', 'Eve']);
	 * var newList = list.slice(1, 4);
	 * newList //-> DefineList['Bob', 'Charlie', 'Daniel']
	 * ```
	 *
	 * @param {Number} [start=0] The index to start copying from. Defaults to `0`.
	 *
	 * @param {Number} [end] The first index not to include in the copy
	 * If _end_ is not supplied, `slice` will copy until the end of the list.
	 *
	 * @return {can-define/list/list} A new `DefineList` with the extracted elements.
	 *
	 * @body
	 *
	 * ## Use
	 *
	 * `slice` is the simplest way to copy a DefineList:
	 *
	 * ```
	 * var list = new DefineList(['Alice', 'Bob', 'Eve']);
	 * var copy = list.slice();
	 *
	 * copy           //-> DefineList['Alice', 'Bob', 'Eve']
	 * list === copy; //-> false
	 * ```
	 */
	slice: function() {
		// tells computes to listen on length for changes.
		canObservationRecorder_1_1_2_canObservationRecorder.add(this, "length");
		var temp = Array.prototype.slice.apply(this, arguments);
		return new this.constructor(temp);
	},

	/**
	 * @function can-define/list/list.prototype.concat concat
	 * @description Merge many collections together into a DefineList.
	 * @signature `list.concat(...args)`
	 *
	 * Returns a `DefineList` with the `list`'s items and the additional `args`.
	 *
	 * @param {Array|can-define/list/list|*} args Any number of arrays, Lists, or values to add in
	 * For each parameter given, if it is an Array or a DefineList, each of its elements will be added to
	 * the end of the concatenated DefineList. Otherwise, the parameter itself will be added.
	 *
	 * @return {can-define/list/list} A DefineList of the same type.
	 *
	 * @body
	 *
	 * ## Use
	 *
	 * `concat` makes a new DefineList with the elements of the DefineList followed by the elements of the parameters.
	 *
	 * ```
	 * var list = new DefineList();
	 * var newList = list.concat(
	 *     'Alice',
	 *     ['Bob', 'Charlie']),
	 *     new DefineList(['Daniel', 'Eve']),
	 *     {f: 'Francis'}
	 * );
	 * newList.get(); // ['Alice', 'Bob', 'Charlie', 'Daniel', 'Eve', {f: 'Francis'}]
	 * ```
	 */
	concat: function() {
		var args = [];
		// Go through each of the passed `arguments` and
		// see if it is list-like, an array, or something else
		canReflect_1_16_7_canReflect.eachIndex(arguments, function(arg) {
			if (canReflect_1_16_7_canReflect.isListLike(arg)) {
				// If it is list-like we want convert to a JS array then
				// pass each item of the array to this.__type
				var arr = Array.isArray(arg) ? arg : canReflect_1_16_7_canReflect.toArray(arg);
				arr.forEach(function(innerArg) {
					args.push(this.__type(innerArg));
				}, this);
			} else {
				// If it is a Map, Object, or some primitive
				// just pass arg to this.__type
				args.push(this.__type(arg));
			}
		}, this);

		// We will want to make `this` list into a JS array
		// as well (We know it should be list-like), then
		// concat with our passed in args, then pass it to
		// list constructor to make it back into a list
		return new this.constructor(Array.prototype.concat.apply(canReflect_1_16_7_canReflect.toArray(this), args));
	},

	/**
	 * @function can-define/list/list.prototype.forEach forEach
	 * @description Call a function for each element of a DefineList.
	 * @signature `list.forEach(callback[, thisArg])`
	 *
	 * Loops through the values of the list, calling `callback` for each one until the list ends
	 * or `false` is returned.
	 *
	 * ```
	 * list.forEach(function(item, index, list){ ... })
	 * ```
	 *
	 * @param {function(item, index, list)} callback A function to call with each element of the DefineList.
	 * The three parameters that callback gets passed are:
	 *    - item - the element at index.
	 *    - index - the current element of the list.
	 *    - list - the DefineList the elements are coming from.
	 *
	 * If the callback returns `false` the looping stops.
	 *
	 * @param {Object} [thisArg] The object to use as `this` inside the callback.
	 * @return {can-define/list/list} The list instance.
	 * @body
	 *
	 * ## Use
	 *
	 * `forEach` calls a callback for each element in the DefineList.
	 *
	 * ```
	 * var list = new DefineList([1, 2, 3]);
	 * list.forEach(function(element, index, list) {
	 *     list.get(index, element * element);
	 * });
	 * list.get(); // [1, 4, 9]
	 * ```
	 */
	forEach: function(cb, thisarg) {
		var item;
		for (var i = 0, len = this.length; i < len; i++) {
			item = this.get(i);
			if (cb.call(thisarg || item, item, i, this) === false) {
				break;
			}
		}
		return this;
	},

	/**
	 * @function can-define/list/list.prototype.replace replace
	 * @description Replace all the elements of a DefineList.
	 * @signature `list.replace(collection)`
	 *
	 * Replaces every item in the list with `collection`.
	 *
	 * ```
	 * var names = new DefineList(["alice","adam","eve"]);
	 * names.replace(["Justin","Xena"]);
	 * names //-> DefineList["Justin","Xena"]
	 * ```
	 *
	 * @param {Array|can-define/list/list} collection The collection of items that will be in `list`.
	 * @return {can-define/list/list} Returns the `list`.
	 *
	 * @body
	 *
	 * ## Use
	 *
	 * `replace` is essentially a shortcut for [can-define/list/list.prototype.splice].
	 *
	 * ## Events
	 *
	 * `replace` causes _remove_, _add_, and _length_ events.
	 */
	replace: function(newList) {
		var patches = list(this, newList);

		canQueues_1_1_0_canQueues.batch.start();
		for (var i = 0, len = patches.length; i < len; i++) {
			this.splice.apply(this, [
				patches[i].index,
				patches[i].deleteCount
			].concat(patches[i].insert));
		}
		canQueues_1_1_0_canQueues.batch.stop();

		return this;
	},
	/**
	 * @function can-define/list/list.prototype.sort sort
	 * @description Sort the properties of a list.
	 *
	 * @signature `list.sort([compareFunction])`
	 *
	 * Sorts the elements of a list in place and returns the list. The API is the
	 * same as the native JavaScript `Array.prototype.sort` API.
	 *
	 * ```js
	 * var accounts = new Account.List([
	 *   { name: "Savings", amount: 20.00 },
	 *   { name: "Checking", amount: 103.24 },
	 *   { name: "Kids Savings", amount: 48155.13 }
	 * ]);
	 * accounts.sort(function(a, b){
	 *   if (a.name < b.name) {
	 *     return -1;
	 *   } else if (a.name > b.name){
	 *     return 1;
	 *   } else {
	 *     return 0;
	 *   }
	 * });
	 * accounts[0].name === "Checking"
	 * accounts[1].name === "Kids Savings"
	 * accounts[2].name === "Savings"
	 * ```
	 *
	 * @param {function(a, b)} compareFunction Specifies a function that defines the sort order.
	 *
	 * If `compareFunction` is supplied, the list elements are sorted according to the return
	 * value of the compare function. If `a` and `b` are two elements being compared, then:
	 *
	 *  - If `compareFunction(a, b)` returns a value less than 0, `a` will be sorted to
	 *  a lower index than `b`, so `a` will now come first.
	 *  - If `compareFunction(a, b)` returns 0, the order of the two values will not be changed.
	 *  - If `compareFunction(a, b)` returns a value greater than 0, `a` will be sorted to
	 *  a higher index than `b`, so `b` will now come first.
	 *
	 * @return {can-define/list/list} The list instance.
	 * @body
	 * ```
	 */
	sort: function(compareFunction) {
		var sorting = Array.prototype.slice.call(this);
		Array.prototype.sort.call(sorting, compareFunction);
		this.splice.apply(this, [0,sorting.length].concat(sorting) );
		return this;
	}
});


// Add necessary event methods to this object.
for (var prop$1 in canDefine_2_3_5_canDefine.eventsProto) {
	DefineList[prop$1] = canDefine_2_3_5_canDefine.eventsProto[prop$1];
	Object.defineProperty(DefineList.prototype, prop$1, {
		enumerable: false,
		value: canDefine_2_3_5_canDefine.eventsProto[prop$1],
		writable: true
	});
}

Object.defineProperty(DefineList.prototype, "length", {
	get: function() {
		if (!this.__inSetup) {
			canObservationRecorder_1_1_2_canObservationRecorder.add(this, "length");
		}
		return this._length;
	},
	set: function(newVal) {
		if (runningNative) {
			this._length = newVal;
			return;
		}

		// Don't set _length if:
		//  - null or undefined
		//  - a string that doesn't convert to number
		//  - already the length being set
		if (newVal == null || isNaN(+newVal) || newVal === this._length) {
			return;
		}

		if (newVal > this._length - 1) {
			var newArr = new Array(newVal - this._length);
			this.push.apply(this, newArr);
		}
		else {
			this.splice(newVal);
		}
	},
	enumerable: true
});

DefineList.prototype.attr = function(prop, value) {
	canLog_1_0_0_canLog.warn("DefineMap::attr shouldn't be called");
	if (arguments.length === 0) {
		return this.get();
	} else if (prop && typeof prop === "object") {
		return this.set.apply(this, arguments);
	} else if (arguments.length === 1) {
		return this.get(prop);
	} else {
		return this.set(prop, value);
	}
};
DefineList.prototype.item = function(index, value) {
	if (arguments.length === 1) {
		return this.get(index);
	} else {
		return this.set(index, value);
	}
};
DefineList.prototype.items = function() {
	canLog_1_0_0_canLog.warn("DefineList::get should should be used instead of DefineList::items");
	return this.get();
};


canReflect_1_16_7_canReflect.assignSymbols(DefineList.prototype,{
	// type
	"can.isMoreListLikeThanMapLike": true,
	"can.isMapLike": true,
	"can.isListLike": true,
	"can.isValueLike": false,
	// get/set
	"can.getKeyValue": DefineList.prototype.get,
	"can.setKeyValue": DefineList.prototype.set,

	// Called for every reference to a property in a template
	// if a key is a numerical index then translate to length event
	"can.onKeyValue": function(key, handler, queue) {
		var translationHandler;
		if (isNaN(key)) {
			return onKeyValue.apply(this, arguments);
		}
		else {
			translationHandler = function() {
				handler(this[key]);
			};
			//!steal-remove-start
			Object.defineProperty(translationHandler, "name", {
				value: "translationHandler(" + key + ")::" + canReflect_1_16_7_canReflect.getName(this) + ".onKeyValue('length'," + canReflect_1_16_7_canReflect.getName(handler) + ")",
			});
			//!steal-remove-end
			canSingleReference_1_0_0_canSingleReference.set(handler, this, translationHandler, key);
			return onKeyValue.call(this, 'length',  translationHandler, queue);
		}
	},
	// Called when a property reference is removed
	"can.offKeyValue": function(key, handler, queue) {
		var translationHandler;
		if ( isNaN(key)) {
			return offKeyValue.apply(this, arguments);
		}
		else {
			translationHandler = canSingleReference_1_0_0_canSingleReference.getAndDelete(handler, this, key);
			return offKeyValue.call(this, 'length',  translationHandler, queue);
		}
	},

	"can.deleteKeyValue": function(prop) {
		// convert string key to number index if key can be an integer:
		//   isNaN if prop isn't a numeric representation
		//   (prop % 1) if numeric representation is a float
		//   In both of the above cases, leave as string.
		prop = isNaN(+prop) || (prop % 1) ? prop : +prop;
		if(typeof prop === "number") {
			this.splice(prop, 1);
		} else if(prop === "length" || prop === "_length") {
			return; // length must not be deleted
		} else {
			this.set(prop, undefined);
		}
		return this;
	},
	// shape get/set
	"can.assignDeep": function(source){
		canQueues_1_1_0_canQueues.batch.start();
		canReflect_1_16_7_canReflect.assignList(this, source);
		canQueues_1_1_0_canQueues.batch.stop();
	},
	"can.updateDeep": function(source){
		canQueues_1_1_0_canQueues.batch.start();
		this.replace(source);
		canQueues_1_1_0_canQueues.batch.stop();
	},

	// observability
	"can.keyHasDependencies": function(key) {
		return !!(this._computed && this._computed[key] && this._computed[key].compute);
	},
	"can.getKeyDependencies": function(key) {
		var ret;
		if(this._computed && this._computed[key] && this._computed[key].compute) {
			ret = {};
			ret.valueDependencies = new Set([
				this._computed[key].compute
			]);
		}
		return ret;
	},
	/*"can.onKeysAdded": function(handler,queue) {
		this[canSymbol.for("can.onKeyValue")]("add", handler,queue);
	},
	"can.onKeysRemoved": function(handler,queue) {
		this[canSymbol.for("can.onKeyValue")]("remove", handler,queue);
	},*/
	"can.splice": function(index, deleteCount, insert){
		this.splice.apply(this, [index, deleteCount].concat(insert));
	},
	"can.onPatches": function(handler,queue){
		this[canSymbol_1_6_1_canSymbol.for("can.onKeyValue")](localOnPatchesSymbol, handler,queue);
	},
	"can.offPatches": function(handler,queue) {
		this[canSymbol_1_6_1_canSymbol.for("can.offKeyValue")](localOnPatchesSymbol, handler,queue);
	},

	//!steal-remove-start
	"can.getName": function() {
		return canReflect_1_16_7_canReflect.getName(this.constructor) + "[]";
	},
	//!steal-remove-end
});

canReflect_1_16_7_canReflect.setKeyValue(DefineList.prototype, canSymbol_1_6_1_canSymbol.iterator, function() {
	var index = -1;
	if(typeof this._length !== "number") {
		this._length = 0;
	}
	return {
		next: function() {
			index++;
			return {
				value: this[index],
				done: index >= this._length
			};
		}.bind(this)
	};
});

canDefine_2_3_5_canDefine.DefineList = DefineList;

var list$1 = canNamespace_1_0_0_canNamespace.DefineList = DefineList;

var utils = {
    isContainer: function (current) {
        var type = typeof current;
        return current && (type === "object" || type === "function");
    },
    strReplacer: /\{([^\}]+)\}/g,

    parts: function(name) {
        if(Array.isArray(name)) {
            return name;
        } else {
            return typeof name !== 'undefined' ? (name + '').replace(/\[/g,'.')
            		.replace(/]/g,'').split('.') : [];
        }
    }
};

var canKey_0_5_0_utils= utils;

/**
 * @module {function} can-key/get/get
 * @parent can-key
 * @description Get properties on deep/nested objects of different types: Object, Map, [can-reflect] types, etc.
 *
 * @signature `get(obj, path)`
 * @param  {Object} obj the object to use as the root for property-based navigation
 * @param  {String} path a String of dot-separated keys, representing a path of properties
 * @return {*}       the value at the property path
 *
 * @body
 *
 * A *path* is a dot-delimited sequence of zero or more property names, such that "foo.bar" means "the property
 * 'bar' of the object at the property 'foo' of the root."  An empty path returns the object passed.
 *
 * ```js
 * var get = require("can-key");
 * console.log(get({a: {b: {c: "foo"}}}, "a.b.c")); // -> "foo"
 * console.log(get({a: {}}, "a.b.c")); // -> undefined
 * console.log(get([{a: {}}, {a: {b: "bar"}}], "a.b")); // -> "bar"
 *
 * var map = new Map();
 * map.set("first", {second: "third"});
 *
 * get(map, "first.second") //-> "third"
 * ```
 */
function get(obj, name) {
    // The parts of the name we are looking up
    // `['App','Models','Recipe']`
    var parts = canKey_0_5_0_utils.parts(name);

    var length = parts.length,
        current, i, container;

    if (!length) {
        return obj;
    }

    current = obj;

    // Walk current to the 2nd to last object or until there
    // is not a container.
    for (i = 0; i < length && canKey_0_5_0_utils.isContainer(current) && current !== null; i++) {
        container = current;
        current = canReflect_1_16_7_canReflect.getKeyValue( container, parts[i] );
    }

    return current;
}

var get_1 = get;

/**
 * @module {function} can-key/delete/delete
 * @parent can-key
 */
var _delete = function deleteAtPath(data, path) {
    var parts = canKey_0_5_0_utils.parts(path);
    var current = data;

    for(var i = 0; i < parts.length - 1; i++) {
        if(current) {
            current = canReflect_1_16_7_canReflect.getKeyValue( current, parts[i]);
        }
    }

    if(current) {
        canReflect_1_16_7_canReflect.deleteKeyValue(current, parts[parts.length - 1 ]);
    }
};

/**
 * @module {function} can-key/sub/sub
 * @parent can-key
 * @hide
 *
 * Replace templated parts of a string with values.
 *
 * @signature `sub(str, data, remove)`
 *
 * `sub` is used to replace templated parts of a string with values.
 *
 * ```js
 * var sub = require("can-key/sub/sub");
 *
 * sub("foo_{bar}", {bar: "baz"}); // -> "foo_baz"
 * ```
 *
 * If `null` or `undefined` values are found, `null` is returned:
 *
 * ```js
 * sub("foo_{bar}", {}); // -> null
 * ```
 *
 * If an object value is found, the templated part of the string is replace with `""`
 * and the object is added to an array that is returned.
 *
 * ```js
 * var data = {element: div, selector: "li" }
 * var res = sub("{element} {selector} click", data);
 * res //-> [" li click", div]
 * ```
 *
 * @param {String} str   a string with {curly brace} delimited property names
 * @param {Object} data  an object from which to read properties
 * @return {String|null|Array} the supplied string with delimited properties replaced with their values
 *                       if all properties exist on the object, null otherwise
 *
 * If `remove` is true, the properties found in delimiters in `str` are removed from `data`.
 *
 *
 */
var sub = function sub(str, data, remove) {
	var obs = [];
	str = str || '';
	obs.push(str.replace(canKey_0_5_0_utils.strReplacer, function (whole, inside) {
		// Convert inside to type.
		var ob = get_1(data, inside);

		if(remove === true) {
			_delete(data, inside);
		}

		if (ob === undefined || ob === null) {
			obs = null;
			return '';
		}
		// If a container, push into objs (which will return objects found).
		if (!canReflect_1_16_7_canReflect.isPrimitive(ob) && obs) {
			obs.push(ob);
			return '';
		}
		return '' + ob;
	}));
	return obs === null ? obs : obs.length <= 1 ? obs[0] : obs;
};

// # can-query-logic/set.js
// This file defines the set mechanics of types.
// It provides ways for types to define how to perform
// `union`, `difference`, `intersection` operations.
//
// It also derives other operators (`isEqual`, `isSubset`, etc) from these
// core operators.
//
// `.memberOf` is a property that defines if a value is within the set. It's
// currently a different thing.





// This is what we are defining
var set$1;

// ## HELPERS =========
//
// Used to make sure an object serializes to itself.
// This makes sure the empty object won't try to clone itself.
var addSerializeToThis = function(obj) {
	return canReflect_1_16_7_canReflect.assignSymbols(obj, {
		"can.serialize": function() {
			return this;
		}
	});
};

// Reverses the arguments of a function.
function reverseArgs(fn) {
	return function(first, second) {
		return fn.call(this, second, first);
	};
}

// This symbol is put on constructor functions to track the comparator operators
// available to that type.
var setComparisonsSymbol = canSymbol_1_6_1_canSymbol.for("can.setComparisons");

// Adds comparators to a type. They are stored like:
// Type[@can.setComparisons] = Map({
//    [type1]: Map({[type2]: {union, different, intersection}})
// })
//
// Why do we need the outer object?
function addComparators(type1, type2, comparators) {
	var comparisons = type1[setComparisonsSymbol];
	if (!type1[setComparisonsSymbol]) {
		comparisons = type1[setComparisonsSymbol] = new Map();
	}
	var subMap = comparisons.get(type1);

	if (!subMap) {
		subMap = new Map();
		comparisons.set(type1, subMap);
	}
	var existingComparators = subMap.get(type2);
	if (existingComparators) {
		for (var prop in comparators) {
			if (existingComparators.hasOwnProperty(prop)) {
				console.warn("Overwriting " + type1.name + " " + prop + " " + type2.name + " comparitor");
			}
			existingComparators[prop] = comparators[prop];
		}
	} else {
		subMap.set(type2, comparators);
	}
}


// This type is used for primitives in JS, but it can be used for
// any value that should only === itself.
function Identity() {}

var typeMap = {
	"number": Identity,
	"string": Identity,
	"undefined": Identity,
	"boolean": Identity
};

// `get.intersection`, etc is used to look within the types
// maps and get the right comparator operators.
var get$1 = {};
/*
var algebraSymbol = {
    "intersection": "âˆ©",
    "union": "âˆª",
    "difference": "\\"
};
*/

["intersection", "difference", "union"].forEach(function(prop) {
	get$1[prop] = function(forwardComparators, value1, value2) {

		if (value2 === set$1.UNIVERSAL) {
			if (prop === "intersection") {
				return value1;
			}
			if (prop === "union") {
				return set$1.UNIVERSAL;
			}
			if (prop === "difference") {
				return set$1.EMPTY;
			}
		}
		if (value1 === set$1.UNIVERSAL) {
			if (prop === "intersection") {
				return value1;
			}
			if (prop === "union") {
				return set$1.UNIVERSAL;
			}
		}

		if (forwardComparators && forwardComparators[prop]) {
			var result = forwardComparators[prop](value1, value2);
			// console.log("",/*name1,*/ value1, algebraSymbol[prop], /*name2,*/ value2,"=", result);
			if (result === undefined && forwardComparators.undefinedIsEmptySet === true) {
				return set$1.EMPTY;
			} else {
				return result;
			}
		} else {
			throw new Error("Unable to perform " + prop + " between " + set$1.getType(value1).name + " and " + set$1.getType(value2).name);
		}

	};
});



set$1 = {
	// The special types

	// All values within the "universe". Other sets can equal UNIVERSAL.
	UNIVERSAL: canReflect_1_16_7_canReflect.assignSymbols({
		name: "UNIVERSAL"
	}, {
		"can.serialize": function() {
			return this;
		},
		"can.isMember": function(){
			return true;
		}
	}),
	// Nothing
	EMPTY: canReflect_1_16_7_canReflect.assignSymbols({
		name: "EMPTY"
	}, {
		"can.serialize": function() {
			return this;
		},
		"can.isMember": function(){
			return false;
		}
	}),
	// The set exists, but we lack the language to represent it.
	UNDEFINABLE: addSerializeToThis({
		name: "UNDEFINABLE"
	}),
	// We don't know if this exists. Intersection between two paginated sets.
	UNKNOWABLE: addSerializeToThis({
		name: "UNKNOWABLE"
	}),
	Identity: Identity,
	isSpecial: function(setA) {
		return setA === set$1.UNIVERSAL || setA === set$1.EMPTY ||
			setA === set$1.UNDEFINABLE || setA === set$1.UNKNOWABLE;
	},
	isDefinedAndHasMembers: function(setA) {
		if (setA !== set$1.EMPTY && setA !== set$1.UNDEFINABLE && setA !== set$1.UNKNOWABLE) {
			return setA;
		} else {
			return false;
		}
	},
	getType: function(value) {
		if (value === set$1.UNIVERSAL) {
			return set$1.UNIVERSAL;
		}
		if (value === set$1.EMPTY) {
			return set$1.EMPTY;
		}
		if (value === set$1.UNKNOWABLE) {
			return set$1.UNKNOWABLE;
		}
		if (value === null) {
			return Identity;
		}
		if (typeMap.hasOwnProperty(typeof value)) {
			return typeMap[typeof value];
		}
		return value.constructor;
	},
	ownAndMemberValue: function(startOwnValue, startMemberValue) {
		// If either side has a value, then try to type-coerse.
		if (startOwnValue != null || startMemberValue != null) {
			var ownValue = startOwnValue != null ? startOwnValue.valueOf() : startOwnValue,
				memberValue = startMemberValue != null ? startMemberValue.valueOf() : startMemberValue;
			// if we have nulls or undefineds
			if (startOwnValue == null || startMemberValue == null) {
				return {
					own: ownValue,
					member: memberValue
				};
			}
			if (ownValue.constructor !== memberValue.constructor) {
				memberValue = new startOwnValue.constructor(memberValue).valueOf();
			}
			return {
				own: ownValue,
				member: memberValue
			};
		}
		return {
			own: startMemberValue,
			member: startOwnValue
		};
	},
	getComparisons: function(Type1, Type2) {
		var comparisons = Type1[setComparisonsSymbol];
		if (comparisons) {
			var subMap = comparisons.get(Type1);

			if (subMap) {
				return subMap.get(Type2);
			}
		}
	},
	hasComparisons: function(Type) {
		return !!Type[setComparisonsSymbol];
	},
	defineComparison: function(type1, type2, comparators) {
		addComparators(type1, type2, comparators);
		if (type1 !== type2) {
			var reverse = {};
			for (var prop in comparators) {
				// difference can not be reversed
				if (prop !== "difference") {
					reverse[prop] = reverseArgs(comparators[prop]);
				}

			}
			addComparators(type2, type1, reverse);
		}
	},
	/**
	 * Checks if A is a subset of B.  If A is a subset of B if:
	 * - A \ B = EMPTY (A has nothing outside what's in B)
	 * - A âˆ© B = defined
	 */
	isSubset: function(value1, value2) {
		// check primary direction
		if (value1 === value2) {
			return true;
		}
		var Type1 = set$1.getType(value1),
			Type2 = set$1.getType(value2);
		var forwardComparators = set$1.getComparisons(Type1, Type2);
		if (forwardComparators) {
			// A set is a subset, if it intersects with the set, and it has nothing
			// outside the other set.
			var intersection = get$1.intersection(forwardComparators, value1, value2);
			// [a, b] \ [a, b, c]
			var difference = get$1.difference(forwardComparators, value1, value2);
			// they intersect, but value2 has nothing value1 outside value2
			if (intersection === set$1.UNKNOWABLE || difference === set$1.UNKNOWABLE) {
				// {sort: "a", page: 0-2} E {sort: "b", page: 2-3}
				return undefined;
			} else if (intersection !== set$1.EMPTY && difference === set$1.EMPTY) {
				return true;
			} else {
				return false;
			}
		} else {
			throw new Error("Unable to perform subset comparison between " + Type1.name + " and " + Type2.name);
		}
	},
	isProperSubset: function(setA, setB) {
		return set$1.isSubset(setA, setB) && !set$1.isEqual(setA, setB);
	},
	isEqual: function(value1, value2) {
		if (value1 === set$1.UNKNOWABLE || value2 === set$1.UNKNOWABLE) {
			return set$1.UNKNOWABLE;
		}
		//console.group("is", value1, "==", value2);
		var isSpecial1 = set$1.isSpecial(value1),
			isSpecial2 = set$1.isSpecial(value2);

		// Both have to be specail because some other sets will be equal to UNIVERSAL without being UNIVERSAL
		if (isSpecial1 && isSpecial2) {
			return isSpecial1 === isSpecial2;
		}
		var Type1 = set$1.getType(value1),
			Type2 = set$1.getType(value2);
		if (value1 === value2) {
			return true;
		}
		var forwardComparators = set$1.getComparisons(Type1, Type2);
		var reverseComparators = set$1.getComparisons(Type2, Type1);
		if (forwardComparators && reverseComparators) {

			// Two sets are equal if there's an intersection, but not difference
			var intersection = get$1.intersection(forwardComparators, value1, value2);
			var difference = get$1.difference(forwardComparators, value1, value2);
			if (intersection !== set$1.EMPTY && difference === set$1.EMPTY) {
				var reverseIntersection = get$1.intersection(reverseComparators, value2, value1);
				var reverseDifference = get$1.difference(reverseComparators, value2, value1);
				//console.groupEnd();
				return reverseIntersection !== set$1.EMPTY && reverseDifference === set$1.EMPTY;
			} else {
				//console.groupEnd();
				return false;
			}
		} else {
			var values = set$1.ownAndMemberValue(value1, value2);
			if (canReflect_1_16_7_canReflect.isPrimitive(values.own) && canReflect_1_16_7_canReflect.isPrimitive(values.member)) {
				return values.own === values.member;
			} else {
				// try to convert ...
				throw new Error("Unable to perform equal comparison between " + Type1.name + " and " + Type2.name);
			}

		}
	},

	union: function(value1, value2) {
		if (value1 === set$1.UNIVERSAL || value2 === set$1.UNIVERSAL) {
			return set$1.UNIVERSAL;
		}
		if (value1 === set$1.EMPTY) {
			return value2;
		} else if (value2 === set$1.EMPTY) {
			return value1;
		}
		if (value1 === set$1.UNKNOWABLE || value2 === set$1.UNKNOWABLE) {
			return set$1.UNKNOWABLE;
		}
		var Type1 = set$1.getType(value1),
			Type2 = set$1.getType(value2);
		var forwardComparators = set$1.getComparisons(Type1, Type2);
		return get$1.union(forwardComparators, value1, value2);
	},

	intersection: function(value1, value2) {
		if (value1 === set$1.UNIVERSAL) {
			return value2;
		}
		if (value2 === set$1.UNIVERSAL) {
			return value1;
		}
		if (value1 === set$1.EMPTY || value2 === set$1.EMPTY) {
			return set$1.EMPTY;
		}
		if (value1 === set$1.UNKNOWABLE || value2 === set$1.UNKNOWABLE) {
			return set$1.UNKNOWABLE;
		}
		var Type1 = set$1.getType(value1),
			Type2 = set$1.getType(value2);
		var forwardComparators = set$1.getComparisons(Type1, Type2);
		if (forwardComparators) {
			return get$1.intersection(forwardComparators, value1, value2);
		} else {
			throw new Error("Unable to perform intersection comparison between " + Type1.name + " and " + Type2.name);
		}
	},
	difference: function(value1, value2) {
		if (value1 === set$1.EMPTY) {
			return set$1.EMPTY;
		}
		if (value2 === set$1.EMPTY) {
			return value1;
		}
		if (value1 === set$1.UNKNOWABLE || value2 === set$1.UNKNOWABLE) {
			return set$1.UNKNOWABLE;
		}
		var Type1 = set$1.getType(value1),
			Type2 = set$1.getType(value2);
		var forwardComparators = set$1.getComparisons(Type1, Type2);
		if (forwardComparators) {
			return get$1.difference(forwardComparators, value1, value2);
		} else {
			throw new Error("Unable to perform difference comparison between " + Type1.name + " and " + Type2.name);
		}
	},

	indexWithEqual: function(arr, value) {
		for (var i = 0, len = arr.length; i < len; i++) {
			if (set$1.isEqual(arr[i], value)) {
				return i;
			}
		}
		return -1;
	}

};



function identityIntersection(v1, v2) {
	return v1 === v2 ? v1 : set$1.EMPTY;
}

function identityDifference(v1, v2) {
	return v1 === v2 ? set$1.EMPTY : v1;
}

function identityUnion(v1, v2) {
	return v1 === v2 ? v1 : set$1.UNDEFINABLE;
}
var identityComparitor = {
	intersection: identityIntersection,
	difference: identityDifference,
	union: identityUnion
};
set$1.defineComparison(Identity, Identity, identityComparitor);

set$1.defineComparison(set$1.UNIVERSAL, set$1.UNIVERSAL, identityComparitor);

var set_1 = set$1;

var replacer =  /\{([^\}]+)\}/g;
// Returns data from a url, given a fixtue URL. For example, given
// "todo/{id}" and "todo/5", it will return an object with an id property
// equal to 5.
var canFixture_3_0_0Pre_11_dataFromUrl = function dataFromUrl(fixtureUrl, url) {
	if(!fixtureUrl) {
		// if there's no url, it's a match
		return {};
	}

	var order = [],
		// Sanitizes fixture URL
		fixtureUrlAdjusted = fixtureUrl.replace('.', '\\.')
			.replace('?', '\\?'),
		// Creates a regular expression out of the adjusted fixture URL and
		// runs it on the URL we passed in.
		res = new RegExp(fixtureUrlAdjusted.replace(replacer, function (whole, part) {
			order.push(part);
			return "([^\/]+)";
		}) + "$")
			.exec(url),
		data = {};

	// If there were no matches, return null;
	if (!res) {
		return null;
	}

	// Shift off the URL and just keep the data.
	res.shift();
	order.forEach( function (name) {
		// Add data from regular expression onto data object.
		data[name] = res.shift();
	});
	return data;
};

function getValue(value){
    return value == null ? value : value.valueOf();
}

var arrayUnionIntersectionDifference = function arrayUnionIntersectionDifference(arr1, arr2){
    var set = new Set();

    var intersection = [];
    var union = [];
    var difference = arr1.slice(0);


    arr1.forEach(function(value){
        set.add(getValue(value));
        union.push(value);
    });

    arr2.forEach(function(value){
        if(set.has(getValue(value))) {
            intersection.push(value);
            var index = set_1.indexWithEqual(difference, value);
            if(index !== -1) {
                difference.splice(index, 1);
            }
        } else {
            union.push(value);
        }
    });

    return {
        intersection: intersection,
        union: union,
        difference: difference
    };
};

var isMemberSymbol$1 = canSymbol_1_6_1_canSymbol.for("can.isMember");
// $ne	Matches all values that are not equal to a specified value.
// $eq	Matches values that are equal to a specified value.
//
// $gt	Matches values that are greater than a specified value.
// $gte	Matches values that are greater than or equal to a specified value.

// $lt	Matches values that are less than a specified value.
// $lte	Matches values that are less than or equal to a specified value.

// $in	Matches any of the values specified in an array.
// $nin	Matches none of the values specified in an array.



var comparisons = {
	In: function In(values) {
		// TODO: change this to store as `Set` later.
		this.values = values;
	},
	NotIn: function NotIn(values) {
		this.values = values;
	},
	GreaterThan: function GreaterThan(value) {
		this.value = value;
	},
	GreaterThanEqual: function GreaterThanEqual(value) {
		this.value = value;
	},
	LessThan: function LessThan(value) {
		this.value = value;
	},
	LessThanEqual: function LessThanEqual(value) {
		this.value = value;
	},
	// This is used to And something like `GT(3)` n `LT(4)`.
	// These are all value comparisons.
	And: function ValueAnd(ands) {
		this.values = ands;
	},
	// This is used to OR something like `GT(4)` n `LT(3)`.
	// These are all value comparisons.
	Or: function ValueOr(ors) {
		this.values = ors;
	}
};

comparisons.Or.prototype.orValues = function() {
	return this.values;
};


comparisons.In.test = function(values, b) {
	return values.some(function(value) {
		var values = set_1.ownAndMemberValue(value, b);
		return values.own === values.member;
	});
};

comparisons.NotIn.test = function(values, b) {
	return !comparisons.In.test(values, b);
};
comparisons.NotIn.testValue = function(value, b) {
	return !comparisons.In.testValue(value, b);
};

function nullIsFalse(test) {
	return function(arg1, arg2) {
		if (arg1 == null || arg2 == null) {
			return false;
		} else {
			return test(arg1, arg2);
		}
	};
}

function nullIsFalseTwoIsOk(test) {
	return function(arg1, arg2) {
		if (arg1 === arg2) {
			return true;
		} else if (arg1 == null || arg2 == null) {
			return false;
		} else {
			return test(arg1, arg2);
		}
	};
}

comparisons.GreaterThan.test = nullIsFalse(function(a, b) {
	return a > b;
});
comparisons.GreaterThanEqual.test = nullIsFalseTwoIsOk(function(a, b) {
	return a >= b;
});
comparisons.LessThan.test = nullIsFalse(function(a, b) {
	return a < b;
});
comparisons.LessThanEqual.test = nullIsFalseTwoIsOk(function(a, b) {
	return a <= b;
});



function isMemberThatUsesTest(value) {
	var values = set_1.ownAndMemberValue(this.value, value);
	return this.constructor.test(values.member, values.own);
}
[comparisons.GreaterThan, comparisons.GreaterThanEqual, comparisons.LessThan, comparisons.LessThanEqual, comparisons.LessThan].forEach(function(Type) {
	Type.prototype.isMember = isMemberThatUsesTest;
});

function isMemberThatUsesTestOnValues(value) {
	return this.constructor.test(this.values, value);
}
[comparisons.In, comparisons.NotIn].forEach(function(Type) {
	Type.prototype.isMember = isMemberThatUsesTestOnValues;
});

comparisons.And.prototype.isMember = function(value) {
	return this.values.every(function(and) {
		return and.isMember(value);
	});
};
comparisons.Or.prototype.isMember = function(value) {
	return this.values.some(function(and) {
		return and.isMember(value);
	});
};
Object.keys(comparisons).forEach(function(name){
	comparisons[name].prototype[isMemberSymbol$1] = comparisons[name].prototype.isMember;
});



function makeNot(Type) {
	return {
		test: function(vA, vB) {
			return !Type.test(vA, vB);
		}
	}
}


function makeEnum(type, Type, emptyResult) {
	return function(a, b) {
		var result = arrayUnionIntersectionDifference(a.values, b.values);
		if (result[type].length) {
			return new Type(result[type]);
		} else {
			return emptyResult || set_1.EMPTY;
		}
	};
}

function swapArgs(fn) {
	return function(a, b) {
		return fn(b, a)
	};
}


function makeSecondValue(Type, prop) {
	return function(universe, value) {
		return new Type(value[prop || "value"]);
	};
}

function returnBiggerValue(gtA, gtB) {
	if (gtA.value < gtB.value) {
		return gtB;
	} else {
		return gtA;
	}
}

function returnSmallerValue(gtA, gtB) {
	if (gtA.value > gtB.value) {
		return gtB;
	} else {
		return gtA;
	}
}

function makeAndIf(Comparison, Type) {
	return function(ltA, ltB) {
		if (Comparison.test(ltA.value, ltB.value)) {
			return makeAnd([ltA, new Type(ltB.value)]);
		} else {
			return set_1.EMPTY;
		}
	};
}

function make_InIfEqual_else_andIf(Comparison, Type) {
	var elseCase = makeAndIf(Comparison, Type);
	return function(a, b) {
		if (a.value === b.value) {
			return new is.In([a.value]);
		} else {
			return elseCase(a, b);
		}
	};
}

function make_filterFirstValueAgainstSecond(Comparison, Type, defaultReturn) {
	return function(inSet, gt) {
		var values = inSet.values.filter(function(value) {
			return Comparison.test(gt, value);
		});
		return values.length ?
			new Type(values) : defaultReturn || set_1.EMPTY;
	};
}

var isMemberTest = {
	test: function isMemberTest(set, value) {
		return set.isMember(value);
	}
};

function isOr(value) {
	return (value instanceof is.Or);
}

function isAnd(value) {
	return (value instanceof is.And);
}

function isAndOrOr(value) {
	return isAnd(value) || isOr(value);
}

function combineFilterFirstValuesAgainstSecond(options) {
	return function(inSet, gt) {
		var values = inSet.values.filter(function(value) {
			return options.values.test(gt, value);
		});
		var range;
		if (options.complement) {
			range = set_1.difference(set_1.UNIVERSAL, gt);
		} else if (options.with) {
			range = new options.with(gt.value);
		} else {
			range = gt;
		}
		return values.length ?
			options.combinedUsing([new options.arePut(values), range]) : range;
	};
}

function makeOrUnless(Comparison, result) {
	return function(setA, setB) {
		if (Comparison.test(setA.value, setB.value)) {
			return result || set_1.UNIVERSAL;
		} else {
			return makeOr([setA, setB]);
		}
	}
}

function makeAndUnless(Comparison, result) {
	return function(setA, setB) {
		if (Comparison.test(setA.value, setB.value)) {
			return result || set_1.EMPTY;
		} else {
			return makeAnd([setA, setB]);
		}
	}
}

function makeComplementSecondArgIf(Comparison) {
	return function(setA, setB) {
		if (Comparison.test(setA.value, setB.value)) {
			return set_1.difference(set_1.UNIVERSAL, setB);
		} else {
			return setA;
		}
	}
}


function makeAnd(ands) {
	return comparisons.And ? new comparisons.And(ands) : set_1.UNDEFINABLE;
}

function makeOr(ors) {
	return comparisons.Or ? new comparisons.Or(ors) : set_1.UNDEFINABLE;
}

var is = comparisons;

var In_RANGE = {
	union: combineFilterFirstValuesAgainstSecond({
		values: makeNot(isMemberTest),
		arePut: is.In,
		combinedUsing: makeOr
	}),
	intersection: make_filterFirstValueAgainstSecond(isMemberTest, is.In, set_1.EMPTY),
	difference: make_filterFirstValueAgainstSecond(makeNot(isMemberTest), is.In, set_1.EMPTY)
};
var RANGE_IN = {
	difference: swapArgs(combineFilterFirstValuesAgainstSecond({
		values: isMemberTest,
		arePut: is.NotIn,
		combinedUsing: makeAnd
	}))
};

var NotIn_RANGE = function() {
	return {
		union: make_filterFirstValueAgainstSecond(makeNot(isMemberTest), is.NotIn, set_1.UNIVERSAL),
		intersection: combineFilterFirstValuesAgainstSecond({
			values: isMemberTest,
			arePut: is.NotIn,
			combinedUsing: makeAnd
		}),
		difference: combineFilterFirstValuesAgainstSecond({
			values: makeNot(isMemberTest),
			arePut: is.NotIn,
			combinedUsing: makeAnd,
			complement: true
		})
	}
};
var RANGE_NotIn = {
	difference: swapArgs(make_filterFirstValueAgainstSecond(isMemberTest, is.In, set_1.EMPTY))
};

var RANGE_And_Union = function(gt, and) {

	var union1 = set_1.union(gt, and.values[0]);
	var union2 = set_1.union(gt, and.values[1]);

	if (!isAndOrOr(union1) && !isAndOrOr(union2)) {
		return set_1.intersection(union1, union2);
	} else {
		return new is.Or([gt, and]);
	}
};
var RANGE_And_Intersection = function(gt, and) {
	var and1 = and.values[0],
		and2 = and.values[1];
	var intersection1 = set_1.intersection(gt, and1);
	var intersection2 = set_1.intersection(gt, and2);
	if (intersection1 === set_1.EMPTY || intersection2 === set_1.EMPTY) {
		return set_1.EMPTY;
	}
	if (!isAndOrOr(intersection1)) {
		return new set_1.intersection(intersection1, and2);
	}

	if (!isAndOrOr(intersection2)) {
		return new set_1.intersection(intersection2, and1);
	} else {
		return new is.And([gt, and]);
	}

};

var RANGE_And_Difference = function(gt, and) {
	var and1 = and.values[0],
		and2 = and.values[1];
	var difference1 = set_1.difference(gt, and1);
	var difference2 = set_1.difference(gt, and2);
	if (difference1 === set_1.EMPTY) {
		return difference2;
	}
	if (difference2 === set_1.EMPTY) {
		return difference1;
	}
	return new is.Or([difference1, difference2]);
};

var And_RANGE_Difference = function(and, gt) {
	var and1 = and.values[0],
		and2 = and.values[1];
	var difference1 = set_1.difference(and1, gt);
	var difference2 = set_1.difference(and2, gt);

	return set_1.intersection(difference1, difference2);
};

var RANGE_Or = {
	union: function(gt, or) {
		var or1 = or.values[0],
			or2 = or.values[1];
		var union1 = set_1.union(gt, or1);
		if (!isAndOrOr(union1)) {
			return set_1.union(union1, or2);
		}
		var union2 = set_1.union(gt, or2);
		if (!isAndOrOr(union2)) {
			return set_1.union(or1, union2);
		} else {
			return new is.Or([gt, or]);
		}
	},
	intersection: function(gt, or) {
		var or1 = or.values[0],
			or2 = or.values[1];
		var intersection1 = set_1.intersection(gt, or1);
		var intersection2 = set_1.intersection(gt, or2);
		if (intersection1 === set_1.EMPTY) {
			return intersection2;
		}
		if (intersection2 === set_1.EMPTY) {
			return intersection1;
		}
		return set_1.union(intersection1, intersection2);
	},
	// v \ (a || b) -> (v \ a) n (v \ b)
	difference: function(gt, or) {

		var or1 = or.values[0],
			or2 = or.values[1];
		var difference1 = set_1.difference(gt, or1);
		var difference2 = set_1.difference(gt, or2);
		return set_1.intersection(difference1, difference2);
	}
};

var Or_RANGE = {
	// ( a || b ) \ v -> (a \ v) U (b \ v)
	difference: function(or, gt) {
		var or1 = or.values[0],
			or2 = or.values[1];
		var difference1 = set_1.difference(or1, gt);
		var difference2 = set_1.difference(or2, gt);
		return set_1.union(difference1, difference2);
	}
};


var comparators = {
	// In
	In_In: {
		union: makeEnum("union", is.In),
		intersection: makeEnum("intersection", is.In),
		difference: makeEnum("difference", is.In)
	},
	UNIVERSAL_In: {
		difference: makeSecondValue(is.NotIn, "values")
	},

	In_NotIn: {
		union: swapArgs(makeEnum("difference", is.NotIn, set_1.UNIVERSAL)),
		// what does In have on its own
		intersection: makeEnum("difference", is.In),
		difference: makeEnum("intersection", is.In)
	},
	NotIn_In: {
		difference: makeEnum("union", is.NotIn)
	},

	In_GreaterThan: In_RANGE,
	GreaterThan_In: RANGE_IN,

	In_GreaterThanEqual: In_RANGE,
	GreaterThanEqual_In: RANGE_IN,

	In_LessThan: In_RANGE,
	LessThan_In: RANGE_IN,

	In_LessThanEqual: In_RANGE,
	LessThanEqual_In: RANGE_IN,
	In_And: In_RANGE,
	And_In: RANGE_IN,

	In_Or: In_RANGE,
	Or_In: RANGE_IN,

	// NotIn ===============================
	NotIn_NotIn: {
		union: makeEnum("intersection", is.NotIn, set_1.UNIVERSAL),
		intersection: makeEnum("union", is.NotIn),
		difference: makeEnum("difference", is.In)
	},
	UNIVERSAL_NotIn: {
		difference: makeSecondValue(is.In, "values")
	},

	NotIn_GreaterThan: NotIn_RANGE(),
	GreaterThan_NotIn: RANGE_NotIn,

	NotIn_GreaterThanEqual: NotIn_RANGE(),
	GreaterThanEqual_NotIn: RANGE_NotIn,

	NotIn_LessThan: NotIn_RANGE(),
	LessThan_NotIn: RANGE_NotIn,

	NotIn_LessThanEqual: NotIn_RANGE(),
	LessThanEqual_NotIn: RANGE_NotIn,

	NotIn_And: NotIn_RANGE(),
	And_NotIn: RANGE_NotIn,

	NotIn_Or: NotIn_RANGE(),
	Or_NotIn: RANGE_NotIn,

	// GreaterThan ===============================
	GreaterThan_GreaterThan: {
		union: returnSmallerValue,
		intersection: returnBiggerValue,
		// {$gt:5} \ {gt: 6} -> AND( {$gt:5}, {$lte: 6} )
		difference: makeAndIf(is.LessThan, is.LessThanEqual)
	},
	UNIVERSAL_GreaterThan: {
		difference: makeSecondValue(is.LessThanEqual)
	},

	GreaterThan_GreaterThanEqual: {
		union: returnSmallerValue,
		intersection: returnBiggerValue,
		// {$gt:5} \ {gte: 6} -> AND( {$gt:5}, {$lt: 6} )
		difference: makeAndIf(is.LessThan, is.LessThan)
	},
	GreaterThanEqual_GreaterThan: {
		difference: make_InIfEqual_else_andIf(is.LessThan, is.LessThanEqual)
	},

	GreaterThan_LessThan: {
		union: makeOrUnless(is.LessThan),
		intersection: makeAndUnless(is.GreaterThan),
		difference: makeComplementSecondArgIf(is.LessThan)
	},
	LessThan_GreaterThan: {
		difference: makeComplementSecondArgIf(is.GreaterThan)
	},

	GreaterThan_LessThanEqual: {
		union: makeOrUnless(is.LessThanEqual),
		intersection: makeAndUnless(is.GreaterThanEqual),
		difference: makeComplementSecondArgIf(is.LessThanEqual)
	},
	LessThanEqual_GreaterThan: {
		difference: makeComplementSecondArgIf(is.GreaterThanEqual)
	},

	GreaterThan_And: {
		union: RANGE_And_Union,
		intersection: RANGE_And_Intersection,
		difference: RANGE_And_Difference
	},
	And_GreaterThan: {
		difference: And_RANGE_Difference
	},
	GreaterThan_Or: RANGE_Or,
	Or_GreaterThan: Or_RANGE,

	// GreaterThanEqual =========
	GreaterThanEqual_GreaterThanEqual: {
		union: returnSmallerValue,
		intersection: returnBiggerValue,
		// {gte: 2} \ {gte: 3} = {gte: 2} AND {lt: 3}
		difference: makeAndIf(is.LessThan, is.LessThan)
	},
	UNIVERSAL_GreaterThanEqual: {
		difference: makeSecondValue(is.LessThan)
	},

	GreaterThanEqual_LessThan: {
		union: makeOrUnless(is.LessThanEqual),
		intersection: makeAndUnless(is.GreaterThanEqual),
		difference: makeComplementSecondArgIf(is.LessThanEqual)
	},
	LessThan_GreaterThanEqual: {
		difference: makeComplementSecondArgIf(is.GreaterThanEqual)
	},

	GreaterThanEqual_LessThanEqual: {
		union: makeOrUnless(is.LessThanEqual),
		// intersect on a number
		intersection: (function() {
			var makeAnd = makeAndUnless(is.GreaterThan);
			return function gte_lte_intersection(gte, lte) {
				var inSet = new is.In([gte.value]);
				if (inSet.isMember(lte.value)) {
					return inSet
				} else {
					return makeAnd(gte, lte);
				}
			};
		})(),
		difference: makeComplementSecondArgIf(is.LessThanEqual)
	},
	LessThanEqual_GreaterThanEqual: {
		difference: makeComplementSecondArgIf(is.GreaterThanEqual)
	},

	GreaterThanEqual_And: {
		union: RANGE_And_Union,
		intersection: RANGE_And_Intersection,
		difference: RANGE_And_Difference
	},
	And_GreaterThanEqual: {
		difference: And_RANGE_Difference
	},
	GreaterThanEqual_Or: RANGE_Or,
	Or_GreaterThanEqual: Or_RANGE,

	// LessThan
	LessThan_LessThan: {
		union: returnBiggerValue,
		intersection: returnSmallerValue,
		difference: makeAndIf(is.GreaterThan, is.GreaterThanEqual)
	},
	UNIVERSAL_LessThan: {
		difference: makeSecondValue(is.GreaterThanEqual)
	},

	LessThan_LessThanEqual: {
		union: returnBiggerValue,
		intersection: returnSmallerValue,
		// {lt: 3} \ {lte: 2} -> {lt: 3} AND {gt: 2}
		difference: makeAndIf(is.GreaterThan, is.GreaterThan)
	},
	LessThanEqual_LessThan: {
		difference: make_InIfEqual_else_andIf(is.GreaterThanEqual, is.GreaterThanEqual)
	},

	LessThan_And: {
		union: RANGE_And_Union,
		intersection: RANGE_And_Intersection,
		difference: RANGE_And_Difference
	},
	And_LessThan: {
		difference: And_RANGE_Difference
	},
	LessThan_Or: RANGE_Or,
	Or_LessThan: Or_RANGE,

	// LessThanEqual
	LessThanEqual_LessThanEqual: {
		union: returnBiggerValue,
		intersection: returnSmallerValue,
		difference: function(lteA, lteB) {
			if (lteA.value >= lteB.value) {
				return makeAnd([lteA, new is.GreaterThan(lteB.value)]);
			} else {
				return set_1.EMPTY;
			}
		}
	},
	UNIVERSAL_LessThanEqual: {
		difference: makeSecondValue(is.GreaterThan)
	},

	LessThanEqual_And: {
		union: RANGE_And_Union,
		intersection: RANGE_And_Intersection,
		difference: RANGE_And_Difference
	},
	And_LessThanEqual: {
		difference: And_RANGE_Difference
	},
	LessThanEqual_Or: RANGE_Or,
	Or_LessThanEqual: Or_RANGE,

	// AND =====
	And_And: {
		// (a n b) U (c n d) => (a U c) n (b U d)?
		// union both ways ... if one is unviersal, the other is the result.
		// (a âˆ© b) âˆª (c âˆ© d) where Z = (a âˆ© b)
		// -> Z âˆª (c âˆ© d)
		// -> (Z âˆª c) âˆ© (Z âˆª d)
		// -> ((a âˆ© b) âˆª c) âˆª ((a âˆ© b) âˆª d)
		union: function(and1, and2) {
			var union1 = set_1.union(and1, and2.values[0]);
			var union2 = set_1.union(and1, and2.values[1]);

			if (isAndOrOr(union1) || isAndOrOr(union2)) {
				// try the other direction
				union1 = set_1.union(and2, and1.values[0]);
				union2 = set_1.union(and2, and1.values[1]);
			}
			if (isAndOrOr(union1) || isAndOrOr(union2)) {
				return new is.Or([and1, and2]);
			} else {
				return set_1.intersection(union1, union2);
			}

			/*
			var combo1 = [
					set.union(and1.values[0], and2.values[0]),
					set.union(and1.values[1], and2.values[1])
				],
				combo2 = [
					set.union(and1.values[0], and2.values[1]),
					set.union(and1.values[1], and2.values[0])
				];
			if(combo1.every(isUniversal)) {
				return set.intersection.apply(set, combo2);
			}
			if(combo2.every(isUniversal)) {
				return set.intersection.apply(set, combo1);
			}
			return new is.Or([and1, and2]);*/
		},

		intersection: function(and1, and2) {
			var intersection1 = set_1.intersection(and1.values[0], and2.values[0]);
			var intersection2 = set_1.intersection(and1.values[1], and2.values[1]);

			if (!isAndOrOr(intersection1) || !isAndOrOr(intersection2)) {
				return set_1.intersection(intersection1, intersection2);
			}
			intersection1 = set_1.intersection(and1.values[0], and2.values[1]);
			intersection2 = set_1.intersection(and1.values[1], and2.values[0]);

			if (!isAndOrOr(intersection1) || !isAndOrOr(intersection2)) {
				return set_1.intersection(intersection1, intersection2);
			} else {
				return new is.And([and1, and2]);
			}
		},
		// (a âˆ© b) \ (c âˆ© d) where Z = (a âˆ© b)
		// -> Z \ (c âˆ© d)
		// -> (Z \ c) âˆª (Z \ d)
		// -> ((a âˆ© b) \ c) âˆª ((a âˆ© b) \ d)
		difference: (function() {

			return function(and1, and2) {
				var d1 = set_1.difference(and1, and2.values[0]);
				var d2 = set_1.difference(and1, and2.values[1]);
				return set_1.union(d1, d2);
			}
			/*
			function getDiffIfPartnerIsEmptyAndOtherComboNotDisjoint(inOrderDiffs, reverseOrderDiffs, diffedAnd) {
				var diff;
				if(inOrderDiffs[0] === set.EMPTY) {
					diff = inOrderDiffs[1];
				}
				if(inOrderDiffs[1] === set.EMPTY) {
					diff = inOrderDiffs[0];
				}
				if(diff) {
					// check if a diff equals itself (and therefor is disjoint)

					if(set.isEqual(diffedAnd.values[0], reverseOrderDiffs[0] ) ) {
						// is disjoint
						return diffedAnd;
					}
					if( set.isEqual(diffedAnd.values[1], reverseOrderDiffs[1] ) ) {
						return diffedAnd;
					}
					return diff;
				}
			}
			return function(and1, and2) {
				var inOrderDiffs = [
						set.difference(and1.values[0], and2.values[0]),
						set.difference(and1.values[1], and2.values[1])
					],
					reverseOrderDiffs = [
						set.difference(and1.values[0], and2.values[1]),
						set.difference(and1.values[1], and2.values[0])
					];

				var diff = getDiffIfPartnerIsEmptyAndOtherComboNotDisjoint(inOrderDiffs, reverseOrderDiffs, and1);
				if(diff) {
					return diff;
				}
				diff = getDiffIfPartnerIsEmptyAndOtherComboNotDisjoint(reverseOrderDiffs, inOrderDiffs, and1);
				if(diff) {
					return diff;
				} else {
					// if one is a double And ... that's the outer \\ inner
					if(isAndOrOr(inOrderDiffs[0]) && isAndOrOr(inOrderDiffs[1])) {
						return new is.Or([inOrderDiffs[0], inOrderDiffs[1]]);
					} else if( isAndOrOr(reverseOrderDiffs[0]) && isAndOrOr(reverseOrderDiffs[1]) ) {
						return new is.Or([reverseOrderDiffs[0], reverseOrderDiffs[1]]);
					}
					return set.UNKNOWABLE;
				}
			};*/
		})()
	},
	And_Or: {
		// (a âˆ© b) âˆª (c u d) where Z = (c u d)
		// -> Z u (a âˆ© b)
		// -> (Z u a) âˆ© (Z u b)
		// -> ((c u d) u a) âˆ© ((c u d) u b)
		union: function(and, or) {
			var aUnion = set_1.union(and.values[0], or);
			var bUnion = set_1.union(and.values[1], or);

			if (!isAndOrOr(aUnion) || !isAndOrOr(bUnion)) {
				return set_1.intersection(aUnion, bUnion);
			}

			return new is.Or([and, or]);
		},
		// (a âˆ© b) âˆ© (c u d) where Z = (a âˆ© b)
		// -> Z âˆ© (c u d)
		// -> (Z âˆ© c) u (Z âˆ© d)
		// -> (a âˆ© b âˆ© c) u (a âˆ© b âˆ© d)
		intersection: function(and, or) {
			var aIntersection = set_1.intersection(and, or.values[0]);
			var bIntersection = set_1.intersection(and, or.values[1]);
			if (!isOr(aIntersection) && !isOr(bIntersection)) {
				return set_1.union(aIntersection, bIntersection);
			}
			return new is.And([and, or]);
		},
		// (a âˆ© b) \ (c u d) where Z = (a âˆ© b)
		// -> Z \ (c u d)
		// -> (Z \ c) âˆ© (Z \ d)
		// -> ((a âˆ© b) \ c) âˆ© ((a âˆ© b) \ d)
		difference: function(and, or) {
			var aDiff = set_1.difference(and, or.values[0]);
			var bDiff = set_1.difference(and, or.values[1]);
			return set_1.intersection(aDiff, bDiff);
		}
	},
	Or_And: {
		// (a âˆª b) \ (c âˆ© d) where Z = (a âˆª b)
		// -> Z \ (c âˆ© d)
		// -> (Z \ c) âˆª (Z \ d)
		// -> ((a âˆª b) \ c) âˆª ((a âˆª b) \ d)
		difference: function(or, and) {
			var aDiff = set_1.difference(or, and.values[0]);
			var bDiff = set_1.difference(or, and.values[1]);
			return set_1.union(aDiff, bDiff);
		}
	},
	UNIVERSAL_And: {
		difference: function(universe, and) {
			var inverseFirst = set_1.difference(universe, and.values[0]),
				inverseSecond = set_1.difference(universe, and.values[1]);
			return set_1.union(inverseFirst, inverseSecond);
		}
	},

	Or_Or: {
		// (a âˆª b) âˆª (c âˆª d)
		union: function(or1, or2) {
			var union1 = set_1.union(or1.values[0], or2.values[0]);
			var union2 = set_1.union(or1.values[1], or2.values[1]);

			if (!isAndOrOr(union1) || !isAndOrOr(union2)) {
				return set_1.union(union1, union2);
			}
			union1 = set_1.union(or1.values[0], or2.values[1]);
			union2 = set_1.union(or1.values[1], or2.values[0]);

			if (!isAndOrOr(union1) || !isAndOrOr(union2)) {
				return set_1.union(union1, union2);
			} else {
				return new is.Or([or1, or2]);
			}
		},
		// (a âˆª b) âˆ© (c âˆª d) where Z = (a âˆª b)
		// -> Z âˆ© (c âˆª d)
		// -> (Z âˆ© c) âˆª (Z âˆª d)
		// -> ((a âˆª b) âˆ© c) âˆª ((a âˆª b) âˆ© d)
		intersection: function(or1, or2) {
			var c = or2.values[0],
				d = or2.values[1];

			var intersection1 = set_1.intersection(or1, c);
			var intersection2 = set_1.intersection(or1, d);

			if (!isOr(intersection1) || !isOr(intersection2)) {
				return set_1.union(intersection1, intersection2);
			}
			intersection1 = set_1.union(or2, or1.values[0]);
			intersection2 = set_1.union(or2, or1.values[1]);

			if (!isOr(intersection1) || !isOr(intersection2)) {
				return set_1.union(intersection1, intersection2);
			} else {
				return new is.Or([or1, or2]);
			}
		},
		// (a âˆª b) \ (c âˆª d) where Z = (a âˆª b)
		// -> Z \ (c âˆª d)
		// -> (Z \ c) âˆ© (Z \ d)
		// -> ((a âˆª b) \ c) âˆ© ((a âˆª b) \ d)
		difference: function(or1, or2) {
			var d1 = set_1.difference(or1, or2.values[0]);
			var d2 = set_1.difference(or1, or2.values[1]);
			return set_1.intersection(d1, d2);
		}
	},
	UNIVERSAL_Or: {
		difference: function(universe, or) {
			var inverseFirst = set_1.difference(universe, or.values[0]),
				inverseSecond = set_1.difference(universe, or.values[1]);
			return set_1.intersection(inverseFirst, inverseSecond);
		}
	},
};

// Registers all the comparisons above
var names = Object.keys(comparisons);
names.forEach(function(name1, i) {
	if (!comparators[name1 + "_" + name1]) {
		console.warn("no " + name1 + "_" + name1);
	} else {
		set_1.defineComparison(comparisons[name1], comparisons[name1], comparators[name1 + "_" + name1]);
	}

	if (!comparators["UNIVERSAL_" + name1]) {
		console.warn("no UNIVERSAL_" + name1);
	} else {
		set_1.defineComparison(set_1.UNIVERSAL, comparisons[name1], comparators["UNIVERSAL_" + name1]);
	}

	for (var j = i + 1; j < names.length; j++) {
		var name2 = names[j];
		if (!comparators[name1 + "_" + name2]) {
			console.warn("no " + name1 + "_" + name2);
		} else {
			set_1.defineComparison(comparisons[name1], comparisons[name2], comparators[name1 + "_" + name2]);
		}
		if (!comparators[name2 + "_" + name1]) {
			console.warn("no " + name2 + "_" + name1);
		} else {
			set_1.defineComparison(comparisons[name2], comparisons[name1], comparators[name2 + "_" + name1]);
		}
	}
});

var comparisons_1 = comparisons;

// THIS IS REALLY INTEGERS!!!

var makeRealNumberRangeInclusive = function(min, max) {




    function RealNumberRangeInclusive(start, end){

        this.start =  arguments.length > 0 ? +start : min;
        this.end = arguments.length > 1 ? +end : max;
		this.range = new comparisons_1.And([
			new comparisons_1.GreaterThanEqual( this.start ),
			new comparisons_1.LessThanEqual( this.end )
		]);
    }

	var universeRange = new RealNumberRangeInclusive( min , max );

    function isUniversal(range) {
        return set_1.isSubset(universeRange.range, range.range);
    }

	function rangeFromAnd(aSet) {
		var values = {};
		aSet.values.forEach(function(value){
			if(value instanceof comparisons_1.GreaterThanEqual) {
				values.start = value.value;
			}
			if(value instanceof comparisons_1.GreaterThan) {
				values.start = value.value+1;
			}
			if(value instanceof comparisons_1.LessThanEqual) {
				values.end = value.value;
			}
			if(value instanceof comparisons_1.LessThan) {
				values.end = value.value-1;
			}
		});
		if("start" in values && "end" in values) {
			return new RealNumberRangeInclusive(values.start, values.end );
		}
	}

	function toRange(aSet) {
		var range;
		if(aSet instanceof comparisons_1.And) {
			range = rangeFromAnd(aSet);
		}
		if(aSet instanceof comparisons_1.Or) {
			// check if next to each other ...
			var first = rangeFromAnd(aSet.values[0]),
				second = rangeFromAnd(aSet.values[1]);
			if(first && second) {
				var firstValues = first.range.values,
					secondValues = second.range.values;
				if(firstValues[1].value + 1 === secondValues[0].value) {
					range = new RealNumberRangeInclusive(firstValues[0].value, secondValues[1].value );
				}
				else if(secondValues[1].value + 1 === firstValues[0].value) {
					range = new RealNumberRangeInclusive(secondValues[0].value, firstValues[1].value );
				} else {
					return set_1.UNDEFINABLE;
				}
			} else {
				return set_1.UNDEFINABLE;
			}
		}
		if(range && isUniversal(range)) {
			return set_1.UNIVERSAL;
		} else {
			return range;
		}
	}

    function intersection(range1, range2){
		var intersection = toRange(set_1.intersection(range1.range, range2.range));
		if(intersection) {
			return intersection;
		} else {
            return set_1.EMPTY;
        }
    }

    function difference(range1, range2){

		var difference = toRange( set_1.difference(range1.range, range2.range) );
		if(difference) {
			return difference;
		} else {
            return set_1.EMPTY;
        }
    }

    set_1.defineComparison(RealNumberRangeInclusive, RealNumberRangeInclusive,{
        union: function(range1, range2){
			var union = toRange( set_1.union(range1.range, range2.range) );
			if(union) {
				return union;
			} else {
	            return set_1.EMPTY;
	        }
        },
        intersection: intersection,
        difference: difference
    });

    set_1.defineComparison(set_1.UNIVERSAL,RealNumberRangeInclusive, {
        difference: function(universe, range){
            if(isUniversal(range)) {
                return set_1.EMPTY;
            } else {
                return difference(universeRange, range);
            }
        }
    });

    return RealNumberRangeInclusive;
};

/*
 * # types
 * This folder is for SetTypes that are used to compare against a single value.
 * For example, `new comparisons.GreaterThan(5)` is used to compare against 
 */



// this is a placeholder for types that have cycle dependencies
var types = {};

// this is intended to be used for $or ... it
// ors expected key values
// `{age: 22}` U `{name: "Justin"}`
function ValuesOr(values) {
    // the if values can be unioned into a single value
    this.values = values;
}

ValuesOr.prototype.isMember = function(props){
    return this.values.some(function(value){
            return value && value.isMember ?
                value.isMember( props ) : value === props;
    });
};


// Or comparisons
set_1.defineComparison(set_1.UNIVERSAL, ValuesOr,{
    difference: function(){
        return set_1.UNDEFINABLE;
    }
});


var valuesOr = types.ValuesOr = ValuesOr;

function NotIdentity(value) {
    this.value = value;
}

// Not comparisons ---------
var Identity$1 = set_1.Identity;

// Only difference is needed w/ universal
set_1.defineComparison(set_1.UNIVERSAL, Identity$1,{
    // A \ B -> what's in b, but not in A
    difference: function(universe, value){
        return new NotIdentity(value);
    }
});

// Only difference is needed w/ universal
set_1.defineComparison(set_1.UNIVERSAL, NotIdentity,{
    // A \ B -> what's in b, but not in A
    difference: function(universe, not){
        return not.value;
    }
});

set_1.defineComparison(NotIdentity, NotIdentity,{
    /*
    // not 5 and not 6
    union: function(obj1, obj2){
        // must unroll the value

    },
    // {foo: zed, abc: d}
    intersection: function(obj1, obj2){

    },
    // A \ B -> what's in b, but not in A
    difference: function(obj1, obj2){

    }
    */
});



set_1.defineComparison(NotIdentity, Identity$1,{
    // not 5 and not 6
    union: function(not, primitive){
        // NOT(5) U 5
        if( set_1.isEqual( not.value, primitive) ) {
            return set_1.UNIVERSAL;
        }
        // NOT(4) U 6
        else {
            throw new Error("Not,Identity Union is not filled out");
        }
    },
    // {foo: zed, abc: d}
    intersection: function(not, primitive){
        return set_1.isEqual( !not.value, primitive ) ? primitive: set_1.EMPTY;
    },
    // A \ B -> what's in b, but not in A
    difference: function difference(not, primitive){
        // NOT(5) \ 3 -> UNDEFINABLE
        // NOT(3) \ 3 -> NOT(3)
        if(set_1.isEqual( not.value, primitive )) {
            return not;
        } else {
            return set_1.UNDEFINABLE;
        }
    }
});

set_1.defineComparison(Identity$1, NotIdentity,{
    difference: function(primitive, not){
        if(set_1.isEqual(primitive, not.value)) {
            return primitive;
        } else {
            return set_1.UNDEFINABLE;
        }
    }
});

var valuesNot = types.Not = NotIdentity;

// Define the sub-types that BasicQuery will use
function KeysAnd(values) {
	var vals = this.values = {};
	canReflect_1_16_7_canReflect.eachKey(values, function(value, key) {
		if (canReflect_1_16_7_canReflect.isPlainObject(value) && !set_1.isSpecial(value)) {
			vals[key] = new KeysAnd(value);
		} else {
			vals[key] = value;
		}
	});
}

var isMemberSymbol$2 = canSymbol_1_6_1_canSymbol.for("can.isMember");


KeysAnd.prototype.isMember = function(props, root, rootKey) {
	var equal = true;
	var preKey = rootKey ? rootKey + "." : "";
	canReflect_1_16_7_canReflect.eachKey(this.values, function(value, key) {
		var isMember = value && (value[isMemberSymbol$2] || value.isMember);
		if (isMember) {
			if (!isMember.call(value, get_1(props, key), root || props, preKey + key)) {
				equal = false;
			}
		} else {
			if (value !== get_1(props, key)) {
				equal = false;
			}
		}
	});
	return equal;
};


// ====== DEFINE COMPARISONS ========

// Helpers ----------------------------
function checkIfUniversalAndReturnUniversal(setA) {
	return set_1.isEqual(setA, set_1.UNIVERSAL) ? set_1.UNIVERSAL : setA;
}

var MISSING = {};

function eachInUnique(a, acb, b, bcb, defaultReturn) {
	var bCopy = canAssign_1_1_1_canAssign({}, b),
		res;
	for (var prop in a) {
		res = acb(prop, a[prop], (prop in b) ? b[prop] : MISSING, a, b);
		if (res !== undefined) {
			return res;
		}
		delete bCopy[prop];
	}
	for (prop in bCopy) {
		res = bcb(prop, MISSING, b[prop], a, b);
		if (res !== undefined) {
			return res;
		}
	}
	return defaultReturn;
}

function keyDiff(valuesA, valuesB) {
	var keyResults = arrayUnionIntersectionDifference(
		Object.keys(valuesA),
		Object.keys(valuesB));
	return {
		aOnlyKeys: keyResults.difference,
		aAndBKeys: keyResults.intersection,
		bOnlyKeys: arrayUnionIntersectionDifference(
			Object.keys(valuesB),
			Object.keys(valuesA)).difference
	};
}

function notEmpty(value) {
	return value !== set_1.EMPTY;
}

// Difference of two ANDs is used two places
function difference(objA, objB) {

	var valuesA = objA.values,
		valuesB = objB.values,
		diff = keyDiff(valuesA, valuesB),
		aOnlyKeys = diff.aOnlyKeys,
		aAndBKeys = diff.aAndBKeys,
		bOnlyKeys = diff.bOnlyKeys;

	// check if all aAndB are equal

	// With the shared keys, perform vA \ vB difference. If the DIFFERENCE is:
	// - EMPTY: vA has nothing outside vB. vA is equal or subset of vB.
	//   - IF sB has keys not in sA, the shared keys will be part of the result;
	//     OTHERWISE, if all empty, sA is subset of sB, EMPTY will be returned
	//                (even if sA has some extra own keys)
	// - NON-EMPTY: something in sA that is not in sB
	//   Now we need to figure out if it's "product-able" or not.
	//   Product-able -> some part of B is in A.
	//   Perform B âˆ© A intersection.  INTERSECTION is:
	//   - EMPTY: NOT "product-able". DISJOINT.  Must return something.
	//   - non-EMPTY: Use to performa  product (in the future.)
	var sharedKeysAndValues = {},
		productAbleKeysAndData = {},
		disjointKeysAndValues = {};
	aAndBKeys.forEach(function(key) {
		var difference = set_1.difference(valuesA[key], valuesB[key]);
		if (difference === set_1.EMPTY) {
			sharedKeysAndValues[key] = valuesA[key];
		} else {
			var intersection = set_1.intersection(valuesA[key], valuesB[key]);
			var isProductable = intersection !== set_1.EMPTY;
			if (isProductable) {
				productAbleKeysAndData[key] = {
					// Products with `difference U intersection` would be subtracted
					// from produts with `intersection`
					difference: difference,
					intersection: intersection
				};
			} else {
				disjointKeysAndValues[key] = valuesA[key];
			}
		}
	});
	var productAbleKeys = Object.keys(productAbleKeysAndData);
	var singleProductKeyAndValue;
	if (productAbleKeys.length === 1) {
		singleProductKeyAndValue = {};
		singleProductKeyAndValue[productAbleKeys[0]] = productAbleKeysAndData[productAbleKeys[0]].difference;
	}

	// Now that we've got the shared keys organized
	// we can make decisions based on this information
	// and A-only and B-only keys.

	// if we have any disjoint keys, these sets can not intersect
	// {age: 21, ...} \ {age: 22, ...} ->  {age: 21, ...}
	if (Object.keys(disjointKeysAndValues).length) {
		return objA;
	}

	// contain all the same keys
	if ((aOnlyKeys.length === 0) && (bOnlyKeys.length === 0)) {
		if (productAbleKeys.length > 1) {
			return set_1.UNDEFINABLE;
		}
		// {color: [RED, GREEN], ...X...} \ {color: [RED], ...X...} -> {color: [GREEN], ...X...}
		else if (productAbleKeys.length === 1) {
			canAssign_1_1_1_canAssign(sharedKeysAndValues, singleProductKeyAndValue);
			return new KeysAnd(sharedKeysAndValues);
		} else {
			// {...X...} \ {...X...} -> EMPTY
			return set_1.EMPTY;
		}
	}
	// sA is likely a subset of sB
	if (aOnlyKeys.length > 0 && bOnlyKeys.length === 0) {
		if (productAbleKeys.length > 1) {
			return set_1.UNDEFINABLE;
		}
		// {age: 35, color: [RED, GREEN], ...X...} \ {color: [RED], ...X...} -> {age: 35, color: [GREEN], ...X...}
		else if (productAbleKeys.length === 1) {
			canAssign_1_1_1_canAssign(sharedKeysAndValues, singleProductKeyAndValue);
			aOnlyKeys.forEach(function(key) {
				sharedKeysAndValues[key] = valuesA[key];
			});
			return new KeysAnd(sharedKeysAndValues);
		} else {
			// sharedKeysAndValues
			return set_1.EMPTY;
		}
	}
	// sB is likely subset of sA
	// {}, {foo: "bar"} -> {foo: NOT("bar")}
	if (aOnlyKeys.length === 0 && bOnlyKeys.length > 0) {
		// Lets not figure out productAbleKeys right now.
		// Example:
		// {color: [RED, GREEN], ...X...}
		// \ {age: 35, color: [RED], ...X...}
		// = OR( {color: [GREEN], ...X...}, {age: NOT(35), color: [RED], ...X...} )
		if (productAbleKeys.length > 1) {
			return set_1.UNDEFINABLE;
		}
		var productAbleOr;
		if (productAbleKeys.length === 1) {
			// we add the intersection to the AND
			// the difference is the or
			var productableKey = productAbleKeys[0];
			productAbleOr = canAssign_1_1_1_canAssign({}, sharedKeysAndValues);
			productAbleOr[productableKey] = productAbleKeysAndData[productableKey].difference;
			sharedKeysAndValues[productableKey] = productAbleKeysAndData[productableKey].intersection;
		}

		var ands = bOnlyKeys.map(function(key) {
			var shared = canAssign_1_1_1_canAssign({}, sharedKeysAndValues);
			var result = shared[key] = set_1.difference(set_1.UNIVERSAL, valuesB[key]);
			return result === set_1.EMPTY ? result : new KeysAnd(shared);
		}).filter(notEmpty);

		if (productAbleOr) {
			ands.push(new KeysAnd(productAbleOr));
		}

		// {c: "g"}
		// \ {c: "g", age: 22, name: "justin"}
		// = OR[ AND(name: NOT("justin"), c:"g"), AND(age: NOT(22), c: "g") ]
		if (ands.length > 1) {
			return new types.ValuesOr(ands);
		} else if (ands.length === 1) {
			// {c: "g"}
			// \ {c: "g", age: 22}
			// = AND(age: NOT(22), c: "g")
			return ands[0];
		} else {
			return set_1.EMPTY;
		}
	}

	// {name: "Justin"} \\ {age: 35} -> {name: "Justin", age: NOT(35)}
	if (aOnlyKeys.length > 0 && bOnlyKeys.length > 0) {
		if (productAbleKeys.length) {
			throw new Error("Can't handle any productable keys right now")
		}
		// add everything in sA into the result:
		aOnlyKeys.forEach(function(key) {
			sharedKeysAndValues[key] = valuesA[key];
		});

		if (bOnlyKeys.length === 1) {
			// TODO: de-duplicate below
			var key = bOnlyKeys[0];
			var shared = canAssign_1_1_1_canAssign({}, sharedKeysAndValues);
			shared[key] = set_1.difference(set_1.UNIVERSAL, valuesB[key]);
			return new KeysAnd(shared);
		}
		// {foo: "bar"} \\ {name: "Justin", age: 35} -> UNDEFINABLE
		else {
			return set_1.UNDEFINABLE;
		}

	}
}

// KeysAnd comaprisons




set_1.defineComparison(KeysAnd, KeysAnd, {
	// {name: "Justin"} or {age: 35} -> new OR[{name: "Justin"},{age: 35}]
	// {age: 2} or {age: 3} -> {age: new OR[2,3]}
	// {age: 3, name: "Justin"} OR {age: 4} -> {age: 3, name: "Justin"} OR {age: 4}
	union: function(objA, objB) {
		// first see if we can union a single property
		// {age: 21, color: ["R"]} U {age: 21, color: ["B"]} -> {age: 21, color: ["R","B"]}

		var diff = keyDiff(objA.values, objB.values);


		// find the different keys
		var aAndBKeysThatAreNotEqual = [],
			sameKeys = {};

		diff.aAndBKeys.forEach(function(key) {
			if (!set_1.isEqual(objA.values[key], objB.values[key])) {
				aAndBKeysThatAreNotEqual.push(key);
			} else {
				sameKeys[key] = objA.values[key];
			}
		});

		// if all keys are shared
		if (!diff.aOnlyKeys.length && !diff.bOnlyKeys.length) {

			if (aAndBKeysThatAreNotEqual.length === 1) {
				var keyValue = aAndBKeysThatAreNotEqual[0];

				var result = sameKeys[keyValue] = set_1.union(objA.values[keyValue], objB.values[keyValue]);

				// if there is only one property, we can just return the universal set
				return canReflect_1_16_7_canReflect.size(sameKeys) === 1 && set_1.isEqual(result, set_1.UNIVERSAL) ?
					set_1.UNIVERSAL : new KeysAnd(sameKeys);
			} else if (aAndBKeysThatAreNotEqual.length === 0) {
				// these things are equal
				return objA;
			}
		}
		// If everything shared is the same
		if (aAndBKeysThatAreNotEqual.length === 0) {
			// the set with the extra keys is a subset
			if (diff.aOnlyKeys.length > 0 && diff.bOnlyKeys.length === 0) {
				return checkIfUniversalAndReturnUniversal(objB);
			} else if (diff.aOnlyKeys.length === 0 && diff.bOnlyKeys.length > 0) {
				return checkIfUniversalAndReturnUniversal(objA);
			}
		}


		return new types.ValuesOr([objA, objB]);
	},
	// {foo: zed, abc: d}
	intersection: function(objA, objB) {
		// combine all properties ... if the same property, try to take
		// an intersection ... if an intersection isn't possible ... freak out?
		var valuesA = objA.values,
			valuesB = objB.values,
			foundEmpty = false;
		var resultValues = {};
		eachInUnique(valuesA,
			function(prop, aVal, bVal) {
				resultValues[prop] = bVal === MISSING ? aVal : set_1.intersection(aVal, bVal);
				if (resultValues[prop] === set_1.EMPTY) {
					foundEmpty = true;
				}
			},
			valuesB,
			function(prop, aVal, bVal) {
				resultValues[prop] = bVal;
				if (resultValues[prop] === set_1.EMPTY) {
					foundEmpty = true;
				}
			});
		if (foundEmpty) {
			return set_1.EMPTY;
		} else {
			return new KeysAnd(resultValues);
		}

	},
	// A \ B -> what's in A, but not in B
	difference: difference
});

set_1.defineComparison(set_1.UNIVERSAL, KeysAnd, {
	// A \ B -> what's in A, but not in B
	difference: function(universe, and) {
		return difference({
			values: {}
		}, and);
	}
});


var keysAnd = types.KeysAnd = KeysAnd;

var andOrNot = {
    KeysAnd: keysAnd,
    ValuesOr: valuesOr,
    ValuesNot: valuesNot
};

var defaultCompare = {
    $gt: function(valueA, valueB) {
        return valueA > valueB;
    },
    $lt: function(valueA, valueB) {
        return valueA < valueB;
    }
};

var helpers$1 =  {
    // given two arrays of items, combines and only returns the unique ones
    uniqueConcat: function(itemsA, itemsB, getId) {
        var ids = new Set();
        return itemsA.concat(itemsB).filter(function(item){
            var id = getId(item);
            if(!ids.has(id)) {
                ids.add(id);
                return true;
            } else {
                return false;
            }
        });
    },
    //
    getIndex: function(compare, items, props){
        if(!items || !items.length) {
            return undefined;
        }
        // check the start and the end
        if( compare(props, items[0]) === -1 ) {
            return 0;
        }
        else if(compare(props, items[items.length -1] ) === 1 ) {
            return items.length;
        }
        var low = 0,
            high = items.length;

        // From lodash lodash 4.6.1 <https://lodash.com/>
        // Copyright 2012-2016 The Dojo Foundation <http://dojofoundation.org/>
        while (low < high) {
            var mid = (low + high) >>> 1,
                item = items[mid],
                computed = compare(props, item);
            if ( computed === -1 ) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        return high;
        // bisect by calling sortFunc
    },
    sortData: function (sortPropValue) {
        if(sortPropValue[0] === "-") {
            return {prop: sortPropValue.slice(1), desc: true};
        } else {
            return {prop: sortPropValue, desc: false};
        }
    },
    defaultCompare: defaultCompare,
    sorter: function (sortPropValue, sorters) {
        var data = helpers$1.sortData(sortPropValue);
        var compare;
        if(sorters && sorters[data.prop]) {
            compare = sorters[data.prop];
        } else {
            compare = defaultCompare;
        }
        return function(item1, item2){
            var item1Value = canReflect_1_16_7_canReflect.getKeyValue(item1, data.prop);
            var item2Value = canReflect_1_16_7_canReflect.getKeyValue(item2, data.prop);
            var temp;

            if(data.desc) {
                temp = item1Value;
                item1Value = item2Value;
                item2Value = temp;
            }

            if( compare.$lt( item1Value, item2Value) ) {
                return -1;
            }

            if( compare.$gt( item1Value, item2Value)) {
                return 1;
            }

            return 0;
        };
    },
		valueHydrator: function(value){
				if(canReflect_1_16_7_canReflect.isBuiltIn(value)) {
						return value;
				} else {
						throw new Error("can-query-logic doesn't support comparison operator: "+JSON.stringify(value));
				}
		}
};
var helpers_1$1 = helpers$1;

var isMemberSymbol$3 = canSymbol_1_6_1_canSymbol.for("can.isMember");

// TYPES FOR FILTERING
var KeysAnd$1 = andOrNot.KeysAnd,
	Or = andOrNot.ValuesOr,
	Not = andOrNot.ValuesNot;

// TYPES FOR PAGINATION
var RecordRange = makeRealNumberRangeInclusive(0, Infinity);

// WILL MAKE A TYPE FOR SORTING
function makeSort(schemaKeys, hydrateAndValue){
	// Makes gt and lt functions that `helpers.sorter` can use
	// to make a `compare` function for `Array.sort(compare)`.`
	var sorters = {};
    canReflect_1_16_7_canReflect.eachKey(schemaKeys, function(schemaProp, key){

        sorters[key] = {
            // valueA is GT valueB
            $gt: function(valueA, valueB) {
                var $gt = hydrateAndValue({$gt: valueB}, key, schemaProp,
									helpers_1$1.valueHydrator);
                return $gt[isMemberSymbol$3](valueA);
            },
            $lt: function( valueA, valueB ){
                var $lt = hydrateAndValue({$lt: valueB}, key, schemaProp,
									helpers_1$1.valueHydrator);
                return $lt[isMemberSymbol$3](valueA);
            }
        };
    });

	function Sort(key) {
		this.key = key;
		this.compare = helpers_1$1.sorter(key, sorters);
	}

	function identityIntersection(v1, v2) {
		return v1.key === v2.key ? v1 : set_1.EMPTY;
	}
	function identityDifference(v1, v2) {
		return v1.key === v2.key ? set_1.EMPTY : v1;
	}
	function identityUnion(v1, v2) {
		return v1.key === v2.key ? v1 : set_1.UNDEFINABLE;
	}
	set_1.defineComparison(Sort, Sort, {
		intersection: identityIntersection,
		difference: identityDifference,
		union: identityUnion
	});
	return Sort;
}

var DefaultSort = makeSort({});


// Define the BasicQuery type
function BasicQuery(query) {
	canAssign_1_1_1_canAssign(this, query);
	if (!this.filter) {
		this.filter = set_1.UNIVERSAL;
	}
	if (!this.page) {
		this.page = new RecordRange();
	}
	if (!this.sort) {
		this.sort = "id";
	}
	if(typeof this.sort === "string") {
		this.sort = new DefaultSort(this.sort);
	}
}

// BasicQuery's static properties
BasicQuery.KeysAnd = KeysAnd$1;
BasicQuery.Or = Or;
BasicQuery.Not = Not;
BasicQuery.RecordRange = RecordRange;
BasicQuery.makeSort = makeSort;

// BasicQuery's prototype methods.
// These are "additional" features beyond what `set` provides.
// These typically pertain to actual data results of a query.
canReflect_1_16_7_canReflect.assignMap(BasicQuery.prototype, {
	count: function() {
		return this.page.end - this.page.start + 1;
	},
	sortData: function(data) {
		return data.slice(0).sort(this.sort.compare);
	},
	filterMembersAndGetCount: function(bData, parentQuery) {
		if (parentQuery) {
			if (!set_1.isSubset(this, parentQuery)) {
				throw new Error("can-query-logic: Unable to get members from a set that is not a superset of the current set.");
			}
		} else {
			parentQuery = new BasicQuery();
		}

		// reduce response to items in data that meet where criteria
		var aData = bData.filter(function(data) {
			return this.filter.isMember(data);
		}, this);

		var count = aData.length;

		// sort the data if needed
		if (count && (this.sort.key !== parentQuery.sort.key)) {
			aData = this.sortData(aData);
		}

		var thisIsUniversal = set_1.isEqual(this.page, set_1.UNIVERSAL),
			parentIsUniversal = set_1.isEqual(parentQuery.page, set_1.UNIVERSAL);

		if (parentIsUniversal) {
			if (thisIsUniversal) {
				return {
					data: aData,
					count: count
				};
			} else {
				return {
					data: aData.slice(this.page.start, this.page.end + 1),
					count: count
				};
			}
		}
		// everything but range is equal
		else if (this.sort.key === parentQuery.sort.key && set_1.isEqual(parentQuery.filter, this.filter)) {
			return {
				data: aData.slice(this.page.start - parentQuery.page.start, this.page.end - parentQuery.page.start + 1),
				count: count
			};
		} else {
			// parent starts at something ...
			throw new Error("can-query-logic: Unable to get members from the parent set for this subset.");
		}
	},
	filterFrom: function(bData, parentQuery) {
		return this.filterMembersAndGetCount(bData, parentQuery).data;
	},
	merge: function(b, aItems, bItems, getId) {
		var union = set_1.union(this, b);

		if (union === set_1.UNDEFINABLE) {
			return undefined;
		} else {
			var combined = helpers_1$1.uniqueConcat(aItems, bItems, getId);
			return union.sortData(combined);
		}
	},
	index: function(props, items) {
		// make sure we have the property
		var data = helpers_1$1.sortData(this.sort.key);
		if (!canReflect_1_16_7_canReflect.hasOwnKey(props, data.prop)) {
			return undefined;
		}
		// use the passed sort's compare function
		return helpers_1$1.getIndex(this.sort.compare, items, props);
	},
	isMember: function(props) {
		// Use the AND type for it's isMember method
		return this.filter.isMember(props);
	},
	removePagination: function(){
		this.page = new RecordRange();
	}
});

// Helpers used for the `set` comparators
var CLAUSE_TYPES = ["filter", "page","sort"];

function getDifferentClauseTypes(queryA, queryB) {
	var differentTypes = [];

	CLAUSE_TYPES.forEach(function(clause) {
		if (!set_1.isEqual(queryA[clause], queryB[clause])) {
			differentTypes.push(clause);
		}
	});

	return differentTypes;
}

function isSubset(subLetter, superLetter, meta) {
	if (meta[subLetter + "FilterIsSubset"]) {
		if (meta[superLetter + "PageIsUniversal"]) {
			return true;
		} else {
			return meta[subLetter + "PageIsSubset"] && meta.sortIsEqual;
		}
	} else {
		return false;
	}
}

// This type contains a bunch of lazy getters that
// cache their value after being read.
// This helps performance.
function MetaInformation(queryA, queryB) {
	this.queryA = queryA;
	this.queryB = queryB;
}

canReflect_1_16_7_canReflect.eachKey({
	"pageIsEqual": function() {
		return set_1.isEqual(this.queryA.page, this.queryB.page);
	},
	"aPageIsUniversal": function() {
		return set_1.isEqual(this.queryA.page, set_1.UNIVERSAL);
	},
	"bPageIsUniversal": function() {
		return set_1.isEqual(this.queryB.page, set_1.UNIVERSAL);
	},
	"pagesAreUniversal": function() {
		return this.pageIsEqual && this.aPageIsUniversal;
	},
	"sortIsEqual": function() {
		return this.queryA.sort.key === this.queryB.sort.key;
	},
	"aFilterIsSubset": function() {
		return set_1.isSubset(this.queryA.filter, this.queryB.filter);
	},
	"bFilterIsSubset": function() {
		return set_1.isSubset(this.queryB.filter, this.queryA.filter);
	},
	"aPageIsSubset": function() {
		return set_1.isSubset(this.queryA.page, this.queryB.page);
	},
	"bPageIsSubset": function() {
		return set_1.isSubset(this.queryB.page, this.queryA.page);
	},
	"filterIsEqual": function() {
		return set_1.isEqual(this.queryA.filter, this.queryB.filter);
	},
	"aIsSubset": function() {
		return isSubset("a", "b", this);
	},
	"bIsSubset": function() {
		return isSubset("b", "a", this);
	}
}, function(def, prop) {
	canDefineLazyValue_1_0_2_defineLazyValue(MetaInformation.prototype, prop, def);
});

function metaInformation(queryA, queryB) {
	var meta = new MetaInformation(queryA, queryB);
	return meta;
}


// Define comparators
set_1.defineComparison(BasicQuery, BasicQuery, {
	union: function(queryA, queryB) {

		var meta = metaInformation(queryA, queryB);


		var filterUnion = set_1.union(queryA.filter, queryB.filter);

		if (meta.pagesAreUniversal) {
			// We ignore the sort.
			return new BasicQuery({
				filter: filterUnion,
				sort: meta.sortIsEqual ? queryA.sort.key : undefined
			});
		}


		if (meta.filterIsEqual) {
			if (meta.sortIsEqual) {
				return new BasicQuery({
					filter: queryA.filter,
					sort: queryA.sort.key,
					page: set_1.union(queryA.page, queryB.page)
				});
			} else {
				if (meta.aIsSubset) {
					return queryB;
				} else if (meta.bIsSubset) {
					return queryA;
				}
				// we can't specify which pagination would bring in everything.
				// but a union does exist.
				return set_1.UNDEFINABLE;
			}
		} else {
			throw new Error("different filters, non-universal pages");
		}
	},
	intersection: function(queryA, queryB) {

		// {age: 35} U {name: "JBM"} -> {age: 35, name: "JBM"}

		// { filter: {age: 35},
		//   page: {0, 10},
		//   sort: "foo" }
		// U
		// { filter: {name: "JBM"},
		//   page: {0, 10},
		//   sort: "foo" }

		var meta = metaInformation(queryA, queryB);

		if (meta.pagesAreUniversal) {
			// We ignore the sort.
			var filterResult = set_1.intersection(queryA.filter, queryB.filter);
			if (set_1.isDefinedAndHasMembers(filterResult)) {
				return new BasicQuery({
					filter: filterResult,
					sort: meta.sortIsEqual ? queryA.sort.key : undefined
				});

			} else {
				return filterResult;
			}
		}



		// check if disjoint wheres
		if (set_1.intersection(queryA.filter, queryB.filter) === set_1.EMPTY) {
			return set_1.EMPTY;
		}

		if (meta.filterIsEqual) {
			if (meta.sortIsEqual) {
				return new BasicQuery({
					filter: queryA.filter,
					sort: queryA.sort.key,
					page: set_1.intersection(queryA.page, queryB.page)
				});
			} else {
				if (meta.aIsSubset) {
					return queryA;
				} else if (meta.bIsSubset) {
					return queryB;
				}
				return set_1.UNKNOWABLE;
				//throw new Error("same filter, different sorts, non universal pages");
			}
		} else {
			if (meta.aIsSubset) {
				return queryA;
			} else if (meta.bIsSubset) {
				return queryB;
			} else {
				// filters are different, both pagination isn't universal
				return set_1.UNDEFINABLE;
			}

		}

	},
	difference: function(queryA, queryB) {

		var differentClauses = getDifferentClauseTypes(queryA, queryB);
		var meta = metaInformation(queryA, queryB);
		var clause;
		if (differentClauses.length > 1) {
			if (meta.aIsSubset) {
				return set_1.EMPTY;
			}
			if (meta.pagesAreUniversal) {
				return new BasicQuery({
					filter: set_1.difference(queryA.filter, queryB.filter),
					sort: queryA.sort.key
				});
			}

			return set_1.UNDEFINABLE;
		} else {
			switch (clause = differentClauses[0]) {
				// if all the clauses are the same, then there can't be a difference
				case undefined:
					{
						return set_1.EMPTY;
					}
				case "sort":
					{
						// if order is the only difference, then there can't be a difference
						// if items are paged but the order is different, though, the sets are not comparable
						// Either way, the result is false
						if (meta.pagesAreUniversal) {
							return set_1.EMPTY;
						} else {
							return set_1.UNKNOWABLE;
						}


					}
				case "page":
				case "filter":
					{
						// if there's only one clause to evaluate or the clauses are where + id,
						// then we can try to determine the difference set.
						// Note that any difference in the ID clause will cause the result to be
						// true (if A has no ID but B has ID) or false (any case where A has ID)
						var result = set_1.difference(queryA[clause],
							queryB[clause]);

						if (set_1.isSpecial(result)) {
							return result;
						} else {
							var query = {
								filter: queryA.filter,
								page: queryA.page,
								sort: queryA.sort.key
							};
							query[clause] = result;
							return new BasicQuery(query);
						}
					}
			}
		}
	}
});


var basicQuery = BasicQuery;

var Serializer = function(entries){
    this.serializers = new Map(entries || []);
    this.serialize = this.serialize.bind(this);
};
Serializer.prototype.add = function(serializers){
    canReflect_1_16_7_canReflect.assign( this.serializers, serializers instanceof Serializer ? serializers.serializers : serializers );
};


Serializer.prototype.serialize = function(item) {
    if(!item) {
        return item;
    }
    var Type = item.constructor;
    var serializer = this.serializers.get(Type);
    if(!serializer) {
        return canReflect_1_16_7_canReflect.serialize(item);
    } else {
        return serializer(item, this.serialize);
    }
};

var serializer = Serializer;

function makeNew(Constructor) {
    return function(value){
        return new Constructor(value);
    };
}
var hydrateMap = {};
function addHydrateFrom(key, hydrate) {
    hydrateMap[key] = function(value, unknownHydrator) {
        return hydrate( unknownHydrator ? unknownHydrator(value[key]) : value[key]);
    };
    Object.defineProperty(hydrateMap[key], "name", {
		value: "hydrate "+key,
		writable: true
	});
}

function addHydrateFromValues(key, hydrate) {
    hydrateMap[key] = function(value, unknownHydrator) {
        var clones = value[key];
        if(unknownHydrator) {
            clones = clones.map(function(value){
                return unknownHydrator(value);
            });
        }
        return hydrate( clones );
    };
    Object.defineProperty(hydrateMap[key], "name", {
		value: "hydrate "+key,
		writable: true
	});
}

// https://docs.mongodb.com/manual/reference/operator/query-comparison/
addHydrateFrom("$eq", function(value){
    return new comparisons_1.In([value]);
});
addHydrateFrom("$ne", function(value){
    return new comparisons_1.NotIn([value]);
});

addHydrateFrom("$gt", makeNew(comparisons_1.GreaterThan));
addHydrateFrom("$gte", makeNew(comparisons_1.GreaterThanEqual));
addHydrateFromValues("$in", makeNew(comparisons_1.In));
addHydrateFrom("$lt", makeNew(comparisons_1.LessThan));
addHydrateFrom("$lte", makeNew(comparisons_1.LessThanEqual));
addHydrateFromValues("$nin", makeNew(comparisons_1.GreaterThan));





var serializer$1 = new serializer([
    [comparisons_1.In,function(isIn, serialize){
        return isIn.values.length === 1 ?
            serialize(isIn.values[0]) :
            {$in: isIn.values.map(serialize)};
    }],
    [comparisons_1.NotIn,function(notIn, serialize){
        return notIn.values.length === 1 ?
            {$ne: serialize(notIn.values[0])} : {$nin: notIn.values.map(serialize)};
    }],
    [comparisons_1.GreaterThan, function(gt, serialize){ return {$gt: serialize(gt.value) }; }],
    [comparisons_1.GreaterThanEqual, function(gte, serialize){ return {$gte: serialize(gte.value) }; }],
    [comparisons_1.LessThan, function(lt, serialize){ return {$lt: serialize(lt.value) }; }],
    [comparisons_1.LessThanEqual, function(lt, serialize){ return {$lte: serialize(lt.value) }; }],
    [comparisons_1.And, function(and, serialize){
        var obj = {};
        and.values.forEach(function(clause){
            canReflect_1_16_7_canReflect.assignMap(obj, serialize(clause) );
        });
        return obj;
    }]
    /*[is.Or, function(or, serialize){
        return {
            $or: or.values.map(function(value){
                return serialize(value, serialize);
            })
        };
    }]*/
]);

var comparisons$1 = {
    hydrate: function(value, hydrateUnknown){
        if(!hydrateUnknown) {
            hydrateUnknown = function(){
                throw new Error("can-query-logic doesn't recognize operator: "+JSON.stringify(value));
            };
        }
        if(Array.isArray(value)) {
            return new comparisons_1.In(value);
        }
        else if(value && typeof value === "object") {
            var keys = Object.keys(value);
            var allKeysAreComparisons = keys.every(function(key){
                return hydrateMap[key]
            });
            if(allKeysAreComparisons) {
                var andClauses = keys.map(function(key){
                    var part = {};
                    part[key] = value[key];
                    var hydrator = hydrateMap[key];
                    return hydrator(part, hydrateUnknown);
                });
                if(andClauses.length > 1) {
                    return new comparisons_1.And(andClauses);
                } else {
                    return andClauses[0];
                }
            } else {
                return hydrateUnknown(value);
            }
        } else {
            return new comparisons_1.In([value]);
        }
    },
    serializer: serializer$1
};

var schemaHelpers;
var schemaHelpers_1 = schemaHelpers = {

    // Number is a ranged type
    isRangedType: function(Type){
        return Type && canReflect_1_16_7_canReflect.isConstructorLike(Type) &&
            !set_1.hasComparisons(Type) &&
            !Type[canSymbol_1_6_1_canSymbol.for("can.SetType")] &&
            Type.prototype.valueOf && Type.prototype.valueOf !== Object.prototype.valueOf;
    },
    categorizeOrValues: function categorizeOrValues(values){

    	var categories = {
    		primitives: [],
    		valueOfTypes: [],
    		others: []
    	};

    	values.forEach(function(value){
    		if( canReflect_1_16_7_canReflect.isPrimitive( value ) ) {
    			categories.primitives.push(value);
    		}
    		else if( schemaHelpers.isRangedType(value) ) {
    			categories.valueOfTypes.push(value);
    		}
    		else {
    			categories.others.push(value);
    		}
    	});
    	return categories;
    }
};

var comparisonSetTypeSymbol = canSymbol_1_6_1_canSymbol.for("can.ComparisonSetType");
var isMemberSymbol$4 = canSymbol_1_6_1_canSymbol.for("can.isMember");

// This helper function seperates out sets that relate to the "maybe" values
// like `null` or `undefined`. For example, if `rangeToBeSplit`
// is `In([null, 3])`, it will produce `{enum: In([null]), range: In(3)}`
function splitByRangeAndEnum(maybeUniverse, rangeToBeSplit) {
	var enumSet;

	// If it's an AND
	if (rangeToBeSplit instanceof comparisons_1.And) {
		// recursively split each value
		var sets = rangeToBeSplit.values.map(function(setInAnd) {
			return splitByRangeAndEnum(maybeUniverse, setInAnd);
		});
		// take the intersections
		return sets.reduce(function(last, maybe) {
			return {
				range: set_1.intersection(last.range, maybe.range),
				enum: set_1.intersection(last.enum, maybe.enum)
			};
		}, {
			range: set_1.UNIVERSAL,
			enum: maybeUniverse
		});

	} else if (rangeToBeSplit instanceof comparisons_1.In) {

		var shouldBeInValues = rangeToBeSplit.values.filter(function(value) {
			return maybeUniverse.isMember(value);
		});
		if (shouldBeInValues.length) {
			var valuesCopy = rangeToBeSplit.values.slice(0);
			canReflect_1_16_7_canReflect.removeValues(valuesCopy, shouldBeInValues);

			return {
				enum: new comparisons_1.In(shouldBeInValues),
				range: valuesCopy.length ? new comparisons_1.In(valuesCopy) : set_1.EMPTY
			};
		} else {
			return {
				enum: set_1.EMPTY,
				range: rangeToBeSplit
			};
		}
	} else if (rangeToBeSplit instanceof comparisons_1.NotIn) {

		// Gets the 'maybe' values in the range
		enumSet = set_1.intersection(maybeUniverse, rangeToBeSplit);

		// We should remove all the values within $in matching an in values.
		var rangeValues = rangeToBeSplit.values.filter(function(value) {
			return !maybeUniverse.isMember(value);
		});
		return {
			range: rangeValues.length ? new comparisons_1.NotIn(rangeValues) : set_1.UNIVERSAL,
			enum: enumSet
		};
	} else {
		return {
			enum: set_1.EMPTY,
			range: rangeToBeSplit
		};
	}
}

// Builds a type for ranged values plus some other enum values.
// This is great for 'maybe' values. For example, it might be a string OR `null` OR `undefined`
// `makeMaybe([null, undefined])`
function makeMaybe(inValues, makeChildType) {


	var maybeUniverse = new comparisons_1.In(inValues);

	function Maybe(values) {

		// Maybe has two sub-sets:
		// - `.range` - Selects the non-enum values. Ex: `GreaterThan(3)`
		// - `.enum` - Selects the enum values. This is ALWAYS an `In`. Ex: `In([null])`.
		// Maybe is effectively an OR with these two properties.
		var result = splitByRangeAndEnum(maybeUniverse, values.range);
		this.range = result.range || set_1.EMPTY;
		if (values.enum) {
			if (result.enum !== set_1.EMPTY) {
				this.enum = set_1.union(result.enum, values.enum);
			} else {
				this.enum = values.enum;
			}
		} else {
			this.enum = result.enum;
		}
		if(this.enum === set_1.EMPTY && this.range === set_1.EMPTY) {
			return set_1.EMPTY;
		}
	}
	Maybe.prototype.orValues = function() {
		var values = [];
		if( this.range !== set_1.EMPTY ) {
			values.push(this.range);
		}
		if( this.enum !== set_1.EMPTY ) {
			values.push(this.enum);
		}
		return values;
	};
	Maybe.prototype[isMemberSymbol$4] = function isMember() {
		var rangeIsMember = this.range[isMemberSymbol$4] || this.range.isMember,
			enumIsMember = this.enum[isMemberSymbol$4] || this.enum.isMember;
		return rangeIsMember.apply(this.range, arguments) || enumIsMember.apply(this.enum, arguments);
	};



	set_1.defineComparison(Maybe, Maybe, {
		union: function(maybeA, maybeB) {
			var enumSet = set_1.union(maybeA.enum, maybeB.enum);
			var range = set_1.union(maybeA.range, maybeB.range);

			return new Maybe({
				enum: enumSet,
				range: range
			});
		},
		difference: function(maybeA, maybeB) {
			var enumSet = set_1.difference(maybeA.enum, maybeB.enum);
			var range = set_1.difference(maybeA.range, maybeB.range);

			return new Maybe({
				enum: enumSet,
				range: range
			});
		},
		intersection: function(maybeA, maybeB) {
			var enumSet = set_1.intersection(maybeA.enum, maybeB.enum);
			var range = set_1.intersection(maybeA.range, maybeB.range);

			return new Maybe({
				enum: enumSet,
				range: range
			});
		}
	});
	Maybe.inValues = inValues;

	set_1.defineComparison(set_1.UNIVERSAL, Maybe, {
		difference: function(universe, maybe) {
			var primary,
				secondary;

			if (maybe.range === set_1.UNIVERSAL) {
				// there is only the enum
				return new Maybe({
					range: maybe.range,
					enum: set_1.difference(maybeUniverse, maybe.enum)
				});
			}
			// there is only a primary
			if (maybe.enum === set_1.EMPTY) {
				var rangeSet = set_1.difference(set_1.UNIVERSAL, maybe.range);
				var notPresent = set_1.difference(maybeUniverse, maybe.range);
				// make sure they are included
				var enumSet = set_1.difference(notPresent, rangeSet);


				return new Maybe({
					range: rangeSet,
					enum: enumSet
				});
				// check enum things that aren't included in primary

			} else {
				primary = set_1.difference(universe, maybe.range);
				secondary = set_1.difference(maybeUniverse, maybe.enum);
			}
			return new Maybe({
				enum: secondary,
				range: primary
			});
		}
	});
	makeChildType = makeChildType || function(v) {
		return v;
	};

	Maybe.hydrate = function(value, childHydrate) {
		return new Maybe({
			range: childHydrate(value, makeChildType)
		});
	};

	return Maybe;
}



makeMaybe.canMakeMaybeSetType = function(Type) {
	var schema = canReflect_1_16_7_canReflect.getSchema(Type);
	if (schema && schema.type === "Or") {
		var categories = schemaHelpers_1.categorizeOrValues(schema.values);

		return categories.valueOfTypes.length === 1 &&
			(categories.valueOfTypes.length + categories.primitives.length === schema.values.length);
	}
	return false;
};

// Given an __Or__ type like:
// ```
// var MaybeString = {
//   "can.new"(val){ ... },
// 	 "can.getSchema"(){ return  { type: "Or", values: [String, undefined, null] }
// });
// ```
//
// This creates two types:
// - `Value` - A value type used for what's within `GreaterThan`, etc.
// - `Maybe` - A SetType for this property. It will have `GreaterThan` within its
//            `{enum, range}` sub values.
//
// This creates the outer `SetType` and the innermost `Value` type while the Comparisons
// are used inbetween.
//
// The `MaybeString` could probably be directly used to hydrate values to what they should be.
makeMaybe.makeMaybeSetTypes = function(Type) {
	var schema = canReflect_1_16_7_canReflect.getSchema(Type);
	var categories = schemaHelpers_1.categorizeOrValues(schema.values);
	var ComparisonSetType;

	// No need to build the comparison type if we are given it.
	if (Type[comparisonSetTypeSymbol]) {
		ComparisonSetType = Type[comparisonSetTypeSymbol];
	} else {

		ComparisonSetType = function(value) {
			this.value = canReflect_1_16_7_canReflect.new(Type, value);
		};
		ComparisonSetType.prototype.valueOf = function() {
			return this.value;
		};
		canReflect_1_16_7_canReflect.assignSymbols(ComparisonSetType.prototype, {
			"can.serialize": function() {
				return this.value;
			}
		});
		//!steal-remove-start
		Object.defineProperty(ComparisonSetType, "name", {
			value: "Or[" + categories.valueOfTypes[0].name + "," + categories.primitives.map(String).join(" ") + "]"
		});
		//!steal-remove-end
	}

	return {
		Maybe: makeMaybe(categories.primitives, function hydrateMaybesValueType(value) {
			return new ComparisonSetType(value);
		}),
		ComparisonSetType: ComparisonSetType
	}
};


var makeMaybe_1 = makeMaybe;

var setTypeSymbol = canSymbol_1_6_1_canSymbol.for("can.SetType"),
	isMemberSymbol$5 = canSymbol_1_6_1_canSymbol.for("can.isMember"),
	newSymbol$2 = canSymbol_1_6_1_canSymbol.for("can.new");

function makeEnumSetType(allValues, hydrate) {
	function Enum(values) {
		var arr = Array.isArray(values) ? values : [values];
		this.values = hydrate ? arr.map(hydrate) : arr;
	}
	canReflect_1_16_7_canReflect.assignSymbols(Enum.prototype, {
		"can.serialize": function() {
			return this.values.length === 1 ? this.values[0] : this.values;
		}
	});

	Enum.prototype[isMemberSymbol$5] = function(value) {
		return this.values.some(function(val) {
			return set_1.isEqual(val, value);
		});
	};

	Enum.UNIVERSAL = new Enum(allValues);

	var difference = function(enum1, enum2) {
		var result = arrayUnionIntersectionDifference(enum1.values, enum2.values);
		if (result.difference.length) {
			return new Enum(result.difference);
		} else {
			return set_1.EMPTY;
		}
	};

	set_1.defineComparison(Enum, Enum, {
		union: function(enum1, enum2) {
			var result = arrayUnionIntersectionDifference(enum1.values, enum2.values);
			if (result.union.length) {
				return new Enum(result.union);
			} else {
				return set_1.EMPTY;
			}
		},
		intersection: function(enum1, enum2) {
			var result = arrayUnionIntersectionDifference(enum1.values, enum2.values);
			if (result.intersection.length) {
				return new Enum(result.intersection);
			} else {
				return set_1.EMPTY;
			}
		},
		difference: difference
	});

	set_1.defineComparison(Enum, set_1.UNIVERSAL, {
		difference: function(enumA) {
			return difference(enumA, {
				values: allValues.slice(0)
			});
		}
	});

	set_1.defineComparison(set_1.UNIVERSAL, Enum, {
		difference: function(universe, enumB) {
			return difference({
				values: allValues.slice(0)
			}, enumB);
		}
	});

	return Enum;
}

function makeEnum$1(Type, allValues, hydrate) {

	var Enum = makeEnumSetType(allValues, hydrate);

	Type[setTypeSymbol] = Enum;
	Type[isMemberSymbol$5] = function(value) {
		return allValues.some(function(val) {
			return set_1.isEqual(val, value);
		});
	};

	return Enum;
}

makeEnum$1.canMakeEnumSetType = function(Type) {
	var schema = canReflect_1_16_7_canReflect.getSchema(Type);
	if (schema && schema.type === "Or") {
		var categories = schemaHelpers_1.categorizeOrValues(schema.values);
		return categories.primitives.length === schema.values.length;
	}
	return false;
};

makeEnum$1.makeEnumSetType = function(Type) {
	var schema = canReflect_1_16_7_canReflect.getSchema(Type);
	var categories = schemaHelpers_1.categorizeOrValues(schema.values);
	var hydrate = Type[newSymbol$2] ? Type[newSymbol$2].bind(Type) : undefined;
	return makeEnumSetType(categories.primitives, hydrate);
};

var makeEnum_1 = makeEnum$1;

var setTypeSymbol$1 = canSymbol_1_6_1_canSymbol.for("can.SetType");
var schemaSymbol = canSymbol_1_6_1_canSymbol.for("can.getSchema");

var defaultQuery = new basicQuery({});


function getSchemaProperties(value) {
    var constructor = value.constructor;
    if(constructor && constructor[schemaSymbol]) {
        var schema = constructor[schemaSymbol]();
        return schema.keys || {};
    } else {
        return {};
    }
}

function hydrateFilter(values, schemaProperties, hydrateUnknown) {
    if(values && typeof values === "object" && ("$or" in values)) {
        return hydrateOrs(values.$or, schemaProperties, hydrateUnknown);
    } else {
        return hydrateAndValues(values, schemaProperties, hydrateUnknown);
    }
}

var setTypeMap = new WeakMap();

// This is used to hydrate a value directly within a `filter`'s And.
function hydrateAndValue(value, prop, SchemaType, hydrateChild){
    // The `SchemaType` is the type of value on `instances` of
    // the schema. `Instances` values are different from `Set` values.
    if(SchemaType) {
        // If there's a `SetType`, we will use that
        var SetType = SchemaType[setTypeSymbol$1];
        if(SetType) {
            /// If it exposes a hydrate, this means it can use the current hydrator to
            // hydrate its children.
            // I'm not sure why it's not taking the `unknown` hydrator instead.
            if(SetType.hydrate) {
                return SetType.hydrate(value, comparisons$1.hydrate);
            }
            // If the SetType implemented `union`, `intersection`, `difference`
            // We can create instances of it directly.
            else if(set_1.hasComparisons(SetType)) {
                // Todo ... canReflect.new
                return new SetType(value);
            }
            // If the SetType did not implement the comparison methods,
            // it's probably just a "Value" comparison type. We will hydrate
            // as a comparison converter, but create an instance of this `"Value"`
            // comparison type within the comparison converter.
            else {
                // inner types
                return comparisons$1.hydrate(value, function(value){
                    return new SetType(value);
                });
            }

        } else {
            // There is a `SchemaType`, but it doesn't have a `SetType`.
            // Can we create the SetType from the `SchemaType`?
            if(makeEnum_1.canMakeEnumSetType(SchemaType)) {
                if(!setTypeMap.has(SchemaType)) {
                    setTypeMap.set(SchemaType, makeEnum_1.makeEnumSetType(SchemaType) );
                }
                SetType = setTypeMap.get(SchemaType);
                return new SetType(value);
            }
            // It could also have a `ComparisonSetType` which are the values
            // within the Maybe type.
            else if(makeMaybe_1.canMakeMaybeSetType(SchemaType)) {
                if(!setTypeMap.has(SchemaType)) {
                    setTypeMap.set(SchemaType, makeMaybe_1.makeMaybeSetTypes(SchemaType) );
                }
                SetType = setTypeMap.get(SchemaType).Maybe;
                return SetType.hydrate(value, comparisons$1.hydrate);
            }
            // We can't create the `SetType`, so lets hydrate with the default behavior.
            else {
                return comparisons$1.hydrate(value, hydrateChild);
            }
        }
    } else {
        // HERE {$gt: 1} -> new is.GreaterThan(1)
        return comparisons$1.hydrate(value, hydrateChild);
    }
}

function hydrateAndValues(values, schemaProperties, hydrateUnknown) {
    schemaProperties = schemaProperties || {};

    function hydrateChild(value) {
        if(value) {
            if(Array.isArray(value)) {
                return value.map(hydrateUnknown);
            } else if(canReflect_1_16_7_canReflect.isPlainObject(value)) {
                // lets try to get the schema ...
                return hydrateAndValues(value, getSchemaProperties(value));
            }
        }
        if(hydrateUnknown) {
            return hydrateUnknown(value);
        } else {
            return value;
        }
    }
    var clone = {};
    canReflect_1_16_7_canReflect.eachKey(values, function(value, prop){
        clone[prop] = hydrateAndValue(value, prop, schemaProperties[prop], hydrateChild);
    });

    return new basicQuery.KeysAnd(clone);

}
// This tries to combine a bunch of OR-ed ANDS into a single AND.
// Example: [{name: "j", age: 3},{name: "j", age: 4}] //-> {name: "j", age: in[3,4]}
function combineAnds(ands) {
    var firstKeys = Object.keys(ands[0].values);
    var keys = {};

    var keysCompare = new comparisons_1.In(firstKeys);

    firstKeys.map(function(key){
        keys[key] = [];
    });

    var sameKeys = ands.every(function(and){
        // have to have the same keys
        if(!set_1.isEqual(keysCompare, new comparisons_1.In(Object.keys(and.values))) ) {
            return false;
        }
        canReflect_1_16_7_canReflect.eachKey(and.values, function(value, key){
            keys[key].push(value);
        });
        return true;
    });
    if(!sameKeys) {
        return;
    }
    // now try to union everything and see if it simplifies ...
    var unequalKeys = [];
    firstKeys.forEach(function(key){
        var isEqual = keys[key].reduce(function(newSet, lastSetOrFalse){
            if(lastSetOrFalse === false) {
                return false;
            }
            if(lastSetOrFalse === undefined) {
                return newSet;
            }
            var res = set_1.isEqual(newSet,lastSetOrFalse);
            return res ? newSet : false;
        });
        if(!isEqual) {
            unequalKeys.push(key);
        }
    });

    if(unequalKeys.length !== 1) {
        return;
    }
    var unionKey = unequalKeys[0];
    // lets see if we can union that one value
    var unioned = keys[unionKey].reduce(function(cur, last){
        return set_1.union(cur, last);
    }, set_1.EMPTY);

    var result = {};
    firstKeys.map(function(key){
        result[key] = keys[key][0];
    });
    result[unionKey] = unioned;
    return new basicQuery.KeysAnd(result);
}

function hydrateOrs(values, schemaProperties, hydrateUnknown ) {
    var comparisons = values.map(function(value){
        return hydrateAndValues(value, schemaProperties, hydrateUnknown);
    });
    var combined = combineAnds(comparisons);
    if(combined) {
        return combined;
    }
    return new basicQuery.Or(comparisons);
}



var basicQuery$1 = function(schema) {

    var id = schema.identity && schema.identity[0];
    var keys = schema.keys;

    var serializeMap = [
        [basicQuery.Or, function(or, serializer$$1){
            return or.values.map(function(value){
                return serializer$$1(value);
            });
        }],
        // this destructures ANDs with OR-like clauses
        [basicQuery.KeysAnd, function(and, serializer$$1){
            var ors = [];
            var result = {};
            canReflect_1_16_7_canReflect.eachKey(and.values, function(value, key){
                // is value universal ... if not, we don't need to add anything

                if(typeof value.orValues === "function") {
                    canReflect_1_16_7_canReflect.addValues( ors, value.orValues().map(function(orValue){
                        var result = {};
                        result[key] = serializer$$1(orValue);
                        return result;
                    }) );
                } else {
                    result[key] = serializer$$1(value);
                }
            });
            if(ors.length) {
                if(ors.length === 1 ) {
                    return ors[0];
                } else {
                    return {
                        $or: ors.map(function(orPart){
                            return canReflect_1_16_7_canReflect.assign( canReflect_1_16_7_canReflect.serialize(result), orPart);
                        })
                    };
                }
            } else {
                return result;
            }

        }],
        [basicQuery.RecordRange, function(range){
            return {start: range.start, end: range.end};
        }],
        [basicQuery, function(basicQuery$$1, childSerializer){

            var filter = set_1.isEqual(basicQuery$$1.filter, set_1.UNIVERSAL) ? {} : childSerializer(basicQuery$$1.filter);

            var res = {};
            if(canReflect_1_16_7_canReflect.size(filter) !== 0) {
                res.filter= filter;
            }

            if(!set_1.isEqual(basicQuery$$1.page, defaultQuery.page)) {
                // we always provide the start, even if it's 0
                res.page = {
                    start: basicQuery$$1.page.start
                };
                if(basicQuery$$1.page.end !== defaultQuery.page.end) {
                    res.page.end = basicQuery$$1.page.end;
                }
            }

            if(basicQuery$$1.sort.key !== id) {
                res.sort = basicQuery$$1.sort.key;
            }
            return res;

        }]
    ];



    // Makes a sort type that can make a compare function using the SetType
    var Sort = basicQuery.makeSort(keys, hydrateAndValue);
    var serializer$$1 = new serializer(serializeMap);
    serializer$$1.add(comparisons$1.serializer);

    return {
        hydrate: function(data){

            //!steal-remove-start
            var AcceptedFields = makeEnum_1(function(){},["filter","sort","page"]);
            var diff = set_1.difference(new AcceptedFields(Object.keys(data)), AcceptedFields.UNIVERSAL);
            if(diff.values && diff.values.length) {
    			dev.warn(
    				"can-query-logic: Ignoring keys: " + diff.values.join(", ") + "."
    			);
    		}
    		//!steal-remove-end


            var filter = canReflect_1_16_7_canReflect.serialize(data.filter);

            // this mutates
            var filterAnd = hydrateFilter(filter, keys, helpers_1$1.valueHydrator);

            // Conver the filter arguments

            var query = {
                filter: filterAnd
            };
            if(data.page) {
                query.page = new basicQuery.RecordRange(data.page.start, data.page.end);
            }
            if(data.sort) {
                query.sort = new Sort(data.sort);
            } else {
                query.sort = new Sort(id);
            }
            return new basicQuery(query);
        },
        serializer: serializer$$1
    };
};

var schemaSymbol$1 = canSymbol_1_6_1_canSymbol.for("can.getSchema");
var newSymbol$3 = canSymbol_1_6_1_canSymbol.for("can.new");



// Creates an algebra used to convert primitives to types and back
function QueryLogic(Type, options){
    Type = Type || {};
    var passedHydrator = options && options.toQuery;
    var passedSerializer = options && options.toParams;
    var schema;
    if(Type[schemaSymbol$1]) {
        schema = Type[schemaSymbol$1]();
    } else {
        schema = Type;
    }

    // check that the basics are here

    var id = schema.identity && schema.identity[0];
    if(!id) {
        //console.warn("can-query given a type without an identity schema.  Using `id` as the identity id.");
        schema.identity = ["id"];
    }

    var converter = basicQuery$1(schema),
        hydrate,
        serialize;

    if(passedHydrator) {
        hydrate = function(query){
            return converter.hydrate(passedHydrator(query));
        };
    } else {
        hydrate = converter.hydrate;
    }

    if(passedSerializer) {
        serialize = function(query){
            return passedSerializer(converter.serializer.serialize(query));
        };
    } else {
        serialize = converter.serializer.serialize;
    }
    this.hydrate = hydrate;
    this.serialize = serialize;
    this.schema = schema;

}

function makeNewSet(prop){
    return function(qA, qB){
        var queryA = this.hydrate(qA),
            queryB = this.hydrate(qB);
        var unionQuery = set_1[prop](queryA , queryB );
        return this.serialize( unionQuery );
    };
}

function makeReturnValue(prop) {
    return function(qA, qB){
        var queryA = this.hydrate(qA),
            queryB = this.hydrate(qB);
        return set_1[prop](queryA , queryB );
    };
}

canReflect_1_16_7_canReflect.assignSymbols(QueryLogic.prototype,{
    "can.getSchema": function(){
        return this.schema;
    }
});

canReflect_1_16_7_canReflect.assign(QueryLogic.prototype,{
    union: makeNewSet("union"),
    difference: makeNewSet("difference"),
    intersection: makeNewSet("intersection"),

    isEqual: makeReturnValue("isEqual"),
    isProperSubset: makeReturnValue("isProperSubset"),
    isSubset: makeReturnValue("isSubset"),

    isSpecial: set_1.isSpecial,
    isDefinedAndHasMembers: set_1.isDefinedAndHasMembers,

    count: function(a){
        var queryA = this.hydrate(a);
        return queryA.page.end - queryA.page.start + 1;
    },

    // identity keys
    identityKeys: function(){
        console.warn("you probably can get the identity keys some other way");
        return this.schema.identity;
    },

    filterMembers: function(a, b, bData){
        var queryA = this.hydrate(a);
        if(arguments.length >= 3) {
            var queryB = this.hydrate(b);
            return queryA.filterFrom(bData, queryB);
        } else {
            return queryA.filterFrom(b);
        }

    },
    // filterMembersAndGetCount
    filterMembersAndGetCount: function(a, b, bData) {
        var queryA = this.hydrate(a),
            queryB = this.hydrate(b);
        return queryA.filterMembersAndGetCount(bData, queryB);
    },
    // unionMembers
    unionMembers: function(a, b, aData, bData) {
        var queryA = this.hydrate(a),
            queryB = this.hydrate(b);

        var schema = this.schema;
        return queryA.merge(queryB, aData, bData, function(obj){
            return canReflect_1_16_7_canReflect.getIdentity(obj, schema);
        });
    },
    // isMember
    isMember: function(query, props) {
        return this.hydrate(query).isMember(props);
    },

    memberIdentity: function(props) {
        console.warn("you probably can get the member identity some other way");
        return canReflect_1_16_7_canReflect.getIdentity(props, this.schema);
    },
    index: function(query, items, props){
        return this.hydrate(query).index(props, items);
    },

    insert: function(query, items, item){
    	var index = this.index(query, items, item);
    	if(index === undefined) {
    		index = items.length;
    	}

    	var copy = items.slice(0);
    	copy.splice(index, 0, item);

    	return copy;
    },

    isPaginated: function(query) {
        var basicQuery$$1 = this.hydrate(query);
        return !set_1.isEqual(basicQuery$$1.page, set_1.UNIVERSAL);
    },
    removePagination: function(query) {
        var basicQuery$$1 = this.hydrate(query);
        basicQuery$$1.removePagination();
        return this.serialize( basicQuery$$1 );
    },

});

QueryLogic.UNIVERSAL = set_1.UNIVERSAL;
// Nothing
QueryLogic.EMPTY = set_1.EMPTY;
// The set exists, but we lack the language to represent it.
QueryLogic.UNDEFINABLE = set_1.UNDEFINABLE;

// We don't know if this exists. Intersection between two paginated sets.
QueryLogic.UNKNOWABLE = set_1.UNKNOWABLE;

QueryLogic.makeEnum = function(values){
    var Type = function(){};
		Type[newSymbol$3] = function(val) { return val; };
    makeEnum_1(Type, values);
    return Type;
};
QueryLogic.defineComparison = set_1.defineComparison;
QueryLogic.isSpecial = set_1.isSpecial;
QueryLogic.isDefinedAndHasMembers = QueryLogic.isDefinedAndHasMembers;

QueryLogic.KeysAnd = basicQuery.KeysAnd;
QueryLogic.ValuesOr = basicQuery.Or;



QueryLogic.In = comparisons_1.In;
QueryLogic.NotIn = comparisons_1.NotIn;
QueryLogic.GreaterThan = comparisons_1.GreaterThan;
QueryLogic.GreaterThanEqual = comparisons_1.GreaterThanEqual;
QueryLogic.LessThan = comparisons_1.LessThan;
QueryLogic.LessThanEqual = comparisons_1.LessThanEqual;
QueryLogic.ValueAnd = comparisons_1.And;
QueryLogic.ValueOr = comparisons_1.Or;

var canQueryLogic_0_8_11_canQueryLogic = QueryLogic;

function deepMatches(a, b) {
	if(a === b) {
		return true;
	} else if(Array.isArray(a) && Array.isArray(b)) {

		return a.every(function(aVal, i){
			return deepMatches(aVal, b[i]);
		});

	} else if(a && b && canReflect_1_16_7_canReflect.isPlainObject(a) && canReflect_1_16_7_canReflect.isPlainObject(b)) {

		for(var prop in a) {
			if(!b.hasOwnProperty(prop)) {
				return false;
			}
			if(!deepMatches(a[prop], b[prop])) {
				return false;
			}
		}
		return true;

	} else {
		return false
	}
}

function removeFixtureAndXHR(query) {
	if(query.fixture || query.xhr || query.data) {
		var clone = canReflect_1_16_7_canReflect.serialize(query);
		delete clone.fixture;
		delete clone.xhr;
		delete clone.data;
		return clone;
	} else {
		return query;
	}
}

function identityIntersection$1(v1, v2) {
    return v1.value === v2.value ? v1 : set_1.EMPTY;
}
function identityDifference$1(v1, v2){
    return v1.value === v2.value ? set_1.EMPTY : v1;
}
function identityUnion$1(v1, v2) {
    return v1.value === v2.value ? v1 : set_1.UNDEFINABLE;
}
var identityComparitor$1 = {
    intersection: identityIntersection$1,
    difference: identityDifference$1,
    union: identityUnion$1
};



function makeComparatorType(compare) {
	var Type = function(){};
	var SetType = function(value) {
		this.value = value;
	};
	SetType.prototype.isMember = function(value, root, keys){
	    return compare(this.value, value, root, keys);
	};
	canReflect_1_16_7_canReflect.assignSymbols(Type,{
		"can.SetType": SetType
	});

	set_1.defineComparison(SetType,SetType, identityComparitor$1);

	set_1.defineComparison(set_1.UNIVERSAL,SetType,{
		difference: function(){
			return set_1.UNDEFINABLE;
		}
	});
	return Type;
}

function quickEqual(queryA, queryB){
	var dataA = queryA.data,
		dataB = queryB.data;
	if(dataA && dataB) {
		if(!deepMatches(dataA, dataB)) {
			return false;
		}
	}
	var q1 = new canQueryLogic_0_8_11_canQueryLogic.KeysAnd(removeFixtureAndXHR(queryA)),
		q2 = new canQueryLogic_0_8_11_canQueryLogic.KeysAnd(removeFixtureAndXHR(queryB));
	return set_1.isEqual( q1, q2 );
}

function quickSubset(queryA, queryB){
	return set_1.isSubset( new canQueryLogic_0_8_11_canQueryLogic.KeysAnd(queryA), new canQueryLogic_0_8_11_canQueryLogic.KeysAnd(queryB) );
}

// Define types
var types$1 = {};
canReflect_1_16_7_canReflect.eachKey({
	IsEmptyOrNull: function(a, b){
		if( a == null && canReflect_1_16_7_canReflect.size(b) === 0 ) {
			return true;
		} else if( b == null && canReflect_1_16_7_canReflect.size(a) === 0 ) {
			return true;
		} else {
			return quickEqual(a, b);
		}
	},
	isEmptyOrSubset: function(a, b) {
		if( a == null && canReflect_1_16_7_canReflect.size(b) === 0 ) {
			return true;
		} else if( b == null && canReflect_1_16_7_canReflect.size(a) === 0 ) {
			return true;
		} else {
			return quickSubset(a, b);
		}
	},
	TemplateUrl: function(a, b) {
		return !!canFixture_3_0_0Pre_11_dataFromUrl(a, b);
	},
	StringIgnoreCase: function(a, b){
		return b && a ? a.toLowerCase() === b.toLowerCase() : b === a;
	},
	Ignore: function(){
		return true;
	}
}, function(compare, name){
	types$1[name] = makeComparatorType(compare);
});





var schema$1 = {
	identity: ["id"],
	keys: {
		url: types$1.TemplateUrl,
		fixture: types$1.Ignore,
		xhr: types$1.Ignore,
		type: types$1.StringIgnoreCase,
		method: types$1.StringIgnoreCase,
		helpers: types$1.Ignore,
		headers: types$1.IsEmptyOrNull,
		data: types$1.IsEmptyOrSubset
	}
};

var query = new canQueryLogic_0_8_11_canQueryLogic(schema$1);




var canFixture_3_0_0Pre_11_matches = {
	fixture: quickEqual,
	request: function(requestData, fixtureData) {
		return query.isMember({filter: fixtureData}, requestData);
	},
	matches: function(settings, fixture, exact) {
		if (exact) {
			return this.fixture(settings, fixture);
		} else {
			return this.request(settings, fixture)
		}
	},
	makeComparatorType: makeComparatorType
};

function getItems(data){
	if(Array.isArray(data)) {
		return data;
	} else {
		return data.data;
	}
}

function indexOf(records, identity, queryLogic ){
	var schema = canReflect_1_16_7_canReflect.getSchema( queryLogic );
	for(var i = 0 ; i < records.length; i++) {
		if(identity === canReflect_1_16_7_canReflect.getIdentity(records[i],  schema) ) {
			return i;
		}
	}
	return -1;
}

// update could remove all other records that would be in the set
function makeSimpleStore(baseConnection) {
    baseConnection.constructor = makeSimpleStore;
    var behavior = Object.create(baseConnection);

    // this stores data like:
    // queries: {[queryKey]: {queryKey, query, recordIds}}
    // records
    return canReflect_1_16_7_canReflect.assignMap(behavior, {
        getRecordFromParams: function(record) {
        	var id = canReflect_1_16_7_canReflect.getIdentity(record, this.queryLogic.schema);
        	return this.getRecord(id);
        },

        log: function(){
			this._log = true;
		},

        getSets: function(){
			return this.getQueries();
		},
		getQueries: function(){
			return Promise.resolve(this.getQueriesSync());
		},
		getQueriesSync: function(){
			return this.getQueryDataSync().map(function(queryData){
				return queryData.query;
			});
		},

        getListData: function(query){
        	query = query || {};
        	var listData = this.getListDataSync(query);
        	if(listData) {
        		return Promise.resolve(listData);
        	}
        	return Promise.reject({
        		title: "no data",
        		status: "404",
        		detail: "No data available for this query.\nAvailable queries: "+
        			JSON.stringify(this.getQueriesSync())
        	});
        },
		getPaginatedListDataSync: function(superSetQueryData) {
			var records = this.getAllRecords();
			var queryWithoutPagination = this.queryLogic.removePagination(superSetQueryData.query);
			var matchingSuperRecordsNoPagination = this.queryLogic.filterMembersAndGetCount(queryWithoutPagination, {}, records);
			var startIndex = indexOf(matchingSuperRecordsNoPagination.data, superSetQueryData.startIdentity, this.queryLogic);
			var matchingSuperRecords = matchingSuperRecordsNoPagination.data.slice(startIndex, startIndex+ this.queryLogic.count(superSetQueryData.query));
			return {
				count: matchingSuperRecordsNoPagination.data.length,
				data: matchingSuperRecords
			};
		},
        getListDataSync: function(query){
			var queryData = this.getQueryDataSync(),
				superSetQueryData,
				isPaginated = this.queryLogic.isPaginated(query);

			for(var i = 0; i < queryData.length; i++) {
        		var checkSet = queryData[i].query;
        		if( this.queryLogic.isSubset(query, checkSet) ) {
					superSetQueryData = queryData[i];
        		}
        	}
			var records = this.getAllRecords();

			if(isPaginated && this.queryLogic.isPaginated(superSetQueryData.query) ) {
				var result = this.getPaginatedListDataSync(superSetQueryData);
				return this.queryLogic.filterMembersAndGetCount(query, superSetQueryData.query, result.data);
			}

            var matching = this.queryLogic.filterMembersAndGetCount(query, {}, records);
            if(matching && matching.count) {
                return matching;
            }
            // now check if we have a query  for it
        	if(superSetQueryData) {
				return {count: 0, data: []};
			}
        },

        updateListData: function(data, query){
			var queryData = this.getQueryDataSync();
        	query = query || {};
            var clonedData = canReflect_1_16_7_canReflect.serialize(data);
        	var records = getItems(clonedData);
			// Update or create all records
			this.updateRecordsSync(records);
			var isPaginated = this.queryLogic.isPaginated(query);
			var identity = records.length ? canReflect_1_16_7_canReflect.getIdentity(records[0],  this.queryLogic.schema) : undefined;
			if(isPaginated) {
				// we are going to merge with some paginated set
				for(var i = 0; i < queryData.length; i++) {
	        		var checkSet = queryData[i].query;
					var union = this.queryLogic.union(checkSet, query);
					if( this.queryLogic.isDefinedAndHasMembers(union)  ) {
						var siblingRecords = this.getPaginatedListDataSync(queryData[i]);
						var res = this.queryLogic.unionMembers(checkSet, query, siblingRecords.data, records );
						identity = canReflect_1_16_7_canReflect.getIdentity(res[0],  this.queryLogic.schema);
						queryData[i] = {
							query: union,
							startIdentity: identity
						};
						this.updateQueryDataSync(queryData);
						return Promise.resolve();
					}
	        	}

				queryData.push({
					query: query,
					startIdentity: identity
				});
				this.updateQueryDataSync(queryData);
				return Promise.resolve();
			}

            // we need to remove everything that would have matched this query before, but that's not in data
            // but what if it's in another set -> we remove it
            var allRecords = this.getAllRecords();
            var curretMatching = this.queryLogic.filterMembers(query, allRecords);
            if(curretMatching.length) {
                var toBeDeleted = new Map();
                curretMatching.forEach(function(record){
                    toBeDeleted.set( canReflect_1_16_7_canReflect.getIdentity(record, this.queryLogic.schema), record );
                }, this);

                // remove what's in records
                records.forEach(function(record){
                    toBeDeleted.delete( canReflect_1_16_7_canReflect.getIdentity(record, this.queryLogic.schema) );
                }, this);

                this.destroyRecords( canReflect_1_16_7_canReflect.toArray(toBeDeleted.values() ) );
            }

            // the queries that are not consumed by query
            var allQueries = this.getQueryDataSync();
            var notSubsets = allQueries.filter(function(existingQueryData){
                    return !this.queryLogic.isSubset(existingQueryData.query, query);
                }, this),
                superSets = notSubsets.filter(function(existingQueryData){
                    return this.queryLogic.isSubset(query, existingQueryData.query);
                }, this);

			// would need to note the first record ... so we can do a query w/o pagination
			//

            // if there are sets that are parents of query
            if(superSets.length) {
                this.updateQueryDataSync(notSubsets);
            } else {
                this.updateQueryDataSync(notSubsets.concat([{
					query: query,
					startIdentity:identity
				}]));
            }

        	// setData.push({query: query, items: data});
        	return Promise.resolve();
        },

        getData: function(params){
        	var id = canReflect_1_16_7_canReflect.getIdentity(params, canReflect_1_16_7_canReflect.getSchema( this.queryLogic ) );
        	var res = this.getRecord(id);
        	if(res){
        		return Promise.resolve( res );
        	} else {
        		return Promise.reject({
        			title: "no data",
        			status: "404",
        			detail: "No record with matching identity ("+id+")."
        		});
        	}
        },
        createData: function(record){
			this.updateRecordsSync([record]);

			return Promise.resolve(canReflect_1_16_7_canReflect.assignMap({}, this.getRecordFromParams(record) ));
		},

		updateData: function(record){

			if(this.errorOnMissingRecord && !this.getRecordFromParams(record)) {
				var id = canReflect_1_16_7_canReflect.getIdentity(record, this.queryLogic.schema);
				return Promise.reject({
					title: "no data",
					status: "404",
					detail: "No record with matching identity ("+id+")."
				});
			}

			this.updateRecordsSync([record]);

			return Promise.resolve(canReflect_1_16_7_canReflect.assignMap({},this.getRecordFromParams(record) ));
		},

		destroyData: function(record){
			var id = canReflect_1_16_7_canReflect.getIdentity(record,  this.queryLogic.schema),
				savedRecord = this.getRecordFromParams(record);

			if(this.errorOnMissingRecord && !savedRecord) {

				return Promise.reject({
					title: "no data",
					status: "404",
					detail: "No record with matching identity ("+id+")."
				});
			}
            this.destroyRecords([record]);
			return Promise.resolve(canReflect_1_16_7_canReflect.assignMap({},savedRecord || record));
		}
    });
}

var canMemoryStore_1_0_0_makeSimpleStore = makeSimpleStore;

var canMemoryStore_1_0_0_canMemoryStore = canNamespace_1_0_0_canNamespace.memoryStore = function memoryStore(baseConnection){
    baseConnection.constructor = memoryStore;
    var behavior = Object.create(canMemoryStore_1_0_0_makeSimpleStore(baseConnection));

    canReflect_1_16_7_canReflect.assignMap(behavior, {
		clear: function(){
			this._instances = {};
			this._queries = [];
		},
		_queryData: [],
		updateQueryDataSync: function(queries){
			this._queryData = queries;
		},
		getQueryDataSync: function(){
			return this._queryData;
		},

		_instances: {},
		getRecord: function(id){
			return this._instances[id];
		},
		getAllRecords: function(){
			var records = [];
			for(var id in this._instances) {
				records.push(this._instances[id]);
			}
			return records;
		},
		destroyRecords: function(records) {
			canReflect_1_16_7_canReflect.eachIndex(records, function(record){
				var id = canReflect_1_16_7_canReflect.getIdentity(record, this.queryLogic.schema);
				delete this._instances[id];
			}, this);
		},
		updateRecordsSync: function(records){
			records.forEach(function(record){
				var id = canReflect_1_16_7_canReflect.getIdentity(record, this.queryLogic.schema);
				this._instances[id] = record;
			},this);
		},

		// ## External interface

		/**
		 * @function can-memory-store.getQueries getQueries
		 * @parent can-memory-store.data-methods
		 *
		 * Returns the queries contained within the cache.
		 *
		 * @signature `connection.getQueries()`
		 *
		 *   Returns the queries added by [can-memory-store.updateListData].
		 *
		 *   @return {Promise<Array<can-query-logic/query>>} A promise that resolves to the list of queries.
		 *
		 * @body
		 *
		 * ## Use
		 *
		 * ```js
		 * connection.getSets() //-> Promise( [{type: "completed"},{user: 5}] )
		 * ```
		 *
		 */

		/**
		 * @function can-memory-store.clear clear
		 * @parent can-memory-store.data-methods
		 *
		 * Resets the memory store so it contains nothing.
		 *
		 * @signature `connection.clear()`
		 *
		 *   Removes all instances and lists being stored in memory.
		 *
		 *   ```js
		 *   memoryStore({queryLogic: new QueryLogic()});
		 *
		 *   cacheConnection.updateInstance({id: 5, name: "justin"});
		 *
		 *   cacheConnection.getData({id: 5}).then(function(data){
		 *     data //-> {id: 5, name: "justin"}
		 *     cacheConnection.clear();
		 *     cacheConnection.getData({id: 5}).catch(function(err){
		 *       err -> {message: "no data", error: 404}
		 *     });
		 *   });
		 *   ```
		 *
		 */

		/**
		 * @function can-memory-store.getListData getListData
		 * @parent can-memory-store.data-methods
		 *
		 * Gets a list of data from the memory store.
		 *
		 * @signature `connection.getListData(query)`
		 *
		 *   Goes through each query add by [can-memory-store.updateListData]. If
		 *   `query` is a subset, uses [can-connect/base/base.queryLogic] to get the data for the requested `query`.
		 *
		 *   @param {can-query-logic/query} query An object that represents the data to load.
		 *
		 *   @return {Promise<can-connect.listData>} A promise that resolves if `query` is a subset of
		 *   some data added by [can-memory-store.updateListData].  If it is not,
		 *   the promise is rejected.
		 */

		/**
		 * @function can-connect/data/memory-cache.getListDataSync getListDataSync
		 * @parent can-connect/data/memory-cache.data-methods
		 *
		 * Synchronously gets a query of data from the memory cache.
		 *
		 * @signature `connection.getListDataSync(query)`
		 * @hide
		 */


		/**
		 * @function can-memory-store.updateListData updateListData
		 * @parent can-memory-store.data-methods
		 *
		 * Saves a query of data in the cache.
		 *
		 * @signature `connection.updateListData(listData, query)`
		 *
		 *   Tries to merge this query of data with any other saved queries of data. If
		 *   unable to merge this data, saves the query by itself.
		 *
		 *   @param {can-connect.listData} listData The data that belongs to `query`.
		 *   @param {can-query-logic/query} query The query `listData` belongs to.
		 *   @return {Promise} Promise resolves if and when the data has been successfully saved.
		 */


		/**
		 * @function can-memory-store.getData getData
		 * @parent can-memory-store.data-methods
		 *
		 * Get an instance's data from the memory cache.
		 *
		 * @signature `connection.getData(params)`
		 *
		 *   Looks in the instance store for the requested instance.
		 *
		 *   @param {Object} params An object that should have the [conenction.id] of the element
		 *   being retrieved.
		 *
		 *   @return {Promise} A promise that resolves to the item if the memory cache has this item.
		 *   If the memory cache does not have this item, it rejects the promise.
		 */




		/**
		 * @function can-memory-store.createData createData
		 * @parent can-memory-store.data-methods
		 *
		 * Called when an instance is created and should be added to cache.
		 *
		 * @signature `connection.createData(record)`
		 *
		 *   Adds `record` to the stored list of instances. Then, goes
		 *   through every query and adds record the queries it belongs to.
		 */


		/**
		 * @function can-memory-store.updateData updateData
		 * @parent can-memory-store.data-methods
		 *
		 * Called when an instance is updated.
		 *
		 * @signature `connection.updateData(record)`
		 *
		 *   Overwrites the stored instance with the new record. Then, goes
		 *   through every query and adds or removes the instance if it belongs or not.
		 */

		/**
		 * @function can-memory-store.destroyData destroyData
		 * @parent can-memory-store.data-methods
		 *
		 * Called when an instance should be removed from the cache.
		 *
		 * @signature `connection.destroyData(record)`
		 *
		 *   Goes through each query of data and removes any data that matches
		 *   `record`'s [can-connect/base/base.id]. Finally removes this from the instance store.
		 */

	});

	return behavior;

};

// Returns a function that calls the method on a connection.
// Wires up fixture signature to a connection signature.
var connectToConnection = function(method, convert){
	return function(req, res){
		// have to get data from
		this.connection[method]( convert.call(this, req.data) ).then(function(data){
			res(data);
		}, function(err){
			res(parseInt(err.status, 10), err);
		});
	};
};
// Returns a new makeItems function for a different baseItems;
var makeMakeItems = function(baseItems, idProp){
	return function () {
		// clone baseItems
		var items = [],
			maxId = 0;
		baseItems.forEach(function(item){
			items.push(canReflect_1_16_7_canReflect.serialize(item) );
			maxId = Math.max(item[idProp], maxId) ;
		});

		return {
			maxId: maxId,
			items: items
		};
	};
};

var stringToAny = function(str){
	switch(str) {
		case "NaN":
		case "Infinity":
			return +str;
		case "null":
			return null;
		case "undefined":
			return undefined;
		case "true":
		case "false":
			return str === "true";
		default:
			var val = +str;
			if(!isNaN(val)) {
				return val;
			} else {
				return str;
			}
	}
};

// A store constructor function
var Store = function(connection, makeItems, idProp){
	var schema = connection.queryLogic.schema;
	var identityKey = schema.identity[0],
		keys = schema.keys;

	if(!keys || !keys[identityKey]) {
		console.warn("No type specified for identity key. Going to convert strings to reasonable type.");
	}

	this.connection = connection;
	this.makeItems = makeItems;
	this.idProp = idProp;
	this.reset();
	// we have to make sure the methods can be called without their context
	for(var method in Store.prototype) {
		this[method] = this[method].bind(this);
	}
};

var doNotConvert = function(v){ return v; };

function typeConvert(data){
	var schema = this.connection.queryLogic.schema;
	var identityKey = schema.identity[0],
		keys = schema.keys;
	if(!keys || !keys[identityKey]) {
		keys = {};
		keys[identityKey] = function(value){
			return typeof value === "string" ? stringToAny(value) : value;
		};
	}
		// this probably needs to be recursive, but this is ok for now
	var copy = {};
	canReflect_1_16_7_canReflect.eachKey(data, function(value, key){
		if(keys[key]) {
			copy[key] = canReflect_1_16_7_canReflect.convert(value, keys[key]);
		} else {
			copy[key] = value;
		}
	});
	// clone the data

	return copy;

}

canReflect_1_16_7_canReflect.assignMap(Store.prototype,{
	getListData: connectToConnection("getListData",doNotConvert),
	getData: connectToConnection( "getData",typeConvert),

	// used
	createData: function(req, res){
		var idProp = this.idProp;
		// add an id
		req.data[idProp] = ++this.maxId;

		this.connection.createData( typeConvert.call(this,req.data) ).then(function(data){
			res(data);
		}, function(err){
			res(403, err);
		});
	},
	createInstance: function(record){
		var idProp = this.idProp;
		if(!(idProp in record)) {
			record[idProp] = ++this.maxId;
		}
		return this.connection.createData( record );
	},
	updateData: connectToConnection("updateData",typeConvert),
	updateInstance: function(record) {
		return this.connection.updateData(record);
	},
	destroyInstance: function(record) {
		return this.connection.destroyData(record);
	},
	destroyData: connectToConnection("destroyData",typeConvert),
	reset: function(newItems){
		if(newItems) {
			this.makeItems = makeMakeItems(newItems, this.idProp);
		}
		var itemData =  this.makeItems();
		this.maxId = itemData.maxId;
		this.connection.updateListData(itemData.items, {});
	},
	get: function (params) {
		var id = this.connection.queryLogic.memberIdentity(params);
		return this.connection.getRecord(id);
	},
	getList: function(set){
		return this.connection.getListDataSync(set);
	}
});

function looksLikeAQueryLogic(obj){
	return obj && ("identityKeys" in obj);
}

// ## fixture.store
// Make a store of objects to use when making requests against fixtures.
Store.make = function (count, make, queryLogic) {
	/*jshint eqeqeq:false */


	// Figure out makeItems which populates data
	var makeItems,
		idProp;
	if(typeof count === "number") {
		if(!queryLogic) {
			queryLogic = new canQueryLogic_0_8_11_canQueryLogic({});
		} else if(!looksLikeAQueryLogic(queryLogic)) {
			queryLogic = new canQueryLogic_0_8_11_canQueryLogic(queryLogic);
		}
		idProp = queryLogic.identityKeys()[0] || "id";
		makeItems = function () {
			var items = [];
			var maxId = 0;
			for (var i = 0; i < (count); i++) {
				//call back provided make
				var item = make(i, items);

				if (!item[idProp]) {
					item[idProp] = i;
				}
				maxId = Math.max(item[idProp] , maxId);
				items.push(item);
			}

			return {
				maxId: maxId,
				items: items
			};
		};
	} else if(Array.isArray(count)){
		queryLogic = make;
		if(!queryLogic) {
			queryLogic = new canQueryLogic_0_8_11_canQueryLogic({});
		} else if(!looksLikeAQueryLogic(queryLogic)) {
			queryLogic = new canQueryLogic_0_8_11_canQueryLogic(queryLogic);
		}
		idProp = queryLogic.identityKeys()[0] || "id";
		makeItems = makeMakeItems(count, idProp);
	}

	var connection = canMemoryStore_1_0_0_canMemoryStore({
		queryLogic: queryLogic,
		errorOnMissingRecord: true
	});

	return new Store(connection, makeItems, idProp);
};

var canFixture_3_0_0Pre_11_store = Store;

var canFixture_3_0_0Pre_11_core = createCommonjsModule(function (module, exports) {
// Adds









var fixtures = [];
exports.fixtures = fixtures;

function isStoreLike (fixture) {
	return fixture && (fixture.getData || fixture.getListData);
}

var methodMapping = {
	item: {
		'GET': 'getData',
		'PUT': 'updateData',
		'DELETE': 'destroyData',
	},
	list: {
		'GET': 'getListData',
		'POST': 'createData'
	}
};

function getMethodAndPath (route) {
	// Match URL if it has GET, POST, PUT, DELETE or PATCH.
	var matches = route.match(/(GET|POST|PUT|DELETE|PATCH) (.+)/i);
	if (!matches) {
		return [undefined, route];
	}
	var method = matches[1];
	var path = matches[2];
	return [method, path];
}

function inferIdProp (url) {
	var wrappedInBraces = /\{(.*)\}/;
	var matches = url.match(wrappedInBraces);
	var isUniqueMatch = matches && matches.length === 2;
	if (isUniqueMatch) {
		return matches[1];
	}
}

function getItemAndListUrls (url, idProp) {
	idProp = idProp || inferIdProp(url);
	if (!idProp) {
		return [undefined, url];
	}
	var itemRegex = new RegExp('\\/\\{' + idProp+"\\}.*" );
	var rootIsItemUrl = itemRegex.test(url);
	var listUrl = rootIsItemUrl ? url.replace(itemRegex, "") : url;
	var itemUrl = rootIsItemUrl ? url : (url.trim() + "/{" + idProp + "}");
	return [itemUrl, listUrl];
}

function addStoreFixture (root, store) {
	var settings = {};
	var typeAndUrl = getMethodAndPath(root);
	var type = typeAndUrl[0];
	var url = typeAndUrl[1];

	var itemAndListUrls = getItemAndListUrls(url, store.idProp);
	var itemUrl = itemAndListUrls[0];
	var listUrl = itemAndListUrls[1];

	if (type) {
		var warning = [
			'fixture("' + root + '", fixture) must use a store method, not a store directly.',
		];
		if (itemUrl) {
			var itemAction = methodMapping.item[type];
			if (itemAction) {
				settings[type + ' ' + itemUrl] = store[itemAction];
				var itemWarning = 'Replace with fixture("' + type + ' ' + itemUrl + '", fixture.' + itemAction + ') for items.';
				warning.push(itemWarning);
			}
		}
		var listAction = methodMapping.list[type];
		if (listAction) {
			settings[type + ' ' + listUrl] = store[listAction];
			var listWarning = 'Replace with fixture("' + type + ' ' + listUrl + '", fixture.' + listAction + ') for lists.';
			warning.push(listWarning);
		}
		var message = warning.join(' ');
		dev.warn(message);
	} else {
		var itemMapping = methodMapping.item;
		for (var itemMethod in itemMapping) {
			var storeItemMethod = itemMapping[itemMethod];
			settings[itemMethod + ' ' + itemUrl] = store[storeItemMethod];
		}
		var listMapping = methodMapping.list;
		for (var listMethod in listMapping) {
			var storeListMethod = listMapping[listMethod];
			settings[listMethod + ' ' + listUrl] = store[storeListMethod];
		}
	}

	return settings;
}

function getSettingsFromString (route) {
	var typeAndUrl = getMethodAndPath(route);
	var type = typeAndUrl[0];
	var url = typeAndUrl[1];
	if (type) {
		return {
			type: type,
			url: url
		};
	}
	return {
		url: url
	};
}

// Check if the same fixture was previously added, if so, we remove it
// from our array of fixture overwrites.
function upsertFixture (fixtureList, settings, fixture) {
	var index = exports.index(settings, true);
	if (index > -1) {
		fixtures.splice(index, 1);
	}
	if (fixture == null) {
		return;
	}
	if(typeof fixture === "object") {
		var data = fixture;
		fixture = function(){
			return data;
		};
	}
	settings.fixture = fixture;
	fixtures.unshift(settings);
}

// Adds a fixture to the list of fixtures.
exports.add = function (settings, fixture) {
	// If a fixture isn't provided, we assume that settings is
	// an array of fixtures, and we should iterate over it, and set up
	// the new fixtures.
	if (fixture === undefined) {
		canReflect_1_16_7_canReflect.eachKey(settings, function (fixture, url) {
			exports.add(url, fixture);
		});
		return;
	}

	// When a fixture is passed a store like:
	// `fixture("/things/{id}", store)`
	if (isStoreLike(fixture)) {
		settings = addStoreFixture(settings, fixture);
		exports.add(settings);
		return;
	}

	if (typeof settings === 'string') {
		settings = getSettingsFromString(settings);
	}
	upsertFixture(fixtures, settings, fixture);
};

var $fixture = exports.add;
$fixture.on = true;
$fixture.delay =10;

function FixtureResponse(fixture, response){
	this.statusCode= response[0];
	this.responseBody= response[1];
	this.headers= response[2];
	this.statusText= response[3];
	this.fixture= fixture;
}

// Calls a dynamic fixture and calls `cb` with the response data.
exports.callDynamicFixture = function(xhrSettings, fixtureSettings, cb){
	// this is for legacy.  In the future, people should get it from fixtureSettings probably.
	xhrSettings.data = fixtureSettings.data;

	var response = function(){
		var res = exports.extractResponse.apply(xhrSettings, arguments);
		//!steal-remove-start
		canLog_1_0_0_canLog.log("can-fixture: " + xhrSettings.type.toUpperCase() + " " + xhrSettings.url+" ",xhrSettings.data," => ",new FixtureResponse(fixtureSettings.fixture,res));
		//!steal-remove-end
		return cb.apply(this, res);
	};
	var callFixture = function () {
		// fall the fixture
		var result = fixtureSettings.fixture(xhrSettings, response, xhrSettings.headers, fixtureSettings);

		if (result !== undefined) {
			// Resolve with fixture results
			response(200, result );
		}
	};

	if(!xhrSettings.async) {
		callFixture();
		return null;
	} else {
		return setTimeout(callFixture, $fixture.delay);
	}
};

exports.index = function (settings, exact) {
	for (var i = 0; i < fixtures.length; i++) {
		if (canFixture_3_0_0Pre_11_matches.matches(settings, fixtures[i], exact)) {
			return i;
		}
	}
	return -1;
};
exports.get = function(xhrSettings) {
	if ( !$fixture.on ) {
		return;
	}
	// First try an exact match
	var index = exports.index(xhrSettings, true);

	// If that doesn't work, try a looser match.
	if(index === -1) {
		index = exports.index(xhrSettings, false);
	}

	var fixtureSettings = index >=0 ? canReflect_1_16_7_canReflect.assignMap({},fixtures[index]) : undefined;
	if(fixtureSettings) {
		var url = fixtureSettings.fixture,
			data = canFixture_3_0_0Pre_11_dataFromUrl(fixtureSettings.url, xhrSettings.url);
		if(typeof fixtureSettings.fixture === "string") {
			// check that we might have a replacement

			// here we could read data from first url and translate into next
			if (data) {
				// Template static fixture URLs
				url = sub(url, data);
			}

			// Override the AJAX settings, changing the URL to the fixture file,
			// removing the data, and changing the type to GET.
			fixtureSettings.url = url;
			fixtureSettings.data = null;
			fixtureSettings.type = "GET";
			if (!fixtureSettings.error) {
				// If no error handling is provided, we provide one and throw an
				// error.
				fixtureSettings.error = function (xhr, error$$1, message) {
					throw "fixtures.js Error " + error$$1 + " " + message;
				};
			}

		} else if (canReflect_1_16_7_canReflect.isPlainObject(xhrSettings.data) || xhrSettings.data == null) {
			var xhrData = canReflect_1_16_7_canReflect.assignMap({}, xhrSettings.data || {});
			fixtureSettings.data = canReflect_1_16_7_canReflect.assignMap(xhrData, data);

		} else {
			fixtureSettings.data = xhrSettings.data;
		}
	}

	return fixtureSettings;
};

exports.matches = canFixture_3_0_0Pre_11_matches;




// A helper function that takes what's called with response
// and moves some common args around to make it easier to call
exports.extractResponse = function (status, response, headers, statusText) {
	// if we get response(RESPONSE, HEADERS)
	if (typeof status !== "number") {
		headers = response;
		response = status;
		status = 200;
	}
	// if we get response(200, RESPONSE, STATUS_TEXT)
	if (typeof headers === "string") {
		statusText = headers;
		headers = {};
	}
	return [status, response, headers, statusText];
};
});
var canFixture_3_0_0Pre_11_core_1 = canFixture_3_0_0Pre_11_core.fixtures;
var canFixture_3_0_0Pre_11_core_2 = canFixture_3_0_0Pre_11_core.add;
var canFixture_3_0_0Pre_11_core_3 = canFixture_3_0_0Pre_11_core.callDynamicFixture;
var canFixture_3_0_0Pre_11_core_4 = canFixture_3_0_0Pre_11_core.index;
var canFixture_3_0_0Pre_11_core_5 = canFixture_3_0_0Pre_11_core.get;
var canFixture_3_0_0Pre_11_core_6 = canFixture_3_0_0Pre_11_core.matches;
var canFixture_3_0_0Pre_11_core_7 = canFixture_3_0_0Pre_11_core.extractResponse;

/**
 * @module {function} can-deparam can-deparam
 * @parent can-routing
 * @collection can-infrastructure
 * @package ./package.json
 * @description Deserialize a query string into an array or object.
 * @signature `deparam(params)`
 *
 * @param {String} params A form-urlencoded string of key-value pairs.
 * @param {function} [valueDeserializer] A function that decodes the string values. For example, using
 * [can-string-to-any] will convert `"null"` to `null` like:
 *
 *   ```js
 *   import stringToAny from "can-string-to-any";
 *   deparam("value=null", stringToAny) //-> {value: null}
 *   ```
 * @return {Object} The params formatted into an object
 *
 * Takes a string of name value pairs and returns a Object literal that represents those params.
 *
 * ```js
 * var deparam = require("can-deparam");
 *
 * console.log(JSON.stringify(deparam("?foo=bar&number=1234"))); // -> '{"foo" : "bar", "number": 1234}'
 * console.log(JSON.stringify(deparam("#foo[]=bar&foo[]=baz"))); // -> '{"foo" : ["bar", "baz"]}'
 * console.log(JSON.stringify(deparam("foo=bar%20%26%20baz"))); // -> '{"foo" : "bar & baz"}'
 * ```
 * @body
 *
 * ## Try it
 *
 * Use this JS Bin to play around with this package:
 *
 * <a class="jsbin-embed" href="https://jsbin.com/mobimok/3/embed?js,console">can-deparam on jsbin.com</a>
 * <script src="https://static.jsbin.com/js/embed.min.js?4.0.4"></script>
 */
var digitTest = /^\d+$/,
	keyBreaker = /([^\[\]]+)|(\[\])/g,
	paramTest = /([^?#]*)(#.*)?$/,
	entityRegex = /%([^0-9a-f][0-9a-f]|[0-9a-f][^0-9a-f]|[^0-9a-f][^0-9a-f])/i,
	prep = function (str) {
		str = str.replace(/\+/g, ' ');

		try {
			return decodeURIComponent(str);
		}
		catch (e) {
			return decodeURIComponent(str.replace(entityRegex, function(match, hex) {
				return '%25' + hex;
			}));
		}
	};

function isArrayLikeName(name) {
	return digitTest.test(name) || name === '[]';
}


function idenity(value){ return value; }

var canDeparam_1_1_1_canDeparam = canNamespace_1_0_0_canNamespace.deparam = function (params, valueDeserializer) {
	valueDeserializer = valueDeserializer || idenity;
	var data = {}, pairs, lastPart;
	if (params && paramTest.test(params)) {
		pairs = params.split('&');
		pairs.forEach(function (pair) {
			var parts = pair.split('='),
				key = prep(parts.shift()),
				value = prep(parts.join('=')),
				current = data;
			if (key) {
				parts = key.match(keyBreaker);
				for (var j = 0, l = parts.length - 1; j < l; j++) {
					var currentName = parts[j],
						nextName = parts[j + 1],
						currentIsArray = isArrayLikeName(currentName) && current instanceof Array;
					if (!current[currentName]) {
						if(currentIsArray) {
							current.push( isArrayLikeName(nextName) ? [] : {} );
						} else {
							// If what we are pointing to looks like an `array`
							current[currentName] = isArrayLikeName(nextName) ? [] : {};
						}

					}
					if(currentIsArray) {
						current = current[current.length - 1];
					} else {
						current = current[currentName];
					}

				}
				lastPart = parts.pop();
				if ( isArrayLikeName(lastPart) ) {
					current.push(valueDeserializer(value));
				} else {
					current[lastPart] = valueDeserializer(value);
				}
			}
		});
	}
	return data;
};

/* global require, window, global */
/* global setTimeout, clearTimeout, XMLHttpRequest */

// This overwrites the default XHR with a mock XHR object.
// The mock XHR object's `.send` method is able to
// call the fixture callbacks or create a real XHR request
// and then respond normally.





// Save the real XHR object as XHR
var XHR = XMLHttpRequest,
// Get a global reference.
	GLOBAL = typeof commonjsGlobal !== "undefined"? commonjsGlobal : window;

// Figure out props and events on XHR object
// but start with some defaults
var props$2 = [
	"type", "url", "async", "response", "responseText", "responseType",
	"responseXML", "responseURL", "status", "statusText", "readyState"
];
var events = ["abort", "error", "load", "loadend", "loadstart",  "progress", "readystatechange"];
(function(){
	var x = new XHR();
	for(var prop in x) {
		if(prop.indexOf("on") === 0) {
			if (events.indexOf(prop.substr(2)) === -1) {
				events.push(prop.substr(2));
			}
		} else if (props$2.indexOf(prop) === -1 && typeof x[prop] !== 'function') {
			props$2.push(prop);
		}
	}
})();
// DEFINE HELPERS

// Call all of an event for an XHR object
function callEvents(xhr, ev) {
	var evs = xhr.__events[ev] || [], fn;
	for(var i = 0, len = evs.length; i < len; i++) {
		fn = evs[i];
		fn.call(xhr);
	}
}

GLOBAL.XMLHttpRequest = function() {
	var mockXHR = this;
	var realXHR = new XHR();

	// store real xhr on mockXHR
	this._xhr = realXHR;

	// create other properties needed by prototype functions
	this._requestHeaders = {};
	this.__events = {};

	// wire up events to forward from real xhr to fake xhr
	events.forEach(function(eventName) {
		realXHR["on" + eventName] = function() {
			callEvents(mockXHR, eventName);
			if(mockXHR["on"+eventName]) {
				return mockXHR["on"+eventName].apply(mockXHR, arguments);
			}
		};
	});

	// The way code detects if the browser supports onload is to check
	// if a new XHR object has the onload property, so setting it to null
	// passes that check.
	this.onload = null;
};
GLOBAL.XMLHttpRequest._XHR = XHR;

// Methods on the mock XHR:
canReflect_1_16_7_canReflect.assignMap(XMLHttpRequest.prototype,{
	setRequestHeader: function(name, value){
		this._requestHeaders[name] = value;
	},
	open: function(type, url, async){
		this.type = type;
		this.url = url;
		this.async = async === false ? false : true;
	},
	getAllResponseHeaders: function(){
		return this._xhr.getAllResponseHeaders.apply(this._xhr, arguments);
	},
	addEventListener: function(ev, fn){
		var evs = this.__events[ev] = this.__events[ev] || [];
		evs.push(fn);
	},
	removeEventListener: function(ev, fn){
		var evs = this.__events[ev] = this.__events[ev] || [];
		var idx = evs.indexOf(fn);
		if(idx >= 0) {
			evs.splice(idx, 1);
		}
	},
	setDisableHeaderCheck: function(val){
		this._disableHeaderCheck = !!val;
	},
	getResponseHeader: function(key){
		return this._xhr.getResponseHeader(key);
	},
	abort: function() {
		var xhr = this._xhr;

		// If we are aborting a delayed fixture we have to make the fake
		// steps that are expected for `abort` to
		if(this.timeoutId !== undefined) {
			clearTimeout(this.timeoutId);
			xhr.open(this.type, this.url, this.async === false ? false : true);
			xhr.send();
		}

		return xhr.abort();
	},
	// This needs to compile the information necessary to see if
	// there is a corresponding fixture.
	// If there isn't a fixture, this should create a real XHR object
	// linked to the mock XHR instance and make a data request.
	// If there is a fixture, depending on the type of fixture the following happens:
	// - dynamic fixtures - call the dynamic fixture, use the result to update the
	//   mock XHR object and trigger its callbacks.
	// - redirect fixtures - create a real XHR linked to the mock XHR for the new url.
	send: function(data) {
		// derive the XHR settings object from the XHR object
		var type = this.type.toLowerCase() || 'get';
		var xhrSettings = {
			url: this.url,
			data: data,
			headers: this._requestHeaders,
			type: type,
			method: type,
			async: this.async,
			xhr: this
		};
		// if get or delete, the url should not include the querystring.
		// the querystring should be the data.
		if(!xhrSettings.data && xhrSettings.type === "get" || xhrSettings.type === "delete") {
			xhrSettings.data = canDeparam_1_1_1_canDeparam( xhrSettings.url.split("?")[1] );
			xhrSettings.url = xhrSettings.url.split("?")[0];
		}

		// Try to convert the request body to POJOs.
		if(typeof xhrSettings.data === "string") {
			try {
				xhrSettings.data = JSON.parse(xhrSettings.data);
			} catch(e) {
				xhrSettings.data = canDeparam_1_1_1_canDeparam( xhrSettings.data );
			}
		}

		// See if the XHR settings match a fixture.
		var fixtureSettings = canFixture_3_0_0Pre_11_core.get(xhrSettings);
		var mockXHR = this;

		// If a dynamic fixture is being used, we call the dynamic fixture function and then
		// copy the response back onto the `mockXHR` in the right places.
		if(fixtureSettings && typeof fixtureSettings.fixture === "function") {

			this.timeoutId = canFixture_3_0_0Pre_11_core.callDynamicFixture(xhrSettings, fixtureSettings, function(status, body, headers, statusText){
				body = typeof body === "string" ? body :  JSON.stringify(body);

				// we are no longer using the real XHR
				// set it to an object so that props like readyState can be set
				mockXHR._xhr = {
					open: function(){},
					send: function() {},
					abort: function(){},
					getResponseHeader: function(){}
				};

				canReflect_1_16_7_canReflect.assignMap(mockXHR, {
					readyState: 4,
					status: status
				});

				var success = (status >= 200 && status < 300 || status === 304);
				if ( success ) {
					canReflect_1_16_7_canReflect.assignMap(mockXHR,{
						statusText: statusText || "OK",
						responseText: body
					});
				} else {
					canReflect_1_16_7_canReflect.assignMap(mockXHR,{
						statusText: statusText || "error",
						responseText: body
					});
				}

				mockXHR.getAllResponseHeaders = function() {
					var ret = [];
					canReflect_1_16_7_canReflect.eachKey(headers || {}, function(value, name) {
						Array.prototype.push.apply(ret, [name, ': ', value, '\r\n']);
					});
					return ret.join('');
				};

				if(mockXHR.onreadystatechange) {
					mockXHR.onreadystatechange({ target: mockXHR });
				}

				// fire progress events
				callEvents(mockXHR, "progress");
				if(mockXHR.onprogress) {
					mockXHR.onprogress();
				}

				callEvents(mockXHR, "load");
				if(mockXHR.onload) {
					mockXHR.onload();
				}

				callEvents(mockXHR, "loadend");
				if(mockXHR.onloadend) {
					mockXHR.onloadend();
				}
			});

			return;
		}
		// At this point there is either not a fixture or a redirect fixture.
		// Either way we are doing a request.
		var makeRequest = function() {
			mockXHR._xhr.open(mockXHR._xhr.type, mockXHR._xhr.url, mockXHR._xhr.async);
			if(mockXHR._requestHeaders) {
				Object.keys(mockXHR._requestHeaders).forEach(function(key) {
					mockXHR._xhr.setRequestHeader(key, mockXHR._requestHeaders[key]);
				});
			}
			return mockXHR._xhr.send(data);
		};

		if(fixtureSettings && typeof fixtureSettings.fixture === "number") {
			canLog_1_0_0_canLog.log("can-fixture: "+xhrSettings.url+" => delay " + fixtureSettings.fixture+"ms");
			this.timeoutId = setTimeout(makeRequest, fixtureSettings.fixture);
			return;
		}

		// if we do have a fixture, update the real XHR object.
		if(fixtureSettings) {
			canLog_1_0_0_canLog.log("can-fixture: "+xhrSettings.url+" => " + fixtureSettings.url);
			canReflect_1_16_7_canReflect.assignMap(mockXHR, fixtureSettings);
		}

		// Make the request.
		return makeRequest();
	}
});

// when props of mockXHR are get/set, return the prop from the real XHR
props$2.forEach(function(prop) {
	Object.defineProperty(XMLHttpRequest.prototype, prop, {
		get: function(){
			return this._xhr[prop];
		},
		set: function(newVal){
			try {
				this._xhr[prop] = newVal;
			} catch(e) {}
		}
	});
});

var fixture = canFixture_3_0_0Pre_11_core.add;




// HELPERS START

var noop = function(){};

canReflect_1_16_7_canReflect.assignMap(fixture, {
	rand: function randomize (arr, min, max) {
		if (typeof arr === 'number') {
			if (typeof min === 'number') {
				return arr + Math.floor(Math.random() * (min - arr+1));
			} else {
				return Math.floor(Math.random() * (arr+1));
			}

		}
		// clone the array because we will remove items from it.
		var choices = arr.slice(0);

		// get a random set
		if (min === undefined) {
			min = 1;
			max = choices.length;
		} else if(max === undefined){
			max = min;
		}
		// get a random selection of arr
		var result = [];

		// set max
		//random max
		var selectedCount = min + Math.round(randomize(max - min));
		for (var i = 0; i < selectedCount; i++) {
			var selectedIndex = randomize(choices.length - 1),
				selected = choices.splice(selectedIndex, 1)[0];
			result.push(selected);
		}
		return result;
	},
	xhr: function (xhr) {
		return canReflect_1_16_7_canReflect.assignMap({}, {
			abort: noop,
			getAllResponseHeaders: function () {
				return "";
			},
			getResponseHeader: function () {
				return "";
			},
			open: noop,
			overrideMimeType: noop,
			readyState: 4,
			responseText: "",
			responseXML: null,
			send: noop,
			setRequestHeader: noop,
			status: 200,
			statusText: "OK"
		}, xhr);
	},
	store: canFixture_3_0_0Pre_11_store.make,
	fixtures: canFixture_3_0_0Pre_11_core.fixtures
});

if(typeof window !== "undefined" && typeof commonjsRequire.resolve !== "function") {
	window.fixture = fixture;
}


var canFixture_3_0_0Pre_11_fixture = canNamespace_1_0_0_canNamespace.fixture = fixture;

var assign$1 = canReflect_1_16_7_canReflect.assignMap;

/**
 * @module {function} can-connect/helpers/weak-reference-map WeakReferenceMap
 * @parent can-connect.modules
 *
 * Provides a map that only contains keys that are referenced.
 *
 * @signature `new WeakReferenceMap()`
 *
 *   Creates a new weak reference map.
 *
 * @body
 *
 * ## Use
 *
 * ```
 * var WeakReferenceMap = require("can-connect/helpers/weak-reference-map");
 * var wrm = new WeakReferenceMap();
 * var task1 = {id: 1, name: "do dishes"};
 *
 * wrm.addReference("1", task1);
 * wrm.has("1") //-> true
 * wrm.addReference("1", task1);
 * wrm.has("1") //-> true
 * wrm.deleteReference("1");
 * wrm.has("1") //-> true
 * wrm.deleteReference("1");
 * wrm.has("1") //-> false
 * ```
 */

var WeakReferenceMap = function(){
	this.set = {};
};

// if weakmap, we can add and never worry ...
// otherwise, we need to have a count ...

assign$1(WeakReferenceMap.prototype,
/**
 * @prototype
 */
	{
	/**
	 * @function can-connect/helpers/weak-reference-map.prototype.has has
	 * @signature `weakReferenceMap.has(key)`
	 *
	 *   Returns if key is in the set.
	 *
	 *   @param  {String} key A key to look for.
	 *   @return {Boolean} If the key exists.
	 */
	has: function(key){
		return !!this.set[key];
	},
	/**
	 * @function can-connect/helpers/weak-reference-map.prototype.addReference addReference
	 * @signature `WeakReferenceMap.addReference(key, item)`
	 *
	 *   Adds a reference to item as key and increments the reference count. This should be called
	 *   when a value should be managed by something, typically the [can-connect/constructor/store/store].
	 *
	 *   @param  {String} key The key of the item in the store.
	 */
	addReference: function(key, item, referenceCount){
		// !steal-remove-start
		if (typeof key === 'undefined'){
			throw new Error("can-connect: You must provide a key to store a value in a WeakReferenceMap");
		}
		// !steal-remove-end
		var data = this.set[key];
		if(!data) {
			data = this.set[key] = {
				item: item,
				referenceCount: 0,
				key: key
			};
		}
		data.referenceCount += (referenceCount || 1);
	},
	referenceCount: function(key) {
		var data = this.set[key];
		if(data) {
			return data.referenceCount;
		}
	},
	/**
	 * @function can-connect/helpers/weak-reference-map.prototype.deleteReference deleteReference
	 * @signature `weakReferenceMap.deleteReference(key)`
	 *
	 *   Decrements the reference count for key and removes it if the reference count is `0`. This should be called
	 *   when a value should not be managed by something, typically the [can-connect/constructor/store/store].
	 *
	 *   @param  {String} key The key of the item in the store.
	 */
	deleteReference: function(key){
		var data = this.set[key];
		if(data){
			data.referenceCount--;
			if( data.referenceCount === 0 ) {
				delete this.set[key];
			}
		}
	},
	/**
	 * @function can-connect/helpers/weak-reference-map.prototype.get get
	 * @signature `weakReferenceMap.get(key)`
	 *
	 *   Returns the value stored at key if it's in the store.
	 *
	 *   @param  {String} key The key of the item in the store.
	 *   @return {*|undefined} The item if it's available.
	 */
	get: function(key){
		var data = this.set[key];
		if(data) {
			return data.item;
		}
	},
	/**
	 * @function can-connect/helpers/weak-reference-map.prototype.forEach forEach
	 * @signature `weakReferenceMap.forEach(callback)`
	 *
	 *   Calls `callback` for every value in the store.
	 *
	 *   @param  {function(*,String)} callback(item,key) A callback handler.
	 */
	forEach: function(cb){
		for(var id in this.set) {
			cb(this.set[id].item, id);
		}
	}
});

var weakReferenceMap = WeakReferenceMap;

var updateDeepExceptIdentity = function updateExceptIdentity(obj, data, schema) {
    if(!schema) {
        schema = canReflect_1_16_7_canReflect.getSchema(obj);
    }
    if(!schema) {
        throw new Error("can-diff/update-except-id is unable to update without a schema.");
    }
    // copy the keys onto data
    schema.identity.forEach(function(key){
        var id = canReflect_1_16_7_canReflect.getKeyValue(obj, key);
        if(id!== undefined) {
            canReflect_1_16_7_canReflect.setKeyValue(data, key, id );
        }
    });

    canReflect_1_16_7_canReflect.updateDeep(obj, data);
};

var idMerge = function(list$$1, update, id, make){

	var patches = list(list$$1, update, function(a, b){
		return id(a) === id(b);
	});
	patches.forEach(function(patch){
		canReflect_1_16_7_canReflect.splice(list$$1, patch.index, patch.deleteCount, patch.insert.map(make));
	});
};

var behaviorsMap = {};

function behavior(name, behavior){
	if(typeof name !== "string") {
		behavior = name;
		name = undefined;
	}
	var behaviorMixin = function(base){
		// basically Object.create
		var Behavior = function(){};
		Behavior.name = name;
		Behavior.prototype = base;
		var newBehavior = new Behavior();
		// allows behaviors to be a simple object, not always a function
		var res = typeof behavior === "function" ? behavior.apply(newBehavior, arguments) : behavior;
		for(var prop in res) {
			if(res.hasOwnProperty(prop)) {
				Object.defineProperty(newBehavior, prop, Object.getOwnPropertyDescriptor(res, prop));
			} else {
				// we only copy values from up the proto chain
				newBehavior[prop] = res[prop];
			}
		}
		newBehavior.__behaviorName = name;
		return newBehavior;
	};
	if(name) {
		behaviorMixin.behaviorName = name;
		behaviorsMap[name] = behaviorMixin;
	}
	behaviorMixin.isBehavior = true;
	return behaviorMixin;
}
behavior.map = behaviorsMap;
var canConnect_3_0_0Pre_14_behavior = behavior;

/**
 * @module {connect.Behavior} can-connect/constructor/constructor constructor
 * @parent can-connect.behaviors
 * @group can-connect/constructor/constructor.options 1 behavior options
 * @group can-connect/constructor/constructor.crud 2 CRUD methods
 * @group can-connect/constructor/constructor.callbacks 3 CRUD callbacks
 * @group can-connect/constructor/constructor.hydrators 4 hydrators
 * @group can-connect/constructor/constructor.serializers 5 serializers
 * @group can-connect/constructor/constructor.helpers 6 helpers
 *
 * Adds an interface to interact with custom types via the connection instead of plain Objects and Arrays.
 *
 * @signature `constructor( baseConnection )`
 *
 * Adds an interface that allows the connection to operate on custom types. These fall into the categories:
 * - [can-connect/constructor/constructor#CRUDMethods CRUD Methods] - create, read, update and delete typed instances via the data source
 * - [can-connect/constructor/constructor#CRUDCallbacks CRUD Callbacks] - activities run on typed instances following data source operations
 * - [can-connect/constructor/constructor#Hydrator Hydrators] - conversion of raw data to typed data
 * - [can-connect/constructor/constructor#Serializers Serializers] - conversion of typed data to raw data
 *
 * @param {{}} baseConnection `can-connect` connection object that is having the `constructor` behavior added
 * on to it.
 *
 * @return {Object} A `can-connect` connection containing the method implementations provided by `constructor`.
 *
 * @body
 *
 * ## Use
 *
 * The `constructor` behavior allows you to instantiate the raw representation of the data source's data into a
 * custom typed representation with additional methods and behaviors.

 * An example might be loading data from a `"/todos"` service and being able to call `.timeLeft()`  on the todos that
 * you get back like:
 *
 * ```js
 * todoConnection.get({id: 6}).then(function(todo){
 *   todo.timeLeft() //-> 60000
 * })
 * ```
 *
 * The following creates a `todoConnection` that does exactly that:
 *
 * ```js
 * // require connection plugins
 * var constructor = require("can-connect/constructor/");
 * var dataUrl = require("can-connect/data/url/");
 *
 * // define type constructor function
 * var Todo = function(data){
 *   // add passed properties to new instance
 *   for(var prop in data) {
 *    this[prop] = data;
 *   }
 * };
 *
 * // add method to get time left before due, in milliseconds
 * Todo.prototype.timeLeft = function(){
 *   return new Date() - this.dueDate
 * };
 *
 * // create connection, passing function to instantiate new instances
 * var todoConnection = connect([constuctor, dataUrl], {
 *   url: "/todos",
 *   instance: function(data){
 *     return new Todo(data);
 *   }
 * });
 * ```
 *
 * The `constructor` behavior is still useful even if you want to keep your data as untyped objects (which is the
 * default behavior when no [can-connect/constructor/constructor.instance `instance`] implementation is provided).  The
 * behavior provides an interface to the data held by the client. For example,
 * [can-connect/constructor/constructor.updatedInstance] provides an extension point for logic that needs to be executed
 * after an instance held by the client finishes an update request. This is valuable whether that instance is typed or not.
 * Extensions like [can-connect/real-time/real-time] or [can-connect/fall-through-cache/fall-through-cache]
 * require this interface for advanced behavior.
 *
 * ## Interface
 *
 * `constructor` provides the following categories of methods to interact with typed data:
 *
 * ### <span id="CRUDMethods">CRUD Methods</span>
 *
 * Methods that create, read, update and delete (CRUD) typed representations of raw connection data:
 *
 * - [can-connect/constructor/constructor.get] - retrieve a single typed instance from the data source
 * - [can-connect/constructor/constructor.getList] - retrieve a typed list of instances from the data source
 * - [can-connect/constructor/constructor.save] - save a typed instance's data to the data source
 * - [can-connect/constructor/constructor.destroy] - delete a typed instance's data from the data source
 *
 * ### <span id="CRUDCallbacks">CRUD Callbacks</span>
 *
 * "CRUD Methods" call these methods with request response data and a related instance. Their implementation here
 * updates the related instance with that data:
 *
 * - [can-connect/constructor/constructor.createdInstance] - after [can-connect/constructor/constructor.save saving] new instance to data source, update that instance with response data
 * - [can-connect/constructor/constructor.updatedInstance] - after [can-connect/constructor/constructor.save saving] existing instance to data source, update that instance with response data
 * - [can-connect/constructor/constructor.destroyedInstance] - after [can-connect/constructor/constructor.destroy deleting] instance from data source, update that instance with response data
 * - [can-connect/constructor/constructor.updatedList] - after new data is read from the data source, update an existing list with instances created from that data
 *
 * ### <span id="CRUDMethods">Hydrators</span>
 *
 * These methods are used to create a typed instance or typed list given raw data objects:
 * - [can-connect/constructor/constructor.hydrateInstance] - create a typed instance given raw instance data
 * - [can-connect/constructor/constructor.hydrateList] - create a typed list of typed instances given given raw list data
 *
 * ### <span id="Serializers">Serializers</span>
 *
 * These methods convert a typed instance or typed list into a raw object:
 * - [can-connect/constructor/constructor.serializeInstance] - return raw data representing the state of the typed instance argument
 * - [can-connect/constructor/constructor.serializeList] - return raw data representing the state of the typed list argument
 *
 */

var makeArray = canReflect_1_16_7_canReflect.toArray;
var assign$3 = canReflect_1_16_7_canReflect.assignMap;





var constructor_1 = canConnect_3_0_0Pre_14_behavior("constructor",function(baseConnection){

	var behavior = {
		// stores references to instances
		// for now, only during create
		/**
		 * @property {can-connect/helpers/weak-reference-map} can-connect/constructor/constructor.cidStore cidStore
		 * @parent can-connect/constructor/constructor.helpers
		 *
		 * Temporarily hold references to new instances via their [can-cid] while they are undergoing creation.
		 *
		 * @option {can-connect/helpers/weak-reference-map} Temporarily holds references to instances by
		 * [can-cid] when they are in the process of being created and don't yet have an `id`s. This is typically
		 * accessed in `createdData` handlers (e.g [can-connect/real-time/real-time.createdData real-time.createdData]) that
		 * need to lookup the instance that was being created during a particular request.
		 */
		cidStore: new weakReferenceMap(),
		_cid: 0,

		/**
		 * @function can-connect/constructor/constructor.get get
		 * @parent can-connect/constructor/constructor.crud
		 *
		 * Retrieve a single instance from the connection data source.
		 *
		 * @signature `connection.get(params)`
		 *
		 * Retrieves instance data from [can-connect/connection.getData], runs the resulting data through
		 * [can-connect/constructor/constructor.hydrateInstance], creating a typed instance with the retrieved data.
		 *
		 * @param {Object} params data specifying the instance to retrieve.  Normally, this is something like like:
		 * `{id: 5}`.
		 *
		 * @return {Promise<can-connect/Instance>} `Promise` resolving to the instance returned by
		 * [can-connect/constructor/constructor.hydrateInstance].
		 *
		 * ### Usage
		 *
		 * Call `.get()` with the parameters that identify the instance you want to load.  `.get()` will return a promise
		 * that resolves to that instance:
		 * ```js
		 * todoConnection.get({id: 6}).then(function(todo){
		 *   todo.id; // 6
		 *   todo.name; // 'Take out the garbage'
		 * });
		 * ```
		 *
		 * `.get()` above will call [can-connect/connection.getData `getData`] on the [can-connect/data/url/url]
		 * behavior, which will make an HTTP GET request to `/todos/6`.
		 */
		get: function(params) {
			var self = this;
			return this.getData(params).then(function(data){
				return self.hydrateInstance(data);
			});
		},

		/**
		 * @function can-connect/constructor/constructor.getList getList
		 * @parent can-connect/constructor/constructor.crud
		 *
		 * Retrieve a list of instances from the connection data source.
		 *
		 * @signature `connection.getList(set)`
		 *
		 * Retrieves list data from [can-connect/connection.getListData] and runs the resulting data through
		 * [can-connect/constructor/constructor.hydrateList], creating a typed list of typed instances from  the retrieved
		 * data.
		 *
		 * @param {can-query-logic/query} query data specifying the range of instances to retrieve. This might look something like:
		 * ```{start: 0, end: 50, due: 'today'}```
		 *
		 * @return {Promise<can-connect.List<can-connect/Instance>>} `Promise` resolving to the typed list returned by
		 * [can-connect/constructor/constructor.hydrateList].
		 *
		 * ### Usage
		 *
		 * Call `getList` with the parameters that specify the set of data you want to load.  `.getList()` will return
		 * a promise that resolves to a [can-connect.List] created from that set.
		 *
		 * ```js
		 * todoConnection.getList({due: 'today'}).then(function(todos){
		 *   todos[0].name; // 'Take out the garbage'
		 *   todos[0].due > startOfDay && todos[0].due < endOfDay; // true
		 * })
		 * ```
		 *
		 */
		getList: function(set) {
			set = set ||  {};
			var self = this;
			return this.getListData( set ).then(function(data){
				return self.hydrateList(data, set);
			});
		},


		/**
		 * @function can-connect/constructor/constructor.hydrateList hydrateList
		 * @parent can-connect/constructor/constructor.hydrators
		 *
		 * Produce a typed list from the provided raw list data.
		 *
		 * @signature `connection.hydrateList(listData, set)`
		 *
		 *   Call [can-connect/constructor/constructor.hydrateInstance] for each item in the raw list data, and then call
		 *   [can-connect/constructor/constructor.list] with an array of the typed instances returned from
		 *   [can-connect/constructor/constructor.hydrateInstance] .  If [can-connect/constructor/constructor.list] is not
		 *   provided as an argument or implemented by another behavior, a normal array is created.
		 *
		 *   @param {can-connect.listData} listData the raw list data returned by the data source, often via [can-connect/connection.getListData]
		 *   @param {can-query-logic/query} query description of the set of data `listData` represents
		 *
		 *   @return {can-connect.List} a typed list containing typed instances generated from `listData`
		 */
		hydrateList: function(listData, set){
			if(Array.isArray(listData)) {
				listData = {data: listData};
			}

			var arr = [];
			for(var i = 0; i < listData.data.length; i++) {
				arr.push( this.hydrateInstance(listData.data[i]) );
			}
			listData.data = arr;
			if(this.list) {
				return this.list(listData, set);
			} else {
				var list = listData.data.slice(0);
				list[this.listQueryProp || "__listQuery"] = set;
				copyMetadata(listData, list);
				return list;
			}
		},

		/**
		 * @function can-connect/constructor/constructor.hydrateInstance hydrateInstance
		 * @parent can-connect/constructor/constructor.hydrators
		 *
		 * Produce a typed object containing the provided raw data.
		 *
		 * @signature `connection.hydrateInstance(props)`
		 *
		 * If [can-connect/constructor/constructor.instance] has been passed as an option, or defined by another behavior,
		 * pass `props` to it and return the value. Otherwise, return a clone of `props`.
		 *
		 * @param {Object} props the raw instance data returned by the data source, often via [can-connect/connection.getData]
		 * @return {can-connect/Instance} a typed instance containing the data from `props`
		 */
		hydrateInstance: function(props){
			if(this.instance) {
				return this.instance(props);
			}  else {
				return assign$3({}, props);
			}
		},
		/**
		 * @function can-connect/constructor/constructor.save save
		 * @parent can-connect/constructor/constructor.crud
		 *
		 * @description Create or update an instance on the connection data source
		 *
		 * @signature `connection.save( instance )`
		 *
		 *   First checks if the instance has an [can-connect/base/base.id] or not.  If it has an id, the instance will be
		 *   updated; otherwise, it will be created.
		 *
		 *   When creating an instance, the instance is added to the [can-connect/constructor/constructor.cidStore], and its
		 *   [can-connect/constructor/constructor.serializeInstance serialized data] is passed to
		 *   [can-connect/connection.createData].  If `createData`'s promise resolves to anything other than `undefined`,
		 *   [can-connect/constructor/constructor.createdInstance] is called with that data.
		 *
		 *   When updating an instance, its [can-connect/constructor/constructor.serializeInstance serialized data] is
		 *   passed to [can-connect/connection.updateData]. If `updateData`'s promise resolves to anything other than
		 *   `undefined`, [can-connect/constructor/constructor.updatedInstance] is called with that data.
		 *
		 *   @param {can-connect/Instance} instance the instance to create or save
		 *
		 *   @return {Promise<can-connect/Instance>} `Promise` resolving to the same instance that was passed to `save`
		 *
		 * @body
		 *
		 * ## Use
		 *
		 * To use `save` to create an instance, create a connection, then an instance, and call `.save()` on it:
		 *
		 * ```js
		 * // Create a connection
	     * var constructor = require('can-connect/constructor/');
		 * var dataUrl = require('can-connect/data/url/');
		 * var todoConnection = connect([dataUrl, constructor], {
		 *   url: "/todos"
		 * });
		 *
		 * // Create an instance
		 * var todo = {name: "do dishes"};
		 *
		 * // Call .save()
		 * todoConnection.save(todo)
		 * ```
		 *
		 * `.save(todo)` above will call [can-connect/data/url/url.createData `createData`] on the [can-connect/data/url/url]
		 * behavior, which will make an HTTP POST request to `/todos` with the serialized `todo` data.  The server response
		 * data may look something like:
		 *
		 * ```js
		 * {
		 *  id: 5,
		 *  ownerId: 9
		 * }
		 * ```
		 *
		 * That data will be passed to [can-connect/constructor/constructor.createdInstance] which by default
		 * adds those properties to `todo`, resulting in `todo` looking like:
		 *
		 * ```js
		 * {
		 *  name: "do dishes",
		 *  id: 5,
		 *  ownerId: 9
		 * }
		 * ```
		 *
		 * As an example of updating an instance, change a property on `todo` and call `.save()` again:
		 *
		 * ```js
		 * // Change a property
		 * todo.name = "Do dishes now!!";
		 *
		 * // Call .save()
		 * todoConnection.save(todo)
		 * ```
		 *
		 * The `.save(todo)` above will call [can-connect/data/url/url.updateData `updateData`] on the
		 * [can-connect/data/url/url] behavior, which will make an HTTP PUT request to `/todos` with the serialized `todo`
		 * data.
		 *
		 * A successful server response body should look something like:
		 *
		 * ```js
		 * {
		 *  name: "Do dishes now!!",
		 *  id: 5,
		 *  ownerId: 9
		 * }
		 * ```
		 *
		 * This data will be passed to [can-connect/constructor/constructor.updatedInstance] which by default sets
		 * all of `todo`'s properties to look like the response data, even removing properties that are missing from the
		 * response data.
		 */
		save: function(instance){
			var serialized = this.serializeInstance(instance);
			var id = this.id(instance);
			var self = this;
			if(id === undefined) {
				// If `id` is undefined, we are creating this instance.
				// It should be given a local id and temporarily added to the cidStore
				// so other hooks can get back the instance that's being created.
				var cid = this._cid++;
				// cid is really a token to be able to reference this transaction.
				this.cidStore.addReference(cid, instance);

				// Call the data layer.
				// If the data returned is undefined, don't call `createdInstance`
				return this.createData(serialized, cid).then(function(data){
					// if undefined is returned, this can't be created, or someone has taken care of it
					if(data !== undefined) {
						self.createdInstance(instance, data);
					}
					self.cidStore.deleteReference(cid, instance);
					return instance;
				});
			} else {
				return this.updateData(serialized).then(function(data){
					if(data !== undefined) {
						self.updatedInstance(instance, data);
					}
					return instance;
				});
			}
		},
		/**
		 * @function can-connect/constructor/constructor.destroy destroy
		 * @parent can-connect/constructor/constructor.crud
		 * @description Delete an instance from the connection data source
		 *
		 * @signature `connection.destroy( instance )`
		 *
		 *   To destroy an instance, it's [can-connect/constructor/constructor.serializeInstance serialized data] is passed
		 *   to [can-connect/connection.destroyData]. If [can-connect/connection.destroyData]'s promise resolves to anything
		 *   other than `undefined`, [can-connect/constructor/constructor.destroyedInstance] is called.
		 *
		 *   @param {can-connect/Instance} instance the instance being deleted from the data source
		 *
		 *   @return {Promise<can-connect/Instance>} `Promise` resolving to the same instance that was passed to `destroy`
		 *
		 * @body
		 *
		 * ## Use
		 *
		 * To use `destroy`, create a connection, retrieve an instance, and then call `.destroy()` with it.
		 *
		 * ```js
		 * // create a connection
		 * var constructor = require('can-connect/constructor/');
		 * var dataUrl = require('can-connect/data/url/');
		 * var todoConnection = connect([dataUrl, constructor], {
		 *   url: "/todos"
		 * })
		 *
		 * // retrieve a todo instance
		 * todoConnection.get({id: 5}).then(function(todo){
		 *   // Call .destroy():
		 *   todoConnection.destroy(todo)
		 * });
		 * ```
		 *
		 * `.destroy()` above will call [can-connect/connection.destroyData `destroyData`] on the [can-connect/data/url/url]
		 * behavior, which will make an HTTP DELETE request to `/todos/5` with the serialized `todo` data.  The server
		 * response data may look something like:
		 *
		 * ```js
		 * {
		 *   deleted: true
		 * }
		 * ```
		 *
		 * That response data will be passed to [can-connect/constructor/constructor.destroyedInstance], which by default
		 * adds those properties to `todo`.
		 */
		// ## destroy
		// Calls the data interface `destroyData` and as long as it
		// returns something, uses that data to call `destroyedInstance`.
		destroy: function(instance){
			var serialized = this.serializeInstance(instance),
				self = this;

			return this.destroyData(serialized).then(function(data){
				if(data !== undefined) {
					self.destroyedInstance(instance, data);
				}
				return instance;
			});
		},

		/**
		 * @function can-connect/constructor/constructor.createdInstance createdInstance
		 * @parent can-connect/constructor/constructor.callbacks
		 *
		 * A method run whenever a new instance has been saved to the data source. Updates the instance with response data.
		 *
		 * @signature `connection.createdInstance( instance, props )`
		 *
		 * `createdInstance` is run whenever a new instance is saved to the data source. This implementation updates the
		 * instance with the data returned by [can-connect/connection.createData] which made the request to save the raw
		 * instance data.
		 *
		 * @param {can-connect/Instance} instance the instance that was created
		 * @param {Object} props the data returned from [can-connect/connection.createData] that will update the properties of `instance`
		 */
		createdInstance: function(instance, props){
			assign$3(instance, props);
		},

		/**
		 * @function can-connect/constructor/constructor.updatedInstance updatedInstance
		 * @parent can-connect/constructor/constructor.callbacks
		 *
		 * A method run whenever an existing instance has been saved to the data source. Overwrites the instance with response
		 * data.
		 *
		 * @signature `connection.updatedInstance( instance, props )`
		 *
		 * `updatedInstance` is run whenever an existing instance is saved to the data source. This implementation overwrites
		 * the instance with the data returned bu [can-connect/connection.updatedData] which made the request to save the
		 * modified instance data.
		 *
		 * @param {can-connect/Instance} instance the instance that was updated
		 * @param {Object} props the data from [can-connect/connection.updateData] that will overwrite the properties of `instance`
		 */
		updatedInstance: function(instance, data){
			updateDeepExceptIdentity(instance, data, this.queryLogic.schema);
		},

		/**
		 * @function can-connect/constructor/constructor.updatedList updatedList
		 * @parent can-connect/constructor/constructor.callbacks
		 *
		 * A method run whenever new data for an existing list is retrieved from the data source. Updates the list to
		 * include the new data.
		 *
		 * @signature `connection.updatedList( list, listData, set )`
		 *
		 * [can-connect/constructor/constructor.hydrateInstance Hydrates instances] from `listData`'s data and attempts to
		 * merge them into `list`.  The merge is able to identify simple insertions and removals of elements instead of
		 * replacing the entire list.
		 *
		 * @param {can-connect/Instance} list an existing list
		 * @param {can-connect.listData} listData raw data that should be included as part of `list` after conversion to typed instances
		 * @param {can-query-logic/query} query description of the set of data `list` represents
		 */
		updatedList: function(list, listData, set) {
			var instanceList = [];
			for(var i = 0; i < listData.data.length; i++) {
				instanceList.push( this.hydrateInstance(listData.data[i]) );
			}
			// This only works with "referenced" instances because it will not
			// update and assume the instance is already updated
			// this could be overwritten so that if the ids match, then a merge of properties takes place
			idMerge(list, instanceList, this.id.bind(this), this.hydrateInstance.bind(this));

			copyMetadata(listData, list);
		},

		/**
		 * @function can-connect/constructor/constructor.destroyedInstance destroyedInstance
		 * @parent can-connect/constructor/constructor.callbacks
		 *
		 * A method run whenever an instance has been deleted from the data source. Overwrites the instance with response data.
		 *
		 * @signature `connection.destroyedInstance( instance, props )`
		 *
		 * `destroyedInstance` is run whenever an existing instance is deleted from the data source. This implementation
		 * overwrites the instance with the data returned by [can-connect/connection.destroyData] which made the request to
		 * delete the raw instance data.
		 *
		 * @param {can-connect/Instance} instance the instance that was deleted
		 * @param {Object} props the data returned from [can-connect/connection.destroyData] that will overwrite the
		 * properties of `instance`
		 */
		destroyedInstance: function(instance, data){
			updateDeepExceptIdentity(instance, data, this.queryLogic.schema);
		},

		/**
		 * @function can-connect/constructor/constructor.serializeInstance serializeInstance
		 * @parent can-connect/constructor/constructor.serializers
		 *
		 * @description Generate the serialized form of a typed instance.
		 *
		 * @signature `connection.serializeInstance( instance )`
		 *
		 *   Generate a raw object representation of a typed instance. This default implementation simply clones the
		 *   `instance` object, copying all the properties of the object (excluding properties of it's prototypes) to a new
		 *   object. This is equivalent to `Object.assign({}, instance)`.
		 *
		 * @param {can-connect/Instance} instance the instance to serialize
		 * @return {Object} a serialized representation of the instance
		 */
		serializeInstance: function(instance){
			return assign$3({}, instance);
		},

		/**
		 * @function can-connect/constructor/constructor.serializeList serializeList
		 * @parent can-connect/constructor/constructor.serializers
		 *
		 * @description Generate the serialized form of a typed list.
		 *
		 * @signature `connection.serializeList( list )`
		 *
		 *   Generate a raw array representation of a typed list. This default implementation simply returns a plain `Array`
		 *   containing the result of calling [can-connect/constructor/constructor.serializeInstance] on each item in the
		 *   typed list.
		 *
		 * @param {can-connect.List} list The instance to serialize.
		 * @return {Object|Array} A serialized representation of the list.
		 */
		serializeList: function(list){
			var self = this;
			return makeArray(list).map(function(instance){
				return self.serializeInstance(instance);
			});
		},

		/**
		 * @function can-connect/constructor/constructor.isNew isNew
		 * @parent can-connect/constructor/constructor.helpers
		 *
		 * Returns if the instance has not been loaded from or saved to the data source.
		 *
		 * @signature `connection.isNew(instance)`
		 * @param {Object} instance the instance to test
		 * @return {Boolean} `true` if [can-connect/base/base.id] is `null` or `undefined`
		 */
		isNew: function(instance){
			var id = this.id(instance);
			return !(id || id === 0);
		}

		/**
		 * @property can-connect/constructor/constructor.list list
		 * @parent can-connect/constructor/constructor.options
		 *
		 * Behavior option provided to create a typed list from a raw array.
		 *
		 * @signature `connection.list( listData, set )`
		 *
		 * Takes a `listData` argument with a `data` property, that is an array of typed instances, each produced by
		 * [can-connect/constructor/constructor.hydrateInstance], and returns a new typed list containing those typed
		 * instances.
		 * This method is passed as an option to the connection.
		 * Called by [can-connect/constructor/constructor.hydrateList].
		 *
		 * @param {can-connect.listData} listData an object with a `data` property, which is an array of instances.
		 * @param {can-query-logic/query} query the set description of this list
		 * @return {can-connect.List} a typed list type containing the typed instances
		 *
		 * ### Usage
		 *
		 * The following example makes the connection produce `MyList` typed lists including a `completed` method:
		 *
		 * ```js
		 * var constructor = require("can-connect/constructor/");
		 * var dataUrl = require("can-connect/data/url/");
		 *
		 * // define custom list type constructor
		 * var MyList = function(items) {
		 *  this.push.apply(this, items);
		 * }
		 * // inherit Array functionality
		 * MyList.prototype = Object.create(Array.prototype);
		 * // add custom methods to new list type
		 * MyList.prototype.completed = function(){
		 *  return this.filter(function(){ return this.completed });
		 * };
		 *
		 * // create connection
		 * var todosConnection = connect([constructor, dataUrl], {
		 *   url: "/todos",
		 *   list: function(listData, set){
		 *     // create custom list instance
		 *     var collection = new MyList(listData.data);
		 *     // add set info for use by other behaviors
		 *     collection.__listQuery = set;
		 *     return collection;
		 *   }
		 * });
		 *
		 * // use connection to get typed list & use custom method
		 * todosConnection.getList({}).then(function(todoList){
		 *   console.log("There are", todoList.completed().length, "completed todos");
		 * });
		 * ```
		 *
		 * **Note:** we added the [can-connect/base/base.listQueryProp] property (`Symbol.for("can.listQuery")` by default) on the list. This is
		 * expected by other behaviors.
		 */

		/**
		 * @property can-connect/constructor/constructor.instance instance
		 * @parent can-connect/constructor/constructor.options
		 *
		 * Behavior option provided to create a typed form of passed raw data.
		 *
		 * @signature `connection.instance( props )`
		 *
		 * Creates a typed instance for the passed raw data object. This method is passed as an option to the connection.
		 * Called by [can-connect/constructor/constructor.hydrateInstance].
		 *
		 * @param {Object} props a raw object containing the properties from the data source
		 * @return {can-connect/Instance} the typed instance created from the passed `props` object
		 *
		 * ### Usage
		 *
		 * The following example makes the connection produce `Todo` typed objects including a `complete` method:
		 *
		 * ```js
		 * var constructor = require("can-connect/constructor/");
		 * var dataUrl = require("can-connect/data/url/");
		 *
		 * // define type constructor
		 * var Todo = function(rawData){
		 *   // add raw data to new instance
		 *   Object.assign(this, rawData);
		 * };
		 *
		 * // add methods to custom type
		 * Todo.prototype.complete = function(){
		 *   this.completed = true;
		 * }
		 *
		 * // create connection
		 * var todosConnection = connect([constructor, dataUrl], {
		 *   url: "/todos",
		 *   instance: function(rawData) {
		 *     return new Todo(rawData);
		 *   }
		 * });
		 *
		 * // use connection to get typed instance & use custom method
		 * todosConnection.get({id: 5}).then(function(todo){
		 *   todo.completed; // false
		 *   todo.complete();
		 *   todo.completed; // true
		 * });
		 * ```
		 *
		 */
	};

	return behavior;

});

function copyMetadata(listData, list){
	for(var prop in listData) {
		if(prop !== "data") {
			// this is map infultrating constructor, but it's alright here.
			if(typeof list.set === "function") {
				list.set(prop, listData[prop]);
			} else if(typeof list.attr === "function") {
				list.attr(prop, listData[prop]);
			} else {
				list[prop] = listData[prop];
			}

		}
	}
}

var assignDeepExceptIdentity = function assignExceptIdentity(obj, data, schema) {
    if(!schema) {
        schema = canReflect_1_16_7_canReflect.getSchema(obj);
    }
    if(!schema) {
        throw new Error("can-diff/update-except-id is unable to update without a schema.");
    }
    // copy the keys onto data
    schema.identity.forEach(function(key){
        var id = canReflect_1_16_7_canReflect.getKeyValue(obj, key);
        if(id!== undefined) {
            canReflect_1_16_7_canReflect.setKeyValue(data, key, id );
        }
    });

    canReflect_1_16_7_canReflect.assignDeep(obj, data);
};

function smartMerge(instance, props) {

	props = canReflect_1_16_7_canReflect.serialize(props);

	if (canReflect_1_16_7_canReflect.isMoreListLikeThanMapLike(instance)) {
		mergeList(instance, props);
	} else {
		mergeMap(instance, props);
	}
	return instance;
}

// date is expected to be mutable here
function mergeMap(instance, data) {

	// for each key in
	canReflect_1_16_7_canReflect.eachKey(instance, function(value, prop) {
		if(!canReflect_1_16_7_canReflect.hasKey(data, prop)) {
			canReflect_1_16_7_canReflect.deleteKeyValue(instance, prop);
			return;
		}
		var newValue = canReflect_1_16_7_canReflect.getKeyValue(data, prop);
		canReflect_1_16_7_canReflect.deleteKeyValue(data, prop);

		// cases:
		// a. list
		// b. map
		// c. primitive

		// if the data is typed, we would just replace it
		if (canReflect_1_16_7_canReflect.isPrimitive(value)) {
			canReflect_1_16_7_canReflect.setKeyValue(instance, prop, newValue);
			return;
		}


		var newValueIsList = Array.isArray(newValue),
			currentValueIsList = canReflect_1_16_7_canReflect.isMoreListLikeThanMapLike(value);

		if (currentValueIsList && newValueIsList) {

			mergeList(value, newValue);

		} else if (!newValueIsList && !currentValueIsList && canReflect_1_16_7_canReflect.isMapLike(value) && canReflect_1_16_7_canReflect.isPlainObject(newValue)) {

			// TODO: the `TYPE` should probably be infered from the `_define` property definition.
			var schema = canReflect_1_16_7_canReflect.getSchema(value);
			if (schema && schema.identity && schema.identity.length) {
				var id = canReflect_1_16_7_canReflect.getIdentity(value, schema);
				if (id != null && id === canReflect_1_16_7_canReflect.getIdentity(newValue, schema)) {
					mergeMap(value, newValue);
					return;
				}
			}
			canReflect_1_16_7_canReflect.setKeyValue(instance, prop, canReflect_1_16_7_canReflect.new(value.constructor, newValue));
		} else {
			canReflect_1_16_7_canReflect.setKeyValue(instance, prop, newValue);
		}
	});
	canReflect_1_16_7_canReflect.eachKey(data, function(value, prop) {
		canReflect_1_16_7_canReflect.setKeyValue(instance, prop, value);
	});
}

function mergeList(list$$1, data) {
	var ItemType, itemSchema;
	var listSchema = canReflect_1_16_7_canReflect.getSchema(list$$1);
	if (listSchema) {
		ItemType = listSchema.values;
	}

	if (ItemType) {
		itemSchema = canReflect_1_16_7_canReflect.getSchema(ItemType);
	}
	if (!itemSchema && canReflect_1_16_7_canReflect.size(list$$1) > 0) {
		itemSchema = canReflect_1_16_7_canReflect.getSchema(canReflect_1_16_7_canReflect.getKeyValue(list$$1, 0));
	}

	var identity;
	if(itemSchema && itemSchema.identity && itemSchema.identity.length) {
		identity = function(a, b) {
		   var aId = canReflect_1_16_7_canReflect.getIdentity(a, itemSchema),
			   bId = canReflect_1_16_7_canReflect.getIdentity(b, itemSchema);
		   var eq = aId === bId;
		   if (eq) {
			   // If id is the same we merge data in. Case #2
			   mergeMap(a, b);
		   }
		   return eq;
	   };
   } else {
	   identity = function(a, b) {
		  var eq = a === b;
		  if (eq) {
			  // If id is the same we merge data in. Case #2
			  mergeMap(a, b);
		  }
		  return eq;
	  };
   }


	var patches = list(list$$1, data, identity);



	var hydrate = ItemType ? canReflect_1_16_7_canReflect.new.bind(canReflect_1_16_7_canReflect, ItemType) : function(v) {
		return v;
	};


	// If there are no patches then data contains only updates for all of the existing items, and we just leave.
	if (!patches.length) {
		return list$$1;
	}

	// Apply patches (add new, remove) #3. For any insertion use a hydrator.
	patches.forEach(function(patch) {
		applyPatch(list$$1, patch, hydrate);
	});
}

function applyPatch(list$$1, patch, makeInstance) {
	// Splice signature compared to patch:
	//   array.splice(start, deleteCount, item1, item2, ...)
	//   patch = {index: 1, deleteCount: 0, insert: [1.5]}
	var insert = makeInstance && patch.insert.map(function(val){
		return makeInstance(val);
	}) || patch.insert;

	var args = [patch.index, patch.deleteCount].concat(insert);
	list$$1.splice.apply(list$$1, args);

	return list$$1;
}

smartMerge.applyPatch = applyPatch;

var mergeDeep = smartMerge;

function flatten(arrays) {
	return arrays.reduce(function(ret, val) {
		return ret.concat(val);
	}, []);
}

// return a function that validates it's argument has all the properties in the interfacePropArrays
function makeInterfaceValidator(interfacePropArrays) {
	var props = flatten(interfacePropArrays);

	return function(base) {
			var missingProps = props.reduce(function(missing, prop) {
				return prop in base ? missing : missing.concat(prop);
			}, []);

		return missingProps.length ? {message:"missing expected properties", related: missingProps} : undefined;
	};
}

var canValidateInterface_1_0_2_index = makeInterfaceValidator;

// return wrapped can-connect behavior mixin that validates interface of the input behavior being extended
// deprecate this and use can-validate-interface decorator once available



var validate = function(extendingBehavior, interfaces){
	var validatedBehaviour = validateArgumentInterface(extendingBehavior, 0, interfaces, function(errors, baseBehavior) {
		throw new BehaviorInterfaceError(baseBehavior, extendingBehavior, errors);
	});

	// copy properties on behavior to validator wrapped behavior
	Object.keys(extendingBehavior).forEach(function (k) {
		validatedBehaviour[k] = extendingBehavior[k];
	});
	// add interfaces for building behavior ordering
	validatedBehaviour.__interfaces = interfaces;

	return validatedBehaviour;
};

function validateArgumentInterface(func, argIndex, interfaces, errorHandler) {
	return function() {
		var errors = canValidateInterface_1_0_2_index(interfaces)(arguments[argIndex]);
		if (errors && errorHandler) {
			errorHandler(errors, arguments[argIndex]);
		}

		return func.apply(this, arguments);
	}
}


// change to 'BehaviourInterfaceError extends Error' once we drop support for pre-ES2015
function BehaviorInterfaceError(baseBehavior, extendingBehavior, missingProps) {
	var extendingName = extendingBehavior.behaviorName || 'anonymous behavior',
		baseName = baseBehavior.__behaviorName || 'anonymous behavior',
		message = 'can-connect: Extending behavior "' + extendingName + '" found base behavior "' + baseName
			+ '" was missing required properties: ' + JSON.stringify(missingProps.related),
		instance = new Error(message);

	if (Object.setPrototypeOf){
		Object.setPrototypeOf(instance, Object.getPrototypeOf(this));
	}
	return instance;
}
BehaviorInterfaceError.prototype = Object.create(Error.prototype, {
	constructor: {value: Error}
});
if (Object.setPrototypeOf){
	Object.setPrototypeOf(BehaviorInterfaceError, Error);
} else {
	BehaviorInterfaceError.__proto__ = Error;
}

var each = canReflect_1_16_7_canReflect.each;
var isPlainObject$1 = canReflect_1_16_7_canReflect.isPlainObject;














var getNameSymbol$1 = canSymbol_1_6_1_canSymbol.for("can.getName");

function smartMergeExceptIdentity(dest, source, schema) {
	if(!schema) {
        schema = canReflect_1_16_7_canReflect.getSchema(dest);
    }
    if(!schema) {
        throw new Error("can-connect/can/map/ is unable to update without a schema.");
    }
	schema.identity.forEach(function(key){
        var id = canReflect_1_16_7_canReflect.getKeyValue(dest, key);
        if(id!== undefined) {
            canReflect_1_16_7_canReflect.setKeyValue(source, key, id );
        }
    });
	mergeDeep(dest, source);
}

var canMapBehavior = canConnect_3_0_0Pre_14_behavior("can/map",function(baseConnection){

	// overwrite
	var behavior = {
		init: function(){
			if(!this.Map) {
				throw new Error("can-connect/can/map/map must be configured with a Map type");
			}
			if(!this[getNameSymbol$1]) {
				this[getNameSymbol$1] = function(){
					if(this.name) {
						return "Connection{"+this.name+"}";
					} else if(this.Map) {
						return "Connection{"+canReflect_1_16_7_canReflect.getName(this.Map)+"}";
					} else if(typeof this.url === "string") {
						return "Connection{"+this.url+"}";
					} else {
						return "Connection{}";
					}
				};
			}

			this.List = this.List || this.Map.List;
			if(!this.List) {
				throw new Error("can-connect/can/map/map - "+canReflect_1_16_7_canReflect.getName(this)+" must be configured with a List type.");
			}

			overwrite(this, this.Map, mapOverwrites);
			overwrite(this, this.List, listOverwrites);

			if(!this.queryLogic) {
				this.queryLogic = new canQueryLogic_0_8_11_canQueryLogic(this.Map);
			}


			var connection = this;

			// ### Setup store updates
			if(this.Map[canSymbol_1_6_1_canSymbol.for("can.onInstanceBoundChange")]) {
				var canConnectMap_onMapBoundChange = function (instance, isBound){
					var method = isBound ? "addInstanceReference" : "deleteInstanceReference";
					if(connection[method]) {
						connection[method](instance);
					}
				};
				//!steal-remove-start
				Object.defineProperty(canConnectMap_onMapBoundChange, "name", {
					value: canReflect_1_16_7_canReflect.getName(this.Map) + " boundChange",
					configurable: true
				});
				//!steal-remove-end
				this.Map[canSymbol_1_6_1_canSymbol.for("can.onInstanceBoundChange")](canConnectMap_onMapBoundChange);
			} else {
				console.warn("can-connect/can/map is unable to listen to onInstanceBoundChange on the Map type");
			}

			if(this.List[canSymbol_1_6_1_canSymbol.for("can.onInstanceBoundChange")]) {
				var canConnectMap_onListBoundChange = function(list, isBound){
					var method = isBound ? "addListReference" : "deleteListReference";
					if(connection[method]) {
						connection[method](list);
					}
				};
				//!steal-remove-start
				Object.defineProperty(canConnectMap_onListBoundChange, "name", {
					value: canReflect_1_16_7_canReflect.getName(this.List) + " boundChange",
					configurable: true
				});
				//!steal-remove-end
				this.List[canSymbol_1_6_1_canSymbol.for("can.onInstanceBoundChange")](canConnectMap_onListBoundChange);
			} else {
				console.warn("can-connect/can/map is unable to listen to onInstanceBoundChange on the List type");
			}
			// Adds the instance when its `id` property is set
			if(this.Map[canSymbol_1_6_1_canSymbol.for("can.onInstancePatches")]) {
				this.Map[canSymbol_1_6_1_canSymbol.for("can.onInstancePatches")](function canConnectMap_onInstancePatches(instance, patches){
					patches.forEach(function(patch){
						if( (patch.type === "add" || patch.type === "set") &&
							patch.key === connection.idProp &&
							instance[canSymbol_1_6_1_canSymbol.for("can.isBound")]()) {
							connection.addInstanceReference(instance);
						}
					});
				});
			} else {
				console.warn("can-connect/can/map is unable to listen to onInstancePatches on the Map type");
			}
			baseConnection.init.apply(this, arguments);
		},
		/**
		 * @function can-connect/can/map/map.serializeInstance serializeInstance
		 * @parent can-connect/can/map/map.serializers
		 *
		 * Returns the properties of an instance that should be sent to the data source when saving. Done by calling
		 * [can-define/map/map.prototype.serialize `instance.serialize()`].
		 *
		 * @signature `connection.serializeInstance(instance)`
		 * Simply calls [can-define/map/map.prototype.serialize] on the `instance` argument.
		 *
		 * @param {can-connect/can/map/map._Map} instance the instance to serialize
		 * @return {Object} the result of calling [can-define/map/map.prototype.serialize `instance.serialize()`]
		 */
		serializeInstance: function(instance){
			return canReflect_1_16_7_canReflect.serialize(instance);
		},
		/**
		 * @function can-connect/can/map/map.serializeList serializeList
		 * @parent can-connect/can/map/map.serializers
		 *
		 * Returns the properties of a list that should be sent to the data source when saving. Done by calling
		 * [can-define/list/list.prototype.serialize `list.serialize()`].
		 *
		 * @signature `connection.serializeList(list)`
		 * Simply calls [can-define/list/list.prototype.serialize] on the `list` argument.
		 *
		 * @param {can-connect/can/map/map._List} list the list to serialize
		 * @return {Object} the result of calling [can-define/list/list.prototype.serialize `list.serialize()`]
		 */
		serializeList: function(list){
			return canReflect_1_16_7_canReflect.serialize(list);
		},
		/**
		 * @property {Boolean} can-connect/can/map/map.updateInstanceWithAssignDeep updateInstanceWithAssignDeep
		 * @parent can-connect/can/map/map.options
		 *
		 * Use the response from `save()` and `destroy()` to assign properties, never delete them.
		 *
		 * @option {Boolean}
		 *
		 * Setting `updateInstanceWithAssignDeep` to `true` changes how instances get updated. Instead of using
		 * [can-diff/merge-deep/merge-deep], records will be updated with [can-reflect.assignDeep].
		 *
		 * The following example shows that the response from `.save()` only includes the `id`
		 * property. Normally, this would delete all other properties (`name`).  But setting `updateInstanceWithAssignDeep`
		 * to `true` prevents this:
		 *
		 * **Usage:**
		 *
		 * ```js
		 * import {DefineMap, restModel} from "can";
		 *
		 * var Todo = DefineMap.extend({
		 *   id: {type: "number", identity: true},
		 *   name: "string"
		 * });
		 *
		 * // restModel uses `can-connect/can/map/map`
		 * restModel({
		 *   Map: Todo,
		 *   url: "/todos",
		 *   updateInstanceWithAssignDeep: true
		 * });
		 *
		 *
		 * var todo = new Todo({name: "learn canjs"})
		 *
		 * var savePromise = todo.save()
		 * // SERVER SENDS
		 * // -> POST /todos {name: "learn canjs"}
		 *
		 * // SERVER RESPONDS WITH:
		 * // <- {id: 5}
		 *
		 * savePromise.then(function(){
		 *   // Name still exists even though the server did not
		 *   // respond with it.
		 *   todo.name //-> "learn canjs"
		 * })
		 * ```
		 *
		 * __NOTE__: [can-diff/merge-deep/merge-deep] is able to work _MUCH_ better with nested
		 * data than [can-reflect.assignDeep]. Specifically, it is able to better
		 * prevent overwriting one instance's data with another. The _Use_ section of [can-diff/merge-deep/merge-deep]
		 * goes over this ability. Make sure you understand its capabilities before turning it off.
		 */

		/**
		 * @property {connection.Map} can-connect/can/map/map._Map Map
		 * @parent can-connect/can/map/map.options
		 *
		 * Specify the type of the `[can-define/map/map DefineMap]` that should be instantiated by the connection.
		 *
		 * @option {connection.Map}
		 *
		 * **Usage:**
		 *
		 * ```js
		 * var DefineMap = require("can-define/map/map");
		 * var canMap = require("can-connect/can/map/map");
		 * var constructor = require("can-connect/constructor/constructor");
		 * var dataUrl = require("can-connect/data/url/url");
		 *
		 * var Todo = DefineMap.extend({
		 *   completed: "boolean",
		 *   complete: function(){
		 *     this.completed = true
		 *   }
		 * });
		 *
		 * var todoConnection = connect([dataUrl, constructor, canMap], {
		 *   Map: Todo,
		 *   url: "/todos"
		 * });
		 *
		 * todoConnect.get({id:1}).then(function(item) {
		 *   item instanceof Todo // true
		 * });
		 * ```
		 */

		/**
		 * @property {connection.List} can-connect/can/map/map._List List
		 * @parent can-connect/can/map/map.options
		 *
		 * Specify the type of the `[can-define/list/list DefineList]` that should be instantiated by the connection.
		 *
		 * @option {connection.List} If this option is not specified it defaults to the [can-connect/can/map/map._Map Map].List
		 * property.
		 *
		 * **Usage:**
		 * ```js
		 * var DefineMap = require("can-define/map/map");
		 * var DefineList = require("can-define/list/list");
		 * var canMap = require("can-connect/can/map/map");
		 * var constructor = require("can-connect/constructor/constructor");
		 * var dataUrl = require("can-connect/data/url/url");
		 *
		 * var Todo = DefineMap.extend({
		 *   completed: "boolean",
		 *   complete: function(){
		 *     this.completed = true
		 *   }
		 * });
		 *
		 * var Todo.List = DefineList.extend({
		 *   "#": Todo,
		 *   completed: function(){
		 *     this.filter(function(todo){
		 *       return todo.completed;
		 *     });
		 *   }
		 * });
		 *
		 * var todoConnection = connect([dataUrl, constructor, canMap],{
		 *   Map: Todo,
		 *   List: Todo.List,
		 *   url: "/todos"
		 * });
		 *
		 * todoConnection.getList({}).then(function(list) {
		 *   list instanceOf Todo.List // true
		 * })
		 * ```
		 *
		 */

		/**
		 * @function can-connect/can/map/map.instance instance
		 * @parent can-connect/can/map/map.hydrators
		 *
		 * Creates a [can-connect/can/map/map._Map] instance given raw data.
		 *
		 * @signature `connection.instance(props)`
		 *
		 *   Create an instance of [can-connect/can/map/map._Map].
		 *
		 *   @param {Object} props the raw instance data.
		 *   @return [can-connect/can/map/map._Map] a [can-connect/can/map/map._Map] instance containing the `props`.
		 */
		instance: function(props){
			var _Map = this.Map;
			return new _Map(props);
		},

		/**
		 * @function can-connect/can/map/map.list list
		 * @parent can-connect/can/map/map.hydrators
		 *
		 * Creates a [can-connect/can/map/map._List] instance given raw data.
		 *
		 * @signature `connection.list(listData, set)`
		 *
		 *   Creates an instance of [can-connect/can/map/map._List] if available, otherwise creates
		 *   [can-connect/can/map/map._Map].List if available.
		 *
		 *   This will add properties on the raw `listData` array to the created list instance. e.g:
		 *   ```js
		 *   var listData = [{id: 1, name:"do dishes"}, ...];
		 *   listData.loadedFrom; // "shard 5"
		 *
		 *   var todoList = todoConnection.list(listData, {});
		 *   todoList.loadedFrom; // "shard 5"
		 *   ```
		 *
		 *   @param {can-connect.listData} listData the raw list data.
		 *   @param {can-query-logic/query} query the set the data belongs to.
		 *   @return {can-connect.List} a [can-connect/can/map/map._List] instance containing instances of
		 *   [can-connect/can/map/map._Map] built from the list items in `listData`.
		 */
		list: function(listData, set){
			var _List = this.List || (this.Map && this.Map.List);
			var list = new _List(listData.data);
			canReflect_1_16_7_canReflect.eachKey(listData, function (val, prop) {
				if (prop !== 'data') {
					canReflect_1_16_7_canReflect.setKeyValue(list, prop, val);
				}
			});

			list[this.listQueryProp] = set;
			return list;
		},

		/**
		 * @function can-connect/can/map/map.updatedList updatedList
		 * @parent can-connect/can/map/map.instance-callbacks
		 *
		 * Implements the [can-connect/constructor/constructor.updatedList] callback so it updates the list and it's items
		 * during a single [can-event/batch/batch batched event].
		 *
		 * @signature `connection.updatedList(list, listData, set)`
		 *
		 *   Updates the list and the items within it during a single [can-event/batch/batch batched event].
		 *
		 *   @param {can-connect.List} list the list to be updated.
		 *   @param {can-connect.listData} listData raw list data.
		 *   @param {can-query-logic/query} query the set of the list being updated.
		 */
		updatedList: function(list, listData, set){
			canQueues_1_1_0_canQueues.batch.start();
			canQueues_1_1_0_canQueues.mutateQueue.enqueue(baseConnection.updatedList, this, arguments,{
				//!steal-remove-start
				reasonLog: ["set", set,"list", list,"updated with", listData]
				//!steal-remove-end
			});
			canQueues_1_1_0_canQueues.batch.stop();

		},
		save: function(instance){
			canReflect_1_16_7_canReflect.setKeyValue(instance, "_saving", true);
			//canEvent.dispatch.call(instance, "_saving", [true, false]);
			var done = function(){
				canReflect_1_16_7_canReflect.setKeyValue(instance, "_saving", false);
				//canEvent.dispatch.call(instance, "_saving", [false, true]);
			};
			var base = baseConnection.save.apply(this, arguments);
			base.then(done,done);
			return base;
		},
		destroy: function(instance){
			canReflect_1_16_7_canReflect.setKeyValue(instance, "_destroying", true);
			//canEvent.dispatch.call(instance, "_destroying", [true, false]);
			var done = function(){
				canReflect_1_16_7_canReflect.setKeyValue(instance, "_destroying", false);
				//canEvent.dispatch.call(instance, "_destroying", [false, true]);
			};
			var base = baseConnection.destroy.apply(this, arguments);
			base.then(done,done);
			return base;
		}
	};

	each([
		/**
		 * @function can-connect/can/map/map.createdInstance createdInstance
		 * @parent can-connect/can/map/map.instance-callbacks
		 *
		 * Implements the [can-connect/constructor/constructor.createdInstance] callback so it dispatches an event and
		 * updates the instance.
		 *
		 * @signature `connection.createdInstance(instance, props)`
		 *
		 *   Updates the instance with `props` and dispatches a "created" event on the instance and the instances's
		 *   constructor function ([can-connect/can/map/map._Map]).
		 *
		 *   Calls [can-connect/constructor/store/store.stores.moveCreatedInstanceToInstanceStore] to ensure new instances
		 *   are moved into the [can-connect/constructor/store/store.instanceStore] after being saved.
		 *
		 *   @param {can-connect/can/map/map._Map} instance a [can-connect/can/map/map._Map] instance
		 *   @param {Object} props the data in the response from [can-connect/connection.createData]
		 */
		"created",
		/**
		 * @function can-connect/can/map/map.updatedInstance updatedInstance
		 * @parent can-connect/can/map/map.instance-callbacks
		 *
		 * Implements the [can-connect/constructor/constructor.updatedInstance] callback so it dispatches an event and
		 * updates the instance.
		 *
		 * @signature `connection.updatedInstance(instance, props)`
		 *
		 *   Updates the instance with `props` and dispatches an "updated" event on the instance and the instances's
		 *   constructor function ([can-connect/can/map/map._Map]).
		 *
		 *   @param {can-connect/can/map/map._Map} instance a [can-connect/can/map/map._Map] instance
		 *   @param {Object} props the data in the response from [can-connect/connection.updateData]
		 */
		"updated",
		/**
		 * @function can-connect/can/map/map.destroyedInstance destroyedInstance
		 * @parent can-connect/can/map/map.instance-callbacks
		 *
		 * Implements the [can-connect/constructor/constructor.destroyedInstance] callback so it dispatches an event and
		 * updates the instance.
		 *
		 * @signature `connection.destroyedInstance(instance, props)`
		 *
		 *   Updates the instance with `props` and dispatches a "destroyed" event on the instance and the instances's
		 *   constructor function ([can-connect/can/map/map._Map]).
		 *
		 *   @param {can-connect/can/map/map._Map} instance a [can-connect/can/map/map._Map] instance
		 *   @param {Object} props the data in the response from [can-connect/connection.destroyData]
		 */
		"destroyed"
	], function (funcName) {
		// Each of these is pretty much the same, except for the events they trigger.
		behavior[funcName+"Instance"] = function (instance, props) {

			// Update attributes if attributes have been passed
			if(props && typeof props === 'object') {

				if(funcName === "destroyed" && canReflect_1_16_7_canReflect.size(props) === 0) {
					// If destroy is passed an empty object, ignore update
					// This isn't tested except by can-rest-model.
				} else {
					if(this.constructor.removeAttr) {
						updateDeepExceptIdentity(instance, props, this.queryLogic.schema);
					}
					// this is legacy
					else if(this.updateInstanceWithAssignDeep){
						assignDeepExceptIdentity(instance, props, this.queryLogic.schema);
					}
					else {
						smartMergeExceptIdentity( instance, props, this.queryLogic.schema);
					}
				}

			}
			// This happens in constructor/store, but we don't call base, so we have to do it ourselves.
			if(funcName === "created" && this.moveCreatedInstanceToInstanceStore) {
				this.moveCreatedInstanceToInstanceStore(instance);
			}

			canMapBehavior.callbackInstanceEvents(funcName, instance);
		};
	});


	return behavior;

});

/**
 * @function can-connect/can/map/map.callbackInstanceEvents callbackInstanceEvents
 * @parent can-connect/can/map/map.static
 *
 * Utility function to dispatch events for instance callbacks, e.g. [can-connect/can/map/map.updatedInstance].
 *
 * @signature `connection.callbackInstanceEvents(cbName, instance)`
 *
 *   Used to dispatch events as part of instance callbacks implementations. This method could be useful in other
 *   behaviors that implement instance callbacks. E.g. a behavior overriding the
 *   [can-connect/can/map/map.updatedInstance `updatedInstance`] callback:
 *
 *   ```
 *   connect([canMap, {
 *       updatedInstance: function(instance, props) {
 *           instance = smartMerge(instance, props);
 *           canMapBehavior.callbackInstanceEvents("updated", instance);
 *       }
 *   }], {})
 *   ```
 *
 *   @param {String} eventName name of the the event to be triggered
 *   @param {can-connect/can/map/map._Map} instance a [can-connect/can/map/map._Map] instance.
 */
canMapBehavior.callbackInstanceEvents = function (funcName, instance) {
	var constructor = instance.constructor;

	// triggers change event that bubble's like
	// handler( 'change','1.destroyed' ). This is used
	// to remove items on destroyed from Model Lists.
	// but there should be a better way.
	canQueues_1_1_0_canQueues.batch.start();
	map$1.dispatch.call(instance, {type: funcName, target: instance});

	//!steal-remove-start
	if (this.id) {
		dev.log("can-connect/can/map/map.js - " + (constructor.shortName || this.name) + " " + this.id(instance) + " " + funcName);
	}
	//!steal-remove-end

	// Call event on the instance's Class
	map$1.dispatch.call(constructor, funcName, [instance]);
	canQueues_1_1_0_canQueues.batch.stop();
};


var mapOverwrites = {
	static: {
		/**
		 * @function can-connect/can/map/map.getList getList
		 * @parent can-connect/can/map/map.map-static
		 *
		 * Retrieve a list of instance.
		 *
		 * @signature `Map.getList(query)`
		 *
		 * `.getList` is added to the configured [can-connect/can/map/map._Map] type. Retrieves a [can-connect/can/map/map._List] of
		 * [can-connect/can/map/map._Map] instances via the connection.
		 *
		 * ```js
		 * // import connection plugins
		 * var canMap = require("can-connect/can/map/map");
		 * var constructor = require("can-connect/constructor/constructor");
		 * var dataUrl = require("can-connect/data/url/url");
		 *
		 * // define connection types
		 * var Todo = DefineMap.extend({
		 *   id: "number",
		 *   complete: "boolean",
		 *   name: "string"
		 * });
		 *
		 * Todo.List = DefineList.extend({
		 *   completed: function() {
		 *     return this.filter(function(item) { return item.completed; });
		 *   }
		 * });
		 *
		 * // create connection
		 * connect([canMap, constructor, dataUrl],{
		 *   Map: Todo,
		 *   url: "/todos"
		 * })
		 *
		 * // retrieve instances
		 * Todo.getList({filter: {due: "today"}}).then(function(todos){
		 *   ...
		 * });
		 * ```
		 *
		 * @param {can-query-logic/query} query Definition of the list being retrieved.
		 * @return {Promise<Map>} `Promise` returning the [can-connect/can/map/map._List] of instances being retrieved
		 *
		 *
		 *
		 *
		 */
		getList: function (base, connection) {
			return function(set) {
				return connection.getList(set);
			};
		},
		/**
		 * @function can-connect/can/map/map.findAll findAll
		 * @parent can-connect/can/map/map.map-static
		 * @hide
		 *
		 * Alias of [can-connect/can/map/map.getList]. You should use `.getList()`.
		 */
		findAll: function (base, connection) {
			return function(set) {
				return connection.getList(set);
			};
		},
		/**
		 * @function can-connect/can/map/map.get get
		 * @parent can-connect/can/map/map.map-static
		 *
		 * Use it to get a single instance by id.
		 *
		 * @signature `Map.get(params)`
		 *
		 * `.get()` is added to the configured [can-connect/can/map/map._Map] type.
		 * Use it to get a single instance by the identity keys of the Map type.
		 *
		 * ```js
		 * // import connection plugins
		 * var canMap = require("can-connect/can/map/map");
		 * var constructor = require("can-connect/constructor/constructor");
		 * var dataUrl = require("can-connect/data/url/url");
		 *
		 * // define connection type
		 * var Todo = DefineMap.extend({
		 *   id: "number",
		 *   complete: "boolean",
		 *   name: "string"
		 * });
		 *
		 * // create connection
		 * connect([canMap, constructor, dataUrl],{
		 *   Map: Todo,
		 *   url: "/todos"
		 * })
		 *
		 * // retrieve instance
		 * Todo.get({id: 5}).then(function(todo){
		 *   ...
		 * });
		 * ```
		 *
		 * @param {Object} params Identifying parameters of the instance to retrieve. Typically, this is an object
		 * with the identity property and its value like: `{_id: 5}`.
		 * @return {Promise<Map>} `Promise` returning the [can-connect/can/map/map._Map] instance being retrieved
		 *
		 * @body
		 *
		 * ## Get a single record by filtering non-identity keys
		 *
		 * Sometimes, you want a single record, but by filtering non-identity keys.  Instead of using
		 * `.get`, use `.getList` like:
		 *
		 * ```js
		 * var firstCompleteTodo = Todo.getList({
		 *   filter: {complete: false},
		 *   page: {start: 0, end: 0}
		 * }).then(function(list){
		 *   return list.length ? list[0] : Promise.reject({message: "reject message"});
		 * });
		 * ```
		 *
		 */
		get: function (base, connection) {
			return function(params) {
				// adds .then for compat
				return connection.get(params);
			};
		},
		/**
		 * @function can-connect/can/map/map.findOne findOne
		 * @parent can-connect/can/map/map.map-static
		 * @hide
		 *
		 * Alias of [can-connect/can/map/map.get]. You should use `.get()`.
		 */
		findOne: function (base, connection) {
			return function(params) {
				// adds .then for compat
				return connection.get(params);
			};
		}
	},
	prototype: {
		isNew: function (base, connection) {
			/**
			 * @function can-connect/can/map/map.prototype.isNew isNew
			 * @parent can-connect/can/map/map.map
			 *
			 * If the data is not in the dat
			 *
			 * @signature `instance.isNew()`
			 *
			 * Returns if the instance has not been loaded from or saved to the data source.
			 *
			 * ```js
			 * connect([...],{
			 *   Map: Todo
			 * });
			 *
			 * var todo = new Todo();
			 * todo.isNew()   //-> true
			 *
			 * todo.save().then(function(){
			 *   todo.isNew() //-> false
			 * })
			 * ```
			 *
			 * @return {Boolean} Returns `true` if [can-connect/base/base.id] is `null` or `undefined`.
			 */
			return function () {
				return connection.isNew(this);
			}
		},

		isSaving: function (base, connection) {
			/**
			 * @function can-connect/can/map/map.prototype.isSaving isSaving
			 * @parent can-connect/can/map/map.map
			 *
			 * Returns if the instance is currently being saved.
			 *
			 * @signature `instance.isSaving()`
			 *
			 * Observes if a promise returned by [can-connect/connection.save `connection.save`] is in progress for this
			 * instance.  This is often used in a template like:
			 *
			 * ```html
			 * <button on:click="todo.save()"
			 *    disabled:from="todo.isSaving()">
			 *   Save Changes
			 * </button>
			 * ```
			 *
			 *   @return {Boolean} Returns `true` if [can-connect/connection.save `connection.save`] has been called for this
			 *   instance but the returned promise has not yet resolved.
			 */
			return function () {
				return !!canReflect_1_16_7_canReflect.getKeyValue(this,"_saving");
			};
		},

		isDestroying: function (base, connection) {
			/**
			 * @function can-connect/can/map/map.prototype.isDestroying isDestroying
			 * @parent can-connect/can/map/map.map
			 *
			 * Returns if the instance is currently being destroyed.
			 *
			 * @signature `instance.isDestroying()`
			 *
			 * Observes if a promise returned by [can-connect/connection.destroy `connection.destroy`] is in progress for this
			 * instance.  This is often used in a template like:
			 *
			 * ```html
			 * <button on:click="todo.destroy()"
			 *         disabled:from="todo.isDestroying()">
			 *   Delete
			 * </button>
			 * ```
			 *
			 *   @return {Boolean} `true` if [can-connect/connection.destroy `connection.destroy`] has been called for this
			 *   instance but the returned promise has not resolved.
			 */
			return function () {
				return !!canReflect_1_16_7_canReflect.getKeyValue(this,"_destroying");
			};
		},

		save: function (base, connection) {
			/**
			 * @function can-connect/can/map/map.prototype.save save
			 * @parent can-connect/can/map/map.map
			 *
			 * Save or update client data to the persisted data source.
			 *
			 * @signature `instance.save(success, error)`
			 *
			 * Calls [can-connect/connection.save].
			 *
			 * ```js
			 * // import connection plugins
			 * var canMap = require("can-connect/can/map/map");
			 * var constructor = require("can-connect/constructor/constructor");
			 * var dataUrl = require("can-connect/data/url/url");
			 *
			 * // define connection types
			 * var Todo = DefineMap.extend({
			 *   id: "number",
			 *   complete: "boolean",
			 *   name: "string"
			 * });
			 *
			 * // create connection
			 * connect([canMap, constructor, dataUrl], {
			 *   Map: Todo,
			 *   url: "/todos"
			 * })
			 *
			 * new Todo({name: "dishes"}).save();
			 * ```
			 *
			 *   @param {function} success A function that is called if the save is successful.
			 *   @param {function} error A function that is called if the save is rejected.
			 *   @return {Promise<Instance>} A promise that resolves to the instance if successful.
			 *
			 *
			 */
			return function(success, error){
				// return only one item for compatability
				var promise = connection.save(this);
				promise.then(success,error);
				return promise;
			};
		},
		destroy: function (base, connection) {
			/**
			 * @function can-connect/can/map/map.prototype.destroy destroy
			 * @parent can-connect/can/map/map.map
			 *
			 * Delete an instance from the service via the connection.
			 *
			 * @signature `instance.destroy(success, error)`
			 *
			 * Calls [can-connect/connection.destroy] for the `instance`.
			 *
			 * ```js
			 * // import connection plugins
			 * var canMap = require("can-connect/can/map/map");
			 * var constructor = require("can-connect/constructor/constructor");
			 * var dataUrl = require("can-connect/data/url/url");
			 *
			 * // define connection types
			 * var Todo = DefineMap.extend({
			 *   id: "number",
			 *   complete: "boolean",
			 *   name: "string"
			 * });
			 *
			 * // create connection
			 * connect([canMap, constructor, dataUrl],{
			 *   Map: Todo,
			 *   url: "/todos"
			 * })
			 *
			 * // read instance
			 * Todo.get({id: 5}).then(function(todo){
			 *   if (todo.complete) {
			 *     // delete instance
			 *     todo.destroy();
			 *   }
			 * });
			 * ```
			 *
			 * @param {function} success a function that is called if the [can-connect/connection.destroy] call is successful.
			 * @param {function} error a function that is called if the [can-connect/connection.destroy] call is rejected.
			 * @return {Promise<Instance>} a promise that resolves to the instance if successful
			 *
			 *
			 */
			return function(success, error){
				var promise;
				if (this.isNew()) {

					promise = Promise.resolve(this);
					connection.destroyedInstance(this, {});
				} else {
					promise = connection.destroy(this);
				}

				promise.then(success,error);
				return promise;
			};
		}
	},
	properties: {
		_saving: {enumerable: false, value: false, configurable: true, writable: true},
		_destroying: {enumerable: false, value: false, configurable: true, writable: true}
	}
};

var listOverwrites = {
	static:  {
		_bubbleRule: function(base, connection) {
			return function(eventName, list) {
				var bubbleRules = base(eventName, list);
				bubbleRules.push('destroyed');
				return bubbleRules;
			};
		}
	},
	prototype: {
		setup: function(base, connection){
			return function (params) {
				// If there was a plain object passed to the List constructor,
				// we use those as parameters for an initial getList.
				if (isPlainObject$1(params) && !Array.isArray(params)) {
					this[connection.listQueryProp] = params;
					base.apply(this);
					this.replace(canReflect_1_16_7_canReflect.isPromise(params) ? params : connection.getList(params));
				} else {
					// Otherwise, set up the list like normal.
					base.apply(this, arguments);
				}
			};
		}
	},
	properties: {}
};

var overwrite = function( connection, Constructor, overwrites) {
	var prop;
	for(prop in overwrites.properties) {
		canReflect_1_16_7_canReflect.defineInstanceKey(Constructor, prop, overwrites.properties[prop]);
	}
	for(prop in overwrites.prototype) {
		Constructor.prototype[prop] = overwrites.prototype[prop](Constructor.prototype[prop], connection);
	}
	if(overwrites.static) {
		for(prop in overwrites.static) {
			Constructor[prop] = overwrites.static[prop](Constructor[prop], connection);
		}
	}
};

var map$4 = canMapBehavior;

//!steal-remove-start

var map$4 = validate(
	canMapBehavior,
	[
		'id', 'get', 'updatedList', 'destroy', 'save', 'getList'
	]
);
//!steal-remove-end

var canMap = map$4;

/**
 * @module {connect.Behavior} can-connect/data/parse/parse
 * @parent can-connect.behaviors
 *
 * Extract response data into a format needed for other extensions.
 *
 * @signature `dataParse( baseConnection )`
 *
 *   Overwrites the [can-connect/DataInterface] methods to run their results through
 *   either [can-connect/data/parse/parse.parseInstanceData] or [can-connect/data/parse/parse.parseListData].
 *
 *   @param {{}} baseConnection The base connection.
 *
 * @body
 *
 * ## Use
 *
 * `data/parse` is used to modify the response data of "data interface" methods to comply with what
 * is expected by "instance interface" methods.  For example, if a service was returning list data
 * at the `/services/todos` url like:
 *
 * ```
 * {
 *   todos: [
 *     {todo: {id: 0, name: "dishes"}},
 *     {todo: {id: 2, name: "lawn"}}
 *   ]
 * }
 * ```
 *
 * That service does not return [can-connect.listData] in the right format which should look like:
 *
 * ```
 * {
 *   data: [
 *     {id: 0, name: "dishes"},
 *     {id: 2, name: "lawn"}
 *   ]
 * }
 * ```
 *
 * To correct this, you can configure `data-parse` to use the [can-connect/data/parse/parse.parseListProp] and [can-connect/data/parse/parse.parseInstanceProp]
 * as follows:
 *
 * ```
 * connect([
 *   require("can-connect/data/parse/parse"),
 *   require("can-connect/data/url/url")
 * ],{
 *  parseListProp: "todos",
 *  parseInstanceProp: "todo"
 * })
 * ```
 *
 */

var each$1 = canReflect_1_16_7_canReflect.each;



var parse = canConnect_3_0_0Pre_14_behavior("data/parse",function(baseConnection){

	var behavior = {
    /**
     * @function can-connect/data/parse/parse.parseListData parseListData
     * @parent can-connect/data/parse/parse
     *
     * @description Given a response from [can-connect/connection.getListData] returns its data in the
     * proper [can-connect.listData] format.
     *
     * @signature `connection.parseListData(responseData)`
     *
     *   This function uses [can-connect/data/parse/parse.parseListProp] to find the array
     *   containing the data for each instance.  Then it uses [can-connect/data/parse/parse.parseInstanceData]
     *   on each item in the array  Finally, it returns data in the
     *   [can-connect.listData] format.
     *
     *   @param {Object} responseData The response data from the AJAX request.
     *
     *   @return {can-connect.listData} An object like `{data: [props, props, ...]}`.
     *
     * @body
     *
     * ## Use
     *
     * `parseListData` comes in handy when dealing with an irregular API
     * that can be improved with data transformation.
     *
     * Suppose an endpoint responds with a status of 200 OK, even when the
     * request generates an empty result set. Worse yet, instead of representing
     * an emtpy set with an empty list, it removes the property.
     *
     * A request to `/services/todos` may return:
     *
     * ```
     * {
     *   todos: [
     *     {todo: {id: 0, name: "dishes"}},
     *     {todo: {id: 2, name: "lawn"}}
     *   ]
     * }
     * ```
     *
     * What if a request for `/services/todos?filterName=bank` responds with
     * 200 OK:
     *
     * ```
     * {
     * }
     * ```
     *
     * This response breaks its own schema. One way to bring it in line
     * with a format compatible with [can-connect.listData] is:
     *
     * ```
     * connect([
     *   require("can-connect/data/parse/parse"),
     *   require("can-connect/data/url/url")
     * ],{
     *   parseListProp: "todos",
     *   parseListData(responseData) {
     *     if (responseData && !responseData.todos) {
     *       responseData = { todos: [] };
     *     }
     *
     *     return responseData;
     *   }
     * })
     * ```
     */
		parseListData: function( responseData ) {

			// call any base parseListData
			if(baseConnection.parseListData) {
			   responseData = baseConnection.parseListData.apply(this, arguments);
			}

			var result;
			if( Array.isArray(responseData) ) {
				result = {data: responseData};
			} else {
				var prop = this.parseListProp || 'data';

				responseData.data = get_1(responseData, prop);
				result = responseData;
				if(prop !== "data") {
					delete responseData[prop];
				}
				if(!Array.isArray(result.data)) {
					throw new Error('Could not get any raw data while converting using .parseListData');
				}

			}
			var arr = [];
			for(var i =0 ; i < result.data.length; i++) {
				arr.push( this.parseInstanceData(result.data[i]) );
			}
			result.data = arr;
			return result;
		},
    /**
     * @function can-connect/data/parse/parse.parseInstanceData parseInstanceData
     * @parent can-connect/data/parse/parse
     *
     * @description Returns the properties that should be used to [can-connect/constructor/constructor.hydrateInstance make an instance]
     * given the results of [can-connect/connection.getData], [can-connect/connection.createData], [can-connect/connection.updateData],
     * and [can-connect/connection.destroyData].
     *
     * @signature `connection.parseInstanceData(responseData)`
     *
     *   This function will use [can-connect/data/parse/parse.parseInstanceProp] to find the data object
     *   representing the instance that will be created.
     *
     *   @param {Object} responseData The response data from [can-connect/connection.getData], [can-connect/connection.createData], or [can-connect/connection.updateData].
     *
     *   @return {Object} The data that should be passed to [can-connect/constructor/constructor.hydrateInstance].
     *
     * @body
     *
     * ## Use
     *
     * `parseInstanceData` comes in handy when dealing with an irregular API
     * that can be improved with data transformation.
     *
     * Suppose a request to `/services/todos` returns:
     * ```
     * {
     *   baseUrl: "/proxy/share",
     *   todo: {
     *     id: 0,
     *     name: "dishes",
     *     friendFaceUrl: "friendface?id=0",
     *     fiddlerUrl: "fiddler?id=0"
     *   }
     * }
     * ```
     *
     * The baseUrl property is meta-data that needs to be incorporated into the
     * instance data. One way to deal with this is:
     *
     * ```
     * connect([
     *   require("can-connect/data/parse/parse"),
     *   require("can-connect/data/url/url")
     * ],{
     *   parseInstanceProp: "todo",
     *   parseInstanceData(responseData) {
     *     ['friendFaceUrl', 'fiddlerUrl'].map(urlProp => {
     *       responseData.todo[urlProp] = [
     *         responseData.baseUrl,
     *         responseData.todo[urlProp]
     *       ].join('/');
     *     });
     *
     *     return responseData;
     *   }
     * })
     * ```
     *
     * This results in an object like:
     *
     * ```js
     * {
     *   id: 0,
     *   name: "dishes",
     *   friendFaceUrl: "/proxy/share/friendface?id=0",
     *   fiddlerUrl: "/proxy/share/fiddler?id=0"
     * }
     * ```
     */
		parseInstanceData: function( props ) {
			// call any base parseInstanceData
			if(baseConnection.parseInstanceData) {
				// It's possible this might be looking for a property that only exists in some
				// responses. So if it doesn't return anything, go back to using props.
			   props = baseConnection.parseInstanceData.apply(this, arguments) || props;
			}
			return this.parseInstanceProp ? get_1(props, this.parseInstanceProp) || props : props;
		}
		/**
		 * @property {String} can-connect/data/parse/parse.parseListProp parseListProp
		 * @parent can-connect/data/parse/parse
		 *
		 * The property to find the array-like data that represents each instance item.
		 *
		 * @option {String} [can-connect/data/parse/parse.parseListData] uses this property to find an array-like data struture
		 * on the result of [can-connect/connection.getListData].
		 *
		 * @body
		 *
		 * ## Use
		 *
		 * Set `parseListProp` if your response data does not look like: `{data: [props, props]}`.
		 *
		 * For example, if [can-connect/connection.getListData] returns data like:
		 *
		 * ```
		 * {
		 * 	  todos: [{id: 1, name: "dishes"}, {id: 2, name: "lawn"}]
		 * }
		 * ```
		 *
		 * Set `parseListProp` to `"todos"` like:
		 *
		 * ```
		 * connect([
         *   require("can-connect/data/parse/parse"),
         *   require("can-connect/data/url/url")
         * ],{
		 *   url : "/todos",
		 *   parseListProp: "todos"
		 * });
		 * ```
		 *
		 */
		/**
		 * @property {String} can-connect/data/parse/parse.parseInstanceProp parseInstanceProp
		 * @parent can-connect/data/parse/parse
		 *
		 * The property to find the data that represents an instance item.
		 *
		 * @option {String} [can-connect/data/parse/parse.parseInstanceData] uses this property's value to
		 * [can-connect/constructor/constructor.hydrateInstance make an instance].
		 *
		 * @body
		 *
		 * ## Use
		 *
		 * Set `parseInstanceData` if your response data does not directly contain the data you would like to pass to
		 * [connection.hydrateInstance].
		 *
		 * For example, if [can-connect/connection.getData] returns data like:
		 *
		 * ```
		 * {
		 *   todo: {
		 * 	   id: 1,
		 *     name: "dishes"
		 *   }
		 * }
		 * ```
		 *
		 * Set `parseInstanceProp` to `"todo"` like:
		 *
		 * ```
		 * connect([
         *   require("can-connect/data/parse/parse"),
         *   require("can-connect/data/url/url")
         * ],{
		 *   url : "/todos",
		 *   parseInstanceProp: "todo"
		 * });
		 * ```
		 */

	};

	each$1(pairs, function(parseFunction, name){
		behavior[name] = function(params){
			var self = this;
			return baseConnection[name].call(this, params).then(function(){
				return self[parseFunction].apply(self, arguments);
			});
		};
	});

	return behavior;

});

var pairs = {
	getListData: "parseListData",
	getData: "parseInstanceData",
	createData: "parseInstanceData",
	updateData: "parseInstanceData",
	destroyData: "parseInstanceData"
};

/**
 * @module {function} can-parse-uri can-parse-uri
 * @parent can-js-utilities
 * @collection can-infrastructure
 * @signature `parseURI(url)`
 *
 * Parse a URI into its components.
 *
 * ```js
 * import {parseURI} from "can"
 * parseURI("http://foo:8080/bar.html?query#change")
 * //-> {
 * //  authority: "//foo:8080",
 * //  hash: "#change",
 * //  host: "foo:8080",
 * //  hostname: "foo",
 * //  href: "http://foo:8080/bar.html?query#change",
 * //  pathname: "/bar.html",
 * //  port: "8080",
 * //  protocol: "http:",
 * //  search: "?query"
 * // }
 * ```
 *
 * @param {String} url The URL you want to parse.
 *
 * @return {Object} Returns an object with properties for each part of the URL. `null`
 * is returned if the url can not be parsed.
 */

var canParseUri_1_1_0_canParseUri = canNamespace_1_0_0_canNamespace.parseURI = function(url){
		var m = String(url).replace(/^\s+|\s+$/g, '').match(/^([^:\/?#]+:)?(\/\/(?:[^:@]*(?::[^:@]*)?@)?(([^:\/?#]*)(?::(\d*))?))?([^?#]*)(\?[^#]*)?(#[\s\S]*)?/);
			// authority = '//' + user + ':' + pass '@' + hostname + ':' port
		return (m ? {
			href     : m[0] || '',
			protocol : m[1] || '',
			authority: m[2] || '',
			host     : m[3] || '',
			hostname : m[4] || '',
			port     : m[5] || '',
			pathname : m[6] || '',
			search   : m[7] || '',
			hash     : m[8] || ''
		} : null);
	};

function buildParam(prefix, obj, add) {
	if (Array.isArray(obj)) {
		for (var i = 0, l = obj.length; i < l; ++i) {
			buildParam(prefix + '[]', obj[i], add);
		}
	} else if ( obj && typeof obj === "object" ) {
		for (var name in obj) {
			buildParam(prefix + '[' + name + ']', obj[name], add);
		}
	} else {
		add(prefix, obj);
	}
}

var canParam_1_0_4_canParam = canNamespace_1_0_0_canNamespace.param = function param(object) {
	var pairs = [],
		add = function (key, value) {
			pairs.push(encodeURIComponent(key) + '=' + encodeURIComponent(value));
		};
	for (var name in object) {
		buildParam(name, object[name], add);
	}
	return pairs.join('&')
		.replace(/%20/g, '+');
};

/**
 * @module {function} can-ajax can-ajax
 * @parent can-dom-utilities
 * @collection can-infrastructure
 *
 * Make an asynchronous HTTP (AJAX) request.
 *
 * @signature `ajax( ajaxOptions )`
 *
 *    Is used to make an asynchronous HTTP (AJAX) request similar to [http://api.jquery.com/jQuery.ajax/jQuery.ajax].
 *
 *    ```
 *    var ajax = require("can-ajax");
 *
 *    ajax({
 *      url: "http://query.yahooapis.com/v1/public/yql",
 *      data: {
 *        format: "json",
 *        q: 'select * from geo.places where text="sunnyvale, ca"'
 *      }
 *    }).then(function(response){
 *      console.log( response.query.count ); // => 2
 *    });
 *    ```
 *
 *    @param {Object} ajaxOptions Configuration options for the AJAX request.
 *      - __url__ `{String}` The requested url.
 *      - __type__ `{String}` The method of the request. Ex: `GET`, `PUT`, `POST`, etc. Capitalization is ignored. _Default is `GET`_.
 *      - __data__ `{Object}` The data of the request. If data needs to be urlencoded (e.g. for GET requests or for CORS) it is serialized with [can-param].
 *      - __dataType__ `{String}` Type of data. _Default is `json`_.
 *      - __crossDomain__ `{Boolean}` If you wish to force a crossDomain request (such as JSONP) on the same domain, set the value of crossDomain to true. This allows, for example, server-side redirection to another domain. Default: `false` for same-domain requests, `true` for cross-domain requests.
 *      - __xhrFields__ `{Object}` Any fields to be set directly on the xhr request, [https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest] such as the withCredentials attribute that indicates whether or not cross-site Access-Control requests should be made using credentials such as cookies or authorization headers.
 *
 *    @return {Promise} A Promise that resolves to the data. The Promise instance is abortable and exposes an `abort` method. Invoking abort on the Promise instance indirectly rejects it.
 *
 *
 * @signature `ajaxSetup( ajaxOptions )`
 *
 *    Is used to persist ajaxOptions across all ajax requests and they can be over-written in the ajaxOptions of the actual request.
 *    [https://api.jquery.com/jquery.ajaxsetup/]
 *
 *    ```
 *    var ajax = require("can-ajax");
 *
 *    ajax.ajaxSetup({xhrFields: {withCredentials: true}});
 *
 *    ajax({
 *      url: "http://query.yahooapis.com/v1/public/yql",
 *      data: {
 *        format: "json",
 *        q: 'select * from geo.places where text="sunnyvale, ca"'
 *      }
 *    }).then(function(response){
 *      console.log( response.query.count ); // => 2
 *    });
 *    ```
 */

// from https://gist.github.com/mythz/1334560
var xhrs = [
		function () { return new XMLHttpRequest(); },
		function () { return new ActiveXObject("Microsoft.XMLHTTP"); },
		function () { return new ActiveXObject("MSXML2.XMLHTTP.3.0"); },
		function () { return new ActiveXObject("MSXML2.XMLHTTP"); }
	],
	_xhrf = null;
// used to check for Cross Domain requests
var originUrl = canParseUri_1_1_0_canParseUri(global_1().location.href);

var globalSettings = {};

var makeXhr = function () {
	if (_xhrf != null) {
		return _xhrf();
	}
	for (var i = 0, l = xhrs.length; i < l; i++) {
		try {
			var f = xhrs[i], req = f();
			if (req != null) {
				_xhrf = f;
				return req;
			}
		} catch (e) {
			continue;
		}
	}
	return function () { };
};

var contentTypes = {
	json: "application/json",
	form: "application/x-www-form-urlencoded"
};

var _xhrResp = function (xhr, options) {
	switch (options.dataType || xhr.getResponseHeader("Content-Type").split(";")[0]) {
		case "text/xml":
		case "xml":
			return xhr.responseXML;
		case "text/json":
		case "application/json":
		case "text/javascript":
		case "application/javascript":
		case "application/x-javascript":
		case "json":
			return xhr.responseText && JSON.parse(xhr.responseText);
		default:
			return xhr.responseText;
	}
};

function ajax(o) {
	var xhr = makeXhr(), timer, n = 0;
	var deferred = {};
	var promise = new Promise(function(resolve,reject){
		deferred.resolve = resolve;
		deferred.reject = reject;
	});
	var requestUrl;

	promise.abort = function () {
		xhr.abort();
	};

	o = [{
			userAgent: "XMLHttpRequest",
			lang: "en",
			type: "GET",
			data: null,
			dataType: "json"
	}, globalSettings, o].reduce(function(a,b,i) {
		return canReflect_1_16_7_canReflect.assignDeep(a,b);
	});

	// Set the default contentType
	if(!o.contentType) {
		o.contentType = o.type.toUpperCase() === "GET" ?
			contentTypes.form : contentTypes.json;
	}

	//how jquery handles check for cross domain
	if(o.crossDomain == null){
		try {
			requestUrl = canParseUri_1_1_0_canParseUri(o.url);
			o.crossDomain = !!((requestUrl.protocol && requestUrl.protocol !== originUrl.protocol) ||
				(requestUrl.host && requestUrl.host !== originUrl.host));

		} catch (e){
			o.crossDomain = true;
		}
	}
	if (o.timeout) {
		timer = setTimeout(function () {
			xhr.abort();
			if (o.timeoutFn) {
				o.timeoutFn(o.url);
			}
		}, o.timeout);
	}
	xhr.onreadystatechange = function () {
		try {
			if (xhr.readyState === 4) {
				if (timer) {
					clearTimeout(timer);
				}
				if (xhr.status < 300) {
					if (o.success) {
						o.success( _xhrResp(xhr, o) );
					}
				}
				else if (o.error) {
					o.error(xhr, xhr.status, xhr.statusText);
				}
				if (o.complete) {
					o.complete(xhr, xhr.statusText);
				}

				if (xhr.status >= 200 && xhr.status < 300) {
					deferred.resolve( _xhrResp(xhr, o) );
				} else {
					deferred.reject( xhr );
				}
			}
			else if (o.progress) {
				o.progress(++n);
			}
		} catch(e) {
			deferred.reject(e);
		}
	};
	var url = o.url, data = null, type = o.type.toUpperCase();
	var isJsonContentType = o.contentType === contentTypes.json;
	var isPost = type === "POST" || type === "PUT";
	if (!isPost && o.data) {
		url += "?" + (isJsonContentType ? JSON.stringify(o.data) : canParam_1_0_4_canParam(o.data));
	}
	xhr.open(type, url);

	// For CORS to send a "simple" request (to avoid a preflight check), the following methods are allowed: GET/POST/HEAD,
	// see https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS#Simple_requests

	var isSimpleCors = o.crossDomain && ['GET', 'POST', 'HEAD'].indexOf(type) !== -1;

	if (isPost) {
		data = (isJsonContentType && !isSimpleCors) ?
			(typeof o.data === "object" ? JSON.stringify(o.data) : o.data):
			canParam_1_0_4_canParam(o.data);

		// CORS simple: `Content-Type` has to be `application/x-www-form-urlencoded`:
		var setContentType = (isJsonContentType && !isSimpleCors) ?
			"application/json" : "application/x-www-form-urlencoded";
		xhr.setRequestHeader("Content-Type", setContentType);
	} else {
		xhr.setRequestHeader("Content-Type", o.contentType);
	}

	// CORS simple: no custom headers, so we don't add `X-Requested-With` header:
	if (!isSimpleCors){
		xhr.setRequestHeader("X-Requested-With", "XMLHttpRequest");
	}

        if (o.xhrFields) {
            for (var f in o.xhrFields) {
                xhr[f] = o.xhrFields[f];
            }
        }

	xhr.send(data);
	return promise;
}

var canAjax_1_1_4_canAjax = canNamespace_1_0_0_canNamespace.ajax = ajax;
var ajaxSetup = function (o) {
    globalSettings = o || {};
};
canAjax_1_1_4_canAjax.ajaxSetup = ajaxSetup;

/**
 * @module {function} can-key/replace-with/replace-with
 * @parent can-key
 *
 * Replace the templated parts of a string with values from an object.
 *
 * @signature `replaceWith(str, data, replacer, remove)`
 *
 * ```js
 * import replaceWith from "can-key/replace-with/replace-with";
 *
 * replaceWith("foo_{bar}", {bar: "baz"}); // -> "foo_baz"
 * ```
 *
 * @param {String} str String with {curly brace} delimited property names.
 * @param {Object} data Object from which to read properties.
 * @param {function(String,*)} [replacer(key,value)] Function which returns string replacements.  Optional.
 *
 *   ```js
 *   replaceWith("foo_{bar}", {bar: "baz"}, (key, value) => {
 *     return value.toUpperCase();
 *   }); // -> "foo_BAZ"
 *   ```
 *
 *
 * @param {Boolean} shouldRemoveMatchedPaths Whether to remove properties
 * found in delimiters in `str` from `data`.
 * @return {String} the supplied string with delimited properties replaced with their values.
 *
 * @body
 *
 * ```js
 * var replaceWith = require("can-key/replace-with/replace-with");
 * var answer = replaceWith(
 *   '{.}{.}{.}{.}{.} Batman!',
 *   {},
 *   () => 'Na'
 * );
 * // => 'NaNaNaNaNa Batman!'
 * ```
 */
var replaceWith = function (str, data, replacer, shouldRemoveMatchedPaths) {
    return str.replace(canKey_0_5_0_utils.strReplacer, function (whole, path) {
        var value = get_1(data, path);
        if(shouldRemoveMatchedPaths) {
            _delete(data, path);
        }
        return replacer ? replacer(path, value) : value;
    });
};

// The following is from jQuery
function isArrayLike(obj){
	var type = typeof obj;
	if(type === "string") {
		return true;
	}
	else if(type === "number") {
		return false;
	}
	// The `in` check is from jQueryâ€™s fix for an iOS 8 64-bit JIT object length bug:
	// https://github.com/jquery/jquery/pull/2185
	var length = obj && type !== 'boolean' &&
		typeof obj !== 'number' &&
		"length" in obj && obj.length;

	// var length = "length" in obj && obj.length;
	return typeof obj !== "function" &&
		( length === 0 || typeof length === "number" && length > 0 && ( length - 1 ) in obj );
}

var isArrayLike_1 = isArrayLike;

var isIterable = function(obj) {
	return obj && !!obj[canSymbol_1_6_1_canSymbol.iterator || canSymbol_1_6_1_canSymbol.for("iterator")];
};

/* jshint maxdepth:7*/

var has = Object.prototype.hasOwnProperty;



function each$2(elements, callback, context) {
	var i = 0,
		key,
		len,
		item;
	if (elements) {
		if ( isArrayLike_1(elements) ) {

			for (len = elements.length; i < len; i++) {
				item = elements[i];
				if (callback.call(context || item, item, i, elements) === false) {
					break;
				}
			}
		}
		// Works in anything that implements Symbol.iterator
		else if(isIterable(elements)) {
			var iter = elements[canSymbol_1_6_1_canSymbol.iterator || canSymbol_1_6_1_canSymbol.for("iterator")]();
			var res, value;

			while(!(res = iter.next()).done) {
				value = res.value;
				callback.call(context || elements, Array.isArray(value) ?
											value[1] : value, value[0]);
			}
		}
		 else if (typeof elements === "object") {
			for (key in elements) {
				if (has.call(elements, key) &&
						callback.call(context || elements[key],
													elements[key], key, elements) === false) {
					break;
				}
			}
		}
	}
	return elements;
}

var each_1 = each$2;

var methodMapping = {
	item: {
		'GET': 'getData',
		'PUT': 'updateData',
		'DELETE': 'destroyData',
	},
	list: {
		'GET': 'getListData',
		'POST': 'createData'
	}
};


function inferIdProp (url) {
	var wrappedInBraces = /\{(.*)\}/;
	var matches = url.match(wrappedInBraces);
	var isUniqueMatch = matches && matches.length === 2;
	if (isUniqueMatch) {
		return matches[1];
	}
}

function getItemAndListUrls (url, idProp) {
	idProp = idProp || inferIdProp(url) || "id";
	var itemRegex = new RegExp('\\/\\{' + idProp+"\\}.*" );
	var rootIsItemUrl = itemRegex.test(url);
	var listUrl = rootIsItemUrl ? url.replace(itemRegex, "") : url;
	var itemUrl = rootIsItemUrl ? url : (url.trim() + "/{" + idProp + "}");
	return {item: itemUrl, list: listUrl};
}



var canMakeRest_0_1_3_canMakeRest = function(url, idProp){
	var data= {};
	each_1( getItemAndListUrls(url, idProp), function(url, type){
		each_1(methodMapping[type], function(interfaceMethod, method){
			data[interfaceMethod] = {
				method: method,
				url: url
			};
		});
	});
	return data;
};

var makePromise = function(obj){
	if (obj && typeof obj.then === "function" && !canReflect_1_16_7_canReflect.isPromise(obj)) {
		return new Promise(function(resolve, reject) {
			obj.then(resolve, reject);
		});
	}
	else {
		return obj;
	}
};

/**
 * @module {connect.Behavior} can-connect/data/url/url data/url
 * @parent can-connect.behaviors
 * @group can-connect/data/url/url.data-methods data methods
 * @group can-connect/data/url/url.option options
 *
 * @option {connect.Behavior}
 *
 * Uses the [can-connect/data/url/url.url] option to implement the behavior of
 * [can-connect/connection.getListData],
 * [can-connect/connection.getData],
 * [can-connect/connection.createData],
 * [can-connect/connection.updateData], and
 * [can-connect/connection.destroyData] to make an AJAX request
 * to urls.
 *
 * @body
 *
 * ## Use
 *
 * The `data/url` behavior implements many of the [can-connect/DataInterface]
 * methods to send instance data to a URL.
 *
 * For example, the following `todoConnection`:
 *
 * ```js
 * var todoConnection = connect([
 *   require("can-connect/data/url/url")
 * ],{
 *   url: {
 *     getListData: "GET /todos",
 *     getData: "GET /todos/{id}",
 *     createData: "POST /todos",
 *     updateData: "PUT /todos/{id}",
 *     destroyData: "DELETE /todos/{id}"
 *   }
 * });
 * ```
 *
 * Will make the following request when the following
 * methods are called:
 *
 * ```
 * // GET /todos?due=today
 * todoConnection.getListData({due: "today"});
 *
 * // GET /todos/5
 * todosConnection.getData({id: 5})
 *
 * // POST /todos \
 * // name=take out trash
 * todosConnection.createData({
 *   name: "take out trash"
 * });
 *
 * // PUT /todos/5 \
 * // name=do the dishes
 * todosConnection.updateData({
 *   name: "do the dishes",
 *   id: 5
 * });
 *
 * // DELETE /todos/5
 * todosConnection.destroyData({
 *   id: 5
 * });
 * ```
 *
 * There's a few things to notice:
 *
 * 1. URL values can include simple templates like `{id}`
 *    that replace that part of the URL with values in the data
 *    passed to the method.
 * 2. GET and DELETE request data is put in the URL using [can-param].
 * 3. POST and PUT requests put data that is not templated in the URL in POST or PUT body
 *    as JSON-encoded data.  To use form-encoded requests instead, add the property
 *    `contentType:'application/x-www-form-urlencoded'` to your [can-connect/data/url/url.url].
 * 4. If a provided URL doesn't include the method, the following default methods are provided:
 *    - `getListData` - `GET`
 *    - `getData` - `GET`
 *    - `createData` - `POST`
 *    - `updateData` - `PUT`
 *    - `destroyData` - `DELETE`
 *
 * If [can-connect/data/url/url.url] is provided as a string like:
 *
 * ```js
 * var todoConnection = connect([
 *   require("can-connect/data/url/url")
 * ],{
 *   url: "/todos"
 * });
 * ```
 *
 * This does the same thing as the first `todoConnection` example.
 */







var defaultRest = canMakeRest_0_1_3_canMakeRest("/resource/{id}");



// # can-connect/data/url/url
// For each pair, create a function that checks the url object
// and creates an ajax request.
var urlBehavior = canConnect_3_0_0Pre_14_behavior("data/url", function(baseConnection) {
	var behavior = {};
	canReflect_1_16_7_canReflect.eachKey(defaultRest, function(defaultData, dataInterfaceName){
		behavior[dataInterfaceName] = function(params) {
			var meta = methodMetaData[dataInterfaceName];

			if(typeof this.url === "object") {
				if(typeof this.url[dataInterfaceName] === "function") {

					return makePromise(this.url[dataInterfaceName](params));
				}
				else if(this.url[dataInterfaceName]) {
					var promise = makeAjax(
							this.url[dataInterfaceName],
							params,
							defaultData.method,
							this.ajax || canAjax_1_1_4_canAjax,
							findContentType(this.url, defaultData.method),
							meta);
					return makePromise(promise);
				}
			}

			var resource = typeof this.url === "string" ? this.url : this.url.resource;
			if( resource ) {
				var idProps = canReflect_1_16_7_canReflect.getSchema(this.queryLogic).identity;
				var resourceWithoutTrailingSlashes = resource.replace(/\/+$/, "");
				var result = canMakeRest_0_1_3_canMakeRest(resourceWithoutTrailingSlashes, idProps[0])[dataInterfaceName];
				return makePromise(makeAjax( result.url,
					params, result.method,
					this.ajax || canAjax_1_1_4_canAjax,
					findContentType(this.url, result.method),
					meta));
			}

			return baseConnection[name].call(this, params);
		};
	});

	return behavior;
});
/**
 * @property {String|Object} can-connect/data/url/url.url url
 * @parent can-connect/data/url/url.option
 *
 * Specify the url and methods that should be used for the "Data Methods".
 *
 * @option {String} If a string is provided, it's assumed to be a RESTful interface. For example,
 * if the following is provided:
 *
 * ```
 * url: "/services/todos"
 * ```
 *
 * ... the following methods and requests are used:
 *
 *  - `getListData` - `GET /services/todos`
 *  - `getData` - `GET /services/todos/{id}`
 *  - `createData` - `POST /services/todos`
 *  - `updateData` - `PUT /services/todos/{id}`
 *  - `destroyData` - `DELETE /services/todos/{id}`
 *
 * @option {Object} If an object is provided, it can customize each method and URL directly
 * like:
 *
 * ```
 * url: {
 *   getListData: "GET /services/todos",
 *   getData: "GET /services/todo/{id}",
 *   createData: "POST /services/todo",
 *   updateData: "PUT /services/todo/{id}",
 *   destroyData: "DELETE /services/todo/{id}"
 * }
 * ```
 *
 * You can provide a `resource` property that works like providing `url` as a string, but overwrite
 * other values like:
 *
 * ```
 * url: {
 *   resource: "/services/todo",
 *   getListData: "GET /services/todos"
 * }
 * ```
 *
 * Finally, you can provide your own method to totally control how the request is made:
 *
 * ```
 * url: {
 *   resource: "/services/todo",
 *   getListData: "GET /services/todos",
 *   getData: function(param){
 *     return new Promise(function(resolve, reject){
 *       $.get("/services/todo", {identifier: param.id}).then(resolve, reject);
 *     });
 *   }
 * }
 * ```
 */


 /**
  * @property {function} can-connect/data/url/url.ajax ajax
  * @parent can-connect/data/url/url.option
  *
  * Specify the ajax functionality that should be used to make the request.
  *
  * @option {function} Provides an alternate function to be used to make
  * ajax requests.  By default [can-ajax] provides the ajax
  * functionality. jQuery's ajax method can be substituted as follows:
  *
  * ```js
  * connect([
  *   require("can-connect/data/url/url")
  * ],{
  *   url: "/things",
  *   ajax: $.ajax
  * });
  * ```
  *
  *   @param {Object} settings Configuration options for the AJAX request.
  *   @return {Promise} A Promise that resolves to the data.
  */

// ## methodMetaData
// Metadata on different methods that is passed to makeAjax
var methodMetaData = {
	/**
	 * @function can-connect/data/url/url.getListData getListData
	 * @parent can-connect/data/url/url.data-methods
	 *
	 * @signature `getListData(set)`
	 *
	 *   Retrieves list data for a particular set given the [can-connect/data/url/url.url] settings.
	 *   If `url.getListData` is a function, that function will be called.  If `url.getListData` is a
	 *   string, a request to that string will be made. If `url` is a string, a `GET` request is made to
	 *   `url`.
	 *
	 *   @param {can-query-logic/query} query A object that represents the set of data needed to be loaded.
	 *   @return {Promise<can-connect.listData>} A promise that resolves to the ListData format.
	 */
	getListData: {},
	/**
	 * @function can-connect/data/url/url.getData getData
	 * @parent can-connect/data/url/url.data-methods
	 *
	 * @signature `getData(params)`
	 *
	 *   Retrieves raw instance data given the [can-connect/data/url/url.url] settings.
	 *   If `url.getData` is a function, that function will be called.  If `url.getData` is a
	 *   string, a request to that string will be made. If `url` is a string, a `GET` request is made to
	 *   `url+"/"+IDPROP`.
	 *
	 *   @param {Object} params A object that represents the set of data needed to be loaded.
	 *   @return {Promise<Object>} A promise that resolves to the instance data.
	 */
	getData: {},
	/**
	 * @function can-connect/data/url/url.createData createData
	 * @parent can-connect/data/url/url.data-methods
	 *
	 * @signature `createData(instanceData, cid)`
	 *
	 *   Creates instance data given the serialized form of the data and
	 *   the [can-connect/data/url/url.url] settings.
	 *   If `url.createData` is a function, that function will be called.  If `url.createData` is a
	 *   string, a request to that string will be made. If `url` is a string, a `POST` request is made to
	 *   `url`.
	 *
	 *   @param {Object} instanceData The serialized data of the instance.
	 *   @param {Number} cid A unique id that represents the instance that is being created.
	 *   @return {Promise<Object>} A promise that resolves to the newly created instance data.
	 */
	createData: {},
	/**
	 * @function can-connect/data/url/url.updateData updateData
	 * @parent can-connect/data/url/url.data-methods
	 *
	 * @signature `updateData(instanceData)`
	 *
	 * Updates instance data given the serialized form of the data and
	 *   the [can-connect/data/url/url.url] settings.
	 *   If `url.updateData` is a function, that function will be called.  If `url.updateData` is a
	 *   string, a request to that string will be made. If `url` is a string, a `PUT` request is made to
	 *   `url+"/"+IDPROP`.
	 *
	 *   @param {Object} instanceData The serialized data of the instance.
	 *   @return {Promise<Object>} A promise that resolves to the updated instance data.
	 */
	updateData: {},
	/**
	 * @function can-connect/data/url/url.destroyData destroyData
	 * @parent can-connect/data/url/url.data-methods
	 *
	 * @signature `destroyData(instanceData)`
	 *
	 * Deletes instance data given the serialized form of the data and
	 *   the [can-connect/data/url/url.url] settings.
	 *   If `url.destroyData` is a function, that function will be called.  If `url.destroyData` is a
	 *   string, a request to that string will be made. If `url` is a string, a `DELETE` request is made to
	 *   `url+"/"+IDPROP`.
	 *
	 *   @param {Object} instanceData The serialized data of the instance.
	 *   @return {Promise<Object>} A promise that resolves to the deleted instance data.
	 */
	destroyData: {includeData: false}
};

var findContentType = function( url, method ) {
	if ( typeof url === 'object' && url.contentType ) {
		var acceptableType = url.contentType === 'application/x-www-form-urlencoded' ||
			url.contentType === 'application/json';
		if ( acceptableType ) {
			return url.contentType;
		} else {
			//!steal-remove-start
			dev.warn("Unacceptable contentType on can-connect request. " +
				"Use 'application/json' or 'application/x-www-form-urlencoded'");
			//!steal-remove-end
		}
	}
	return method === "GET" ? "application/x-www-form-urlencoded" : "application/json";
};

function urlParamEncoder (key, value) {
	return encodeURIComponent(value)
}

var makeAjax = function ( ajaxOb, data, type, ajax, contentType, reqOptions ) {

	var params = {};

	// A string here would be something like `"GET /endpoint"`.
	if (typeof ajaxOb === 'string') {
		// Split on spaces to separate the HTTP method and the URL.
		var parts = ajaxOb.split(/\s+/);
		params.url = parts.pop();
		if (parts.length) {
			params.type = parts.pop();
		}
	} else {
		// If the first argument is an object, just load it into `params`.
		canReflect_1_16_7_canReflect.assignMap(params, ajaxOb);
	}

	// If the `data` argument is a plain object, copy it into `params`.
	params.data = typeof data === "object" && !Array.isArray(data) ?
		canReflect_1_16_7_canReflect.assignMap(params.data || {}, data) : data;

	// Substitute in data for any templated parts of the URL.
	params.url = replaceWith(params.url, params.data, urlParamEncoder, true);
	params.contentType = contentType;

	if(reqOptions.includeData === false) {
		delete params.data;
	}

	return ajax(canReflect_1_16_7_canReflect.assignMap({
		type: type || 'post',
		dataType: 'json'
	}, params));
};

var url = urlBehavior;

//!steal-remove-start

var url = validate(urlBehavior, ['url']);
//!steal-remove-end

var dataUrl = url;

/**
 * @module can-connect/base/base base
 * @group can-connect/base/base.options 0 behavior options
 * @group can-connect/base/base.identifiers 1 identifiers
 * @parent can-connect.behaviors
 *
 * The first behavior added to every `can-connect` connection. Provides methods to uniquely identify instances and
 * lists.
 *
 * @signature `base(connectionOptions)`
 *
 * Provides instance and list identifiers. Added automatically to every connection created by the `connect` helper.
 * So even if we do:
 *
 * ```js
 * var connection = connect([],{});
 * ```
 *
 * The connection still has the identification functionality provided by `base`:
 *
 * ```js
 * connection.id({id: 1, ...}) //-> 1
 * ```
 *
 * `can-connect` connections are typically created by the `connect` helper rather than by calling the behaviors directly.
 * This ensures the behaviors are called in the required order and is more elegant than requiring the user to chain
 * together the calls to all the behaviors.
 *
 * See the [can-connect/base/base.id id] and [can-connect/base/base.listQuery listQuery] methods for more specifics on
 * how ids are determined.
 *
 * @param {Object} connectionOptions Object containing the configuration for the behaviors of the connection. Added to the
 * prototype of the returned connection object. `base` is almost always configured with an [can-connect/base/base.queryLogic] option since it
 * [can-connect/base/base.id defines how to read the identity properties] and the majority of behaviors also require the queryLogic.
 *
 * @return {Object} A `can-connect` connection containing the methods provided by `base`.
 */
var base = canConnect_3_0_0Pre_14_behavior("base",function(baseConnection){
	var setQueryLogic;
	return {
		/**
		 * @function can-connect/base/base.id id
		 * @parent can-connect/base/base.identifiers
		 *
		 * Uniquely identify an instance or raw instance data.
		 *
		 * @signature `connection.id(instance)`
		 *
		 *   Returns the instance id as determined by [can-connect/base/base.queryLogic]'s id values.
		 *
		 *   @param {Instance|Object} instance An instance or raw properties for an instance.
		 *
		 *   @return {String|Number} A string or number uniquely representing `instance`.
		 *
		 *
		 * @body
		 *
		 * ## Use
		 *
		 * Many behaviors, such as the [can-connect/constructor/store/store], need to have a unique identifier for an
		 * instance or instance data.  This `connection.id` method should return that.
		 *
		 * Typically, an item's id is a simply property value on the object. For example, "Todo" data might look like:
		 *
		 * ```js
		 * {_id: 5, name: "do the dishes"}
		 * ```
		 *
		 * In this case, [can-connect/base/base.queryLogic]'s `id` property should be set to "_id":
		 *
		 * ```js
		 * import QueryLogic from "can-query-logic";
		 *
		 * var queryLogic = new QueryLogic({
		 *   identity: ["_id"]
	 	 * });
		 *
		 * connect([...],{queryLogic: queryLogic});
		 * ```
		 *
		 */
		id: function(instance){
			if(this.queryLogic) {
				return canReflect_1_16_7_canReflect.getIdentity(instance, this.queryLogic.schema);
			} else if(this.idProp) {
				return instance[this.idProp];
			} else {
				throw new Error("can-connect/base/base - Please add a queryLogic option.")
			}
		},

		/**
		 * @function can-connect/base/base.listQuery listQuery
		 * @parent can-connect/base/base.identifiers
		 *
		 * Uniquely identify the set of data a list contains.
		 *
		 * @signature `connection.listQuery(list)`
		 *
		 *   Returns the value of the property referenced by [can-connect/base/base.listQueryProp] if it exists.
		 *   By default, this will return `list[Symbol.for("can.listQuery")]`.
		 *
		 *   @param {can-connect.List} list A list instance.
		 *
		 *   @return {can-query-logic/query} An object that can be passed to `JSON.stringify` to represent the list.
		 *
		 * @body
		 *
		 * ## Use
		 *
		 * Many behaviors, such as the [can-connect/constructor/store/store], need to have a unique identifier for a list.
		 * This `connection.listQuery` method should return that.
		 *
		 * Typically, a list's set identifier is a property on the list object.  As example, a list of Todos might look like
		 * the following:
		 *
		 * ```js
		 * var dueTodos = todoConnection.getList({filter: {due: "today"}});
		 * dueTodos; // [{_id: 5, name: "do dishes", due:"today"}, {_id: 6, name: "walk dog", due:"today"}, ...]
		 * dueTodos[Symbol.for("can.listQuery")]; //-> {filter: {due: "today"}}
		 * todoConnection.listQuery(dueTodos); //-> {filter: {due: "today"}}
		 * ```
		 *
		 * In the above example the [can-connect/base/base.listQueryProp] would be the default `@can.listQuery`.
		 */
		listQuery: function(list){
			return list[this.listQueryProp];
		},

		/**
		 * @property {Symbol} can-connect/base/base.listQueryProp listQueryProp
		 * @parent can-connect/base/base.identifiers
		 *
		 * Specifies the property that uniquely identifies a list.
		 *
		 * @option {Symbol} The property that uniquely identifies the list.
		 * Defaults to `Symbol.for("can.listQuery")`.
		 *
		 * ```js
		 * var dataUrl = require("can-connect/data/url/");
		 * var connection = connect([dataUrl], {
		 *   listQueryProp: "set"
		 * });
		 *
		 * var list = [{id: 1, ...}, {id: 2, ...}]
		 * list.set = {complete: true};
		 *
		 * connection.listQuery(list) //-> {complete: true}
		 * ```
		 *
		 */
		listQueryProp: canSymbol_1_6_1_canSymbol.for("can.listQuery"),

		init: function(){},


		/**
		 * @property {can-query-logic} can-connect/base/base.queryLogic queryLogic
		 * @parent can-connect/base/base.options
		 *
		 * Configuration for list comparison, instance identification and membership
		 * calculations. A way for the `can-connect` behaviors to understand what the properties of a request mean and act
		 * on them.
		 *
		 * @option {can-query-logic} A [can-query-logic queryLogic] that is used to perform calculations using set
		 * definition objects passed to [can-connect/connection.getListData] and [can-connect/connection.getList].
		 * Needed to enable [can-connect/fall-through-cache/fall-through-cache caching],
		 * [can-connect/data/combine-requests/combine-requests request combining], [can-connect/real-time/real-time] and other
		 * behaviors. By default no queryLogic is provided.
		 *
		 * An example of the types of calculations behaviors will make using the queryLogic:
		 * ```js
		 * var queryLogic = new QueryLogic({
		 *   identity: ['_uid'],
		 *   keys: {
		 *     _uid: Number
		 *   }
		 * });
		 *
		 * var todoConnection = connect([...behaviors...],{
		 *   queryLogic: queryLogic
		 * });
		 *
		 * todoConnection.queryLogic.memberIdentity({_uid: 5, ...}); //-> 5
		 * todoConnection.id({_uid: 5, ...}); //-> 5
		 * todoConnection.queryLogic.intersection(
		 *   {page: {first: 0, last: 10}},
		 *   {page: {first:  d5, last: 20}}); //-> {first:5, last:10}
		 * ```
		 */

		get queryLogic(){
			if(setQueryLogic) {
				return setQueryLogic;
			} else if(baseConnection.queryLogic) {
				return baseConnection.queryLogic;
			} else if(baseConnection.algebra) {
				return baseConnection.algebra;
			}
		},
		set queryLogic(newVal) {
			setQueryLogic = newVal;
		}

		/**
		 * @property {can-query-logic} can-connect/base/base.algebra algebra
		 * @parent can-connect/base/base.options
		 *
		 * @description Legacy configuration for [can-set-legacy]. Use [can-connect/base/base.queryLogic] instead.
		 */

		/**
		 * @property {can-connect/DataInterface} can-connect/base/base.cacheConnection cacheConnection
		 * @parent can-connect/base/base.options
		 *
		 * An underlying `can-connect` connection used when fetching data from a cache.
		 *
		 * @option {can-connect/DataInterface} A connection that provides access to a cache via [can-connect/DataInterface]
		 * requests. Several behaviors including [can-connect/fall-through-cache/fall-through-cache] expect this property.
		 *
		 * @body
		 *
		 * ## Use
		 *
		 * ```js
		 * import {memoryStore, connect, QueryLogic} from "can";
		 *
		 * var cacheConnection = memoryStore({
		 *   queryLogic: new QueryLogic({identity: ["id"]})
		 * });
		 *
		 * var todoConnection = connect([...behaviors...],{
		 *   cacheConnection: cacheConnection
		 * });
		 * ```
		 */
	};
});

function restModel(options){
	var connection = [base,dataUrl, parse, constructor_1, canMap].reduce(function(prev, behavior){
		return behavior(prev);
	}, options);
	connection.init();
	return connection;
}

var canRestModel_0_1_4_canRestModel = canNamespace_1_0_0_canNamespace.restModel = restModel;

var behavior$1 = canConnect_3_0_0Pre_14_behavior;

/**
 *
 * @param {Array<String,Behavior,function>} behaviors - An array of behavior names or custom behaviors.
 * The order of named execution gets run in order.
 * @param {Object} options
 * @hide
 */
var connect = function(behaviors, options){

	behaviors = behaviors.map(function(behavior, index){
		var sortedIndex = -1;
		if(typeof behavior === "string") {
			sortedIndex = connect.order.indexOf(behavior);
			behavior = behavior.map[behavior];
		} else if(behavior.isBehavior) {
			sortedIndex = connect.order.indexOf(behavior.behaviorName);
		} else {
			behavior = connect.behavior(behavior);
		}

		return {
			originalIndex: index,
			sortedIndex: sortedIndex,
			behavior: behavior
		};
	});

	behaviors.sort(function(b1, b2){
		// if both have a sorted index
		if(~b1.sortedIndex && ~b2.sortedIndex) {
			return b1.sortedIndex - b2.sortedIndex;
		}
		return b1.originalIndex - b2.originalIndex;
	});

	behaviors = behaviors.map(function(b){
		return b.behavior;
	});

	var behavior = connect.base( connect.behavior("options",function(){return options; })() );

	behaviors.forEach(function(behave){
		behavior = behave(behavior);
	});
	if(behavior.init) {
		behavior.init();
	}
	return behavior;
};



connect.order = ["data/localstorage-cache","data/url","data/parse","cache-requests","data/combine-requests",

	"constructor","constructor/store","can/map","can/ref",
	"fall-through-cache",

	"data/worker","real-time",

	"data/callbacks-cache","data/callbacks","constructor/callbacks-once"
];

connect.behavior = behavior$1;



var canConnect_3_0_0Pre_14_connect= connect;

canConnect_3_0_0Pre_14_connect.base = base;

var canConnect_3_0_0Pre_14_canConnect = canNamespace_1_0_0_canNamespace.connect = canConnect_3_0_0Pre_14_connect;

var assign$5 = canReflect_1_16_7_canReflect.assignMap;


var WeakReferenceSet = function(){
	this.set = [];
};

// if weakmap, we can add and never worry ...
// otherwise, we need to have a count ...

assign$5(WeakReferenceSet.prototype,{

	has: function(item){
		return this._getIndex(item) !== -1;
	},
	addReference: function(item, referenceCount){

		var index = this._getIndex(item);
		var data = this.set[index];

		if(!data) {
			data = {
				item: item,
				referenceCount: 0
			};
			this.set.push(data);
		}
		data.referenceCount += (referenceCount || 1);
	},
	deleteReference: function(item){
		var index = this._getIndex(item);
		var data = this.set[index];
		if(data){
			data.referenceCount--;
			if( data.referenceCount === 0 ) {
				this.set.splice(index,1);
			}
		}
	},
	delete: function(item){
		var index = this._getIndex(item);
		if(index !== -1) {
			this.set.splice(index,1);
		}
	},
	get: function(item){
		var data = this.set[this._getIndex(item)];
		if(data) {
			return data.item;
		}
	},
	referenceCount: function(item) {
		var data = this.set[this._getIndex(item)];
		if(data) {
			return data.referenceCount;
		}
	},
	_getIndex: function(item){
		var index;
		this.set.every(function(data, i){
			if(data.item === item) {

				index = i;
				return false;
			}
		});
		return index !== undefined ? index : -1;
	},
	/**
	 * @function can-connect/helpers/weak-reference-map.prototype.forEach forEach
	 * @signature `weakReferenceMap.forEach(callback)`
	 *
	 *   Calls `callback` for every value in the store.
	 *
	 *   @param  {function(*,String)} callback(item,key) A callback handler.
	 */
	forEach: function(cb){
		return this.set.forEach(cb);
	}
});

var weakReferenceSet = WeakReferenceSet;

var sortedSetJson = function(set){
	if(set == null) {
		return set;
	} else {
		return JSON.stringify(canReflect_1_16_7_canReflect.cloneKeySort(set));
	}

};

var store = createCommonjsModule(function (module) {
/**
 * @module {connect.Behavior} can-connect/constructor/store/store constructor/store
 * @parent can-connect.behaviors
 * @group can-connect/constructor/store/store.stores 0 stores
 * @group can-connect/constructor/store/store.callbacks 1 CRUD callbacks
 * @group can-connect/constructor/store/store.crud 2 CRUD methods
 * @group can-connect/constructor/store/store.hydrators 3 hydrators
 *
 * Adds support for keeping references to active lists and instances. Prevents different copies of an instance from
 * being used by the application at once. Allows other behaviors to look up instances currently active in the
 * application.
 *
 *
 * @signature `constructorStore( baseConnection )`
 *
 * Overwrites `baseConnection` so it contains a store for instances and lists.  This behavior:
 * - extends the [can-connect/constructor/store/store.hydrateInstance] and
 * [can-connect/constructor/store/store.hydrateList] methods to return instances or lists from the store, if available
 * - overwrites "CRUD" methods to make sure that while requests are pending, new lists and instances have references
 * kept in the store. This prevents duplicated instances from being created during concurrent requests.
 * - provides methods to add and remove items in the store by counting references
 *
 * @param {{}} baseConnection `can-connect` connection object that is having the `constructor/store` behavior added
 * on to it. Should already contain a behavior that provides the InstanceInteface
 * (e.g [can-connect/constructor/constructor]). If the `connect` helper is used to build the connection, the behaviors
 * will automatically be ordered as required.
 *
 * @return {Object} a `can-connect` connection containing the method implementations provided by `constructor/store`.
 *
 * @body
 *
 * ## Use
 *
 * The `constructor-store` behavior is used to:
 *  - provide a store of instances and lists in use by the client
 *  - prevent multiple instances from being generated for the same [can-connect/base/base.id] or multiple
 *    lists for the same [can-connect/base/base.listQuery].
 *
 * The store provides access to an instance by its [can-connect/base/base.id] or a list by its
 * [can-connect/base/base.listQuery]. This is used by other behaviors to lookup instances that should have changes applied.
 * Two examples, when there is a new instance that should be added to a list ([can-connect/real-time/real-time]) or
 * when newer data is available for a cached instance that is used in the page
 * ([can-connect/fall-through-cache/fall-through-cache]).
 *
 * Below you can see how `constructor-store`'s behavior be used to prevent multiple instances from being generated. This
 * example allows you to create multiple instances of a `todoEditor` that loads and edits a todo instance:
 *
 * @demo demos/can-connect/constructor-store.html
 *
 * You can see in this example that you can edit one todo and the other todos update.  This is because each `todoEditor`
 * is acting on same instance in memory. When it updates the todo's name here:
 *
 * ```
 * var updateData = function(newName) {
 *   todo.name = newName; // update name on todo instance
 *   ...
 * };
 * ```
 *
 * The other widgets update because they are bound to the same instance:
 *
 * ```
 * todo.on("name", updateElement); // when todo name changes update input element
 * todosConnection.addInstanceReference(todo); // previous line is a new usage of todo, so increase reference count
 * ```
 *
 * Each `todoEditor` receives the same instance because it was added to the
 * [can-connect/constructor/store/store.instanceStore connnection.instanceStore] by
 * [can-connect/constructor/store/store.addInstanceReference]. During all instance retrievals, a connection using the
 * `constructor/store` behavior checks the [can-connect/constructor/store/store.instanceStore] for an instance with a
 * matching `id` and return that if it exists. This example always requests `id: 5`, so all the `todoEditor`s use the
 * same instance held in the [can-connect/constructor/store/store.instanceStore].
 *
 * This widget cleans itself up when it is removed by removing the listener on the `todo` instance and
 * [can-connect/constructor/store/store.deleteInstanceReference reducing the instance reference count]:
 *
 * ```
 * todo.off("name", updateElement); // stop listening to todo name change
 * todosConnection.deleteInstanceReference(todo); // previous line removed a usage of todo, so reduce reference count
 * ```
 * This is done to prevent a memory leak produced by keeping instances in the `instanceStore` when they are no longer
 * needed by the application.
 *
 * **Note:** a hazard of sharing the same instance is that if new instance data is loaded from the server during
 * on-going editing of the instance, the new server data will replace the data that is edited but not yet saved.
 * This is because whenever data is loaded from the server, it is passed to
 * [can-connect/constructor/constructor.updatedInstance] which updates the shared instance properties with the new
 * server data.
 */






// shared across all connections
var pendingRequests = 0;
var noRequestsTimer = null;
var requests = {
	increment: function(connection){
		pendingRequests++;
		clearTimeout(noRequestsTimer);
	},
	decrement: function(connection){
		pendingRequests--;
		if(pendingRequests === 0) {
			noRequestsTimer = setTimeout(function(){
				requests.dispatch("end");
			},module.exports.requestCleanupDelay);
		}
		if(pendingRequests < 0) {
			pendingRequests = 0;
		}
	},
	count: function(){
		return pendingRequests;
	}
};
map$1(requests);


var constructorStore = canConnect_3_0_0Pre_14_canConnect.behavior("constructor/store",function(baseConnection){

	var behavior = {
		/**
		 * @property {can-connect/helpers/weak-reference-map} can-connect/constructor/store/store.instanceStore instanceStore
		 * @parent can-connect/constructor/store/store.stores
		 *
		 * A mapping of instances keyed by their [can-connect/base/base.id].
		 *
		 * @type {can-connect/helpers/weak-reference-map}
		 *
		 * Stores instances by their [can-connect/base/base.id]. Holds instances based on reference counts which
		 * are incremented by [can-connect/constructor/store/store.addInstanceReference] and decremented by
		 * [can-connect/constructor/store/store.deleteInstanceReference]. Once a reference count is 0, the instance is no
		 * longer held in the store. Once a reference count is greater than 0, the instance is added to the store.
		 *
		 * ```js
		 * connection.addInstanceReference(todo5);
		 * connection.instanceStore.get("5") //-> todo5
		 * ```
		 */
		instanceStore: new weakReferenceMap(),
		// This really should be a set ... we just need it "weak" so we know how many references through binding
		// it has.
		newInstanceStore: new weakReferenceSet(),
		/**
		 * @property {can-connect/helpers/weak-reference-map} can-connect/constructor/store/store.listStore listStore
		 * @parent can-connect/constructor/store/store.stores
		 *
		 * A mapping of lists keyed by their [can-connect/base/base.listQuery].
		 *
		 * @type {can-connect/helpers/weak-reference-map}
		 *
		 * Stores lists by their [can-connect/base/base.listQuery]. Hold lists based on reference counts which are incremented
		 * by [can-connect/constructor/store/store.addListReference] and decremented by
		 * [can-connect/constructor/store/store.deleteListReference]. Once a reference count is 0, the list is no
		 * longer held in the store. Once a reference count is greater than 0, the list is added to the store.
		 *
		 * ```js
		 * connection.addInstanceReference(allTodos, {});
		 * connection.instanceStore.get({}) //-> allTodos
		 * ```
		 */
		listStore: new weakReferenceMap(),
		 // Set up the plain objects for tracking requested lists and instances for this connection,
		 // and add a handler to the requests counter to flush list and instance references when all
		 // requests have completed
		 //
		 // This function is called automatically when connect() is called on this behavior,
		 // and should not need to be called manually.
		init: function() {
			if(baseConnection.init) {
				baseConnection.init.apply(this, arguments);
			}

			if(!this.hasOwnProperty("_requestInstances")) {
				this._requestInstances = {};
			}
			if(!this.hasOwnProperty("_requestLists")) {
				this._requestLists = {};
			}

			requests.on("end", function onRequestsEnd_deleteStoreReferences(){
				var id;
				for(id in this._requestInstances) {
					this.instanceStore.deleteReference(id);
				}
				this._requestInstances = {};
				for(id in this._requestLists) {
					this.listStore.deleteReference(id);
					this._requestLists[id].forEach(this.deleteInstanceReference.bind(this));
				}
				this._requestLists = {};
			}.bind(this));
		},
		_finishedRequest: function(){
			requests.decrement(this);
		},

		/**
		 * @function can-connect/constructor/store/store.addInstanceReference addInstanceReference
		 * @parent can-connect/constructor/store/store.stores
		 *
		 * Add a reference to the [can-connect/constructor/store/store.instanceStore] so an instance can be easily looked up.
		 *
		 * @signature `connection.addInstanceReference( instance )`
		 * Adds a reference to an instance by [can-connect/base/base.id] to the [can-connect/constructor/store/store.instanceStore].
		 * Keeps a count of the number of references, removing the instance from the store when the count reaches 0.
		 *
		 * @param {can-connect/Instance} instance the instance to add
		 *
		 * @body
		 *
		 * ## Use
		 *
		 * The [can-connect/constructor/store/store.instanceStore] contains a mapping of instances keyed by their
		 * [can-connect/base/base.id]. The [can-connect/constructor/store/store.instanceStore] is used to prevent creating
		 * the same instance multiple times, and for finding active instance for a given id.  Instances need to be added to
		 * this store for this to work.  To do this, call `addInstanceReference`:
		 *
		 * ```
		 * // a basic connection
		 * var constructorStore = require("can-connect/constructor/store/");
		 * var constructor = require("can-connect/constructor/");
		 * var dataUrl = require("can-connect/data/url/");
		 * var todoConnection = connect([dataUrl, constructorStore, constructor], {
		 *   url: "/todos"
		 * });
		 *
		 * var originalTodo;
		 *
		 * // get a todo
		 * todoConnection.get({id: 5}).then(function( todo ){
		 *   // add it to the store
		 *   todoConnection.addInstanceReference(todo);
		 *   originalTodo = todo;
		 * });
		 * ```
		 *
		 * Now, if you were to retrieve the same data sometime later, it would be the same instance:
		 *
		 * ```
		 * todoConnection.get({id: 5}).then(function( todo ){
		 *   todo === originalTodo // true
		 * });
		 * ```
		 *
		 * The `.getData` response data (underlying the call to `todoConnection.get`) is passed, along with the existing todo
		 * instance (`originalTodo`) to [can-connect/constructor/constructor.updatedInstance]. That updates the shared
		 * instance with the newly retrieved data.
		 *
		 * All the referenced instances are held in memory.  Use
		 * [can-connect/constructor/store/store.deleteInstanceReference] to remove them.
		 *
		 * Typically, `addInstanceReference` is called when something expresses interest in the instance, such
		 * as an event binding, and `deleteInstanceReference` is called when the interest is removed.
		 */
		addInstanceReference: function(instance, id) {
			var ID = id || this.id(instance);
			if(ID === undefined) {
				// save in the newInstanceStore store temporarily.
				this.newInstanceStore.addReference(instance);
			} else {
				this.instanceStore.addReference( ID, instance );
			}

		},

		/**
		 * @function can-connect/constructor/store/store.callbacks.createdInstance createdInstance
		 * @parent can-connect/constructor/store/store.callbacks
		 *
		 * Calls `createdInstance` on the underlying behavior and moves the new instance from the `newInstanceStore` to
		 * `instanceStore` if needed.
		 *
		 * @signature `connection.createdInstance( instance, props )`
		 * Calls the base behavior. Then calls [can-connect/constructor/store/store.stores.moveCreatedInstanceToInstanceStore]
		 * to move any pre-creation instance references to the standard instance reference store.
		 *
		 * @param {can-connect/Instance} instance the instance that was created
		 * @param {Object} props the data returned from [can-connect/connection.createData]
		 */
		createdInstance: function(instance, props){
			// when an instance is created, and it is in the newInstance store
			// transfer it to the instanceStore
			baseConnection.createdInstance.apply(this, arguments);
			this.moveCreatedInstanceToInstanceStore(instance);
		},

		/**
		 * @function can-connect/constructor/store/store.stores.moveCreatedInstanceToInstanceStore moveCreatedInstanceToInstanceStore
		 * @parent can-connect/constructor/store/store.stores
		 *
		 * Moves recently created instances into the [can-connect/constructor/store/store.instanceStore].
		 *
		 * @signature `moveCreatedInstanceToInstanceStore( instance )`
		 * Checks if an instance has an `id` and is in the `newInstanceStore`. If so, it adds it into the
		 * [can-connect/constructor/store/store.instanceStore] and removes it from the `newInstanceStore`.
		 *
		 * A new instances may have been added to the `newInstanceStore` if [can-connect/constructor/store/store.addInstanceReference]
		 * is called on is before the instance has been saved. This is done so we can keep track of references for unsaved
		 * instances and update the references to be keyed by `id` when one is available. Without this a request for a
		 * currently referenced instance that was just saved for the first time will erroneously result in a new instance.
		 *
		 * @param {can-connect/Instance} instance an instance.  If it was "referenced" (bound to) prior to
		 * being created, this will check for that condition and move this instance into the
		 * [can-connect/constructor/store/store.instanceStore].
		 */
		moveCreatedInstanceToInstanceStore: function(instance){
			var ID = this.id(instance);
			if(this.newInstanceStore.has(instance) && ID !== undefined) {
				var referenceCount = this.newInstanceStore.referenceCount(instance);
				this.newInstanceStore.delete(instance);
				this.instanceStore.addReference( ID, instance, referenceCount );
			}
		},
		addInstanceMetaData: function(instance, name, value){
			var data = this.instanceStore.set[this.id(instance)];
			if(data) {
				data[name] = value;
			}
		},
		getInstanceMetaData: function(instance, name){
			var data = this.instanceStore.set[this.id(instance)];
			if(data) {
				return data[name];
			}
		},
		deleteInstanceMetaData: function(instance, name){
			var data = this.instanceStore.set[this.id(instance)];

			delete data[name];
		},
		/**
		 * @function can-connect/constructor/store/store.deleteInstanceReference deleteInstanceReference
		 * @parent can-connect/constructor/store/store.stores
		 *
		 * Remove a reference from the [can-connect/constructor/store/store.instanceStore] so an instance can be garbage
		 * collected.
		 *
		 * @signature `connection.addInstanceReference( instance )`
		 * Decrements the number of references to an instance in the [can-connect/constructor/store/store.instanceStore].
		 * Removes the instance if there are no longer any references.
		 *
		 * @param {can-connect/Instance} instance the instance to remove
		 *
		 * ### Usage
		 *
		 * `deleteInstanceReference` is called to remove references to instances in the
		 * [can-connect/constructor/store/store.instanceStore] so that instances maybe garbage collected.  It's usually
		 * called when the application or some part of the application no longer is interested in an instance.
		 *
		 * [can-connect/constructor/store/store.addInstanceReference] has an example of adding an instance to the store.
		 * The following continues that example to remove the `originalTodo` instance from the store:
		 *
		 * ```
		 * todoConnection.deleteInstanceReference(originalTodo);
		 * ```
		 *
		 * Also see the [can-connect/constructor/store/store#Use usage example on the index page] for a more complete
		 * example of the lifecycle of a reference.
		 */
		deleteInstanceReference: function(instance) {
			var ID = this.id(instance);
			if(ID === undefined) {
				// if there is no id, remove this from the newInstanceStore
				this.newInstanceStore.deleteReference(instance);
			} else {
				this.instanceStore.deleteReference( this.id(instance), instance );
			}

		},
		/**
		 * @property {WeakReferenceMap} can-connect/constructor/store/store.addListReference addListReference
		 * @parent can-connect/constructor/store/store.stores
		 *
		 * Add a reference to the [can-connect/constructor/store/store.listStore] so a list can be easily looked up.
		 *
		 * @signature `connection.addListReference( list[, set] )`
		 * Adds a reference to a list by `set` (or by [can-connect/base/base.listQuery]) to the
		 * [can-connect/constructor/store/store.listStore].  Keeps a count of the number of references, removing the list
		 * from the store when the count reaches 0.
		 *
		 * @param {can-connect.List} list The list to add.
		 * @param {can-query-logic/query} [query] The set this list represents if it can't be identified with [can-connect/base/base.listQuery].
		 *
		 * @body
		 *
		 * ## Use
		 *
		 * The [can-connect/constructor/store/store.listStore] contains a mapping of lists keyed by their `set`. The
		 * [can-connect/constructor/store/store.listStore] is used to prevent creating the same list multiple times and for
		 * identifying a list for a given set. Lists need to be added to this store for this to work.  To do this, call
		 * `addListReference`:
		 *
		 * ```
		 * // A basic connection:
		 * var constructorStore = require("can-connect/constructor/store/");
		 * var constructor = require("can-connect/constructor/");
		 * var dataUrl = require("can-connect/data/url/");
		 * var todoConnection = connect([dataUrl, constructorStore, constructor], {
		 *   url: "/todos"
		 * });
		 *
		 * var dueToday;
		 *
		 * // get a todo list
		 * todoConnection.getList({due: "today"}).then(function( todos ){
		 *   // add it to the store
		 *   todoConnection.addListReference(todos, {due: "today"});
		 *   dueToday = todos;
		 * });
		 * ```
		 *
		 * Now, if you were to retrieve the same set of data sometime later, it would be the same list instance:
		 *
		 * ```
		 * todoConnection.get({due: "today"}).then(function( todos ){
		 *   todos === dueToday //-> true
		 * });
		 * ```
		 *
		 * The `.getListData`  response data (underlying the call to `todoConnection.getList`) is passed, along with the
		 * existing list (`dueToday`) to [can-connect/constructor/constructor.updatedList]. That updates the shared list
		 * instance with the newly retrieved data.
		 *
		 * All the referenced lists stay in memory.  Use [can-connect/constructor/store/store.deleteListReference]
		 * to remove them.
		 *
		 * Typically, `addListReference` is called when something expresses interest in the list, such
		 * as an event binding, and `deleteListReference` is called when interest is removed.
		 *
		 */
		addListReference: function(list, set) {
			var id = sortedSetJson( set || this.listQuery(list) );
			if(id) {
				this.listStore.addReference( id, list );
				list.forEach(function(instance) {
					this.addInstanceReference(instance);
				}.bind(this));
			}
		},
		/**
		 * @function can-connect/constructor/store/store.deleteListReference deleteListReference
		 * @parent can-connect/constructor/store/store.stores
		 *
		 * Removes a reference from the [can-connect/constructor/store/store.listStore] so a list can can be garbage
		 * collected.
		 *
		 * @signature `connection.addInstanceReference( instance )`
		 * Decrements the number of references to a list in the [can-connect/constructor/store/store.listStore].
		 * Removes the list if there are no longer any references.
		 *
		 * @param {can-connect/Instance} list the list to remove
		 *
		 * ### Usage
		 *
		 * `deleteListReference` is called to remove references to instances in the
		 * [can-connect/constructor/store/store.listStore] so that lists maybe garbage collected.  It's usually called when
		 * the application or some part of the application no longer is interested in a list.
		 *
		 * [can-connect/constructor/store/store.addListReference] has an example of adding a list to the store.  The
		 * following continues that example to remove the `dueToday` list from the store:
		 *
		 * ```
		 * todoConnection.deleteListReference(dueToday);
		 * ```
		 *
		 * Also see the [can-connect/constructor/store/store#Use usage example on the index page] for a more complete
		 * example of the lifecycle of a reference.
		 */
		deleteListReference: function(list, set) {
			var id = sortedSetJson( set || this.listQuery(list) );
			if(id) {
				this.listStore.deleteReference( id, list );
				list.forEach(this.deleteInstanceReference.bind(this));
			}
		},
		/**
		 * @function can-connect/constructor/store/store.hydratedInstance hydratedInstance
		 * @parent can-connect/constructor/store/store.hydrators
		 *
		 * Keeps new instances in the [can-connect/constructor/store/store.instanceStore] for the lifetime of any
		 * concurrent requests.
		 *
		 * @signature `hydratedInstance(instance)`
		 * Adds a reference for new instances for the lifetime of any concurrent requests. Called when a new instance is
		 * created during [can-connect/constructor/store/store.hydrateInstance hydration]. This prevents concurrent requests
		 * for the same data from returning different instances.
		 *
		 * @param {can-connect/Instance} instance the newly hydrated instance
		 */
		// ## hydratedInstance
		hydratedInstance: function(instance){
			if( requests.count() > 0) {
				var id = this.id(instance);
				if(! this._requestInstances[id] ) {
					this.addInstanceReference(instance);
					this._requestInstances[id] = instance;
				}

			}
		},

		/**
		 * @function can-connect/constructor/store/store.hydrateInstance hydrateInstance
		 * @parent can-connect/constructor/store/store.hydrators
		 *
		 * Returns an instance given raw data, returning it from the [can-connect/constructor/store/store.instanceStore] if
		 * available.
		 *
		 * @signature `connection.hydrateInstance(props)`
		 * Overwrites the base `hydrateInstance` so that if a matching instance is in the
		 * [can-connect/constructor/store/store.instanceStore], that instance will be
		 * [can-connect/constructor/constructor.updatedInstance updated] with `props` and returned.  If there isn't a
		 * matching instance, the base `hydrateInstance` will be called.
		 *
		 * @param {Object} props the raw data used to create an instance
		 * @return {can-connect/Instance} a typed instance either created or updated with the data from `props`.
		 */
		hydrateInstance: function(props){
			var id = this.id(props);
			if((id || id === 0) && this.instanceStore.has(id) ) {
				var storeInstance = this.instanceStore.get(id);
				// TODO: find a way to prevent this from being called so many times.
				this.updatedInstance(storeInstance, props);
				return storeInstance;
			}
			var instance = baseConnection.hydrateInstance.call(this, props);
			this.hydratedInstance(instance);
			return instance;
		},

		/**
		 * @function can-connect/constructor/store/store.hydratedList hydratedList
		 * @parent can-connect/constructor/store/store.hydrators
		 *
		 * Keeps new lists in the [can-connect/constructor/store/store.listStore] for the lifetime of any concurrent
		 * requests.
		 *
		 * @signature `hydratedList(list)`
		 * Adds a reference for new lists for the lifetime of any concurrent requests. Called when a new list is
		 * created during [can-connect/constructor/store/store.hydrateList hydration]. This prevents concurrent requests
		 * for the same data from returning different instances.
		 *
		 * @param {can-connect.List} list the newly hydrated list
		 */
		hydratedList: function(list, set){
			if( requests.count() > 0) {
				var id = sortedSetJson( set || this.listQuery(list) );
				if(id) {
					if(! this._requestLists[id] ) {
						this.addListReference(list, set);
						this._requestLists[id] = list;
					}
				}
			}
		},

		/**
		 * @function can-connect/constructor/store/store.hydrateList hydrateList
		 * @parent can-connect/constructor/store/store.hydrators
		 *
		 * Returns a list given raw data, returning it from the [can-connect/constructor/store/store.listStore] if
		 * available.
		 *
		 * @signature `connection.hydrateList( listData, set )`
		 *
		 *   Overwrites the base `hydrateList` so that if a matching list is in the
		 *   [can-connect/constructor/store/store.listStore], that list will be
		 *   [can-connect/constructor/constructor.updatedList updated] with `listData` and returned.
		 *   If there isn't a matching list, the base `hydrateList` will be called.
		 *
		 *   @param {can-connect.listData} listData raw list data to hydrate into a list type
		 *   @param {can-query-logic/query} query the parameters that represent the set of data in `listData`
		 *   @return {List} a typed list from either created or updated with the data from `listData`
		 */
		hydrateList: function(listData, set){
			set = set || this.listQuery(listData);
			var id = sortedSetJson( set );

			if( id && this.listStore.has(id) ) {
				var storeList = this.listStore.get(id);
				this.updatedList(storeList, listData, set);
				return storeList;
			}
			var list = baseConnection.hydrateList.call(this, listData, set);
			this.hydratedList(list, set);
			return list;
		},

		/**
		 * @function can-connect/constructor/store/store.getList getList
		 * @parent can-connect/constructor/store/store.crud
		 *
		 * Extends the underlying [can-connect/connection.getList] so any [can-connect/constructor/store/store.hydrateInstance instances hydrated]
		 * or [can-connect/constructor/store/store.hydrateList lists hydrated] during this request are kept in the store until
		 * all the concurrent requests complete.
		 *
		 * @signature `connection.getList( set )`
		 * Increments an internal request counter so instances hydrated during this request will be stored, and then
		 * decrements the counter after the request is complete. This prevents concurrent requests for the same data from
		 * returning different instances.
		 *
		 * @param {can-query-logic/query} listQuery parameters specifying the list to retrieve
		 * @return {Promise<can-connect/Instance>} `Promise` returned by the underlying behavior's [can-connect/connection.getList]
		 */
		getList: function(listQuery) {
			var self = this;
			requests.increment(this);
			var promise = baseConnection.getList.call(this, listQuery);

			promise.then(function(instances){
				self._finishedRequest();
			}, function(){
				self._finishedRequest();
			});
			return promise;
		},

		/**
		 * @function can-connect/constructor/store/store.get get
		 * @parent can-connect/constructor/store/store.crud
		 *
		 * Extends the underlying [can-connect/connection.get] so any [can-connect/constructor/store/store.hydrateInstance instances hydrated]
		 * during this request are kept in the store until all the concurrent requests complete.
		 *
		 * @signature `connection.get( params )`
		 * Increments an internal request counter so instances hydrated during this request will be stored, and then
		 * decrements the counter after the request is complete. This prevents concurrent requests for the same data from
		 * returning different instances.
		 *
		 * @param {Object} params params used to specify which instance to retrieve.
		 * @return {Promise<can-connect/Instance>} `Promise` returned by the underlying behavior's [can-connect/connection.get]
		 */
		get: function(params) {
			var self = this;
			requests.increment(this);
			var promise = baseConnection.get.call(this, params);

			promise.then(function(instance){
				self._finishedRequest();
			}, function(){
				self._finishedRequest();
			});
			return promise;

		},
		/**
		 * @function can-connect/constructor/store/store.save save
		 * @parent can-connect/constructor/store/store.crud
		 *
		 * Extends the underlying [can-connect/connection.save] so any [can-connect/constructor/store/store.hydrateInstance instances hydrated]
		 * during this request are kept in the store until all the concurrent requests complete.
		 *
		 * @signature `connection.save( instance )`
		 *
		 * Increments an internal request counter so instances hydrated during this request will be stored, and then
		 * decrements the counter after the request is complete. This prevents concurrent requests for the same data from
		 * returning different instances.
		 *
		 * @param {Object} instance a typed instance being saved
		 * @return {Promise<can-connect/Instance>} `Promise` returned by the underlying behavior's [can-connect/connection.save]
		 */
		save: function(instance) {
			var self = this;
			requests.increment(this);

			var updating = !this.isNew(instance);
			if(updating) {
				this.addInstanceReference(instance);
			}

			var promise = baseConnection.save.call(this, instance);

			promise.then(function(instances){
				if(updating) {
					self.deleteInstanceReference(instance);
				}
				self._finishedRequest();
			}, function(){
				self._finishedRequest();
			});
			return promise;
		},
		/**
		 * @function can-connect/constructor/store/store.destroy destroy
		 * @parent can-connect/constructor/store/store.crud
		 *
		 * Extends the underlying [can-connect/connection.destroy] so any [can-connect/constructor/store/store.hydrateInstance instances hydrated]
		 * during this request are kept in the store until all the concurrent requests complete.
		 *
		 * @signature `connection.destroy( instance )`
		 * Increments an internal request counter so instances hydrated during this request will be stored, and then
		 * decrements the counter after the request is complete. This prevents concurrent requests for the same data from
		 * returning different instances.
		 *
		 * @param {Object} instance a typed instance being deleted
		 * @return {Promise<can-connect/Instance>} `Promise` returned by the underlying behavior's [can-connect/connection.destroy]
		 */
		destroy: function(instance) {
			var self = this;
			// Add to instance store, for the duration of the
			// destroy callback
			this.addInstanceReference(instance);
			requests.increment(this);
			var promise = baseConnection.destroy.call(this, instance);

			promise.then(function(instance){
				self._finishedRequest();
				self.deleteInstanceReference(instance);
			}, function(){
				self._finishedRequest();
			});
			return promise;

		},
		/**
		 * @function can-connect/constructor/store/store.updatedList updatedList
		 * @parent can-connect/constructor/store/store.callbacks
		 *
		 * Extends the underlying [can-connect/connection.updatedList] so any instances that have been added or removed
		 * from the list have their reference counts updated accordingly.
		 *
		 * @signature `connection.updatedList( list, listData, set )`
		 * Increments an internal request counter so instances on this list during this request will be stored, and decrements
		 * the same counter for all items previously on the list (found in `listData.data`).
		 *
		 * @param {can-connect.List} list a typed list of instances being updated
		 * @param {Object} listData an object representing the previous state of the list
		 * @param {Object} set the retrieval set used to get the list
		 */
		updatedList: function(list, listData, set) {
			var oldList = list.slice(0);
			if(!listData.data && typeof listData.length === "number") {
				listData = { data: listData };
			}
			if(baseConnection.updatedList) {
				baseConnection.updatedList.call(this, list, listData, set);
				list.forEach(function(instance) {
					this.addInstanceReference(instance);
				}.bind(this));
			} else if(listData.data) {
				listData.data.forEach(function(instance) {
					this.addInstanceReference(instance);
				}.bind(this));
			}
			oldList.forEach(this.deleteInstanceReference.bind(this));
		}
	};

	return behavior;

});
constructorStore.requests = requests;
// The number of ms to wait after all known requests have finished,
//  before starting request cleanup.
// If a new request comes in before timeout, wait until that request
//  has finished (+ delay) before starting cleanup.
// This is configurable, for use cases where more waiting is desired,
//  or for the can-connect tests which expect everything to clean up
//  in 1ms.
constructorStore.requestCleanupDelay = 10;

module.exports = constructorStore;

//!steal-remove-start

module.exports = validate(constructorStore, ['hydrateInstance', 'hydrateList', 'getList', 'get', 'save', 'destroy']);
//!steal-remove-end
});

/**
 * @module {connect.Behavior} can-connect/can/ref/ref can/ref
 * @parent can-connect.behaviors
 * @group can-connect/can/ref/ref.hydrators hydrators
 * @group can-connect/can/ref/ref.methods methods
 *
 * @description Handle references to instances in the data returned by the server. Allows several means of
 * loading referenced instances, determined on-the-fly.
 *
 * @signature `canRef( baseConnection )`
 *
 * Adds a reference type to [can-connect/can/map/map._Map `connection.Map`] that loads the related type or holds onto
 * an existing one. This handles circular references and loads relevant data as needed. The reference type can be loaded
 * by:
 * - it's data being included in the response for the referencing instance
 * - having an existing instance available in the [can-connect/constructor/store/store.instanceStore]
 * - lazy loading via the connection for the reference type
 *
 * @param {{}} baseConnection `can-connect` connection object that is having the `can/ref` behavior added on to it.
 * Expects the [can-connect/can/map/map] behavior to already be added to this base connection. If the `connect` helper
 * is used to build the connection, the behaviors will automatically be ordered as required.
 *
 * @return {{}} a connection with the [can-connect/can/map/map._Map `Map`] having the reference type property
 * (`Map.Ref.type`) created by `can/ref`.
 *
 * @body
 *
 * ## Use
 *
 * `can/ref` is useful when the server might return either a reference to
 * a value or the value itself.  For example, in a MongoDB setup,
 * a request like `GET /game/5` might return:
 *
 * ```
 * {
 *   id: 5,
 *   teamRef: 7,
 *   score: 21
 * }
 * ```
 *
 * But a request like `GET /game/5?$populate=teamRef` might return:
 *
 * ```
 * {
 *   id: 5,
 *   teamRef: {id: 7, name: "Cubs"},
 *   score: 21
 * }
 * ```
 *
 * `can/ref` can handle this ambiguity and even make lazy loading possible.
 *
 * To use `can/ref`, first create a Map and a connection for the referenced type:
 *
 * ```
 * var Team = DefineMap.extend({
 *   id: 'string'
 * });
 *
 * connect([
 *   require("can-connect/constructor/constructor"),
 *   require("can-connect/constructor/store/store"),
 *   require("can-connect/can/map/map"),
 *   require("can-connect/can/ref/ref")
 * ],{
 *     Map: Team,
 *     List: Team.List,
 *     ...
 * })
 * ```
 *
 * The connection is necessary because it creates an instance store which will
 * hold instances of `Team` that the `Team.Ref` type will be able to access.
 *
 * Now we can create a reference to the Team within a Game map and the Game's connection:
 *
 * ```
 * var Game = DefineMap.extend({
 *   id: 'string',
 *   teamRef: {type: Team.Ref.type},
 *   score: "number"
 * });
 *
 * superMap({
 *   Map: Game,
 *   List: Game.List
 * })
 * ```
 *
 * Now, `teamRef` is a [can-connect/can/ref/ref.Map.Ref] type, which will
 * house the id of the reference no matter how the server returns data, e.g.
 * `game.teamRef.id`.
 *
 * For example, without populating the team data:
 *
 * ```
 * Game.get({id: 5}).then(function(game){
 *   game.teamRef.id //-> 7
 * });
 * ```
 *
 * With populating the team data:
 *
 * ```
 * Game.get({id: 5, $populate: "teamRef"}).then(function(game){
 *   game.teamRef.id //-> 7
 * });
 * ```
 *
 * The values of other properties and methods on the [can-connect/can/ref/ref.Map.Ref] type
 * are determined by if the reference was populated or the referenced item already exists
 * in the [can-connect/constructor/store/store.instanceStore].
 *
 * For example, `value`, which points to the referenced instance, will be populated if the reference was populated:
 *
 * ```
 * Game.get({id: 5, $populate: "teamRef"}).then(function(game){
 *   game.teamRef.value.name //-> 5
 * });
 * ```
 *
 * Or, it will be populated if that instance had been loaded through another means and
 * itâ€™s in the instance store:
 *
 * ```
 * Team.get({id: 7}).then(function(team){
 *   // binding adds things to the store
 *   team.on("name", function(){})
 * }).then(function(){
 *   Game.get({id: 5}).then(function(game){
 *     game.teamRef.value.name //-> 5
 *   });
 * })
 * ```
 *
 * `value` is an [can-define.types.get asynchronous getter], which means that even if
 * the referenced value isn't populated or loaded through the store, it can be lazy loaded. This
 * is generally most useful in a template.
 *
 * The following will make an initial request for game `5`, but when the template
 * tried to read and listen to `game.teamRef.value.name`, a request for team `7`
 * will be made.
 *
 * ```
 * var template = stache("{{game.teamRef.value.name}} scored {{game.score}} points");
 * Game.get({id: 5}).then(function(game){
 *   template({game: game});
 * });
 * ```
 *
 *
 */







var makeRef = function(connection) {
	var idProp = canReflect_1_16_7_canReflect.getSchema(connection.queryLogic).identity[0];
	/**
	 * @property {constructor} can-connect/can/ref/ref.Map.Ref Map.Ref
	 * @parent can-connect/can/ref/ref.hydrators
	 * @group can-connect/can/ref/ref.Map.Ref.static static
	 * @group can-connect/can/ref/ref.Map.Ref.prototype prototype
	 *
	 * A reference type with `instanceRef.value` primed to return an existing instance of the
	 * [can-connect/can/map/map._Map] type, if available, or lazy load an instance upon accessing `instanceRef.value`.
	 *
	 * @signature `new Map.Ref(id, value)`
	 * @param  {string} id    string representing the record id
	 * @param  {Object} value properties to be loaded / hydrated
	 * @return {Map.Ref}       instance reference object for the id
	 */
	var Ref = (function(){
		return function(id, value) {
			if (typeof id === "object") {
				value = id;
				id = value[idProp];
			}
			// check if this is in the store
			var storeRef = Ref.store.get(id);
			if (storeRef) {
				if (value && !storeRef._value) {
					if (value instanceof connection.Map) {
						storeRef._value = value;
					} else {
						storeRef._value = connection.hydrateInstance(value);
					}
				}
				return storeRef;
			}
			// if not, create it
			this[idProp] = id;
			if (value) {
				// if the value is already an instance, use it.

				if (value instanceof connection.Map) {
					this._value = value;
				} else {
					this._value = connection.hydrateInstance(value);
				}
			}


			// check if this is being made during a request
			// if it is, save it
			if (store.requests.count() > 0) {
				if (!Ref._requestInstances[id]) {
					Ref.store.addReference(id, this);
					Ref._requestInstances[id] = this;
				}
			}
		};
	})();
	/**
	 * @property {can-connect/helpers/weak-reference-map} can-connect/can/ref/ref.Map.Ref.store store
	 * @parent can-connect/can/ref/ref.Map.Ref.static
	 * @hide // not something that needs to be documented for the average user
	 * A WeakReferenceMap that contains instances being created by their `._cid` property.
	 */
	Ref.store = new weakReferenceMap();
	Ref._requestInstances = {};
	/**
	 * @function can-connect/can/ref/ref.Map.Ref.type type
	 * @parent can-connect/can/ref/ref.Map.Ref.static
	 *
	 * Returns a new instance of `Map.Ref`.
	 *
	 * @signature `Map.Ref.type(reference)`
	 *
	 *   @param {Object|String|Number} reference either data or an id for an instance of [can-connect/can/map/map._Map].
	 *   @return {can-connect/can/ref/ref.Map.Ref} reference instance for the passed data or identifier.
	 */
	Ref.type = function(ref) {
		if (ref && typeof ref !== "object") {
			// get or make the existing reference from the store
			return new Ref(ref);
		} else {
			// get or make the reference in the store, update the instance too
			return new Ref(ref[idProp], ref);
		}
	};
	var defs = {
		/**
		 * @property {Promise} can-connect/can/ref/ref.Map.Ref.prototype.promise promise
		 * @parent can-connect/can/ref/ref.Map.Ref.prototype
		 * @hide // don't know if this is part of the public API
		 *
		 * Returns a resolved promise if the referenced instance is already available, if not, returns a new promise
		 * to retrieve the instance by the id.
		 *
		 * @signature `ref.promise`
		 * @return {Promise} Promise resolving the instance referenced
		 */
		promise: {
			get: function() {
				if (this._value) {
					return Promise.resolve(this._value);
				} else {
					var props = {};
					props[idProp] = this[idProp];
					return connection.Map.get(props);
				}
			}
		},

		_state: {
			get: function(lastSet, resolve) {
				if (resolve) {
					this.promise.then(function() {
						resolve("resolved");
					}, function() {
						resolve("rejected");
					});
				}

				return "pending";
			}
		},

		/**
		 * @property {*} can-connect/can/ref/ref.Map.Ref.prototype.value value
		 * @parent can-connect/can/ref/ref.Map.Ref.prototype
		 *
		 * Returns the actual instance the reference points to. Returns `undefined` if the instance is still being loaded.
		 * Accessing this property will start lazy loading if the instance isn't already available.
		 *
		 * @signature `ref.value`
		 * @return {object} actual instance referenced or `undefined` if lazy loading ongoing
		 */
		value: {
			get: function(lastSet, resolve) {
				if (this._value) {
					return this._value;
				} else if (resolve) {
					this.promise.then(function(value) {
						resolve(value);
					});
				}
			}
		},

		/**
		 * @property {*} can-connect/can/ref/ref.Map.Ref.prototype.reason reason
		 * @parent can-connect/can/ref/ref.Map.Ref.prototype
		 *
		 * Returns the failure message from the lazy loading promise. Returns `undefined` if the referenced instance is
		 * available or loading is ongoing.
		 *
		 * @signature `ref.reason`
		 * @return {Object} error message if the promise is rejected
		 */
		reason: {
			get: function(lastSet, resolve) {
				if (this._value) {
					return undefined;
				} else {
					this.promise.catch(function(value) {
						resolve(value);
					});
				}
			}
		}
	};
	defs[idProp] = {
		type: "*",
		set: function() {
			this._value = undefined;
		}
	};

	canDefine_2_3_5_canDefine(Ref.prototype, defs);

	Ref.prototype.unobservedId = canObservationRecorder_1_1_2_canObservationRecorder.ignore(function() {
		return this[idProp];
	});
	/**
	 * @function can-connect/can/ref/ref.Map.Ref.prototype.isResolved isResolved
	 * @parent can-connect/can/ref/ref.Map.Ref.prototype
	 *
	 * Observable property typically for use in templates to indicate to the user if lazy loading has succeeded.
	 *
	 * @signature `ref.isResolved`
	 * @return {boolean} `true` if the lazy loading promise was resolved.
	 */
	Ref.prototype.isResolved = function() {
		return !!this._value || this._state === "resolved";
	};
	/**
	 * @function can-connect/can/ref/ref.Map.Ref.prototype.isRejected isRejected
	 * @parent can-connect/can/ref/ref.Map.Ref.prototype
	 *
	 * Observable property typically for use in templates to indicate to the user if lazy loading has failed.
	 *
	 * @signature `ref.isRejected`
	 * @return {boolean} `true` if the lazy loading promise was rejected.
	 */
	Ref.prototype.isRejected = function() {
		return this._state === "rejected";
	};

	/**
	 * @function can-connect/can/ref/ref.Map.Ref.prototype.isPending isPending
	 * @parent can-connect/can/ref/ref.Map.Ref.prototype
	 *
	 * Observable property typically for use in templates to indicate to the user if lazy loading is ongoing.
	 *
	 * @signature `ref.isPending`
	 * @return {boolean} `true` if the lazy loading promise state is not resolved or rejected.
	 */
	Ref.prototype.isPending = function() {
		return !this._value && (this._state !== "resolved" || this._state !== "rejected");
	};

	/**
	 * @function can-connect/can/ref/ref.Map.Ref.prototype.serialize serialize
	 * @parent can-connect/can/ref/ref.Map.Ref.prototype
	 *
	 * Return the id of the referenced instance when serializing. Prevents the referenced instance from
	 * being entirely serialized when serializing the referencing instance.
	 *
	 * @signature `ref.serialize`
	 * @return {string} id the id of the referenced instance
	 */
	Ref.prototype.serialize = function() {
		return this[idProp];
	};
	canReflect_1_16_7_canReflect.assignSymbols(Ref.prototype, {
		"can.serialize": Ref.prototype.serialize,
		"can.getName": function(){
			return canReflect_1_16_7_canReflect.getName(this.constructor)+"{"+this[idProp]+"}";
		}
	});

	var baseEventSetup = Ref.prototype._eventSetup;
	Ref.prototype._eventSetup = function() {
		Ref.store.addReference(this.unobservedId(), this);
		return baseEventSetup.apply(this, arguments);
	};
	var baseTeardown = Ref.prototype._eventTeardown;
	Ref.prototype._eventTeardown = function() {
		Ref.store.deleteReference(this.unobservedId(), this);
		return baseTeardown.apply(this, arguments);
	};


	store.requests.on("end", function() {
		for (var id in Ref._requestInstances) {
			Ref.store.deleteReference(id);
		}
		Ref._requestInstances = {};
	});

	//!steal-remove-start
	Object.defineProperty(Ref, "name", {
		value: canReflect_1_16_7_canReflect.getName(connection.Map) + "Ref",
		configurable: true
	});
	//!steal-remove-end

	return Ref;
};


var ref = canConnect_3_0_0Pre_14_canConnect.behavior("can/ref", function(baseConnection) {
	return {
		/**
		 * @can-connect/can/ref/ref.init init
		 * @parent can-connect/can/ref/ref.methods
		 *
		 * @signature `connection.init()`
		 *
		 * Initializes the base connection and then creates and sets [can-connect/can/ref/ref.Map.Ref].
		 * Typically called by the `connect` helper after the connection behaviors have been assembled.
		 *
		 * @return {undefined} no return value
		 **/
		init: function() {
			baseConnection.init.apply(this, arguments);
			this.Map.Ref = makeRef(this);
		}
	};
});

/**
 * @module can-connect/data/callbacks/callbacks data/callbacks
 * @parent can-connect.behaviors
 *
 * Extend [can-connect/DataInterface] methods to call callbacks with the raw response data.
 *
 * @signature `dataCallbacks( baseConnection )`
 *
 * Extends the [can-connect/DataInterface] create, update, read & delete methods to call 'callback' methods following
 * their execution. Callbacks are called with the data returned from the underlying behavior's [can-connect/DataInterface]
 * implementation.
 *
 * For example:
 * ```
 * var dataUrl = require("can-connect/data/url/");
 * var dataCallbacks = require("can-connect/data/url");
 * var logging = {
 *   createdData: function(responseData) {
 *     console.log('New Todo Saved: ', responseData);
 *     return responseData;
 *   }
 * };
 * var todoConnection = connect([dataUrl, dataCallbacks, logging}],  {
 *   url: '/todos'
 * });
 *
 * // create a new todo
 * todoConnection.createData({name: "do the dishes", completed: false}).then(function(responseData) {
 *   responseData; // {id: 5}
 * });
 *
 * // after create request is completed, following is logged by the "logging" createdData callback:
 * // > New Todo Saved: {id: 5}
 * ```
 *
 * @param {{}} baseConnection `can-connect` connection object that is having the `data/callbacks` behavior added
 * on to it. Should already contain a behavior that provides the DataInterface (e.g [can-connect/data/url/url]). If
 * the `connect` helper is used to build the connection, the behaviors will automatically be ordered as required.
 *
 * @return {{}} a `can-connect` connection containing the method implementations provided by `data/callbacks`.
 */

var each$3 = canReflect_1_16_7_canReflect.each;

// wires up the following methods
var pairs$1 = {
	/**
	 * @function can-connect/data/callbacks/callbacks.getListData getListData
	 * @parent can-connect/data/callbacks/callbacks
	 *
	 * Call `gotListData` with the data returned from underlying behavior's implementation of
	 * [can-connect/connection.gotListData].
	 *
	 * @signature `getListData(listQuery)`
	 *
	 *   Extends the underlying behavior's [can-connect/connection.getListData] to call `gotListData` with the returned
	 *   response data. The result of the call to `gotListData` will be used as the new response data.
	 *
	 *   @param {Object} listQuery an object that represents the set of data to be loaded
	 *   @return {Promise<Object>} `Promise` resolving the raw response data, possibly modified by `gotListData`.
	 */
	getListData: "gotListData",

	/**
	 * @function can-connect/data/callbacks/callbacks.createData createData
	 * @parent can-connect/data/callbacks/callbacks
	 *
	 * Call `createdData` with the data returned from underlying behavior's implementation of
	 * [can-connect/connection.createData].
	 *
	 * @signature `createData(instanceData, cid)`
	 *
	 *   Extends the underlying behavior's [can-connect/connection.createData] to call `createdData` with the returned
	 *   response data. The result of the call to `createdData` will be used as the new response data.
	 *
	 *   @param {Object} instanceData the raw data of an instance
	 *   @param {Number} cid unique id that represents the instance that is being created
	 *   @return {Promise<Object>} `Promise` resolving the raw response data, possibly modified by `createdData`.
	 */
	createData: "createdData",

	/**
	 * @function can-connect/data/callbacks/callbacks.updateData updatedData
	 * @parent can-connect/data/callbacks/callbacks
	 *
	 * Call `updatedData` with the data returned from underlying behavior's implementation of
	 * [can-connect/connection.updateData].
	 *
	 * @signature `updateData(instanceData)`
	 *
	 *   Extends the underlying behavior's [can-connect/connection.updateData] to call `updatedData` with the returned
	 *   response data. The result of the call to `updatedData` will be used as the new response data.
	 *
	 *   @param {Object} instanceData the raw data of an instance
	 *   @return {Promise<Object>} `Promise` resolving the raw response data, possibly modified by `updatedData`.
	 */
	updateData: "updatedData",

	/**
	 * @function can-connect/data/callbacks/callbacks.destroyData destroyData
	 * @parent can-connect/data/callbacks/callbacks
	 *
	 * Call `destroyedData` with the data returned from underlying behavior's implementation of
	 * [can-connect/connection.destroyData].
	 *
	 * @signature `destroyData(params, cid)`
	 *
	 *   Extends the underlying behavior's [can-connect/connection.destroyData] to call `destroyedData` with the returned
	 *   response data. The result of the call to `destroyedData` will be used as the new response data.
	 *
	 *   @param {Object} instanceData the raw data of an instance
	 *   @return {Promise<Object>} `Promise` resolving the raw response data, possibly modified by `destroyedData`.
	 */
	destroyData: "destroyedData"
};

var dataCallbackBehavior = canConnect_3_0_0Pre_14_canConnect.behavior("data/callbacks",function(baseConnection){

	var behavior = {
	};

	// overwrites createData to createdData
	each$3(pairs$1, function(callbackName, name){

		behavior[name] = function(params, cid){
			var self = this;

			return baseConnection[name].call(this, params).then(function(data){
				if(self[callbackName]) {
					return self[callbackName].call(self,data, params, cid );
				} else {
					return data;
				}
			});
		};

	});
	return behavior;
});

var callbacks = dataCallbackBehavior;

//!steal-remove-start

var callbacks = validate(dataCallbackBehavior, [
	"getListData", "createData", "updateData", "destroyData"
]);
//!steal-remove-end

var dataCallbacks = callbacks;

/**
 * @module can-connect/data/callbacks-cache/callbacks-cache data/callbacks-cache
 * @parent can-connect.behaviors
 *
 * Implements the data interface callbacks to call the [can-connect/base/base.cacheConnection]
 * [can-connect/DataInterface]. These calls keep the [can-connect/base/base.cacheConnection] contents
 * up to date.
 *
 * @signature `dataCallbacksCache( baseConnection )`
 * Implements the data interface callbacks so that a corresponding [can-connect/DataInterface] method is called on the
 * [can-connect/base/base.cacheConnection]. This updates the [can-connect/base/base.cacheConnection] contents whenever
 * data is updated on the primary connection.
 *
 * @param {{}} baseConnection `can-connect` connection object that is having the `data/callbacks-cache` behavior added
 * on to it.
 *
 * @return {{}} a `can-connect` connection containing the method implementations provided by `data/callbacks-cache`.
 *
 * ### Example
 * Shows synchronization between primary connection and cacheConnection data when using this behavior:
 * ```
 * import dataUrl from "can-connect/data/url/";
 * import dataCallbacks from "can-connect/data/callbacks/";
 * import cacheCallbacks from "can-connect/data/callbacks-cache/";
 * import memoryCache from "can-connect/data/memory-cache/";
 *
 * var cacheConnection = connect([memoryCache], {});
 * var todoConnection = connect([dataUrl, dataCallback, cacheCallbacks], {
 *   cacheConnection,
 *   url: "/todo"
 * });
 *
 * todoConnection.createData({name:'do the dishes', completed: false}).then(function(data) {
 *   todoConnection.cacheConnection.getData({id: data.id}).then(function(cachedData) {
 *     // data returned from connection and data returned from cache have the same contents
 *     data.id === cachedData.id; // true
 *     data.name === cachedData.name; // true
 *     data.completed === cachedData.completed; // true
 *     data === cachedData; // false, since callbacks-cache creates a copy of the data when adding it to the cache
 *   })
 * });
 * ```
 */

var assign$6 = canReflect_1_16_7_canReflect.assignMap;
var each$4 = canReflect_1_16_7_canReflect.each;

// wires up the following methods
var pairs$2 = {
	/**
	 * @function can-connect/data/callbacks-cache/callbacks-cache.createdData createdData
	 * @parent can-connect/data/callbacks-cache/callbacks-cache
	 *
	 * Data callback that updates the [can-connect/base/base.cacheConnection cache] when a new data record is created.
	 *
	 * @signature `connection.createdData(responseData, requestData, cid)`
	 *
	 * Calls `createData` on the [can-connect/base/base.cacheConnection] to add a newly created data record to the cache.
	 * Calls and returns the response from any underlying behavior's `createdData` callback.
	 *
	 * @param {{}} responseData the data returned by the data creation request
	 * @param {{}} requestData the data that was passed to the data creation request
	 * @param {Number} cid the unique identifier for this data. Used before data has a [can-connect/base/base.id] added
	 * at creation time.
	 *
	 * @return {{}} the data returned from an underlying behavior's `createdData` callback, if one exists. Otherwise
	 * returns the `responseData`.
	 */
	createdData: "createData",

	/**
	 * @function can-connect/data/callbacks-cache/callbacks-cache.updatedData updatedData
	 * @parent can-connect/data/callbacks-cache/callbacks-cache
	 *
	 * Data callback that updates the [can-connect/base/base.cacheConnection cache] when a data record is modified.
	 *
	 * @signature `connection.updatedData(responseData, requestData)`
	 *
	 * Calls `updateData` on the [can-connect/base/base.cacheConnection] to modify a data record stored in the cache.
	 * Calls and returns the response from any underlying behavior's `updatedData` callback.
	 *
	 * @param {{}} responseData the data returned by the data update request
	 * @param {{}} requestData the data that was passed to the data update request
	 *
	 * @return {{}} the data returned from an underlying behavior's `updatedData` callback, if one exists. Otherwise
	 * returns the `responseData`.
	 */
	updatedData: "updateData",

	/**
	 * @function can-connect/data/callbacks-cache/callbacks-cache.destroyedData destroyedData
	 * @parent can-connect/data/callbacks-cache/callbacks-cache
	 *
	 * Data callback that updates the [can-connect/base/base.cacheConnection cache] when a data record is deleted.
	 *
	 * @signature `connection.destroyedData(responseData, requestData)`
	 *
	 * Calls `destroyData` on the [can-connect/base/base.cacheConnection] to remove a data record stored in the cache.
	 * Calls and returns the response from any underlying behavior's `destroyedData` callback.
	 *
	 * @param {{}} responseData the data returned by the data destroy request
	 * @param {{}} requestData the data that was passed to the data destroy request
	 *
	 * @return {{}} the data returned from an underlying behavior's `destroyedData` callback, if one exists. Otherwise
	 * returns the `responseData`.
	 */
	destroyedData: "destroyData"
};



var callbackCache = canConnect_3_0_0Pre_14_canConnect.behavior("data/callbacks-cache",function(baseConnection){
	var behavior = {};

	each$4(pairs$2, function(crudMethod, dataCallback){
		behavior[dataCallback] = function(data, params, cid){

			// update the data in the cache
			this.cacheConnection[crudMethod]( assign$6(assign$6({}, params), data) );

			// return underlying dataCallback implementation if one exists or return input data
			if (baseConnection[dataCallback]) {
				return baseConnection[dataCallback].call(this, data, params, cid);
			} else {
				return data;
			}
		};
	});

	return behavior;
});

var callbacksCache = callbackCache;

//!steal-remove-start

var callbacksCache = validate(callbackCache, []);
//!steal-remove-end

var callbacksCache$1 = callbacksCache;

var getItems$1 = function(data){
	if(Array.isArray(data)) {
		return data;
	} else {
		return data.data;
	}
};

var deferred = function(){
	var def = {};
	def.promise = new Promise(function(resolve, reject){
		def.resolve = resolve;
		def.reject = reject;
	});
	return def;
};

var forEach = [].forEach;
/**
 * @module can-connect/data/combine-requests/combine-requests combine-requests
 * @parent can-connect.behaviors
 * @group can-connect/data/combine-requests.options 1 behavior options
 * @group can-connect/data/combine-requests.types 2 types
 * @group can-connect/data/combine-requests.data-methods 3 data methods
 * @group can-connect/data/combine-requests.queryLogic 4 queryLogic methods
 *
 * Combines multiple incoming lists requests into a single list request when possible.
 *
 * @signature `combineRequests( baseConnection )`
 *
 * Implements [can-connect/data/combine-requests.getListData] to collect the requested sets for some
 * [can-connect/data/combine-requests.time].  Once the configured amount of time has passed, it tries to take the
 * [can-connect/data/combine-requests.unionPendingRequests union] of the requested sets. It then makes requests with
 * those unified sets. Once the unified set requests have returned, the original requests are resolved by taking
 * [can-connect/data/combine-requests.filterMembers subsets] of the unified response data.
 *
 * @param {{}} baseConnection `can-connect` connection object that is having the `combine-requests` behavior added
 * on to it. Should already contain a behavior that provides `getListData` (e.g [can-connect/data/url/url]). If
 * the `connect` helper is used to build the connection, the behaviors will automatically be ordered as required.
 *
 * @return {{}} a `can-connect` connection containing the method implementations provided by `combine-requests`.
 *
 * @body
 *
 * ## Use
 *
 * Create a connection with the `combine-requests` plugin:
 *
 * ```
 * var combineRequests = require("can-connect/data/combine-requests/");
 * var dataUrl = require("can-connect/data/url/");
 * var todosConnection = connect([dataUrl, combineRequests], {
 *   url: "/todos"
 * });
 * ```
 * Since the configuration above doesn't include the [can-connect/data/combine-requests.time] option, the following
 * will only make a single request if all requests are made during the same "thread of execution" (i.e. before the
 * browser takes a break from executing the current JavaScript):
 *
 * ```
 * todosConnection.getListData({})
 * todosConnection.getListData({filter: {userId: 5}});
 * todosConnection.getListData({filter: {userId: 5, type: "critical"}});
 * ```
 *
 * The above requests can all be joined since [can-set] intuitively knows that
 * `({filter: {userId: 5}}` and `{filter: {userId: 5, type: "critical"}}` are subsets of the complete set of todos, `{}`.
 *
 * For more advanced combining, a [can-query-logic queryLogic] must be configured. This allows `combine-requests` to understand
 * what certain parameters of a set mean, and how they might be combined.
 *
 *
 *
 */
var combineRequests = canConnect_3_0_0Pre_14_canConnect.behavior("data/combine-requests",function(baseConnection){
	var pendingRequests; //[{set, deferred}]

	return {
		/**
		 * @function can-connect/data/combine-requests.unionPendingRequests unionPendingRequests
		 * @parent can-connect/data/combine-requests.queryLogic
		 *
		 * Group pending requests by the request that they are a subset of.
		 *
		 * @signature `connection.unionPendingRequests( pendingRequests )`
		 *
		 * This is called by [can-connect/data/combine-requests.getListData] to determine which pending requests can be unified
		 * into a broader request. This produces a grouping of 'parent' sets to 'child' requests whose data will be
		 * derived from the data retrieved by the parent.
		 *
		 * After this grouping is returned, [can-connect/data/combine-requests.getListData] executes requests for the parent
		 * sets. After a parent request succeeds, the child requests will have their data calculated from the parent data.
		 *
		 * @param {Array<can-connect/data/combine-requests.PendingRequest>} pendingRequests
		 * an array of objects, each containing:
		 *   - `set` - the requested set
		 *   - `deferred` - a wrapper around a `Promise` that will be resolved with this sets data
		 *
		 * @return {Array<{set: Set, pendingRequests: can-connect/data/combine-requests.PendingRequest}>}
		 * an array of each of the unified requests to be made.  Each unified request should have:
		 *   - `set` - the set to request
		 *   - `pendingRequests` - the array of [can-connect/data/combine-requests.PendingRequest pending requests] the `set` satisfies
		 *
		 * ### Example
		 *
		 * This function converts something like:
		 *
		 * ```
		 * [
		 *   {set: {completed: false}, deferred: def1},
		 *   {set: {completed: true}, deferred: def2}
		 * ]
		 * ```
		 *
		 * to:
		 *
		 * ```
		 * [
		 *   {
		 *    set: {},
		 *    pendingRequests: [
		 *      {set: {completed: false}, deferred: def1},
		 *      {set: {completed: true}, deferred: def2}
		 *    ]
		 *   }
		 * ]
		 * ```
		 *
		 */
		unionPendingRequests: function(pendingRequests){
			// this should try to merge existing param requests, into an array of
			// others to send out
			// but this data structure keeps the original promises.


			// we need the "biggest" sets first so they can swallow up everything else
			// O(n log n)
			var self = this;

			pendingRequests.sort(function(pReq1, pReq2){

				if(self.queryLogic.isSubset(pReq1.set, pReq2.set)) {
					return 1;
				} else if( self.queryLogic.isSubset(pReq2.set, pReq1.set) ) {
					return -1;
				} else {
					return 0;
				}

			});

			// O(n^2).  This can probably be made faster, but there are rarely lots of pending requests.
			var combineData = [];
			var current;

			doubleLoop(pendingRequests, {
				start: function(pendingRequest){
					current = {
						set: pendingRequest.set,
						pendingRequests: [pendingRequest]
					};
					combineData.push(current);
				},
				iterate: function(pendingRequest){
					var combined = self.queryLogic.union(current.set, pendingRequest.set);
					if( self.queryLogic.isDefinedAndHasMembers(combined) ) {
						// add next
						current.set = combined;
						current.pendingRequests.push(pendingRequest);
						// removes this from iteration
						return true;
					}
				}
			});

			return Promise.resolve(combineData);
		},

		/**
		 * @property {Number} can-connect/data/combine-requests.time time
		 * @parent can-connect/data/combine-requests.options
		 *
		 * Specifies the amount of time to wait to combine requests.
		 *
		 * @option {Number} Defaults to `1`, meaning only requests made within the same "thread of execution" will be
		 * combined (i.e. requests made before the browser takes a break from the ongoing JavaScript execution).
		 *
		 * Increasing this number will mean that requests are delayed that length of time in case other requests
		 * are made. In general, we advise against increasing this amount of time except in cases where loads take a
		 * significant amount of time and the increased delay is unlikely to be noticed.
		 *
		 * ```
		 * var combineRequests = require("can-connect/data/combine-requests/");
		 * connect([... combineRequests, ...],{
		 *   time: 100
		 * })
		 * ```
		 */
		time:1,

		/**
		 * @function can-connect/data/combine-requests.getListData getListData
		 * @parent can-connect/data/combine-requests.data-methods
		 *
		 * Combines multiple list data requests into a single request, when possible.
		 *
		 * @signature `connection.getListData( set )`
		 *
		 * Extension of [can-connect/connection.getListData `getListData`] that tries to combine calls to it into a single
		 * call. The calls are fulfilled by an underlying behavior's `getListData` implementation.
		 *
		 * Waits for a configured [can-connect/data/combine-requests.time] then tries to unify the sets requested during it.
		 * After unification, calls for the unified sets are made to the underlying `getListData`. Once the unified
		 * data has returned, the individual calls to `getListData` are resolved with a
		 * [can-query-logic.prototype.filterMembers calculated subset] of the unified data.
		 *
		 * @param {can-query-logic/query} query the parameters of the requested set of data
		 * @return {Promise<can-connect.listData>} `Promise` resolving the data of the requested set
		 */
		getListData: function(set){
			set = set || {};
			var self = this;

			if(!pendingRequests) {

				pendingRequests = [];

				setTimeout(function(){

					var combineDataPromise = self.unionPendingRequests(pendingRequests);
					pendingRequests = null;
					combineDataPromise.then(function(combinedData){
						// farm out requests
						forEach.call(combinedData, function(combined){
							// clone combine.set to prevent mutations by baseConnection.getListData
							var combinedSet = canReflect_1_16_7_canReflect.serialize(combined.set);

							baseConnection.getListData(combinedSet).then(function(data){
								if(combined.pendingRequests.length === 1) {
									combined.pendingRequests[0].deferred.resolve(data);
								} else {
									forEach.call(combined.pendingRequests, function(pending){
										// get the subset using the combine.set property before being passed down
										// to baseConnection.getListData which might mutate it causing combinedRequests
										// to resolve with an `undefined` value instead of an actual set
										// https://github.com/canjs/can-connect/issues/139
										pending.deferred.resolve( {data: self.queryLogic.filterMembers(pending.set, combined.set, getItems$1(data))} );
									});
								}
							}, function(err){
								if(combined.pendingRequests.length === 1) {
									combined.pendingRequests[0].deferred.reject(err);
								} else {
									forEach.call(combined.pendingRequests, function(pending){
										pending.deferred.reject(err);
									});
								}

							});
						});
					});


				}, this.time || 1);
			}
			var deferred$$1 = deferred();

			pendingRequests.push({deferred: deferred$$1, set: set});

			return deferred$$1.promise;
		}
	};
});

var combineRequests_1 = combineRequests;

//!steal-remove-start

var combineRequests_1 = validate(combineRequests, ['getListData']);
//!steal-remove-end

/**
 * @typedef {PendingRequest} can-connect/data/combine-requests.PendingRequest PendingRequest
 * @parent can-connect/data/combine-requests.types
 *
 * @description Type to keep track of the multiple requests that were unified into a single request.
 *
 * @type {PendingRequest} Record of an individual request that has been unified as part of the combined request. After
 * the unified request completes instances of these types are processed to complete the individual requests with the
 * subset of the unified data.
 *
 * @option {can-query-logic/query} query a requested [can-set/Set set] of data that has been unified into the combined request
 * @option {{}} deferred a type that keeps track of the individual [can-connect/data/combine-requests.getListData]
 * promise that will be resolved after the unified request completes
 */

// ### doubleLoop
var doubleLoop = function(arr, callbacks){
	var i = 0;
	while(i < arr.length) {
		callbacks.start(arr[i]);
		var j = i+1;
		while( j < arr.length ) {
			if(callbacks.iterate(arr[j]) === true) {
				arr.splice(j, 1);
			} else {
				j++;
			}
		}
		i++;
	}
};

var combineRequests$1 = combineRequests_1;

var canLocalStore_1_0_0_canLocalStore = canNamespace_1_0_0_canNamespace.localStore = function localStore(baseConnection){
    baseConnection.constructor = localStore;
    var behavior = Object.create(canMemoryStore_1_0_0_makeSimpleStore(baseConnection));

    canReflect_1_16_7_canReflect.assignMap(behavior, {
		clear: function(){
			localStorage.removeItem(this.name+"/queries");
			localStorage.removeItem(this.name+"/records");
            this._recordsMap = null;
            return Promise.resolve();
		},
		updateQueryDataSync: function(queries){
			localStorage.setItem(this.name+"/queries", JSON.stringify(queries) );
		},
		getQueryDataSync: function(){
			return JSON.parse( localStorage.getItem(this.name+"/queries") ) || [];
		},

		getRecord: function(id){
			// a little side-effectual mischeif for performance
			if(!this._recordsMap) {
				this.getAllRecords();
			}

			return this._recordsMap[id];
		},
		getAllRecords: function(){
			// this._records is a in memory representation so things can be fast
            // Must turn on `cacheLocalStorageReads` for this to work.
			if(!this.cacheLocalStorageReads || !this._recordsMap) {
				var recordsMap = JSON.parse( localStorage.getItem(this.name+"/records") ) || {};
				this._recordsMap = recordsMap;
			}

			var records = [];
			for(var id in this._recordsMap) {
				records.push(this._recordsMap[id]);
			}
			return records;
		},
		destroyRecords: function(records) {
            if(!this._recordsMap) {
				this.getAllRecords();
			}
			canReflect_1_16_7_canReflect.eachIndex(records, function(record){
				var id = canReflect_1_16_7_canReflect.getIdentity(record, this.queryLogic.schema);
				delete this._recordsMap[id];
			}, this);
			localStorage.setItem(this.name+"/records", JSON.stringify(this._recordsMap) );
		},
		updateRecordsSync: function(records){
            if(!this._recordsMap) {
				this.getAllRecords();
			}
			records.forEach(function(record){
				var id = canReflect_1_16_7_canReflect.getIdentity(record, this.queryLogic.schema);
				this._recordsMap[id] = record;
			},this);
			localStorage.setItem(this.name+"/records", JSON.stringify(this._recordsMap) );
		}
		// ## Identifiers

		/**
		 * @property {String} can-connect/data/localstorage-cache/localstorage-cache.name name
		 * @parent can-connect/data/localstorage-cache/localstorage-cache.identifiers
		 *
		 * Specify a name to use when saving data in localstorage.
		 *
		 * @option {String} This name is used to find and save data in
		 * localstorage. Instances are saved in `{name}/instance/{id}`
		 * and sets are saved in `{name}/set/{set}`.
		 *
		 * @body
		 *
		 * ## Use
		 *
		 * ```
		 * var cacheConnection = connect(["data-localstorage-cache"],{
		 *   name: "todos"
		 * });
		 * ```
		 */


		// ## External interface

		/**
		 * @function can-connect/data/localstorage-cache/localstorage-cache.clear clear
		 * @parent can-connect/data/localstorage-cache/localstorage-cache.data-methods
		 *
		 * Resets the memory cache so it contains nothing.
		 *
		 * @signature `connection.clear()`
		 *
		 */



		/**
		 * @function can-connect/data/localstorage-cache/localstorage-cache.getSets getSets
		 * @parent can-connect/data/localstorage-cache/localstorage-cache.data-methods
		 *
		 * Returns the sets contained within the cache.
		 *
		 * @signature `connection.getSets(set)`
		 *
		 *   Returns the sets added by [can-connect/data/localstorage-cache/localstorage-cache.updateListData].
		 *
		 *   @return {Promise<Array<Set>>} A promise that resolves to the list of sets.
		 *
		 * @body
		 *
		 * ## Use
		 *
		 * ```
		 * connection.getSets() //-> Promise( [{type: "completed"},{user: 5}] )
		 * ```
		 *
		 */

		/**
		 * @function can-connect/data/localstorage-cache/localstorage-cache.getListData getListData
		 * @parent can-connect/data/localstorage-cache/localstorage-cache.data-methods
		 *
		 * Gets a set of data from localstorage.
		 *
		 * @signature `connection.getListData(set)`
		 *
		 *   Goes through each set add by [can-connect/data/memory-cache.updateListData]. If
		 *   `set` is a subset, uses [can-connect/base/base.queryLogic] to get the data for the requested `set`.
		 *
		 *   @param {can-query-logic/query} query An object that represents the data to load.
		 *
		 *   @return {Promise<can-connect.listData>} A promise that resolves if `set` is a subset of
		 *   some data added by [can-connect/data/memory-cache.updateListData].  If it is not,
		 *   the promise is rejected.
		 */

		/**
		 * @function can-connect/data/localstorage-cache.getListDataSync getListDataSync
		 * @parent can-connect/data/localstorage-cache.data-methods
		 *
		 * Synchronously gets a set of data from localstorage.
		 *
		 * @signature `connection.getListDataSync(set)`
		 * @hide
		 */

		/**
		 * @function can-connect/data/localstorage-cache/localstorage-cache.getData getData
		 * @parent can-connect/data/localstorage-cache/localstorage-cache.data-methods
		 *
		 * Get an instance's data from localstorage.
		 *
		 * @signature `connection.getData(params)`
		 *
		 *   Looks in localstorage for the requested instance.
		 *
		 *   @param {Object} params An object that should have the [conenction.id] of the element
		 *   being retrieved.
		 *
		 *   @return {Promise} A promise that resolves to the item if the memory cache has this item.
		 *   If localstorage does not have this item, it rejects the promise.
		 */


		/**
		 * @function can-connect/data/localstorage-cache/localstorage-cache.updateListData updateListData
		 * @parent can-connect/data/localstorage-cache/localstorage-cache.data-methods
		 *
		 * Saves a set of data in the cache.
		 *
		 * @signature `connection.updateListData(listData, set)`
		 *
		 *   Tries to merge this set of data with any other saved sets of data. If
		 *   unable to merge this data, saves the set by itself.
		 *
		 *   @param {can-connect.listData} listData
		 *   @param {can-query-logic/query} query
		 *   @return {Promise} Promise resolves if and when the data has been successfully saved.
		 */


		/**
		 * @function can-connect/data/localstorage-cache/localstorage-cache.createData createData
		 * @parent can-connect/data/localstorage-cache/localstorage-cache.data-methods
		 *
		 * Called when an instance is created and should be added to cache.
		 *
		 * @signature `connection.createData(props)`
		 *
		 *   Adds `props` to the stored list of instances. Then, goes
		 *   through every set and adds props the sets it belongs to.
		 */


		/**
		 * @function can-connect/data/localstorage-cache/localstorage-cache.updateData updateData
		 * @parent can-connect/data/localstorage-cache/localstorage-cache.data-methods
		 *
		 * Called when an instance is updated.
		 *
		 * @signature `connection.updateData(props)`
		 *
		 *   Overwrites the stored instance with the new props. Then, goes
		 *   through every set and adds or removes the instance if it belongs or not.
		 */


		/**
		 * @function can-connect/data/localstorage-cache/localstorage-cache.destroyData destroyData
		 * @parent can-connect/data/localstorage-cache/localstorage-cache.data-methods
		 *
		 * Called when an instance should be removed from the cache.
		 *
		 * @signature `connection.destroyData(props)`
		 *
		 *   Goes through each set of data and removes any data that matches
		 *   `props`'s [can-connect/base/base.id]. Finally removes this from the instance store.
		 */

	});

	return behavior;

};

/**
 * @module can-connect/data/localstorage-cache/localstorage-cache localstorage-cache
 * @parent can-connect.deprecated
 * @group can-connect/data/localstorage-cache/localstorage-cache.identifiers 0 identifiers
 * @group can-connect/data/localstorage-cache/localstorage-cache.data-methods 1 data methods
 *
 * Saves raw data in localStorage.
 * 
 * @deprecated {5.0} Use [can-local-store] instead.
 *
 * @signature `localStorage( baseConnection )`
 *
 *   Creates a cache of instances and a cache of sets of instances that is
 *   accessible to read via [can-connect/data/localstorage-cache/localstorage-cache.getSets],
 *   [can-connect/data/localstorage-cache/localstorage-cache.getData], and [can-connect/data/localstorage-cache/localstorage-cache.getListData].
 *   The caches are updated via [can-connect/data/localstorage-cache/localstorage-cache.createData],
 *   [can-connect/data/localstorage-cache/localstorage-cache.updateData], [can-connect/data/localstorage-cache/localstorage-cache.destroyData],
 *   and [can-connect/data/localstorage-cache/localstorage-cache.updateListData].
 *
 *   [can-connect/data/localstorage-cache/localstorage-cache.createData],
 *   [can-connect/data/localstorage-cache/localstorage-cache.updateData],
 *   [can-connect/data/localstorage-cache/localstorage-cache.destroyData] are able to move items in and out
 *   of sets.
 *
 * @body
 *
 * ## Use
 *
 * `data/localstorage-cache` is often used with a caching strategy like [can-connect/fall-through-cache/fall-through-cache] or
 * [can-connect/cache-requests/cache-requests].  Make sure you configure the connection's [can-connect/data/localstorage-cache/localstorage-cache.name].
 *
 * ```
 * var cacheConnection = connect([
 *   require("can-connect/data/localstorage-cache/localstorage-cache")
 * ],{
 *   name: "todos"
 * });
 *
 * var todoConnection = connect([
 *   require("can-connect/data/url/url"),
 *   require("can-connect/fall-through-cache/fall-through-cache")
 * ],
 * {
 *   url: "/services/todos",
 *   cacheConnection: cacheConnection
 * });
 * ```
 *
 */




var localstorageCache = canLocalStore_1_0_0_canLocalStore;

/**
 * @module can-connect/fall-through-cache/fall-through-cache fall-through-cache
 * @parent can-connect.behaviors
 * @group can-connect/fall-through-cache/fall-through-cache.data data callbacks
 * @group can-connect/fall-through-cache/fall-through-cache.hydrators hydrators
 *
 * Add fall-through caching with the `cacheConnection`.
 *
 * @signature `fallThroughCache( baseConnection )`
 *
 *   Implements a `getData` and `getListData` that
 *   check their [can-connect/base/base.cacheConnection] for data. If there is data,
 *   this data will be immediately returned.
 *   In the background, the `baseConnection` method will be called and used to update the instance or list.
 *
 * @body
 *
 * ## Use
 *
 * To use the `fall-through-cache`, create a connection with a
 * [can-connect/base/base.cacheConnection] and a behavior that implements
 * [can-connect/connection.getData] and [can-connect/connection.getListData].
 *
 * ```js
 * var QueryLogic = require("can-query-logic");
 *
 * var queryLogic = new QueryLogic();
 *
 * var cache = connect([
 *   require("can-local-store")
 * ],{
 *   name: "todos",
 *   queryLogic: queryLogic
 * });
 *
 * var todoConnection = connect([
 *    require("can-connect/fall-through-cache/fall-through-cache"),
 *    require("can-connect/data/url/url"),
 *    require("can-connect/constructor/constructor"),
 *    require("can-connect/constructor/store/store")
 *   ], {
 *   url: "/todos",
 *   cacheConnection: cache,
 *   queryLogic: queryLogic
 * });
 * ```
 *
 * Then, make requests.  If the cache has the data,
 * it will be returned immediately, and then the item or list updated later
 * with the response from the base connection:
 *
 * ```js
 * todoConnection.getList({due: "today"}).then(function(todos){
 *
 * })
 * ```
 *
 * ## Demo
 *
 * The following shows the `fall-through-cache` behavior.
 *
 * @demo demos/can-connect/fall-through-cache.html
 *
 * Clicking
 * "Completed" or "Incomplete" will make one of the following requests and
 * display the results in the page:
 *
 * ```
 * todoConnection.getList({completed: true});
 * todoConnection.getList({completed: false});
 * ```
 *
 * If you click back and forth between "Completed" and "Incomplete" multiple times
 * you'll notice that the old data is displayed immediately and then
 * updated after about a second.
 *
 */




var fallThroughCache = canConnect_3_0_0Pre_14_canConnect.behavior("fall-through-cache",function(baseConnection){

	var behavior = {
		/**
		 * @function can-connect/fall-through-cache/fall-through-cache.hydrateList hydrateList
		 * @parent can-connect/fall-through-cache/fall-through-cache.hydrators
		 *
		 * Returns a List instance given raw data.
		 *
		 * @signature `connection.hydrateList(listData, set)`
		 *
		 *   Calls the base `hydrateList` to create a List for `listData`.
		 *
		 *   Then, Looks for registered hydrateList callbacks for a given `set` and
		 *   calls them.
		 *
		 *   @param {can-connect.listData} listData
		 *   @param {can-query-logic/query} query
		 *   @return {can-connect.List}
		 */
		hydrateList: function(listData, set){
			set = set || this.listQuery(listData);
			var id = sortedSetJson( set );
			var list = baseConnection.hydrateList.call(this, listData, set);

			if(this._getHydrateListCallbacks[id]) {
				this._getHydrateListCallbacks[id].shift()(list);
				if(!this._getHydrateListCallbacks[id].length){
					delete this._getHydrateListCallbacks[id];
				}
			}
			return list;
		},
		_getHydrateListCallbacks: {},
		_getHydrateList: function(set, callback){
			var id = sortedSetJson( set );
			if(!this._getHydrateListCallbacks[id]) {
				this._getHydrateListCallbacks[id]= [];
			}
			this._getHydrateListCallbacks[id].push(callback);
		},
		/**
		 * @function can-connect/fall-through-cache/fall-through-cache.getListData getListData
		 * @parent can-connect/fall-through-cache/fall-through-cache.data
		 *
		 * Get raw data from the cache if available, and then update
		 * the list later with data from the base connection.
		 *
		 * @signature `connection.getListData(set)`
		 *
		 *   Checks the [can-connect/base/base.cacheConnection] for `set`'s data.
		 *
		 *   If the cache connection has data, the cached data is returned. Prior to
		 *   returning the data, the [can-connect/constructor.hydrateList] method
		 *   is intercepted so we can get a handle on the list that's being created
		 *   for the returned data. Once the intercepted list is retrieved,
		 *   we use the base connection to get data and update the intercepted list and
		 *   the cacheConnection.
		 *
		 *   If the cache connection does not have data, the base connection
		 *   is used to load the data and the cached connection is updated with that
		 *   data.
		 *
		 *   @param {can-query-logic/query} query The set to load.
		 *
		 *   @return {Promise<can-connect.listData>} A promise that returns the
		 *   raw data.
		 */
		// if we do getList, the cacheConnection runs on
		// if we do getListData, ... we need to register the list that is going to be created
		// so that when the data is returned, it updates this
		getListData: function(set){
			set = set || {};
			var self = this;
			return this.cacheConnection.getListData(set).then(function(data){

				// get the list that is going to be made
				// it might be possible that this never gets called, but not right now
				self._getHydrateList(set, function(list){
					self.addListReference(list, set);

					setTimeout(function(){
						baseConnection.getListData.call(self, set).then(function(listData){

							self.cacheConnection.updateListData(listData, set);
							self.updatedList(list, listData, set);
							self.deleteListReference(list, set);

						}, function(e){
							// what do we do here?  self.rejectedUpdatedList ?
							canLog_1_0_0_canLog.log("REJECTED", e);
						});
					},1);
				});
				// TODO: if we wired up all responses to updateListData, this one should not
				// updateListData with itself.
				// But, how would we do a bypass?
				return data;
			}, function(){

				var listData = baseConnection.getListData.call(self, set);
				listData.then(function(listData){

					self.cacheConnection.updateListData(listData, set);
				});

				return listData;
			});
		},
		/**
		 * @function can-connect/fall-through-cache/fall-through-cache.hydrateInstance hydrateInstance
		 * @parent can-connect/fall-through-cache/fall-through-cache.hydrators
		 *
		 * Returns an instance given raw data.
		 *
		 * @signature `connection.hydrateInstance(props)`
		 *
		 *   Calls the base `hydrateInstance` to create an Instance for `props`.
		 *
		 *   Then, Looks for registered hydrateInstance callbacks for a given [can-connect/base/base.id] and
		 *   calls them.
		 *
		 *   @param {Object} props
		 *   @return {can-connect/Instance}
		 */
		hydrateInstance: function(props){

			var id = this.id( props );
			var instance = baseConnection.hydrateInstance.apply(this, arguments);

			if(this._getMakeInstanceCallbacks[id]) {
				this._getMakeInstanceCallbacks[id].shift()(instance);
				if(!this._getMakeInstanceCallbacks[id].length){
					delete this._getMakeInstanceCallbacks[id];
				}
			}
			return instance;
		},
		_getMakeInstanceCallbacks: {},
		_getMakeInstance: function(id, callback){
			if(!this._getMakeInstanceCallbacks[id]) {
				this._getMakeInstanceCallbacks[id]= [];
			}
			this._getMakeInstanceCallbacks[id].push(callback);
		},
		/**
		 * @function can-connect/fall-through-cache/fall-through-cache.getData getData
		 * @parent can-connect/fall-through-cache/fall-through-cache.data
		 *
		 * Get raw data from the cache if available, and then update
		 * the instance later with data from the base connection.
		 *
		 * @signature `connection.getData(params)`
		 *
		 *   Checks the [can-connect/base/base.cacheConnection] for `params`'s data.
		 *
		 *   If the cache connection has data, the cached data is returned. Prior to
		 *   returning the data, the [can-connect/constructor/constructor.hydrateInstance] method
		 *   is intercepted so we can get a handle on the instance that's being created
		 *   for the returned data. Once the intercepted instance is retrieved,
		 *   we use the base connection to get data and update the intercepted instance and
		 *   the cacheConnection.
		 *
		 *   If the cache connection does not have data, the base connection
		 *   is used to load the data and the cached connection is updated with that
		 *   data.
		 *
		 *   @param {Object} params The set to load.
		 *
		 *   @return {Promise<Object>} A promise that returns the
		 *   raw data.
		 */
		getData: function(params){
			// first, always check the cache connection
			var self = this;
			return this.cacheConnection.getData(params).then(function(instanceData){

				// get the list that is going to be made
				// it might be possible that this never gets called, but not right now
				self._getMakeInstance(self.id(instanceData) || self.id(params), function(instance){
					self.addInstanceReference(instance);

					setTimeout(function(){
						baseConnection.getData.call(self, params).then(function(instanceData2){

							self.cacheConnection.updateData(instanceData2);
							self.updatedInstance(instance, instanceData2);
							self.deleteInstanceReference(instance);

						}, function(e){
							// what do we do here?  self.rejectedUpdatedList ?
							canLog_1_0_0_canLog.log("REJECTED", e);
						});
					},1);
				});

				return instanceData;
			}, function(){
				var listData = baseConnection.getData.call(self, params);
				listData.then(function(instanceData){
					self.cacheConnection.updateData(instanceData);
				});

				return listData;
			});
		}

	};

	return behavior;

});

var fallThroughCache_1 = fallThroughCache;

//!steal-remove-start

var fallThroughCache_1 = validate(fallThroughCache, ['hydrateList', 'hydrateInstance', 'getListData', 'getData']);
//!steal-remove-end

var fallThroughCache$1 = fallThroughCache_1;

var indexByIdentity = function(items, item, schema){
    var length = canReflect_1_16_7_canReflect.size(items);
    if(!schema && length > 0) {
        schema = canReflect_1_16_7_canReflect.getSchema( items[0] );
    }
    if(!schema) {
        schema = canReflect_1_16_7_canReflect.getSchema( item );
    }
    if(!schema) {
        throw new Error("No schema to use to get identity.");
    }

	var id = canReflect_1_16_7_canReflect.getIdentity(item, schema);

	for(var i = 0; i < length; i++) {
		var connId = canReflect_1_16_7_canReflect.getIdentity(items[i], schema);
        // this was ==
		if( id === connId) {
			return i;
		}
	}
	return -1;
};

/**
 * @module can-connect/real-time/real-time real-time
 * @parent can-connect.behaviors
 * @group can-connect/real-time/real-time.methods 0 methods
 * @group can-connect/real-time/real-time.callbacks 1 data callbacks
 *
 * Update lists to include or exclude instances based
 * on set logic.
 *
 * @signature `realTime( baseConnection )`
 *
 *   Overwrites the "data callback" methods and provides
 *   [can-connect/real-time/real-time.createInstance],
 *   [can-connect/real-time/real-time.updateInstance], and
 *   [can-connect/real-time/real-time.destroyInstance] methods
 *   that
 *   update lists to include or exclude a created,
 *   updated, or destroyed instance.
 *
 *   An instance is put in a list if it is a
 *   [can-query-logic/queryLogic.prototype.isSubset]
 *   of the [can-connect/base/base.listQuery].  The item is inserted using [can-query-logic.prototype.index].
 *
 * @body
 *
 * ## Use
 *
 * To use `real-time`, create a connection with its dependent
 * behaviors like:
 *
 * ```js
 * var todoConnection = connect(
 *    ["real-time",
 *     "constructor",
 *     "constructor-store",
 *     "constructor-callbacks-once",
 *     "data-url"],{
 *   url: "/todos"
 * });
 * ```
 *
 * Next, use the connection to load lists and save those lists in the
 * store:
 *
 * ```js
 * todoConnection.getList({complete: false}).then(function(todos){
 *   todoConnection.addListReference(todos);
 * })
 * ```
 *
 * Finally, use one of the  [can-connect/real-time/real-time.createInstance],
 * [can-connect/real-time/real-time.updateInstance], and
 * [can-connect/real-time/real-time.destroyInstance] methods to tell the connection
 * that data has changed.  The connection will update (by calling splice)
 * each list accordingly.
 *
 *
 * ## Example
 *
 * The following demo shows two lists that use this connection.  The
 * "Run Code" button sends the connection data changes which the
 * connection will then update lists accordingly:
 *
 *
 * @demo demos/can-connect/real-time.html
 *
 * This example creates a `todoList` function and `todoItem` function
 * that manage the behavior of a list of todos and a single todo respectfully.
 * It uses [Object.observe](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/observe)
 * to observe changes in the todo list and individual todo data. Other
 * frameworks will typically provide their own observable system.
 *
 * ### todoList
 *
 * When `todoList` is created, it is passed the `set` of data to load.  It uses
 * this to get todos from the `todoConnection` like:
 *
 *
 * ```js
 * todosConnection.getList(set).then(function(retrievedTodos){
 * ```
 *
 * It then adds those `todos` to the [can-connect/constructor/store/store.listStore] so
 * they can be updated automatically.  And, it listens to changes in `todos` and calls an `update` function:
 *
 * ```js
 * todosConnection.addListReference(todos);
 * Object.observe(todos, update, ["add", "update", "delete"] );
 * ```
 *
 * The update function is able to inserted new `todoItem`s in the page when items are added
 * to or removed from `todos`.  We exploit that by calling `update` as if it just added
 * each todo in the list:
 *
 * ```js
 * update(todos.map(function(todo, i){
 *   return {
 *     type: "add",
 *     name: ""+i
 *   };
 * }));
 * ```
 *
 * ### todoItem
 *
 * The `todoItem` creates an element that updates with changes
 * in its `todo`.  It listens to changes in the `todo` and saves
 * the todo in the [can-connect/constructor/store/store.instanceStore] with the
 * following:
 *
 * ```js
 * Object.observe(todo, update, ["add", "update", "delete"] );
 * todosConnection.addInstanceReference(todo);
 * ```
 *
 * A `todoItem` needs to be able to stop listening on the `todo` and remove itself from the
 * `instanceStore` if the `todo` is removed from the page.  To provide this teardown
 * functionality, `todoItem` listens to a `"removed"` event on its element and
 * `unobserves` the todo and removes it from the `instanceStore`:
 *
 * ```js
 * $(li).bind("removed", function(){
 *   Object.unobserve(todo, update, ["add", "update", "delete"] );
 *   todosConnection.deleteInstanceReference(todo);
 * });
 * ```
 */






var spliceSymbol = canSymbol_1_6_1_canSymbol.for("can.splice");

function updateList(list, getRecord, currentIndex, newIndex) {
	if(currentIndex === -1) { // item is not in the list

		if(newIndex !== -1) { // item should be in the list
			canReflect_1_16_7_canReflect.splice(list, newIndex, 0, [getRecord()]);
		}
	}
	else { // item is already in the list
		if(newIndex === -1) { // item should be removed from the lists
			canReflect_1_16_7_canReflect.splice(list, currentIndex, 1, []);
		}
		else if(newIndex !== currentIndex){ // item needs to be moved

			if(currentIndex < newIndex) {
				canReflect_1_16_7_canReflect.splice(list, newIndex, 0, [getRecord()]);
				canReflect_1_16_7_canReflect.splice(list, currentIndex, 1, []);
			} else {
				canReflect_1_16_7_canReflect.splice(list, currentIndex,1, []);
				canReflect_1_16_7_canReflect.splice(list, newIndex, 0, [getRecord()]);
			}
		}
		else { // item in the same place

		}
	}
}


function updateListWithItem(list, recordData, currentIndex, newIndex, connection, set){
	if(list[spliceSymbol] !== undefined) {
		updateList(list, function(){
			return connection.hydrateInstance(recordData);
		},currentIndex, newIndex);

	} else {
		var copy = connection.serializeList(list);
		updateList(copy, function(){
			return recordData;
		},currentIndex, newIndex);
		connection.updatedList(list,  { data: copy }, set);
	}
}


var realTime = canConnect_3_0_0Pre_14_canConnect.behavior("real-time",function(baseConnection){

	var createPromise = Promise.resolve();

	return {
		createData: function(){
			var promise = baseConnection.createData.apply(this, arguments);
			var cleanPromise = promise.catch(function () { return ''; });
			createPromise = Promise.all([createPromise, cleanPromise]);
			return promise;
		},
		/**
		 * @function can-connect/real-time/real-time.createInstance createInstance
		 * @parent can-connect/real-time/real-time.methods
		 *
		 * Programatically indicate a new instance has been created.
		 *
		 * @signature `connection.createInstance(props)`
		 *
		 *   If there is no instance in the [can-connect/constructor/store/store.instanceStore]
		 *   for `props`'s [can-connect/base/base.id], an instance is [can-connect/constructor/constructor.hydrateInstance hydrated],
		 *   added to the store, and then [can-connect/real-time/real-time.createdData] is called with
		 *   `props` and the hydrated instance's serialized data. [can-connect/real-time/real-time.createdData]
		 *   will add this instance to any lists the instance belongs to.
		 *
		 *   If this instance has already been created, calls
		 *   [can-connect/real-time/real-time.updateInstance] with `props`.
		 *
		 *   @param {Object} props The raw properties of the instance was created.
		 *
		 *   @return {Promise<Instance>} A promise that resolves to the created instance.
		 *
		 * @body
		 *
		 * ## Use
		 *
		 * With a `real-time` connection, call `createInstance` when an instance is created that
		 * the connection itself did not make.  For instance, the following might listen to
		 * [socket.io](http://socket.io/) for when a `todo` is created and update the connection
		 * accordingly:
		 *
		 * ```js
		 * socket.on('todo created', function(todo){
		 *   todoConnection.createInstance(todo);
		 * });
		 * ```
		 *
		 */
		createInstance: function(props){
			var self = this;
			return new Promise(function(resolve, reject){
				// Wait until all create promises are done
				// so that we can find data in the instance store
				createPromise.then(function(){
					// Allow time for the store to get hydrated
					setTimeout(function(){
						var id = self.id(props);
						var instance = self.instanceStore.get(id);
						var serialized;

						if( instance ) {
							// already created, lets update
							resolve(self.updateInstance(props));
						} else {
							instance = self.hydrateInstance(props);
							serialized = self.serializeInstance(instance);

							self.addInstanceReference(instance);

							Promise.resolve( self.createdData(props, serialized) ).then(function(){
								self.deleteInstanceReference(instance);
								resolve(instance);
							});
						}
					}, 1);
				});
			});
		},

		/**
		 * @function can-connect/real-time/real-time.createdData createdData
		 * @parent can-connect/real-time/real-time.callbacks
		 *
		 * Called whenever instance data is created.
		 *
		 * @signature `connection.createdData(props, params, [cid])`
		 *
		 *   Updates lists with the created instance.
		 *
		 *   Gets the instance created for this request. Then, updates the instance with
		 *   the response data `props`.
		 *
		 *   Next, it goes through every list in the [can-connect/constructor/store/store.listStore],
		 *   test if the instance's data belongs in that list.  If it does,
		 *   adds the instance's data to the serialized list data and
		 *   [can-connect/constructor/constructor.updatedList updates the list].
		 */
		createdData: function(props, params, cid){
			var instance;
			if(cid !== undefined) {
				instance = this.cidStore.get(cid);
			} else {
				instance = this.instanceStore.get( this.id(props) );
			}
			// pre-register so everything else finds this even if it doesn't have an id
			this.addInstanceReference(instance, this.id(props));
			this.createdInstance(instance, props);
			create.call(this, this.serializeInstance(instance));
			this.deleteInstanceReference(instance);
			return undefined;
		},

		/**
		 * @function can-connect/real-time/real-time.updatedData updatedData
		 * @parent can-connect/real-time/real-time.callbacks
		 *
		 * Called whenever instance data is updated.
		 *
		 * @signature `connection.updatedData(props, params)`
		 *
		 *   Gets the instance that is updated, updates
		 *   it with `props` and the adds or removes it to
		 *   lists it belongs in.
		 *
		 *   @return {undefined} Returns `undefined` to prevent `.save` from calling `updatedInstance`.
		 */
		// Go through each list in the listStore and see if there are lists that should have this,
		// or a list that shouldn't.
		updatedData: function(props, params){

			var instance = this.instanceStore.get( this.id(params) );
			this.updatedInstance(instance, props);
			update$1.call(this, this.serializeInstance(instance));

			// Returning undefined prevents other behaviors from running.
			return undefined;
		},
		/**
		 * @function can-connect/real-time/real-time.updateInstance updateInstance
		 * @parent can-connect/real-time/real-time.methods
		 *
		 * Programatically indicate a new instance has been updated.
		 *
		 * @signature `connection.updateInstance(props)`
		 *
		 *   Calls [can-connect/real-time/real-time.updatedData] in the right way so
		 *   that the instance is updated and added to or removed from
		 *   any lists it belongs in.
		 *
		 *   @param {Object} props The properties of the instance that needs to be updated.
		 *
		 *   @return {Promise<Instance>} the updated instance.
		 *
		 * @body
		 *
		 * ## Use
		 *
		 * ```js
		 * socket.on('todo updated', function(todo){
		 *   todoConnection.updateInstance(todo);
		 * });
		 * ```
		 */
		updateInstance: function(props){
			var id = this.id(props);
			var instance = this.instanceStore.get(id);
			if( !instance ) {
				instance = this.hydrateInstance(props);
			}
			this.addInstanceReference(instance);

			var serialized = this.serializeInstance(instance),
				self = this;

			return Promise.resolve( this.updatedData(props, serialized) ).then(function(){

				self.deleteInstanceReference(instance);
				return instance;
			});
		},
		/**
		 * @function can-connect/real-time/real-time.destroyedData destroyedData
		 * @parent can-connect/real-time/real-time.callbacks
		 *
		 * @signature `connection.destroyedData(props, params)`
		 *
		 * Gets the instance for this request.  Then tests if the instance
		 * is in any list in the [can-connect/constructor/store/store.listStore].  If
		 * it is, removes the instance from the list.
		 *
		 * @param {Object} props The properties of the destroyed instance.
		 * @param {Object} [params] The parameters used to destroy the data.
		 */
		destroyedData: function(props, params){
			var id = this.id(params || props);
			var instance = this.instanceStore.get(id);
			if( !instance ) {
				instance = this.hydrateInstance(props);
			}
			var serialized = this.serializeInstance(instance);
			this.destroyedInstance(instance, props);
			// we can pre-register it so everything else finds it
			destroy.call(this, serialized);
			return undefined;
		},
		/**
		 * @function can-connect/real-time/real-time.destroyInstance destroyInstance
		 * @parent can-connect/real-time/real-time.methods
		 *
		 * Programatically indicate a new instance has been destroyed.
		 *
		 * @signature `connection.destroyInstance(props)`
		 *
		 *   Gets or creates an instance from `props` and uses
		 *   it to call [can-connect/real-time/real-time.destroyedData]
		 *   correctly.
		 *
		 * @param {Object} props The properties of the destroyed instance.
		 * @return {Promise<Instance>}  A promise with the destroyed instance.
		 *
		 * @body
		 * ## Use
		 *
		 * ```js
		 * socket.on('todo destroyed', function(todo){
		 *   todoConnection.destroyInstance(todo);
		 * });
		 * ```
		 */
		destroyInstance: function(props){
			var id = this.id(props);
			var instance = this.instanceStore.get(id);
			if( !instance ) {
				instance = this.hydrateInstance(props);
			}
			this.addInstanceReference(instance);

			var serialized = this.serializeInstance(instance),
				self = this;

			return Promise.resolve( this.destroyedData(props, serialized) ).then(function(){

				self.deleteInstanceReference(instance);
				return instance;
			});
		}

		//!steal-remove-start
		,gotListData: function(items, set) {
			var self = this;
			if (this.queryLogic) {
				if(Array.isArray(items)) {
					items = {data: items};
				}
				for(var item, i = 0, l = items.data.length; i < l; i++) {
					item = items.data[i];
					if( !self.queryLogic.isMember(set, item) ) {
						var msg = "One or more items were retrieved which do not match the 'Set' parameters used to load them. "
							+ "Read the docs for more information: https://canjs.com/doc/can-query-logic.html#TestingyourQueryLogic"
							+ "\n\nBelow are the 'query' parameters:"
							+ "\n" + dev.stringify(set)
							+ "\n\nAnd below is an item which does not match those parameters:"
							+ "\n" + dev.stringify(item);
						dev.warn(msg);
						break;
					}
				}
			}

			return Promise.resolve(items);
		}
		//!steal-remove-end
	};
});

var create = function(props){
	var self = this;
	// go through each list
	this.listStore.forEach(function(list, id){
		var set = JSON.parse(id);
		// ideally there should be speed up ... but this is fine for now.


		var index = indexByIdentity(list, props, self.queryLogic.schema);

		if(self.queryLogic.isMember(set, props)) {
			var newIndex = self.queryLogic.index(set, list, props);

			updateListWithItem(list, props, index, newIndex, self, set);
		}

	});
};

// ## update
// Goes through each list and sees if the list should be updated
// with the new.
var update$1 = function(props) {
	var self = this;

	this.listStore.forEach(function(list, id){
		var set = JSON.parse(id);
		// ideally there should be speed up ... but this is fine for now.


		var currentIndex = indexByIdentity(list, props, self.queryLogic.schema);

		if(self.queryLogic.isMember( set, props )) {

			var newIndex = self.queryLogic.index(set, list, props);

			updateListWithItem(list, props, currentIndex, newIndex, self, set);

		}  else if(currentIndex !== -1){ // its still in the list
			// otherwise remove it
			updateListWithItem(list, props, currentIndex, -1, self, set);
		}

	});
};

var destroy = function(props) {
	var self = this;
	this.listStore.forEach(function(list, id){
		var set = JSON.parse(id);
		// ideally there should be speed up ... but this is fine for now.

		var currentIndex = indexByIdentity(list, props, self.queryLogic.schema);

		if(currentIndex !== -1){
			// otherwise remove it
			updateListWithItem(list, props, currentIndex, -1, self, set);
		}

	});
};

/**
 * @module {function} can-connect/constructor/callbacks-once/callbacks-once constructor/callbacks-once
 * @parent can-connect.behaviors
 *
 * Prevents duplicate calls to the instance callback methods.
 *
 * @signature `callbacksOnce( baseConnection )`
 *
 *   Prevents duplicate calls to the instance callback methods by tracking the last data the methods were called with.
 *   If called with the same data again, it does not call the base connection's instance callback.
 *
 *   @param {{}} baseConnection `can-connect` connection object that is having the `callbacks-once` behavior added
 *   on to it. Should already contain the behaviors that provide the Instance Callbacks
 *   (e.g [can-connect/constructor/constructor]). If the `connect` helper is used to build the connection, the
 *   behaviors will automatically be ordered as required.
 *
 *   @return {Object} A `can-connect` connection containing the methods provided by `callbacks-once`.
 *
 */


var forEach$1 = [].forEach;

// wires up the following methods
var callbacks$1 = [
	/**
	 * @function can-connect/constructor/callbacks-once/callbacks-once.createdInstance createdInstance
	 * @parent can-connect/constructor/callbacks-once/callbacks-once
	 *
	 * `createdInstance` callback handler that prevents sequential calls with the same arguments.
	 *
	 * @signature `createdInstance(instance, data)`
	 * Called with the instance created by [can-connect/constructor/constructor.save `connection.save`] and the response data of the
	 * underlying request. Prevents sequential calls to the underlying `createdInstance` handlers with the same arguments.
	 *
	 * @param {} instance the instance created by `connection.save`
	 * @param {} data the response data returned during `connection.save`
	 */
	"createdInstance",
	/**
	 * @function can-connect/constructor/callbacks-once/callbacks-once.updatedInstance updatedInstance
	 * @parent can-connect/constructor/callbacks-once/callbacks-once
	 *
	 * `updatedInstance` callback handler that prevents sequential calls with the same arguments.
	 *
	 * @signature `updatedInstance(instance, data)`
	 * Called with the instance updated by [can-connect/constructor/constructor.save`connection.save`] and the response data of the
	 * underlying request. Prevents sequential calls to the underlying `updatedInstance` handlers with the same arguments.
	 *
	 * @param {} instance the instance created by `connection.save`
	 * @param {} data the response data returned during `connection.save`
	 */
	"updatedInstance",
	/**
	 * @function can-connect/constructor/callbacks-once/callbacks-once.destroyedInstance destroyedInstance
	 * @parent can-connect/constructor/callbacks-once/callbacks-once
	 *
	 * `destroyedInstance` callback handler that prevents sequential calls with the same arguments.
	 *
	 * @signature `destroyedInstance(instance, data)`
	 * Called with the instance created by [can-connect/constructor/constructor.destroy `connection.destroy`] and the response data of the
	 * underlying request. Prevents sequential calls to the underlying `destroyedInstance` handlers with the same arguments.
	 *
	 * @param {} instance the instance created by `connection.destroy`
	 * @param {} data the response data returned during `connection.destroy`
	 */
	"destroyedInstance"
];



var callbacksOnceBehavior = canConnect_3_0_0Pre_14_canConnect.behavior("constructor/callbacks-once",function(baseConnection){

	var behavior = {};

	forEach$1.call(callbacks$1, function(name){
		behavior[name] = function(instance, data ){

			var lastSerialized = this.getInstanceMetaData(instance, "last-data-" + name);

			var serialize = sortedSetJson(data);
			if(lastSerialized !== serialize) {
				var result =  baseConnection[name].apply(this, arguments);
				this.addInstanceMetaData(instance, "last-data-" + name, serialize);
				return result;
			}
		};

	});

	return behavior;
});

var callbacksOnce = callbacksOnceBehavior;

//!steal-remove-start

var callbacksOnce = validate(callbacksOnceBehavior, callbacks$1);
//!steal-remove-end

var callbacksOnce$1 = callbacksOnce;

function superModel(options){
    options = canReflect_1_16_7_canReflect.assignDeep({},options);

    if(!options.name) {
        options.name = canReflect_1_16_7_canReflect.getName(options.Map)+".connection";
    }
    if(!options.queryLogic) {
        options.queryLogic = new canQueryLogic_0_8_11_canQueryLogic(options.Map);
    }

	var behaviors = [
		constructor_1,
		canMap,
		ref,
		store,
		dataCallbacks,
		combineRequests$1,
		parse,
		dataUrl,
		realTime,
		callbacksOnce$1];

	if(typeof localStorage !== "undefined") {
		if(!options.cacheConnection) {
			options.cacheConnection = canConnect_3_0_0Pre_14_canConnect([localstorageCache],{
				name: options.name+".cacheConnection",
				idProp: options.idProp,
				queryLogic: options.queryLogic
			});
		}
		behaviors.push(callbacksCache$1,fallThroughCache$1);
	}
	return canConnect_3_0_0Pre_14_canConnect(behaviors,options);
}

var canSuperModel_1_0_0_canSuperModel = canNamespace_1_0_0_canNamespace.superModel = superModel;

function realtimeRestModel(options){

	var behaviors = [
		constructor_1,
		canMap,
		store,
		dataCallbacks,
		parse,
		dataUrl,
		realTime,
		callbacksOnce$1
	];

	return canConnect_3_0_0Pre_14_canConnect(behaviors,options);
}

var canRealtimeRestModel_0_1_1_canRealtimeRestModel = canNamespace_1_0_0_canNamespace.realtimeRestModel = realtimeRestModel;

var getKeyValueSymbol$2 = canSymbol_1_6_1_canSymbol.for("can.getKeyValue"),
	observeDataSymbol = canSymbol_1_6_1_canSymbol.for("can.meta");

var promiseDataPrototype = {
	isPending: true,
	state: "pending",
	isResolved: false,
	isRejected: false,
	value: undefined,
	reason: undefined
};

function setVirtualProp(promise, property, value) {
	var observeData = promise[observeDataSymbol];
	var old = observeData[property];
	observeData[property] = value;
	canQueues_1_1_0_canQueues.enqueueByQueue(observeData.handlers.getNode([property]), promise, [value,old], function() {
		return {};
	},["Promise", promise, "resolved with value", value, "and changed virtual property: "+property]);
}

function initPromise(promise) {
	var observeData = promise[observeDataSymbol];
	if(!observeData) {
		Object.defineProperty(promise, observeDataSymbol, {
			enumerable: false,
			configurable: false,
			writable: false,
			value: Object.create(promiseDataPrototype)
		});
		observeData = promise[observeDataSymbol];
		observeData.handlers = new canKeyTree_1_0_2_canKeyTree([Object, Object, Array]);
	}
	promise.then(function(value){
		canQueues_1_1_0_canQueues.batch.start();
		setVirtualProp(promise, "isPending", false);
		setVirtualProp(promise, "isResolved", true);
		setVirtualProp(promise, "value", value);
		setVirtualProp(promise, "state", "resolved");
		canQueues_1_1_0_canQueues.batch.stop();
	}, function(reason){
		canQueues_1_1_0_canQueues.batch.start();
		setVirtualProp(promise, "isPending", false);
		setVirtualProp(promise, "isRejected", true);
		setVirtualProp(promise, "reason", reason);
		setVirtualProp(promise, "state", "rejected");
		canQueues_1_1_0_canQueues.batch.stop();

		//!steal-remove-start
		dev.error("Failed promise:", reason);
		//!steal-remove-end
	});
}

function setupPromise(value) {
	var oldPromiseFn;
	var proto = "getPrototypeOf" in Object ? Object.getPrototypeOf(value) : value.__proto__; //jshint ignore:line

	if(value[getKeyValueSymbol$2] && value[observeDataSymbol]) {
		// promise has already been set up.  Don't overwrite.
		return;
	}

	if(proto === null || proto === Object.prototype) {
		// promise type is a plain object or dictionary.  Set up object instead of proto.
		proto = value;

		if(typeof proto.promise === "function") {
			// Duck-type identification as a jQuery.Deferred;
			// In that case, the promise() function returns a new object
			//  that needs to be decorated.
			oldPromiseFn = proto.promise;
			proto.promise = function() {
				var result = oldPromiseFn.call(proto);
				setupPromise(result);
				return result;
			};
		}
	}

	canReflect_1_16_7_canReflect.assignSymbols(proto, {
		"can.getKeyValue": function(key) {
			if(!this[observeDataSymbol]) {
				initPromise(this);
			}

			canObservationRecorder_1_1_2_canObservationRecorder.add(this, key);
			switch(key) {
				case "state":
				case "isPending":
				case "isResolved":
				case "isRejected":
				case "value":
				case "reason":
				return this[observeDataSymbol][key];
				default:
				return this[key];
			}
		},
		"can.getValue": function() {
			return this[getKeyValueSymbol$2]("value");
		},
		"can.isValueLike": false,
		"can.onKeyValue": function(key, handler, queue) {
			if(!this[observeDataSymbol]) {
				initPromise(this);
			}
			this[observeDataSymbol].handlers.add([key, queue || "mutate", handler]);
		},
		"can.offKeyValue": function(key, handler, queue) {
			if(!this[observeDataSymbol]) {
				initPromise(this);
			}
			this[observeDataSymbol].handlers.delete([key, queue || "mutate", handler]);
		}
	});
}

var canReflectPromise_2_0_1_canReflectPromise = setupPromise;

var getValueSymbol$1 = canSymbol_1_6_1_canSymbol.for("can.getValue");
var setValueSymbol$1 = canSymbol_1_6_1_canSymbol.for("can.setValue");

var isValueLikeSymbol = canSymbol_1_6_1_canSymbol.for("can.isValueLike");
var peek$3 = canObservationRecorder_1_1_2_canObservationRecorder.ignore(canReflect_1_16_7_canReflect.getKeyValue.bind(canReflect_1_16_7_canReflect));
var observeReader;

var bindName = Function.prototype.bind;
//!steal-remove-start
bindName = function(source){
	var fn = Function.prototype.bind.call(this, source);
	Object.defineProperty(fn, "name", {
		value: canReflect_1_16_7_canReflect.getName(source) + "."+canReflect_1_16_7_canReflect.getName(this)
	});
	return fn;
};
//!steal-remove-end

var isAt = function(index, reads) {
	var prevRead = reads[index-1];
	return prevRead && prevRead.at;
};

var readValue = function(value, index, reads, options, state, prev){
	// if the previous read is AT false ... we shouldn't be doing this;
	var usedValueReader;
	do {

		usedValueReader = false;
		for(var i =0, len = observeReader.valueReaders.length; i < len; i++){
			if( observeReader.valueReaders[i].test(value, index, reads, options) ) {
				value = observeReader.valueReaders[i].read(value, index, reads, options, state, prev);
				//usedValueReader = true;
			}
		}
	} while(usedValueReader);

	return value;
};

var specialRead = {index: true, key: true, event: true, element: true, viewModel: true};

var checkForObservableAndNotify = function(options, state, getObserves, value, index){
	if(options.foundObservable && !state.foundObservable) {
		if(canObservationRecorder_1_1_2_canObservationRecorder.trapsCount()) {
			canObservationRecorder_1_1_2_canObservationRecorder.addMany( getObserves() );
			options.foundObservable(value, index);
			state.foundObservable = true;
		}
	}
};

var objHasKeyAtIndex = function(obj, reads, index) {
	return !!(
		reads && reads.length &&
		canReflect_1_16_7_canReflect.hasKey(obj, reads[index].key)
	);
};

observeReader = {
	// there are things that you need to evaluate when you get them back as a property read
	// for example a compute or a function you might need to call to get the next value to
	// actually check
	// - readCompute - can be set to `false` to prevent reading an ending compute.  This is used by component to get a
	//   compute as a delegate.  In 3.0, this should be removed and force people to write "{@prop} change"
	// - callMethodsOnObservables - this is an overwrite ... so normal methods won't be called, but observable ones will.
	// - executeAnonymousFunctions - call a function if it's found, defaults to true
	// - proxyMethods - if the last read is a method, return a function so `this` will be correct.
	// - args - arguments to call functions with.
	//
	// Callbacks
	// - earlyExit - called if a value could not be found
	// - foundObservable - called when an observable value is found
	read: function (parent, reads, options) {
		options = options || {};
		var state = {
			foundObservable: false
		};
		var getObserves;
		if(options.foundObservable) {
			getObserves = canObservationRecorder_1_1_2_canObservationRecorder.trap();
		}

		// `cur` is the current value.
		var cur = readValue(parent, 0, reads, options, state),
			// `prev` is the object we are reading from.
			prev,
			// `foundObs` did we find an observable.
			readLength = reads.length,
			i = 0,
			parentHasKey;

		checkForObservableAndNotify(options, state, getObserves, parent, 0);

		while( i < readLength ) {
			prev = cur;
			// try to read the property
			for(var r=0, readersLength = observeReader.propertyReaders.length; r < readersLength; r++) {
				var reader = observeReader.propertyReaders[r];
				if(reader.test(cur)) {
					cur = reader.read(cur, reads[i], i, options, state);
					break; // there can be only one reading of a property
				}
			}
			checkForObservableAndNotify(options, state, getObserves, prev, i);
			i = i+1;
			// read the value if it is a compute or function
			cur = readValue(cur, i, reads, options, state, prev);

			checkForObservableAndNotify(options, state, getObserves, prev, i-1);
			// early exit if need be
			if (i < reads.length && (cur === null || cur === undefined )) {
				parentHasKey = objHasKeyAtIndex(prev, reads, i - 1);
				if (options.earlyExit && !parentHasKey) {
					options.earlyExit(prev, i - 1, cur);
				}
				// return undefined so we know this isn't the right value
				return {
					value: undefined,
					parent: prev,
					parentHasKey: parentHasKey,
					foundLastParent: false
				};
			}

		}

		parentHasKey = objHasKeyAtIndex(prev, reads, reads.length - 1);
		// if we don't have a value, exit early.
		if (cur === undefined && !parentHasKey) {
			if (options.earlyExit) {
				options.earlyExit(prev, i - 1);
			}
		}
		return {
			value: cur,
			parent: prev,
			parentHasKey: parentHasKey,
			foundLastParent: true
		};
	},
	get: function(parent, reads, options){
		return observeReader.read(parent, observeReader.reads(reads), options || {}).value;
	},
	valueReadersMap: {},
	// an array of types that might have a value inside them like functions
	// value readers check the current value
	// and get a new value from it
	// ideally they would keep calling until
	// none of these passed
	valueReaders: [
		{
			name: "function",
			// if this is a function before the last read and its not a constructor function
			test: function(value){
				return value && canReflect_1_16_7_canReflect.isFunctionLike(value) && !canReflect_1_16_7_canReflect.isConstructorLike(value);
			},
			read: function(value, i, reads, options, state, prev){
				if(options.callMethodsOnObservables && canReflect_1_16_7_canReflect.isObservableLike(prev) && canReflect_1_16_7_canReflect.isMapLike(prev)) {
					dev.warn("can-stache-key: read() called with `callMethodsOnObservables: true`.");

					return value.apply(prev, options.args || []);
				}

				return options.proxyMethods !== false ? bindName.call(value, prev) : value;
			}
		},
		{
			name: "isValueLike",
			// compute value reader
			test: function(value, i, reads, options) {
				return value && value[getValueSymbol$1] && value[isValueLikeSymbol] !== false && (options.foundAt || !isAt(i, reads) );
			},
			read: function(value, i, reads, options){
				if(options.readCompute === false && i === reads.length ) {
					return value;
				}
				return canReflect_1_16_7_canReflect.getValue(value);
			},
			write: function(base, newVal){
				if(base[setValueSymbol$1]) {
					base[setValueSymbol$1](newVal);
				} else if(base.set) {
					base.set(newVal);
				} else {
					base(newVal);
				}
			}
		}],
	propertyReadersMap: {},
	// an array of things that might have a property
	propertyReaders: [
		{
			name: "map",
			test: function(value){
				// the first time we try reading from a promise, set it up for
				//  special reflections.
				if(canReflect_1_16_7_canReflect.isPromise(value) || typeof value === "object" && value && typeof value.then === "function") {
					canReflectPromise_2_0_1_canReflectPromise(value);
				}

				return canReflect_1_16_7_canReflect.isObservableLike(value) && canReflect_1_16_7_canReflect.isMapLike(value);
			},
			read: function(value, prop){
				var res = canReflect_1_16_7_canReflect.getKeyValue(value, prop.key);
				if(res !== undefined) {
					return res;
				} else {
					return value[prop.key];
				}
			},
			write: canReflect_1_16_7_canReflect.setKeyValue
		},

		// read a normal object
		{
			name: "object",
			// this is the default
			test: function(){return true;},
			read: function(value, prop, i, options){
				if(value == null) {
					return undefined;
				} else {
					if(typeof value === "object") {
						if(prop.key in value) {
							return value[prop.key];
						}
						// TODO: remove in 5.0.
						//!steal-remove-start
						if( prop.at && specialRead[prop.key] && ( ("@"+prop.key) in value)) {
							options.foundAt = true;
							dev.warn("Use %"+prop.key+" in place of @"+prop.key+".");
							return undefined;
						}
						//!steal-remove-end
					} else {
						return value[prop.key];
					}
				}
			},
			write: function(base, prop, newVal){
				var propValue = base[prop];
				// if newVal is observable object, lets try to update
				if(newVal != null && typeof newVal === "object" && canReflect_1_16_7_canReflect.isMapLike(propValue) ) {
					dev.warn("can-stache-key: Merging data into \"" + prop + "\" because its parent is non-observable");
					canReflect_1_16_7_canReflect.update(propValue, newVal);
				} else if(propValue != null && propValue[setValueSymbol$1] !== undefined){
					canReflect_1_16_7_canReflect.setValue(propValue, newVal);
				} else {
					base[prop] = newVal;
				}
			}
		}
	],
	reads: function(keyArg) {
		var key = ""+keyArg;
		var keys = [];
		var last = 0;
		var at = false;
		if( key.charAt(0) === "@" ) {
			last = 1;
			at = true;
		}
		var keyToAdd = "";
		for(var i = last; i < key.length; i++) {
			var character = key.charAt(i);
			if(character === "." || character === "@") {
				if( key.charAt(i -1) !== "\\" ) {
					keys.push({
						key: keyToAdd,
						at: at
					});
					at = character === "@";
					keyToAdd = "";
				} else {
					keyToAdd = keyToAdd.substr(0,keyToAdd.length - 1) + ".";
				}
			} else {
				keyToAdd += character;
			}
		}
		keys.push({
			key: keyToAdd,
			at: at
		});

		return keys;
	},
	// This should be able to set a property similar to how read works.
	write: function(parent, key, value, options) {
		var keys = typeof key === "string" ? observeReader.reads(key) : key;
		var last;

		options = options || {};
		if(keys.length > 1) {
			last = keys.pop();
			parent = observeReader.read(parent, keys, options).value;
			keys.push(last);
		} else {
			last = keys[0];
		}
		if(!parent) {
			return;
		}
		var keyValue = peek$3(parent, last.key);
		// here's where we need to figure out the best way to write

		// if property being set points at a compute, set the compute
		if( observeReader.valueReadersMap.isValueLike.test(keyValue, keys.length - 1, keys, options) ) {
			observeReader.valueReadersMap.isValueLike.write(keyValue, value, options);
		} else {
			if(observeReader.valueReadersMap.isValueLike.test(parent, keys.length - 1, keys, options) ) {
				parent = parent[getValueSymbol$1]();
			}
			if(observeReader.propertyReadersMap.map.test(parent)) {
				observeReader.propertyReadersMap.map.write(parent, last.key, value, options);
			}
			else if(observeReader.propertyReadersMap.object.test(parent)) {
				observeReader.propertyReadersMap.object.write(parent, last.key, value, options);
				if(options.observation) {
					options.observation.update();
				}
			}
		}
	}
};
observeReader.propertyReaders.forEach(function(reader){
	observeReader.propertyReadersMap[reader.name] = reader;
});
observeReader.valueReaders.forEach(function(reader){
	observeReader.valueReadersMap[reader.name] = reader;
});
observeReader.set = observeReader.write;

var canStacheKey_1_3_2_canStacheKey = observeReader;

/**
 * @module {function} can-globals/location/location location
 * @parent can-globals/modules
 * 
 * Get the global [`location`](https://developer.mozilla.org/en-US/docs/Web/API/Window/location) object for the current context.
 * 
 * @signature `LOCATION([newLocation])`
 * 
 * Optionally sets, and returns, the [`location`](https://developer.mozilla.org/en-US/docs/Web/API/Window/location) object for the context.
 * 
 * ```js
 * var locationShim = { path: '/' };
 * var LOCATION = require('can-globals/location/location');
 * LOCATION(locationShim);
 * LOCATION().path; // -> '/'
 * ```
 *
 * @param {Object} location An optional location-like object to set as the context's location
 *
 * @return {Object} The location object for this JavaScript environment.
 */
canGlobals_1_1_1_canGlobalsInstance.define('location', function(){
	return canGlobals_1_1_1_canGlobalsInstance.getKeyValue('global').location;
});

var location = canGlobals_1_1_1_canGlobalsInstance.makeExport('location');

/**
 * @module {function} can-globals/mutation-observer/mutation-observer mutation-observer
 * @parent can-globals/modules
 * 
 * Get the global [`MutationObserver`](https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver) object for the current context.
 * 
 * @signature `MUTATIONOBSERVER([newMutationObserver])`
 * 
 * Optionally sets, and returns, the [`MutationObserver`](https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver) object for the context.
 * 
 * ```js
 * var mutationObserverShim = require('can-globals/mutation-observer/mutation-observer');
 * MUTATIONOBSERVER(mutationObserverShim);
 * MUTATIONOBSERVER() //-> MutationObserver
 * ```
 *
 * @param {Object} MutationObserver An optional MutationObserver-like object to set as the context's MutationObserver
 *
 * @return {Object} The MutationObserver object for this JavaScript environment.
 */

canGlobals_1_1_1_canGlobalsInstance.define('MutationObserver', function(){
	var GLOBAL = canGlobals_1_1_1_canGlobalsInstance.getKeyValue('global');
	return GLOBAL.MutationObserver || GLOBAL.WebKitMutationObserver || GLOBAL.MozMutationObserver;
});

var mutationObserver = canGlobals_1_1_1_canGlobalsInstance.makeExport('MutationObserver');

/**
 * @module {function} can-globals/custom-elements/custom-elements custom-elements
 * @parent can-globals/modules
 *
 * Get the global [`customElements`](https://developer.mozilla.org/en-US/docs/Web/API/Window/customElements) object for the current context.
 *
 * @signature `CUSTOMELEMENTS([newCustomElements])`
 *
 * Optionally sets, and returns, the [`customElements`](https://developer.mozilla.org/en-US/docs/Web/API/Window/customElements) object for the context.
 *
 * ```js
 * var customElementsShim = require('some-custom-elements-shim');
 * CUSTOMELEMENTS(customElementsShim);
 * CUSTOMELEMENTS() //-> customElementsShim
 * ```
 *
 * @param {Object} customElements An optional CustomElementRegistry-like object to set as the context's customElements
 *
 * @return {Object} The customElements object for this JavaScript environment.
 */

canGlobals_1_1_1_canGlobalsInstance.define('customElements', function(){
	var GLOBAL = canGlobals_1_1_1_canGlobalsInstance.getKeyValue('global');
	return GLOBAL.customElements;
});

var customElements = canGlobals_1_1_1_canGlobalsInstance.makeExport('customElements');

var canGlobals_1_1_1_canGlobals = canGlobals_1_1_1_canGlobalsInstance;

var push = Array.prototype.push;

function eliminate(array, item) {
	var index = array.indexOf(item);
	if (index >= 0) {
		array.splice(index, 1);
	}
}

function isInDocument (node) {
	var root = document$1().documentElement;
	if (root === node) {
		return true;
	}
	return root.contains(node);
}

function isDocumentElement (node) {
	return document$1().documentElement === node;
}

function isFragment (node) {
	return !!(node && node.nodeType === 11);
}

function getChildren (parentNode) {
	var nodes = [];
	var node = parentNode.firstChild;
	while (node) {
		nodes.push(node);
		node = node.nextSibling;
	}
	return nodes;
}

function getParents (node) {
	var nodes;
	if (isFragment(node)) {
		nodes = getChildren(node);
	} else {
		nodes = [node];
	}
	return nodes;
}

function getAllNodes (node) {
	var nodes = getParents(node);
	var cLen = nodes.length;
	for (var c = 0; c < cLen; c++) {
		var element = nodes[c];
		if (element.getElementsByTagName) {
			var descendants = element.getElementsByTagName('*');
			push.apply(nodes, descendants);
		}
	}

	return nodes;
}

function subscription (fn) {
	return function _subscription () {
		var disposal = fn.apply(this, arguments);
		var isDisposed = false;
		return function _disposal () {
			if (isDisposed) {
				var fnName = fn.name || fn.displayName || 'an anonymous function';
				var message = 'Disposal function returned by ' + fnName + ' called more than once.';
				throw new Error(message);
			}
			disposal.apply(this, arguments);
			isDisposed = true;
		};
	};
}

var canDomMutate_1_0_4_Util = {
	eliminate: eliminate,
	isInDocument: isInDocument,
	getDocument: document$1,
	isDocumentElement: isDocumentElement,
	isFragment: isFragment,
	getParents: getParents,
	getAllNodes: getAllNodes,
	getChildren: getChildren,
	subscription: subscription
};

var setImmediate = global_1().setImmediate || function (cb) {
	return setTimeout(cb, 0);
};


var getDocument = canDomMutate_1_0_4_Util.getDocument;
var eliminate$1 = canDomMutate_1_0_4_Util.eliminate;
var subscription$1 = canDomMutate_1_0_4_Util.subscription;
var isDocumentElement$1 = canDomMutate_1_0_4_Util.isDocumentElement;
var getAllNodes$1 = canDomMutate_1_0_4_Util.getAllNodes;

var push$1 = Array.prototype.push;
var slice$2 = Array.prototype.slice;

var domMutate;
var dataStore = new WeakMap();

function getRelatedData(node, key) {
	var data = dataStore.get(node);
	if (data) {
		return data[key];
	}
}

function setRelatedData(node, key, targetListenersMap) {
	var data = dataStore.get(node) || dataStore.set(node, {}).get(node);
	data[key] = targetListenersMap;
}

function deleteRelatedData(node, key) {
	var data = dataStore.get(node);
	return delete data[key];
}

function batch(processBatchItems, shouldDeduplicate) {
	var waitingBatch = [];
	var waitingCalls = [];
	var dispatchSet = new Set();
	var isPrimed = false;
	return function batchAdd(items, callback) {
		if (shouldDeduplicate) {
			for (var i = 0; i < items.length; i++) {
				var item = items[i];
				var target = item.target;
				if (!dispatchSet.has(target)) {
					waitingBatch.push(item);
					dispatchSet.add(target);
				}
			}
		} else {
			push$1.apply(waitingBatch, items);
		}
		if (callback) {
			waitingCalls.push(callback);
		}

		var shouldPrime = !isPrimed && waitingBatch.length > 0;
		if (shouldPrime) {
			isPrimed = true;
			setImmediate(function processBatch() {
				var currentBatch = waitingBatch;
				waitingBatch = [];
				var currentCalls = waitingCalls;
				waitingCalls = [];
				if (shouldDeduplicate) {
					dispatchSet = new Set();
				}
				isPrimed = false;
				processBatchItems(currentBatch);
				var callCount = currentCalls.length;
				for (var c = 0; c < callCount; c++) {
					currentCalls[c]();
				}
			});
		}
	};
}

function getDocumentListeners (target, key) {
	var doc = getDocument();
	var data = getRelatedData(doc, key);
	if (data) {
		return data.listeners;
	}
}

function getTargetListeners (target, key) {
	var doc = getDocument();
	var targetListenersMap = getRelatedData(doc, key);
	if (!targetListenersMap) {
		return;
	}

	return targetListenersMap.get(target);
}

function addTargetListener (target, key, listener) {
	var doc = getDocument();
	var targetListenersMap = getRelatedData(doc, key);
	if (!targetListenersMap) {
		targetListenersMap = new Map();
		setRelatedData(doc, key, targetListenersMap);
	}
	var targetListeners = targetListenersMap.get(target);
	if (!targetListeners) {
		targetListeners = [];
		targetListenersMap.set(target, targetListeners);
	}
	targetListeners.push(listener);
}

function removeTargetListener (target, key, listener) {
	var doc = getDocument();
	var targetListenersMap = getRelatedData(doc, key);
	if (!targetListenersMap) {
		return;
	}
	var targetListeners = targetListenersMap.get(target);
	if (!targetListeners) {
		return;
	}
	eliminate$1(targetListeners, listener);
	if (targetListeners.length === 0) {
		targetListenersMap['delete'](target);
		if (targetListenersMap.size === 0) {
			deleteRelatedData(doc, key);
		}
	}
}

function fire (callbacks, arg) {
	var safeCallbacks = slice$2.call(callbacks, 0);
	var safeCallbackCount = safeCallbacks.length;
	for (var i = 0; i < safeCallbackCount; i++) {
		safeCallbacks[i](arg);
	}
}

function dispatch$1(listenerKey, documentDataKey) {
	return function dispatchEvents(events) {
		for (var e = 0; e < events.length; e++) {
			var event = events[e];
			var target = event.target;

			var targetListeners = getTargetListeners(target, listenerKey);
			if (targetListeners) {
				fire(targetListeners, event);
			}

			if (!documentDataKey) {
				continue;
			}

			var documentListeners = getDocumentListeners(target, documentDataKey);
			if (documentListeners) {
				fire(documentListeners, event);
			}
		}
	};
}

function observeMutations(target, observerKey, config, handler) {
	var observerData = getRelatedData(target, observerKey);
	if (!observerData) {
		observerData = {
			observingCount: 0
		};
		setRelatedData(target, observerKey, observerData);
	}

	var setupObserver = function () {
		var MutationObserver = mutationObserver();
		if (MutationObserver) {
			var Node = global_1().Node;
			var isRealNode = !!(Node && target instanceof Node);
			if (isRealNode) {
				var targetObserver = new MutationObserver(handler);
				targetObserver.observe(target, config);
				observerData.observer = targetObserver;
			}
		} else {
			if (observerData.observer) {
				observerData.observer.disconnect();
				observerData.observer = null;
			}
		}
	};

	if (observerData.observingCount === 0) {
		canGlobals_1_1_1_canGlobals.onKeyValue('MutationObserver', setupObserver);
		setupObserver();
	}

	observerData.observingCount++;
	return function stopObservingMutations() {
		var observerData = getRelatedData(target, observerKey);
		if (observerData) {
			observerData.observingCount--;
			if (observerData.observingCount <= 0) {
				if (observerData.observer) {
					observerData.observer.disconnect();
				}
				deleteRelatedData(target, observerKey);
				canGlobals_1_1_1_canGlobals.offKeyValue('MutationObserver', setupObserver);
			}
		}
	};
}

function handleTreeMutations(mutations) {
	var mutationCount = mutations.length;
	for (var m = 0; m < mutationCount; m++) {
		var mutation = mutations[m];

		var addedNodes = mutation.addedNodes;
		var addedCount = addedNodes.length;
		for (var a = 0; a < addedCount; a++) {
			domMutate.dispatchNodeInsertion(addedNodes[a]);
		}

		var removedNodes = mutation.removedNodes;
		var removedCount = removedNodes.length;
		for (var r = 0; r < removedCount; r++) {
			domMutate.dispatchNodeRemoval(removedNodes[r]);
		}
	}
}

function handleAttributeMutations(mutations) {
	var mutationCount = mutations.length;
	for (var m = 0; m < mutationCount; m++) {
		var mutation = mutations[m];
		if (mutation.type === 'attributes') {
			var node = mutation.target;
			var attributeName = mutation.attributeName;
			var oldValue = mutation.oldValue;
			domMutate.dispatchNodeAttributeChange(node, attributeName, oldValue);
		}
	}
}

var treeMutationConfig = {
	subtree: true,
	childList: true
};

var attributeMutationConfig = {
	attributes: true,
	attributeOldValue: true
};

function addNodeListener(listenerKey, observerKey, isAttributes) {
	return subscription$1(function _addNodeListener(target, listener) {
		var stopObserving;
		if (isAttributes) {
			stopObserving = observeMutations(target, observerKey, attributeMutationConfig, handleAttributeMutations);
		} else {
			stopObserving = observeMutations(getDocument(), observerKey, treeMutationConfig, handleTreeMutations);
		}

		addTargetListener(target, listenerKey, listener);
		return function removeNodeListener() {
			stopObserving();
			removeTargetListener(target, listenerKey, listener);
		};
	});
}

function addGlobalListener(globalDataKey, addNodeListener) {
	return subscription$1(function addGlobalGroupListener(documentElement, listener) {
		if (!isDocumentElement$1(documentElement)) {
			throw new Error('Global mutation listeners must pass a documentElement');
		}

		var doc = getDocument();
		var documentData = getRelatedData(doc, globalDataKey);
		if (!documentData) {
			documentData = {listeners: []};
			setRelatedData(doc, globalDataKey, documentData);
		}

		var listeners = documentData.listeners;
		if (listeners.length === 0) {
			// We need at least on listener for mutation events to propagate
			documentData.removeListener = addNodeListener(doc, function () {});
		}

		listeners.push(listener);

		return function removeGlobalGroupListener() {
			var documentData = getRelatedData(doc, globalDataKey);
			if (!documentData) {
				return;
			}

			var listeners = documentData.listeners;
			eliminate$1(listeners, listener);
			if (listeners.length === 0) {
				documentData.removeListener();
				deleteRelatedData(doc, globalDataKey);
			}
		};
	});
}

function toMutationEvents (nodes) {
	var events = [];
	for (var i = 0; i < nodes.length; i++) {
		events.push({target: nodes[i]});
	}
	return events;
}

var domMutationPrefix = 'domMutation';

// target listener keys
var insertionDataKey = domMutationPrefix + 'InsertionData';
var removalDataKey = domMutationPrefix + 'RemovalData';
var attributeChangeDataKey = domMutationPrefix + 'AttributeChangeData';

// document listener keys
var documentInsertionDataKey = domMutationPrefix + 'DocumentInsertionData';
var documentRemovalDataKey = domMutationPrefix + 'DocumentRemovalData';
var documentAttributeChangeDataKey = domMutationPrefix + 'DocumentAttributeChangeData';

// observer keys
var treeDataKey = domMutationPrefix + 'TreeData';
var attributeDataKey = domMutationPrefix + 'AttributeData';

var dispatchInsertion = batch(dispatch$1(insertionDataKey, documentInsertionDataKey), true);
var dispatchRemoval = batch(dispatch$1(removalDataKey, documentRemovalDataKey), true);
var dispatchAttributeChange = batch(dispatch$1(attributeChangeDataKey, documentAttributeChangeDataKey));

// node listeners
var addNodeInsertionListener = addNodeListener(insertionDataKey, treeDataKey);
var addNodeRemovalListener = addNodeListener(removalDataKey, treeDataKey);
var addNodeAttributeChangeListener = addNodeListener(attributeChangeDataKey, attributeDataKey, true);

// global listeners
var addInsertionListener = addGlobalListener(
	documentInsertionDataKey,
	addNodeInsertionListener
);
var addRemovalListener = addGlobalListener(
	documentRemovalDataKey,
	addNodeRemovalListener
);
var addAttributeChangeListener = addGlobalListener(
	documentAttributeChangeDataKey,
	addNodeAttributeChangeListener
);

/**
 * @module {{}} can-dom-mutate
 * @parent can-dom-utilities
 * @collection can-infrastructure
 *
 * @description Dispatch and listen for DOM mutations.
 * @group can-dom-mutate.static 0 methods
 * @group can-dom-mutate/modules 1 modules
 * @signature `domMutate`
 *
 * `can-dom-mutate` exports an object that lets you listen to changes
 * in the DOM using the [MutationObserver](https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver)
 * API.
 *
 * ```js
 * import domMutate from "can-dom-mutate";
 *
 * domMutate //->
 * {
 *   onAttributeChange( documentElement, callback ),
 *   onInsertion( documentElement, callback ),
 *   onRemoval( documentElement, callback ),
 *   onNodeAttributeChange( node, callback ),
 *   onNodeInsertion( node, callback ),
 *   onNodeRemoval( node, callback )
 * }
 *
 * // listen to every attribute change within the document:
 * domMutate.onAttributeChange(document.documentElement, function(mutationRecord){
 *   mutationRecord.target        //-> <input>
 *   mutationRecord.attributeName //-> "name"
 *   mutationRecord.oldValue      //-> "Ramiya"
 * })
 * ```
 *
 * If you want to support browsers that do not support the `MutationObserver` api, use
 * [can-dom-mutate/node] to update the DOM. Every module within CanJS should do this:
 *
 * ```js
 * var mutate = require('can-dom-mutate/node');
 * var el = document.createElement('div');
 *
 * mutate.appendChild.call(document.body, el);
 * ```
 */
domMutate = {
	/**
	* @function can-dom-mutate.dispatchNodeInsertion dispatchNodeInsertion
	* @hide
	*
	* Dispatch an insertion mutation on the given node.
	*
	* @signature `dispatchNodeInsertion( node [, callback ] )`
	* @parent can-dom-mutate.static
	* @param {Node} node The node on which to dispatch an insertion mutation.
	* @param {function} callback The optional callback called after the mutation is dispatched.
	*/
	dispatchNodeInsertion: function (node, callback) {
		var events = toMutationEvents(getAllNodes$1(node));
		dispatchInsertion(events, callback);
	},

	/**
	* @function can-dom-mutate.dispatchNodeRemoval dispatchNodeRemoval
	* @hide
	*
	* Dispatch a removal mutation on the given node.
	*
	* @signature `dispatchNodeRemoval( node [, callback ] )`
	* @parent can-dom-mutate.static
	* @param {Node} node The node on which to dispatch a removal mutation.
	* @param {function} callback The optional callback called after the mutation is dispatched.
	*/
	dispatchNodeRemoval: function (node, callback) {
		var events = toMutationEvents(getAllNodes$1(node));
		dispatchRemoval(events, callback);
	},

	/**
	* @function can-dom-mutate.dispatchNodeAttributeChange dispatchNodeAttributeChange
	* @parent can-dom-mutate.static
	* @hide
	*
	* Dispatch an attribute change mutation on the given node.
	*
	* @signature `dispatchNodeAttributeChange( node, attributeName, oldValue [, callback ] )`
	*
	* ```
	* input.setAttribute("value", "newValue")
	* domMutate.dispatchNodeAttributeChange(input, "value","oldValue")
	* ```
	*
	*
	* @param {Node} target The node on which to dispatch an attribute change mutation.
	* @param {String} attributeName The attribute name whose value has changed.
	* @param {String} oldValue The attribute value before the change.
	* @param {function} callback The optional callback called after the mutation is dispatched.
	*/
	dispatchNodeAttributeChange: function (target, attributeName, oldValue, callback) {
		dispatchAttributeChange([{
			target: target,
			attributeName: attributeName,
			oldValue: oldValue
		}], callback);
	},

	/**
	* @function can-dom-mutate.onNodeInsertion onNodeInsertion
	*
	* Listen for insertion mutations on the given node.
	*
	* @signature `onNodeInsertion( node, callback )`
	* @parent can-dom-mutate.static
	* @param {Node} node The node on which to listen for insertion mutations.
	* @param {function} callback The callback called when an insertion mutation is dispatched.
	* @return {function} The callback to remove the mutation listener.
	*/
	onNodeInsertion: addNodeInsertionListener,

	/**
	* @function can-dom-mutate.onNodeRemoval onNodeRemoval
	*
	* Listen for removal mutations on the given node.
	*
	* @signature `onNodeRemoval( node, callback )`
	* @parent can-dom-mutate.static
	* @param {Node} node The node on which to listen for removal mutations.
	* @param {function} callback The callback called when a removal mutation is dispatched.
	* @return {function} The callback to remove the mutation listener.
	*/
	onNodeRemoval: addNodeRemovalListener,

	/**
	* @function can-dom-mutate.onNodeAttributeChange onNodeAttributeChange
	*
	* Listen for attribute change mutations on the given node.
	*
	* @signature `onNodeAttributeChange( node, callback )`
	* @parent can-dom-mutate.static
	* @param {Node} node The node on which to listen for attribute change mutations.
	* @param {function} callback The callback called when an attribute change mutation is dispatched.
	* @return {function} The callback to remove the mutation listener.
	*/
	onNodeAttributeChange: addNodeAttributeChangeListener,

	/**
	* @function can-dom-mutate.onRemoval onRemoval
	*
	* Listen for removal mutations on any node within the documentElement.
	*
	* @signature `onRemoval( documentElement, callback )`
	* @parent can-dom-mutate.static
	* @param {Node} documentElement The documentElement on which to listen for removal mutations.
	* @param {function} callback The callback called when a removal mutation is dispatched.
	* @return {function} The callback to remove the mutation listener.
	*/
	onRemoval: addRemovalListener,

	/**
	* @function can-dom-mutate.onInsertion onInsertion
	*
	* Listen for insertion mutations on any node within the documentElement.
	*
	* @signature `onInsertion( documentElement, callback )`
	* @parent can-dom-mutate.static
	* @param {Node} documentElement The documentElement on which to listen for removal mutations.
	* @param {function} callback The callback called when a insertion mutation is dispatched.
	* @return {function} The callback to remove the mutation listener.
	*/
	onInsertion: addInsertionListener,

	/**
	* @function can-dom-mutate.onAttributeChange onAttributeChange
	*
	* Listen for attribute change mutations on any node within the documentElement.
	*
	* @signature `onAttributeChange( documentElement, callback )`
	* @parent can-dom-mutate.static
	* @param {Node} documentElement The documentElement on which to listen for removal mutations.
	* @param {function} callback The callback called when an attribute change mutation is dispatched.
	* @return {function} The callback to remove the mutation listener.
	*/
	onAttributeChange: addAttributeChangeListener
};

var canDomMutate_1_0_4_canDomMutate = domMutate;

// # can/control/control.js
//
// Create organized, memory-leak free, rapidly performing, stateful
// controls with declarative eventing binding. Used when creating UI
// controls with behaviors, bound to elements on the page.
// ## helpers














var processors;
var controlData = new WeakMap();

// ### bind
// this helper binds to one element and returns a function that unbinds from that element.
var bind = function (el, ev, callback, queue) {

    map$1.on.call(el, ev, callback, queue);

	return function () {
        map$1.off.call(el, ev, callback, queue);
	};
},
	slice$3 = [].slice,
	paramReplacer = /\{([^\}]+)\}/g,

	// ### delegate
	//
	// this helper binds to elements based on a selector and returns a
	// function that unbinds.
	delegate = function (el, selector, ev, callback) {
        map$1.on.call(el, ev, selector, callback);

		return function () {
            map$1.off.call(el, ev, selector, callback);
		};
	},

	// ### binder
	//
	// Calls bind or unbind depending if there is a selector.
	binder = function (el, ev, callback, selector) {
		return selector ?
			delegate(el, selector.trim(), ev, callback) :
			bind(el, ev, callback);
	},

	basicProcessor;

var Control = canConstruct_3_4_4_canConstruct.extend("Control",
	// ## *static functions*
	/**
	 * @static
	 */
	{
		// ## can.Control.setup
		//
		// This function pre-processes which methods are event listeners and which are methods of
		// the control. It has a mechanism to allow controllers to inherit default values from super
		// classes, like `can.Construct`, and will cache functions that are action functions (see `_isAction`)
		// or functions with an underscored name.
		setup: function () {
			canConstruct_3_4_4_canConstruct.setup.apply(this, arguments);

			if (Control) {
				var control = this,
					funcName;

				control.actions = {};
				for (funcName in control.prototype) {
					if (control._isAction(funcName)) {
						control.actions[funcName] = control._action(funcName);
					}
				}
			}
		},
		// ## can.Control._shifter
		//
		// Moves `this` to the first argument, wraps it with `jQuery` if it's
		// an element.
		_shifter: function (context, name) {
			var method = typeof name === "string" ? context[name] : name;

			if (typeof method !== "function") {
				method = context[method];
			}
            var Control = this;
			function controlMethod() {
				var wrapped = Control.wrapElement(this);
				context.called = name;
				return method.apply(context, [wrapped].concat(slice$3.call(arguments, 0)));
			}
            //!steal-remove-start
        	Object.defineProperty(controlMethod, "name", {
        		value: canReflect_1_16_7_canReflect.getName(this) + "["+name+"]",
        	});
        	//!steal-remove-end
            return controlMethod;
		},

		// ## can.Control._isAction
		//
		// Return `true` if `methodName` refers to an action. An action is a `methodName` value that
		// is not the constructor, and is either a function or string that refers to a function, or is
		// defined in `special`, `processors`. Detects whether `methodName` is also a valid method name.
		_isAction: function (methodName) {
			var val = this.prototype[methodName],
				type = typeof val;

			return (methodName !== 'constructor') &&
			(type === "function" || (type === "string" && (typeof this.prototype[val] === "function") )) &&
			!! (Control.isSpecial(methodName) || processors[methodName] || /[^\w]/.test(methodName));
		},
		// ## can.Control._action
		//
		// Takes a method name and the options passed to a control and tries to return the data
		// necessary to pass to a processor (something that binds things).
		//
		// For performance reasons, `_action` is called twice:
		// * It's called when the Control class is created. for templated method names (e.g., `{window} foo`), it returns null. For non-templated method names it returns the event binding data. That data is added to `this.actions`.
		// * It is called wehn a control instance is created, but only for templated actions.
		_action: function(methodName, options, controlInstance) {
			var readyCompute,
                unableToBind;

			// If we don't have options (a `control` instance), we'll run this later. If we have
			// options, run `can.sub` to replace the action template `{}` with values from the `options`
			// or `window`. If a `{}` template resolves to an object, `convertedName` will be an array.
			// In that case, the event name we want will be the last item in that array.
			paramReplacer.lastIndex = 0;
			if (options || !paramReplacer.test(methodName)) {
                var controlActionData = function() {
					var delegate;

					// Set the delegate target and get the name of the event we're listening to.
					var name = methodName.replace(paramReplacer, function(matched, key) {
						var value, parent;

						// If listening directly to a delegate target, set it
						if (this._isDelegate(options, key)) {
							delegate = this._getDelegate(options, key);
							return "";
						}

						// If key contains part of the lookup path, remove it.
						// This is needed for bindings like {viewModel.foo} in can-component's Control.
						key = this._removeDelegateFromKey(key);

						// set the parent (where the key will be read from)
						parent = this._lookup(options)[0];

						value = canStacheKey_1_3_2_canStacheKey.read(parent, canStacheKey_1_3_2_canStacheKey.reads(key), {
							// if we find a compute, we should bind on that and not read it
							readCompute: false
						}).value;

						// If `value` is undefined try to get the value from the window.
						if (value === undefined && typeof window !== 'undefined') {
							value = get_1(window, key);
						}

						// if the parent is not an observable and we don't have a value, show a warning
						// in this situation, it is not possible for the event handler to be triggered
						if (!parent || !(canReflect_1_16_7_canReflect.isObservableLike(parent) && canReflect_1_16_7_canReflect.isMapLike(parent)) && !value) {
                            unableToBind = true;
							return null;
						}

						// If `value` is a string we just return it, otherwise we set it as a delegate target.
						if (typeof value === "string") {
							return value;
						} else {
							delegate = value;
							return "";
						}
					}.bind(this));

					// removing spaces that get added when converting
					// `{element} click` -> ` click`
					name = name.trim();

					// Get the name of the `event` we're listening to.
					var parts = name.split(/\s+/g),
						event = parts.pop();

					// Return everything needed to handle the event we're listening to.
					return {
						processor: this.processors[event] || basicProcessor,
						parts: [name, parts.join(" "), event],
						delegate: delegate || undefined
					};
				};

                //!steal-remove-start
            	Object.defineProperty(controlActionData, "name", {
            		value: canReflect_1_16_7_canReflect.getName(controlInstance || this.prototype) + "["+methodName+"].actionData",
            	});
            	//!steal-remove-end

				readyCompute = new canObservation_4_0_1_canObservation(controlActionData, this);


				if (controlInstance) {
					// Create a handler function that we'll use to handle the `change` event on the `readyCompute`.
					var handler = function(actionData) {
						// unbinds the old binding
						controlInstance._bindings.control[methodName](controlInstance.element);
						// binds the new
						controlInstance._bindings.control[methodName] = actionData.processor(
							actionData.delegate || controlInstance.element,
							actionData.parts[2], actionData.parts[1], methodName, controlInstance);
					};

                    //!steal-remove-start
                	Object.defineProperty(handler, "name", {
                		value: canReflect_1_16_7_canReflect.getName(controlInstance) + "["+methodName+"].handler",
                	});
                	//!steal-remove-end


					canReflect_1_16_7_canReflect.onValue(readyCompute, handler, "mutate");
                    //!steal-remove-start
                    if(unableToBind) {
                        dev.log('can-control: No property found for handling ' + methodName);
                    }
                    //!steal-remove-end

					controlInstance._bindings.readyComputes[methodName] = {
						compute: readyCompute,
						handler: handler
					};
				}

				return readyCompute.get();
			}
		},
		// the lookup path - where templated keys will be looked up
		_lookup: function (options) {
			return [options, window];
		},
		// strip strings that represent delegates from the key
		_removeDelegateFromKey: function (key) {
			return key;
		},
		// return whether the key is a delegate
		_isDelegate: function(options, key) {
			return key === 'element';
		},
		// return the delegate object for a given key
		_getDelegate: function(options, key) {
			return undefined;
		},
		// ## can.Control.processors
		//
		// An object of `{eventName : function}` pairs that Control uses to
		// hook up events automatically.
		processors: {},
		// ## can.Control.defaults
		// A object of name-value pairs that act as default values for a control instance
		defaults: {},
        // should be used to overwrite to make nodeLists on this
        convertElement: function(element) {
            element = typeof element === "string" ?
							document.querySelector(element) : element;

						return this.wrapElement(element);
        },
        wrapElement: function(el){
            return el;
        },
        unwrapElement: function(el){
            return el;
        },
        // should be overwritten to look in jquery special events
        isSpecial: function(eventName){
            return eventName === "inserted" || eventName === "removed";
        }
	}, {
		// ## *prototype functions*
		/**
		 * @prototype
		 */
		// ## setup
		//
		// Setup is where most of the Control's magic happens. It performs several pre-initialization steps:
		// - Sets `this.element`
		// - Adds the Control's name to the element's className
		// - Saves the Control in `$.data`
		// - Merges Options
		// - Binds event handlers using `delegate`
		// The final step is to return pass the element and prepareed options, to be used in `init`.
		setup: function (element, options) {

			var cls = this.constructor,
				pluginname = cls.pluginName || cls.shortName,
				arr;

			if (!element) {
				throw new Error('Creating an instance of a named control without passing an element');
			}
			// Retrieve the raw element, then set the plugin name as a class there.
            this.element = cls.convertElement(element);

			if (pluginname && pluginname !== 'Control' && this.element.classList) {
                this.element.classList.add(pluginname);
			}

			// Set up the 'controls' data on the element. If it does not exist, initialize
			// it to an empty array.
			arr = controlData.get(this.element);
			if (!arr) {
				arr = [];
				controlData.set(this.element, arr);
			}
			arr.push(this);

			// The `this.options` property is an Object that contains configuration data
			// passed to a control when it is created (`new can.Control(element, options)`)
			//
			// The `options` argument passed when creating the control is merged with `can.Control.defaults`
			// in [can.Control.prototype.setup setup].
			//
			// If no `options` value is used during creation, the value in `defaults` is used instead
			if (canReflect_1_16_7_canReflect.isObservableLike(options) && canReflect_1_16_7_canReflect.isMapLike(options)) {
				for (var prop in cls.defaults) {
					if (!options.hasOwnProperty(prop)) {
						canStacheKey_1_3_2_canStacheKey.set(options, prop, cls.defaults[prop]);
					}
				}
				this.options = options;
			} else {
				this.options = canAssign_1_1_1_canAssign( canAssign_1_1_1_canAssign({}, cls.defaults), options);
			}

			this.on();

			return [this.element, this.options];
		},
		// ## on
		//
		// This binds an event handler for an event to a selector under the scope of `this.element`
		// If no options are specified, all events are rebound to their respective elements. The actions,
		// which were cached in `setup`, are used and all elements are bound using `delegate` from `this.element`.
		on: function (el, selector, eventName, func) {
			if (!el) {
				this.off();

				var cls = this.constructor,
					bindings = this._bindings,
					actions = cls.actions,
					element = this.constructor.unwrapElement(this.element),
					destroyCB = Control._shifter(this, "destroy"),
					funcName, ready;

				for (funcName in actions) {
					// Only push if we have the action and no option is `undefined`
					if ( actions.hasOwnProperty(funcName) ) {
						ready = actions[funcName] || cls._action(funcName, this.options, this);
						if( ready ) {
							bindings.control[funcName]  = ready.processor(ready.delegate || element,
								ready.parts[2], ready.parts[1], funcName, this);
						}
					}
				}

				// Set up the ability to `destroy` the control later.
				var removalDisposal = canDomMutate_1_0_4_canDomMutate.onNodeRemoval(element, function () {
					if (!element.ownerDocument.contains(element)) {
						destroyCB();
					}
				});
				bindings.user.push(function () {
					if (removalDisposal) {
						removalDisposal();
						removalDisposal = undefined;
					}
				});
				return bindings.user.length;
			}

			// if `el` is a string, use that as `selector` and re-set it to this control's element...
			if (typeof el === 'string') {
				func = eventName;
				eventName = selector;
				selector = el;
				el = this.element;
			}

			// ...otherwise, set `selector` to null
			if (func === undefined) {
				func = eventName;
				eventName = selector;
				selector = null;
			}

			if (typeof func === 'string') {
				func = Control._shifter(this, func);
			}

			this._bindings.user.push(binder(el, eventName, func, selector));

			return this._bindings.user.length;
		},
		// ## off
		//
		// Unbinds all event handlers on the controller.
		// This should _only_ be called in combination with .on()
		off: function () {
			var el = this.constructor.unwrapElement(this.element),
				bindings = this._bindings;
			if( bindings ) {
				(bindings.user || []).forEach(function (value) {
					value(el);
				});
				canReflect_1_16_7_canReflect.eachKey(bindings.control || {}, function (value) {
					value(el);
				});
				canReflect_1_16_7_canReflect.eachKey(bindings.readyComputes || {}, function(value) {
					canReflect_1_16_7_canReflect.offValue(value.compute, value.handler, "mutate");
				});
			}
			// Adds bindings.
			this._bindings = {user: [], control: {}, readyComputes: {}};
		},
		// ## destroy
		//
		// Prepares a `control` for garbage collection.
		// First checks if it has already been removed. Then, removes all the bindings, data, and
		// the element from the Control instance.
		destroy: function () {
			if (this.element === null) {
				//!steal-remove-start
				dev.warn("can-control: Control already destroyed");
				//!steal-remove-end
				return;
			}
			var Class = this.constructor,
				pluginName = Class.pluginName || (Class.shortName && canString_0_0_5_canString.underscore(Class.shortName)),
				controls;

			this.off();

			if (pluginName && pluginName !== 'can_control' && this.element.classList) {
                this.element.classList.remove(pluginName);
			}

			controls = controlData.get(this.element);
			if (controls) {
				controls.splice(controls.indexOf(this), 1);
			}

			//canEvent.dispatch.call(this, "destroyed");

			this.element = null;
		}
	});

// ## Processors
//
// Processors do the binding. This basic processor binds events. Each returns a function that unbinds
// when called.
processors = Control.processors;
basicProcessor = function (el, event, selector, methodName, control) {
	return binder(el, event, Control._shifter(control, methodName), selector);
};

// Set common events to be processed as a `basicProcessor`
["beforeremove", "change", "click", "contextmenu", "dblclick", "keydown", "keyup",
	"keypress", "mousedown", "mousemove", "mouseout", "mouseover",
	"mouseup", "reset", "resize", "scroll", "select", "submit", "focusin",
	"focusout", "mouseenter", "mouseleave",
	"touchstart", "touchmove", "touchcancel", "touchend", "touchleave",
	"inserted","removed",
	"dragstart", "dragenter", "dragover", "dragleave", "drag", "drop", "dragend"
].forEach(function (v) {
	processors[v] = basicProcessor;
});

var canControl_4_1_0_canControl = canNamespace_1_0_0_canNamespace.Control = Control;

// ## Helpers
// Attribute names to ignore for setting viewModel values.
var paramReplacer$1 = /\{([^\}]+)\}/g;

var ComponentControl = canControl_4_1_0_canControl.extend({
		// the lookup path - where templated keys will be looked up
		// change lookup to first look in the viewModel
		_lookup: function(options) {
			return [options.scope, options, window];
		},
		// strip strings that represent delegates from the key
		// viewModel.foo -> foo
		_removeDelegateFromKey: function (key) {
			return key.replace(/^(scope|^viewModel)\./, "");
		},
		// return whether the key is a delegate
		_isDelegate: function(options, key) {
			return key === 'scope' || key === 'viewModel';
		},
		// return the delegate object for a given key
		_getDelegate: function(options, key) {
			return options[key];
		},
		_action: function(methodName, options, controlInstance) {
			var hasObjectLookup;

			paramReplacer$1.lastIndex = 0;

			hasObjectLookup = paramReplacer$1.test(methodName);

			// If we don't have options (a `control` instance), we'll run this later.
			if (!controlInstance && hasObjectLookup) {
				return;
			} else {
				return canControl_4_1_0_canControl._action.apply(this, arguments);
			}
		}
	},
	// Extend `events` with a setup method that listens to changes in `viewModel` and
	// rebinds all templated event handlers.
	{
		setup: function(el, options) {
			this.scope = options.scope;
			this.viewModel = options.viewModel;
			return canControl_4_1_0_canControl.prototype.setup.call(this, el, options);
		},
		off: function() {
			// If `this._bindings` exists we need to go through it's `readyComputes` and manually
			// unbind `change` event listeners set by the controller.
			if (this._bindings) {
				canReflect_1_16_7_canReflect.eachKey(this._bindings.readyComputes || {}, function(value) {
					canReflect_1_16_7_canReflect.offValue(value.compute, value.handler);
				});
			}
			// Call `Control.prototype.off` function on this instance to cleanup the bindings.
			canControl_4_1_0_canControl.prototype.off.apply(this, arguments);
			this._bindings.readyComputes = {};
		},
		destroy: function() {
			canControl_4_1_0_canControl.prototype.destroy.apply(this, arguments);
			if (typeof this.options.destroy === 'function') {
				this.options.destroy.apply(this, arguments);
			}
		}
	});

var control = ComponentControl;

var canAttributeEncoder_1_0_5_canAttributeEncoder = createCommonjsModule(function (module) {
/**
 * @module {{}} can-attribute-encoder can-attribute-encoder
 * @parent can-dom-utilities
 * @collection can-infrastructure
 * @package ./package.json
 *
 * Encode and decode attribute names.
 *
 * @option {Object} An object with the methods:
 * [can-attribute-encoder.encode] and [can-attribute-encoder.decode].
 *
 */


function each(items, callback){
	for ( var i = 0; i < items.length; i++ ) {
		callback(items[i], i);
	}
}

function makeMap(str){
	var obj = {}, items = str.split(",");
	each(items, function(name){
		obj[name] = true;
	});
	return obj;
}

// Attributes for which the case matters - shouldnâ€™t be lowercased.
var caseMattersAttributes = makeMap("allowReorder,attributeName,attributeType,autoReverse,baseFrequency,baseProfile,calcMode,clipPathUnits,contentScriptType,contentStyleType,diffuseConstant,edgeMode,externalResourcesRequired,filterRes,filterUnits,glyphRef,gradientTransform,gradientUnits,kernelMatrix,kernelUnitLength,keyPoints,keySplines,keyTimes,lengthAdjust,limitingConeAngle,markerHeight,markerUnits,markerWidth,maskContentUnits,maskUnits,patternContentUnits,patternTransform,patternUnits,pointsAtX,pointsAtY,pointsAtZ,preserveAlpha,preserveAspectRatio,primitiveUnits,repeatCount,repeatDur,requiredExtensions,requiredFeatures,specularConstant,specularExponent,spreadMethod,startOffset,stdDeviation,stitchTiles,surfaceScale,systemLanguage,tableValues,textLength,viewBox,viewTarget,xChannelSelector,yChannelSelector");

function camelCaseToSpinalCase(match, lowerCaseChar, upperCaseChar) {
	return lowerCaseChar + "-" + upperCaseChar.toLowerCase();
}

function startsWith(allOfIt, startsWith) {
	return allOfIt.indexOf(startsWith) === 0;
}

function endsWith(allOfIt, endsWith) {
	return (allOfIt.length - allOfIt.indexOf(endsWith)) === endsWith.length;
}

var regexes = {
	leftParens: /\(/g,
	rightParens: /\)/g,
	leftBrace: /\{/g,
	rightBrace: /\}/g,
	camelCase: /([a-z]|^)([A-Z])/g,
	forwardSlash: /\//g,
	space: /\s/g,
	uppercase: /[A-Z]/g,
	uppercaseDelimiterThenChar: /:u:([a-z])/g,
	caret: /\^/g,
	dollar: /\$/g,
	at: /@/g
};

var delimiters = {
	prependUppercase: ':u:',
	replaceSpace: ':s:',
	replaceForwardSlash: ':f:',
	replaceLeftParens: ':lp:',
	replaceRightParens: ':rp:',
	replaceLeftBrace: ':lb:',
	replaceRightBrace: ':rb:',
	replaceCaret: ':c:',
	replaceDollar: ':d:',
	replaceAt: ':at:'
};

var encoder = {};

/**
 * @function can-attribute-encoder.encode encode
 * @parent can-attribute-encoder
 * @description Encode an attribute name
 *
 * @signature `encoder.encode(attributeName)`
 *
 * Note: specific encoding may change, but encoded attributes
 * can always be decoded using [can-attribute-encoder.decode].
 *
 * @body
 *
 * ```js
 * var encodedAttributeName = encoder.encode("{(^$foo/bar baz)}");
 * div.setAttribute(encodedAttributeName, "attribute value");
 * ```
 *
 * @param {String} attributeName The attribute name.
 * @return {String} The encoded attribute name.
 *
 */
encoder.encode = function(name) {
	var encoded = name;

	// encode or convert camelCase attributes unless in list of attributes
	// where case matters
	if (!caseMattersAttributes[encoded] && encoded.match(regexes.camelCase)) {
		// encode uppercase characters in new bindings
		// - on:fooBar, fooBar:to, fooBar:from, fooBar:bind
		if (
			startsWith(encoded, 'on:') ||
			endsWith(encoded, ':to') ||
			endsWith(encoded, ':from') ||
			endsWith(encoded, ':bind') ||
			endsWith(encoded, ':raw')
		) {
			encoded = encoded
				.replace(regexes.uppercase, function(char) {
					return delimiters.prependUppercase + char.toLowerCase();
				});
		} else if(startsWith(encoded, '(') || startsWith(encoded, '{')) {
			// convert uppercase characters in older bindings to kebab-case
			// - {fooBar}, (fooBar), {(fooBar)}
			encoded = encoded.replace(regexes.camelCase, camelCaseToSpinalCase);
			//!steal-remove-start
			dev.warn("can-attribute-encoder: Found attribute with name: " + name + ". Converting to: " + encoded + '.');
			//!steal-remove-end
		}
	}

	//encode spaces
	encoded = encoded.replace(regexes.space, delimiters.replaceSpace)
		//encode forward slashes
		.replace(regexes.forwardSlash, delimiters.replaceForwardSlash)
		// encode left parentheses
		.replace(regexes.leftParens, delimiters.replaceLeftParens)
		// encode right parentheses
		.replace(regexes.rightParens, delimiters.replaceRightParens)
		// encode left braces
		.replace(regexes.leftBrace, delimiters.replaceLeftBrace)
		// encode left braces
		.replace(regexes.rightBrace, delimiters.replaceRightBrace)
		// encode ^
		.replace(regexes.caret, delimiters.replaceCaret)
		// encode $
		.replace(regexes.dollar, delimiters.replaceDollar)
		// encode @
		.replace(regexes.at, delimiters.replaceAt);

	return encoded;
};

/**
 * @function can-attribute-encoder.decode decode
 * @parent can-attribute-encoder
 * @description Decode an attribute name encoded by [can-attribute-encoder.encode]
 * @signature `encoder.decode(attributeName)`
 *
 * @body
 *
 * ```js
 * encoder.decode(attributeName); // -> "{(^$foo/bar baz)}"
 *
 * ```
 *
 * @param {String} attributeName The encoded attribute name.
 * @return {String} The decoded attribute name.
 *
 */
encoder.decode = function(name) {
	var decoded = name;

	// decode uppercase characters in new bindings
	if (!caseMattersAttributes[decoded] && decoded.match(regexes.uppercaseDelimiterThenChar)) {
		if (
			startsWith(decoded, 'on:') ||
			endsWith(decoded, ':to') ||
			endsWith(decoded, ':from') ||
			endsWith(decoded, ':bind') ||
			endsWith(decoded, ':raw')
		) {
			decoded = decoded
				.replace(regexes.uppercaseDelimiterThenChar, function(match, char) {
					return char.toUpperCase();
				});
		}
	}

	// decode left parentheses
	decoded = decoded.replace(delimiters.replaceLeftParens, '(')
		// decode right parentheses
		.replace(delimiters.replaceRightParens, ')')
		// decode left braces
		.replace(delimiters.replaceLeftBrace, '{')
		// decode left braces
		.replace(delimiters.replaceRightBrace, '}')
		// decode forward slashes
		.replace(delimiters.replaceForwardSlash, '/')
		// decode spaces
		.replace(delimiters.replaceSpace, ' ')
		// decode ^
		.replace(delimiters.replaceCaret, '^')
		//decode $
		.replace(delimiters.replaceDollar, '$')
		//decode @
		.replace(delimiters.replaceAt, '@');

	return decoded;
};

if (canNamespace_1_0_0_canNamespace.encoder) {
	throw new Error("You can't have two versions of can-attribute-encoder, check your dependencies");
} else {
	module.exports = canNamespace_1_0_0_canNamespace.encoder = encoder;
}
});

/* jshint maxdepth:7,node:true, latedef:false */


function each$5(items, callback){
	for ( var i = 0; i < items.length; i++ ) {
		callback(items[i], i);
	}
}

function makeMap$1(str){
	var obj = {}, items = str.split(",");
	each$5(items, function(name){
		obj[name] = true;
	});
	return obj;
}

function handleIntermediate(intermediate, handler){
	for(var i = 0, len = intermediate.length; i < len; i++) {
		var item = intermediate[i];
		handler[item.tokenType].apply(handler, item.args);
	}
	return intermediate;
}

//!steal-remove-start
function countLines(input) {
	// TODO: optimize?
	return input.split('\n').length - 1;
}
//!steal-remove-end

var alphaNumeric = "A-Za-z0-9",
	alphaNumericHU = "-:_"+alphaNumeric,
	magicStart = "{{",
	endTag = new RegExp("^<\\/(["+alphaNumericHU+"]+)[^>]*>"),
	magicMatch = new RegExp("\\{\\{(![\\s\\S]*?!|[\\s\\S]*?)\\}\\}\\}?","g"),
	space = /\s/,
	alphaRegex = new RegExp('['+ alphaNumeric + ']'),
	attributeRegexp = new RegExp("["+alphaNumericHU+"]+\s*=\s*(\"[^\"]*\"|'[^']*')");

// Empty Elements - HTML 5
var empty = makeMap$1("area,base,basefont,br,col,frame,hr,img,input,isindex,link,meta,param,embed");

// Elements for which tag case matters - shouldn't be lowercased.
var caseMattersElements = makeMap$1("altGlyph,altGlyphDef,altGlyphItem,animateColor,animateMotion,animateTransform,clipPath,feBlend,feColorMatrix,feComponentTransfer,feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,feDistantLight,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,foreignObject,glyphRef,linearGradient,radialGradient,textPath");

// Elements that you can, intentionally, leave open
// (and which close themselves)
var closeSelf = makeMap$1("colgroup,dd,dt,li,options,p,td,tfoot,th,thead,tr");

// Special Elements (can contain anything)
var special = makeMap$1("script");

// Callback names on `handler`.
var tokenTypes = "start,end,close,attrStart,attrEnd,attrValue,chars,comment,special,done".split(",");

//maps end characters to start characters
var startOppositesMap = {"{": "}", "(":")"};

var fn = function(){};

var HTMLParser = function (html, handler, returnIntermediate) {
	if(typeof html === "object") {
		return handleIntermediate(html, handler);
	}

	var intermediate = [];
	handler = handler || {};
	if(returnIntermediate) {
		// overwrite handlers so they add to intermediate
		each$5(tokenTypes, function(name){
			var callback = handler[name] || fn;
			handler[name] = function(){
				if( callback.apply(this, arguments) !== false ) {
					var end = arguments.length;

					// the intermediate is stringified in the compiled stache templates
					// so we want to trim the last item if it is the line number
					if (arguments[end - 1] === undefined) {
						end = arguments.length - 1;
					}

					//!steal-remove-start
					// but restore line number in dev mode
					end = arguments.length;
					//!steal-remove-end

					intermediate.push({
						tokenType: name,
						args: [].slice.call(arguments, 0, end),
					});
				}
			};
		});
	}

	function parseStartTag(tag, tagName, rest, unary) {
		tagName = caseMattersElements[tagName] ? tagName : tagName.toLowerCase();

		if (closeSelf[tagName] && stack.last() === tagName) {
			parseEndTag("", tagName);
		}

		unary = empty[tagName] || !!unary;
		handler.start(tagName, unary, lineNo);
		if (!unary) {
			stack.push(tagName);
		}

		// find attribute or special
		HTMLParser.parseAttrs(rest, handler, lineNo);

		//!steal-remove-start
		lineNo += countLines(tag);
		//!steal-remove-end


		handler.end(tagName, unary, lineNo);

	}

	function parseEndTag(tag, tagName) {
		// If no tag name is provided, clean shop
		var pos;
		if (!tagName) {
			pos = 0;
		}
		// Find the closest opened tag of the same type
		else {
			tagName = caseMattersElements[tagName] ? tagName : tagName.toLowerCase();
			for (pos = stack.length - 1; pos >= 0; pos--) {
				if (stack[pos] === tagName) {
					break;
				}
			}
		}

		//!steal-remove-start
		if (typeof tag === 'undefined') {
			if (stack.length > 0) {
				if (handler.filename) {
					dev.warn(handler.filename + ": expected closing tag </" + stack[pos] + ">");
				}
				else {
					dev.warn("expected closing tag </" + stack[pos] + ">");
				}
			}
		} else if (pos < 0 || pos !== stack.length - 1) {
			if (stack.length > 0) {
				if (handler.filename) {
					dev.warn(handler.filename + ":" + lineNo + ": unexpected closing tag " + tag + " expected </" + stack[stack.length - 1] + ">");
				}
				else {
					dev.warn(lineNo + ": unexpected closing tag " + tag + " expected </" + stack[stack.length - 1] + ">");
				}
			} else {
				if (handler.filename) {
					dev.warn(handler.filename + ":" + lineNo + ": unexpected closing tag " + tag);
				}
				else {
					dev.warn(lineNo + ": unexpected closing tag " + tag);
				}
			}
		}
		//!steal-remove-end

		if (pos >= 0) {
			// Close all the open elements, up the stack
			for (var i = stack.length - 1; i >= pos; i--) {
				if (handler.close) {
					handler.close(stack[i], lineNo);
				}
			}

			// Remove the open elements from the stack
			stack.length = pos;
		}
	}

	function parseMustache(mustache, inside){
		if(handler.special){
			handler.special(inside, lineNo);
		}
	}

	var callChars = function(){
		if(charsText) {
			if(handler.chars) {
				handler.chars(charsText, lineNo);
			}

			//!steal-remove-start
			lineNo += countLines(charsText);
			//!steal-remove-end
		}

		charsText = "";
	};

	var index,
		chars,
		match,
		lineNo,
		stack = [],
		last = html,
		// an accumulating text for the next .chars callback
		charsText = "";

	//!steal-remove-start
	lineNo = 1;
	//!steal-remove-end

	stack.last = function () {
		return this[this.length - 1];
	};

	while (html) {

		chars = true;

		// Make sure we're not in a script or style element
		if (!stack.last() || !special[stack.last()]) {

			// Comment
			if (html.indexOf("<!--") === 0) {
				index = html.indexOf("-->");

				if (index >= 0) {
					callChars();
					if (handler.comment) {
						handler.comment(html.substring(4, index), lineNo);
					}

					//!steal-remove-start
					lineNo += countLines(html.substring(0, index + 3));
					//!steal-remove-end

					html = html.substring(index + 3);
					chars = false;
				}

				// end tag
			} else if (html.indexOf("</") === 0) {
				match = html.match(endTag);

				if (match) {
					callChars();
					match[0].replace(endTag, parseEndTag);

					//!steal-remove-start
					lineNo += countLines(html.substring(0, match[0].length));
					//!steal-remove-end

					html = html.substring(match[0].length);
					chars = false;
				}

				// start tag
			} else if (html.indexOf("<") === 0) {
				var res = HTMLParser.searchStartTag(html);

				if(res) {
					callChars();
					parseStartTag.apply(null, res.match);

					html = res.html;
					chars = false;
				}

				// magic tag
			} else if (html.indexOf(magicStart) === 0 ) {
				match = html.match(magicMatch);

				if (match) {
					callChars();
					match[0].replace(magicMatch, parseMustache);

					//!steal-remove-start
					lineNo += countLines(html.substring(0, match[0].length));
					//!steal-remove-end

					html = html.substring(match[0].length);
				}
			}

			if (chars) {
				index = findBreak(html, magicStart);
				if(index === 0 && html === last) {
					charsText += html.charAt(0);
					html = html.substr(1);
					index = findBreak(html, magicStart);
				}

				var text = index < 0 ? html : html.substring(0, index);
				html = index < 0 ? "" : html.substring(index);

				if (text) {
					charsText += text;
				}
			}

		} else {
			html = html.replace(new RegExp("([\\s\\S]*?)<\/" + stack.last() + "[^>]*>"), function (all, text) {
				text = text.replace(/<!--([\s\S]*?)-->|<!\[CDATA\[([\s\S]*?)]]>/g, "$1$2");
				if (handler.chars) {
					handler.chars(text, lineNo);
				}

				//!steal-remove-start
				lineNo += countLines(text);
				//!steal-remove-end

				return "";
			});

			parseEndTag("", stack.last());
		}

		if (html === last) {
			throw new Error("Parse Error: " + html);
		}

		last = html;
	}
	callChars();
	// Clean up any remaining tags
	parseEndTag();


	handler.done(lineNo);
	return intermediate;
};

var callAttrStart = function(state, curIndex, handler, rest, lineNo){
	var attrName = rest.substring(typeof state.nameStart === "number" ? state.nameStart : curIndex, curIndex),
		newAttrName = canAttributeEncoder_1_0_5_canAttributeEncoder.encode(attrName);

	state.attrStart = newAttrName;
	handler.attrStart(state.attrStart, lineNo);
	state.inName = false;
};

var callAttrEnd = function(state, curIndex, handler, rest, lineNo){
	if(state.valueStart !== undefined && state.valueStart < curIndex) {
		var val = rest.substring(state.valueStart, curIndex);
		//!steal-remove-start
		var quotedVal, closedQuote;
		quotedVal = rest.substring(state.valueStart - 1, curIndex + 1);
		quotedVal = quotedVal.trim();
		closedQuote = quotedVal.charAt(quotedVal.length - 1);
		
		if (state.inQuote !== closedQuote) {
			if (handler.filename) {
				dev.warn(handler.filename + ":" + lineNo + ": End quote is missing for " + val);
			} else {
				dev.warn(lineNo + ": End quote is missing for " + val);
			}
		}
		//!steal-remove-end
		handler.attrValue(val, lineNo);
	}
	// if this never got to be inValue, like `DISABLED` then send a attrValue
	// else if(!state.inValue){
	// 	handler.attrValue(state.attrStart, lineNo);
	// }

	handler.attrEnd(state.attrStart, lineNo);
	state.attrStart = undefined;
	state.valueStart = undefined;
	state.inValue = false;
	state.inName = false;
	state.lookingForEq = false;
	state.inQuote = false;
	state.lookingForName = true;
};

var findBreak = function(str, magicStart) {
	var magicLength = magicStart.length;
	for(var i = 0, len = str.length; i < len; i++) {
		if(str[i] === "<" || str.substr(i, magicLength) === magicStart) {
			return i;
		}
	}
	return -1;
};

HTMLParser.parseAttrs = function(rest, handler, lineNo){
	if(!rest) {
		return;
	}

	var i = 0;
	var curIndex;
	var state = {
		inName: false,
		nameStart: undefined,
		inValue: false,
		valueStart: undefined,
		inQuote: false,
		attrStart: undefined,
		lookingForName: true,
		lookingForValue: false,
		lookingForEq : false
	};

	while(i < rest.length) {
		curIndex = i;
		var cur = rest.charAt(i);
		i++;

		if(magicStart === rest.substr(curIndex, magicStart.length) ) {
			if(state.inValue && curIndex > state.valueStart) {
				handler.attrValue(rest.substring(state.valueStart, curIndex), lineNo);
			}
			// `{{#foo}}DISABLED{{/foo}}`
			else if(state.inName && state.nameStart < curIndex) {
				callAttrStart(state, curIndex, handler, rest, lineNo);
				callAttrEnd(state, curIndex, handler, rest, lineNo);
			}
			// foo={{bar}}
			else if(state.lookingForValue){
				state.inValue = true;
			}
			// a {{bar}}
			else if(state.lookingForEq && state.attrStart) {
				callAttrEnd(state, curIndex, handler, rest, lineNo);
			}

			magicMatch.lastIndex = curIndex;
			var match = magicMatch.exec(rest);
			if(match) {
				handler.special(match[1], lineNo);
				// i is already incremented
				i = curIndex + (match[0].length);
				if(state.inValue) {
					state.valueStart = curIndex+match[0].length;
				}
			}
		}
		else if(state.inValue) {
			if(state.inQuote) {
				if(cur === state.inQuote) {
					callAttrEnd(state, curIndex, handler, rest, lineNo);
				}
			}
			else if(space.test(cur)) {
				callAttrEnd(state, curIndex, handler, rest, lineNo);
			}
		}
		// if we hit an = outside a value
		else if(cur === "=" && (state.lookingForEq || state.lookingForName || state.inName)) {
			// if we haven't yet started this attribute `{{}}=foo` case:
			if(!state.attrStart) {
				callAttrStart(state, curIndex, handler, rest, lineNo);
			}
			state.lookingForValue = true;
			state.lookingForEq = false;
			state.lookingForName = false;
		}
		// if we are currently in a name:
		//  when the name starts with `{` or `(`
		//  it isn't finished until the matching end character is found
		//  otherwise, a space finishes the name
		else if(state.inName) {
			var started = rest[ state.nameStart ],
					otherStart, otherOpposite;
			if(startOppositesMap[started] === cur) {
				//handle mismatched brackets: `{(})` or `({)}`
				otherStart = started === "{" ? "(" : "{";
				otherOpposite = startOppositesMap[otherStart];

				if(rest[curIndex+1] === otherOpposite){
					callAttrStart(state, curIndex+2, handler, rest, lineNo);
					i++;
				}else{
					callAttrStart(state, curIndex+1, handler, rest, lineNo);
				}

				state.lookingForEq = true;
			}
			else if(space.test(cur) && started !== "{" && started !== "(") {
					callAttrStart(state, curIndex, handler, rest, lineNo);
					state.lookingForEq = true;
			}
		}
		else if(state.lookingForName) {
			if(!space.test(cur)) {
				// might have just started a name, we need to close it
				if(state.attrStart) {
					callAttrEnd(state, curIndex, handler, rest, lineNo);
				}
				state.nameStart = curIndex;
				state.inName = true;
			}
		}
		else if(state.lookingForValue) {
			if(!space.test(cur)) {
				state.lookingForValue = false;
				state.inValue = true;
				if(cur === "'" || cur === '"') {
					state.inQuote = cur;
					state.valueStart = curIndex+1;
				} else {
					state.valueStart = curIndex;
				}
				// if we are looking for a value
				// at the end of the loop we need callAttrEnd
			} else if (i === rest.length){
				callAttrEnd(state, curIndex, handler, rest, lineNo);
			}
		}
	}

	if(state.inName) {
		callAttrStart(state, curIndex+1, handler, rest, lineNo);
		callAttrEnd(state, curIndex+1, handler, rest, lineNo);
	} else if(state.lookingForEq || state.lookingForValue || state.inValue) {
		callAttrEnd(state, curIndex+1, handler, rest, lineNo);
	}
	magicMatch.lastIndex = 0;
};

HTMLParser.searchStartTag = function (html) {
	var closingIndex = html.indexOf('>');

	// The first closing bracket we find might be in an attribute value.
	// Move through the attributes by regexp.
	var attributeRange = attributeRegexp.exec(html.substring(1));
	var afterAttributeOffset = 1;
	// if the closing index is after the next attribute...
	while(attributeRange && closingIndex >= afterAttributeOffset + attributeRange.index) {

		// prepare to move to the attribute after this one by increasing the offset
		afterAttributeOffset += attributeRange.index + attributeRange[0].length;
		// if the closing index is before the new offset, then this closing index is inside
		//  an attribute value and should be ignored.  Find the *next* closing character.
		while(closingIndex < afterAttributeOffset) {
			closingIndex += html.substring(closingIndex + 1).indexOf('>') + 1;
		}

		// find the next attribute by starting from the new offset.
		attributeRange = attributeRegexp.exec(html.substring(afterAttributeOffset));
	}

	// if there is no closing bracket
	// <input class=
	// or if the tagName does not start with alphaNumer character
	// <_iaois>
	// it is not a startTag
	if(closingIndex === -1 || !(alphaRegex.test(html[1]))){
		return null;
	}

	var tagName, tagContent, match, rest = '', unary = '';
	var startTag = html.substring(0, closingIndex + 1);
	var isUnary = startTag[startTag.length-2] === '/';
	var spaceIndex = startTag.search(space);

	if(isUnary){
		unary = '/';
		tagContent = startTag.substring(1, startTag.length-2).trim();
	} else {
		tagContent = startTag.substring(1, startTag.length-1).trim();
	}

	if(spaceIndex === -1){
		tagName = tagContent;
	} else {
		//spaceIndex needs to shift one to the left
		spaceIndex--;
		tagName = tagContent.substring(0, spaceIndex);
		rest = tagContent.substring(spaceIndex);
	}

	match = [startTag, tagName, rest, unary];

	return {
		match: match,
		html: html.substring(startTag.length),
	};


};

var canViewParser_4_0_2_canViewParser = canNamespace_1_0_0_canNamespace.HTMLParser = HTMLParser;

var isInDocument$1 = canDomMutate_1_0_4_Util.isInDocument;
var getParents$1 = canDomMutate_1_0_4_Util.getParents;

var synthetic = {
	dispatchNodeInsertion: function (container, node) {
		if (isInDocument$1(node)) {
			canDomMutate_1_0_4_canDomMutate.dispatchNodeInsertion(node);
		}
	},
	dispatchNodeRemoval: function (container, node) {
		if (isInDocument$1(container) && !isInDocument$1(node)) {
			canDomMutate_1_0_4_canDomMutate.dispatchNodeRemoval(node);
		}
	}
};

var compat = {
	replaceChild: function (newChild, oldChild) {
		var newChildren = getParents$1(newChild);
		var result = this.replaceChild(newChild, oldChild);
		synthetic.dispatchNodeRemoval(this, oldChild);
		for (var i = 0; i < newChildren.length; i++) {
			synthetic.dispatchNodeInsertion(this, newChildren[i]);
		}
		return result;
	},
	setAttribute: function (name, value) {
		var oldAttributeValue = this.getAttribute(name);
		var result = this.setAttribute(name, value);
		var newAttributeValue = this.getAttribute(name);
		if (oldAttributeValue !== newAttributeValue) {
			canDomMutate_1_0_4_canDomMutate.dispatchNodeAttributeChange(this, name, oldAttributeValue);
		}
		return result;
	},
	removeAttribute: function (name) {
		var oldAttributeValue = this.getAttribute(name);
		var result = this.removeAttribute(name);
		if (oldAttributeValue) {
			canDomMutate_1_0_4_canDomMutate.dispatchNodeAttributeChange(this, name, oldAttributeValue);
		}
		return result;
	}
};

var compatData = [
	['appendChild', 'Insertion'],
	['insertBefore', 'Insertion'],
	['removeChild', 'Removal']
];
compatData.forEach(function (pair) {
	var nodeMethod = pair[0];
	var dispatchMethod = 'dispatchNode' + pair[1];
	compat[nodeMethod] = function (node) {
		var nodes = getParents$1(node);
		var result = this[nodeMethod].apply(this, arguments);
		for (var i = 0; i < nodes.length; i++) {
			synthetic[dispatchMethod](this, nodes[i]);
		}
		return result;
	};
});

var normal = {};
var nodeMethods = ['appendChild', 'insertBefore', 'removeChild', 'replaceChild', 'setAttribute', 'removeAttribute'];
nodeMethods.forEach(function (methodName) {
	normal[methodName] = function () {
		return this[methodName].apply(this, arguments);
	};
});

/**
* @module {{}} can-dom-mutate/node node
* @parent can-dom-mutate/modules
*
* Append, insert, and remove DOM nodes. Also, change node attributes.
* This allows mutations to be dispatched in environments where MutationObserver is not supported.
* @signature `mutateNode`
*
* Exports an `Object` with methods that shouhld be used to mutate HTML.
* 
* ```js
* var mutateNode = require('can-dom-mutate/node');
* var el = document.createElement('div');
*
* mutateNode.appendChild.call(document.body, el);
*
* ```
*/
var mutate = {};

/**
* @function can-dom-mutate/node.appendChild appendChild
* @parent can-dom-mutate/node
*
* Append a node to an element, effectively `Node.prototype.appendChild`.
*
* @signature `mutate.appendChild.call(parent, child)`
*
* @param {Node} parent The parent into which the child is inserted.
* @param {Node} child The child which will be inserted into the parent.
* @return {Node} The appended child.
*/

/**
* @function can-dom-mutate/node.insertBefore insertBefore
* @parent can-dom-mutate/node
*
* Insert a node before a given reference node in an element, effectively `Node.prototype.insertBefore`.
*
* @signature `mutate.insertBefore.call(parent, child, reference)`
* @param {Node} parent The parent into which the child is inserted.
* @param {Node} child The child which will be inserted into the parent.
* @param {Node} reference The reference which the child will be placed before.
* @return {Node} The inserted child.
*/

/**
* @function can-dom-mutate/node.removeChild removeChild
* @parent can-dom-mutate/node
*
* Remove a node from an element, effectively `Node.prototype.removeChild`.
*
* @signature `mutate.removeChild.call(parent, child)`
*
* @param {Node} parent The parent from which the child is removed.
* @param {Node} child The child which will be removed from the parent.
* @return {Node} The removed child.
*/

/**
* @function can-dom-mutate/node.replaceChild replaceChild
* @parent can-dom-mutate/node
*
* Insert a node before a given reference node in an element, effectively `Node.prototype.replaceChild`.
*
* @signature `mutate.replaceChild.call(parent, newChild, oldChild)`
*
* @param {Node} parent The parent into which the newChild is inserted.
* @param {Node} newChild The child which is inserted into the parent.
* @param {Node} oldChild The child which is removed from the parent.
* @return {Node} The replaced child.
*/

/**
* @function can-dom-mutate/node.setAttribute setAttribute
* @parent can-dom-mutate/node
*
* Set an attribute value on an element, effectively `Element.prototype.setAttribute`.
*
* @signature `mutate.setAttribute.call(element, name, value)`
*
* @param {Element} element The element on which to set the attribute.
* @param {String} name The name of the attribute to set.
* @param {String} value The value to set on the attribute.
*/

/**
* @function can-dom-mutate/node.removeAttribute removeAttribute
* @parent can-dom-mutate/node
*
* Removes an attribute from an element, effectively `Element.prototype.removeAttribute`.
*
* @signature `mutate.removeAttribute.call(element, name, value)`
*
* @param {Element} element The element from which to remove the attribute.
* @param {String} name The name of the attribute to remove.
*/

function setMutateStrategy(observer) {
	var strategy = observer ? normal : compat;
	for (var key in strategy) {
		mutate[key] = strategy[key];
	}
}

var mutationObserverKey = 'MutationObserver';
setMutateStrategy(canGlobals_1_1_1_canGlobals.getKeyValue(mutationObserverKey));
canGlobals_1_1_1_canGlobals.onKeyValue(mutationObserverKey, setMutateStrategy);

var canDomMutate_1_0_4_node = mutate;

// # can/view/node_lists/node_list.js
//

// ### What's a nodeList?
//
// A nodelist is an array of DOM nodes (elements text nodes and DOM elements) and/or other
// nodeLists, along with non-array-indexed properties that manage relationships between lists.
// These properties are:
//
// * deepChildren   children that couldn't be found by iterating over the nodeList when nesting
// * nesting          nested level of a nodelist (parent's nesting plus 1)
// * newDeepChildren  same as deepChildren but stored before registering with update()
// * parentList   the direct parent nodeList of this nodeList
// * replacements   an array of nodeLists meant to replace virtual nodes
// * unregistered   a callback to call when unregistering a nodeList

// ## Helpers
// A mapping of element ids to nodeList id allowing us to quickly find an element
// that needs to be replaced when updated.
var nodeMap = new Map(),
	splice$1 = [].splice,
	push$2 = [].push,

	// ## nodeLists.itemsInChildListTree
	// Given a nodeList return the number of child items in the provided
	// list and any child lists.
	itemsInChildListTree = function(list){
		var count = 0;
		for(var i = 0, len = list.length ; i < len; i++){
			var item = list[i];
			// If the item is an HTMLElement then increment the count by 1.
			if(item.nodeType) {
				count++;
			} else {
				// If the item is not an HTMLElement it is a list, so
				// increment the count by the number of items in the child
				// list.
				count += itemsInChildListTree(item);
			}
		}
		return count;
	},
	// replacements is an array of nodeLists
	// makes a map of the first node in the replacement to the nodeList
	replacementMap = function(replacements){
		var map = new Map();
		for(var i = 0, len = replacements.length; i < len; i++){
			var node = nodeLists.first(replacements[i]);
			map.set(node, replacements[i]);
		}
		return map;
	},
	addUnfoundAsDeepChildren = function(list, rMap){
		rMap.forEach(function(replacement){
			list.newDeepChildren.push(replacement);
		});
	};

// ## Registering & Updating
//
// To keep all live-bound sections knowing which elements they are managing,
// all live-bound elments are registered and updated when they change.
//
// For example, here's a template:
//
//     <div>
//     	{{#if items.length}}
//     		Items:
//     		{{#each items}}
//     			<label>{{.}}</label>
//     		{{/each}}
//     	{{/if}}
//     </div>
//
//
// the above template, when rendered with data like:
//
//     data = new can.Map({
//         items: ["first","second"]
//     })
//
// This will first render the following content:
//
//     <div>
//         <#text "">
//     </div>
//
// The empty text node has a callback which, when called, will register it like:
//
//     var ifsNodes = [<#text "">]
//     nodeLists.register(ifsNodes);
//
// And then render `{{if}}`'s contents and update `ifsNodes` with it:
//
//     nodeLists.update( ifsNodes, [<#text "\nItems:\n">, <#text "">] );
//
// Next, that final text node's callback is called which will regsiter it like:
//
//     var eachsNodes = [<#text "">];
//     nodeLists.register(eachsNodes);
//
// And then it will render `{{#each}}`'s content and update `eachsNodes` with it:
//
//     nodeLists.update(eachsNodes, [<label>,<label>]);
//
// As `nodeLists` knows that `eachsNodes` is inside `ifsNodes`, it also updates
// `ifsNodes`'s nodes to look like:
//
//     [<#text "\nItems:\n">,<label>,<label>]
//
// Now, if all items were removed, `{{#if}}` would be able to remove
// all the `<label>` elements.
//
// When you regsiter a nodeList, you can also provide a callback to know when
// that nodeList has been replaced by a parent nodeList.  This is
// useful for tearing down live-binding.
var nodeLists = {

   /**
	* @function can-view-nodelist.update update
	* @parent can-view-nodelist/methods
	*
	* @signature `nodeLists.update(nodeList, newNodes)`
	*
	* Updates a nodeList with new items, i.e. when values for the template have changed.
	*
	*   @param {can-view-nodelist/types/NodeList} nodeList The list to update with the new nodes.
	*   @param {can-view-nodelist/types/NodeList} newNodes The new nodes to update with.
	*
	*   @return {Array<Node>} The nodes that were removed from `nodeList`.
	*/
	update: function (nodeList, newNodes, oldNodes) {
		// Unregister all childNodeLists.
		if(!oldNodes) {
			// if oldNodes has been passed, we assume everything has already been unregistered.
			oldNodes = nodeLists.unregisterChildren(nodeList);
		}

		var arr = [];
		for (var i = 0, ref = arr.length = newNodes.length; i < ref; i++) {
 			arr[i] = newNodes[i];
		} // see https://jsperf.com/nodelist-to-array
		newNodes = arr;

		var oldListLength = nodeList.length;

		// Replace oldNodeLists's contents.
		splice$1.apply(nodeList, [
			0,
			oldListLength
		].concat(newNodes));

		// Replacements are nodes that have replaced the original element this is on.
		// We can't simply insert elements because stache does children before parents.
		if(nodeList.replacements){
			nodeLists.nestReplacements(nodeList);
			nodeList.deepChildren = nodeList.newDeepChildren;
			nodeList.newDeepChildren = [];
		} else {
			nodeLists.nestList(nodeList);
		}

		return oldNodes;
	},
   /**
	* @function can-view-nodelist.nestReplacements nestReplacements
	* @parent can-view-nodelist/methods
	* @signature `nodeLists.nestReplacements(list)`
	*
	* Goes through each node in the list. `[el1, el2, el3, ...]`
	* Finds the nodeList for that node in replacements.  el1's nodeList might look like `[el1, [el2]]`.
	* Replaces that element and any other elements in the node list with the
	* nodelist itself. resulting in `[ [el1, [el2]], el3, ...]`
	* If a replacement is not found, it was improperly added, so we add it as a deepChild.
	*
	* @param {can-view-nodelist/types/NodeList} list  The nodeList of nodes to go over
	*
	*/
	nestReplacements: function(list){
		var index = 0,
			// replacements are in reverse order in the DOM
			rMap = replacementMap(list.replacements),
			rCount = list.replacements.length;

		while(index < list.length && rCount) {
			var node = list[index],
				replacement = rMap.get(node);
			if( replacement ) {
				rMap["delete"](node);
				list.splice( index, itemsInChildListTree(replacement), replacement );
				rCount--;
			}
			index++;
		}
		// Only do this if
		if(rCount) {
			addUnfoundAsDeepChildren(list, rMap );
		}

		list.replacements = [];
	},
	/**
	 * @function can-view-nodelist.nestList nestList
	 * @parent can-view-nodelist/methods
	 * @signature `nodeLists.nestList(list)`
	 *
	 * If a given list does not exist in the nodeMap then create an lookup
	 * id for it in the nodeMap and assign the list to it.
	 * If the the provided does happen to exist in the nodeMap update the
	 * elements in the list.
	 *
	 * @param {can-view-nodelist/types/NodeList} list The nodeList being nested.
	 *
	 */
	nestList: function(list){
		var index = 0;
		while(index < list.length) {
			var node = list[index],
				childNodeList = nodeMap.get(node);


			if(childNodeList) {
				// if this node is in another nodelist
				if(childNodeList !== list) {
					// update this nodeList to point to the childNodeList
					list.splice( index, itemsInChildListTree(childNodeList), childNodeList );
				}
			} else {
				// Indicate the new nodes belong to this list.
				nodeMap.set(node, list);
			}
			index++;
		}
	},

	/**
	 * @function can-view-nodelist.last last
	 * @parent can-view-nodelist/methods
	 * @signature `nodeLists.last(nodeList)`
	 *
	 * Return the last HTMLElement in a nodeList; if the last
	 * element is a nodeList, returns the last HTMLElement of
	 * the child list, etc.
	 *
	 * @param {can-view-nodelist/types/NodeList} nodeList A nodeList.
	 * @return {HTMLElement} The last element of the last list nested in this list.
	 *
	 */
	last: function(nodeList){
		var last = nodeList[nodeList.length - 1];
		// If the last node in the list is not an HTMLElement
		// it is a nodeList so call `last` again.
		if(last.nodeType) {
			return last;
		} else {
			return nodeLists.last(last);
		}
	},

	/**
	 * @function can-view-nodelist.first first
	 * @parent can-view-nodelist/methods
	 * @signature `nodeLists.first(nodeList)`
	 *
	 * Return the first HTMLElement in a nodeList; if the first
	 * element is a nodeList, returns the first HTMLElement of
	 * the child list, etc.
	 *
	 * @param {can-view-nodelist/types/NodeList} nodeList A nodeList.
	 * @return {HTMLElement} The first element of the first list nested in this list.
	 *
	 *
	 */
	first: function(nodeList) {
		var first = nodeList[0];
		// If the first node in the list is not an HTMLElement
		// it is a nodeList so call `first` again.
		if(first.nodeType) {
			return first;
		} else {
			return nodeLists.first(first);
		}
	},
	flatten: function(nodeList){
		var items = [];
		for(var i = 0 ; i < nodeList.length; i++) {
			var item = nodeList[i];
			if(item.nodeType) {
				items.push(item);
			} else {
				items.push.apply(items, nodeLists.flatten(item));
			}
		}
		return items;
	},
	/**
	 * @function can-view-nodelist.register register
	 * @parent can-view-nodelist/methods
	 *
	 * @signature `nodeLists.register(nodeList, unregistered, parent, directlyNested)`
	 *
	 * Registers a nodeList and returns the nodeList passed to register.
	 *
	 *   @param {can-view-nodelist/types/NodeList} nodeList A nodeList.
	 *   @param {function()} unregistered A callback to call when the nodeList is unregistered.
	 *   @param {can-view-nodelist/types/NodeList} parent The parent nodeList of this nodeList.
	 *   @param {Boolean} directlyNested `true` if nodes in the nodeList are direct children of the parent.
	 *   @return {can-view-nodelist/types/NodeList} The passed in nodeList.
	 *
	 */
	register: function (nodeList, unregistered, parent, directlyNested) {
		// If a unregistered callback has been provided assign it to the nodeList
		// as a property to be called when the nodeList is unregistred.
		nodeList.unregistered = unregistered;
		nodeList.parentList = parent;
		nodeList.nesting = parent && typeof parent.nesting !== 'undefined' ? parent.nesting + 1 : 0;

		if(parent) {
			nodeList.deepChildren = [];
			nodeList.newDeepChildren = [];
			nodeList.replacements = [];
			if(parent !== true) {
				if(directlyNested) {
					parent.replacements.push(nodeList);
				}
				else {
					parent.newDeepChildren.push(nodeList);
				}
			}
		}
		else {
			nodeLists.nestList(nodeList);
		}


		return nodeList;
	},

	/**
	 * @function can-view-nodelist.unregisterChildren unregisterChildren
	 * @parent can-view-nodelist/methods
	 * @signature `nodeLists.unregisterChildren(nodeList)`
	 *
	 * Unregister all childen within the provided list and return the
	 * unregistred nodes.
	 *
	 * @param {can-view-nodelist/types/NodeList} nodeList The nodeList of child nodes to unregister.
	 * @return {Array} The list of all nodes that were unregistered.
	 */
	unregisterChildren: function(nodeList){
		var nodes = [];
		// For each node in the nodeList we want to compute it's id
		// and delete it from the nodeList's internal map.
		for (var n = 0; n < nodeList.length; n++) {
			var node = nodeList[n];
			// If the node does not have a nodeType it is an array of
			// nodes.
			if(node.nodeType) {
				if(!nodeList.replacements) {
					nodeMap["delete"](node);
				}

				nodes.push(node);
			} else {
				// Recursively unregister each of the child lists in
				// the nodeList.
				push$2.apply(nodes, nodeLists.unregister(node, true));
			}
		}

		var deepChildren = nodeList.deepChildren;
		if (deepChildren) {
			for (var l = 0; l < deepChildren.length; l++) {
				nodeLists.unregister(deepChildren[l], true);
			}
		}

		return nodes;
	},

	/**
		@function can-view-nodelist.unregister unregister
		@parent can-view-nodelist/methods
		@signature `nodeLists.unregister(nodeList, isChild)`
		@param {ArrayLike} nodeList a nodeList to unregister from its parent
		@param {isChild}  true if the nodeList is a direct child, false if a deep child
		@return {Array}   a list of all nodes that were unregistered

		Unregister's a nodeList and returns the unregistered nodes.
		Call if the nodeList is no longer being updated. This will
		also unregister all child nodeLists.
	*/
	unregister: function (nodeList, isChild) {
		var nodes = nodeLists.unregisterChildren(nodeList, true);
		nodeList.isUnregistered = true;

		// If an 'unregisted' function was provided during registration, remove
		// it from the list, and call the function provided.
		if (nodeList.unregistered) {
			var unregisteredCallback = nodeList.unregistered;
			nodeList.replacements = nodeList.unregistered = null;
			if(!isChild) {
				var deepChildren = nodeList.parentList && nodeList.parentList.deepChildren;
				if(deepChildren) {
					var index = deepChildren.indexOf(nodeList);
					if(index !== -1) {
						deepChildren.splice(index,1);
					}
				}
			}
			unregisteredCallback();
		}
		return nodes;
	},
	/**
	 * @function can-view-nodelist.after after
	 * @parent can-view-nodelist/methods
	 * @hide
	 * @signature `nodeLists.after(oldElements, newFrag)`
	 *
	 *   Inserts `newFrag` after `oldElements`.
	 *
	 *   @param {ArrayLike<Node>} oldElements The elements to use as reference.
	 *   @param {DocumentFragment} newFrag The fragment to insert.
	 *
	 */
	after: function (oldElements, newFrag) {
		var last = oldElements[oldElements.length - 1];
		// Insert it in the `document` or `documentFragment`
		if (last.nextSibling) {
			canDomMutate_1_0_4_node.insertBefore.call(last.parentNode, newFrag, last.nextSibling);
		} else {
			canDomMutate_1_0_4_node.appendChild.call(last.parentNode, newFrag );
		}
	},
	/**
	 * @function can-view-nodelist.replace replace
	 * @hide
	 * @parent can-view-nodelist/methods
	 * @signature `nodeLists.replace(oldElements, newFrag)`
	 *
	 * Replaces `oldElements` with `newFrag`.
	 *
	 * @param {Array<Node>} oldElements the list elements to remove
	 * @param {DocumentFragment} newFrag the fragment to replace the old elements
	 *
	 */
	replace: function (oldElements, newFrag) {
		// The following helps make sure that a selected <option> remains
		// the same by removing `selected` from the currently selected option
		// and adding selected to an option that has the same value.
		var selectedValue,
			parentNode = oldElements[0].parentNode;

		if(parentNode.nodeName.toUpperCase() === "SELECT" && parentNode.selectedIndex >= 0) {
			selectedValue = parentNode.value;
		}
		if(oldElements.length === 1) {
			canDomMutate_1_0_4_node.replaceChild.call(parentNode, newFrag, oldElements[0]);
		} else {
			nodeLists.after(oldElements, newFrag);
			nodeLists.remove(oldElements);
		}

		if(selectedValue !== undefined) {
			parentNode.value = selectedValue;
		}
	},
	/**
	 * @function can-view-nodelist.remove remove
	 * @parent can-view-nodelist/methods
	 * @hide
	 * @signature `nodeLists.remove(elementsToBeRemoved)`
	 *
	 * Remove all Nodes in `oldElements` from the DOM.
	 *
	 * @param {ArrayLike<Node>} oldElements the list of Elements to remove (must have a common parent)
	 *
	 */
	remove: function(elementsToBeRemoved){
		var parent = elementsToBeRemoved[0] && elementsToBeRemoved[0].parentNode;
		for (var i = 0; i < elementsToBeRemoved.length; i++) {
			canDomMutate_1_0_4_node.removeChild.call(parent, elementsToBeRemoved[i]);
		}
	},
	nodeMap: nodeMap
};
var canViewNodelist_4_2_0_canViewNodelist = canNamespace_1_0_0_canNamespace.nodeLists = nodeLists;

/**
 * @module {function} can-child-nodes
 * @parent can-dom-utilities
 * @collection can-infrastructure
 * 
 * @signature `childNodes(node)`
 *
 * Get all of the childNodes of a given node.
 *
 * ```js
 * var stache = require("can-stache");
 * var childNodes = require("can-util/child-nodes/child-nodes");
 *
 * var html = "<div><h1><span></span></h1></div>";
 * var frag = stache(html)();
 *
 * console.log(childNodes(frag)[0].nodeName); // -> DIV
 * ```
 *
 * @param {Object} node The Node that you want child nodes for.
 */

function childNodes(node) {
	var childNodes = node.childNodes;
	if ("length" in childNodes) {
		return childNodes;
	} else {
		var cur = node.firstChild;
		var nodes = [];
		while (cur) {
			nodes.push(cur);
			cur = cur.nextSibling;
		}
		return nodes;
	}
}

var canChildNodes_1_0_0_canChildNodes = canNamespace_1_0_0_canNamespace.childNodes = childNodes;

/**
@module {function} can-fragment
@parent can-dom-utilities
@collection can-infrastructure

Convert a String, HTMLElement, documentFragment, or contentArray into a documentFragment.

@signature `fragment(item, doc)`

@param {String|HTMLElement|documentFragment|contentArray} item
@param {Document} doc   an optional DOM document in which to build the fragment

@return {documentFragment}

@body

## Use

ContentArrays can be used to combine multiple HTMLElements into a single document fragment.  For example:

    var fragment = require("can-fragment");

    var p = document.createElement("p");
    p.innerHTML = "Welcome to <b>CanJS</b>";
    var contentArray = ["<h1>Hi There</h1>", p];
    var fragment = fragment( contentArray )

`fragment` will be a documentFragment with the following elements:

    <h1>Hi There</h1>
    <p>Welcome to <b>CanJS</b></p>

 */


// fragment.js
// ---------
// _DOM Fragment support._
var fragmentRE = /^\s*<(\w+)[^>]*>/,
	toString$1 = {}.toString;

function makeFragment(html, name, doc) {
	if (name === undefined) {
		name = fragmentRE.test(html) && RegExp.$1;
	}
	if (html && toString$1.call(html.replace) === "[object Function]") {
		// Fix "XHTML"-style tags in all browsers
		html = html.replace(/<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi, '<$1></$2>');
	}
	var container = doc.createElement('div'),
		temp = doc.createElement('div');
	// IE's parser will strip any `<tr><td>` tags when `innerHTML`
	// is called on a `tbody`. To get around this, we construct a
	// valid table with a `tbody` that has the `innerHTML` we want.
	// Then the container is the `firstChild` of the `tbody`.
	// [source](http://www.ericvasilik.com/2006/07/code-karma.html).
	if (name === 'tbody' || name === 'tfoot' || name === 'thead' || name === 'colgroup') {
		temp.innerHTML = '<table>' + html + '</table>';
		container = temp.firstChild.nodeType === 3 ? temp.lastChild : temp.firstChild;
	} else if (name === 'col') {
		temp.innerHTML = '<table><colgroup>' + html + '</colgroup></table>';
		container = temp.firstChild.nodeType === 3 ? temp.lastChild : temp.firstChild.firstChild;
	} else if (name === 'tr') {
		temp.innerHTML = '<table><tbody>' + html + '</tbody></table>';
		container = temp.firstChild.nodeType === 3 ? temp.lastChild : temp.firstChild.firstChild;
	} else if (name === 'td' || name === 'th') {
		temp.innerHTML = '<table><tbody><tr>' + html + '</tr></tbody></table>';
		container = temp.firstChild.nodeType === 3 ? temp.lastChild : temp.firstChild.firstChild.firstChild;
	} else if (name === 'option') {
		temp.innerHTML = '<select>' + html + '</select>';
		container = temp.firstChild.nodeType === 3 ? temp.lastChild : temp.firstChild;
	} else {
		container.innerHTML = '' + html;
	}

	return [].slice.call(canChildNodes_1_0_0_canChildNodes(container));
}

function fragment(html, doc) {
	if (html && html.nodeType === 11) {
		return html;
	}
	if (!doc) {
		doc = document$1();
	} else if (doc.length) {
		doc = doc[0];
	}

	var parts = makeFragment(html, undefined, doc),
		frag = (doc || document).createDocumentFragment();
	for (var i = 0, length = parts.length; i < length; i++) {
		frag.appendChild(parts[i]);
	}
	return frag;
}

var makeFrag = function(item, doc) {
	var document = doc || document$1();
	var frag;
	if (!item || typeof item === "string") {
		frag = fragment(item == null ? "" : "" + item, document);
		// If we have an empty frag...
	} else if (item.nodeType === 11) {
		return item;
	} else if (typeof item.nodeType === "number") {
		frag = document.createDocumentFragment();
		frag.appendChild(item);
		return frag;
	} else if (canReflect_1_16_7_canReflect.isListLike(item)) {
		frag = document.createDocumentFragment();
		canReflect_1_16_7_canReflect.eachIndex(item, function(item) {
			frag.appendChild(makeFrag(item));
		});
	} else {
		frag = fragment("" + item, document);
	}
    if (!canChildNodes_1_0_0_canChildNodes(frag).length) {
        frag.appendChild(document.createTextNode(''));
    }
    return frag;
};

var canFragment_1_0_1_canFragment = canNamespace_1_0_0_canNamespace.fragment = canNamespace_1_0_0_canNamespace.frag = makeFrag;

var canViewCallbacks_4_1_2_canViewCallbacks = createCommonjsModule(function (module) {
//!steal-remove-start
var requestedAttributes = {};
//!steal-remove-end

var tags = {};

// WeakSet containing elements that have been rendered already
// and therefore do not need to be rendered again

var automountEnabled = function(){
	return canGlobals_1_1_1_canGlobals.getKeyValue("document").documentElement.getAttribute("data-can-automount") !== "false";
};

var renderedElements = new WeakSet();

var renderNodeAndChildren = function(node) {
	var tagName = node.tagName && node.tagName.toLowerCase();
	var tagHandler = tags[tagName];
	var children;

	// skip elements that already have a viewmodel or elements whose tags don't match a registered tag
	// or elements that have already been rendered
	if (tagHandler && !renderedElements.has(node)) {
		tagHandler(node, {});
	}

	if (node.getElementsByTagName) {
		children = node.getElementsByTagName("*");
		for (var k=0, child; (child = children[k]) !== undefined; k++) {
			renderNodeAndChildren(child);
		}
	}
};

var mutationObserverEnabled = false;
var globalMutationObserver;
var enableMutationObserver = function() {
	if (mutationObserverEnabled) {
		return;
	}

	var mutationHandler = function(mutationsList) {
		var addedNodes;

		for (var i=0, mutation; (mutation = mutationsList[i]) !== undefined; i++) {
			if (mutation.type === "childList") {
				addedNodes = mutation.addedNodes;

				for (var j=0, addedNode; (addedNode = addedNodes[j]) !== undefined; j++) {
					// skip elements that have already been rendered
					if (!renderedElements.has(addedNode)) {
						renderNodeAndChildren(addedNode);
					}
				}
			}
		}
	};

	var MutationObserver = canGlobals_1_1_1_canGlobals.getKeyValue("MutationObserver");
	if(MutationObserver) {
		globalMutationObserver = new MutationObserver(mutationHandler);
		globalMutationObserver.observe(global_1().document.documentElement, {
			childList: true,
			subtree: true
		});

		mutationObserverEnabled = true;
	}
};

var renderTagsInDocument = function(tagName) {
	var nodes = global_1().document.getElementsByTagName(tagName);

	for (var i=0, node; (node = nodes[i]) !== undefined; i++) {
		renderNodeAndChildren(node);
	}
};

var attr = function (attributeName, attrHandler) {
	if(attrHandler) {
		if (typeof attributeName === "string") {
			attributes[attributeName] = attrHandler;
			//!steal-remove-start
			if(requestedAttributes[attributeName]) {
				dev.warn("can-view-callbacks: " + attributeName+ " custom attribute behavior requested before it was defined.  Make sure "+attributeName+" is defined before it is needed.");
			}
			//!steal-remove-end
		} else {
			regExpAttributes.push({
				match: attributeName,
				handler: attrHandler
			});

			//!steal-remove-start
			Object.keys(requestedAttributes).forEach(function(requested){
				if(attributeName.test(requested)) {
					dev.warn("can-view-callbacks: " + requested+ " custom attribute behavior requested before it was defined.  Make sure "+requested+" is defined before it is needed.");
				}
			});
			//!steal-remove-end
		}
	} else {
		var cb = attributes[attributeName];
		if( !cb ) {

			for( var i = 0, len = regExpAttributes.length; i < len; i++) {
				var attrMatcher = regExpAttributes[i];
				if(attrMatcher.match.test(attributeName)) {
					return attrMatcher.handler;
				}
			}
		}
		//!steal-remove-start
		requestedAttributes[attributeName] = true;
		//!steal-remove-end

		return cb;
	}
};

var attributes = {},
	regExpAttributes = [],
	automaticCustomElementCharacters = /[-\:]/;
var defaultCallback = function () {};

var tag = function (tagName, tagHandler) {
	if(tagHandler) {
		var GLOBAL = global_1();

		var validCustomElementName = automaticCustomElementCharacters.test(tagName),
			tagExists = typeof tags[tagName.toLowerCase()] !== 'undefined',
			customElementExists;

		//!steal-remove-start
		if (tagExists) {
			dev.warn("Custom tag: " + tagName.toLowerCase() + " is already defined");
		}

		if (!validCustomElementName && tagName !== "content") {
			dev.warn("Custom tag: " + tagName.toLowerCase() + " hyphen missed");
		}
		//!steal-remove-end

		// if we have html5shiv ... re-generate
		if (GLOBAL.html5) {
			GLOBAL.html5.elements += " " + tagName;
			GLOBAL.html5.shivDocument();
		}

		tags[tagName.toLowerCase()] = tagHandler;

		if(automountEnabled()) {
			var customElements = canGlobals_1_1_1_canGlobals.getKeyValue("customElements");

			// automatically render elements that have tagHandlers
			// If browser supports customElements, register the tag as a custom element
			if (customElements) {
				customElementExists = customElements.get(tagName.toLowerCase());

				if (validCustomElementName && !customElementExists) {
					var CustomElement = function() {
						return Reflect.construct(HTMLElement, [], CustomElement);
					};

					CustomElement.prototype = Object.create(HTMLElement.prototype);

					CustomElement.prototype.connectedCallback = function() {
						// don't re-render an element that has been rendered already
						if (!renderedElements.has(this)) {
							tags[tagName.toLowerCase()](this, {});
						}
					};

					customElements.define(tagName, CustomElement);
				}
			}
			// If browser doesn't support customElements, set up MutationObserver for
			// rendering elements when they are inserted in the page
			// and rendering elements that are already in the page
			else {
				enableMutationObserver();
				renderTagsInDocument(tagName);
			}
		} else if(mutationObserverEnabled) {
			globalMutationObserver.disconnect();
		}
	} else {
		var cb;

		// if null is passed as tagHandler, remove tag
		if (tagHandler === null) {
			delete tags[tagName.toLowerCase()];
		} else {
			cb = tags[tagName.toLowerCase()];
		}

		if(!cb && automaticCustomElementCharacters.test(tagName)) {
			// empty callback for things that look like special tags
			cb = defaultCallback;
		}
		return cb;
	}

};

var callbacks = {
	_tags: tags,
	_attributes: attributes,
	_regExpAttributes: regExpAttributes,
	defaultCallback: defaultCallback,
	tag: tag,
	attr: attr,
	// handles calling back a tag callback
	tagHandler: function(el, tagName, tagData){
		var scope = tagData.scope,
			helperTagCallback = scope && scope.templateContext.tags.get(tagName),
			tagCallback = helperTagCallback || tags[tagName],
			res;

		// If this was an element like <foo-bar> that doesn't have a component, just render its content
		if(tagCallback) {
			res = canObservationRecorder_1_1_2_canObservationRecorder.ignore(tagCallback)(el, tagData);

			// add the element to the Set of elements that have had their handlers called
			// this will prevent the handler from being called again when the element is inserted
			renderedElements.add(el);
		} else {
			res = scope;
		}

		//!steal-remove-start
		if (!tagCallback) {
			var GLOBAL = global_1();
			var ceConstructor = GLOBAL.document.createElement(tagName).constructor;
			// If not registered as a custom element, the browser will use default constructors
			if (ceConstructor === GLOBAL.HTMLElement || ceConstructor === GLOBAL.HTMLUnknownElement) {
				dev.warn('can-view-callbacks: No custom element found for ' + tagName);
			}
		}
		//!steal-remove-end

		// If the tagCallback gave us something to render with, and there is content within that element
		// render it!
		if (res && tagData.subtemplate) {
			if (scope !== res) {
				scope = scope.add(res);
			}

			var nodeList = canViewNodelist_4_2_0_canViewNodelist.register([], undefined, tagData.parentNodeList || true, false);
			nodeList.expression = "<" + el.tagName + ">";

			var result = tagData.subtemplate(scope, tagData.options, nodeList);
			var frag = typeof result === "string" ? canFragment_1_0_1_canFragment(result) : result;
			canDomMutate_1_0_4_node.appendChild.call(el, frag);
		}
	}
};

canNamespace_1_0_0_canNamespace.view = canNamespace_1_0_0_canNamespace.view || {};

if (canNamespace_1_0_0_canNamespace.view.callbacks) {
	throw new Error("You can't have two versions of can-view-callbacks, check your dependencies");
} else {
	module.exports = canNamespace_1_0_0_canNamespace.view.callbacks = callbacks;
}
});

/* jshint maxdepth:7 */
/* jshint latedef:false */





// if an object or a function
// convert into what it should look like
// then the modification can happen in place
// but it has to have more than the current node
// blah!
var processNodes = function(nodes, paths, location, document){
	var frag = document.createDocumentFragment();

	for(var i = 0, len = nodes.length; i < len; i++) {
		var node = nodes[i];
		frag.appendChild( processNode(node,paths,location.concat(i), document) );
	}
	return frag;
},
	keepsTextNodes =  typeof document !== "undefined" && (function(){
		var testFrag = document.createDocumentFragment();
		var div = document.createElement("div");

		div.appendChild(document.createTextNode(""));
		div.appendChild(document.createTextNode(""));
		testFrag.appendChild(div);

		var cloned  = testFrag.cloneNode(true);

		return cloned.firstChild.childNodes.length === 2;
	})(),
	clonesWork = typeof document !== "undefined" && (function(){
		// Since html5shiv is required to support custom elements, assume cloning
		// works in any browser that doesn't have html5shiv

		// Clone an element containing a custom tag to see if the innerHTML is what we
		// expect it to be, or if not it probably was created outside of the document's
		// namespace.
		var el = document.createElement('a');
		el.innerHTML = "<xyz></xyz>";
		var clone = el.cloneNode(true);
		var works = clone.innerHTML === "<xyz></xyz>";
		var MO, observer;

		if(works) {
			// Cloning text nodes with dashes seems to create multiple nodes in IE11 when
			// MutationObservers of subtree modifications are used on the documentElement.
			// Since this is not what we expect we have to include detecting it here as well.
			el = document.createDocumentFragment();
			el.appendChild(document.createTextNode('foo-bar'));

			MO = mutationObserver();

			if (MO) {
				observer = new MO(function() {});
				observer.observe(document.documentElement, { childList: true, subtree: true });

				clone = el.cloneNode(true);

				observer.disconnect();
			} else {
				clone = el.cloneNode(true);
			}

			return clone.childNodes.length === 1;
		}

		return works;
	})(),
	namespacesWork = typeof document !== "undefined" && !!document.createElementNS;

/**
 * @function cloneNode
 * @hide
 *
 * A custom cloneNode function to be used in browsers that properly support cloning
 * of custom tags (IE8 for example). Fixes it by doing some manual cloning that
 * uses innerHTML instead, which has been shimmed.
 *
 * @param {DocumentFragment} frag A document fragment to clone
 * @return {DocumentFragment} a new fragment that is a clone of the provided argument
 */
var cloneNode = clonesWork ?
	function(el){
		return el.cloneNode(true);
	} :
	function(node){
		var document = node.ownerDocument;
		var copy;

		if(node.nodeType === 1) {
			if(node.namespaceURI !== 'http://www.w3.org/1999/xhtml' && namespacesWork && document.createElementNS) {
				copy = document.createElementNS(node.namespaceURI, node.nodeName);
			}
			else {
				copy = document.createElement(node.nodeName);
			}
		} else if(node.nodeType === 3){
			copy = document.createTextNode(node.nodeValue);
		} else if(node.nodeType === 8) {
			copy = document.createComment(node.nodeValue);
		} else if(node.nodeType === 11) {
			copy = document.createDocumentFragment();
		}

		if(node.attributes) {
			var attributes = node.attributes;
			for (var i = 0; i < attributes.length; i++) {
				var attribute = attributes[i];
				if (attribute && attribute.specified) {
					canDomMutate_1_0_4_node.setAttribute.call(copy, attribute.nodeName || attribute.name, attribute.nodeValue || attribute.value);
				}
			}
		}

		if(node && node.firstChild) {
			var child = node.firstChild;

			while(child) {
				copy.appendChild( cloneNode(child) );
				child = child.nextSibling;
			}
		}

		return copy;
	};

function processNode(node, paths, location, document){
	var callback,
		loc = location,
		nodeType = typeof node,
		el,
		p,
		i , len;
	var getCallback = function(){
		if(!callback) {
			callback  = {
				path: location,
				callbacks: []
			};
			paths.push(callback);
			loc = [];
		}
		return callback;
	};

	if(nodeType === "object") {
		if( node.tag ) {
			if(namespacesWork && node.namespace) {
				el = document.createElementNS(node.namespace, node.tag);
			} else {
				el = document.createElement(node.tag);
			}

			if(node.attrs) {
				for(var attrName in node.attrs) {
					var value = node.attrs[attrName];
					if(typeof value === "function"){
						getCallback().callbacks.push({
							callback:  value
						});
					} else  {
						canDomMutate_1_0_4_node.setAttribute.call(el, attrName, value);
					}
				}
			}
			if(node.attributes) {
				for(i = 0, len = node.attributes.length; i < len; i++ ) {
					getCallback().callbacks.push({callback: node.attributes[i]});
				}
			}
			if(node.children && node.children.length) {
				// add paths
				if(callback) {
					p = callback.paths = [];
				} else {
					p = paths;
				}

				el.appendChild( processNodes(node.children, p, loc, document) );
			}
		} else if(node.comment) {
			el = document.createComment(node.comment);

			if(node.callbacks) {
				for(i = 0, len = node.attributes.length; i < len; i++ ) {
					getCallback().callbacks.push({callback: node.callbacks[i]});
				}
			}
		}


	} else if(nodeType === "string"){

		el = document.createTextNode(node);

	} else if(nodeType === "function") {

		if(keepsTextNodes) {
			el = document.createTextNode("");
			getCallback().callbacks.push({
				callback: node
			});
		} else {
			el = document.createComment("~");
			getCallback().callbacks.push({
				callback: function(){
					var el = document.createTextNode("");
					canDomMutate_1_0_4_node.replaceChild.call(this.parentNode, el, this);
					return node.apply(el,arguments );
				}
			});
		}

	}
	return el;
}

function getCallbacks(el, pathData, elementCallbacks){
	var path = pathData.path,
		callbacks = pathData.callbacks,
		paths = pathData.paths,
		child = el,
		pathLength = path ? path.length : 0,
		pathsLength = paths ? paths.length : 0;

	for(var i = 0; i < pathLength; i++) {
		child = child.childNodes.item(path[i]);
	}

	for( i= 0 ; i < pathsLength; i++) {
		getCallbacks(child, paths[i], elementCallbacks);
	}

	elementCallbacks.push({element: child, callbacks: callbacks});
}

function hydrateCallbacks(callbacks, args) {
	var len = callbacks.length,
		callbacksLength,
		callbackElement,
		callbackData;

	for(var i = 0; i < len; i++) {
		callbackData = callbacks[i];
		callbacksLength = callbackData.callbacks.length;
		callbackElement = callbackData.element;
		for(var c = 0; c < callbacksLength; c++) {
			callbackData.callbacks[c].callback.apply(callbackElement, args);
		}
	}
}

function makeTarget(nodes, doc){
	var paths = [];
	var frag = processNodes(nodes, paths, [], doc || document$1());
	return {
		paths: paths,
		clone: frag,
		hydrate: function(){
			var cloned = cloneNode(this.clone);
			var args = [];
			for (var a = 0, ref = args.length = arguments.length; a < ref; a++) {
				args[a] = arguments[a];
			} // see https://jsperf.com/nodelist-to-array

			var callbacks = [];
			for(var i = 0; i < paths.length; i++) {
				getCallbacks(cloned, paths[i], callbacks);
			}
			hydrateCallbacks(callbacks, args);

			return cloned;
		}
	};
}
makeTarget.keepsTextNodes = keepsTextNodes;
makeTarget.cloneNode = cloneNode;

canNamespace_1_0_0_canNamespace.view = canNamespace_1_0_0_canNamespace.view || {};
var canViewTarget_4_0_1_canViewTarget = canNamespace_1_0_0_canNamespace.view.target = makeTarget;

// Ensure the "obj" passed as an argument has an object on @@can.meta
var ensureMeta$2 = function ensureMeta(obj) {
	var metaSymbol = canSymbol_1_6_1_canSymbol.for("can.meta");
	var meta = obj[metaSymbol];

	if (!meta) {
		meta = {};
		canReflect_1_16_7_canReflect.setKeyValue(obj, metaSymbol, meta);
	}

	return meta;
};

// this is a very simple can-map like object
var SimpleMap = canConstruct_3_4_4_canConstruct.extend("SimpleMap",
	{
		// ### setup
		// A setup function for the instantiation of a simple-map.
		setup: function(initialData){
			this._data = {};
			if(initialData && typeof initialData === "object") {
				this.attr(initialData);
			}
		},
		// ### attr
		// The main get/set interface simple-map.
		// Either sets or gets one or more properties depending on how it is called.
		attr: function(prop, value) {
			var self = this;

			if(arguments.length === 0 ) {
				canObservationRecorder_1_1_2_canObservationRecorder.add(this,"can.keys");
				var data = {};
				canReflect_1_16_7_canReflect.eachKey(this._data, function(value, prop){
					canObservationRecorder_1_1_2_canObservationRecorder.add(this, prop);
					data[prop] = value;
				}, this);
				return data;
			}
			else if(arguments.length > 1) {
				var had = this._data.hasOwnProperty(prop);
				var old = this._data[prop];
				this._data[prop] = value;
				if(old !== value) {


					//!steal-remove-start
					if (typeof this._log === "function") {
						this._log(prop, value, old);
					}
					//!steal-remove-end

					this.dispatch({
						keyChanged: !had ? prop : undefined,
						type: prop,
						//!steal-remove-start
						reasonLog: [ canReflect_1_16_7_canReflect.getName(this) + "'s", prop, "changed to", value, "from", old ],
						//!steal-remove-end
					}, [value, old]);
				}

			}
			// 1 argument
			else if(typeof prop === 'object') {
				canQueues_1_1_0_canQueues.batch.start();
				canReflect_1_16_7_canReflect.eachKey(prop, function(value, key) {
					self.attr(key, value);
				});
				canQueues_1_1_0_canQueues.batch.stop();
			}
			else {
				if(prop !== "constructor") {
					canObservationRecorder_1_1_2_canObservationRecorder.add(this, prop);
					return this._data[prop];
				}

				return this.constructor;
			}
		},
		serialize: function(){
			return canReflect_1_16_7_canReflect.serialize(this, Map);
		},
		get: function(){
			return this.attr.apply(this, arguments);
		},
		set: function(){
			return this.attr.apply(this, arguments);
		},
		// call `.log()` to log all property changes
		// pass a single property to only get logs for said property, e.g: `.log("foo")`
		log: function(key) {
			//!steal-remove-start
			var quoteString = function quoteString(x) {
				return typeof x === "string" ? JSON.stringify(x) : x;
			};

			var meta = ensureMeta$2(this);
			meta.allowedLogKeysSet = meta.allowedLogKeysSet || new Set();

			if (key) {
				meta.allowedLogKeysSet.add(key);
			}

			this._log = function(prop, current, previous, log) {
				if (key && !meta.allowedLogKeysSet.has(prop)) {
					return;
				}
				dev.log(
					canReflect_1_16_7_canReflect.getName(this),
					"\n key ", quoteString(prop),
					"\n is  ", quoteString(current),
					"\n was ", quoteString(previous)
				);
			};
			//!steal-remove-end
		}
	}
);

map$1(SimpleMap.prototype);

canReflect_1_16_7_canReflect.assignSymbols(SimpleMap.prototype,{
	// -type-
	"can.isMapLike": true,
	"can.isListLike": false,
	"can.isValueLike": false,

	// -get/set-
	"can.getKeyValue": SimpleMap.prototype.get,
	"can.setKeyValue": SimpleMap.prototype.set,
	"can.deleteKeyValue": function(prop) {
		if( this._data.hasOwnProperty(prop) ) {
			var old = this._data[prop];
			delete this._data[prop];

			//!steal-remove-start
			if (typeof this._log === "function") {
				this._log(prop, undefined, old);
			}
			//!steal-remove-end
			this.dispatch({
				keyChanged: prop,
				type: prop,
				//!steal-remove-start
				reasonLog: [ canReflect_1_16_7_canReflect.getName(this) + "'s", prop, "deleted", old ],
				//!steal-remove-end
			}, [undefined, old]);
		}
	},


	// -shape
	"can.getOwnEnumerableKeys": function(){
		canObservationRecorder_1_1_2_canObservationRecorder.add(this, 'can.keys');
		return Object.keys(this._data);
	},

	// -shape get/set-
	"can.assignDeep": function(source){
		canQueues_1_1_0_canQueues.batch.start();
		// TODO: we should probably just throw an error instead of cleaning
		canReflect_1_16_7_canReflect.assignMap(this, source);
		canQueues_1_1_0_canQueues.batch.stop();
	},
	"can.updateDeep": function(source){
		canQueues_1_1_0_canQueues.batch.start();
		// TODO: we should probably just throw an error instead of cleaning
		canReflect_1_16_7_canReflect.updateMap(this, source);
		canQueues_1_1_0_canQueues.batch.stop();
	},
	"can.keyHasDependencies": function(key) {
		return false;
	},
	"can.getKeyDependencies": function(key) {
		return undefined;
	},

	//!steal-remove-start
	"can.getName": function() {
		return canReflect_1_16_7_canReflect.getName(this.constructor) + "{}";
	},
	//!steal-remove-end
});

// Setup other symbols


var canSimpleMap_4_1_1_canSimpleMap = SimpleMap;

var TemplateContext = function() {
	this.vars = new canSimpleMap_4_1_1_canSimpleMap({});
	this.helpers = new canSimpleMap_4_1_1_canSimpleMap({});
	this.partials = new canSimpleMap_4_1_1_canSimpleMap({});
	this.tags = new canSimpleMap_4_1_1_canSimpleMap({});
};

var canViewScope_4_4_3_templateContext = TemplateContext;

var Compute = function(newVal){
	if(arguments.length) {
		return canReflect_1_16_7_canReflect.setValue(this, newVal);
	} else {
		return canReflect_1_16_7_canReflect.getValue(this);
	}
};

var canViewScope_4_4_3_makeComputeLike = function(observable) {
    var compute = Compute.bind(observable);

	//!steal-remove-start
	Object.defineProperty(compute, "name", {
		value: "Compute<"+canReflect_1_16_7_canReflect.getName(observable) + ">",
	});
	//!steal-remove-end

    compute.on = compute.bind = compute.addEventListener = function(event, handler) {
        var translationHandler = function(newVal, oldVal) {
            handler.call(compute, {type:'change'}, newVal, oldVal);
        };
        canSingleReference_1_0_0_canSingleReference.set(handler, this, translationHandler);
        observable.on(translationHandler);
    };
    compute.off = compute.unbind = compute.removeEventListener = function(event, handler) {
        observable.off( canSingleReference_1_0_0_canSingleReference.getAndDelete(handler, this) );
    };

    canReflect_1_16_7_canReflect.assignSymbols(compute, {
        "can.getValue": function(){
            return canReflect_1_16_7_canReflect.getValue(observable);
        },
        "can.setValue": function(newVal){
            return canReflect_1_16_7_canReflect.setValue(observable, newVal);
        },
        "can.onValue": function(handler, queue){
            return canReflect_1_16_7_canReflect.onValue(observable, handler, queue);
        },
        "can.offValue": function(handler, queue){
            return canReflect_1_16_7_canReflect.offValue(observable, handler, queue);
        },
        "can.valueHasDependencies": function(){
            return canReflect_1_16_7_canReflect.valueHasDependencies(observable);
        },
        "can.getPriority": function(){
    		return canReflect_1_16_7_canReflect.getPriority( observable );
    	},
    	"can.setPriority": function(newPriority){
    		canReflect_1_16_7_canReflect.setPriority( observable, newPriority );
    	},
		"can.isValueLike": true,
		"can.isFunctionLike": false
    });
    compute.isComputed = true;
    return compute;
};

// DependencyRecord :: { keyDependencies: Map, valueDependencies: Set }
var makeDependencyRecord = function makeDependencyRecord() {
	return {
		keyDependencies: new Map(),
		valueDependencies: new Set()
	};
};

var makeRootRecord = function makeRootRecord() {
	return {
		// holds mutated key dependencies of a key-value like object, e.g:
		// if person.first is mutated by other observable, this map will have a
		// key `first` (the mutated property) mapped to a DependencyRecord
		mutateDependenciesForKey: new Map(),

		// holds mutated value dependencies of value-like objects
		mutateDependenciesForValue: makeDependencyRecord()
	};
};

var addMutatedBy = function(mutatedByMap) {
	return function addMutatedBy(mutated, key, mutator) {
		var gotKey = arguments.length === 3;

		// normalize arguments
		if (arguments.length === 2) {
			mutator = key;
			key = undefined;
		}

		// normalize mutator when shorthand is used
		if (!mutator.keyDependencies && !mutator.valueDependencies) {
			mutator = { valueDependencies: new Set([mutator]) };
		}

		// retrieve root record from the state map or create a new one
		var root = mutatedByMap.get(mutated);
		if (!root) {
			root = makeRootRecord();
			mutatedByMap.set(mutated, root);
		}

		// create a [key] DependencyRecord if [key] was provided
		// and Record does not already exist
		if (gotKey && !root.mutateDependenciesForKey.get(key)) {
			root.mutateDependenciesForKey.set(key, makeDependencyRecord());
		}

		// retrieve DependencyRecord
		var dependencyRecord = gotKey ?
			root.mutateDependenciesForKey.get(key) :
			root.mutateDependenciesForValue;

		if (mutator.valueDependencies) {
			canReflect_1_16_7_canReflect.addValues(
				dependencyRecord.valueDependencies,
				mutator.valueDependencies
			);
		}

		if (mutator.keyDependencies) {
			canReflect_1_16_7_canReflect.each(mutator.keyDependencies, function(keysSet, obj) {
				var entry = dependencyRecord.keyDependencies.get(obj);

				if (!entry) {
					entry = new Set();
					dependencyRecord.keyDependencies.set(obj, entry);
				}

				canReflect_1_16_7_canReflect.addValues(entry, keysSet);
			});
		}
	};
};

var deleteMutatedBy = function(mutatedByMap) {
	return function deleteMutatedBy(mutated, key, mutator) {
		var gotKey = arguments.length === 3;
		var root = mutatedByMap.get(mutated);

		// normalize arguments
		if (arguments.length === 2) {
			mutator = key;
			key = undefined;
		}

		// normalize mutator when shorthand is used
		if (!mutator.keyDependencies && !mutator.valueDependencies) {
			mutator = { valueDependencies: new Set([mutator]) };
		}

		var dependencyRecord = gotKey ?
			root.mutateDependenciesForKey.get(key) :
			root.mutateDependenciesForValue;

		if (mutator.valueDependencies) {
			canReflect_1_16_7_canReflect.removeValues(
				dependencyRecord.valueDependencies,
				mutator.valueDependencies
			);
		}

		if (mutator.keyDependencies) {
			canReflect_1_16_7_canReflect.each(mutator.keyDependencies, function(keysSet, obj) {
				var entry = dependencyRecord.keyDependencies.get(obj);

				if (entry) {
					canReflect_1_16_7_canReflect.removeValues(entry, keysSet);
					if (!entry.size) {
						dependencyRecord.keyDependencies.delete(obj);
					}
				}
			});
		}
	};
};

var isFunction = function isFunction(value) {
	return typeof value === "function";
};

var getWhatIChangeSymbol = canSymbol_1_6_1_canSymbol.for("can.getWhatIChange");
var getKeyDependenciesSymbol = canSymbol_1_6_1_canSymbol.for("can.getKeyDependencies");
var getValueDependenciesSymbol$1 = canSymbol_1_6_1_canSymbol.for("can.getValueDependencies");

var getKeyDependencies = function getKeyDependencies(obj, key) {
	if (isFunction(obj[getKeyDependenciesSymbol])) {
		return canReflect_1_16_7_canReflect.getKeyDependencies(obj, key);
	}
};

var getValueDependencies = function getValueDependencies(obj) {
	if (isFunction(obj[getValueDependenciesSymbol$1])) {
		return canReflect_1_16_7_canReflect.getValueDependencies(obj);
	}
};

var getMutatedKeyDependencies =
	function getMutatedKeyDependencies(mutatedByMap, obj, key) {
		var root = mutatedByMap.get(obj);
		var dependencyRecord;

		if (root && root.mutateDependenciesForKey.has(key)) {
			dependencyRecord = root.mutateDependenciesForKey.get(key);
		}

		return dependencyRecord;
	};

var getMutatedValueDependencies =
	function getMutatedValueDependencies( mutatedByMap, obj) {
		var result;
		var root = mutatedByMap.get(obj);

		if (root) {
			var	dependencyRecord = root.mutateDependenciesForValue;

			if (dependencyRecord.keyDependencies.size) {
				result = result || {};
				result.keyDependencies = dependencyRecord.keyDependencies;
			}

			if (dependencyRecord.valueDependencies.size) {
				result = result || {};
				result.valueDependencies = dependencyRecord.valueDependencies;
			}
		}

		return result;
	};

var getWhatIChange = function getWhatIChange(obj, key) {
	if (isFunction(obj[getWhatIChangeSymbol])) {
		var gotKey = arguments.length === 2;

		return gotKey ?
			canReflect_1_16_7_canReflect.getWhatIChange(obj, key) :
			canReflect_1_16_7_canReflect.getWhatIChange(obj);
	}
};

var isEmptyRecord = function isEmptyRecord(record) {
	return (
		record == null ||
		!Object.keys(record).length ||
		(record.keyDependencies && !record.keyDependencies.size) &&
		(record.valueDependencies && !record.valueDependencies.size)
	);
};

var getWhatChangesMe = function getWhatChangesMe(mutatedByMap, obj, key) {
	var gotKey = arguments.length === 3;

	var mutate = gotKey ?
		getMutatedKeyDependencies(mutatedByMap, obj, key) :
		getMutatedValueDependencies(mutatedByMap, obj);

	var derive = gotKey ?
		getKeyDependencies(obj, key) :
		getValueDependencies(obj);

	if (!isEmptyRecord(mutate) || !isEmptyRecord(derive)) {
		return Object.assign(
			{},
			mutate ? { mutate: mutate } : null,
			derive ? { derive: derive } : null
		);
	}
};

var getDependencyDataOf = function(mutatedByMap) {
	return function getDependencyDataOf(obj, key) {
		var gotKey = arguments.length === 2;

		var whatChangesMe = gotKey ?
			getWhatChangesMe(mutatedByMap, obj, key) :
			getWhatChangesMe(mutatedByMap, obj);

		var whatIChange = gotKey ? getWhatIChange(obj, key) : getWhatIChange(obj);

		if (whatChangesMe || whatIChange) {
			return Object.assign(
				{},
				whatIChange ? { whatIChange: whatIChange } : null,
				whatChangesMe ? { whatChangesMe: whatChangesMe } : null
			);
		}
	};
};

// mutatedByMap :: WeakMap<obj, {
//	mutateDependenciesForKey:   Map<key, DependencyRecord>,
//	mutateDependenciesForValue: DependencyRecord
// }>
var mutatedByMap = new WeakMap();

var canReflectDependencies_1_0_2_canReflectDependencies = {
	// Track mutations between observable as dependencies
	// addMutatedBy(obs, obs2);
	// addMutatedBy(obs, key, obs2);
	// addMutatedBy(obs, { valueDependencies: Set, keyDependencies: Map })
	// addMutatedBy(obs, key, { valueDependencies: Set, keyDependencies: Map })
	addMutatedBy: addMutatedBy(mutatedByMap),

	// Call this method with the same arguments as `addMutatedBy`
	// to unregister the mutation dependency
	deleteMutatedBy: deleteMutatedBy(mutatedByMap),

	// Returns an object with the dependecies of the given argument
	//	{
	//		whatIChange: { mutate: DependencyRecord, derive: DependencyRecord },
	//		whatChangesMe: { mutate: DependencyRecord, derive: DependencyRecord }
	//	}
	getDependencyDataOf: getDependencyDataOf(mutatedByMap)
};

var canStacheHelpers_1_0_0_canStacheHelpers = createCommonjsModule(function (module) {
if (canNamespace_1_0_0_canNamespace.stacheHelpers) {
	throw new Error("You can't have two versions of can-stache-helpers, check your dependencies");
} else {
	module.exports = canNamespace_1_0_0_canNamespace.stacheHelpers = {};
}
});

var dispatchSymbol$2 = canSymbol_1_6_1_canSymbol.for("can.dispatch");

// The goal of this is to create a high-performance compute that represents a key value from can.view.Scope.
// If the key value is something like {{name}} and the context is a can.Map, a faster
// binding path will be used where new rebindings don't need to be looked for with every change of
// the observable property.
// However, if the property changes to a compute, then the slower `can.compute.read` method of
// observing values will be used.

// ideally, we would know the order things were read.  If the last thing read
// was something we can observe, and the value of it matched the value of the observation,
// and the key matched the key of the observation
// it's a fair bet that we can just listen to that last object.
// If the `this` is not that object ... freak out.  Though `this` is not necessarily part of it.  can-observation could make
// this work.

var peekValue = canObservationRecorder_1_1_2_canObservationRecorder.ignore(canReflect_1_16_7_canReflect.getValue.bind(canReflect_1_16_7_canReflect));

var getFastPathRoot = canObservationRecorder_1_1_2_canObservationRecorder.ignore(function(computeData){
	if( computeData.reads &&
				// a single property read
				computeData.reads.length === 1 ) {
		var root = computeData.root;
		if( root && root[canSymbol_1_6_1_canSymbol.for("can.getValue")] ) {
			root = canReflect_1_16_7_canReflect.getValue(root);
		}
		// on a map
		return root && canReflect_1_16_7_canReflect.isObservableLike(root) && canReflect_1_16_7_canReflect.isMapLike(root) &&
			// that isn't calling a function
			typeof root[computeData.reads[0].key] !== "function" && root;
	}
	return;
});

var isEventObject = function(obj){
	return obj && typeof obj.batchNum === "number" && typeof obj.type === "string";
};

// could we make this an observation first ... and have a getter for the compute?

// This is a fast-path enabled Observation wrapper use many places in can-stache.
// The goal of this is to:
//
// 1.  Make something that can be passed to can-view-live directly, hopefully
//     avoiding creating expensive computes.  Instead we will only be creating
//     `ScopeKeyData` which are thin wrappers.
var ScopeKeyData = function(scope, key, options){

	this.startingScope = scope;
	this.key = key;
	this.read = this.read.bind(this);
	this.dispatch = this.dispatch.bind(this);

	// special case debugger helper so that it is called with helperOtions
	// when you do {{debugger}} as it already is with {{debugger()}}
	if (key === "debugger") {
		// prevent "Unable to find key" warning
		this.startingScope = { _context: canStacheHelpers_1_0_0_canStacheHelpers };

		this.read = function() {
			var helperOptions = { scope: scope };
			var debuggerHelper = canStacheHelpers_1_0_0_canStacheHelpers["debugger"];
			return debuggerHelper(helperOptions);
		};
	}

	//!steal-remove-start
	Object.defineProperty(this.read, "name", {
		value: canReflect_1_16_7_canReflect.getName(this) + ".read",
	});
	Object.defineProperty(this.dispatch, "name", {
		value: canReflect_1_16_7_canReflect.getName(this) + ".dispatch",
	});
	//!steal-remove-end

	var observation = this.observation = new canObservation_4_0_1_canObservation(this.read, this);
	this.options = canAssign_1_1_1_canAssign({ observation: this.observation }, options);

	// things added later
	this.fastPath = undefined;
	this.root = undefined;
	this.initialValue = undefined;
	this.reads = undefined;
	this.setRoot = undefined;
	this.thisArg = undefined;
	this.parentHasKey = undefined;
	var valueDependencies = new Set();
	valueDependencies.add(observation);
	this.dependencies = {valueDependencies: valueDependencies};
};

value(ScopeKeyData.prototype);

Object.assign(ScopeKeyData.prototype, {
	constructor: ScopeKeyData,
	dispatch: function dispatch(newVal){
		var old = this.value;
		this.value = newVal;
		// call the base implementation in can-event-queue
		this[dispatchSymbol$2].call(this, this.value, old);
	},
	onBound: function onBound(){
		this.bound = true;
		canReflect_1_16_7_canReflect.onValue(this.observation, this.dispatch, "notify");
		// TODO: we should check this sometime in the background.
		var fastPathRoot = getFastPathRoot(this);
		if( fastPathRoot ) {
			// rewrite the observation to call its event handlers
			this.toFastPath(fastPathRoot);
		}
		this.value = peekValue(this.observation);
	},
	onUnbound: function onUnbound() {
		this.bound = false;
		canReflect_1_16_7_canReflect.offValue(this.observation, this.dispatch, "notify");
		this.toSlowPath();
	},
	set: function(newVal){
		var root = this.root || this.setRoot;
		if(root) {
			canStacheKey_1_3_2_canStacheKey.write(root, this.reads, newVal, this.options);
		} else {
			this.startingScope.set(this.key, newVal, this.options);
		}
	},
	get: function() {
		if (canObservationRecorder_1_1_2_canObservationRecorder.isRecording()) {
			canObservationRecorder_1_1_2_canObservationRecorder.add(this);
			if (!this.bound) {
				canObservation_4_0_1_canObservation.temporarilyBind(this);
			}
		}

		if (this.bound === true ) {
			return this.value;
		} else {
			return this.observation.get();
		}
	},
	toFastPath: function(fastPathRoot){
		var self = this,
			observation = this.observation;

		this.fastPath = true;

		// there won't be an event in the future ...
		observation.dependencyChange = function(target, newVal){
			if(isEventObject(newVal)) {
				throw "no event objects!";
			}
			// but I think we will be able to get at it b/c there should only be one
			// dependency we are binding to ...
			if(target === fastPathRoot && typeof newVal !== "function") {
				this.newVal = newVal;
			} else {
				// restore
				self.toSlowPath();
			}

			return canObservation_4_0_1_canObservation.prototype.dependencyChange.apply(this, arguments);
		};
		observation.onBound = function(){
			this.value = this.newVal;
		};
	},
	toSlowPath: function(){
		this.observation.dependencyChange = canObservation_4_0_1_canObservation.prototype.dependencyChange;
		this.observation.onBound = canObservation_4_0_1_canObservation.prototype.onBound;
		this.fastPath = false;
	},
	read: function(){
		var data;

		if (this.root) {
			// if we've figured out a root observable, start reading from there
			data = canStacheKey_1_3_2_canStacheKey.read(this.root, this.reads, this.options);

			//!steal-remove-start
			// remove old dependency
			canReflectDependencies_1_0_2_canReflectDependencies.deleteMutatedBy(
				// for properties like foo.bar add the dependency to foo
				this.thisArg || this.root,
				this.reads[ this.reads.length - 1 ].key,
				this
			);
			//!steal-remove-end

			// update thisArg and add new dependency
			this.thisArg = data.parent;

			//!steal-remove-start
			canReflectDependencies_1_0_2_canReflectDependencies.addMutatedBy(
				// for properties like foo.bar add the dependency to foo
				this.thisArg || this.root,
				this.reads[ this.reads.length - 1 ].key,
				{
					valueDependencies: new Set([ this ])
				}
			);
			//!steal-remove-end

			return data.value;
		}
		// If the key has not already been located in a observable then we need to search the scope for the
		// key.  Once we find the key then we need to return it's value and if it is found in an observable
		// then we need to store the observable so the next time this compute is called it can grab the value
		// directly from the observable.
		data = this.startingScope.read(this.key, this.options);

		//!steal-remove-start
		if (data.rootObserve) {
			canReflectDependencies_1_0_2_canReflectDependencies.addMutatedBy(
				// for properties like foo.bar add the dependency to foo
				data.thisArg || data.rootObserve,
				data.reads[ data.reads.length - 1 ].key,
				{
					valueDependencies: new Set([ this ])
				}
			);
		}
		//!steal-remove-end

		this.scope = data.scope;
		this.reads = data.reads;
		this.root = data.rootObserve;
		this.setRoot = data.setRoot;
		this.thisArg = data.thisArg;
		this.parentHasKey = data.parentHasKey;
		return this.initialValue = data.value;
	},
	hasDependencies: function(){
		return canReflect_1_16_7_canReflect.valueHasDependencies( this.observation );
	}
});

canReflect_1_16_7_canReflect.assignSymbols(ScopeKeyData.prototype, {
	"can.getValue": ScopeKeyData.prototype.get,
	"can.setValue": ScopeKeyData.prototype.set,
	"can.valueHasDependencies": ScopeKeyData.prototype.hasDependencies,
	"can.getValueDependencies": function() {
		return this.dependencies;
	},
	"can.getPriority": function(){
		return canReflect_1_16_7_canReflect.getPriority( this.observation );
	},
	"can.setPriority": function(newPriority){
		canReflect_1_16_7_canReflect.setPriority( this.observation, newPriority );
	},
	//!steal-remove-start
	"can.getName": function() {
		return canReflect_1_16_7_canReflect.getName(this.constructor) + "{{" + this.key + "}}";
	},
	//!steal-remove-end
});

// Creates a compute-like for legacy reasons ...
Object.defineProperty(ScopeKeyData.prototype, "compute", {
	get: function(){
		var compute = canViewScope_4_4_3_makeComputeLike(this);

		Object.defineProperty(this, "compute", {
			value: compute,
			writable: false,
			configurable: false
		});
		return compute;
	},
	configurable: true
});

var canViewScope_4_4_3_scopeKeyData = ScopeKeyData;

var canViewScope_4_4_3_compute_data = function(scope, key, options){
	return new canViewScope_4_4_3_scopeKeyData(scope, key, options || {
		args: []
	});
};

// # can/view/scope/scope.js
//
// This allows you to define a lookup context and parent contexts that a key's value can be retrieved from.
// If no parent scope is provided, only the scope's context will be explored for values.











function Scope(context, parent, meta) {
	// The obj that will be looked on for values.
	this._context = context;
	// The next Scope object whose context should be looked on for values.
	this._parent = parent;
	// If this is a special context, it can be labeled here.
	// Options are:
	// - viewModel - This is a viewModel
	// - notContext - This can't be looked within using `./` and `../`. It will be skipped.
	//   This is for virtual contexts like those used by `%index`.
	// - special - This can't be looked within using `./` and `../`. It will be skipped.
	//   This is for reading properties like {{scope.index}}.
	this._meta = meta || {};

	// A cache that can be used to store computes used to look up within this scope.
	// For example if someone creates a compute to lookup `name`, another compute does not
	// need to be created.
	this.__cache = {};
}

canAssign_1_1_1_canAssign(Scope, {
	// ## Scope.read
	// Scope.read was moved to can.compute.read
	// can.compute.read reads properties from a parent. A much more complex version of getObject.
	read: canStacheKey_1_3_2_canStacheKey.read,

	keyInfo: function(attr){
		var info = {};
		info.isDotSlash = attr.substr(0, 2) === './';
		info.isThisDot = attr.substr(0,5) === "this.";
		info.isThisAt = attr.substr(0,5) === "this@";
		info.isInCurrentContext = info.isDotSlash || info.isThisDot || info.isThisAt;
		info.isInParentContext = attr.substr(0, 3) === "../";
		info.isCurrentContext = attr === "." || attr === "this";
		info.isParentContext = attr === "..";
		info.isScope = attr === "scope";
		info.isInScope =
			attr.substr(0, 6) === "scope." ||
			attr.substr(0, 6) === "scope@";
		info.isContextBased = info.isInCurrentContext ||
			info.isInParentContext ||
			info.isCurrentContext ||
			info.isParentContext;
		return info;
	}
});

canAssign_1_1_1_canAssign(Scope.prototype, {

	// ## Scope.prototype.add
	// Creates a new scope and sets the current scope to be the parent.
	// ```
	// var scope = new can.view.Scope([
	//   {name:"Chris"},
	//   {name: "Justin"}
	// ]).add({name: "Brian"});
	// scope.attr("name") //-> "Brian"
	// ```
	add: function(context, meta) {
		if (context !== this._context) {
			return new this.constructor(context, this, meta);
		} else {
			return this;
		}
	},

	// ## Scope.prototype.find
	find: function(attr, options) {
		return this.get(attr, canAssign_1_1_1_canAssign({ currentScopeOnly: false }, options));
	},

	// ## Scope.prototype.read
	// Reads from the scope chain and returns the first non-`undefined` value.
	// `read` deals mostly with setting up "context based" keys to start reading
	// from the right scope. Once the right scope is located, `_read` is called.
	/**
	 * @hide
	 * @param {can.stache.key} attr A dot-separated path. Use `"\."` if you have a property name that includes a dot.
	 * @param {can.view.Scope.readOptions} options that configure how this gets read.
	 * @return {{}}
	 *   @option {Object} parent the value's immediate parent
	 *   @option {can.Map|can.compute} rootObserve the first observable to read from.
	 *   @option {Array<String>} reads An array of properties that can be used to read from the rootObserve to get the value.
	 *   @option {*} value the found value
	 */
	read: function(attr, options) {
		options = options || {};

		// make `{{./}}` an alias for `{{.}}`
		if (attr === "./") {
			attr = ".";
		}

		// Identify context based keys. Context based keys try to
		// specify a particular context a key should be within.
		var keyInfo = Scope.keyInfo(attr);

		// `notContext` contexts should be skipped if the key is "context based".
		// For example, the context that holds `%index`.
		if (keyInfo.isContextBased && (this._meta.notContext || this._meta.special)) {
			return this._parent.read(attr, options);
		}

		// If true, lookup stops after the current context.
		var currentScopeOnly = "currentScopeOnly" in options ? options.currentScopeOnly : true;

		if (keyInfo.isInCurrentContext) {
			// Stop lookup from checking parent scopes.
			// Set flag to halt lookup from walking up scope.
			currentScopeOnly = true;
			attr = keyInfo.isDotSlash ? attr.substr(2) : attr.substr(5);
		} else if ((keyInfo.isInParentContext || keyInfo.isParentContext) && this._parent) {
			// walk up until we find a parent that can have context.
			// the `isContextBased` check above won't catch it when you go from
			// `../foo` to `foo` because `foo` isn't context based.
			var parent = this._parent;
			while (parent._meta.notContext || parent._meta.special) {
				parent = parent._parent;
			}

			if (keyInfo.isParentContext) {
				return canStacheKey_1_3_2_canStacheKey.read(parent._context, [], options);
			}

			var parentValue = parent.read(attr.substr(3) || ".", options);

			return canAssign_1_1_1_canAssign( parentValue, {
				thisArg: parentValue.thisArg || parent._context
			});
		} else if (keyInfo.isCurrentContext) {
			return canStacheKey_1_3_2_canStacheKey.read(this._context, [], options);
		} else if (keyInfo.isScope) {
			return { value: this };
		}

		var keyReads = canStacheKey_1_3_2_canStacheKey.reads(attr);
		var readValue;

		if (keyInfo.isInScope) {
			// check for a value on Scope.prototype
			readValue = canStacheKey_1_3_2_canStacheKey.read(this, keyReads.slice(1), options);

			// otherwise, check the templateContext
			if (typeof readValue.value === 'undefined' && !readValue.parentHasKey) {
				readValue = this.readFromTemplateContext(attr.slice(6), options);
			}

			return canAssign_1_1_1_canAssign(readValue, {
				thisArg: keyReads.length > 1 ? readValue.parent : undefined
			});
		}

		return this._read(keyReads, options, currentScopeOnly);
	},

	// ## Scope.prototype.readFromSpecialContext
	readFromSpecialContext: function(key) {
		return this._read(
			[{key: key, at: false }],
			{ special: true }
		);
	},

	// ## Scope.prototype.readFromTemplateContext
	readFromTemplateContext: function(key, readOptions) {
		var keyReads = canStacheKey_1_3_2_canStacheKey.reads(key);
		return canStacheKey_1_3_2_canStacheKey.read(this.templateContext, keyReads, readOptions);
	},

	// ## Scope.prototype._read
	//
	_read: function(keyReads, options, currentScopeOnly) {
		// The current scope and context we are trying to find "keyReads" within.
		var currentScope = this,
			currentContext,

			// If no value can be found, this is a list of of every observed
			// object and property name to observe.
			undefinedObserves = [],

			// Tracks the first found observe.
			currentObserve,
			// Tracks the reads to get the value from `currentObserve`.
			currentReads,

			// Tracks the most likely observable to use as a setter.
			setObserveDepth = -1,
			currentSetReads,
			currentSetObserve,

			readOptions = canAssign_1_1_1_canAssign({
				/* Store found observable, incase we want to set it as the rootObserve. */
				foundObservable: function(observe, nameIndex) {
					currentObserve = observe;
					currentReads = keyReads.slice(nameIndex);
				},
				earlyExit: function(parentValue, nameIndex) {
					if (nameIndex > setObserveDepth || (nameIndex === setObserveDepth && (typeof parentValue === "object" && keyReads[nameIndex].key in parentValue))) {
						currentSetObserve = currentObserve;
						currentSetReads = currentReads;
						setObserveDepth = nameIndex;
					}
				}
			}, options);

		var isRecording = canObservationRecorder_1_1_2_canObservationRecorder.isRecording();

		// Goes through each scope context provided until it finds the key (attr). Once the key is found
		// then it's value is returned along with an observe, the current scope and reads.
		// While going through each scope context searching for the key, each observable found is returned and
		// saved so that either the observable the key is found in can be returned, or in the case the key is not
		// found in an observable the closest observable can be returned.
		while (currentScope) {
			currentContext = currentScope._context;

			// skip this if it _is_ a special context and we aren't explicitly reading special contexts
			if ((!options || options.special !== true) && currentScope._meta.special) {
				currentScope = currentScope._parent;
				continue;
			}

			// skip this if we _are_ explicitly reading special contexts and this context is _not_ special
			if (options && options.special && !currentScope._meta.special) {
				currentScope = currentScope._parent;
				continue;
			}

			if (currentContext !== null &&
				// if its a primitive type, keep looking up the scope, since there won't be any properties
				(typeof currentContext === "object" || typeof currentContext === "function")
			) {
				// Prevent computes from temporarily observing the reading of observables.
				var getObserves = canObservationRecorder_1_1_2_canObservationRecorder.trap();

				var data = canStacheKey_1_3_2_canStacheKey.read(currentContext, keyReads, readOptions);

				// Retrieve the observes that were read.
				var observes = getObserves();
				// If a **value was was found**, return value and location data.
				if (data.value !== undefined || data.parentHasKey) {

					if(!observes.length && isRecording) {
						// if we didn't actually observe anything
						// the reads and currentObserve don't mean anything
						// we just point to the current object so setting is fast
						currentObserve = data.parent;
						currentReads = keyReads.slice(keyReads.length - 1);
					} else {
						canObservationRecorder_1_1_2_canObservationRecorder.addMany(observes);
					}

					return {
						scope: currentScope,
						rootObserve: currentObserve,
						value: data.value,
						reads: currentReads,
						thisArg: keyReads.length > 1 ? data.parent : undefined,
						parentHasKey: data.parentHasKey
					};
				}
				// Otherwise, save all observables that were read. If no value
				// is found, we will observe on all of them.
				else {
					undefinedObserves.push.apply(undefinedObserves, observes);
				}
			}

			var parentIsNormalContext = currentScope._parent && currentScope._parent._meta &&
				!currentScope._parent._meta.notContext && !currentScope._parent._meta.special;

			if (currentScopeOnly && parentIsNormalContext) {
				currentScope = null;
			} else {
				// Move up to the next scope.
				currentScope = currentScope._parent;
			}
		}

		// The **value was not found** in the scope
		// if not looking for a "special" key, check in can-stache-helpers
		if (!(options && options.special)) {
			var helper = this.getHelper(keyReads);

			if (helper && helper.value) {
				return helper;
			}
		}

		// The **value was not found**, return `undefined` for the value.
		// Make sure we listen to everything we checked for when the value becomes defined.
		// Once it becomes defined, we won't have to listen to so many things.
		canObservationRecorder_1_1_2_canObservationRecorder.addMany(undefinedObserves);
		return {
			setRoot: currentSetObserve,
			reads: currentSetReads,
			value: undefined
		};
	},

	// ## Scope.prototype.getHelper
	// read a helper from the templateContext or global helpers list
	getHelper: function(keyReads) {
		var helper = canStacheKey_1_3_2_canStacheKey.read(this.templateContext.helpers, keyReads, { proxyMethods: false });

		if (!helper || !helper.value) {
			helper = canStacheKey_1_3_2_canStacheKey.read(canStacheHelpers_1_0_0_canStacheHelpers, keyReads, { proxyMethods: false });
		}

		return helper;
	},

	// ## Scope.prototype.get
	// Gets a value from the scope without being observable.
	get: function(key, options) {

		options = canAssign_1_1_1_canAssign({
			isArgument: true
		}, options);

		var res = this.read(key, options);
		return res.value;
	},
	peek: canObservationRecorder_1_1_2_canObservationRecorder.ignore(function(key, options) {
		return this.get(key, options);
	}),
	peak: canObservationRecorder_1_1_2_canObservationRecorder.ignore(function(key, options) {
		//!steal-remove-start
		dev.warn('peak is deprecated, please use peek instead');
		//!steal-remove-end
		return this.peek(key, options);
	}),
	// ## Scope.prototype.getScope
	// Returns the first scope that passes the `tester` function.
	getScope: function(tester) {
		var scope = this;
		while (scope) {
			if (tester(scope)) {
				return scope;
			}
			scope = scope._parent;
		}
	},
	// ## Scope.prototype.getContext
	// Returns the first context whose scope passes the `tester` function.
	getContext: function(tester) {
		var res = this.getScope(tester);
		return res && res._context;
	},
	// ## Scope.prototype.getTemplateContext
	// Returns the template context
	getTemplateContext: function() {
		var lastScope;

		// find the first reference scope
		var templateContext = this.getScope(function(scope) {
			lastScope = scope;
			return scope._context instanceof canViewScope_4_4_3_templateContext;
		});

		// if there is no reference scope, add one as the root
		if(!templateContext) {
			templateContext = new Scope(new canViewScope_4_4_3_templateContext());

			// add templateContext to root of the scope chain so it
			// can be found using `getScope` next time it is looked up
			lastScope._parent = templateContext;
		}
		return templateContext;
	},
	// ## Scope.prototype.getRoot
	// Returns the top most context that is not a references scope.
	// Used by `.read` to provide `%root`.
	getRoot: function() {
		var cur = this,
			child = this;

		while (cur._parent) {
			child = cur;
			cur = cur._parent;
		}

		if (cur._context instanceof canViewScope_4_4_3_templateContext) {
			cur = child;
		}
		return cur._context;
	},

	// first viewModel scope
	getViewModel: function() {
		var vmScope = this.getScope(function(scope) {
			return scope._meta.viewModel;
		});

		return vmScope && vmScope._context;
	},

	// _top_ viewModel scope
	getTop: function() {
		var top;

		this.getScope(function(scope) {
			if (scope._meta.viewModel) {
				top = scope;
			}

			// walk entire scope tree
			return false;
		});

		return top && top._context;
	},

	// ## Scope.prototype.getPathsForKey
	// Finds all paths that will return a value for a specific key
	// NOTE: this is for development purposes only and is removed in production
	getPathsForKey: function getPathsForKey(key) {
		//!steal-remove-start
		var paths = {};

		var getKeyDefinition = function(obj, key) {
			if (!obj || typeof obj !== "object") {
				return {};
			}

			var keyExistsOnObj = key in obj;
			var objHasKey = canReflect_1_16_7_canReflect.hasKey(obj, key);

			return {
				isDefined: keyExistsOnObj || objHasKey,
				isFunction: keyExistsOnObj && typeof obj[key] === "function"
			};
		};

		// scope.foo@bar -> bar
		var reads = canStacheKey_1_3_2_canStacheKey.reads(key);
		var keyParts = reads.map(function(read) {
			return read.key;
		});
		var scopeIndex = keyParts.indexOf("scope");

		if (scopeIndex > -1) {
			keyParts.splice(scopeIndex, 2);
		}
		var normalizedKey = keyParts.join(".");

		// check scope.vm.<key>
		var vm = this.getViewModel();
		var vmKeyDefinition = getKeyDefinition(vm, normalizedKey);

		if (vmKeyDefinition.isDefined) {
			paths["scope.vm." + normalizedKey + (vmKeyDefinition.isFunction ? "()" : "")] = vm;
		}

		// check scope.top.<key>
		var top = this.getTop();
		var topKeyDefinition = getKeyDefinition(top, normalizedKey);

		if (topKeyDefinition.isDefined) {
			paths["scope.top." + normalizedKey + (topKeyDefinition.isFunction ? "()" : "")] = top;
		}

		// find specific paths (like ../key)
		var cur = "";

		this.getScope(function(scope) {
			// `notContext` and `special` contexts can't be read using `../`
			var canBeRead = !scope._meta.special &&  !scope._meta.notContext;

			if (canBeRead) {
				var contextKeyDefinition = getKeyDefinition(scope._context, normalizedKey);
				if (contextKeyDefinition.isDefined) {
					paths[cur + normalizedKey + (contextKeyDefinition.isFunction ? "()" : "")] = scope._context;
				}

				cur += "../";
			}

			// walk entire scope tree
			return false;
		});

		return paths;
		//!steal-remove-end
	},

	// ## Scope.prototype.hasKey
	// returns whether or not this scope has the key
	hasKey: function hasKey(key) {
		var reads = canStacheKey_1_3_2_canStacheKey.reads(key);
		var readValue;

		if (reads[0].key === "scope") {
			// read properties like `scope.vm.foo` directly from the scope
			readValue = canStacheKey_1_3_2_canStacheKey.read(this, reads.slice(1), key);
		} else {
			// read normal properties from the scope's context
			readValue = canStacheKey_1_3_2_canStacheKey.read(this._context, reads, key);
		}

		return readValue.foundLastParent && readValue.parentHasKey;
	},

	// ## Scope.prototype.getDataForScopeSet
	// Returns an object with data needed by `.set` to figure out what to set,
	// and how.
	getDataForScopeSet: function getDataForScopeSet(key, options) {
		var keyInfo = Scope.keyInfo(key),
			parent;

		// Use `.read` to read everything upto, but not including the last property
		// name to find the object we want to set some property on.
		// For example:
		//  - `foo.bar` -> `foo`
		//  - `../foo.bar` -> `../foo`
		//  - `../foo` -> `..`
		//  - `foo` -> `.`
		if (keyInfo.isCurrentContext) {
			return { parent: this._context, how: "setValue" };
		} else if (keyInfo.isInParentContext || keyInfo.isParentContext) {
			// walk up until we find a parent that can have context.
			// the `isContextBased` check above won't catch it when you go from
			// `../foo` to `foo` because `foo` isn't context based.
			parent = this._parent;
			while (parent._meta.notContext) {
				parent = parent._parent;
			}

			if (keyInfo.isParentContext) {
				return { parent: parent._context, how: "setValue" };
			}
			// key starts with "../" or is "."
			return { how: "set", parent: parent, passOptions: true, key: key.substr(3) || "." };
		}

		var dotIndex = key.lastIndexOf('.'),
			slashIndex = key.lastIndexOf('/'),
			contextPath,
			propName;

		if (slashIndex > dotIndex) {
			// ../foo
			contextPath = key.substring(0, slashIndex);
			propName = key.substring(slashIndex + 1, key.length);
		} else {
			if (dotIndex !== -1) {
				// ./foo
				contextPath = key.substring(0, dotIndex);
				propName = key.substring(dotIndex + 1, key.length);
			} else {
				// foo.bar
				contextPath = ".";
				propName = key;
			}
		}

		var context = this.read(contextPath, options).value;
		if (context === undefined) {
			return {
				error: "Attempting to set a value at " +
					key + " where " + contextPath + " is undefined."
			};
		}

		if(!canReflect_1_16_7_canReflect.isObservableLike(context) && canReflect_1_16_7_canReflect.isObservableLike(context[propName])) {
			if(canReflect_1_16_7_canReflect.isMapLike(context[propName])) {
				return {
					parent: context,
					key: propName,
					how: "updateDeep",
					warn: "can-view-scope: Merging data into \"" +
						propName + "\" because its parent is non-observable"
				};
			}
			else if(canReflect_1_16_7_canReflect.isValueLike(context[propName])){
				return { parent: context, key: propName, how: "setValue" };
			} else {
				return { parent: context, how: "write", key: propName, passOptions: true };
			}
		} else {
			return { parent: context, how: "write", key: propName, passOptions: true };
		}
	},

	set: function(key, value, options) {
		options = options || {};

		var data = this.getDataForScopeSet(key, options);
		var parent = data.parent;

		//!steal-remove-start
		if (data.error) {
			return dev.error(data.error);
		}
		//!steal-remove-end

		if (data.warn) {
			dev.warn(data.warn);
		}

		switch (data.how) {
			case "set":
				parent.set(data.key, value, data.passOptions ? options : undefined);
				break;

			case "write":
				canStacheKey_1_3_2_canStacheKey.write(parent, data.key, value, options);
				break;

			case "setValue":
				canReflect_1_16_7_canReflect.setValue("key" in data ? parent[data.key] : parent, value);
				break;

			case "setKeyValue":
				canReflect_1_16_7_canReflect.setKeyValue(parent, data.key, value);
				break;

			case "updateDeep":
				canReflect_1_16_7_canReflect.updateDeep(parent[data.key], value);
				break;
		}
	},

	// ## Scope.prototype.attr
	// Gets or sets a value in the scope without being observable.
	attr: canObservationRecorder_1_1_2_canObservationRecorder.ignore(function(key, value, options) {
		dev.warn("can-view-scope::attr is deprecated, please use peek, get or set");

		options = canAssign_1_1_1_canAssign({
			isArgument: true
		}, options);

		// Allow setting a value on the context
		if (arguments.length === 2) {
			return this.set(key, value, options);

		} else {
			return this.get(key, options);
		}
	}),

	// ## Scope.prototype.computeData
	// Finds the first location of the key in the scope and then provides a get-set compute that represents the key's value
	// and other information about where the value was found.
	computeData: function(key, options) {
		return canViewScope_4_4_3_compute_data(this, key, options);
	},

	// ## Scope.prototype.compute
	// Provides a get-set compute that represents a key's value.
	compute: function(key, options) {
		return this.computeData(key, options)
			.compute;
	},
	// ## Scope.prototype.cloneFromRef
	//
	// This takes a scope and essentially copies its chain from
	// right before the last TemplateContext. And it does not include the ref.
	// this is a helper function to provide lexical semantics for refs.
	// This will not be needed for leakScope: false.
	cloneFromRef: function() {
		var contexts = [];
		var scope = this,
			context,
			parent;
		while (scope) {
			context = scope._context;
			if (context instanceof canViewScope_4_4_3_templateContext) {
				parent = scope._parent;
				break;
			}
			contexts.unshift(context);
			scope = scope._parent;
		}
		if (parent) {
			contexts.forEach(function(context) {
				parent = parent.add(context);
			});
			return parent;
		} else {
			return this;
		}
	}
});

canReflect_1_16_7_canReflect.assignSymbols(Scope.prototype, {
	"can.hasKey": Scope.prototype.hasKey
});

var templateContextPrimitives = [
	"filename", "lineNumber"
];

// create getters/setters for primitives on the templateContext
// scope.filename -> scope.readFromTemplateContext("filename")
templateContextPrimitives.forEach(function(key) {
	Object.defineProperty(Scope.prototype, key, {
		get: function() {
			return this.readFromTemplateContext(key).value;
		},
		set: function(val) {
			this.templateContext[key] = val;
		}
	});
});

canDefineLazyValue_1_0_2_defineLazyValue(Scope.prototype, 'templateContext', function() {
	return this.getTemplateContext()._context;
});

canDefineLazyValue_1_0_2_defineLazyValue(Scope.prototype, 'root', function() {
	dev.warn('`scope.root` is deprecated. Use either `scope.top` or `scope.vm` instead.');
	return this.getRoot();
});

canDefineLazyValue_1_0_2_defineLazyValue(Scope.prototype, 'vm', function() {
	return this.getViewModel();
});

canDefineLazyValue_1_0_2_defineLazyValue(Scope.prototype, 'top', function() {
	return this.getTop();
});

canDefineLazyValue_1_0_2_defineLazyValue(Scope.prototype, 'helpers', function() {
	return canStacheHelpers_1_0_0_canStacheHelpers;
});

var specialKeywords = [
	'index', 'key', 'element',
	'event', 'viewModel','arguments',
	'helperOptions'
];

// create getters for "special" keys
// scope.index -> scope.readFromSpecialContext("index")
specialKeywords.forEach(function(key) {
	Object.defineProperty(Scope.prototype, key, {
		get: function() {
			return this.readFromSpecialContext(key).value;
		}
	});
});

canNamespace_1_0_0_canNamespace.view = canNamespace_1_0_0_canNamespace.view || {};
var canViewScope_4_4_3_canViewScope = canNamespace_1_0_0_canNamespace.view.Scope = Scope;

// when printing out strings to the console, quotes are not included which
// makes it confusing to tell the actual output from static string messages
function quoteString$1(x) {
	return typeof x === "string" ? JSON.stringify(x) : x;
}

// To add the `.log` function to a observable
// a.- Add the log function to the propotype:
//	   `Observable.propotype.log = log`
// b.- Make sure `._log` is called by the observable when mutation happens
//     `_.log` should be passed the current value and the value before the mutation
var canSimpleObservable_2_0_4_log = function log() {
	//!steal-remove-start
	this._log = function(previous, current) {
		dev.log(
			canReflect_1_16_7_canReflect.getName(this),
			"\n is  ", quoteString$1(current),
			"\n was ", quoteString$1(previous)
		);
	};
	//!steal-remove-end
};

var dispatchSymbol$3 = canSymbol_1_6_1_canSymbol.for("can.dispatch");

/**
 * @module {function} can-simple-observable
 * @parent can-observables
 * @collection can-infrastructure
 * @package ./package.json
 * @description Create an observable value.
 *
 * @signature `new SimpleObservable(initialValue)`
 *
 * Creates an observable value that can be read, written, and observed using [can-reflect].
 *
 * @param {*} initialValue The initial value of the observable.
 *
 * @return {can-simple-observable} An observable instance
 *
 * @body
 *
 * ## Use
 *
 * ```js
 *  var obs = new SimpleObservable('one');
 *
 *  canReflect.getValue(obs); // -> "one"
 *
 *  canReflect.setValue(obs, 'two');
 *  canReflect.getValue(obs); // -> "two"
 *
 *  function handler(newValue) {
 *    // -> "three"
 *  };
 *  canReflect.onValue(obs, handler);
 *  canReflect.setValue(obs, 'three');
 *
 *  canReflect.offValue(obs, handler);
 * ```
 */
function SimpleObservable$1(initialValue) {
	this.value = initialValue;
}

// mix in the value-like object event bindings
value(SimpleObservable$1.prototype);

Object.assign(SimpleObservable$1.prototype, {
	log: canSimpleObservable_2_0_4_log,
	get: function(){
		canObservationRecorder_1_1_2_canObservationRecorder.add(this);
		return this.value;
	},
	set: function(value$$1){
		var old = this.value;
		this.value = value$$1;

		this[dispatchSymbol$3](value$$1, old);
	}
});

canReflect_1_16_7_canReflect.assignSymbols(SimpleObservable$1.prototype, {
	"can.getValue": SimpleObservable$1.prototype.get,
	"can.setValue": SimpleObservable$1.prototype.set,
	"can.isMapLike": false,
	"can.valueHasDependencies": function(){
		return true;
	},
	//!steal-remove-start
	"can.getName": function() {
		var value$$1 = this.value;
		if (typeof value$$1 !== 'object' || value$$1 === null) {
			value$$1 = JSON.stringify(value$$1);
		}
		else {
			value$$1 = '';
		}

		return canReflect_1_16_7_canReflect.getName(this.constructor) + "<" + value$$1 + ">";
	},
	//!steal-remove-end
});

var canSimpleObservable_2_0_4_canSimpleObservable = canNamespace_1_0_0_canNamespace.SimpleObservable = SimpleObservable$1;

var peek$4 = canObservationRecorder_1_1_2_canObservationRecorder.ignore(canReflect_1_16_7_canReflect.getValue.bind(canReflect_1_16_7_canReflect));

// This supports an "internal" settable value that the `fn` can derive its value from.
// It's useful to `can-define`.
// ```
// new SettableObservable(function(lastSet){
//   return lastSet * 5;
// }, null, 5)
// ```
function SettableObservable$1(fn, context, initialValue) {

	this.lastSetValue = new canSimpleObservable_2_0_4_canSimpleObservable(initialValue);
	function observe() {
		return fn.call(context, this.lastSetValue.get());
	}
	this.handler = this.handler.bind(this);

	//!steal-remove-start
	canReflect_1_16_7_canReflect.assignSymbols(this, {
		"can.getName": function() {
			return (
				canReflect_1_16_7_canReflect.getName(this.constructor) +
				"<" +
				canReflect_1_16_7_canReflect.getName(fn) +
				">"
			);
		}
	});
	Object.defineProperty(this.handler, "name", {
		value: canReflect_1_16_7_canReflect.getName(this) + ".handler"
	});
	Object.defineProperty(observe, "name", {
		value: canReflect_1_16_7_canReflect.getName(fn) + "::" + canReflect_1_16_7_canReflect.getName(this.constructor)
	});
	//!steal-remove-end

	this.observation = new canObservation_4_0_1_canObservation(observe, this);
}

value(SettableObservable$1.prototype);

Object.assign(SettableObservable$1.prototype, {
	// call `obs.log()` to log observable changes to the browser console
	// The observable has to be bound for `.log` to be called
	log: canSimpleObservable_2_0_4_log,
	constructor: SettableObservable$1,
	handler: function(newVal) {
		var old = this.value;
		this.value = newVal;

		//!steal-remove-start
		if (typeof this._log === "function") {
			this._log(old, newVal);
		}
		//!steal-remove-end

		// adds callback handlers to be called w/i their respective queue.
		canQueues_1_1_0_canQueues.enqueueByQueue(
			this.handlers.getNode([]),
			this,
			[newVal, old],
			function() {
				return {};
			}
		);
	},
	onBound: function() {
		// onBound can be called by `.get` and then later called through
		// a keyTree binding.
		if(!this.bound) {
			this.bound = true;
			this.activate();
		}
	},
	activate: function(){
		canReflect_1_16_7_canReflect.onValue(this.observation, this.handler, "notify");
		this.value = peek$4(this.observation);
	},
	onUnbound: function() {
		this.bound = false;
		canReflect_1_16_7_canReflect.offValue(this.observation, this.handler, "notify");
	},
	set: function(newVal) {
		var oldVal =  this.lastSetValue.get();

		if (
			canReflect_1_16_7_canReflect.isObservableLike(oldVal) &&
			canReflect_1_16_7_canReflect.isValueLike(oldVal) &&
			!canReflect_1_16_7_canReflect.isObservableLike(newVal)
		) {
			canReflect_1_16_7_canReflect.setValue(oldVal, newVal);
		} else {
			if (newVal !== oldVal) {
				this.lastSetValue.set(newVal);
			}
		}
	},
	get: function() {
		if (canObservationRecorder_1_1_2_canObservationRecorder.isRecording()) {
			canObservationRecorder_1_1_2_canObservationRecorder.add(this);
			if (!this.bound) {
				// proactively setup bindings
				this.onBound();
			}
		}

		if (this.bound === true) {
			return this.value;
		} else {
			return this.observation.get();
		}
	},
	hasDependencies: function() {
		return canReflect_1_16_7_canReflect.valueHasDependencies(this.observation);
	},
	getValueDependencies: function() {
		return canReflect_1_16_7_canReflect.getValueDependencies(this.observation);
	}
});

canReflect_1_16_7_canReflect.assignSymbols(SettableObservable$1.prototype, {
	"can.getValue": SettableObservable$1.prototype.get,
	"can.setValue": SettableObservable$1.prototype.set,
	"can.isMapLike": false,
	"can.getPriority": function() {
		return canReflect_1_16_7_canReflect.getPriority(this.observation);
	},
	"can.setPriority": function(newPriority) {
		canReflect_1_16_7_canReflect.setPriority(this.observation, newPriority);
	},
	"can.valueHasDependencies": SettableObservable$1.prototype.hasDependencies,
	"can.getValueDependencies": SettableObservable$1.prototype.getValueDependencies
});

var settable$1 = SettableObservable$1;

function KeyObservable(root, key){
    key = ""+key;
    this.key = key;
    this.root = root;
    settable$1.call(this, function(){
        return canStacheKey_1_3_2_canStacheKey.get(this,key);
    }, root);
}

KeyObservable.prototype = Object.create(settable$1.prototype);

KeyObservable.prototype.set = function(newVal) {
    canStacheKey_1_3_2_canStacheKey.set(this.root,this.key, newVal);
};


var keyObservable = KeyObservable;

// this creates a noop that marks that a renderer was called
// this is for situations where a helper function calls a renderer
// that was not provided such as
// {{#if false}} ... {{/if}}
// with no {{else}}
var createNoOpRenderer = function (metadata) {
	return function noop() {
		if (metadata) {
			metadata.rendered = true;
		}
	};
};

var utils$1 = {
	last: function(arr){
		return arr !=null && arr[arr.length-1];
	},
	// A generic empty function
	emptyHandler: function(){},
	// Converts a string like "1" into 1. "null" into null, etc.
	// This doesn't have to do full JSON, so removing eval would be good.
	jsonParse: function(str){
		// if it starts with a quote, assume a string.
		if(str[0] === "'") {
			return str.substr(1, str.length -2);
		} else if(str === "undefined") {
			return undefined;
		} else {
			return JSON.parse(str);
		}
	},
	mixins: {
		last: function(){
			return this.stack[this.stack.length - 1];
		},
		add: function(chars){
			this.last().add(chars);
		},
		subSectionDepth: function(){
			return this.stack.length - 1;
		}
	},
	// Sets .fn and .inverse on a helperOptions object and makes sure
	// they can reference the current scope and options.
	createRenderers: function(helperOptions, scope, nodeList, truthyRenderer, falseyRenderer, isStringOnly){
		helperOptions.fn = truthyRenderer ? this.makeRendererConvertScopes(truthyRenderer, scope, nodeList, isStringOnly, helperOptions.metadata) : createNoOpRenderer(helperOptions.metadata);
		helperOptions.inverse = falseyRenderer ? this.makeRendererConvertScopes(falseyRenderer, scope, nodeList, isStringOnly, helperOptions.metadata) : createNoOpRenderer(helperOptions.metadata);
		helperOptions.isSection = !!(truthyRenderer || falseyRenderer);
	},
	// Returns a new renderer function that makes sure any data or helpers passed
	// to it are converted to a can.view.Scope and a can.view.Options.
	makeRendererConvertScopes: function (renderer, parentScope, nodeList, observeObservables, metadata) {
		var convertedRenderer = function (newScope, newOptions, parentNodeList) {
			// prevent binding on fn.
			// If a non-scope value is passed, add that to the parent scope.
			if (newScope !== undefined && !(newScope instanceof canViewScope_4_4_3_canViewScope)) {
				if (parentScope) {
					newScope = parentScope.add(newScope);
				}
				else {
					newScope = new canViewScope_4_4_3_canViewScope(newScope || {});
				}
			}
			if (metadata) {
				metadata.rendered = true;
			}

			var result = renderer(newScope || parentScope, parentNodeList || nodeList );
			return result;
		};
		return observeObservables ? convertedRenderer :
			canObservationRecorder_1_1_2_canObservationRecorder.ignore(convertedRenderer);
	},
	// Calls the truthy subsection for each item in a list and returning them in a string.
	getItemsStringContent: function(items, isObserveList, helperOptions){
		var txt = "",
			len = canStacheKey_1_3_2_canStacheKey.get(items, 'length'),
			isObservable = canReflect_1_16_7_canReflect.isObservableLike(items);

		for (var i = 0; i < len; i++) {
			var item = isObservable ? new keyObservable(items, i) :items[i];
			txt += helperOptions.fn(item);
		}
		return txt;
	},
	// Calls the truthy subsection for each item in a list and returns them in a document Fragment.
	getItemsFragContent: function(items, helperOptions, scope) {
		var result = [],
			len = canStacheKey_1_3_2_canStacheKey.get(items, 'length'),
			isObservable = canReflect_1_16_7_canReflect.isObservableLike(items),
			hashExprs = helperOptions.exprData && helperOptions.exprData.hashExprs,
			hashOptions;

		// Check if using hash
		if (canReflect_1_16_7_canReflect.size(hashExprs) > 0) {
			hashOptions = {};
			canReflect_1_16_7_canReflect.eachKey(hashExprs, function (exprs, key) {
				hashOptions[exprs.key] = key;
			});
		}

		for (var i = 0; i < len; i++) {
			var aliases = {};

			var item = isObservable ? new keyObservable(items, i) :items[i];

			if (canReflect_1_16_7_canReflect.size(hashOptions) > 0) {
				if (hashOptions.value) {
					aliases[hashOptions.value] = item;
				}
				if (hashOptions.index) {
					aliases[hashOptions.index] = i;
				}
			}

			result.push(helperOptions.fn(
				scope
				.add(aliases, { notContext: true })
				.add({ index: i }, { special: true })
				.add(item))
			);
		}
		return result;
	}
};

var last = utils$1.last;

var decodeHTML = typeof document !== "undefined" && (function(){
	var el = document$1().createElement('div');
	return function(html){
		if(html.indexOf("&") === -1) {
			return html.replace(/\r\n/g,"\n");
		}
		el.innerHTML = html;
		return el.childNodes.length === 0 ? "" : el.childNodes.item(0).nodeValue;
	};
})();
// ## HTMLSectionBuilder
//
// Contains a stack of HTMLSections.
// An HTMLSection is created everytime a subsection is found. For example:
//
//     {{#if(items)}} {{#items}} X
//
// At the point X was being processed, there would be 2 HTMLSections in the
// stack.  One for the content of `{{#if(items)}}` and the other for the
// content of `{{#items}}`
var HTMLSectionBuilder = function(filename){
	if (filename) {
		this.filename = filename;
	}
	this.stack = [new HTMLSection()];
};

HTMLSectionBuilder.scopify = function(renderer) {
	return canObservationRecorder_1_1_2_canObservationRecorder.ignore(function(scope, options, nodeList){
		if ( !(scope instanceof canViewScope_4_4_3_canViewScope) ) {
			scope = new canViewScope_4_4_3_canViewScope(scope || {});
		}

		// Support passing nodeList as the second argument
		if (nodeList === undefined && canReflect_1_16_7_canReflect.isListLike(options)) {
			nodeList = options;
			options = undefined;
		}

		// if an object is passed to options, assume it is the helpers object
		if (options && !options.helpers && !options.partials && !options.tags) {
			options = {
				helpers: options
			};
		}

		// mark passed in helper so they will be automatically passed
		// helperOptions (.fn, .inverse, etc) when called as Call Expressions
		canReflect_1_16_7_canReflect.eachKey(options && options.helpers, function(helperValue) {
			helperValue.requiresOptionsArgument = true;
		});

		var templateContext = scope.templateContext;

		// loop through each option category - helpers, partials, etc
		canReflect_1_16_7_canReflect.eachKey(options, function(optionValues, optionKey) {
			var container = templateContext[optionKey];

			if (container) {
				// loop through each helper/partial
				canReflect_1_16_7_canReflect.eachKey(optionValues, function(optionValue, optionValueKey) {
					canReflect_1_16_7_canReflect.setKeyValue(container, optionValueKey, optionValue);
				});
			}
		});

		return renderer(scope, nodeList);
	});
};

canAssign_1_1_1_canAssign(HTMLSectionBuilder.prototype,utils$1.mixins);

canAssign_1_1_1_canAssign(HTMLSectionBuilder.prototype,{
	startSubSection: function(process){
		var newSection = new HTMLSection(process);
		this.stack.push(newSection);
		return newSection;
	},
	// Ends the current section and returns a renderer.
	// But only returns a renderer if there is a template.
	endSubSectionAndReturnRenderer: function(){
		if(this.last().isEmpty()) {
			this.stack.pop();
			return null;
		} else {
			var htmlSection = this.endSection();
			return htmlSection.compiled.hydrate.bind(htmlSection.compiled);
		}
	},
	startSection: function( process ) {
		var newSection = new HTMLSection(process);
		this.last().add(newSection.targetCallback);
		// adding a section within a section ...
		// the stack has section ...
		this.stack.push(newSection);
	},
	endSection: function(){
		this.last().compile();
		return this.stack.pop();
	},
	inverse: function(){
		this.last().inverse();
	},
	compile: function(){
		var compiled = this.stack.pop().compile();
		// ignore observations here.  the render fn
		//  itself doesn't need to be observable.
		return canObservationRecorder_1_1_2_canObservationRecorder.ignore(function(scope, nodeList){
			if ( !(scope instanceof canViewScope_4_4_3_canViewScope) ) {
				scope = new canViewScope_4_4_3_canViewScope(scope || {});
			}

			return compiled.hydrate(scope, nodeList);
		});
	},
	push: function(chars){
		this.last().push(chars);
	},
	pop: function(){
		return this.last().pop();
	},
	removeCurrentNode: function() {
		this.last().removeCurrentNode();
	}
});

var HTMLSection = function(process){
	this.data = "targetData";
	this.targetData = [];
	// A record of what targetData element we are within.
	this.targetStack = [];
	var self = this;
	this.targetCallback = function(scope, sectionNode){
		process.call(this,
			scope,
			sectionNode,
			self.compiled.hydrate.bind(self.compiled),
			self.inverseCompiled && self.inverseCompiled.hydrate.bind(self.inverseCompiled)  ) ;
	};
};
canAssign_1_1_1_canAssign(HTMLSection.prototype,{
	inverse: function(){
		this.inverseData = [];
		this.data = "inverseData";
	},
	// Adds a DOM node.
	push: function(data){
		this.add(data);
		this.targetStack.push(data);
	},
	pop: function(){
		return this.targetStack.pop();
	},
	add: function(data){
		if(typeof data === "string"){
			data = decodeHTML(data);
		}
		if(this.targetStack.length) {
			last(this.targetStack).children.push(data);
		} else {
			this[this.data].push(data);
		}
	},
	compile: function(){
		this.compiled = canViewTarget_4_0_1_canViewTarget(this.targetData, document$1());
		if(this.inverseData) {
			this.inverseCompiled = canViewTarget_4_0_1_canViewTarget(this.inverseData, document$1());
			delete this.inverseData;
		}
		this.targetStack = this.targetData = null;
		return this.compiled;
	},
	removeCurrentNode: function() {
		var children = this.children();
		return children.pop();
	},
	children: function(){
		if(this.targetStack.length) {
			return last(this.targetStack).children;
		} else {
			return this[this.data];
		}
	},
	// Returns if a section is empty
	isEmpty: function(){
		return !this.targetData.length;
	}
});
HTMLSectionBuilder.HTMLSection = HTMLSection;

var html_section = HTMLSectionBuilder;

/**
 * @module {{}} can-view-live can-view-live
 * @parent can-views
 * @collection can-infrastructure
 * @package ../package.json
 *
 * Setup live-binding between the DOM and a compute manually.
 *
 * @option {Object} An object with the live-binding methods:
 * [can-view-live.html], [can-view-live.list], [can-view-live.text], and
 * [can-view-live.attr].
 *
 * @release 2.0.4
 *
 * @body
 *
 * ## Use
 *
 *  [can-view-live] is an object with utility methods for setting up
 *  live-binding in relation to different parts of the DOM and DOM elements.  For
 *  example, to make an `<h2>`'s text stay live with
 *  a compute:
 *
 *  ```js
 *  var live = require("can-view-live");
 *  var text = canCompute("Hello World");
 *  var textNode = $("h2").text(" ")[0].childNodes[0];
 *  live.text(textNode, text);
 *  ```
 *
 */
var live = {
	setup: function(el, bind, unbind) {
		// #### setup
		// Setup a live listener on an element that binds now,
		//  but unbinds when an element is no longer in the DOM
		var tornDown = false,
			removalDisposal,
			data,
			teardown = function() {
				// Removing an element can call teardown which
				// unregister the nodeList which calls teardown
				if (!tornDown) {
					tornDown = true;
					unbind(data);
					if (removalDisposal) {
						removalDisposal();
						removalDisposal = undefined;
					}
				}
				return true;
			};
		data = {
			teardownCheck: function(parent) {
				return parent ? false : teardown();
			}
		};
		removalDisposal = canDomMutate_1_0_4_canDomMutate.onNodeRemoval(el, function () {
			if (!el.ownerDocument.contains(el)) {
				teardown();
			}
		});
		bind(data);
		return data;
	},
	// #### listen
	// Calls setup, but presets bind and unbind to
	// operate on a compute
	listen: function(el, compute, change, queueName) {
		return live.setup(
			el,
			function bind() {
				// listen to notify, so on a change, this can
				// teardown all children quickly.
				canReflect_1_16_7_canReflect.onValue(compute, change, queueName || "notify");
				//compute.computeInstance.addEventListener('change', change);

				//!steal-remove-start
				canReflectDependencies_1_0_2_canReflectDependencies.addMutatedBy(el, compute);
				//!steal-remove-end
			},
			function unbind(data) {
				canReflect_1_16_7_canReflect.offValue(compute, change, queueName || "notify");

				//!steal-remove-start
				canReflectDependencies_1_0_2_canReflectDependencies.deleteMutatedBy(el, compute);
				//!steal-remove-end

				//compute.computeInstance.removeEventListener('change', change);
				if (data.nodeList) {
					canViewNodelist_4_2_0_canViewNodelist.unregister(data.nodeList);
				}
			}
		);
	},
	// #### getAttributeParts
	// Breaks up a string like foo='bar' into an object of {"foo": "bar"} pairs
	// See can-view-parser for more about attrStart/attrEnd/attrValue
	getAttributeParts: function(newVal) {
		var attrs = {},
			attr;
		canViewParser_4_0_2_canViewParser.parseAttrs(newVal, {
			attrStart: function(name) {
				attrs[name] = "";
				attr = name;
			},
			attrValue: function(value) {
				attrs[attr] += value;
			},
			attrEnd: function() {}
		});
		return attrs;
	},
	// #### isNode
	// Checks a possible node object for the nodeType property
	isNode: function(obj) {
		return obj && obj.nodeType;
	},
	// #### addTextNodeIfNoChildren
	// Append an empty text node to a parent with no children;
	//  do nothing if the parent already has children.
	addTextNodeIfNoChildren: function(frag) {
		if (!frag.firstChild) {
			frag.appendChild(frag.ownerDocument.createTextNode(""));
		}
	},


	/**
	 * @function can.view.live.replace
	 * @parent can.view.live
	 * @release 2.0.4
	 * @hide
	 *
	 * Replaces one element with some content while keeping [can.view.live.nodeLists nodeLists] data
	 * correct.
	 *
	 * @param {Array.<HTMLElement>} nodes An array of elements.  There should typically be one element.
	 * @param {String|HTMLElement|DocumentFragment} val The content that should replace
	 * `nodes`.  If a string is passed, it will be [can.view.hookup hookedup].
	 *
	 * @param {function} [teardown] A callback if these elements are torn down.
	 */
	replace: function(nodes, val, teardown) {
		// #### replace
		// Replaces one element with some content while keeping nodeLists data
		// correct.
		//
		// Take a copy of old nodeList
		var oldNodes = nodes.slice(0),
			frag = canFragment_1_0_1_canFragment(val);
		// Register a teardown callback
		canViewNodelist_4_2_0_canViewNodelist.register(nodes, teardown);
		// Mark each node as belonging to the node list.
		canViewNodelist_4_2_0_canViewNodelist.update(nodes, canChildNodes_1_0_0_canChildNodes(frag));
		// Replace old nodes with new on the DOM
		canViewNodelist_4_2_0_canViewNodelist.replace(oldNodes, frag);
		return nodes;
	},
	// #### getParentNode
	// Return default parent if el is a fragment, el's parent otherwise
	getParentNode: function(el, defaultParentNode) {
		return defaultParentNode && el.parentNode.nodeType === 11 ? defaultParentNode : el.parentNode;
	},
	// #### makeString
	// any -> string converter (including nullish)
	makeString: function(txt) {
		return txt == null ? "" : "" + txt;
	}
};

var core = live;

var canDomDataState_1_0_1_canDomDataState = createCommonjsModule(function (module) {




var isEmptyObject = function(obj){
	/* jshint -W098 */
	for(var prop in obj) {
		return false;
	}
	return true;
};

var data = {};
var removedDisposalMap = {};

// delete this node's `data`
// returns true if the node was deleted.
var deleteNode = function() {
	var id = canCid_1_1_2_canCid.get(this);
	var nodeDeleted = false;
	if(id && data[id]) {
		nodeDeleted = true;
		delete data[id];
	}
	if (removedDisposalMap[id]) {
		removedDisposalMap[id]();
		delete removedDisposalMap[id];
	}
	return nodeDeleted;
};

var setData = function(name, value) {
	var id = canCid_1_1_2_canCid(this);
	var store = data[id] || (data[id] = {});
	if (name !== undefined) {
		store[name] = value;
		var isNode = !!(this && typeof this.nodeType === 'number');
		if (isNode && !removedDisposalMap[id]) {
			var target = this;
			removedDisposalMap[id] = canDomMutate_1_0_4_canDomMutate.onNodeRemoval(target, function () {
				if (!target.ownerDocument.contains(target)) {
					setTimeout(function () {
						deleteNode(target);
					}, 13);
				}
			});
		}
	}
	return store;
};

/*
 * Core of domData that does not depend on mutationDocument
 * This is separated in order to prevent circular dependencies
 */
var domDataState = {
	_data: data,
	_removalDisposalMap: removedDisposalMap,

	getCid: function() {
		// TODO log warning! to use can-cid directly
		return canCid_1_1_2_canCid.get(this);
	},

	cid: function(){
		// TODO log warning!
		return canCid_1_1_2_canCid(this);
	},

	expando: canCid_1_1_2_canCid.domExpando,

	get: function(key) {
		var id = canCid_1_1_2_canCid.get(this),
			store = id && data[id];
		return key === undefined ? store : store && store[key];
	},

	set: setData,

	clean: function(prop) {
		var id = canCid_1_1_2_canCid.get(this);
		var itemData = data[id];
		if (itemData && itemData[prop]) {
			delete itemData[prop];
		}
		if(isEmptyObject(itemData)) {
			deleteNode.call(this);
		}
	},

	delete: deleteNode
};

if (canNamespace_1_0_0_canNamespace.domDataState) {
	throw new Error("You can't have two versions of can-dom-data-state, check your dependencies");
} else {
	module.exports = canNamespace_1_0_0_canNamespace.domDataState = domDataState;
}
});

var global$1 = global_1();







var formElements = {"INPUT": true, "TEXTAREA": true, "SELECT": true},
	// Used to convert values to strings.
	toString$2 = function(value){
		if(value == null) {
			return "";
		} else {
			return ""+value;
		}
	},
	isSVG = function(el){
		return el.namespaceURI === "http://www.w3.org/2000/svg";
	},
	truthy = function() { return true; },
	getSpecialTest = function(special){
		return (special && special.test) || truthy;
	},
	propProp = function(prop, obj){
		obj = obj || {};
		obj.get = function(){
			return this[prop];
		};
		obj.set = function(value){
			if(this[prop] !== value) {
				this[prop] = value;
			}
			return value;
		};
		return obj;
	},
	booleanProp = function(prop){
		return {
			isBoolean: true,
			set: function(value){
				if(prop in this) {
					this[prop] = value !== false;
				} else {
					canDomMutate_1_0_4_node.setAttribute.call(this, prop, "");
				}
			},
			remove: function(){
				this[prop] = false;
			}
		};
	},
	setupMO = function(el, callback){
		var attrMO = canDomDataState_1_0_1_canDomDataState.get.call(el, "attrMO");
		if(!attrMO) {
			var onMutation = function(){
				callback.call(el);
			};
			var MO = mutationObserver();
			if(MO) {
				var observer = new MO(onMutation);
				observer.observe(el, {
					childList: true,
					subtree: true
				});
				canDomDataState_1_0_1_canDomDataState.set.call(el, "attrMO", observer);
			} else {
				canDomDataState_1_0_1_canDomDataState.set.call(el, "attrMO", true);
				canDomDataState_1_0_1_canDomDataState.set.call(el, "canBindingCallback", {onMutation: onMutation});
			}
		}
	},
	_findOptionToSelect = function (parent, value) {
		var child = parent.firstChild;
		while (child) {
			if (child.nodeName === "OPTION" && value === child.value) {
				return child;
			}
			if (child.nodeName === "OPTGROUP") {
				var groupChild = _findOptionToSelect(child, value);
				if (groupChild) {
					return groupChild;
				}
			}
			child = child.nextSibling;
		}
	},
	setChildOptions = function(el, value){
		var option;
		if (value != null) {
			option = _findOptionToSelect(el, value);
		}
		if (option) {
			option.selected = true;
		} else {
			el.selectedIndex = -1;
		}
	},
	forEachOption = function (parent, fn) {
		var child = parent.firstChild;
		while (child) {
			if (child.nodeName === "OPTION") {
				fn(child);
			}
			if (child.nodeName === "OPTGROUP") {
				forEachOption(child, fn);
			}
			child = child.nextSibling;
		}
	},
	collectSelectedOptions = function (parent) {
		var selectedValues = [];
		forEachOption(parent, function (option) {
			if (option.selected) {
				selectedValues.push(option.value);
			}
		});
		return selectedValues;
	},
	markSelectedOptions = function (parent, values) {
		forEachOption(parent, function (option) {
			option.selected = values.indexOf(option.value) !== -1;
		});
	},
	// Create a handler, only once, that will set the child options any time
	// the select's value changes.
	setChildOptionsOnChange = function(select, aEL){
		var handler = canDomDataState_1_0_1_canDomDataState.get.call(select, "attrSetChildOptions");
		if(handler) {
			return Function.prototype;
		}
		handler = function(){
			setChildOptions(select, select.value);
		};
		canDomDataState_1_0_1_canDomDataState.set.call(select, "attrSetChildOptions", handler);
		aEL.call(select, "change", handler);
		return function(rEL){
			canDomDataState_1_0_1_canDomDataState.clean.call(select, "attrSetChildOptions");
			rEL.call(select, "change", handler);
		};
	},
	// cache of rules already calculated by `attr.getRule`
	behaviorRules = new Map([]),
	// # isPropWritable
	// check if a property is writable on an element by finding its property descriptor
	// on the element or its prototype chain
	isPropWritable = function(el, prop) {
		   var desc = Object.getOwnPropertyDescriptor(el.constructor.prototype, prop);

		   if (desc) {
				   return desc.writable || desc.set;
		   } else {
				   var proto = Object.getPrototypeOf(el);
				   if (proto) {
						   return isPropWritable(proto, prop);
				   }
		   }

		   return false;
	},
	// # cacheRule
	// add a rule to the rules Map so it does not need to be calculated more than once
	cacheRule = function(el, attrOrPropName, rule) {
		   var rulesForElementType;

		   rulesForElementType = behaviorRules.get(el.prototype);

		   if (!rulesForElementType) {
				   rulesForElementType = {};
				   behaviorRules.set(el.constructor, rulesForElementType);
		   }

		   rulesForElementType[attrOrPropName] = rule;

		   return rule;
	};

var specialAttributes = {
	checked: {
		get: function(){
			return this.checked;
		},
		set: function(val){
			// - `set( truthy )` => TRUE
			// - `set( "" )`     => TRUE
			// - `set()`         => TRUE
			// - `set(undefined)` => false.
			var notFalse = !!val || val === "" || arguments.length === 0;
			this.checked = notFalse;
			if(notFalse && this.type === "radio") {
				this.defaultChecked = true;
			}

			return val;
		},
		remove: function(){
			this.checked = false;
		},
		test: function(){
			return this.nodeName === "INPUT";
		}
	},
	"class": {
		get: function(){
			if(isSVG(this)) {
				return this.getAttribute("class");
			}
			return this.className;
		},
		set: function(val){
			val = val || "";

			if(isSVG(this)) {
				canDomMutate_1_0_4_node.setAttribute.call(this, "class", "" + val);
			} else {
				this.className = val;
			}
			return val;
		}
	},
	disabled: booleanProp("disabled"),
	focused: {
		get: function(){
			return this === document.activeElement;
		},
		set: function(val){
			var cur = attr.get(this, "focused");
			var docEl = this.ownerDocument.documentElement;
			var element = this;
			function focusTask() {
				if (val) {
					element.focus();
				} else {
					element.blur();
				}
			}
			if (cur !== val) {
				if (!docEl.contains(element)) {
					var insertionDisposal = canDomMutate_1_0_4_canDomMutate.onNodeInsertion(element, function () {
						insertionDisposal();
						focusTask();
					});
				} else {
					// THIS MIGHT NEED TO BE PUT IN THE MUTATE QUEUE
					focusTask();
				}
			}
			return !!val;
		},
		addEventListener: function(eventName, handler, aEL){
			aEL.call(this, "focus", handler);
			aEL.call(this, "blur", handler);
			return function(rEL){
				rEL.call(this, "focus", handler);
				rEL.call(this, "blur", handler);
			};
		},
		test: function(){
			return this.nodeName === "INPUT";
		}
	},
	"for": propProp("htmlFor"),
	innertext: propProp("innerText"),
	innerhtml: propProp("innerHTML"),
	innerHTML: propProp("innerHTML", {
		addEventListener: function(eventName, handler, aEL){
			var handlers = [];
			var el = this;
			["change", "blur"].forEach(function(eventName){
				var localHandler = function(){
					handler.apply(this, arguments);
				};
				canDomEvents_1_2_0_canDomEvents.addEventListener(el, eventName, localHandler);
				handlers.push([eventName, localHandler]);
			});

			return function(rEL){
				handlers.forEach( function(info){
					rEL.call(el, info[0], info[1]);
				});
			};
		}
	}),
	required: booleanProp("required"),
	readonly: booleanProp("readOnly"),
	selected: {
		get: function(){
			return this.selected;
		},
		set: function(val){
			val = !!val;
			canDomDataState_1_0_1_canDomDataState.set.call(this, "lastSetValue", val);
			return this.selected = val;
		},
		addEventListener: function(eventName, handler, aEL){
			var option = this;
			var select = this.parentNode;
			var lastVal = option.selected;
			var localHandler = function(changeEvent){
				var curVal = option.selected;
				lastVal = canDomDataState_1_0_1_canDomDataState.get.call(option, "lastSetValue") || lastVal;
				if(curVal !== lastVal) {
					lastVal = curVal;

					canDomEvents_1_2_0_canDomEvents.dispatch(option, eventName);
				}
			};

			var removeChangeHandler = setChildOptionsOnChange(select, aEL);
			canDomEvents_1_2_0_canDomEvents.addEventListener(select, "change", localHandler);
			aEL.call(option, eventName, handler);

			return function(rEL){
				removeChangeHandler(rEL);
				canDomEvents_1_2_0_canDomEvents.removeEventListener(select, "change", localHandler);
				rEL.call(option, eventName, handler);
			};
		},
		test: function(){
			return this.nodeName === "OPTION" && this.parentNode &&
				this.parentNode.nodeName === "SELECT";
		}
	},
	style: {
		set: (function () {
			var el = global$1.document && document$1().createElement("div");
			if ( el && el.style && ("cssText" in el.style) ) {
				return function (val) {
					return this.style.cssText = (val || "");
				};
			} else {
				return function (val) {
					return canDomMutate_1_0_4_node.setAttribute.call(this, "style", val);
				};
			}
		})()
	},
	textcontent: propProp("textContent"),
	value: {
		get: function(){
			var value = this.value;
			if(this.nodeName === "SELECT") {
				if(("selectedIndex" in this) && this.selectedIndex === -1) {
					value = undefined;
				}
			}
			return value;
		},
		set: function(value){
			var nodeName = this.nodeName.toLowerCase();
			if(nodeName === "input") {
				// Do some input types support non string values?
				value = toString$2(value);
			}
			if(this.value !== value || nodeName === "option") {
				this.value = value;
			}
			if (nodeName === "input" || nodeName === "textarea") {
				this.defaultValue = value;
			}
			if(nodeName === "select") {
				canDomDataState_1_0_1_canDomDataState.set.call(this, "attrValueLastVal", value);
				//If it's null then special case
				setChildOptions(this, value === null ? value : this.value);

				// If not in the document reset the value when inserted.
				var docEl = this.ownerDocument.documentElement;
				if(!docEl.contains(this)) {
					var select = this;
					var insertionDisposal = canDomMutate_1_0_4_canDomMutate.onNodeInsertion(select, function () {
						insertionDisposal();
						setChildOptions(select, value === null ? value : select.value);
					});
				}

				// MO handler is only set up **ONCE**
				setupMO(this, function(){
					var value = canDomDataState_1_0_1_canDomDataState.get.call(this, "attrValueLastVal");
					attr.set(this, "value", value);
					canDomEvents_1_2_0_canDomEvents.dispatch(this, "change");
				});
			}
			return value;
		},
		test: function(){
			return formElements[this.nodeName];
		}
	},
	values: {
		get: function(){
			return collectSelectedOptions(this);
		},
		set: function(values){
			values = values || [];

			// set new DOM state
			markSelectedOptions(this, values);

			// store new DOM state
			canDomDataState_1_0_1_canDomDataState.set.call(this, "stickyValues", attr.get(this,"values") );

			// MO handler is only set up **ONCE**
			// TODO: should this be moved into addEventListener?
			setupMO(this, function(){

				// Get the previous sticky state
				var previousValues = canDomDataState_1_0_1_canDomDataState.get.call(this,
					"stickyValues");

				// Set DOM to previous sticky state
				attr.set(this, "values", previousValues);

				// Get the new result after trying to maintain the sticky state
				var currentValues = canDomDataState_1_0_1_canDomDataState.get.call(this,
					"stickyValues");

				// If there are changes, trigger a `values` event.
				var changes = list(previousValues.slice().sort(),
					currentValues.slice().sort());

				if (changes.length) {
					canDomEvents_1_2_0_canDomEvents.dispatch(this, "values");
				}
			});

			return values;
		},
		addEventListener: function(eventName, handler, aEL){
			var localHandler = function(){
				canDomEvents_1_2_0_canDomEvents.dispatch(this, "values");
			};

			canDomEvents_1_2_0_canDomEvents.addEventListener(this, "change", localHandler);
			aEL.call(this, eventName, handler);

			return function(rEL){
				canDomEvents_1_2_0_canDomEvents.removeEventListener(this, "change", localHandler);
				rEL.call(this, eventName, handler);
			};
		}
	}
};

var attr = {
	// cached rules (stored on `attr` for testing purposes)
	rules: behaviorRules,

	// special attribute behaviors (stored on `attr` for testing purposes)
	specialAttributes: specialAttributes,

	// # attr.getRule
	//
	// get the behavior rule for an attribute or property on an element
	//
	// Rule precendence:
	//   1. "special" behaviors - use the special behavior getter/setter
	//   2. writable properties - read and write as a property
	//   3. all others - read and write as an attribute
	//
	// Once rule is determined it will be cached for all elements of the same type
	// so that it does not need to be calculated again
	getRule: function(el, attrOrPropName) {
		var special = specialAttributes[attrOrPropName];
		// always use "special" if available
		// these are not cached since they would have to be cached separately
		// for each element type and it is faster to just look up in the
		// specialAttributes object
		if (special) {
			return special;
		}

		// next use rules cached in a previous call to getRule
		var rulesForElementType = behaviorRules.get(el.constructor);
		var cached = rulesForElementType && rulesForElementType[attrOrPropName];

		if (cached) {
			return cached;
		}

		// if the element doesn't have a property of this name, it must be an attribute
		if (!(attrOrPropName in el)) {
			return this.attribute(attrOrPropName);
		}

		// if there is a property, check if it is writable
		var newRule = isPropWritable(el, attrOrPropName) ?
			this.property(attrOrPropName) :
			this.attribute(attrOrPropName);

		// cache the new rule and return it
		return cacheRule(el, attrOrPropName, newRule);
	},

	attribute: function(attrName) {
		return {
			get: function() {
				return this.getAttribute(attrName);
			},
			set: function(val) {
				canDomMutate_1_0_4_node.setAttribute.call(this, attrName, val);
			}
		};
	},

	property: function(propName) {
		return {
			get: function() {
				return this[propName];
			},
			set: function(val) {
				this[propName] = val;
			}
		};
	},

	findSpecialListener: function(attributeName) {
		return specialAttributes[attributeName] && specialAttributes[attributeName].addEventListener;
	},

	setAttrOrProp: function(el, attrName, val){
		return this.set(el, attrName, val);
	},
	// ## attr.set
	// Set the value an attribute on an element.
	set: function (el, attrName, val) {
		var rule = this.getRule(el, attrName);
		var setter = rule && rule.set;

		if (setter) {
			return setter.call(el, val);
		}
	},
	// ## attr.get
	// Gets the value of an attribute or property.
	// First checks if the property is an `specialAttributes` and if so calls the special getter.
	// Then checks if the attribute or property is a property on the element.
	// Otherwise uses `getAttribute` to retrieve the value.
	get: function (el, attrName) {
		var rule = this.getRule(el, attrName);
		var getter = rule && rule.get;

		if (getter) {
			return rule.test ?
				rule.test.call(el) && getter.call(el) :
				getter.call(el);
		}
	},
	// ## attr.remove
	// Removes an attribute from an element. First checks specialAttributes to see if the attribute is special and has a setter. If so calls the setter with `undefined`. Otherwise `removeAttribute` is used.
	// If the attribute previously had a value and the browser doesn't support MutationObservers we then trigger an "attributes" event.
	remove: function (el, attrName) {
		attrName = attrName.toLowerCase();
		var special = specialAttributes[attrName];
		var setter = special && special.set;
		var remover = special && special.remove;
		var test = getSpecialTest(special);

		if(typeof remover === "function" && test.call(el)) {
			remover.call(el);
		} else if(typeof setter === "function" && test.call(el)) {
			setter.call(el, undefined);
		} else {
			canDomMutate_1_0_4_node.removeAttribute.call(el, attrName);
		}
	}
};

var canAttributeObservable_0_3_1_behaviors = attr;

/**
 * @function can-view-live.attr attr
 * @parent can-view-live
 *
 * @signature `live.attr(el, attributeName, observable)`
 *
 * Keep an attribute live to a [can-reflect]-ed observable.
 *
 * ```js
 * var div = document.createElement('div');
 * var value = new SimpleObservable("foo bar");
 * live.attr(div,"class", value);
 * ```
 *
 * @param {HTMLElement} el The element whos attribute will be kept live.
 * @param {String} attributeName The attribute name.
 * @param {Object} observable An observable value.
 *
 * @body
 *
 * ## How it works
 *
 * This listens for the changes in the observable and uses those changes to
 * set the specified attribute.
 */
core.attr = function(el, attributeName, compute) {
	function liveUpdateAttr(newVal) {
		canQueues_1_1_0_canQueues.domUIQueue.enqueue(canAttributeObservable_0_3_1_behaviors.set, canAttributeObservable_0_3_1_behaviors, [el, attributeName, newVal]);
	}
	//!steal-remove-start
	// register that the handler changes the parent element
	canReflect_1_16_7_canReflect.assignSymbols(liveUpdateAttr, {
		"can.getChangesDependencyRecord": function() {
			return {
				valueDependencies: new Set( [ el ] )
			};
		}
	});
	Object.defineProperty(liveUpdateAttr, "name", {
		value: "live.attr update::"+canReflect_1_16_7_canReflect.getName(compute),
	});
	//!steal-remove-end

	// Bind a single attribute on an element to a compute
	core.listen(el, compute, liveUpdateAttr);

	// do initial set of attribute as well
	canAttributeObservable_0_3_1_behaviors.set(el, attributeName, canReflect_1_16_7_canReflect.getValue(compute));
};

// This provides live binding for stache attributes.







core.attrs = function(el, compute, scope, options) {

	if (!canReflect_1_16_7_canReflect.isObservableLike(compute)) {
		// Non-live case (`compute` was not a compute):
		//  set all attributes on the element and don't
		//  worry about setting up live binding since there
		//  is not compute to bind on.
		var attrs = core.getAttributeParts(compute);
		for (var name in attrs) {
			canDomMutate_1_0_4_node.setAttribute.call(el, name, attrs[name]);
		}
		return;
	}

	// last set of attributes
	var oldAttrs = {};

	// set up a callback for handling changes when the compute
	// changes
	function liveAttrsUpdate(newVal) {
		var newAttrs = core.getAttributeParts(newVal),
			name;
		for (name in newAttrs) {
			var newValue = newAttrs[name],
				// `oldAttrs` was set on the last run of setAttrs in this context
				//  (for this element and compute)
				oldValue = oldAttrs[name];
			// Only fire a callback
			//  if the value of the attribute has changed
			if (newValue !== oldValue) {
				// set on DOM attributes (dispatches an "attributes" event as well)
				canDomMutate_1_0_4_node.setAttribute.call(el, name, newValue);
				// get registered callback for attribute name and fire
				var callback = canViewCallbacks_4_1_2_canViewCallbacks.attr(name);
				if (callback) {
					callback(el, {
						attributeName: name,
						scope: scope,
						options: options
					});
				}
			}
			// remove key found in new attrs from old attrs
			delete oldAttrs[name];
		}
		// any attrs left at this point are not set on the element now,
		// so remove them.
		for (name in oldAttrs) {
			canDomMutate_1_0_4_node.removeAttribute.call(el, name);
		}
		oldAttrs = newAttrs;
	}

	//!steal-remove-start
	// register that the handler changes the parent element
	canReflect_1_16_7_canReflect.assignSymbols(liveAttrsUpdate, {
		"can.getChangesDependencyRecord": function() {
			return {
				valueDependencies: new Set( [ el ] )
			};
		}
	});
	
	Object.defineProperty(liveAttrsUpdate, "name", {
		value: "live.attrs update::"+canReflect_1_16_7_canReflect.getName(compute),
	});
	canReflectDependencies_1_0_2_canReflectDependencies.addMutatedBy(el, compute);
	//!steal-remove-end

	// set attributes on any change to the compute
	canReflect_1_16_7_canReflect.onValue(compute, liveAttrsUpdate,"domUI");

	var removalDisposal;
	var teardownHandler = function() {
		canReflect_1_16_7_canReflect.offValue(compute, liveAttrsUpdate,"domUI");
		if (removalDisposal) {
			removalDisposal();
			removalDisposal = undefined;
		}

		//!steal-remove-start
		canReflectDependencies_1_0_2_canReflectDependencies.deleteMutatedBy(el, compute);
		//!steal-remove-end
	};
	// unbind on element removal
	removalDisposal = canDomMutate_1_0_4_canDomMutate.onNodeRemoval(el, function () {
		if (!el.ownerDocument.contains(el)) {
			teardownHandler();
		}
	});

	// set up a current attribute set and assign to oldAttrs
	liveAttrsUpdate(canReflect_1_16_7_canReflect.getValue(compute));
};

function updateNodeList(oldNodes, nodes, frag, nodeListUpdatedByFn) {
	if(nodes.isUnregistered !== true) {
		if(!nodeListUpdatedByFn) {
			canViewNodelist_4_2_0_canViewNodelist.update(nodes, canChildNodes_1_0_0_canChildNodes(frag), oldNodes);
		}
		canViewNodelist_4_2_0_canViewNodelist.replace(oldNodes, frag);
	}
}

/**
 * @function can-view-live.html html
 * @parent can-view-live
 * @release 2.0.4
 *
 * Live binds a compute's value to a collection of elements.
 *
 * @signature `live.html(el, compute, [parentNode])`
 *
 * `live.html` is used to setup incremental live-binding on a block of html.
 *
 * ```js
 * // a compute that changes its list
 * var greeting = compute(function(){
 *   return "Welcome <i>"+me.attr("name")+"</i>"
 * });
 *
 * var placeholder = document.createTextNode(" ");
 * $("#greeting").append(placeholder);
 *
 * live.html(placeholder, greeting);
 * ```
 *
 * @param {HTMLElement} el An html element to replace with the live-section.
 *
 * @param {can.compute} compute A [can.compute] whose value is HTML.
 *
 * @param {HTMLElement} [parentNode] An overwritable parentNode if `el`'s parent is
 * a documentFragment.
 *
 *
 */
core.html = function(el, compute, parentNode, nodeList) {
	var data,
		makeAndPut,
		nodes;

	var meta = {reasonLog: "live.html replace::"+canReflect_1_16_7_canReflect.getName(compute)};
	// prefer to manipulate el's actual parent over the supplied parent
	parentNode = core.getParentNode(el, parentNode);

	function liveHTMLUpdateHTML(newVal) {
		// the attachment point for the nodelist
		var attached = canViewNodelist_4_2_0_canViewNodelist.first(nodes).parentNode;
		// update the nodes in the DOM with the new rendered value
		if (attached) {
			makeAndPut(newVal, true);
		}
		var pn = canViewNodelist_4_2_0_canViewNodelist.first(nodes).parentNode;
		data.teardownCheck(pn);
	}


	//!steal-remove-start
	// register that the handler changes the parent element
	canReflect_1_16_7_canReflect.assignSymbols(liveHTMLUpdateHTML, {
		"can.getChangesDependencyRecord": function() {
			return {
				valueDependencies: new Set( [ parentNode ] )
			};
		}
	});
	
	Object.defineProperty(liveHTMLUpdateHTML, "name", {
		value: "live.html update::"+canReflect_1_16_7_canReflect.getName(compute),
	});
	//!steal-remove-end


	data = core.listen(parentNode, compute, liveHTMLUpdateHTML);

	// Nodes registered to the live operation, either a list of nodes or a single element
	nodes = nodeList || [el];
	makeAndPut = function(val, useQueue) {
		// ##### makeandput
		// Receives the compute output (must be some DOM representation or a function)
		var isFunction = typeof val === "function",
			// translate val into a document fragment if it's DOM-like
			frag = canFragment_1_0_1_canFragment(isFunction ? "" : val);

		// Add a placeholder textNode if necessary.
		core.addTextNodeIfNoChildren(frag);

		// Mark each node as belonging to the node list.

		var oldNodes;
		// DOM replace old nodes with new frag (which might contain some old nodes)
		if(useQueue === true) {
			// unregister all children immediately
			oldNodes = canViewNodelist_4_2_0_canViewNodelist.unregisterChildren(nodes, true);

			var nodeListUpdatedByFn = false;
			// allow
			if (isFunction) {
				val(frag.firstChild);
				// see if nodes has already been updated
				nodeListUpdatedByFn = canViewNodelist_4_2_0_canViewNodelist.first(nodes) === frag.firstChild;
			}
			canQueues_1_1_0_canQueues.domUIQueue.enqueue(updateNodeList, null, [oldNodes, nodes, frag, nodeListUpdatedByFn], meta);
		} else {
			// this is initialization, update right away.
			oldNodes = canViewNodelist_4_2_0_canViewNodelist.update(nodes, canChildNodes_1_0_0_canChildNodes(frag));
			if (isFunction) {
				val(frag.firstChild);
			}
			canViewNodelist_4_2_0_canViewNodelist.replace(oldNodes, frag);
		}

	};

	data.nodeList = nodes;

	// register the span so nodeLists knows the parentNodeList
	if (!nodeList) {
		canViewNodelist_4_2_0_canViewNodelist.register(nodes, data.teardownCheck);
	} else {
		nodeList.unregistered = data.teardownCheck;
	}
	// Finally give the subtree an initial value
	makeAndPut(canReflect_1_16_7_canReflect.getValue(compute));
};

function SetObservable(initialValue, setter) {
	this.setter = setter;

	canSimpleObservable_2_0_4_canSimpleObservable.call(this, initialValue);
}

SetObservable.prototype = Object.create(canSimpleObservable_2_0_4_canSimpleObservable.prototype);
SetObservable.prototype.constructor = SetObservable;
SetObservable.prototype.set = function(newVal) {
	this.setter(newVal);
};


canReflect_1_16_7_canReflect.assignSymbols(SetObservable.prototype, {
	"can.setValue": SetObservable.prototype.set
});

var setObservable = SetObservable;

var onValueSymbol$2 = canSymbol_1_6_1_canSymbol.for("can.onValue"),
	offValueSymbol$1 = canSymbol_1_6_1_canSymbol.for("can.offValue");
var onPatchesSymbol$1 = canSymbol_1_6_1_canSymbol.for("can.onPatches");
var offPatchesSymbol = canSymbol_1_6_1_canSymbol.for("can.offPatches");

// Patcher takes a observable that might wrap a list type.
// When the observable changes, it will diff, and emit patches,
// and if the list emits patches, it will emit those too.
// It is expected that only `domUI` handlers are registered.
/*
var observable = new SimpleObservable( new DefineList([ "a", "b", "c" ]) )
var patcher = new Patcher(observable)
canReflect.onPatches( patcher,function(patches){
  console.log(patches) // a patch removing c, then a
})
var newList = new DefineList(["a","b"]);
observable.set(newList);
newList.unshift("X");
[
    {type: "splice", index: 2, deleteCount: 1}
]
var patches2 = [
    {type: "splice", index: 0, deleteCount: 0, inserted: ["X"]}
]
 */
var Patcher = function(observableOrList, priority) {
	// stores listeners for this patcher
	this.handlers = new canKeyTree_1_0_2_canKeyTree([Object, Array], {
		// call setup when the first handler is bound
		onFirst: this.setup.bind(this),
		// call teardown when the last handler is removed
		onEmpty: this.teardown.bind(this)
	});

	// save this value observable or patch emitter (list)
	this.observableOrList = observableOrList;
	// if we were passed an observable value that we need to read its array for changes
	this.isObservableValue = canReflect_1_16_7_canReflect.isValueLike(this.observableOrList) || canReflect_1_16_7_canReflect.isObservableLike(this.observableOrList);
	if(this.isObservableValue) {
	    this.priority = canReflect_1_16_7_canReflect.getPriority(observableOrList);
	} else {
	    this.priority = priority || 0;
	}
	this.onList = this.onList.bind(this);
	this.onPatchesNotify = this.onPatchesNotify.bind(this);
	// needs to be unique so the derive queue doesn't only add one.
	this.onPatchesDerive = this.onPatchesDerive.bind(this);

	// stores patches that have happened between notification and
	// when we queue the  `onPatches` handlers in the `domUI` queue
	this.patches = [];


	//!steal-remove-start
	Object.defineProperty(this.onList, "name", {
		value: "live.list new list::"+canReflect_1_16_7_canReflect.getName(observableOrList),
	});
	Object.defineProperty(this.onPatchesNotify, "name", {
		value: "live.list notify::"+canReflect_1_16_7_canReflect.getName(observableOrList),
	});
	Object.defineProperty(this.onPatchesDerive, "name", {
		value: "live.list derive::"+canReflect_1_16_7_canReflect.getName(observableOrList),
	});
	//!steal-remove-end
};


Patcher.prototype = {
	constructor: Patcher,
	setup: function() {
		if (this.observableOrList[onValueSymbol$2]) {
			// if we have an observable value, listen to when it changes to get a
			// new list.
			canReflect_1_16_7_canReflect.onValue(this.observableOrList, this.onList, "notify");
			// listen on the current value (which shoudl be a list) if there is one
			this.setupList(canReflect_1_16_7_canReflect.getValue(this.observableOrList));
		} else {
			this.setupList(this.observableOrList);
		}
	},
	teardown: function() {
		if (this.observableOrList[offValueSymbol$1]) {
			canReflect_1_16_7_canReflect.offValue(this.observableOrList, this.onList, "notify");
		}
	},
	// listen to the list for patches
	setupList: function(list$$1) {
		this.currentList = list$$1;
		if (list$$1 && list$$1[onPatchesSymbol$1]) {
			// If observable, set up bindings on list changes
			list$$1[onPatchesSymbol$1](this.onPatchesNotify, "notify");
		}
	},
	// when the list changes, teardown the old list bindings
	// and setup the new list
	onList: function onList(newList) {
		var current = this.currentList || [];
		newList = newList || [];
		if (current[offPatchesSymbol]) {
			current[offPatchesSymbol](this.onPatchesNotify, "notify");
		}
		var patches = list(current, newList);
		this.currentList = newList;
		this.onPatchesNotify(patches);
		if (newList[onPatchesSymbol$1]) {
			// If observable, set up bindings on list changes
			newList[onPatchesSymbol$1](this.onPatchesNotify, "notify");
		}
	},
	// This is when we get notified of patches on the underlying list.
	// Save the patches and queue up a `derive` task that will
	// call `domUI` updates.
	onPatchesNotify: function onPatchesNotify(patches) {
		// we are going to collect all patches
		this.patches.push.apply(this.patches, patches);
		// TODO: share priority
		canQueues_1_1_0_canQueues.deriveQueue.enqueue(this.onPatchesDerive, this, [], {
			priority: this.priority
		});
	},
	// Let handlers (which should only be registered in `domUI`) know about patches
	// that they can apply.
	onPatchesDerive: function onPatchesDerive() {
		var patches = this.patches;
		this.patches = [];
		canQueues_1_1_0_canQueues.enqueueByQueue(this.handlers.getNode([]), this.currentList, [patches, this.currentList], null,["Apply patches", patches]);
	}
};

canReflect_1_16_7_canReflect.assignSymbols(Patcher.prototype, {
	"can.onPatches": function(handler, queue) {
		this.handlers.add([queue || "mutate", handler]);
	},
	"can.offPatches": function(handler, queue) {
		this.handlers.delete([queue || "mutate", handler]);
	}
});

var patcher = Patcher;

var splice$2 = [].splice;

// #### renderAndAddToNodeLists
// a helper function that renders something and adds its nodeLists to newNodeLists
// in the right way for stache.
var renderAndAddToNodeLists = function(newNodeLists, parentNodeList, render, context, args) {
		var itemNodeList = [];

		if (parentNodeList) {
			// With a supplied parent list, "directly" register the new nodeList
			//  as a child.
			canViewNodelist_4_2_0_canViewNodelist.register(itemNodeList, null, true, true);
			itemNodeList.parentList = parentNodeList;
			itemNodeList.expression = "#each SUBEXPRESSION";
		}

		// call the renderer, passing in the new nodeList as the last argument
		var itemHTML = render.apply(context, args.concat([itemNodeList])),
			// and put the output into a document fragment
			itemFrag = canFragment_1_0_1_canFragment(itemHTML);

		// get all the direct children of the frag
		var children = canReflect_1_16_7_canReflect.toArray(canChildNodes_1_0_0_canChildNodes(itemFrag));
		if (parentNodeList) {
			// if a parent list was supplied, children of the frag become the
			//  child nodeList items.
			canViewNodelist_4_2_0_canViewNodelist.update(itemNodeList, children);
			newNodeLists.push(itemNodeList);
		} else {
			// If no parent nodeList, register the new array of frag children as a nodeList
			//  and push into the nodeLists
			newNodeLists.push(canViewNodelist_4_2_0_canViewNodelist.register(children));
		}
		return itemFrag;
	},
	// #### removeFromNodeList
	// a splicing helper for nodeLists, which removes sublists, including unregistering,
	//  for a contiguous slice of the master list.
	removeFromNodeList = function(masterNodeList, index, length) {
		var removedMappings = masterNodeList.splice(index + 1, length),
			itemsToRemove = [];
		removedMappings.forEach( function(nodeList) {

			// Unregister to free up event bindings.
			var nodesToRemove = canViewNodelist_4_2_0_canViewNodelist.unregister(nodeList);

			// add items that we will remove all at once
			[].push.apply(itemsToRemove, nodesToRemove);
		});
		return itemsToRemove;
	};




var onPatchesSymbol$2 = canSymbol_1_6_1_canSymbol.for("can.onPatches");
var offPatchesSymbol$1 = canSymbol_1_6_1_canSymbol.for("can.offPatches");

function ListDOMPatcher(el, compute, render, context, parentNode, nodeList, falseyRender) {
	this.patcher = new patcher(compute);

	// argument cleanup
	parentNode = core.getParentNode(el, parentNode);

	// function callback binding

	// argument saving -----
	this.value = compute;
	this.render = render;
	this.context = context;
	this.parentNode = parentNode;
	this.falseyRender = falseyRender;
	// A nodeList of all elements this live-list manages.
	// This is here so that if this live list is within another section
	// that section is able to remove the items in this list.
	this.masterNodeList = nodeList || canViewNodelist_4_2_0_canViewNodelist.register([el], null, true);
	this.placeholder = el;

	// A mapping of items to their indices
	this.indexMap = [];

	this.isValueLike = canReflect_1_16_7_canReflect.isValueLike(this.value);
	this.isObservableLike = canReflect_1_16_7_canReflect.isObservableLike(this.value);

	// Setup binding and teardown to add and remove events
	this.onPatches = this.onPatches.bind(this);
	var data = this.data = core.setup(
		parentNode,
		this.setupValueBinding.bind(this),
		this.teardownValueBinding.bind(this)
	);

	this.masterNodeList.unregistered = function() {
		data.teardownCheck();
		//isTornDown = true;
	};

	//!steal-remove-start
	Object.defineProperty(this.onPatches, "name", {
		value: "live.list update::"+canReflect_1_16_7_canReflect.getName(compute),
	});
	//!steal-remove-end
}

var onPatchesSymbol$2 = canSymbol_1_6_1_canSymbol.for("can.onPatches");
var offPatchesSymbol$1 = canSymbol_1_6_1_canSymbol.for("can.offPatches");

ListDOMPatcher.prototype = {
	setupValueBinding: function() {
		this.patcher[onPatchesSymbol$2](this.onPatches, "domUI");
		if (this.patcher.currentList && this.patcher.currentList.length) {
			this.onPatches([{
				insert: this.patcher.currentList,
				index: 0,
				deleteCount: 0
			}]);
		} else {
			this.addFalseyIfEmpty();
		}
		//!steal-remove-start
		canReflectDependencies_1_0_2_canReflectDependencies.addMutatedBy(this.parentNode, this.patcher.observableOrList);
		//!steal-remove-end
	},
	teardownValueBinding: function() {
		this.patcher[offPatchesSymbol$1](this.onPatches, "domUI");
		this.exit = true;
		this.remove({
			length: this.patcher.currentList.length
		}, 0, true);
		//!steal-remove-start
		canReflectDependencies_1_0_2_canReflectDependencies.deleteMutatedBy(this.parentNode, this.patcher.observableOrList);
		//!steal-remove-end
	},
	onPatches: function ListDOMPatcher_onPatches(patches) {
		if (this.exit) {
			return;
		}
		for (var i = 0, patchLen = patches.length; i < patchLen; i++) {
			var patch = patches[i];
			if (patch.type === "move") {
				this.move(patch.toIndex, patch.fromIndex);
			} else {
				if (patch.deleteCount) {
					// Remove any items scheduled for deletion from the patch.
					this.remove({
						length: patch.deleteCount
					}, patch.index, true);
				}
				if (patch.insert && patch.insert.length) {
					// Insert any new items at the index
					this.add(patch.insert, patch.index);
				}
			}

		}
	},
	add: function(items, index) {
		//if (!afterPreviousEvents) {
		//	return;
		//}
		// Collect new html and mappings
		var frag = this.placeholder.ownerDocument.createDocumentFragment(),
			newNodeLists = [],
			newIndicies = [],
			masterNodeList = this.masterNodeList,
			render = this.render,
			context = this.context;
		// For each new item,
		items.forEach( function(item, key) {

			var itemIndex = new canSimpleObservable_2_0_4_canSimpleObservable(key + index),
				itemCompute = new setObservable(item, function(newVal) {
					canReflect_1_16_7_canReflect.setKeyValue(this.patcher.currentList, itemIndex.get(), newVal );
				}.bind(this)),
				itemFrag = renderAndAddToNodeLists(newNodeLists, masterNodeList, render, context, [itemCompute, itemIndex]);

			// Hookup the fragment (which sets up child live-bindings) and
			// add it to the collection of all added elements.
			frag.appendChild(itemFrag);
			// track indicies;
			newIndicies.push(itemIndex);
		}, this);
		// The position of elements is always after the initial text placeholder node
		var masterListIndex = index + 1;

		// remove falsey if there's something there
		if (!this.indexMap.length) {
			// remove all leftover things
			var falseyItemsToRemove = removeFromNodeList(masterNodeList, 0, masterNodeList.length - 1);
			canViewNodelist_4_2_0_canViewNodelist.remove(falseyItemsToRemove);
		}

		// Check if we are adding items at the end
		if (!masterNodeList[masterListIndex]) {
			canViewNodelist_4_2_0_canViewNodelist.after(masterListIndex === 1 ? [this.placeholder] : [canViewNodelist_4_2_0_canViewNodelist.last(this.masterNodeList[masterListIndex - 1])], frag);
		} else {
			// Add elements before the next index's first element.
			var el = canViewNodelist_4_2_0_canViewNodelist.first(masterNodeList[masterListIndex]);
			canDomMutate_1_0_4_node.insertBefore.call(el.parentNode, frag, el);
		}
		splice$2.apply(this.masterNodeList, [
			masterListIndex,
			0
		].concat(newNodeLists));

		// update indices after insert point
		splice$2.apply(this.indexMap, [
			index,
			0
		].concat(newIndicies));

		for (var i = index + newIndicies.length, len = this.indexMap.length; i < len; i++) {
			this.indexMap[i].set(i);
		}
	},
	remove: function(items, index) {
		//if (!afterPreviousEvents) {
		//	return;
		//}

		// If this is because an element was removed, we should
		// check to make sure the live elements are still in the page.
		// If we did this during a teardown, it would cause an infinite loop.
		//if (!duringTeardown && this.data.teardownCheck(this.placeholder.parentNode)) {
		//	return;
		//}
		if (index < 0) {
			index = this.indexMap.length + index;
		}
		var itemsToRemove = removeFromNodeList(this.masterNodeList, index, items.length);
		var indexMap = this.indexMap;
		// update indices after remove point
		indexMap.splice(index, items.length);
		for (var i = index, len = indexMap.length; i < len; i++) {
			indexMap[i].set(i);
		}

		// don't remove elements during teardown.  Something else will probably be doing that.
		if (!this.exit) {
			// adds the falsey section if the list is empty
			this.addFalseyIfEmpty();
			canViewNodelist_4_2_0_canViewNodelist.remove(itemsToRemove);
		} else {
			canViewNodelist_4_2_0_canViewNodelist.unregister(this.masterNodeList);
		}
	},
	// #### addFalseyIfEmpty
	// Add the results of redering the "falsey" or inverse case render to the
	// master nodeList and the DOM if the live list is empty
	addFalseyIfEmpty: function() {
		if (this.falseyRender && this.indexMap.length === 0) {
			// If there are no items ... we should render the falsey template
			var falseyNodeLists = [];
			var falseyFrag = renderAndAddToNodeLists(falseyNodeLists, this.masterNodeList, this.falseyRender, this.currentList, [this.currentList]);

			// put the frag after the reference element in the associated nodeList
			canViewNodelist_4_2_0_canViewNodelist.after([this.masterNodeList[0]], falseyFrag);
			// and push the first element onto the master list
			this.masterNodeList.push(falseyNodeLists[0]);
		}
	},
	move: function move(newIndex, currentIndex) {
		//if (!afterPreviousEvents) {
		//	return;
		//}
		// The position of elements is always after the initial text
		// placeholder node
		newIndex = newIndex + 1;
		currentIndex = currentIndex + 1;
		var masterNodeList = this.masterNodeList,
			indexMap = this.indexMap;
		var referenceNodeList = masterNodeList[newIndex];
		var movedElements = canFragment_1_0_1_canFragment(canViewNodelist_4_2_0_canViewNodelist.flatten(masterNodeList[currentIndex]));
		var referenceElement;

		// If we're moving forward in the list, we want to be placed before
		// the item AFTER the target index since removing the item from
		// the currentIndex drops the referenceItem's index. If there is no
		// nextSibling, insertBefore acts like appendChild.
		if (currentIndex < newIndex) {
			referenceElement = canViewNodelist_4_2_0_canViewNodelist.last(referenceNodeList).nextSibling;
		} else {
			referenceElement = canViewNodelist_4_2_0_canViewNodelist.first(referenceNodeList);
		}

		var parentNode = masterNodeList[0].parentNode;

		// Move the DOM nodes into the proper location
		parentNode.insertBefore(movedElements, referenceElement);

		// Now, do the same for the masterNodeList. We need to keep it
		// in sync with the DOM.

		// Save a reference to the "node" that we're manually moving
		var temp = masterNodeList[currentIndex];

		// Remove the movedItem from the masterNodeList
		[].splice.apply(masterNodeList, [currentIndex, 1]);

		// Move the movedItem to the correct index in the masterNodeList
		[].splice.apply(masterNodeList, [newIndex, 0, temp]);

		// Convert back to a zero-based array index
		newIndex = newIndex - 1;
		currentIndex = currentIndex - 1;

		// Grab the index compute from the `indexMap`
		var indexCompute = indexMap[currentIndex];

		// Remove the index compute from the `indexMap`
		[].splice.apply(indexMap, [currentIndex, 1]);

		// Move the index compute to the correct index in the `indexMap`
		[].splice.apply(indexMap, [newIndex, 0, indexCompute]);

		var i = Math.min(currentIndex, newIndex);
		var len = indexMap.length;

		for (len; i < len; i++) {
			// set each compute to have its current index in the map as its value
			indexMap[i].set(i);
		}
	},
	set: function(newVal, index) {
		this.remove({
			length: 1
		}, index, true);
		this.add([newVal], index);
	}
};



/**
 * @function can-view-live.list list
 * @parent can-view-live
 * @release 2.0.4
 *
 * @signature `live.list(el, list, render, context, [parentNode])`
 *
 * Live binds a compute's list incrementally.
 *
 * ```js
 * // a compute that change's it's list
 * var todos = compute(function(){
 *   return new Todo.List({page: can.route.attr("page")})
 * })
 *
 * var placeholder = document.createTextNode(" ");
 * $("ul#todos").append(placeholder);
 *
 * can.view.live.list(
 *   placeholder,
 *   todos,
 *   function(todo, index){
 *     return "<li>"+todo.attr("name")+"</li>"
 *   });
 * ```
 *
 * @param {HTMLElement} el An html element to replace with the live-section.
 *
 * @param {Object} list An observable value or list type. If an observable value, it should contain
 * a falsey value or a list type.
 *
 * @param {function(this:*,*,index):String} render(index, index) A function that when called with
 * the incremental item to render and the index of the item in the list.
 *
 * @param {Object} context The `this` the `render` function will be called with.
 *
 * @param {HTMLElement} [parentNode] An overwritable parentNode if `el`'s parent is
 * a documentFragment.
 *
 * @body
 *
 * ## How it works
 *
 * If `list` is an observable value, `live.list` listens to changes in in that
 * observable value.  It will generally change from one list type (often a list type that implements `onPatches`)
 * to another.  When the value changes, a diff will be performed and the DOM updated.  Also, `live.list`
 * will listen to `.onPatches` on the new list and apply any patches emitted from it.
 *
 *
 */
core.list = function(el, list, render, context, parentNode, nodeList, falseyRender) {
	if (el.nodeType !== Node.TEXT_NODE) {
		var textNode;
		if (!nodeList) {
			textNode = document.createTextNode("");
			el.parentNode.replaceChild(textNode, el);
			el = textNode;
		} else {
			textNode = document.createTextNode("");
			canViewNodelist_4_2_0_canViewNodelist.replace(nodeList, textNode);
			canViewNodelist_4_2_0_canViewNodelist.update(nodeList, [textNode]);
			el = textNode;
		}
	}
	new ListDOMPatcher(el, list, render, context, parentNode, nodeList, falseyRender);
};

/**
 * @function can-view-live.text text
 * @parent can-view-live
 * @release 2.0.4
 *
 * @signature `live.text(el, compute, [parentNode], [nodeList])`
 *
 * Replaces one element with some content while keeping [can-view-live.nodeLists nodeLists] data correct.
 */
core.text = function(el, compute, parentNode, nodeList) {
	// TODO: we can remove this at some point
	if (el.nodeType !== Node.TEXT_NODE) {
		var textNode;
		if (!nodeList) {
			textNode = document.createTextNode("");
			el.parentNode.replaceChild(textNode, el);
			el = textNode;
		} else {
			textNode = document.createTextNode("");
			canViewNodelist_4_2_0_canViewNodelist.replace(nodeList, textNode);
			canViewNodelist_4_2_0_canViewNodelist.update(nodeList, [textNode]);
			el = textNode;
		}
	}

	var parent = core.getParentNode(el, parentNode);
	// setup listening right away so we don't have to re-calculate value

	// Create a new text node from the compute value
	el.nodeValue = core.makeString(canReflect_1_16_7_canReflect.getValue(compute));

	function liveTextUpdateTextNode(newVal) {
		el.nodeValue = core.makeString(newVal);
	}

	//!steal-remove-start
	// register that the handler changes the parent element
	canReflect_1_16_7_canReflect.assignSymbols(liveTextUpdateTextNode, {
		"can.getChangesDependencyRecord": function() {
			return {
				valueDependencies: new Set( [ parent ] )
			};
		}
	});

	Object.defineProperty(liveTextUpdateTextNode, "name", {
		value: "live.text update::"+canReflect_1_16_7_canReflect.getName(compute),
	});
	//!steal-remove-end

	var data = core.listen(parent, compute, liveTextUpdateTextNode,"domUI");

	if(!nodeList) {
		nodeList = canViewNodelist_4_2_0_canViewNodelist.register([el], null, true);
	}

	nodeList.unregistered = data.teardownCheck;
	data.nodeList = nodeList;
};

var canViewLive_4_1_4_canViewLive = core;

var noop$1 = function(){};

var TextSectionBuilder = function(){
	this.stack = [new TextSection()];
};

canAssign_1_1_1_canAssign(TextSectionBuilder.prototype,utils$1.mixins);

canAssign_1_1_1_canAssign(TextSectionBuilder.prototype,{
	// Adds a subsection.
	startSection: function(process){
		var subSection = new TextSection();
		this.last().add({process: process, truthy: subSection});
		this.stack.push(subSection);
	},
	endSection: function(){
		this.stack.pop();
	},
	inverse: function(){
		this.stack.pop();
		var falseySection = new TextSection();
		this.last().last().falsey = falseySection;
		this.stack.push(falseySection);
	},
	compile: function(state){

		var renderer = this.stack[0].compile();
		//!steal-remove-start
		Object.defineProperty(renderer,"name",{
			value: "textSectionRenderer<"+state.tag+"."+state.attr+">"
		});
		//!steal-remove-end

		return function(scope){
			function textSectionRender(){
				return renderer(scope);
			}
			//!steal-remove-start
			Object.defineProperty(textSectionRender,"name",{
				value: "textSectionRender<"+state.tag+"."+state.attr+">"
			});
			//!steal-remove-end
			var observation = new canObservation_4_0_1_canObservation(textSectionRender, null, {isObservable: false});

			canReflect_1_16_7_canReflect.onValue(observation, noop$1);

			var value = canReflect_1_16_7_canReflect.getValue(observation);
			if( canReflect_1_16_7_canReflect.valueHasDependencies( observation ) ) {
				if(state.textContentOnly) {
					canViewLive_4_1_4_canViewLive.text(this, observation);
				}
				else if(state.attr) {
					canViewLive_4_1_4_canViewLive.attr(this, state.attr, observation);
				}
				else {
					canViewLive_4_1_4_canViewLive.attrs(this, observation, scope);
				}
				canReflect_1_16_7_canReflect.offValue(observation, noop$1);
			} else {
				if(state.textContentOnly) {
					this.nodeValue = value;
				}
				else if(state.attr) {
					canDomMutate_1_0_4_node.setAttribute.call(this, state.attr, value);
				}
				else {
					canViewLive_4_1_4_canViewLive.attrs(this, value);
				}
			}
		};
	}
});

var passTruthyFalsey = function(process, truthy, falsey){
	return function(scope){
		return process.call(this, scope, truthy, falsey);
	};
};

var TextSection = function(){
	this.values = [];
};

canAssign_1_1_1_canAssign( TextSection.prototype, {
	add: function(data){
		this.values.push(data);
	},
	last: function(){
		return this.values[this.values.length - 1];
	},
	compile: function(){
		var values = this.values,
			len = values.length;

		for(var i = 0 ; i < len; i++) {
			var value = this.values[i];
			if(typeof value === "object") {
				values[i] = passTruthyFalsey( value.process,
				    value.truthy && value.truthy.compile(),
				    value.falsey && value.falsey.compile());
			}
		}

		return function(scope){
			var txt = "",
				value;
			for(var i = 0; i < len; i++){
				value = values[i];
				txt += typeof value === "string" ? value : value.call(this, scope);
			}
			return txt;
		};
	}
});

var text_section = TextSectionBuilder;

// ### Arg
// `new Arg(Expression [,modifierOptions] )`
// Used to identify an expression that should return a value.
var Arg = function(expression, modifiers){
	this.expr = expression;
	this.modifiers = modifiers || {};
	this.isCompute = false;
};
Arg.prototype.value = function(){
	return this.expr.value.apply(this.expr, arguments);
};
//!steal-remove-start
Arg.prototype.sourceText = function(){
	return (this.modifiers.compute ? "~" : "")+ this.expr.sourceText();
};
//!steal-remove-end

var arg = Arg;

// ### Literal
// For inline static values like `{{"Hello World"}}`
var Literal = function(value){
	this._value = value;
};
Literal.prototype.value = function(){
	return this._value;
};
//!steal-remove-start
Literal.prototype.sourceText = function(){
	return JSON.stringify(this._value);
};
//!steal-remove-end

var literal = Literal;

// SetterObservable's call a function when set. Their getter is backed up by an
// observation.
function SetterObservable(getter, setter) {
	this.setter = setter;
	this.observation = new canObservation_4_0_1_canObservation(getter);
	this.handler = this.handler.bind(this);

	//!steal-remove-start
	canReflect_1_16_7_canReflect.assignSymbols(this, {
		"can.getName": function() {
			return (
				canReflect_1_16_7_canReflect.getName(this.constructor) +
				"<" +
				canReflect_1_16_7_canReflect.getName(getter) +
				">"
			);
		}
	});
	Object.defineProperty(this.handler, "name", {
		value: canReflect_1_16_7_canReflect.getName(this) + ".handler"
	});
	//!steal-remove-end
}

SetterObservable.prototype = Object.create(settable$1.prototype);
SetterObservable.prototype.constructor = SetterObservable;
SetterObservable.prototype.set = function(newVal) {
	this.setter(newVal);
};
SetterObservable.prototype.hasDependencies = function() {
	return canReflect_1_16_7_canReflect.valueHasDependencies(this.observation);
};
canReflect_1_16_7_canReflect.assignSymbols(SetterObservable.prototype, {
	"can.setValue": SetterObservable.prototype.set,
	"can.valueHasDependencies": SetterObservable.prototype.hasDependencies
});

var setter = SetterObservable;

// ## Helpers
// Helper for getting a bound compute in the scope.
function getObservableValue_fromKey(key, scope, readOptions) {
	var data = scope.computeData(key, readOptions);

	canObservation_4_0_1_canObservation.temporarilyBind(data);

	return data;
}

function computeHasDependencies(compute){
	return compute[canSymbol_1_6_1_canSymbol.for("can.valueHasDependencies")] ?
		canReflect_1_16_7_canReflect.valueHasDependencies(compute) : compute.computeInstance.hasDependencies;
}

function getObservableValue_fromDynamicKey_fromObservable(key, root, helperOptions, readOptions) {
	// This needs to return something similar to a ScopeKeyData with intialValue and parentHasKey
	var getKeys = function(){
		return canStacheKey_1_3_2_canStacheKey.reads(("" + canReflect_1_16_7_canReflect.getValue(key)).replace(".", "\\."));
	};
	var parentHasKey;
	var computeValue = new setter(function getDynamicKey() {
		var readData = canStacheKey_1_3_2_canStacheKey.read( canReflect_1_16_7_canReflect.getValue(root) , getKeys());
		parentHasKey = readData.parentHasKey;
		return readData.value;
	}, function setDynamicKey(newVal){
		canStacheKey_1_3_2_canStacheKey.write(canReflect_1_16_7_canReflect.getValue(root), getKeys(), newVal);
	});
	canObservation_4_0_1_canObservation.temporarilyBind(computeValue);
	computeValue.initialValue = canReflect_1_16_7_canReflect.getValue(computeValue);
	computeValue.parentHasKey = parentHasKey;
	return computeValue;
}

// If not a Literal or an Arg, convert to an arg for caching.
function convertToArgExpression(expr) {
	if(!(expr instanceof arg) && !(expr instanceof literal)) {
		return new arg(expr);
	} else {
		return expr;
	}
}

function toComputeOrValue(value) {
	// convert to non observable value
	if(canReflect_1_16_7_canReflect.isObservableLike(value)) {
		// we only want to do this for things that `should` have dependencies, but dont.
		if(canReflect_1_16_7_canReflect.isValueLike(value) && canReflect_1_16_7_canReflect.valueHasDependencies(value) === false) {
			return canReflect_1_16_7_canReflect.getValue(value);
		}
		// if compute data
		if(value.compute) {
			return value.compute;
		} else {
			return canViewScope_4_4_3_makeComputeLike(value);
		}
	}
	return value;
}

// try to make it a compute no matter what.  This is useful for
// ~ operator.
function toCompute(value) {
	if(value) {

		if(value.isComputed) {
			return value;
		}
		if(value.compute) {
			return value.compute;
		} else {
			return canViewScope_4_4_3_makeComputeLike(value);
		}
	}
	return value;
}

var expressionHelpers = {
	getObservableValue_fromKey: getObservableValue_fromKey,
	computeHasDependencies: computeHasDependencies,
	getObservableValue_fromDynamicKey_fromObservable: getObservableValue_fromDynamicKey_fromObservable,
	convertToArgExpression: convertToArgExpression,
	toComputeOrValue: toComputeOrValue,
	toCompute: toCompute
};

var Hashes = function(hashes){
	this.hashExprs = hashes;
};
Hashes.prototype.value = function(scope, helperOptions){
	var hash = {};
	for(var prop in this.hashExprs) {
		var val = expressionHelpers.convertToArgExpression(this.hashExprs[prop]),
			value = val.value.apply(val, arguments);

		hash[prop] = {
			call: !val.modifiers || !val.modifiers.compute,
			value: value
		};
	}
	return new canObservation_4_0_1_canObservation(function(){
		var finalHash = {};
		for(var prop in hash) {
			finalHash[prop] = hash[prop].call ? canReflect_1_16_7_canReflect.getValue( hash[prop].value ) : expressionHelpers.toComputeOrValue( hash[prop].value );
		}
		return finalHash;
	});
};
//!steal-remove-start
Hashes.prototype.sourceText = function(){
	var hashes = [];
	canReflect_1_16_7_canReflect.eachKey(this.hashExprs, function(expr, prop){
		hashes.push( prop+"="+expr.sourceText() );
	});
	return hashes.join(" ");
};
//!steal-remove-end

var hashes = Hashes;

//!steal-remove-start

//!steal-remove-end


// ### Bracket
// For accessing properties using bracket notation like `foo[bar]`
var Bracket = function (key, root, originalKey) {
	this.root = root;
	this.key = key;
	//!steal-remove-start
	this[canSymbol_1_6_1_canSymbol.for("can-stache.originalKey")] = originalKey;
	//!steal-remove-end
};
Bracket.prototype.value = function (scope, helpers) {
	var root = this.root ? this.root.value(scope, helpers) : scope.peek("this");
	return expressionHelpers.getObservableValue_fromDynamicKey_fromObservable(this.key.value(scope, helpers), root, scope, helpers, {});
};
//!steal-remove-start
Bracket.prototype.sourceText = function(){
	if(this.rootExpr) {
		return this.rootExpr.sourceText()+"["+this.key+"]";
	} else {
		return "["+this.key+"]";
	}
};
//!steal-remove-end

Bracket.prototype.closingTag = function() {
	//!steal-remove-start
	return this[canSymbol_1_6_1_canSymbol.for('can-stache.originalKey')] || '';
	//!steal-remove-end
};

var bracket = Bracket;

var setIdentifier = function SetIdentifier(value){
	this.value = value;
};

var sourceTextSymbol = canSymbol_1_6_1_canSymbol.for("can-stache.sourceText");





// ### Call
// `new Call( new Lookup("method"), [new ScopeExpr("name")], {})`
// A call expression like `method(arg1, arg2)` that, by default,
// calls `method` with non compute values.
var Call = function(methodExpression, argExpressions){
	this.methodExpr = methodExpression;
	this.argExprs = argExpressions.map(expressionHelpers.convertToArgExpression);
};
Call.prototype.args = function(scope, ignoreArgLookup) {
	var hashExprs = {};
	var args = [];
	var gotIgnoreFunction = typeof ignoreArgLookup === "function";

	for (var i = 0, len = this.argExprs.length; i < len; i++) {
		var arg = this.argExprs[i];
		if(arg.expr instanceof hashes){
			canAssign_1_1_1_canAssign(hashExprs, arg.expr.hashExprs);
		}
		if (!gotIgnoreFunction || !ignoreArgLookup(i)) {
			var value = arg.value.apply(arg, arguments);
			args.push({
				// always do getValue unless compute is false
				call: !arg.modifiers || !arg.modifiers.compute,
				value: value
			});
		}
	}
	return function(doNotWrapArguments){
		var finalArgs = [];
		if(canReflect_1_16_7_canReflect.size(hashExprs) > 0){
			finalArgs.hashExprs = hashExprs;
		}
		for(var i = 0, len = args.length; i < len; i++) {
			if (doNotWrapArguments) {
				finalArgs[i] = args[i].value;
			} else {
				finalArgs[i] = args[i].call ?
					canReflect_1_16_7_canReflect.getValue( args[i].value ) :
					expressionHelpers.toCompute( args[i].value );
			}
		}
		return finalArgs;
	};
};

Call.prototype.value = function(scope, helperOptions){
	var callExpression = this;

	// proxyMethods must be false so that the `requiresOptionsArgument` and any
	// other flags stored on the function are preserved
	var method = this.methodExpr.value(scope, { proxyMethods: false }),
		func = canReflect_1_16_7_canReflect.getValue( method );

	var getArgs = callExpression.args(scope , func && func.ignoreArgLookup);

	var computeFn = function(newVal){
		var func = canReflect_1_16_7_canReflect.getValue( method );

		if(typeof func === "function") {
			var args = getArgs(
				func.isLiveBound
			);

			if (func.requiresOptionsArgument) {
				if(args.hashExprs && helperOptions && helperOptions.exprData){
					helperOptions.exprData.hashExprs = args.hashExprs;
				}
				args.push(helperOptions);
			}
			if(arguments.length) {
				args.unshift(new setIdentifier(newVal));
			}

			// if this is a call like `foo.bar()` the method.thisArg will be set to `foo`
			// for a call like `foo()`, method.thisArg will not be set and we will default
			// to setting the scope as the context of the function
			return func.apply(method.thisArg || scope.peek("this"), args);
		}
	};
	//!steal-remove-start
	Object.defineProperty(computeFn, "name", {
		value: "{{" + this.sourceText() + "}}"
	});
	//!steal-remove-end

	if (helperOptions && helperOptions.doNotWrapInObservation) {
		return computeFn();
	} else {
		var computeValue = new setter(computeFn, computeFn);

		return computeValue;
	}
};
//!steal-remove-start
Call.prototype.sourceText = function(){
	var args = this.argExprs.map(function(arg){
		return arg.sourceText();
	});
	return this.methodExpr.sourceText()+"("+args.join(",")+")";
};
//!steal-remove-end
Call.prototype.closingTag = function() {
	//!steal-remove-start
	if(this.methodExpr[sourceTextSymbol]) {
		return this.methodExpr[sourceTextSymbol];
	}
	//!steal-remove-end
	return this.methodExpr.key;
};

var call$1 = Call;

var Helper = function(methodExpression, argExpressions, hashExpressions){
	this.methodExpr = methodExpression;
	this.argExprs = argExpressions;
	this.hashExprs = hashExpressions;
	this.mode = null;
};
Helper.prototype.args = function(scope){
	var args = [];
	for(var i = 0, len = this.argExprs.length; i < len; i++) {
		var arg = this.argExprs[i];
		// TODO: once we know the helper, we should be able to avoid compute conversion
		args.push( expressionHelpers.toComputeOrValue( arg.value.apply(arg, arguments) ) );
	}
	return args;
};
Helper.prototype.hash = function(scope){
	var hash = {};
	for(var prop in this.hashExprs) {
		var val = this.hashExprs[prop];
		// TODO: once we know the helper, we should be able to avoid compute conversion
		hash[prop] = expressionHelpers.toComputeOrValue( val.value.apply(val, arguments) );
	}
	return hash;
};

Helper.prototype.value = function(scope, helperOptions){
	// If a literal, this means it should be treated as a key. But helpers work this way for some reason.
	// TODO: fix parsing so numbers will also be assumed to be keys.
	var methodKey = this.methodExpr instanceof literal ?
		"" + this.methodExpr._value :
		this.methodExpr.key,
		helperInstance = this,
		// proxyMethods must be false so that the `requiresOptionsArgument` and any
		// other flags stored on the function are preserved
		helperFn = expressionHelpers.getObservableValue_fromKey(methodKey, scope, { proxyMethods: false }),
		initialValue = helperFn && helperFn.initialValue,
		thisArg = helperFn && helperFn.thisArg;

	if (typeof initialValue === "function") {
		helperFn = function helperFn() {
			var args = helperInstance.args(scope),
				helperOptionArg = canAssign_1_1_1_canAssign(canAssign_1_1_1_canAssign({}, helperOptions), {
					hash: helperInstance.hash(scope),
					exprData: helperInstance
				});

			args.push(helperOptionArg);

			return initialValue.apply(thisArg || scope.peek("this"), args);
		};
		//!steal-remove-start
		Object.defineProperty(helperFn, "name", {
			value: canReflect_1_16_7_canReflect.getName(this)
		});
		//!steal-remove-end
	}
	//!steal-remove-start
	else {
		var filename = scope.peek('scope.filename');
		var lineNumber = scope.peek('scope.lineNumber');
		dev.warn(
			(filename ? filename + ':' : '') +
			(lineNumber ? lineNumber + ': ' : '') +
			'Unable to find helper "' + methodKey + '".');
	}
	//!steal-remove-end

	return  helperFn;
};

Helper.prototype.closingTag = function() {
	return this.methodExpr.key;
};

//!steal-remove-start
Helper.prototype.sourceText = function(){
	var text = [this.methodExpr.sourceText()];
	if(this.argExprs.length) {
		text.push( this.argExprs.map(function(arg){
			return arg.sourceText();
		}).join(" ") );
	}
	if(canReflect_1_16_7_canReflect.size(this.hashExprs) > 0){
		text.push( hashes.prototype.sourceText.call(this) );
	}
	return text.join(" ");
};
//!steal-remove-end
canReflect_1_16_7_canReflect.assignSymbols(Helper.prototype,{
	"can.getName": function() {
		return canReflect_1_16_7_canReflect.getName(this.constructor) + "{{" + (this.sourceText()) + "}}";
	}
});
//!steal-remove-end

var helper = Helper;

var sourceTextSymbol$1 = canSymbol_1_6_1_canSymbol.for("can-stache.sourceText");



// ### Lookup
// `new Lookup(String, [Expression])`
// Finds a value in the scope or a helper.
var Lookup = function(key, root, sourceText) {
	this.key = key;
	this.rootExpr = root;
	canReflect_1_16_7_canReflect.setKeyValue(this, sourceTextSymbol$1, sourceText);
};
Lookup.prototype.value = function(scope, readOptions){
	var value;

	if (this.rootExpr) {
		value = expressionHelpers.getObservableValue_fromDynamicKey_fromObservable(this.key, this.rootExpr.value(scope), scope, {}, {});
	} else {
		value = expressionHelpers.getObservableValue_fromKey(this.key, scope, readOptions);
	}

	//!steal-remove-start
	if (typeof value.initialValue === 'undefined' && this.key !== "debugger" && !value.parentHasKey) {
		var filename = scope.peek('scope.filename');
		var lineNumber = scope.peek('scope.lineNumber');

		var reads = canStacheKey_1_3_2_canStacheKey.reads(this.key);
		var firstKey = reads[0].key;
		var key = reads.map(function(read) {
			return read.key + (read.at ? "()" : "");
		}).join(".");
		var pathsForKey = scope.getPathsForKey(firstKey);
		var paths = Object.keys( pathsForKey );

		var includeSuggestions = paths.length && !paths.includes(firstKey);

		var warning = [
			(filename ? filename + ':' : '') +
				(lineNumber ? lineNumber + ': ' : '') +
				'Unable to find key "' + key + '".' +
				(
					includeSuggestions ?
						" Did you mean" + (paths.length > 1 ? " one of these" : "") + "?\n" :
						"\n"
				)
		];

		if (includeSuggestions) {
			paths.forEach(function(path) {
				warning.push('\t"' + path + '" which will read from');
				warning.push(pathsForKey[path]);
				warning.push("\n");
			});
		}

		warning.push("\n");

		dev.warn.apply(dev,
			warning
		);
	}
	//!steal-remove-end

	return value;
};
//!steal-remove-start
Lookup.prototype.sourceText = function(){
	if(this[sourceTextSymbol$1]) {
		return this[sourceTextSymbol$1];
	} else if(this.rootExpr) {
		return this.rootExpr.sourceText()+"."+this.key;
	} else {
		return this.key;
	}
};
//!steal-remove-end

var lookup = Lookup;

// ## Expression Types
//
// These expression types return a value. They are assembled by `expression.parse`.













var last$1 = utils$1.last;



var sourceTextSymbol$2 = canSymbol_1_6_1_canSymbol.for("can-stache.sourceText");

// ### Hash
// A placeholder. This isn't actually used.
var Hash = function(){ }; // jshint ignore:line

// NAME - \w
// KEY - foo, foo.bar, foo@bar, %foo (special), &foo (references), ../foo, ./foo
// ARG - ~KEY, KEY, CALLEXPRESSION, PRIMITIVE
// CALLEXPRESSION = KEY(ARG,ARG, NAME=ARG)
// HELPEREXPRESSION = KEY ARG ARG NAME=ARG
// DOT .NAME
// AT @NAME
//
var keyRegExp = /[\w\.\\\-_@\/\&%]+/,
	tokensRegExp = /('.*?'|".*?"|=|[\w\.\\\-_@\/*%\$]+|[\(\)]|,|\~|\[|\]\s*|\s*(?=\[))/g,
	bracketSpaceRegExp = /\]\s+/,
	literalRegExp = /^('.*?'|".*?"|-?[0-9]+\.?[0-9]*|true|false|null|undefined)$/;

var isTokenKey = function(token){
	return keyRegExp.test(token);
};

var testDot = /^[\.@]\w/;
var isAddingToExpression = function(token) {

	return isTokenKey(token) && testDot.test(token);
};

var ensureChildren = function(type) {
	if(!type.children) {
		type.children = [];
	}
	return type;
};

var Stack = function(){

	this.root = {children: [], type: "Root"};
	this.current = this.root;
	this.stack = [this.root];
};
canAssign_1_1_1_canAssign(Stack.prototype,{
	top: function(){
		return last$1(this.stack);
	},
	isRootTop: function(){
		return this.top() === this.root;
	},
	popTo: function(types){
		this.popUntil(types);
		this.pop();
	},
	pop: function() {
		if(!this.isRootTop()) {
			this.stack.pop();
		}
	},
	first: function(types){
		var curIndex = this.stack.length - 1;
		while( curIndex > 0 && types.indexOf(this.stack[curIndex].type) === -1 ) {
			curIndex--;
		}
		return this.stack[curIndex];
	},
	firstParent: function(types){
		var curIndex = this.stack.length - 2;
		while( curIndex > 0 && types.indexOf(this.stack[curIndex].type) === -1 ) {
			curIndex--;
		}
		return this.stack[curIndex];
	},
	popUntil: function(types){
		while( types.indexOf(this.top().type) === -1 && !this.isRootTop() ) {
			this.stack.pop();
		}
		return this.top();
	},
	addTo: function(types, type){
		var cur = this.popUntil(types);
		ensureChildren(cur).children.push(type);
	},
	addToAndPush: function(types, type){
		this.addTo(types, type);
		this.stack.push(type);
	},
	push: function(type) {
		this.stack.push(type);
	},
	topLastChild: function(){
		return last$1(this.top().children);
	},
	replaceTopLastChild: function(type){
		var children = ensureChildren(this.top()).children;
		children.pop();
		children.push(type);
		return type;
	},
	replaceTopLastChildAndPush: function(type) {
		this.replaceTopLastChild(type);
		this.stack.push(type);
	},
	replaceTopAndPush: function(type){
		var children;
		if(this.top() === this.root) {
			children = ensureChildren(this.top()).children;
		} else {
			this.stack.pop();
			// get parent and clean
			children = ensureChildren(this.top()).children;
		}

		children.pop();
		children.push(type);
		this.stack.push(type);
		return type;
	}
});

// converts
// - "../foo" -> "../@foo",
// - "foo" -> "@foo",
// - ".foo" -> "@foo",
// - "./foo" -> "./@foo"
// - "foo.bar" -> "foo@bar"
var convertKeyToLookup = function(key){
	var lastPath = key.lastIndexOf("./");
	var lastDot = key.lastIndexOf(".");
	if(lastDot > lastPath) {
		return key.substr(0, lastDot)+"@"+key.substr(lastDot+1);
	}
	var firstNonPathCharIndex = lastPath === -1 ? 0 : lastPath+2;
	var firstNonPathChar = key.charAt(firstNonPathCharIndex);
	if(firstNonPathChar === "." || firstNonPathChar === "@" ) {
		return key.substr(0, firstNonPathCharIndex)+"@"+key.substr(firstNonPathCharIndex+1);
	} else {
		return key.substr(0, firstNonPathCharIndex)+"@"+key.substr(firstNonPathCharIndex);
	}
};
var convertToAtLookup = function(ast){
	if(ast.type === "Lookup") {
		canReflect_1_16_7_canReflect.setKeyValue(ast, sourceTextSymbol$2, ast.key);
		ast.key = convertKeyToLookup(ast.key);
	}
	return ast;
};

var convertToHelperIfTopIsLookup = function(stack){
	var top = stack.top();
	// if two scopes, that means a helper
	if(top && top.type === "Lookup") {

		var base = stack.stack[stack.stack.length - 2];
		// That lookup shouldn't be part of a Helper already or
		if(base.type !== "Helper" && base) {
			stack.replaceTopAndPush({
				type: "Helper",
				method: top
			});
		}
	}
};

var expression = {
	toComputeOrValue: expressionHelpers.toComputeOrValue,
	convertKeyToLookup: convertKeyToLookup,

	Literal: literal,
	Lookup: lookup,
	Arg: arg,
	Hash: Hash,
	Hashes: hashes,
	Call: call$1,
	Helper: helper,
	Bracket: bracket,

	SetIdentifier: setIdentifier,
	tokenize: function(expression){
		var tokens = [];
		(expression.trim() + ' ').replace(tokensRegExp, function (whole, arg$$1) {
			if (bracketSpaceRegExp.test(arg$$1)) {
				tokens.push(arg$$1[0]);
				tokens.push(arg$$1.slice(1));
			} else {
				tokens.push(arg$$1);
			}
		});
		return tokens;
	},
	lookupRules: {
		"default": function(ast, methodType, isArg){
			return ast.type === "Helper" ? helper : lookup;
		},
		"method": function(ast, methodType, isArg){
			return lookup;
		}
	},
	methodRules: {
		"default": function(ast){
			return ast.type === "Call" ? call$1 : helper;
		},
		"call": function(ast){
			return call$1;
		}
	},
	// ## expression.parse
	//
	// - {String} expressionString - A stache expression like "abc foo()"
	// - {Object} options
	//   - baseMethodType - Treat this like a Helper or Call.  Default to "Helper"
	//   - lookupRule - "default" or "method"
	//   - methodRule - "default" or "call"
	parse: function(expressionString, options){
		options =  options || {};
		var ast = this.ast(expressionString);

		if(!options.lookupRule) {
			options.lookupRule = "default";
		}
		if(typeof options.lookupRule === "string") {
			options.lookupRule = expression.lookupRules[options.lookupRule];
		}
		if(!options.methodRule) {
			options.methodRule = "default";
		}
		if(typeof options.methodRule === "string") {
			options.methodRule = expression.methodRules[options.methodRule];
		}

		var expr = this.hydrateAst(ast, options, options.baseMethodType || "Helper");

		return expr;
	},
	hydrateAst: function(ast, options, methodType, isArg){
		var hashes$$1;
		if(ast.type === "Lookup") {
			var LookupRule = options.lookupRule(ast, methodType, isArg);
			var lookup$$1 = new LookupRule(ast.key, ast.root && this.hydrateAst(ast.root, options, methodType), ast[sourceTextSymbol$2] );
			return lookup$$1;
		}
		else if(ast.type === "Literal") {
			return new literal(ast.value);
		}
		else if(ast.type === "Arg") {
			return new arg(this.hydrateAst(ast.children[0], options, methodType, isArg),{compute: true});
		}
		else if(ast.type === "Hash") {
			throw new Error("");
		}
		else if(ast.type === "Hashes") {
			hashes$$1 = {};
			ast.children.forEach(function(hash){
				hashes$$1[hash.prop] = this.hydrateAst( hash.children[0], options, methodType, true );
			}, this);
			return new hashes(hashes$$1);
		}
		else if(ast.type === "Call" || ast.type === "Helper") {
			//get all arguments and hashes
			hashes$$1 = {};
			var args = [],
				children = ast.children,
				ExpressionType = options.methodRule(ast);
			if(children) {
				for(var i = 0 ; i <children.length; i++) {
					var child = children[i];
					if(child.type === "Hashes" && ast.type === "Helper" &&
						(ExpressionType !== call$1)) {

						child.children.forEach(function(hash){
							hashes$$1[hash.prop] = this.hydrateAst( hash.children[0], options, ast.type, true );
						}, this);

					} else {
						args.push( this.hydrateAst(child, options, ast.type, true) );
					}
				}
			}


			return new ExpressionType(this.hydrateAst(ast.method, options, ast.type),
																args, hashes$$1);
		} else if (ast.type === "Bracket") {
			var originalKey;
			//!steal-remove-start
			originalKey = ast[canSymbol_1_6_1_canSymbol.for("can-stache.originalKey")];
			//!steal-remove-end
			return new bracket(
				this.hydrateAst(ast.children[0], options),
				ast.root ? this.hydrateAst(ast.root, options) : undefined,
				originalKey
			);
		}
	},
	ast: function(expression){
		var tokens = this.tokenize(expression);
		return this.parseAst(tokens, {
			index: 0
		});
	},
	parseAst: function(tokens, cursor) {
		// jshint maxdepth: 6
		var stack = new Stack(),
			top,
			firstParent,
			lastToken;

		while(cursor.index < tokens.length) {
			var token = tokens[cursor.index],
				nextToken = tokens[cursor.index+1];

			cursor.index++;

			// Hash
			if(nextToken === "=") {
				//convertToHelperIfTopIsLookup(stack);
				top = stack.top();

				// If top is a Lookup, we might need to convert to a helper.
				if(top && top.type === "Lookup") {
					// Check if current Lookup is part of a Call, Helper, or Hash
					// If it happens to be first within a Call or Root, that means
					// this is helper syntax.
					firstParent = stack.firstParent(["Call","Helper","Hash"]);
					if(firstParent.type === "Call" || firstParent.type === "Root") {

						stack.popUntil(["Call"]);
						top = stack.top();
						stack.replaceTopAndPush({
							type: "Helper",
							method: top.type === "Root" ? last$1(top.children) : top
						});

					}
				}
				firstParent = stack.firstParent(["Call","Helper","Hashes"]);
				// makes sure we are adding to Hashes if there already is one
				// otherwise we create one.
				var hash = {type: "Hash", prop: token};
				if(firstParent.type === "Hashes") {
					stack.addToAndPush(["Hashes"], hash);
				} else {
					stack.addToAndPush(["Helper", "Call"], {
						type: "Hashes",
						children: [hash]
					});
					stack.push(hash);
				}
				cursor.index++;

			}
			// Literal
			else if(literalRegExp.test( token )) {
				convertToHelperIfTopIsLookup(stack);
				// only add to hash if there's not already a child.
				firstParent = stack.first(["Helper", "Call", "Hash", "Bracket"]);
				if(firstParent.type === "Hash" && (firstParent.children && firstParent.children.length > 0)) {
					stack.addTo(["Helper", "Call", "Bracket"], {type: "Literal", value: utils$1.jsonParse( token )});
				} else if(firstParent.type === "Bracket" && (firstParent.children && firstParent.children.length > 0)) {
					stack.addTo(["Helper", "Call", "Hash"], {type: "Literal", value: utils$1.jsonParse( token )});
				} else {
					stack.addTo(["Helper", "Call", "Hash", "Bracket"], {type: "Literal", value: utils$1.jsonParse( token )});
				}

			}
			// Lookup
			else if(keyRegExp.test(token)) {
				lastToken = stack.topLastChild();
				firstParent = stack.first(["Helper", "Call", "Hash", "Bracket"]);

				// if we had `foo().bar`, we need to change to a Lookup that looks up from lastToken.
				if(lastToken && (lastToken.type === "Call" || lastToken.type === "Bracket" ) && isAddingToExpression(token)) {
					stack.replaceTopLastChildAndPush({
						type: "Lookup",
						root: lastToken,
						key: token.slice(1) // remove leading `.`
					});
				}
				else if(firstParent.type === 'Bracket') {
					// a Bracket expression without children means we have
					// parsed `foo[` of an expression like `foo[bar]`
					// so we know to add the Lookup as a child of the Bracket expression
					if (!(firstParent.children && firstParent.children.length > 0)) {
						stack.addToAndPush(["Bracket"], {type: "Lookup", key: token});
					} else {
						// check if we are adding to a helper like `eq foo[bar] baz`
						// but not at the `.baz` of `eq foo[bar].baz xyz`
						if(stack.first(["Helper", "Call", "Hash", "Arg"]).type === 'Helper' && token[0] !== '.') {
							stack.addToAndPush(["Helper"], {type: "Lookup", key: token});
						} else {
							// otherwise, handle the `.baz` in expressions like `foo[bar].baz`
							stack.replaceTopAndPush({
								type: "Lookup",
								key: token.slice(1),
								root: firstParent
							});
						}
					}
				}
				else {
					// if two scopes, that means a helper
					convertToHelperIfTopIsLookup(stack);

					stack.addToAndPush(["Helper", "Call", "Hash", "Arg", "Bracket"], {type: "Lookup", key: token});
				}

			}
			// Arg
			else if(token === "~") {
				convertToHelperIfTopIsLookup(stack);
				stack.addToAndPush(["Helper", "Call", "Hash"], {type: "Arg", key: token});
			}
			// Call
			// foo[bar()]
			else if(token === "(") {
				top = stack.top();
				if(top.type === "Lookup") {
					stack.replaceTopAndPush({
						type: "Call",
						method: convertToAtLookup(top)
					});
				} else {
					throw new Error("Unable to understand expression "+tokens.join(''));
				}
			}
			// End Call
			else if(token === ")") {
				stack.popTo(["Call"]);
			}
			// End Call argument
			else if(token === ",") {
				stack.popUntil(["Call"]);
			}
			// Bracket
			else if(token === "[") {
				top = stack.top();
				lastToken = stack.topLastChild();

				if (lastToken && (lastToken.type === "Call" || lastToken.type === "Bracket"  )  ) {
					stack.replaceTopAndPush({type: "Bracket", root: lastToken});
				} else if (top.type === "Lookup" || top.type === "Bracket") {
					var bracket$$1 = {type: "Bracket", root: top};
					//!steal-remove-start
					canReflect_1_16_7_canReflect.setKeyValue(bracket$$1, canSymbol_1_6_1_canSymbol.for("can-stache.originalKey"), top.key);
					//!steal-remove-end
					stack.replaceTopAndPush(bracket$$1);
				} else if (top.type === "Call") {
					stack.addToAndPush(["Call"], { type: "Bracket" });
				} else if (top === " ") {
					stack.popUntil(["Lookup"]);
					convertToHelperIfTopIsLookup(stack);
					stack.addToAndPush(["Helper", "Call", "Hash"], {type: "Bracket"});
				} else {
					stack.replaceTopAndPush({type: "Bracket"});
				}
			}
			// End Bracket
			else if(token === "]") {
				stack.pop();
			}
			else if(token === " ") {
				stack.push(token);
			}
		}
		return stack.root.children[0];
	}
};

var expression_1 = expression;

//
// This provides helper utilities for Mustache processing. Currently,
// only stache uses these helpers.  Ideally, these utilities could be used
// in other libraries implementing Mustache-like features.






var expression$1 = expression_1;








// Lazily lookup the context only if it's needed.
function HelperOptions(scope, nodeList, exprData, stringOnly) {
	this.metadata = { rendered: false };
	this.stringOnly = stringOnly;
	this.scope = scope;
	this.nodeList = nodeList;
	this.exprData = exprData;
}
canDefineLazyValue_1_0_2_defineLazyValue(HelperOptions.prototype,"context", function(){
	return this.scope.peek("this");
});

// ## Types

// A lookup is an object that is used to identify a lookup in the scope.
/**
 * @hide
 * @typedef {{get: String}} can.stache.Lookup
 * @option {String} get A value in the scope to look up.
 */


// ## Helpers

var mustacheLineBreakRegExp = /(?:(^|\r?\n)(\s*)(\{\{([\s\S]*)\}\}\}?)([^\S\n\r]*)($|\r?\n))|(\{\{([\s\S]*)\}\}\}?)/g,
	mustacheWhitespaceRegExp = /(\s*)(\{\{\{?)(-?)([\s\S]*?)(-?)(\}\}\}?)(\s*)/g,
	k = function(){};


var core$1 = {
	expression: expression$1,
	// ## mustacheCore.makeEvaluator
	// Given a scope and expression, returns a function that evaluates that expression in the scope.
	//
	// This function first reads lookup values in the args and hash.  Then it tries to figure out
	// if a helper is being called or a value is being read.  Finally, depending on
	// if it's a helper, or not, and which mode the expression is in, it returns
	// a function that can quickly evaluate the expression.
	/**
	 * @hide
	 * Given a mode and expression data, returns a function that evaluates that expression.
	 * @param {can-view-scope} The scope in which the expression is evaluated.
	 * @param {can.view.Options} The option helpers in which the expression is evaluated.
	 * @param {String} mode Either null, #, ^. > is handled elsewhere
	 * @param {Object} exprData Data about what was in the mustache expression
	 * @param {renderer} [truthyRenderer] Used to render a subsection
	 * @param {renderer} [falseyRenderer] Used to render the inverse subsection
	 * @param {String} [stringOnly] A flag to indicate that only strings will be returned by subsections.
	 * @return {Function} An 'evaluator' function that evaluates the expression.
	 */
	makeEvaluator: function (scope, nodeList, mode, exprData, truthyRenderer, falseyRenderer, stringOnly) {

		if(mode === "^") {
			var temp = truthyRenderer;
			truthyRenderer = falseyRenderer;
			falseyRenderer = temp;
		}

		var value,
			helperOptions = new HelperOptions(scope, nodeList, exprData, stringOnly);
			// set up renderers
			utils$1.createRenderers(helperOptions, scope, nodeList, truthyRenderer, falseyRenderer, stringOnly);

		if(exprData instanceof expression$1.Call) {
			value = exprData.value(scope, helperOptions);
		} else if (exprData instanceof expression$1.Bracket) {
			value = exprData.value(scope);
		} else if (exprData instanceof expression$1.Lookup) {
			value = exprData.value(scope);
		} else if (exprData instanceof expression$1.Helper && exprData.methodExpr instanceof expression$1.Bracket) {
			// Brackets get wrapped in Helpers when used in attributes
			// like `<p class="{{ foo[bar] }}" />`
			value = exprData.methodExpr.value(scope, helperOptions);
		} else {
			value = exprData.value(scope, helperOptions);
			if (typeof value === "function") {
				return value;
			}
		}
		// {{#something()}}foo{{/something}}
		// return evaluator for no mode or rendered value if a renderer was called
		if(!mode || helperOptions.metadata.rendered) {
			return value;
		} else if( mode === "#" || mode === "^" ) {

			return function(){
				// Get the value
				var finalValue = canReflect_1_16_7_canReflect.getValue(value);
				var result;

				// if options.fn or options.inverse was called, we take the observable's return value
				// as what should be put in the DOM.
				if(helperOptions.metadata.rendered) {
					result = finalValue;
				}
				// If it's an array, render.
				else if ( typeof finalValue !== "string" && canReflect_1_16_7_canReflect.isListLike(finalValue) ) {
					var isObserveList = canReflect_1_16_7_canReflect.isObservableLike(finalValue) &&
						canReflect_1_16_7_canReflect.isListLike(finalValue);

					if(canReflect_1_16_7_canReflect.getKeyValue(finalValue, "length")) {
						if (stringOnly) {
							result = utils$1.getItemsStringContent(finalValue, isObserveList, helperOptions);
						} else {
							result = canFragment_1_0_1_canFragment(utils$1.getItemsFragContent(finalValue, helperOptions, scope));
						}
					} else {
						result = helperOptions.inverse(scope);
					}
				}
				else {
					result = finalValue ? helperOptions.fn(finalValue || scope) : helperOptions.inverse(scope);
				}
				// We always set the rendered result back to false.
				// - Future calls might change from returning a value to calling `.fn`
				// - We are calling `.fn` and `.inverse` ourselves.
				helperOptions.metadata.rendered = false;
				return result;
			};
		} else {
			// not supported!
		}
	},
	// ## mustacheCore.makeLiveBindingPartialRenderer
	// Returns a renderer function that live binds a partial.
	/**
	 * @hide
	 * Returns a renderer function that live binds a partial.
	 * @param {String} expressionString
	 * @param {Object} state The html state of where the expression was found.
	 * @return {function(this:HTMLElement,can-view-scope,can.view.Options)} A renderer function
	 * live binds a partial.
	 */
	makeLiveBindingPartialRenderer: function(expressionString, state){
		expressionString = expressionString.trim();
		var exprData,
				partialName = expressionString.split(/\s+/).shift();

		if(partialName !== expressionString) {
			exprData = core$1.expression.parse(expressionString);
		}

		return function(scope, parentSectionNodeList){
			//!steal-remove-start
			scope.set('scope.filename', state.filename);
			scope.set('scope.lineNumber', state.lineNo);
			//!steal-remove-end
			var nodeList = [this];
			nodeList.expression = ">" + partialName;
			canViewNodelist_4_2_0_canViewNodelist.register(nodeList, null, parentSectionNodeList || true, state.directlyNested);

			var partialFrag = new canObservation_4_0_1_canObservation(function(){
				var localPartialName = partialName;
				// If the second parameter of a partial is a custom context
				if(exprData && exprData.argExprs.length === 1) {
					var newContext = canReflect_1_16_7_canReflect.getValue( exprData.argExprs[0].value(scope) );
					if(typeof newContext === "undefined") {
						//!steal-remove-start
						dev.warn('The context ('+ exprData.argExprs[0].key +') you passed into the' +
							'partial ('+ partialName +') is not defined in the scope!');
						//!steal-remove-end
					}else{
						scope = scope.add(newContext);
					}
				}
				// Look up partials in templateContext first
				var partial = canReflect_1_16_7_canReflect.getKeyValue(scope.templateContext.partials, localPartialName);
				var renderer;

				if (partial) {
					renderer = function() {
						return partial.render ? partial.render(scope, nodeList)
							: partial(scope);
					};
				}
				// Use can.view to get and render the partial.
				else {
					var scopePartialName = scope.read(localPartialName, {
						isArgument: true
					}).value;

					if (scopePartialName === null || !scopePartialName && localPartialName[0] === '*') {
						return canFragment_1_0_1_canFragment("");
					}
					if (scopePartialName) {
						localPartialName = scopePartialName;
					}

					renderer = function() {
						if(typeof localPartialName === "function"){
							return localPartialName(scope, {}, nodeList);
						} else {
							var domRenderer = core$1.getTemplateById(localPartialName);
							return domRenderer ? domRenderer(scope, {}, nodeList) : document$1().createDocumentFragment();
						}
					};
				}
				var res = canObservationRecorder_1_1_2_canObservationRecorder.ignore(renderer)();
				return canFragment_1_0_1_canFragment(res);
			});
			canReflect_1_16_7_canReflect.setPriority(partialFrag,nodeList.nesting );

			canViewLive_4_1_4_canViewLive.html(this, partialFrag, this.parentNode, nodeList);
		};
	},
	// ## mustacheCore.makeStringBranchRenderer
	// Return a renderer function that evalutes to a string and caches
	// the evaluator on the scope.
	/**
	 * @hide
	 * Return a renderer function that evaluates to a string.
	 * @param {String} mode
	 * @param {can.stache.Expression} expression
	 * @param {Object} state The html state of where the expression was found.
	 * @return {function(can.view.Scope,can.view.Options, can-stache.renderer, can.view.renderer)}
	 */
	makeStringBranchRenderer: function(mode, expressionString, state){
		var exprData = core$1.expression.parse(expressionString),
			// Use the full mustache expression as the cache key.
			fullExpression = mode+expressionString;

		// A branching renderer takes truthy and falsey renderer.
		var branchRenderer = function branchRenderer(scope, truthyRenderer, falseyRenderer){
			//!steal-remove-start
			scope.set('scope.filename', state.filename);
			scope.set('scope.lineNumber', state.lineNo);
			//!steal-remove-end
			// Check the scope's cache if the evaluator already exists for performance.
			var evaluator = scope.__cache[fullExpression];
			if(mode || !evaluator) {
				evaluator = makeEvaluator( scope, null, mode, exprData, truthyRenderer, falseyRenderer, true);
				if(!mode) {
					scope.__cache[fullExpression] = evaluator;
				}
			}
			var gotObservableValue = evaluator[canSymbol_1_6_1_canSymbol.for("can.onValue")],
				res;

			// Run the evaluator and return the result.
			if(gotObservableValue) {
				res = canReflect_1_16_7_canReflect.getValue(evaluator);
			} else {
				res = evaluator();
			}


			return res == null ? "" : ""+res;
		};

		branchRenderer.exprData = exprData;

		return branchRenderer;
	},
	// ## mustacheCore.makeLiveBindingBranchRenderer
	// Return a renderer function that evaluates the mustache expression and
	// sets up live binding if a compute with dependencies is found. Otherwise,
	// the element's value is set.
	//
	// This function works by creating a `can.compute` from the mustache expression.
	// If the compute has dependent observables, it passes the compute to `can.view.live`; otherwise,
	// it updates the element's property based on the compute's value.
	/**
	 * @hide
	 * Returns a renderer function that evaluates the mustache expression.
	 * @param {String} mode
	 * @param {can.stache.Expression} expression
	 * @param {Object} state The html state of where the expression was found.
	 */
	makeLiveBindingBranchRenderer: function(mode, expressionString, state){
		// Pre-process the expression.
		var exprData = core$1.expression.parse(expressionString);
		if(!(exprData instanceof expression$1.Helper) && !(exprData instanceof expression$1.Call) && !(exprData instanceof expression$1.Bracket) && !(exprData instanceof expression$1.Lookup)) {
			exprData = new expression$1.Helper(exprData,[],{});
		}
		// A branching renderer takes truthy and falsey renderer.
		var branchRenderer = function branchRenderer(scope, parentSectionNodeList, truthyRenderer, falseyRenderer){
			// If this is within a tag, make sure we only get string values.
			var stringOnly = state.tag;
			//!steal-remove-start
			scope.set('scope.filename', state.filename);
			scope.set('scope.lineNumber', state.lineNo);
			//!steal-remove-end
			var nodeList = [this];
			nodeList.expression = expressionString;
			// register this nodeList.
			// Register it with its parent ONLY if this is directly nested.  Otherwise, it's unnecessary.
			canViewNodelist_4_2_0_canViewNodelist.register(nodeList, null, parentSectionNodeList || true, state.directlyNested);

			// Get the evaluator. This does not need to be cached (probably) because if there
			// an observable value, it will be handled by `can.view.live`.
			var evaluator = makeEvaluator( scope, nodeList, mode, exprData, truthyRenderer, falseyRenderer, stringOnly );

			// Create a compute that can not be observed by other
			// computes. This is important because this renderer is likely called by
			// parent expressions.  If this value changes, the parent expressions should
			// not re-evaluate. We prevent that by making sure this compute is ignored by
			// everyone else.
			//var compute = can.compute(evaluator, null, false);
			var gotObservableValue = evaluator[canSymbol_1_6_1_canSymbol.for("can.onValue")];
			var observable;
			if(gotObservableValue) {
				observable = evaluator;
			} else {
				//!steal-remove-start
				Object.defineProperty(evaluator,"name",{
					value: "{{"+(mode || "")+expressionString+"}}"
				});
				//!steal-remove-end
				observable = new canObservation_4_0_1_canObservation(evaluator,null,{isObservable: false});
			}

			if(canReflect_1_16_7_canReflect.setPriority(observable, nodeList.nesting) === false) {
				throw new Error("can-stache unable to set priority on observable");
			}

			// Bind on the computeValue to set the cached value. This helps performance
			// so live binding can read a cached value instead of re-calculating.
			canReflect_1_16_7_canReflect.onValue(observable, k);

			var value = canReflect_1_16_7_canReflect.getValue(observable);

			// If value is a function and not a Lookup ({{foo}}),
			// it's a helper that returned a function and should be called.
			if(typeof value === "function" && !(exprData instanceof expression$1.Lookup)) {

				// A helper function should do it's own binding.  Similar to how
				// we prevented this function's compute from being noticed by parent expressions,
				// we hide any observables read in the function by saving any observables that
				// have been read and then setting them back which overwrites any `can.__observe` calls
				// performed in value.
				canObservationRecorder_1_1_2_canObservationRecorder.ignore(value)(this);

			}
			// If the computeValue has observable dependencies, setup live binding.
			else if( canReflect_1_16_7_canReflect.valueHasDependencies(observable) ) {

				// Depending on where the template is, setup live-binding differently.
				if(state.attr) {
					canViewLive_4_1_4_canViewLive.attr(this, state.attr, observable);
				}
				else if( state.tag )  {
					canViewLive_4_1_4_canViewLive.attrs( this, observable );
				}
				else if(state.text && typeof value !== "object"){
					canViewLive_4_1_4_canViewLive.text(this, observable, this.parentNode, nodeList);
				}
				else {
					canViewLive_4_1_4_canViewLive.html(this, observable, this.parentNode, nodeList);
				}
			}
			// If the computeValue has no observable dependencies, just set the value on the element.
			else {

				if(state.attr) {
					canDomMutate_1_0_4_canDomMutate.setAttribute(this, state.attr, value);
				}
				else if(state.tag) {
					canViewLive_4_1_4_canViewLive.attrs(this, value);
				}
				else if(state.text && typeof value === "string") {
					this.nodeValue = value;
				}
				else if( value != null ){
					canViewNodelist_4_2_0_canViewNodelist.replace([this], canFragment_1_0_1_canFragment(value, this.ownerDocument));
				}
			}
			// Unbind the compute.
			canReflect_1_16_7_canReflect.offValue(observable, k);
		};

		branchRenderer.exprData = exprData;

		return branchRenderer;
	},
	// ## mustacheCore.splitModeFromExpression
	// Returns the mustache mode split from the rest of the expression.
	/**
	 * @hide
	 * Returns the mustache mode split from the rest of the expression.
	 * @param {can.stache.Expression} expression
	 * @param {Object} state The state of HTML where the expression was found.
	 */
	splitModeFromExpression: function(expression, state){
		expression = expression.trim();
		var mode = expression.charAt(0);

		if( "#/{&^>!<".indexOf(mode) >= 0 ) {
			expression =  expression.substr(1).trim();
		} else {
			mode = null;
		}
		// Triple braces do nothing within a tag.
		if(mode === "{" && state.node) {
			mode = null;
		}
		return {
			mode: mode,
			expression: expression
		};
	},
	// ## mustacheCore.cleanLineEndings
	// Removes line breaks accoding to the mustache specification.
	/**
	 * @hide
	 * Prunes line breaks accoding to the mustache specification.
	 * @param {String} template
	 * @return {String}
	 */
	cleanLineEndings: function(template){

		// Finds mustache tags with space around them or no space around them.
		return template.replace( mustacheLineBreakRegExp,
			function(whole,
				returnBefore,
				spaceBefore,
				special,
				expression,
				spaceAfter,
				returnAfter,
				// A mustache magic tag that has no space around it.
				spaceLessSpecial,
				spaceLessExpression,
				matchIndex){

			// IE 8 will provide undefined
			spaceAfter = (spaceAfter || "");
			returnBefore = (returnBefore || "");
			spaceBefore = (spaceBefore || "");

			var modeAndExpression = splitModeFromExpression(expression || spaceLessExpression,{});

			// If it's a partial or tripple stache, leave in place.
			if(spaceLessSpecial || ">{".indexOf( modeAndExpression.mode) >= 0) {
				return whole;
			}  else if( "^#!/".indexOf(  modeAndExpression.mode ) >= 0 ) {
				// Return the magic tag and a trailing linebreak if this did not
				// start a new line and there was an end line.
				// Add a normalized leading space, if there was any leading space, in case this abuts a tag name
				spaceBefore = (returnBefore + spaceBefore) && " ";
				return spaceBefore+special+( matchIndex !== 0 && returnAfter.length ? returnBefore+"\n" :"");


			} else {
				// There is no mode, return special with spaces around it.
				return spaceBefore+special+spaceAfter+(spaceBefore.length || matchIndex !== 0 ? returnBefore+"\n" : "");
			}

		});
	},
	// ## mustacheCore.cleanWhitespaceControl
	// Removes whitespace according to the whitespace control.
	/**
	 * @hide
	 * Prunes whitespace according to the whitespace control.
	 * @param {String} template
	 * @return {String}
	 */
	cleanWhitespaceControl: function(template) {
		return template.replace(mustacheWhitespaceRegExp, function(
			whole,
			spaceBefore,
			bracketBefore,
			controlBefore,
			expression,
			controlAfter,
			bracketAfter,
			spaceAfter,
			matchIndex
		) {

			if (controlBefore === '-') {
				spaceBefore = '';
			}

			if (controlAfter === '-') {
				spaceAfter = '';
			}

			return spaceBefore + bracketBefore + expression + bracketAfter + spaceAfter;

		});
	},
	getTemplateById: function(){}
};

// ## Local Variable Cache
//
// The following creates slightly more quickly accessible references of the following
// core functions.
var makeEvaluator = core$1.makeEvaluator,
	splitModeFromExpression = core$1.splitModeFromExpression;

var mustache_core = core$1;

/**
 * @module {function} can-globals/base-url/base-url base-url
 * @parent can-globals/modules
 *
 * @signature `baseUrl(optionalBaseUrlToSet)`
 *
 * Get and/or set the "base" (containing path) of the document.
 *
 * ```js
 * var baseUrl = require("can-globals/base-url/base-url");
 *
 * console.log(baseUrl());           // -> "http://localhost:8080"
 * console.log(baseUrl(baseUrl() + "/foo/bar")); // -> "http://localhost:8080/foo/bar"
 * console.log(baseUrl());           // -> "http://localhost:8080/foo/bar"
 * ```
 *
 * @param {String} setUrl An optional base url to override reading the base URL from the known path.
 *
 * @return {String} Returns the set or computed base URL
 */

canGlobals_1_1_1_canGlobalsInstance.define('base-url', function(){
	var global = canGlobals_1_1_1_canGlobalsInstance.getKeyValue('global');
	var domDocument = canGlobals_1_1_1_canGlobalsInstance.getKeyValue('document');
	if (domDocument && 'baseURI' in domDocument) {
		return domDocument.baseURI;
	} else if(global.location) {
		var href = global.location.href;
		var lastSlash = href.lastIndexOf("/");
		return lastSlash !== -1 ? href.substr(0, lastSlash) : href;
	} else if(typeof process !== "undefined") {
		return process.cwd();
	}
});

var baseUrl = canGlobals_1_1_1_canGlobalsInstance.makeExport('base-url');

var canJoinUris_1_0_0_canJoinUris = canNamespace_1_0_0_canNamespace.joinURIs = function(base, href) {
	function removeDotSegments(input) {
		var output = [];
		input.replace(/^(\.\.?(\/|$))+/, '')
			.replace(/\/(\.(\/|$))+/g, '/')
			.replace(/\/\.\.$/, '/../')
			.replace(/\/?[^\/]*/g, function (p) {
				if (p === '/..') {
					output.pop();
				} else {
					output.push(p);
				}
			});
		return output.join('').replace(/^\//, input.charAt(0) === '/' ? '/' : '');
	}

	href = canParseUri_1_1_0_canParseUri(href || '');
	base = canParseUri_1_1_0_canParseUri(base || '');

	return !href || !base ? null : (href.protocol || base.protocol) +
		(href.protocol || href.authority ? href.authority : base.authority) +
		removeDotSegments(href.protocol || href.authority || href.pathname.charAt(0) === '/' ? href.pathname : (href.pathname ? ((base.authority && !base.pathname ? '/' : '') + base.pathname.slice(0, base.pathname.lastIndexOf('/') + 1) + href.pathname) : base.pathname)) +
			(href.protocol || href.authority || href.pathname ? href.search : (href.search || base.search)) +
			href.hash;
};

function noop$2 () {}
var resolveValue = noop$2;
var evaluateArgs = noop$2;
var __testing = {};

//!steal-remove-start



__testing = {
	allowDebugger: true
};

resolveValue = function (value) {
	if (value && value[canSymbol_1_6_1_canSymbol.for("can.getValue")]) {
		return canReflect_1_16_7_canReflect.getValue(value);
	}
	return value;
};

evaluateArgs = function (left, right) {
	switch (arguments.length) {
		case 0: return true;
		case 1: return !!resolveValue(left);
		case 2: return resolveValue(left) === resolveValue(right);
		default:
			canLog_1_0_0_canLog.log([
				'Usage:',
				'  {{debugger}}: break any time this helper is evaluated',
				'  {{debugger condition}}: break when `condition` is truthy',
				'  {{debugger left right}}: break when `left` === `right`'
			].join('\n'));
			throw new Error('{{debugger}} must have less than three arguments');
	}
};
//!steal-remove-end

function debuggerHelper (left, right) {
	//!steal-remove-start
	var shouldBreak = evaluateArgs.apply(null, Array.prototype.slice.call(arguments, 0, -1));
	if (!shouldBreak) {
		return;
	}
	// jshint -W098

	canLog_1_0_0_canLog.log('Use `get(<path>)` to debug this template');

	var allowDebugger = __testing.allowDebugger;
	// forgotten debugger
	// jshint -W087
	if (allowDebugger) {
		debugger;
		return;
	}
	// jshint +W087
	//!steal-remove-end

	canLog_1_0_0_canLog.warn('Forgotten {{debugger}} helper');
}
debuggerHelper.requiresOptionsArgument = true;

var Debugger = {
	helper: debuggerHelper,
	evaluateArgs: evaluateArgs,
	resolveValue: resolveValue,

	// used only for testing purposes
	__testing: __testing
};

var truthyObservable = function(observable){
    return new canObservation_4_0_1_canObservation(function truthyObservation(){
        var val = canReflect_1_16_7_canReflect.getValue(observable);

        return !!val;
    });
};

var canDomData_1_0_1_canDomData = createCommonjsModule(function (module) {


var isEmptyObject = function(obj){
	/* jshint -W098 */
	for(var prop in obj) {
		return false;
	}
	return true;
};

var data = new WeakMap();

// delete this node's `data`
// returns true if the node was deleted.
var deleteNode = function(node) {
	var nodeDeleted = false;
	if (data.has(node)) {
		nodeDeleted = true;
		data.delete(node);
	}
	return nodeDeleted;
};

var setData = function(node, name, value) {
	var store = data.get(node);
	if (store === undefined) {
		store = {};
		data.set(node, store);
	}
	if (name !== undefined) {
		store[name] = value;
	}
	return store;
};

/*
 * Core of domData that does not depend on mutationDocument
 * This is separated in order to prevent circular dependencies
 */
var domData = {
	_data: data,

	get: function(node, key) {
		var store = data.get(node);
		return key === undefined ? store : store && store[key];
	},

	set: setData,

	clean: function(node, prop) {
		var itemData = data.get(node);
		if (itemData && itemData[prop]) {
			delete itemData[prop];
		}
		if (isEmptyObject(itemData)) {
			deleteNode(node);
		}
	},

	delete: deleteNode
};

if (canNamespace_1_0_0_canNamespace.domData) {
	throw new Error("You can't have two versions of can-dom-data, check your dependencies");
} else {
	module.exports = canNamespace_1_0_0_canNamespace.domData = domData;
}
});

var debuggerHelper$1 = Debugger.helper;








var looksLikeOptions = function(options){
	return options && typeof options.fn === "function" && typeof options.inverse === "function";
};

var resolve = function (value) {
	if (value && canReflect_1_16_7_canReflect.isValueLike(value)) {
		return canReflect_1_16_7_canReflect.getValue(value);
	} else {
		return value;
	}
};

var resolveHash = function(hash){
	var params = {};
	for(var prop in hash) {
		params[prop] = resolve(hash[prop]);
	}
	return params;
};
var bindAndRead = function (value) {
	if ( value && canReflect_1_16_7_canReflect.isValueLike(value) ) {
		canObservation_4_0_1_canObservation.temporarilyBind(value);
		return canReflect_1_16_7_canReflect.getValue(value);
	} else {
		return value;
	}
};

var eachHelper = function(items) {
	var args = [].slice.call(arguments),
		options = args.pop(),
		hashExprs = options.exprData.hashExprs,
		resolved = bindAndRead(items),
		hashOptions,
		aliases;

	// Check if using hash
	if (canReflect_1_16_7_canReflect.size(hashExprs) > 0) {
		hashOptions = {};
		canReflect_1_16_7_canReflect.eachKey(hashExprs, function (exprs, key) {
			hashOptions[exprs.key] = key;
		});
	}



	if ((
		canReflect_1_16_7_canReflect.isObservableLike(resolved) && canReflect_1_16_7_canReflect.isListLike(resolved) ||
			( canReflect_1_16_7_canReflect.isListLike(resolved) && canReflect_1_16_7_canReflect.isValueLike(items) )
	) && !options.stringOnly) {
		// Tells that a helper has been called, this function should be returned through
		// checking its value.
		options.metadata.rendered = true;
		return function(el){
			// make a child nodeList inside the can.view.live.html nodeList
			// so that if the html is re
			var nodeList = [el];
			nodeList.expression = "live.list";
			canViewNodelist_4_2_0_canViewNodelist.register(nodeList, null, options.nodeList, true);
			// runs nest replacements
			canViewNodelist_4_2_0_canViewNodelist.update(options.nodeList, [el]);

			var cb = function (item, index, parentNodeList) {
				var aliases = {};

				if (canReflect_1_16_7_canReflect.size(hashOptions) > 0) {
					if (hashOptions.value) {
						aliases[hashOptions.value] = item;
					}
					if (hashOptions.index) {
						aliases[hashOptions.index] = index;
					}
				}

				return options.fn(
					options.scope
					.add(aliases, { notContext: true })
					.add({ index: index }, { special: true })
					.add(item),
				options.options,
				parentNodeList
				);
			};

			canViewLive_4_1_4_canViewLive.list(el, items, cb, options.context, el.parentNode, nodeList, function(list, parentNodeList){
				return options.inverse(options.scope.add(list), options.options, parentNodeList);
			});
		};
	}

	var expr = resolve(items),
		result;

	if (!!expr && canReflect_1_16_7_canReflect.isListLike(expr)) {
		result = utils$1.getItemsFragContent(expr, options, options.scope);
		return options.stringOnly ? result.join('') : result;
	} else if (canReflect_1_16_7_canReflect.isObservableLike(expr) && canReflect_1_16_7_canReflect.isMapLike(expr) || expr instanceof Object) {
		result = [];
		canReflect_1_16_7_canReflect.each(expr, function(val, key){
			var value = new keyObservable(expr, key);
			aliases = {};

			if (canReflect_1_16_7_canReflect.size(hashOptions) > 0) {
				if (hashOptions.value) {
					aliases[hashOptions.value] = value;
				}
				if (hashOptions.key) {
					aliases[hashOptions.key] = key;
				}
			}
			result.push(options.fn(
				options.scope
				.add(aliases, { notContext: true })
				.add({ key: key }, { special: true })
				.add(value)
			));
		});

		return options.stringOnly ? result.join('') : result;
	}
};
eachHelper.isLiveBound = true;
eachHelper.requiresOptionsArgument = true;
eachHelper.ignoreArgLookup = function ignoreArgLookup(index) {
	return index === 1;
};

var indexHelper = function(offset, options) {
	if (!options) {
		options = offset;
		offset = 0;
	}
	var index = options.scope.peek("scope.index");
	return ""+((typeof(index) === "function" ? index() : index) + offset);
};
indexHelper.requiresOptionsArgument = true;

var ifHelper = function (expr, options) {
	var value;
	// if it's a function, wrap its value in a compute
	// that will only change values from true to false
	if (expr && canReflect_1_16_7_canReflect.isValueLike(expr)) {
		value = canReflect_1_16_7_canReflect.getValue(new truthyObservable(expr));
	} else {
		value = !! resolve(expr);
	}

	if (value) {
		return options.fn(options.scope || this);
	} else {
		return options.inverse(options.scope || this);
	}
};
ifHelper.requiresOptionsArgument = true;

var isHelper = function() {
	var lastValue, curValue,
		options = arguments[arguments.length - 1];

	if (arguments.length  <= 2) {
		return options.inverse();
	}

	var args = arguments;

	function isHelper(){
		for (var i = 0; i < args.length - 1; i++) {
			curValue = resolve(args[i]);
			curValue = typeof curValue === "function" ? curValue() : curValue;

			if (i > 0) {
				if (curValue !== lastValue) {
					return false;
				}
			}
			lastValue = curValue;
		}
		return true;
	}

	//!steal-remove-start
	Object.defineProperty(isHelper, "name", {
		value: "is("+[].slice.call(args,0,2).map(function(arg){
			return canReflect_1_16_7_canReflect.getName(arg);
		}).join(",")+")"
	});
	//!steal-remove-end

	var callFn = new canObservation_4_0_1_canObservation(isHelper);

	return callFn.get() ? options.fn() : options.inverse();
};
isHelper.requiresOptionsArgument = true;

var unlessHelper = function (expr, options) {
	return ifHelper.apply(this, [expr, canAssign_1_1_1_canAssign(canAssign_1_1_1_canAssign({}, options), {
		fn: options.inverse,
		inverse: options.fn
	})]);
};
unlessHelper.requiresOptionsArgument = true;

var withHelper = function (expr, options) {
	var ctx = expr;
	if(!options) {
		// hash-only case if no current context expression
		options = expr;
		expr = true;
		ctx = options.hash;
	} else {
		expr = resolve(expr);
		if(options.hash && canReflect_1_16_7_canReflect.size(options.hash) > 0) {
			// presumably rare case of both a context object AND hash keys
			// Leaving it undocumented for now, but no reason not to support it.
			ctx = options.scope.add(options.hash, { notContext: true }).add(ctx);
		}
	}
	return options.fn(ctx || {});
};
withHelper.requiresOptionsArgument = true;

var dataHelper = function(attr, value) {
	var data = (looksLikeOptions(value) ? value.context : value) || this;
	return function setData(el) {
		//!steal-remove-start
		dev.warn('The {{data}} helper has been deprecated; use {{domData}} instead: https://canjs.com/doc/can-stache.helpers.domData.html');
		//!steal-remove-end
		canDomDataState_1_0_1_canDomDataState.set.call( el, attr, data );
	};
};

var domDataHelper = function(attr, value) {
	var data = (looksLikeOptions(value) ? value.context : value) || this;
	return function setDomData(el) {
		canDomData_1_0_1_canDomData.set( el, attr, data );
	};
};

var switchHelper = function(expression, options){
	resolve(expression);
	var found = false;

	var caseHelper = function(value, options) {
		if(!found && resolve(expression) === resolve(value)) {
			found = true;
			return options.fn(options.scope.peek('this') || this);
		}
	};
	caseHelper.requiresOptionsArgument = true;

	// create default helper as a value-like function
	// so that either {{#default}} or {{#default()}} will work
	var defaultHelper = function(options) {
		if (!found) {
			return options ? options.scope.peek('this') : true;
		}
	};
	defaultHelper.requiresOptionsArgument = true;
	canReflect_1_16_7_canReflect.assignSymbols(defaultHelper, {
		"can.isValueLike": true,
		"can.isFunctionLike": false,
		"can.getValue": function() {
			// pass the helperOptions passed to {{#switch}}
			return this(options);
		}
	});

	var newScope = options.scope.add({
		case: caseHelper,
		default: defaultHelper
	}, { notContext: true });

	return options.fn(newScope, options);
};
switchHelper.requiresOptionsArgument = true;

var joinBaseHelper = function(firstExpr/* , expr... */){
	var args = [].slice.call(arguments);
	var options = args.pop();

	var moduleReference = args.map( function(expr){
		var value = resolve(expr);
		return typeof value === "function" ? value() : value;
	}).join("");

	var templateModule = canReflect_1_16_7_canReflect.getKeyValue(options.scope.templateContext.helpers, 'module');
	var parentAddress = templateModule ? templateModule.uri: undefined;

	var isRelative = moduleReference[0] === ".";

	if(isRelative && parentAddress) {
		return canJoinUris_1_0_0_canJoinUris(parentAddress, moduleReference);
	} else {
		var baseURL = (typeof System !== "undefined" &&
			(System.renderingBaseURL || System.baseURL)) ||	baseUrl();

		// Make sure one of them has a needed /
		if(moduleReference[0] !== "/" && baseURL[baseURL.length - 1] !== "/") {
			baseURL += "/";
		}

		return canJoinUris_1_0_0_canJoinUris(baseURL, moduleReference);
	}
};
joinBaseHelper.requiresOptionsArgument = true;

var builtInHelpers = {
	'debugger': debuggerHelper$1,
	each: eachHelper,
	eachOf: eachHelper,
	index: indexHelper,
	'if': ifHelper,
	is: isHelper,
	eq: isHelper,
	unless: unlessHelper,
	'with': withHelper,
	console: console,
	data: dataHelper,
	domData: domDataHelper,
	'switch': switchHelper,
	joinBase: joinBaseHelper,

};

var addBuiltInHelpers = function() {
	canReflect_1_16_7_canReflect.each(builtInHelpers, function(helper, helperName) {
		canStacheHelpers_1_0_0_canStacheHelpers[helperName] = helper;
	});
};

// add all the built-in helpers when stache is loaded
addBuiltInHelpers();

var registerHelper = function(name, callback){
	//!steal-remove-start
	if (canStacheHelpers_1_0_0_canStacheHelpers[name]) {
		dev.warn('The helper ' + name + ' has already been registered.');
	}
	//!steal-remove-end

	// mark passed in helper so it will be automatically passed
	// helperOptions (.fn, .inverse, etc) when called as Call Expressions
	callback.requiresOptionsArgument = true;

	// store on global helpers list
	canStacheHelpers_1_0_0_canStacheHelpers[name] = callback;
};

var makeSimpleHelper = function(fn) {
	return function() {
		var realArgs = [];
		canReflect_1_16_7_canReflect.eachIndex(arguments, function(val) {
			while (val && val.isComputed) {
				val = val();
			}
			realArgs.push(val);
		});
		return fn.apply(this, realArgs);
	};
};

var core$2 = {
	registerHelper: registerHelper,

	addHelper: function(name, callback) {
		return registerHelper(name, makeSimpleHelper(callback));
	},

	// add helpers that set up their own internal live-binding
	// these helpers will not be wrapped in computes and will
	// receive observable arguments when called with Call Expressions
	addLiveHelper: function(name, callback) {
		callback.isLiveBound = true;
		return registerHelper(name, callback);
	},

	getHelper: function(name, scope) {
		var helper = scope && scope.getHelper(name);

		if (!helper) {
			helper = canStacheHelpers_1_0_0_canStacheHelpers[name];
		}

		return helper;
	},

	resolve: resolve,
	resolveHash: resolveHash,
	looksLikeOptions: looksLikeOptions,
	__resetHelpers: function() {
		// remove all helpers from can-stache-helpers object
		for (var helper in canStacheHelpers_1_0_0_canStacheHelpers) {
			delete canStacheHelpers_1_0_0_canStacheHelpers[helper];
		}

		addBuiltInHelpers();
	}
};

function makeConverter(getterSetter){
	getterSetter = getterSetter || {};
	return function(newVal, source) {
		var args = canReflect_1_16_7_canReflect.toArray(arguments);
		if(newVal instanceof setIdentifier) {
			return typeof getterSetter.set === "function" ?
				getterSetter.set.apply(this, [newVal.value].concat(args.slice(1))) :
				source(newVal.value);
		} else {
			return typeof getterSetter.get === "function" ?
				getterSetter.get.apply(this, args) :
				args[0];
		}
	};
}

core$2.addConverter = function(name, getterSetter) {
	var helper = makeConverter(getterSetter);
	helper.isLiveBound = true;
	core$2.registerHelper(name, helper );
};

core$2.registerConverter = function(name, getterSetter) {
	core$2.registerHelper(name, makeConverter(getterSetter) );
};

var mustacheLineBreakRegExp$1 = /(?:(^|\r?\n)(\s*)(\{\{([\s\S]*)\}\}\}?)([^\S\n\r]*)($|\r?\n))|(\{\{([\s\S]*)\}\}\}?)/g,
	mustacheWhitespaceRegExp$1 = /(\s*)(\{\{\{?)(-?)([\s\S]*?)(-?)(\}\}\}?)(\s*)/g;

function splitModeFromExpression$1(expression, state){
	expression = expression.trim();
	var mode = expression.charAt(0);

	if( "#/{&^>!<".indexOf(mode) >= 0 ) {
		expression =  expression.substr(1).trim();
	} else {
		mode = null;
	}
	// Triple braces do nothing within a tag.
	if(mode === "{" && state.node) {
		mode = null;
	}
	return {
		mode: mode,
		expression: expression
	};
}

function cleanLineEndings(template) {
		// Finds mustache tags with space around them or no space around them.
		return template.replace( mustacheLineBreakRegExp$1,
			function(whole,
				returnBefore,
				spaceBefore,
				special,
				expression,
				spaceAfter,
				returnAfter,
				// A mustache magic tag that has no space around it.
				spaceLessSpecial,
				spaceLessExpression,
				matchIndex){

			// IE 8 will provide undefined
			spaceAfter = (spaceAfter || "");
			returnBefore = (returnBefore || "");
			spaceBefore = (spaceBefore || "");

			var modeAndExpression = splitModeFromExpression$1(expression || spaceLessExpression,{});

			// If it's a partial or tripple stache, leave in place.
			if(spaceLessSpecial || ">{".indexOf( modeAndExpression.mode) >= 0) {
				return whole;
			}  else if( "^#!/".indexOf(  modeAndExpression.mode ) >= 0 ) {
				// Return the magic tag and a trailing linebreak if this did not
				// start a new line and there was an end line.
				// Add a normalized leading space, if there was any leading space, in case this abuts a tag name
				spaceBefore = (returnBefore + spaceBefore) && " ";
				return spaceBefore+special+( matchIndex !== 0 && returnAfter.length ? returnBefore+"\n" :"");


			} else {
				// There is no mode, return special with spaces around it.
				return spaceBefore+special+spaceAfter+(spaceBefore.length || matchIndex !== 0 ? returnBefore+"\n" : "");
			}
		});
}

function whiteSpaceReplacement(
	whole,
	spaceBefore,
	bracketBefore,
	controlBefore,
	expression,
	controlAfter,
	bracketAfter,
	spaceAfter
) {

	if (controlBefore === '-') {
		spaceBefore = '';
	}

	if (controlAfter === '-') {
		spaceAfter = '';
	}

	return spaceBefore + bracketBefore + expression + bracketAfter + spaceAfter;
}

function cleanWhitespaceControl(template) {
	return template.replace(mustacheWhitespaceRegExp$1, whiteSpaceReplacement);
}

var cleanLineEndings_1 = cleanLineEndings;
var cleanWhitespaceControl_1 = cleanWhitespaceControl;

var canStacheAst_1_0_0_controls = {
	cleanLineEndings: cleanLineEndings_1,
	cleanWhitespaceControl: cleanWhitespaceControl_1
};

var parse$1 = function(filename, source){
	if (arguments.length === 1) {
		source = arguments[0];
		filename = undefined;
	}

	var template = source;
	template = canStacheAst_1_0_0_controls.cleanWhitespaceControl(template);
	template = canStacheAst_1_0_0_controls.cleanLineEndings(template);

	var imports = [],
		dynamicImports = [],
		importDeclarations = [],
		ases = {},
		inImport = false,
		inFrom = false,
		inAs = false,
		isUnary = false,
		importIsDynamic = false,
		currentAs = "",
		currentFrom = "";

	function processImport(line) {
		if(currentAs) {
			ases[currentAs] = currentFrom;
			currentAs = "";
		}
		if(importIsDynamic) {
			dynamicImports.push(currentFrom);
		} else {
			imports.push(currentFrom);
		}
		importDeclarations.push({
			specifier: currentFrom,
			loc: {
				line: line
			}
		});
	}

	var program = canViewParser_4_0_2_canViewParser(template, {
		filename: filename,
		start: function( tagName, unary ){
			if(tagName === "can-import") {
				isUnary = unary;
				importIsDynamic = false; // assume static import unless there is content (chars/tags/special).
				inImport = true;
			} else if(tagName === "can-dynamic-import") {
				isUnary = unary;
				importIsDynamic = true;
				inImport = true;
			} else if(inImport) {
				importIsDynamic = true;  // found content inside can-import tag.
				inImport = false;
			}
		},
		attrStart: function( attrName ){
			if(attrName === "from") {
				inFrom = true;
			} else if(attrName === "as" || attrName === "export-as") {
				inAs = true;
			}
		},
		attrEnd: function( attrName ){
			if(attrName === "from") {
				inFrom = false;
			} else if(attrName === "as" || attrName === "export-as") {
				inAs = false;
			}
		},
		attrValue: function( value ){
			if(inFrom && inImport) {
				currentFrom = value;
			} else if(inAs && inImport) {
				currentAs = value;
			}
		},
		end: function(tagName, unary, line){
			if((tagName === "can-import" || tagName === "can-dynamic-import") && isUnary) {
				processImport(line);
			}
		},
		close: function(tagName, unary, line){
			if((tagName === "can-import" || tagName === "can-dynamic-import")) {
				processImport(line);
			}
		},
		chars: function(text) {
			if(text.trim().length > 0) {
				importIsDynamic = true;
			}
		},
		special: function() {
			importIsDynamic = true;
		}
	}, true);

	return {
		intermediate: program,
		program: program,
		imports: imports,
		dynamicImports: dynamicImports,
		importDeclarations: importDeclarations,
		ases: ases,
		exports: ases
	};
};

var canStacheAst_1_0_0_canStacheAst = {
	parse: parse$1
};

/**
 * @module {function} can-util/js/import/import import
 * @parent can-util/js
 * @signature `importModule(moduleName, parentName)`
 *
 * ```js
 * var importModule = require("can-util/js/import/import");
 *
 * importModule("foo.stache").then(function(){
 *   // module was imported
 * });
 * ```
 *
 * @param {String} moduleName The module to be imported.
 * @param {String} [parentName] A parent module that will be used as a reference for resolving relative module imports.
 * @return {Promise} A Promise that will resolve when the module has been imported.
 */

var canImportModule_1_0_0_canImportModule = canNamespace_1_0_0_canNamespace.import = function(moduleName, parentName) {
	return new Promise(function(resolve, reject) {
		try {
			var global = global_1();
			if(typeof global.System === "object" && isFunction$1(global.System["import"])) {
				global.System["import"](moduleName, {
					name: parentName
				}).then(resolve, reject);
			} else if(global.define && global.define.amd){
				global.require([moduleName], function(value){
					resolve(value);
				});
			} else if(global.require){
				resolve(global.require(moduleName));
			} else {
				// steal optimized build
				if (typeof stealRequire !== "undefined") {
					steal.import(moduleName, { name: parentName }).then(resolve, reject);
				} else {
					// ideally this will use can.getObject
					resolve();
				}
			}
		} catch(err) {
			reject(err);
		}
	});
};

function isFunction$1(fn) {
	return typeof fn === "function";
}

/* jshint undef: false */









var getIntermediateAndImports = canStacheAst_1_0_0_canStacheAst.parse;

var makeRendererConvertScopes = utils$1.makeRendererConvertScopes;
var last$2 = utils$1.last;








// Make sure that we can also use our modules with Stache as a plugin




if(!canViewCallbacks_4_1_2_canViewCallbacks.tag("content")) {
	// This was moved from the legacy view/scanner.js to here.
	// This makes sure content elements will be able to have a callback.
	canViewCallbacks_4_1_2_canViewCallbacks.tag("content", function(el, tagData) {
		return tagData.scope;
	});
}

var wrappedAttrPattern = /[{(].*[)}]/;
var colonWrappedAttrPattern = /^on:|(:to|:from|:bind)$|.*:to:on:.*/;
var svgNamespace = "http://www.w3.org/2000/svg";
var namespaces = {
	"svg": svgNamespace,
	// this allows a partial to start with g.
	"g": svgNamespace
},
	textContentOnlyTag = {style: true, script: true};

function stache (filename, template) {
	if (arguments.length === 1) {
		template = arguments[0];
		filename = undefined;
	}

	var inlinePartials = {};

	// Remove line breaks according to mustache's specs.
	if(typeof template === "string") {
		template = mustache_core.cleanWhitespaceControl(template);
		template = mustache_core.cleanLineEndings(template);
	}

	// The HTML section that is the root section for the entire template.
	var section = new html_section(filename),
		// Tracks the state of the parser.
		state = {
			node: null,
			attr: null,
			// A stack of which node / section we are in.
			// There is probably a better way of doing this.
			sectionElementStack: [],
			// If text should be inserted and HTML escaped
			text: false,
			// which namespace we are in
			namespaceStack: [],
			// for style and script tags
			// we create a special TextSectionBuilder and add things to that
			// when the element is done, we compile the text section and
			// add it as a callback to `section`.
			textContentOnly: null

		},

		// This function is a catch all for taking a section and figuring out
		// how to create a "renderer" that handles the functionality for a
		// given section and modify the section to use that renderer.
		// For example, if an HTMLSection is passed with mode `#` it knows to
		// create a liveBindingBranchRenderer and pass that to section.add.
		makeRendererAndUpdateSection = function(section, mode, stache, lineNo){

			if(mode === ">") {
				// Partials use liveBindingPartialRenderers
				section.add(mustache_core.makeLiveBindingPartialRenderer(stache, copyState({ filename: section.filename, lineNo: lineNo })));

			} else if(mode === "/") {

				var createdSection = section.last();
				if ( createdSection.startedWith === "<" ) {
					inlinePartials[ stache ] = section.endSubSectionAndReturnRenderer();
					section.removeCurrentNode();
				} else {
					section.endSection();
				}

				if(section instanceof html_section) {
					//!steal-remove-start
					var last = state.sectionElementStack[state.sectionElementStack.length - 1];
					if (last.tag && last.type === "section" && stache !== "" && stache !== last.tag) {
						if (filename) {
							dev.warn(filename + ":" + lineNo + ": unexpected closing tag {{/" + stache + "}} expected {{/" + last.tag + "}}");
						}
						else {
							dev.warn(lineNo + ": unexpected closing tag {{/" + stache + "}} expected {{/" + last.tag + "}}");
						}
					}
					//!steal-remove-end

					state.sectionElementStack.pop();
				}
			} else if(mode === "else") {

				section.inverse();

			} else {

				// If we are an HTMLSection, we will generate a
				// a LiveBindingBranchRenderer; otherwise, a StringBranchRenderer.
				// A LiveBindingBranchRenderer function processes
				// the mustache text, and sets up live binding if an observable is read.
				// A StringBranchRenderer function processes the mustache text and returns a
				// text value.
				var makeRenderer = section instanceof html_section ?
					mustache_core.makeLiveBindingBranchRenderer:
					mustache_core.makeStringBranchRenderer;

				if(mode === "{" || mode === "&") {

					// Adds a renderer function that just reads a value or calls a helper.
					section.add(makeRenderer(null,stache, copyState({ filename: section.filename, lineNo: lineNo })));

				} else if(mode === "#" || mode === "^" || mode === "<") {
					// Adds a renderer function and starts a section.
					var renderer = makeRenderer(mode, stache, copyState({ filename: section.filename, lineNo: lineNo }));
					section.startSection(renderer);
					section.last().startedWith = mode;

					// If we are a directly nested section, count how many we are within
					if(section instanceof html_section) {
						//!steal-remove-start
						var tag = typeof renderer.exprData.closingTag === 'function' ?
							renderer.exprData.closingTag() : '';
						//!steal-remove-end

						state.sectionElementStack.push({
							type: "section",
							//!steal-remove-start
							tag: tag
							//!steal-remove-end
						});
					}
				} else {
					// Adds a renderer function that only updates text.
					section.add(makeRenderer(null, stache, copyState({text: true, filename: section.filename, lineNo: lineNo })));
				}

			}
		},
		isDirectlyNested = function() {
			var lastElement = state.sectionElementStack[state.sectionElementStack.length - 1];
			return state.sectionElementStack.length ?
				lastElement.type === "section" || lastElement.type === "custom": true;
		},
		// Copys the state object for use in renderers.
		copyState = function(overwrites){

			var cur = {
				tag: state.node && state.node.tag,
				attr: state.attr && state.attr.name,
				// <content> elements should be considered direclty nested
				directlyNested: isDirectlyNested(),
				textContentOnly: !!state.textContentOnly
			};
			return overwrites ? canAssign_1_1_1_canAssign(cur, overwrites) : cur;
		},
		addAttributesCallback = function(node, callback){
			if( !node.attributes ) {
				node.attributes = [];
			}
			node.attributes.unshift(callback);
		};

	canViewParser_4_0_2_canViewParser(template, {
		filename: filename,
		start: function(tagName, unary, lineNo){
			var matchedNamespace = namespaces[tagName];

			if (matchedNamespace && !unary ) {
				state.namespaceStack.push(matchedNamespace);
			}

			// either add templates: {} here or check below and decorate
			// walk up the stack/targetStack until you find the first node
			// with a templates property, and add the popped renderer
			state.node = {
				tag: tagName,
				children: [],
				namespace: matchedNamespace || last$2(state.namespaceStack)
			};
		},
		end: function(tagName, unary, lineNo){
			var isCustomTag =  canViewCallbacks_4_1_2_canViewCallbacks.tag(tagName);
			var directlyNested = isDirectlyNested();
			if(unary){
				// If it's a custom tag with content, we need a section renderer.
				section.add(state.node);
				if(isCustomTag) {
					// Call directlyNested now as it's stateful.
					addAttributesCallback(state.node, function(scope, parentNodeList){
						//!steal-remove-start
						scope.set('scope.lineNumber', lineNo);
						//!steal-remove-end
						canViewCallbacks_4_1_2_canViewCallbacks.tagHandler(this,tagName, {
							scope: scope,
							subtemplate: null,
							templateType: "stache",
							parentNodeList: parentNodeList,
							directlyNested: directlyNested
						});
					});
				}
			} else {
				section.push(state.node);

				state.sectionElementStack.push({
					type: isCustomTag ? "custom" : null,
					tag: isCustomTag ? null : tagName,
					templates: {},
					directlyNested: directlyNested
				});

				// If it's a custom tag with content, we need a section renderer.
				if( isCustomTag ) {
					section.startSubSection();
				} else if(textContentOnlyTag[tagName]) {
					state.textContentOnly = new text_section();
				}
			}


			state.node =null;

		},
		close: function(tagName, lineNo) {
			var matchedNamespace = namespaces[tagName];

			if (matchedNamespace  ) {
				state.namespaceStack.pop();
			}

			var isCustomTag = canViewCallbacks_4_1_2_canViewCallbacks.tag(tagName),
				renderer;

			if( isCustomTag ) {
				renderer = section.endSubSectionAndReturnRenderer();
			}

			if(textContentOnlyTag[tagName]) {
				section.last().add(state.textContentOnly.compile(copyState()));
				state.textContentOnly = null;
			}

			var oldNode = section.pop();
			if( isCustomTag ) {
				if (tagName === "can-template") {
					// If we find a can-template we want to go back 2 in the stack to get it's inner content
					// rather than the <can-template> element itself
					var parent = state.sectionElementStack[state.sectionElementStack.length - 2];
					if (renderer) {// Only add the renderer if the template has content
						parent.templates[oldNode.attrs.name] = makeRendererConvertScopes(renderer);
					}
					section.removeCurrentNode();
				} else {
					// Get the last element in the stack
					var current = state.sectionElementStack[state.sectionElementStack.length - 1];
					addAttributesCallback(oldNode, function(scope, parentNodeList){
						//!steal-remove-start
						scope.set('scope.lineNumber', lineNo);
						//!steal-remove-end
						canViewCallbacks_4_1_2_canViewCallbacks.tagHandler(this,tagName, {
							scope: scope,
							subtemplate: renderer  ? makeRendererConvertScopes(renderer) : renderer,
							templateType: "stache",
							parentNodeList: parentNodeList,
							templates: current.templates,
							directlyNested: current.directlyNested
						});
					});
				}
			}
			state.sectionElementStack.pop();
		},
		attrStart: function(attrName, lineNo){
			if(state.node.section) {
				state.node.section.add(attrName+"=\"");
			} else {
				state.attr = {
					name: attrName,
					value: ""
				};
			}

		},
		attrEnd: function(attrName, lineNo){
			if(state.node.section) {
				state.node.section.add("\" ");
			} else {
				if(!state.node.attrs) {
					state.node.attrs = {};
				}

				state.node.attrs[state.attr.name] =
					state.attr.section ? state.attr.section.compile(copyState()) : state.attr.value;

				var attrCallback = canViewCallbacks_4_1_2_canViewCallbacks.attr(attrName);

				//!steal-remove-start
				var decodedAttrName = canAttributeEncoder_1_0_5_canAttributeEncoder.decode(attrName);
				var weirdAttribute = !!wrappedAttrPattern.test(decodedAttrName) || !!colonWrappedAttrPattern.test(decodedAttrName);
				if (weirdAttribute && !attrCallback) {
					dev.warn("unknown attribute binding " + decodedAttrName + ". Is can-stache-bindings imported?");
				}
				//!steal-remove-end

				if(attrCallback) {
					if( !state.node.attributes ) {
						state.node.attributes = [];
					}
					state.node.attributes.push(function(scope, nodeList){
						//!steal-remove-start
						scope.set('scope.lineNumber', lineNo);
						//!steal-remove-end
						attrCallback(this,{
							attributeName: attrName,
							scope: scope,
							nodeList: nodeList
						});
					});
				}

				state.attr = null;
			}
		},
		attrValue: function(value, lineNo){
			var section = state.node.section || state.attr.section;
			if(section){
				section.add(value);
			} else {
				state.attr.value += value;
			}
		},
		chars: function(text, lineNo) {
			(state.textContentOnly || section).add(text);
		},
		special: function(text, lineNo){
			var firstAndText = mustache_core.splitModeFromExpression(text, state),
				mode = firstAndText.mode,
				expression = firstAndText.expression;


			if(expression === "else") {
				var inverseSection;
				if(state.attr && state.attr.section) {
					inverseSection = state.attr.section;
				} else if(state.node && state.node.section ) {
					inverseSection = state.node.section;
				} else {
					inverseSection = state.textContentOnly || section;
				}
				inverseSection.inverse();
				return;
			}

			if(mode === "!") {
				return;
			}

			if(state.node && state.node.section) {

				makeRendererAndUpdateSection(state.node.section, mode, expression, lineNo);

				if(state.node.section.subSectionDepth() === 0){
					state.node.attributes.push( state.node.section.compile(copyState()) );
					delete state.node.section;
				}

			}
			// `{{}}` in an attribute like `class="{{}}"`
			else if(state.attr) {

				if(!state.attr.section) {
					state.attr.section = new text_section();
					if(state.attr.value) {
						state.attr.section.add(state.attr.value);
					}
				}
				makeRendererAndUpdateSection(state.attr.section, mode, expression, lineNo);

			}
			// `{{}}` in a tag like `<div {{}}>`
			else if(state.node) {

				if(!state.node.attributes) {
					state.node.attributes = [];
				}
				if(!mode) {
					state.node.attributes.push(mustache_core.makeLiveBindingBranchRenderer(null, expression, copyState({ filename: section.filename, lineNo: lineNo })));
				} else if( mode === "#" || mode === "^" ) {
					if(!state.node.section) {
						state.node.section = new text_section();
					}
					makeRendererAndUpdateSection(state.node.section, mode, expression, lineNo);
				} else {
					throw new Error(mode+" is currently not supported within a tag.");
				}
			}
			else {
				makeRendererAndUpdateSection(state.textContentOnly || section, mode, expression, lineNo);
			}
		},
		comment: function(text) {
			// create comment node
			section.add({
				comment: text
			});
		},
		done: function(lineNo){}
	});

	var renderer = section.compile();
	var scopifiedRenderer = html_section.scopify(function( scope, nodeList ) {
		var templateContext = scope.templateContext;

		canReflect_1_16_7_canReflect.eachKey(inlinePartials, function(partial, partialName) {
			canReflect_1_16_7_canReflect.setKeyValue(templateContext.partials, partialName, partial);
		});

		// allow the current renderer to be called with {{>scope.view}}
		canReflect_1_16_7_canReflect.setKeyValue(templateContext, 'view', scopifiedRenderer);
		//!steal-remove-start
		canReflect_1_16_7_canReflect.setKeyValue(templateContext, 'filename', section.filename);
		//!steal-remove-end

		return renderer.apply( this, arguments );
	});
	return scopifiedRenderer;
}

// At this point, can.stache has been created
canAssign_1_1_1_canAssign(stache, core$2);

stache.safeString = function(text){
	return {
		toString: function () {
			return text;
		}
	};
};
stache.async = function(source){
	var iAi = getIntermediateAndImports(source);
	var importPromises = iAi.imports.map(function(moduleName){
		return canImportModule_1_0_0_canImportModule(moduleName);
	});
	return Promise.all(importPromises).then(function(){
		return stache(iAi.intermediate);
	});
};
var templates = {};
stache.from = mustache_core.getTemplateById = function(id){
	if(!templates[id]) {
		var el = document$1().getElementById(id);
		if(el) {
			templates[id] = stache("#" + id, el.innerHTML);
		}
	}
	return templates[id];
};

stache.registerPartial = function(id, partial) {
	templates[id] = (typeof partial === "string" ? stache(partial) : partial);
};

var canStache_4_5_10_canStache = canNamespace_1_0_0_canNamespace.stache = stache;

var viewModelSymbol = canSymbol_1_6_1_canSymbol.for('can.viewModel');

var canViewModel_4_0_1_canViewModel = canNamespace_1_0_0_canNamespace.viewModel = function (el, attr, val) {
	if (typeof el === "string") {
		el = document$1().querySelector(el);
	} else if (canReflect_1_16_7_canReflect.isListLike(el) && !el.nodeType) {
		el = el[0];
	}

	if (canReflect_1_16_7_canReflect.isObservableLike(attr) && canReflect_1_16_7_canReflect.isMapLike(attr)) {
		el[viewModelSymbol] = attr;
		return;
	}

	var scope = el[viewModelSymbol];
	if(!scope) {
		scope = new canSimpleMap_4_1_1_canSimpleMap();
		el[viewModelSymbol] = scope;
	}
	switch (arguments.length) {
		case 0:
		case 1:
			return scope;
		case 2:
			return canReflect_1_16_7_canReflect.getKeyValue(scope, attr);
		default:
			canReflect_1_16_7_canReflect.setKeyValue(scope, attr, val);
			return el;
	}
};

var isDomEventTarget$2 = util.isDomEventTarget;

var canEvent = {
	on: function on(eventName, handler, queue) {
		if (isDomEventTarget$2(this)) {
			canDomEvents_1_2_0_canDomEvents.addEventListener(this, eventName, handler, queue);
		} else {
			canReflect_1_16_7_canReflect.onKeyValue(this, eventName, handler, queue);
		}
	},
	off: function off(eventName, handler, queue) {
		if (isDomEventTarget$2(this)) {
			canDomEvents_1_2_0_canDomEvents.removeEventListener(this, eventName, handler, queue);
		} else {
			canReflect_1_16_7_canReflect.offKeyValue(this, eventName, handler, queue);
		}
	},
	one: function one(event, handler, queue) {
		// Unbind the listener after it has been executed
		var one = function() {
			canEvent.off.call(this, event, one, queue);
			return handler.apply(this, arguments);
		};

		// Bind the altered listener
		canEvent.on.call(this, event, one, queue);
		return this;
	}
};

var canAttributeObservable_0_3_1_event = canEvent;

var isRadioInput = function isRadioInput(el) {
	return el.nodeName.toLowerCase() === "input" && el.type === "radio";
};

var isValidProp = function isValidProp(prop, bindingData) {
	return prop === "checked" && !bindingData.legacyBindings;
};

// Determine the event or events we need to listen to when this value changes.
var canAttributeObservable_0_3_1_getEventName = function getEventName(el, prop, bindingData) {
	var event = "change";

	if (isRadioInput(el) && isValidProp(prop, bindingData)) {
		event = "can-attribute-observable-radiochange";
	}

	if (canAttributeObservable_0_3_1_behaviors.findSpecialListener(prop)) {
		event = prop;
	}

	return event;
};

function getRoot () {
	return document$1().documentElement;
}

function findParentForm (el) {
	while (el) {
		if (el.nodeName === 'FORM') {
			break;
		}
		el = el.parentNode;
	}
	return el;
}

function shouldReceiveEventFromRadio (source, dest) {
	// Must have the same name attribute and parent form
	var name = source.getAttribute('name');
	return (
		name &&
		name === dest.getAttribute('name') &&
		findParentForm(source) === findParentForm(dest)
	);
}

function isRadioInput$1 (el) {
	return el.nodeName === 'INPUT' && el.type === 'radio';
}


function attachRootListener (domEvents, eventTypeTargets) {
	var root = getRoot();
	var newListener = function (event) {
		var target = event.target;
		if (!isRadioInput$1(target)) {
			return;
		}

		for (var eventType in eventTypeTargets) {
			var newEvent = {type: eventType};
			var listeningNodes = eventTypeTargets[eventType];
			listeningNodes.forEach(function (el) {
				if (shouldReceiveEventFromRadio(target, el)) {
					domEvents.dispatch(el, newEvent, false);
				}
			});
		}
	};
	domEvents.addEventListener(root, 'change', newListener);
	return newListener;
}

function detachRootListener (domEvents, listener) {
	var root = getRoot();
	domEvents.removeEventListener(root, 'change', listener);
}

/**
 * @module {events} can-event-dom-radiochange
 * @parent can-dom-utilities
 * @collection can-infrastructure
 * @package ./package.json
 *
 * A custom event for listening to changes of inputs with type "radio",
 * which fires when a conflicting radio input changes. A "conflicting"
 * radio button has the same "name" attribute and exists within in the
 * same form, or lack thereof. This event coordinates state bound to
 * whether a radio is checked. The "change" event does not fire for deselected
 * radios. By using this event instead, deselected radios receive notification.
 *
 * ```js
 * var domEvents = require('can-dom-events');
 * var radioChange = require('can-event-dom-radiochange');
 * domEvents.addEvent(radioChange);
 *
 * var target = document.createElement('input');
 *
 * function handler () {
 * 	console.log('radiochange event fired');
 * }
 *
 * domEvents.addEventListener(target, 'radiochange', handler);
 * domEvents.removeEventListener(target, 'radiochange', handler);
 * ```
 */
var radioChangeEvent = {
	defaultEventType: 'radiochange',

	addEventListener: function (target, eventType, handler) {
		if (!isRadioInput$1(target)) {
			throw new Error('Listeners for ' + eventType + ' must be radio inputs');
		}

		var eventTypeTrackedRadios = radioChangeEvent._eventTypeTrackedRadios;
		if (!eventTypeTrackedRadios) {
			eventTypeTrackedRadios = radioChangeEvent._eventTypeTrackedRadios = {};
			if (!radioChangeEvent._rootListener) {
				radioChangeEvent._rootListener = attachRootListener(this, eventTypeTrackedRadios);
			}			
		}

		var trackedRadios = radioChangeEvent._eventTypeTrackedRadios[eventType];
		if (!trackedRadios) {
			trackedRadios = radioChangeEvent._eventTypeTrackedRadios[eventType] = new Set();
		}

		trackedRadios.add(target);
		target.addEventListener(eventType, handler);
	},

	removeEventListener: function (target, eventType, handler) {
		target.removeEventListener(eventType, handler);

		var eventTypeTrackedRadios = radioChangeEvent._eventTypeTrackedRadios;
		if (!eventTypeTrackedRadios) {
			return;
		}

		var trackedRadios = eventTypeTrackedRadios[eventType];
		if (!trackedRadios) {
			return;
		}
	
		trackedRadios.delete(target);
		if (trackedRadios.size === 0) {
			delete eventTypeTrackedRadios[eventType];
			for (var key in eventTypeTrackedRadios) {
				if (eventTypeTrackedRadios.hasOwnProperty(key)) {
					return;
				}						
			}
			delete radioChangeEvent._eventTypeTrackedRadios;
			detachRootListener(this, radioChangeEvent._rootListener);
			delete radioChangeEvent._rootListener;
		}
	}
};

var canEventDomRadiochange_2_1_0_canEventDomRadiochange = canNamespace_1_0_0_canNamespace.domEventRadioChange = radioChangeEvent;

// We register a namespaced radiochange event with the global
// event registry so it does not interfere with user-defined events.


var internalRadioChangeEventType = "can-attribute-observable-radiochange";
canDomEvents_1_2_0_canDomEvents.addEvent(canEventDomRadiochange_2_1_0_canEventDomRadiochange, internalRadioChangeEventType);

var isSelect = function isSelect(el) {
	return el.nodeName.toLowerCase() === "select";
};

var isMultipleSelect = function isMultipleSelect(el, prop) {
	return isSelect(el) && prop === "value" && el.multiple;
};

var slice$4 = Array.prototype.slice;

function canUtilAEL () {
	var args = slice$4.call(arguments, 0);
	args.unshift(this);
	return canDomEvents_1_2_0_canDomEvents.addEventListener.apply(null, args);
}

function canUtilREL () {
	var args = slice$4.call(arguments, 0);
	args.unshift(this);
	return canDomEvents_1_2_0_canDomEvents.removeEventListener.apply(null, args);
}

function AttributeObservable(el, prop, bindingData, event) {
	this.el = el;
	this.bound = false;
	this.bindingData = bindingData;
	this.prop = isMultipleSelect(el, prop) ? "values" : prop;
	this.event = event || canAttributeObservable_0_3_1_getEventName(el, prop, bindingData);
	this.handler = this.handler.bind(this);

	//!steal-remove-start
	// register what changes the element's attribute
	canReflectDependencies_1_0_2_canReflectDependencies.addMutatedBy(this.el, this.prop, this);

	canReflect_1_16_7_canReflect.assignSymbols(this, {
		"can.getName": function getName() {
			return (
				"AttributeObservable<" +
				el.nodeName.toLowerCase() +
				"." +
				this.prop +
				">"
			);
		}
	});
	//!steal-remove-end
}

AttributeObservable.prototype = Object.create(settable$1.prototype);

Object.assign(AttributeObservable.prototype, {
	constructor: AttributeObservable,

	get: function get() {
		if (canObservationRecorder_1_1_2_canObservationRecorder.isRecording()) {
			canObservationRecorder_1_1_2_canObservationRecorder.add(this);
			if (!this.bound) {
				canObservation_4_0_1_canObservation.temporarilyBind(this);
			}
		}
		return canAttributeObservable_0_3_1_behaviors.get(this.el, this.prop);
	},

	set: function set(newVal) {
		canAttributeObservable_0_3_1_behaviors.setAttrOrProp(this.el, this.prop, newVal);

		// update the observation internal value
		this.value = newVal;

		return newVal;
	},

	handler: function handler(newVal, event) {
		var old = this.value;
		this.value = canAttributeObservable_0_3_1_behaviors.get(this.el, this.prop);

		if (this.value !== old) {
			//!steal-remove-start
			if (typeof this._log === "function") {
				this._log(old, newVal);
			}
			//!steal-remove-end

			// adds callback handlers to be called w/i their respective queue.
			canQueues_1_1_0_canQueues.enqueueByQueue(
				this.handlers.getNode([]),
				this,
				[newVal, old]
				//!steal-remove-start
				/* jshint laxcomma: true */
				,null, [this.el,this.prop,"changed to", newVal, "from", old, "by", event]
				/* jshint laxcomma: false */
				//!steal-remove-end
			);
		}
	},

	onBound: function onBound() {
		var observable = this;

		observable.bound = true;

		// make sure `this.handler` gets the new value instead of
		// the event object passed to the event handler
		observable._handler = function(event) {
			observable.handler(canAttributeObservable_0_3_1_behaviors.get(observable.el, observable.prop), event);
		};

		if (observable.event === internalRadioChangeEventType) {
			canAttributeObservable_0_3_1_event.on.call(observable.el, "change", observable._handler);
		}

		var specialBinding = canAttributeObservable_0_3_1_behaviors.findSpecialListener(observable.prop);
		if (specialBinding) {
			observable._specialDisposal = specialBinding.call(observable.el, observable.prop, observable._handler, canUtilAEL);
		}

		canAttributeObservable_0_3_1_event.on.call(observable.el, observable.event, observable._handler);

		// initial value
		this.value = canAttributeObservable_0_3_1_behaviors.get(this.el, this.prop);
	},

	onUnbound: function onUnbound() {
		var observable = this;

		observable.bound = false;

		if (observable.event === internalRadioChangeEventType) {
			canAttributeObservable_0_3_1_event.off.call(observable.el, "change", observable._handler);
		}

		if (observable._specialDisposal) {
			observable._specialDisposal.call(observable.el, canUtilREL);
			observable._specialDisposal = null;
		}

		canAttributeObservable_0_3_1_event.off.call(observable.el, observable.event, observable._handler);
	},

	valueHasDependencies: function valueHasDependencies() {
		return true;
	},

	getValueDependencies: function getValueDependencies() {
		return {
			keyDependencies: new Map([[this.el, new Set([this.prop])]])
		};
	}
});

canReflect_1_16_7_canReflect.assignSymbols(AttributeObservable.prototype, {
	"can.isMapLike": false,
	"can.getValue": AttributeObservable.prototype.get,
	"can.setValue": AttributeObservable.prototype.set,
	"can.onValue": AttributeObservable.prototype.on,
	"can.offValue": AttributeObservable.prototype.off,
	"can.valueHasDependencies": AttributeObservable.prototype.hasDependencies,
	"can.getValueDependencies": AttributeObservable.prototype.getValueDependencies
});

var canAttributeObservable_0_3_1_canAttributeObservable = AttributeObservable;

// # can-stache-bindings.js
//
// This module provides CanJS's default data and event bindings.
// It's broken up into several parts:
//
// - Behaviors - Binding behaviors that run given an attribute or element.
// - Attribute Syntaxes - Hooks up custom attributes to their behaviors.
// - getObservableFrom - Methods that return a observable cross bound to the scope, viewModel, or element.
// - bind - Methods for setting up cross binding
// - getBindingInfo - A helper that returns the details of a data binding given an attribute.
// - makeDataBinding - A helper method for setting up a data binding.
// - initializeValues - A helper that initializes a data binding.






















var noop$3 = function() {};

var onMatchStr = "on:",
	vmMatchStr = "vm:",
	elMatchStr = "el:",
	byMatchStr = ":by:",
	toMatchStr = ":to",
	fromMatchStr = ":from",
	bindMatchStr = ":bind",
	viewModelBindingStr = "viewModel",
	attributeBindingStr = "attribute",
	scopeBindingStr = "scope",
	viewModelOrAttributeBindingStr = "viewModelOrAttribute",
	getValueSymbol$2 = canSymbol_1_6_1_canSymbol.for("can.getValue"),
	onValueSymbol$3 = canSymbol_1_6_1_canSymbol.for("can.onValue"),
	getChangesSymbol$2 = canSymbol_1_6_1_canSymbol.for("can.getChangesDependencyRecord");

var throwOnlyOneTypeOfBindingError = function(){
	throw new Error("can-stache-bindings - you can not have contextual bindings ( this:from='value' ) and key bindings ( prop:from='value' ) on one element.");
};

// This function checks if there bindings that are trying
// to set a property ON the viewModel _conflicting_ with bindings trying to
// set THE viewModel ITSELF.
// If there is a conflict, an error is thrown.
var checkBindingState = function(bindingState, dataBinding) {
	var isSettingOnViewModel = dataBinding.bindingInfo.parentToChild && dataBinding.bindingInfo.child === viewModelBindingStr;
	if(isSettingOnViewModel) {
		var bindingName = dataBinding.bindingInfo.childName;
		var isSettingViewModel = isSettingOnViewModel && ( bindingName === 'this' || bindingName === '.' );

		if( isSettingViewModel ) {
			if(bindingState.isSettingViewModel || bindingState.isSettingOnViewModel) {
				throwOnlyOneTypeOfBindingError();
			} else {
				return {isSettingViewModel: true, initialViewModelData: undefined};
			}
		} else {
			// just setting on viewModel
			if(bindingState.isSettingViewModel) {
				throwOnlyOneTypeOfBindingError();
			} else {
				return {isSettingOnViewModel: true, initialViewModelData: bindingState.initialViewModelData};
			}
		}
	} else {
		return bindingState;
	}
};

// ## Behaviors
var behaviors = {
	// ### bindings.behaviors.viewModel
	// Sets up all of an element's data binding attributes to a "soon-to-be-created"
	// `viewModel`.
	// This is primarily used by `can.Component` to ensure that its
	// `viewModel` is initialized with values from the data bindings as quickly as possible.
	// Component could look up the data binding values itself.  However, that lookup
	// would have to be duplicated when the bindings are established.
	// Instead, this uses the `makeDataBinding` helper, which allows creation of the `viewModel`
	// after scope values have been looked up.
	//
	// - `makeViewModel(initialViewModelData)` - a function that returns the `viewModel`.
	// - `initialViewModelData` any initial data that should already be added to the `viewModel`.
	//
	// Returns:
	// - `function` - a function that tears all the bindings down. Component
	// wants all the bindings active so cleanup can be done during a component being removed.
	viewModel: function(el, tagData, makeViewModel, initialViewModelData, staticDataBindingsOnly) {

		var bindingsSemaphore = {},
			viewModel,
			// Stores callbacks for when the viewModel is created.
			onCompleteBindings = [],
			// Stores what needs to be called when the element is removed
			// to prevent memory leaks.
			onTeardowns = {},
			// Track info about each binding, we need this for binding attributes correctly.
			bindingInfos = {},
			attributeViewModelBindings = canAssign_1_1_1_canAssign({}, initialViewModelData),
			bindingsState = {
				// if we have a binding like {something}="foo"
				isSettingOnViewModel: false,
				// if we have binding like {this}="bar"
				isSettingViewModel: false,
				initialViewModelData: initialViewModelData || {}
			},
			hasDataBinding = false;

		// For each attribute, we start the binding process,
		// and save what's returned to be used when the `viewModel` is created,
		// the element is removed, or the attribute changes values.
		canReflect_1_16_7_canReflect.each(el.attributes || [], function(node) {
			var dataBinding = makeDataBinding(node, el, {
				templateType: tagData.templateType,
				scope: tagData.scope,
				semaphore: bindingsSemaphore,
				getViewModel: function() {
					return viewModel;
				},
				attributeViewModelBindings: attributeViewModelBindings,
				alreadyUpdatedChild: true,
				nodeList: tagData.parentNodeList,
				// force viewModel bindings in cases when it is ambiguous whether you are binding
				// on viewModel or an attribute (:to, :from, :bind)
				favorViewModel: true
			});

			if(dataBinding) {
				bindingsState = checkBindingState(bindingsState, dataBinding);
				hasDataBinding = true;


				// For bindings that change the viewModel,
				if(dataBinding.onCompleteBinding) {
					// save the initial value on the viewModel.
					if(dataBinding.bindingInfo.parentToChild && dataBinding.value !== undefined) {

						if(bindingsState.isSettingViewModel) {
							// the initial data is the context
							bindingsState.initialViewModelData = dataBinding.value;
						} else {
							bindingsState.initialViewModelData[cleanVMName(dataBinding.bindingInfo.childName, tagData.scope)] = dataBinding.value;
						}

					}
					// Save what needs to happen after the `viewModel` is created.
					onCompleteBindings.push(dataBinding.onCompleteBinding);
				}
				onTeardowns[node.name] = dataBinding.onTeardown;
			}
		});
		if(staticDataBindingsOnly && !hasDataBinding) {
			return;
		}
		// Create the `viewModel` and call what needs to happen after `viewModel` is created.
		viewModel = makeViewModel(bindingsState.initialViewModelData, hasDataBinding);

		for(var i = 0, len = onCompleteBindings.length; i < len; i++) {
			onCompleteBindings[i]();
		}

		// Listen to attribute changes and re-initialize
		// the bindings.
		var attributeDisposal;
		if(!bindingsState.isSettingViewModel) {
			attributeDisposal = canDomMutate_1_0_4_canDomMutate.onNodeAttributeChange(el, function (ev) {
				var attrName = ev.attributeName,
					value = el.getAttribute(attrName);

				if( onTeardowns[attrName] ) {
					onTeardowns[attrName]();
				}
				// Parent attribute bindings we always re-setup.
				var parentBindingWasAttribute = bindingInfos[attrName] && bindingInfos[attrName].parent === attributeBindingStr;

				if(value !== null || parentBindingWasAttribute ) {
					var dataBinding = makeDataBinding({name: attrName, value: value}, el, {
						templateType: tagData.templateType,
						scope: tagData.scope,
						semaphore: {},
						getViewModel: function() {
							return viewModel;
						},
						attributeViewModelBindings: attributeViewModelBindings,
						// always update the viewModel accordingly.
						initializeValues: true,
						nodeList: tagData.parentNodeList
					});
					if(dataBinding) {
						// The viewModel is created, so call callback immediately.
						if(dataBinding.onCompleteBinding) {
							dataBinding.onCompleteBinding();
						}
						bindingInfos[attrName] = dataBinding.bindingInfo;
						onTeardowns[attrName] = dataBinding.onTeardown;
					}
				}
			});
		}

		return function() {
			if (attributeDisposal) {
				attributeDisposal();
				attributeDisposal = undefined;
			}
			for(var attrName in onTeardowns) {
				onTeardowns[attrName]();
			}
		};
	},
	// ### bindings.behaviors.data
	// This is called when an individual data binding attribute is placed on an element.
	// For example `{^value}="name"`.
	data: function(el, attrData) {
		if(canDomDataState_1_0_1_canDomDataState.get.call(el, "preventDataBindings")) {
			return;
		}
		var viewModel,
			getViewModel = canObservationRecorder_1_1_2_canObservationRecorder.ignore(function() {
				return viewModel || (viewModel = canViewModel_4_0_1_canViewModel(el));
			}),
			semaphore = {},
			teardown,
			attributeDisposal,
			removedDisposal;

			// Setup binding
			var dataBinding = makeDataBinding({
				name: attrData.attributeName,
				value: el.getAttribute(attrData.attributeName),
				nodeList: attrData.nodeList
			}, el, {
				templateType: attrData.templateType,
				scope: attrData.scope,
				semaphore: semaphore,
				getViewModel: getViewModel,
				syncChildWithParent: false
			});

			//!steal-remove-start
			if(dataBinding.bindingInfo.child === "viewModel" && !canDomDataState_1_0_1_canDomDataState.get(el, "viewModel")) {
				dev.warn('This element does not have a viewModel. (Attempting to bind `' + dataBinding.bindingInfo.bindingAttributeName + '="' + dataBinding.bindingInfo.parentName + '"`)');
			}
			//!steal-remove-end

			if(dataBinding.onCompleteBinding) {
				dataBinding.onCompleteBinding();
			}

			var attributeListener = function (ev) {
				var attrName = ev.attributeName,
					value = el.getAttribute(attrName);

				if( attrName === attrData.attributeName ) {
					if( teardown ) {
						teardown();
					}

					if(value !== null  ) {
						var dataBinding = makeDataBinding({name: attrName, value: value}, el, {
							templateType: attrData.templateType,
							scope: attrData.scope,
							semaphore: semaphore,
							getViewModel: getViewModel,
							// always update the viewModel accordingly.
							initializeValues: true,
							nodeList: attrData.nodeList,
							syncChildWithParent: false
						});
						if(dataBinding) {
							// The viewModel is created, so call callback immediately.
							if(dataBinding.onCompleteBinding) {
								dataBinding.onCompleteBinding();
							}
							teardown = dataBinding.onTeardown;
						}
					}
				}
			};


			var tearItAllDown = function(){
				if(teardown) {
					teardown();
					teardown = undefined;
				}

				if (removedDisposal) {
					removedDisposal();
					removedDisposal = undefined;
				}
				if (attributeDisposal) {
					attributeDisposal();
					attributeDisposal = undefined;
				}
			};
			if(attrData.nodeList) {
				canViewNodelist_4_2_0_canViewNodelist.register([],tearItAllDown, attrData.nodeList, false);
			}


			// Listen for changes
			teardown = dataBinding.onTeardown;

			attributeDisposal = canDomMutate_1_0_4_canDomMutate.onNodeAttributeChange(el, attributeListener);
			removedDisposal = canDomMutate_1_0_4_canDomMutate.onNodeRemoval(el, function() {
				if (el.ownerDocument.contains(el) === false) {
					tearItAllDown();
				}
			});
	},
	// ### bindings.behaviors.event
	// The following section contains code for implementing the can-EVENT attribute.
	// This binds on a wildcard attribute name. Whenever a view is being processed
	// and can-xxx (anything starting with can-), this callback will be run.  Inside, its setting up an event handler
	// that calls a method identified by the value of this attribute.
	event: function(el, data) {

		// Get the `event` name and if we are listening to the element or viewModel.
		// The attribute name is the name of the event.
		var attributeName = canAttributeEncoder_1_0_5_canAttributeEncoder.decode( data.attributeName ),
			// the name of the event we are binding
			event,
			// if we are binding on the element or the VM
			bindingContext;

		// check for `on:event:value:to` type things and call data bindings
		if(attributeName.indexOf(toMatchStr+":") !== -1 ||
			attributeName.indexOf(fromMatchStr+":") !== -1 ||
			attributeName.indexOf(bindMatchStr+":") !== -1
		) {
			return this.data(el, data);
		}

		if(startsWith.call(attributeName, onMatchStr)) {
			event = attributeName.substr(onMatchStr.length);
			var viewModel = el[canSymbol_1_6_1_canSymbol.for('can.viewModel')];

			// when using on:prop:by:obj
			// bindingContext should be scope.obj
			var byParent = data.scope;

			// get the bindingContext
			// on:el:prop -> bindingContext = element
			// on:vm:prop -> bindingContext = viewModel
			// otherwise,
			// bind on the element if there is not a viewModel
			if (startsWith.call(event, elMatchStr)) {
				event = event.substr(elMatchStr.length);
				bindingContext = el;
			} else {
				if (startsWith.call(event, vmMatchStr)) {
					event = event.substr(vmMatchStr.length);
					bindingContext = viewModel;

					// when using on:vm:prop:by:obj
					// bindingContext should be viewModel.obj
					byParent = viewModel;
				} else {
					bindingContext = viewModel || el;
				}

				// update the bindingContext and event if using :by:
				// on:prop:by:obj
				//   -> bindingContext = byParent.get('obj')
				//   -> event = 'prop'
				var byIndex = event.indexOf(byMatchStr);
				if( byIndex >= 0 ) {
					bindingContext = byParent.get(event.substr(byIndex + byMatchStr.length));
					event = event.substr(0, byIndex);
				}
			}
		} else {
			throw new Error("can-stache-bindings - unsupported event bindings "+attributeName);
		}

		// This is the method that the event will initially trigger. It will look up the method by the string name
		// passed in the attribute and call it.
		var handler = function (ev) {
			var attrVal = el.getAttribute( canAttributeEncoder_1_0_5_canAttributeEncoder.encode(attributeName) );
			if (!attrVal) { return; }

			var viewModel = canViewModel_4_0_1_canViewModel(el);

			// expression.parse will read the attribute
			// value and parse it identically to how mustache helpers
			// get parsed.
			var expr = expression_1.parse(attrVal,{
				lookupRule: function() {
					return expression_1.Lookup;
				}, methodRule: "call"});


			if(!(expr instanceof expression_1.Call)) {
				throw new Error("can-stache-bindings: Event bindings must be a call expression. Make sure you have a () in "+data.attributeName+"="+JSON.stringify(attrVal));
			}

			// create "special" values that can be looked up using
			// {{scope.element}}, etc
			var specialValues = {
				element: el,
				event: ev,
				viewModel: viewModel,
				arguments: arguments
			};

			// make a scope with these things just under
			var localScope = data.scope
				.add(specialValues, { special: true });

			var updateFn = function() {
				var value = expr.value(localScope, {
					doNotWrapInObservation: true
				});

				value = canReflect_1_16_7_canReflect.isValueLike(value) ?
					canReflect_1_16_7_canReflect.getValue(value) :
					value;

				return typeof value === 'function' ?
					value(el) :
					value;
			};
			//!steal-remove-start
			Object.defineProperty(updateFn, "name", {
				value: attributeName + '="' + attrVal + '"'
			});
			//!steal-remove-end

			canQueues_1_1_0_canQueues.batch.start();
			canQueues_1_1_0_canQueues.mutateQueue.enqueue(updateFn, null, null, {
				//!steal-remove-start
				reasonLog: [el, ev, attributeName+"="+attrVal]
				//!steal-remove-end
			});
			canQueues_1_1_0_canQueues.batch.stop();

		};

		var attributesDisposal,
			removalDisposal;

		// Unbind the event when the attribute is removed from the DOM
		var attributesHandler = function(ev) {
			var isEventAttribute = ev.attributeName === attributeName;
			var isRemoved = !el.getAttribute(attributeName);
			var isEventAttributeRemoved = isEventAttribute && isRemoved;
			if (isEventAttributeRemoved) {
				unbindEvent();
			}
		};
		var removalHandler = function () {
			if (!el.ownerDocument.contains(el)) {
				unbindEvent();
			}
		};
		var unbindEvent = function() {
			canAttributeObservable_0_3_1_event.off.call(bindingContext, event, handler);
			if (attributesDisposal) {
				attributesDisposal();
				attributesDisposal = undefined;
			}
			if (removalDisposal) {
				removalDisposal();
				removalDisposal = undefined;
			}
		};

		// Bind the handler defined above to the element we're currently processing and the event name provided in this
		// attribute name (can-click="foo")
		canAttributeObservable_0_3_1_event.on.call(bindingContext, event, handler);
		attributesDisposal = canDomMutate_1_0_4_canDomMutate.onNodeAttributeChange(el, attributesHandler);
		removalDisposal = canDomMutate_1_0_4_canDomMutate.onNodeRemoval(el, removalHandler);
	}
};


// ## Attribute Syntaxes
// The following sets up the bindings functions to be called
// when called in a template.


// value:to="bar" data bindings
// these are separate so that they only capture at the end
// to avoid (toggle)="bar" which is encoded as :lp:toggle:rp:="bar"
canViewCallbacks_4_1_2_canViewCallbacks.attr(/[\w\.:]+:to$/, behaviors.data);
canViewCallbacks_4_1_2_canViewCallbacks.attr(/[\w\.:]+:from$/, behaviors.data);
canViewCallbacks_4_1_2_canViewCallbacks.attr(/[\w\.:]+:bind$/, behaviors.data);
canViewCallbacks_4_1_2_canViewCallbacks.attr(/[\w\.:]+:raw$/, behaviors.data);
// value:to:on:input="bar" data bindings
canViewCallbacks_4_1_2_canViewCallbacks.attr(/[\w\.:]+:to:on:[\w\.:]+/, behaviors.data);
canViewCallbacks_4_1_2_canViewCallbacks.attr(/[\w\.:]+:from:on:[\w\.:]+/, behaviors.data);
canViewCallbacks_4_1_2_canViewCallbacks.attr(/[\w\.:]+:bind:on:[\w\.:]+/, behaviors.data);


// `(EVENT)` event bindings.
canViewCallbacks_4_1_2_canViewCallbacks.attr(/on:[\w\.:]+/, behaviors.event);

// ## getObservableFrom
// An object of helper functions that make a getter/setter observable
// on different types of objects.
var getObservableFrom = {
	// ### getObservableFrom.viewModelOrAttribute
	viewModelOrAttribute: function(el, scope, vmNameOrProp, bindingData, mustBeSettable, stickyCompute, event) {
		var viewModel = el[canSymbol_1_6_1_canSymbol.for('can.viewModel')];

		// if we have a viewModel, use it; otherwise, setup attribute binding
		if (viewModel) {
			return this.viewModel.apply(this, arguments);
		} else {
			return this.attribute.apply(this, arguments);
		}
	},
	// ### getObservableFrom.scope
	// Returns a compute from the scope.  This handles expressions like `someMethod(.,1)`.
	scope: function(el, scope, scopeProp, bindingData, mustBeSettable, stickyCompute) {
		if(!scopeProp) {
			return new canSimpleObservable_2_0_4_canSimpleObservable();
		} else {
			if(mustBeSettable) {
				var parentExpression = expression_1.parse(scopeProp,{baseMethodType: "Call"});
				return parentExpression.value(scope);
			} else {
				var observation = {};

				canReflect_1_16_7_canReflect.assignSymbols(observation, {
					"can.getValue": function getValue() {},

					"can.valueHasDependencies": function hasValueDependencies() {
						return false;
					},

					"can.setValue": function setValue(newVal) {
						scope.set(cleanVMName(scopeProp, scope), newVal);
					},

					// Register what the custom observation changes
					"can.getWhatIChange": function getWhatIChange() {
						var data = scope.getDataForScopeSet(cleanVMName(scopeProp, scope));

						return {
							mutate: {
								keyDependencies: new Map([
									[data.parent, new Set([data.key])]
								])
							}
						};
					},

					"can.getName": function getName() {
						//!steal-remove-start
						var result = "ObservableFromScope<>";
						var data = scope.getDataForScopeSet(cleanVMName(scopeProp, scope));

						if (data.parent && data.key) {
							result = "ObservableFromScope<" +
								canReflect_1_16_7_canReflect.getName(data.parent) +
								"." +
								data.key +
								">";
						}

						return result;
						//!steal-remove-end
					},
				});

				var data = scope.getDataForScopeSet(cleanVMName(scopeProp, scope));
				if (data.parent && data.key) {
					// Register what changes the Scope's parent key
					canReflectDependencies_1_0_2_canReflectDependencies.addMutatedBy(data.parent, data.key, observation);
				}

				return observation;
			}
		}
	},
	// ### getObservableFrom.viewModel
	// Returns a compute that's two-way bound to the `viewModel` returned by
	// `options.getViewModel()`.
	viewModel: function(el, scope, vmName, bindingData, mustBeSettable, stickyCompute, childEvent) {
		var setName = cleanVMName(vmName, scope);
		var isBoundToContext = vmName === "." || vmName === "this";
		var keysToRead = isBoundToContext ? [] : canStacheKey_1_3_2_canStacheKey.reads(vmName);

		function getViewModelProperty() {
			var viewModel = bindingData.getViewModel();
			return canStacheKey_1_3_2_canStacheKey.read(viewModel, keysToRead, {}).value;
		}
		//!steal-remove-start
		Object.defineProperty(getViewModelProperty, "name", {
			value: "viewModel."+vmName
		});
		//!steal-remove-end

		var observation = new setter(
			getViewModelProperty,

			function setViewModelProperty(newVal){
				var viewModel = bindingData.getViewModel();

				if(stickyCompute) {
					// TODO: Review what this is used for.
					var oldValue = canReflect_1_16_7_canReflect.getKeyValue(viewModel, setName);
					if (canReflect_1_16_7_canReflect.isObservableLike(oldValue)) {
						canReflect_1_16_7_canReflect.setValue(oldValue, newVal);
					} else {
						canReflect_1_16_7_canReflect.setKeyValue(
							viewModel,
							setName,
							new canSimpleObservable_2_0_4_canSimpleObservable(canReflect_1_16_7_canReflect.getValue(stickyCompute))
						);
					}
				} else {
					if(isBoundToContext) {
						canReflect_1_16_7_canReflect.setValue(viewModel, newVal);
					} else {
						canReflect_1_16_7_canReflect.setKeyValue(viewModel, setName, newVal);
					}
				}
			}
		);

		//!steal-remove-start
		var viewModel = bindingData.getViewModel();
		if (viewModel && setName) {
			canReflectDependencies_1_0_2_canReflectDependencies.addMutatedBy(viewModel, setName, observation);
		}
		//!steal-remove-end

		return observation;
	},
	// ### getObservableFrom.attribute
	// Returns a compute that is two-way bound to an attribute or property on the element.
	attribute: function(el, scope, prop, bindingData, mustBeSettable, stickyCompute, event, bindingInfo) {
		return new canAttributeObservable_0_3_1_canAttributeObservable(el, prop, bindingData, event);
	}
};

// ## bind
// An object with helpers that perform bindings in a certain direction.
// These use the semaphore to prevent cycles.
var bind$1 = {
	// ## bind.childToParent
	// Listens to the child and updates the parent when it changes.
	// - `syncChild` - Makes sure the child is equal to the parent after the parent is set.
	childToParent: function(el, parentObservable, childObservable, bindingsSemaphore, attrName, syncChild, bindingInfo) {
		// Updates the parent if
		function updateParent(newVal) {
			if(!bindingInfo.active) {
				return;
			}
			if (!bindingsSemaphore[attrName]) {
				if (parentObservable && parentObservable[getValueSymbol$2]) {
					var hasDependencies = canReflect_1_16_7_canReflect.valueHasDependencies(parentObservable);

					if (!hasDependencies || (canReflect_1_16_7_canReflect.getValue(parentObservable) !== newVal) ) {
						canReflect_1_16_7_canReflect.setValue(parentObservable, newVal);
					}
					// only sync if parent
					if( syncChild && hasDependencies) {
						// If, after setting the parent, it's value is not the same as the child,
						// update the child with the value of the parent.
						// This is used by `can-value`.
						if(canReflect_1_16_7_canReflect.getValue(parentObservable) !== canReflect_1_16_7_canReflect.getValue(childObservable)) {
							bindingsSemaphore[attrName] = (bindingsSemaphore[attrName] || 0) + 1;
							canQueues_1_1_0_canQueues.batch.start();
							canReflect_1_16_7_canReflect.setValue(childObservable, canReflect_1_16_7_canReflect.getValue(parentObservable));

							canQueues_1_1_0_canQueues.mutateQueue.enqueue(function decrementChildToParentSemaphore() {
								--bindingsSemaphore[attrName];
							},null,[],{});
							canQueues_1_1_0_canQueues.batch.stop();
						}
					}
				}
				// The parentObservable can sometimes be just an observable if the observable
				// is on a plain JS object. This updates the observable to match whatever the
				// new value is.
				else if(canReflect_1_16_7_canReflect.isMapLike(parentObservable)) {
					// !steal-dev-start
					var attrValue = el.getAttribute(attrName);
					dev.warn("can-stache-bindings: Merging " + attrName + " into " + attrValue + " because its parent is non-observable");
					// !steal-dev-end
					canReflect_1_16_7_canReflect.eachKey(parentObservable, function(prop) {
						canReflect_1_16_7_canReflect.deleteKeyValue(parentObservable, prop);
					});
					canReflect_1_16_7_canReflect.setValue(
						parentObservable,
						(newVal && newVal.serialize) ? newVal.serialize() : newVal,
						true
					);
				}
			}
		}
		//!steal-remove-start
		Object.defineProperty(updateParent, "name", {
			value: "update "+bindingInfo.parent+"."+bindingInfo.parentName+" of <"+el.nodeName.toLowerCase()+">",
		});
		//!steal-remove-end

		if(childObservable && childObservable[getValueSymbol$2]) {
			canReflect_1_16_7_canReflect.onValue(childObservable, updateParent, "domUI");

			//!steal-remove-start
			canReflectDependencies_1_0_2_canReflectDependencies.addMutatedBy(parentObservable, childObservable);
			updateParent[getChangesSymbol$2] = function getChangesDependencyRecord() {
				return {
					valueDependencies: new Set([ parentObservable ])
				};
			};
			//!steal-remove-end
		}

		return updateParent;
	},
	// parent -> child binding
	parentToChild: function(el, parentObservable, childObservable, bindingsSemaphore, attrName, bindingInfo) {
		// setup listening on parent and forwarding to viewModel
		var updateChild = function updateChild(newValue) {
			if(!bindingInfo.active) {
				return;
			}
			// Save the viewModel property name so it is not updated multiple times.
			// We listen for when the batch has ended, and all observation updates have ended.
			bindingsSemaphore[attrName] = (bindingsSemaphore[attrName] || 0) + 1;
			canQueues_1_1_0_canQueues.batch.start();
			canReflect_1_16_7_canReflect.setValue(childObservable, newValue);

			// only after computes have been updated, reduce the update counter
			canQueues_1_1_0_canQueues.mutateQueue.enqueue(function decrementParentToChildSemaphore() {
				--bindingsSemaphore[attrName];
			},null,[],{});
			canQueues_1_1_0_canQueues.batch.stop();
		};

		//!steal-remove-start
		Object.defineProperty(updateChild, "name", {
			value: "update "+bindingInfo.child+"."+bindingInfo.childName+" of <"+el.nodeName.toLowerCase()+">",
		});
		//!steal-remove-end

		if(parentObservable && parentObservable[getValueSymbol$2]) {
			canReflect_1_16_7_canReflect.onValue(parentObservable, updateChild, "domUI");
			//!steal-remove-start
			canReflectDependencies_1_0_2_canReflectDependencies.addMutatedBy(childObservable, parentObservable);
			updateChild[getChangesSymbol$2] = function getChangesDependencyRecord() {
				return {
					valueDependencies: new Set([ childObservable])
				};
			};
			//!steal-remove-end
		}

		return updateChild;
	}
};
var startsWith = String.prototype.startsWith || function(text){
	return this.indexOf(text) === 0;
};

// Gets an event name in the after part.
function getEventName(result) {
	if(result.special.on !== undefined) {
		return result.tokens[result.special.on+1];
	}
}

var bindingRules = {
	to: {
		childToParent: true,
		parentToChild: false,
		syncChildWithParent: false
	},
	from: {
		childToParent: false,
		parentToChild: true,
		syncChildWithParent: false,
	},
	bind: {
		childToParent: true,
		parentToChild: true,
		syncChildWithParent: true,
	},
	raw: {
		childToParent: false,
		parentToChild: true,
		syncChildWithParent: false
	}
};
var bindingNames = [];
var special$1 = {
	vm: true,
	on: true
};
canReflect_1_16_7_canReflect.each(bindingRules, function(value, key){
	bindingNames.push(key);
	special$1[key] = true;
});

// "on:click:value:to" //-> {tokens: [...], special: {on: 0, to: 3}}
function tokenize(source) {
	var splitByColon = source.split(":");
	// combine tokens that are not to, from, vm,
	var result = {
		tokens: [],
		special: {}
	};
	splitByColon.forEach(function(token){
		if(special$1[token]) {
			result.special[token] = result.tokens.push(token) - 1;
		} else {
			result.tokens.push(token);
		}
	});

	return result;
}

// ## getChildBindingStr
var getChildBindingStr = function(tokens, favorViewModel) {
	if (tokens.indexOf('vm') >= 0) {
		return viewModelBindingStr;
	} else if (tokens.indexOf('el') >= 0) {
		return attributeBindingStr;
	} else {
		return favorViewModel ?  viewModelBindingStr: viewModelOrAttributeBindingStr;
	}
};

// ## getBindingInfo
// takes a node object like {name, value} and returns
// an object with information about that binding.
// Properties:
// - `parent` - where is the parentName read from: "scope", "attribute", "viewModel".
// - `parentName` - what is the parent property that should be read.
// - `child` - where is the childName read from: "scope", "attribute", "viewModel".
//  - `childName` - what is the child property that should be read.
// - `parentToChild` - should changes in the parent update the child.
// - `childToParent` - should changes in the child update the parent.
// - `bindingAttributeName` - the attribute name that created this binding.
// - `initializeValues` - should parent and child be initialized to their counterpart.
// If undefined is return, there is no binding.
var getBindingInfo = function(node, attributeViewModelBindings, templateType, tagName, favorViewModel) {
	var bindingInfo,
		attributeName = canAttributeEncoder_1_0_5_canAttributeEncoder.decode( node.name ),
		attributeValue = node.value || "";

	// START: check new binding syntaxes ======
	var result = tokenize(attributeName),
		dataBindingName,
		specialIndex;



	// check if there's a match of a binding name with at least a value before it
	bindingNames.forEach(function(name){
		if(result.special[name] !== undefined && result.special[name] > 0) {
			dataBindingName = name;
			specialIndex = result.special[name];
			return false;
		}
	});

	if(dataBindingName) {
		var childEventName = getEventName(result);
		var initializeValues = childEventName && dataBindingName !== "bind" ? false : true;
		bindingInfo = canAssign_1_1_1_canAssign({
			parent: scopeBindingStr,
			child: getChildBindingStr(result.tokens, favorViewModel),
			// the child is going to be the token before the special location
			childName: result.tokens[specialIndex-1],
			childEvent: childEventName,
			bindingAttributeName: attributeName,
			parentName: result.special.raw ? ('"' + attributeValue + '"') : attributeValue,
			initializeValues: initializeValues,
		}, bindingRules[dataBindingName]);
		if(attributeValue.trim().charAt(0) === "~") {
			bindingInfo.stickyParentToChild = true;
		}
		return bindingInfo;
	}
	// END: check new binding syntaxes ======

};



// ## makeDataBinding
// Makes a data binding for an attribute `node`.  Returns an object with information
// about the binding, including an `onTeardown` method that undoes the binding.
// If the data binding involves a `viewModel`, an `onCompleteBinding` method is returned on
// the object.  This method must be called after the element has a `viewModel` with the
// `viewModel` to complete the binding.
//
// - `node` - an attribute node or an object with a `name` and `value` property.
// - `el` - the element this binding belongs on.
// - `bindingData` - an object with:
//   - `templateType` - the type of template.
//   - `scope` - the `Scope`,
//   - `semaphore` - an object that keeps track of changes in different properties to prevent cycles,
//   - `getViewModel`  - a function that returns the `viewModel` when called.  This function can be passed around (not called) even if the
//      `viewModel` doesn't exist yet.
//   - `attributeViewModelBindings` - properties already specified as being a viewModel<->attribute (as opposed to viewModel<->scope) binding.
//
// Returns:
// - `undefined` - If this isn't a data binding.
// - `object` - An object with information about the binding.
var makeDataBinding = function(node, el, bindingData) {
	// Get information about the binding.
	var bindingInfo = getBindingInfo(node, bindingData.attributeViewModelBindings,
		bindingData.templateType, el.nodeName.toLowerCase(), bindingData.favorViewModel);
	if(!bindingInfo) {
		return;
	}
	// hack in the active check (#278)
	bindingInfo.active = true;

	// assign some bindingData props to the bindingInfo
	bindingInfo.alreadyUpdatedChild = bindingData.alreadyUpdatedChild;
	if( bindingData.initializeValues) {
		bindingInfo.initializeValues = true;
	}

	// Get computes for the parent and child binding
	var parentObservable = getObservableFrom[bindingInfo.parent](
		el,
		bindingData.scope,
		bindingInfo.parentName,
		bindingData,
		bindingInfo.parentToChild,
		undefined,
		undefined,
		bindingInfo
	),
	childObservable = getObservableFrom[bindingInfo.child](
		el,
		bindingData.scope,
		bindingInfo.childName,
		bindingData,
		bindingInfo.childToParent,
		bindingInfo.stickyParentToChild && parentObservable,
		bindingInfo.childEvent,
		bindingInfo
	),
	// these are the functions bound to one compute that update the other.
	updateParent,
	updateChild;

	if(bindingData.nodeList) {
		if(parentObservable) {
			canReflect_1_16_7_canReflect.setPriority(parentObservable, bindingData.nodeList.nesting+1);
		}

		if(childObservable) {
			canReflect_1_16_7_canReflect.setPriority(childObservable, bindingData.nodeList.nesting+1);
		}
	}

	// Only bind to the parent if it will update the child.
	if(bindingInfo.parentToChild) {
		updateChild = bind$1.parentToChild(el, parentObservable, childObservable, bindingData.semaphore, bindingInfo.bindingAttributeName, bindingInfo);
	}

	// This completes the binding.  We can't call it right away because
	// the `viewModel` might not have been created yet.
	var completeBinding = function() {

		if(bindingInfo.childToParent) {
			// setup listening on parent and forwarding to viewModel
			updateParent = bind$1.childToParent(el, parentObservable, childObservable, bindingData.semaphore, bindingInfo.bindingAttributeName,
				bindingInfo.syncChildWithParent, bindingInfo);
		}
		// the child needs to be bound even if
		else if(bindingInfo.stickyParentToChild && childObservable[onValueSymbol$3])  {
			canReflect_1_16_7_canReflect.onValue(childObservable, noop$3,"mutate");
		}

		if(bindingInfo.initializeValues) {
			initializeValues(bindingInfo, childObservable, parentObservable, updateChild, updateParent);
		}
	};

	// This tears down the binding.
	var onTeardown = function() {
		bindingInfo.active = false;
		unbindUpdate(parentObservable, updateChild);
		unbindUpdate(childObservable, updateParent);
		unbindUpdate(childObservable, noop$3);
	};

	// If this binding depends on the viewModel, which might not have been created,
	// return the function to complete the binding as `onCompleteBinding`.
	if(bindingInfo.child === viewModelBindingStr) {
		return {
			value: bindingInfo.stickyParentToChild ? canViewScope_4_4_3_makeComputeLike(parentObservable) :
				canReflect_1_16_7_canReflect.getValue(parentObservable),
				onCompleteBinding: completeBinding,
				bindingInfo: bindingInfo,
				onTeardown: onTeardown
		};
	} else {
		completeBinding();
		return {
			bindingInfo: bindingInfo,
			onTeardown: onTeardown
		};
	}
};

// ## initializeValues
// Updates the parent or child value depending on the direction of the binding
// or if the child or parent is `undefined`.
var initializeValues = function(bindingInfo, childObservable, parentObservable, updateChild, updateParent) {
	var doUpdateParent = false;

	if(bindingInfo.parentToChild && !bindingInfo.childToParent) {
		// updateChild
	}
	else if(!bindingInfo.parentToChild && bindingInfo.childToParent) {
		doUpdateParent = true;
	}
	// Two way
	// Update child or parent depending on who has a value.
	// If both have a value, update the child.
	else if(canReflect_1_16_7_canReflect.getValue(childObservable) === undefined) {
		// updateChild
	} else if(canReflect_1_16_7_canReflect.getValue(parentObservable) === undefined) {
		doUpdateParent = true;
	}

	if(doUpdateParent) {
		updateParent( canReflect_1_16_7_canReflect.getValue(childObservable) );
	} else {
		if(!bindingInfo.alreadyUpdatedChild) {
			updateChild( canReflect_1_16_7_canReflect.getValue(parentObservable) );
		}
	}
};

var unbindUpdate = function(observable, updater) {
	if(observable && observable[getValueSymbol$2] && typeof updater === "function") {
		canReflect_1_16_7_canReflect.offValue(observable, updater,"domUI");
	}
},
cleanVMName = function(name, scope) {
	//!steal-remove-start
	if (name.indexOf("@") >= 0) {
		var filename = scope.peek('scope.filename');
		var lineNumber = scope.peek('scope.lineNumber');

		dev.warn(
			(filename ? filename + ':' : '') +
			(lineNumber ? lineNumber + ': ' : '') +
			'functions are no longer called by default so @ is unnecessary in \'' + name + '\'.');
	}
	//!steal-remove-end
	return name.replace(/@/g, "");
};

var canStacheBindings_4_2_5_canStacheBindings = {
	behaviors: behaviors,
	getBindingInfo: getBindingInfo
};

/* jshint -W079 */
// # can/component/component.js
//
// This implements the `Component` which allows you to create widgets
// that use a view, a view-model, and custom tags.
//
// `Component` implements most of it's functionality in the `Component.setup`
// and the `Component.prototype.setup` functions.
//
// `Component.setup` prepares everything needed by the `Component.prototype.setup`
// to hookup the component.


















// DefineList must be imported so Arrays on the ViewModel
// will be converted to DefineLists automatically











// For insertion elements like <can-slot> and <context>, this will add
// a compute viewModel to the top of the context if
// a binding like {this}="value" is present.
// - el - the insertion element
// - tagData - the tagData the insertion element will be rendered with
// - insertionElementTagData - the tagData found at the insertion element
// `returns` - the tagData the template should be rendered with.
function addContext(el, tagData, insertionElementTagData) {
	var vm;

	canDomDataState_1_0_1_canDomDataState.set.call(el, "preventDataBindings", true);

	// insertionElementTagData is where the <content> element is in the shadow dom
	// it should be used for bindings
	var teardown = canStacheBindings_4_2_5_canStacheBindings.behaviors.viewModel(el, insertionElementTagData, function(initialData) {
		// Create a compute responsible for keeping the vm up-to-date
		return vm = new canSimpleObservable_2_0_4_canSimpleObservable(initialData);
	}, undefined, true);


	if(!teardown) {
		// if no teardown, there's no bindings, no need to change the scope
		return tagData;
	} else {
		return canAssign_1_1_1_canAssign( canAssign_1_1_1_canAssign({}, tagData), {
			teardown: teardown,
			scope: tagData.scope.add(vm)
		});
	}

}

// Returns a hookupFuction that gets the proper tagData in a template, renders it, and adds it to nodeLists
function makeInsertionTagCallback(tagName, componentTagData, shadowTagData, leakScope, getPrimaryTemplate) {
	var options = shadowTagData.options;

	return function hookupFunction(el, insertionElementTagData) {
		var template = getPrimaryTemplate(el) || insertionElementTagData.subtemplate,
			renderingLightContent = template !== insertionElementTagData.subtemplate;

		if (template) {
			// However, `_tags.[tagName]` is going to point to this current content callback.  We need to
			// remove that so it will walk up the chain
			delete options.tags[tagName];

			// By default, light dom scoping is
			// dynamic. This means that any `{{foo}}`
			// bindings inside the "light dom" content of
			// the component will have access to the
			// internal viewModel. This can be overridden to be
			// lexical with the leakScope option.
			var tagData;

			if( renderingLightContent ) {

				if(leakScope.toLightContent) {
					// render with the component's viewModel mixed in, however
					// we still want the outer refs to be used, NOT the component's refs
					// <component> {{some value }} </component>
					// To fix this, we
					// walk down the scope to the component's ref, clone scopes from that point up
					// use that as the new scope.
					tagData = addContext(el, {
						scope: insertionElementTagData.scope.cloneFromRef(),
						options: insertionElementTagData.options
					}, insertionElementTagData);
				}
				else {
					// render with the same scope the component was found within.
					tagData = addContext(el, componentTagData, insertionElementTagData);
				}
			} else {
				// we are rendering default content so this content should
				// use the same scope as the <content> tag was found within.
				tagData = addContext(el, insertionElementTagData, insertionElementTagData);
			}


			// the `el` is part of some parent node list

			var nodeList = canViewNodelist_4_2_0_canViewNodelist.register([el], function() {
				if(tagData.teardown) {
					tagData.teardown();
				}
			}, insertionElementTagData.parentNodeList || true, insertionElementTagData.directlyNested);
			nodeList.expression = "<can-slot name='"+el.getAttribute('name')+"'/>";

			var frag = template(tagData.scope, tagData.options, nodeList);
			var newNodes = canReflect_1_16_7_canReflect.toArray( canChildNodes_1_0_0_canChildNodes(frag) );
			var oldNodes = canViewNodelist_4_2_0_canViewNodelist.update(nodeList, newNodes);
			canViewNodelist_4_2_0_canViewNodelist.replace(oldNodes, frag);


			// Restore the proper tag function so it could potentially be used again (as in lists)
			options.tags[tagName] = hookupFunction;
		}
	};
}

var Component = canConstruct_3_4_4_canConstruct.extend(

	// ## Static
	{
		// ### setup
		//
		// When a component is extended, this sets up the component's internal constructor
		// functions and views for later fast initialization.
		setup: function() {
			canConstruct_3_4_4_canConstruct.setup.apply(this, arguments);

			// When `Component.setup` function is ran for the first time, `Component` doesn't exist yet
			// which ensures that the following code is ran only in constructors that extend `Component`.
			if (Component) {
				var self = this;

				// Define a control using the `events` prototype property.
				if(this.prototype.events !== undefined && canReflect_1_16_7_canReflect.size(this.prototype.events) !== 0) {
					this.Control = control.extend(this.prototype.events);
				}

				//!steal-remove-start
				// If a constructor is assigned to the viewModel, give a warning
				if (this.prototype.viewModel && canReflect_1_16_7_canReflect.isConstructorLike(this.prototype.viewModel)) {
					dev.warn("can-component: Assigning a DefineMap or constructor type to the viewModel property may not be what you intended. Did you mean ViewModel instead? More info: https://canjs.com/doc/can-component.prototype.ViewModel.html");
				}
				//!steal-remove-end

				// Look at viewModel, scope, and ViewModel properties and set one of:
				//  - this.viewModelHandler
				//  - this.ViewModel
				//  - this.viewModelInstance
				var protoViewModel = this.prototype.viewModel || this.prototype.scope;

				if(protoViewModel && this.prototype.ViewModel) {
					throw new Error("Cannot provide both a ViewModel and a viewModel property");
				}
				var vmName = canString_0_0_5_canString.capitalize( canString_0_0_5_canString.camelize(this.prototype.tag) )+"VM";
				if(this.prototype.ViewModel) {
					if(typeof this.prototype.ViewModel === "function") {
						this.ViewModel = this.prototype.ViewModel;
					} else {
						this.ViewModel = map$2.extend(vmName, {}, this.prototype.ViewModel);
					}
				} else {

					if(protoViewModel) {
						if(typeof protoViewModel === "function") {
							if(canReflect_1_16_7_canReflect.isObservableLike(protoViewModel.prototype) && canReflect_1_16_7_canReflect.isMapLike(protoViewModel.prototype)) {
								this.ViewModel = protoViewModel;
							} else {
								this.viewModelHandler = protoViewModel;
							}
						} else {
							if(canReflect_1_16_7_canReflect.isObservableLike(protoViewModel) && canReflect_1_16_7_canReflect.isMapLike(protoViewModel)) {
								//!steal-remove-start
								canLog_1_0_0_canLog.warn("can-component: "+this.prototype.tag+" is sharing a single map across all component instances");
								//!steal-remove-end
								this.viewModelInstance = protoViewModel;
							} else {
								canLog_1_0_0_canLog.warn("can-component: "+this.prototype.tag+" is extending the viewModel into a can-simple-map");
								this.ViewModel = canSimpleMap_4_1_1_canSimpleMap.extend(vmName,{},protoViewModel);
							}
						}
					} else {
						this.ViewModel = canSimpleMap_4_1_1_canSimpleMap.extend(vmName,{},{});
					}
				}

				// Convert the template into a renderer function.
				if (this.prototype.template) {
					//!steal-remove-start
					canLog_1_0_0_canLog.warn('can-component.prototype.template: is deprecated and will be removed in a future release. Use can-component.prototype.view');
					//!steal-remove-end
					this.renderer = this.prototype.template;
				}
				if (this.prototype.view) {
					this.renderer = this.prototype.view;
				}

				// default to stache if renderer is a string
				if (typeof this.renderer === "string") {
					var viewName = canString_0_0_5_canString.capitalize( canString_0_0_5_canString.camelize(this.prototype.tag) )+"View";
					this.renderer = canStache_4_5_10_canStache(viewName, this.renderer);
				}

				// Register this component to be created when its `tag` is found.
				canViewCallbacks_4_1_2_canViewCallbacks.tag(this.prototype.tag, function(el, options) {
					new self(el, options);
				});
			}
		}
	}, {
		// ## Prototype
		// ### setup
		// When a new component instance is created, setup bindings, render the view, etc.
		setup: function(el, componentTagData) {
			var component = this;
			// If a view is not provided, we fall back to
			// dynamic scoping regardless of settings.


			// an array of teardown stuff that should happen when the element is removed
			var teardownFunctions = [];
			var initialViewModelData = {};
			var callTeardownFunctions = function() {
					for (var i = 0, len = teardownFunctions.length; i < len; i++) {
						teardownFunctions[i]();
					}
				};
			var setupBindings = !canDomDataState_1_0_1_canDomDataState.get.call(el, "preventDataBindings");
			var viewModel, frag;

			// ## Scope
			var teardownBindings;
			if (setupBindings) {
				var setupFn = componentTagData.setupBindings ||
					function(el, callback, data){
						return canStacheBindings_4_2_5_canStacheBindings.behaviors.viewModel(el, componentTagData,
																											callback, data);
					};
				teardownBindings = setupFn(el, function(initialViewModelData) {

					var ViewModel = component.constructor.ViewModel,
						viewModelHandler = component.constructor.viewModelHandler,
						viewModelInstance = component.constructor.viewModelInstance;

					if(viewModelHandler) {
						var scopeResult = viewModelHandler.call(component, initialViewModelData, componentTagData.scope, el);
						if (canReflect_1_16_7_canReflect.isObservableLike(scopeResult) && canReflect_1_16_7_canReflect.isMapLike(scopeResult) ) {
							// If the function returns a can.Map, use that as the viewModel
							viewModelInstance = scopeResult;
						} else if (canReflect_1_16_7_canReflect.isObservableLike(scopeResult.prototype) && canReflect_1_16_7_canReflect.isMapLike(scopeResult.prototype)) {
							// If `scopeResult` is of a `can.Map` type, use it to wrap the `initialViewModelData`
							ViewModel = scopeResult;
						} else {
							// Otherwise extend `SimpleMap` with the `scopeResult` and initialize it with the `initialViewModelData`
							ViewModel = canSimpleMap_4_1_1_canSimpleMap.extend(scopeResult);
						}
					}

					if(ViewModel) {
						viewModelInstance = new component.constructor.ViewModel(initialViewModelData);
					}
					viewModel = viewModelInstance;
					return viewModelInstance;
				}, initialViewModelData);
			} else {
				viewModel = el[canSymbol_1_6_1_canSymbol.for('can.viewModel')];
			}

			// Set `viewModel` to `this.viewModel` and set it to the element's `data` object as a `viewModel` property
			this.viewModel = viewModel;

			el[canSymbol_1_6_1_canSymbol.for('can.viewModel')] = viewModel;
			canDomDataState_1_0_1_canDomDataState.set.call(el, "preventDataBindings", true);

			// ## Helpers
			var options = {
					helpers: {},
					tags: {}
				};
			// Setup helpers to callback with `this` as the component
			if(this.helpers !== undefined) {
				canReflect_1_16_7_canReflect.eachKey(this.helpers, function(val, prop) {
					if (typeof val === "function") {
						options.helpers[prop] = val.bind(viewModel);
					}
				});
			}


			// ## `events` control

			// Create a control to listen to events
			if(this.constructor.Control) {
				this._control = new this.constructor.Control(el, {
					// Pass the viewModel to the control so we can listen to it's changes from the controller.
					scope: this.viewModel,
					viewModel: this.viewModel,
					destroy: callTeardownFunctions
				});
			} else {
				var removalDisposal = canDomMutate_1_0_4_canDomMutate.onNodeRemoval(el, function () {
					if (!el.ownerDocument.contains(el)) {
						removalDisposal();
						callTeardownFunctions();
					}
				});
			}

			// ## Rendering

			var leakScope = {
				toLightContent: this.leakScope === true,
				intoShadowContent: this.leakScope === true
			};

			var hasShadowTemplate = !!(this.constructor.renderer);

			// Get what we should render between the component tags
			// and the data for it.
			var betweenTagsRenderer;
			var betweenTagsTagData;
			if( hasShadowTemplate ) {
				var shadowTagData;
				if (leakScope.intoShadowContent) {
					// Give access to the component's data and the VM
					shadowTagData = {
						scope: componentTagData.scope.add(this.viewModel, { viewModel: true }),
						options: options
					};

				} else { // lexical
					// only give access to the VM
					shadowTagData = {
						scope: new canViewScope_4_4_3_canViewScope(this.viewModel, null, { viewModel: true }),
						options: options
					};
				}

				// Add a hookup for each <can-slot>
				options.tags['can-slot'] = makeInsertionTagCallback('can-slot', componentTagData, shadowTagData, leakScope, function(el) {
					var templates = componentTagData.templates;
					if (templates) {// This is undefined if the component is <self-closing/>
						return templates[el.getAttribute("name")];
					}
				});

				// Add a hookup for <content>
				options.tags.content = makeInsertionTagCallback('content',  componentTagData, shadowTagData, leakScope, function() {
					return componentTagData.subtemplate;
				});

				betweenTagsRenderer = this.constructor.renderer;
				betweenTagsTagData = shadowTagData;
			}
			else {
				// No shadow template.
				// Render light template with viewModel on top
				var lightTemplateTagData = {
					scope: componentTagData.scope.add(this.viewModel, {
						viewModel: true
					}),
					options: options
				};
				betweenTagsTagData = lightTemplateTagData;
				betweenTagsRenderer = componentTagData.subtemplate || el.ownerDocument.createDocumentFragment.bind(el.ownerDocument);
			}
			var disconnectedCallback,
				componentInPage;

			// Keep a nodeList so we can kill any directly nested nodeLists within this component
			var nodeList = canViewNodelist_4_2_0_canViewNodelist.register([], function() {
				canDomEvents_1_2_0_canDomEvents.dispatch(el, "beforeremove", false);
				if(teardownBindings) {
					teardownBindings();
				}
				if(disconnectedCallback) {
					disconnectedCallback(el);
				}
			}, componentTagData.parentNodeList || true, false);
			nodeList.expression = "<" + this.tag + ">";
			teardownFunctions.push(function() {
				canViewNodelist_4_2_0_canViewNodelist.unregister(nodeList);
			});



			frag = betweenTagsRenderer(betweenTagsTagData.scope, betweenTagsTagData.options, nodeList);

			// Append the resulting document fragment to the element
			canDomMutate_1_0_4_node.appendChild.call(el, frag);

			// update the nodeList with the new children so the mapping gets applied
			canViewNodelist_4_2_0_canViewNodelist.update(nodeList, canChildNodes_1_0_0_canChildNodes(el));

			if(viewModel && viewModel.connectedCallback) {
				componentInPage = document$1().body.contains(el);

				if(componentInPage) {
					disconnectedCallback = viewModel.connectedCallback(el);
				} else {
					var insertionDisposal = canDomMutate_1_0_4_canDomMutate.onNodeInsertion(el, function () {
						insertionDisposal();
						disconnectedCallback = viewModel.connectedCallback(el);
					});
				}

			}
		}
	});

var canComponent_4_1_2_canComponent = canNamespace_1_0_0_canNamespace.Component = Component;

var Compute$1 = function(newVal) {
	if (arguments.length) {
		return canReflect_1_16_7_canReflect.setValue(this, newVal);
	} else {
		return canReflect_1_16_7_canReflect.getValue(this);
	}
};

var translationHelpers = new WeakMap();

var makeCompute = function(observable) {
	var compute = Compute$1.bind(observable);
	compute.on = compute.bind = compute.addEventListener = function(
		event,
		handler
	) {
		var translationHandler = translationHelpers.get(handler);
		if (!translationHandler) {
			translationHandler = function(newVal, oldVal) {
				handler.call(compute, { type: "change" }, newVal, oldVal);
			};
			//!steal-remove-start
			Object.defineProperty(translationHandler, "name", {
				value:
					"translationHandler(" +
					event +
					")::" +
					canReflect_1_16_7_canReflect.getName(observable) +
					".onValue(" +
					canReflect_1_16_7_canReflect.getName(handler) +
					")"
			});
			//!steal-remove-end
			translationHelpers.set(handler, translationHandler);
		}
		canReflect_1_16_7_canReflect.onValue(observable, translationHandler);
	};
	compute.off = compute.unbind = compute.removeEventListener = function(
		event,
		handler
	) {
		canReflect_1_16_7_canReflect.offValue(observable, translationHelpers.get(handler));
	};

	canReflect_1_16_7_canReflect.assignSymbols(compute, {
		"can.getValue": function() {
			return canReflect_1_16_7_canReflect.getValue(observable);
		},
		"can.setValue": function(newVal) {
			return canReflect_1_16_7_canReflect.setValue(observable, newVal);
		},
		"can.onValue": function(handler, queue) {
			return canReflect_1_16_7_canReflect.onValue(observable, handler, queue);
		},
		"can.offValue": function(handler, queue) {
			return canReflect_1_16_7_canReflect.offValue(observable, handler, queue);
		},
		"can.valueHasDependencies": function() {
			return canReflect_1_16_7_canReflect.valueHasDependencies(observable);
		},
		"can.getPriority": function() {
			return canReflect_1_16_7_canReflect.getPriority(observable);
		},
		"can.setPriority": function(newPriority) {
			canReflect_1_16_7_canReflect.setPriority(observable, newPriority);
		},
		"can.isValueLike": true,
		"can.isFunctionLike": false
	});
	compute.isComputed = true;
	return compute;
};

var defaultBinding = new canSimpleObservable_2_0_4_canSimpleObservable("hashchange");

var bindingProxy = {
    get defaultBinding(){
        return defaultBinding.get();
    },
    set defaultBinding(newVal){
        defaultBinding.set(newVal);
    },
    currentBinding: null,
    bindings: {},
    call: function(){
        var args = canReflect_1_16_7_canReflect.toArray(arguments),
            prop = args.shift(),
            binding = bindingProxy.bindings[bindingProxy.currentBinding ||bindingProxy.defaultBinding],
            method = binding[prop.indexOf("can.") === 0 ? canSymbol_1_6_1_canSymbol.for(prop) : prop];
        if (method.apply) {
            return method.apply(binding, args);
        } else {
            return method;
        }
    }
};
var bindingProxy_1 = bindingProxy;

var regexps = {
    curlies: /\{\s*([\w.]+)\s*\}/g,
    colon: /\:([\w.]+)/g
};

var diff = createCommonjsModule(function (module, exports) {

var slice = [].slice;
// a b c
// a b c d
// [[2,0, d]]

var defaultIdentity = function(a, b){ return a === b; };

function reverseDiff(oldDiffStopIndex, newDiffStopIndex, oldList, newList, identity) {
	var oldIndex = oldList.length - 1,
		newIndex =  newList.length - 1;

	while( oldIndex > oldDiffStopIndex && newIndex > newDiffStopIndex) {
		var oldItem = oldList[oldIndex],
			newItem = newList[newIndex];

		if( identity( oldItem, newItem ) ) {
			oldIndex--;
			newIndex--;
			continue;
		} else {
			// use newIndex because it reflects any deletions
			return [{
				index: newDiffStopIndex,
			 	deleteCount: (oldIndex-oldDiffStopIndex+1),
			 	insert: slice.call(newList, newDiffStopIndex,newIndex+1)
			}];
		}
	}
	// if we've reached of either the new or old list
	// we simply return
	return [{
		index: newDiffStopIndex,
		deleteCount: (oldIndex-oldDiffStopIndex+1),
		insert: slice.call(newList, newDiffStopIndex,newIndex+1)
	}];

}

/**
 * @module {function} can-util/js/diff/diff diff
 * @parent can-util/js
 * @signature `diff( oldList, newList, [identity] )`
 *
 * @param  {ArrayLike} oldList the array to diff from
 * @param  {ArrayLike} newList the array to diff to
 * @param  {function} identity an optional identity function for comparing elements
 * @return {Array}     a list of Patch objects representing the differences
 *
 * Returns the difference between two ArrayLike objects (that have nonnegative
 * integer keys and the `length` property) as an array of patch objects.
 *
 * A patch object returned by this function has the following properties:
 * - **index**:  the index of newList where the patch begins
 * - **deleteCount**: the number of items deleted from that index in newList
 * - **insert**: an Array of items newly inserted at that index in newList
 *
 * ```js
 * var diff = require("can-util/js/diff/diff");
 *
 * console.log(diff([1], [1, 2])); // -> [{index: 1, deleteCount: 0, insert: [2]}]
 * console.log(diff([1, 2], [1])); // -> [{index: 1, deleteCount: 1, insert: []}]
 *
 * // with an optional identity function:
 * diff(
 *     [{id:1},{id:2}],
 *     [{id:1},{id:3}],
 *     (a,b) => a.id === b.id
 * ); // -> [{index: 1, deleteCount: 1, insert: [{id:3}]}]
 * ```
 */

// TODO: update for a better type reference. E.g.:
//    @typdef {function(*,*)} can-util/diff/diff/typedefs.identity identify(a, b)
//
//    @param {*} a This is something.
//    @param {can-util/diff/diff/typedefs.identity} identity(a, b)
//    @option {*} a

module.exports = exports = function(oldList, newList, identity){
	identity = identity || defaultIdentity;

	var oldIndex = 0,
		newIndex =  0,
		oldLength = oldList.length,
		newLength = newList.length,
		patches = [];

	while(oldIndex < oldLength && newIndex < newLength) {
		var oldItem = oldList[oldIndex],
			newItem = newList[newIndex];

		if( identity( oldItem, newItem ) ) {
			oldIndex++;
			newIndex++;
			continue;
		}
		// look for single insert, does the next newList item equal the current oldList.
		// 1 2 3
		// 1 2 4 3
		if(  newIndex+1 < newLength && identity( oldItem, newList[newIndex+1] ) ) {
			patches.push({index: newIndex, deleteCount: 0, insert: [ newList[newIndex] ]});
			oldIndex++;
			newIndex += 2;
			continue;
		}
		// look for single removal, does the next item in the oldList equal the current newList item.
		// 1 2 3
		// 1 3
		else if( oldIndex+1 < oldLength  && identity( oldList[oldIndex+1], newItem ) ) {
			patches.push({index: newIndex, deleteCount: 1, insert: []});
			oldIndex += 2;
			newIndex++;
			continue;
		}
		// just clean up the rest and exit
		// 1 2 3
		// 1 2 5 6 7
		else {
			// iterate backwards to `newIndex`
			// "a", "b", "c", "d", "e"
			// "a", "x", "y", "z", "e"
			// -> {}
			patches.push.apply(patches, reverseDiff(oldIndex, newIndex , oldList, newList, identity) );


			return patches;
		}
	}
	if( (newIndex === newLength) && (oldIndex === oldLength) ) {
		return patches;
	}
	// a b
	// a b c d e
	patches.push(
				{index: newIndex,
				 deleteCount: oldLength-oldIndex,
				 insert: slice.call(newList, newIndex) } );

	return patches;
};




// a b c
// a d e b c
});

var diffObject = createCommonjsModule(function (module, exports) {



/**
 * @module {function} can-util/js/diff-object/diff-object diff-object
 * @parent can-util/js
 * @signature `diffObject(oldObject, newObject)`
 *
 * @param {Object} oldObject the object to diff from
 * @param {Object} newObject the object to diff to
 * @return {Array} an array of object-patch objects
 *
 * Find the differences between two objects, based on properties and values
 *
 * The object-patch object format has the following keys:
 * - **property**: the property key on the new object
 * - **type**:     the type of operation on this property: add, remove, or set
 * - **value**:    the new value (if type is "add" or "set")
 *
 * ```js
 * var diffObject = require("can-util/js/diff-object/diff-object");
 *
 * console.log(diffObject({a: 1, b: 2}, {b: 3, c: 4})); // ->
 *   [{property: "a", type: "remove"},
 *    {property: "b", type: "set": value: 3},
 *    {property: "c", type: "add", "value": 4}]
 * ```
 */

module.exports = exports = function(oldObject, newObject){
	var oldObjectClone,
		patches = [];

	// clone oldObject so properties can be deleted
	oldObjectClone = canAssign_1_1_1_canAssign({}, oldObject);

	for (var newProp in newObject) {
		// look for added properties
		if (!oldObject || !oldObject.hasOwnProperty(newProp)) {
			patches.push({
				property: newProp,
				type: 'add',
				value: newObject[newProp]
			});
		// look for changed properties
		} else if (newObject[newProp] !== oldObject[newProp]) {
			patches.push({
				property: newProp,
				type: 'set',
				value: newObject[newProp]
			});
		}

		// delete properties found in newObject
		// so we can find removed properties
		delete oldObjectClone[newProp];
	}

	// loop over removed properties
	for (var oldProp in oldObjectClone) {
		patches.push({
			property: oldProp,
			type: 'remove'
		});
	}

	return patches;
};
});

// This file contains the function that allows the registration of routes









// `RegExp` used to match route variables of the type '{name}'.
// Any word character or a period is matched.



var removeBackslash = function (str) {
	return str.replace(/\\/g, "");
};
var wrapQuote = function (str) {
	return (str + '')
		.replace(/([.?*+\^$\[\]\\(){}|\-])/g, "\\$1");
};

var RouteRegistry = {
    routes:  {},
    register: function registerRoute(url, defaults) {
    	// if route ends with a / and url starts with a /, remove the leading / of the url
    	var root = bindingProxy_1.call("root");

    	if (root.lastIndexOf("/") === root.length - 1 &&
    		url.indexOf("/") === 0) {
    		url = url.substr(1);
    	}

    	defaults = defaults || {};
    	// Extract the variable names and replace with `RegExp` that will match
    	// an atual URL with values.
    	var names = [],
    		res,
    		test = "",
    		matcher,
    		lastIndex,
    		next,
    		querySeparator = bindingProxy_1.call("querySeparator"),
    		matchSlashes = bindingProxy_1.call("matchSlashes");

    	// fall back to legacy `:foo` RegExp if necessary
    	if (regexps.colon.test(url)) {
    		matcher = regexps.colon;

    		//!steal-remove-start
    		dev.warn('update route "' + url + '" to "' + url.replace(regexps.colon, function(name, key) {
    			return '{' + key + '}';
    		}) + '"');
    		//!steal-remove-end
    	} else {
    		matcher = regexps.curlies;
    	}
    	lastIndex = matcher.lastIndex = 0;

    	// res will be something like ["{foo}","foo"]
    	while (res = matcher.exec(url)) {
    		names.push(res[1]);
    		test += removeBackslash(url.substring(lastIndex, matcher.lastIndex - res[0].length));
    		// if matchSlashes is false (the default) don't greedily match any slash in the string, assume its part of the URL
    		next = "\\" + (removeBackslash(url.substr(matcher.lastIndex, 1)) || querySeparator+(matchSlashes? "": "|/"));
    		// a name without a default value HAS to have a value
    		// a name that has a default value can be empty
    		// The `\\` is for string-escaping giving single `\` for `RegExp` escaping.
    		test += "([^" + next + "]" + (defaults[res[1]] ? "*" : "+") + ")";
    		lastIndex = matcher.lastIndex;
    	}
    	test += url.substr(lastIndex)
    		.replace("\\", "");

    	//!steal-remove-start
    	// warn if new route uses same map properties as an existing route
    	canReflect_1_16_7_canReflect.eachKey(RouteRegistry.routes, function(r) {
    		var existingKeys = r.names.concat(Object.keys(r.defaults)).sort();
    		var keys = names.concat(Object.keys(defaults)).sort();
    		var sameMapKeys = !diff(existingKeys, keys).length;
    		var sameDefaultValues = !diffObject(r.defaults, defaults).length;
    		//the regex removes the trailing slash
    		var matchingRoutesWithoutTrailingSlash = r.route.replace(/\/$/, "") === url.replace(/\/$/, "");

    		if (sameMapKeys && sameDefaultValues && !matchingRoutesWithoutTrailingSlash) {
    			dev.warn('two routes were registered with matching keys:\n' +
    				'\t(1) route("' + r.route + '", ' + JSON.stringify(r.defaults) + ')\n' +
    				'\t(2) route("' + url + '", ' + JSON.stringify(defaults) + ')\n' +
    				'(1) will always be chosen since it was registered first');
    		}
    	});
    	//!steal-remove-end
    	// Add route in a form that can be easily figured out.
    	return RouteRegistry.routes[url] = {
    		// A regular expression that will match the route when variable values
    		// are present; i.e. for (`{page}/{type}`) the `RegExp` is `/([\w\.]*)/([\w\.]*)/` which
    		// will match for any value of `{page}` and `{type}` (word chars or period).
    		test: new RegExp("^" + test + "($|" + wrapQuote(querySeparator) + ")"),
    		// The original URL, same as the index for this entry in routes.
    		route: url,
    		// An `array` of all the variable names in this route.
    		names: names,
    		// Default values provided for the variables.
    		defaults: defaults,
    		// The number of parts in the URL separated by `/`.
    		length: url.split('/')
    			.length
    	};
    }
};

var register = RouteRegistry;

var decode = function(str){
	try {
		return decodeURIComponent(str);
	} catch(ex) {
		return unescape(str);
	}
};

// TODO: I'm not totally sure this belongs here. This might be shifted to can-route-pushstate.
function toURLFragment(url){
	var root =bindingProxy_1.call("root");
	// if the root ends with `/` and the url starts with it, remove /
    if (root.lastIndexOf("/") === root.length - 1 && url.indexOf("/") === 0) {
        url = url.substr(1);
    }
	return url;
}

function canRoute_getRule(url){

	url = toURLFragment(url);
    // See if the url matches any routes by testing it against the `route.test` `RegExp`.
    // By comparing the URL length the most specialized route that matches is used.
    var route = {
        length: -1
    };

    canReflect_1_16_7_canReflect.eachKey(register.routes, function (temp, name) {
        if (temp.test.test(url) && temp.length > route.length) {
            route = temp;
        }
    });
    // If a route was matched.
    if (route.length > -1) {
		return route;
	}
}

/**
 * @function can-route.deparam deparam
 * @parent can-route.static
 * @description Extract data from a route path.
 * @signature `route.deparam(url)`
 *
 * Extract data from a url, creating an object representing its values.
 *
 * ```js
 * route("{page}");
 *
 * var result = route.deparam("page=home");
 * console.log(result.page); // -> "home"
 * ```
 *
 * @param {String} url A route fragment to extract data from.
 * @return {Object} An object containing the extracted data.
 *
 * @body
 *
 * Creates a data object based on the query string passed into it. This is
 * useful to create an object based on the `location.hash`.
 *
 * ```js
 * route.deparam("id=5&type=videos");
 *   // -> { id: 5, type: "videos" }
 * ```
 *
 *
 * It's important to make sure the hash or exclamation point is not passed
 * to `route.deparam` otherwise it will be included in the first property's
 * name.
 *
 * ```js
 * route.data.id = 5 // location.hash -> #!id=5
 * route.data.type = "videos"
 *   // location.hash -> #!id=5&type=videos
 * route.deparam(location.hash);
 *   // -> { #!id: 5, type: "videos" }
 * ```
 *
 * `route.deparam` will try and find a matching route and, if it does,
 * will deconstruct the URL and parse out the key/value parameters into the
 * data object.
 *
 * ```js
 * route("{type}/{id}");
 *
 * route.deparam("videos/5");
 *   // -> { id: 5, route: "{type}/{id}", type: "videos" }
 * ```
 */
function canRoute_deparam(url) {

    var route = canRoute_getRule(url),
		querySeparator =bindingProxy_1.call("querySeparator"),
		paramsMatcher =bindingProxy_1.call("paramsMatcher");

	url = toURLFragment(url);

	// If a route was matched.
    if (route) {

        var // Since `RegExp` backreferences are used in `route.test` (parens)
        // the parts will contain the full matched string and each variable (back-referenced) value.
        parts = url.match(route.test),
            // Start will contain the full matched string; parts contain the variable values.
            start = parts.shift(),
            // The remainder will be the `&amp;key=value` list at the end of the URL.
            remainder = url.substr(start.length - (parts[parts.length - 1] === querySeparator ? 1 : 0)),
            // If there is a remainder and it contains a `&amp;key=value` list deparam it.
            obj = (remainder && paramsMatcher.test(remainder)) ? canDeparam_1_1_1_canDeparam(remainder.slice(1)) : {};

        // Add the default values for this route.
        obj = canReflect_1_16_7_canReflect.assignDeep(canReflect_1_16_7_canReflect.assignDeep({}, route.defaults), obj);
        // Overwrite each of the default values in `obj` with those in
        // parts if that part is not empty.
        parts.forEach(function (part, i) {
            if (part && part !== querySeparator) {
                obj[route.names[i]] = decode(part);
            }
        });
        return obj;
    }
    // If no route was matched, it is parsed as a `&amp;key=value` list.
    if (url.charAt(0) !== querySeparator) {
        url = querySeparator + url;
    }
    return paramsMatcher.test(url) ? canDeparam_1_1_1_canDeparam(url.slice(1)) : {};
}

canRoute_deparam.getRule = canRoute_getRule;


var deparam_1 = canRoute_deparam;

// Checks if a route matches the data provided. If any route variable
// is not present in the data, the route does not match. If all route
// variables are present in the data, the number of matches is returned
// to allow discerning between general and more specific routes.
var matchesData = function (route, data) {
	var count = 0,
		i = 0,
		defaults = {};
	// look at default values, if they match ...
	for (var name in route.defaults) {
		if (route.defaults[name] === data[name]) {
			// mark as matched
			defaults[name] = 1;
			count++;
		}
	}
	for (; i < route.names.length; i++) {
		if (!data.hasOwnProperty(route.names[i])) {
			return -1;
		}
		if (!defaults[route.names[i]]) {
			count++;
		}

	}

	return count;
};

function getMatchedRoute(data, routeName) {
	// Check if the provided data keys match the names in any routes;
    // Get the one with the most matches.
    var route,
        // Need to have at least 1 match.
        matches = 0,
        matchCount,
        propCount = 0;

    delete data.route;

    canReflect_1_16_7_canReflect.eachKey(data, function () {
        propCount++;
    });
    // Otherwise find route.
    canReflect_1_16_7_canReflect.eachKey(register.routes, function (temp, name) {
        // best route is the first with all defaults matching

        matchCount = matchesData(temp, data);
        if (matchCount > matches) {
            route = temp;
            matches = matchCount;
        }
        if (matchCount >= propCount) {
            return false;
        }
    });
    // If we have a route name in our `register` data, and it's
    // just as good as what currently matches, use that
    if (register.routes[routeName] && matchesData(register.routes[routeName], data) === matches) {
        route = register.routes[routeName];
    }
    // If this is match...
	return route;
}
function paramFromRoute(route, data) {
	var cpy,
		res,
		after,
		matcher;
	if (route) {

        cpy = canReflect_1_16_7_canReflect.assignMap({}, data);
        // fall back to legacy :foo RegExp if necessary
        matcher = regexps.colon.test(route.route) ? regexps.colon : regexps.curlies;
        // Create the url by replacing the var names with the provided data.
        // If the default value is found an empty string is inserted.
        res = route.route.replace(matcher, function (whole, name) {
            delete cpy[name];
            return data[name] === route.defaults[name] ? "" : encodeURIComponent(data[name]);
        })
        .replace("\\", "");
        // Remove matching default values
        canReflect_1_16_7_canReflect.eachKey(route.defaults, function (val, name) {
            if (cpy[name] === val) {
                delete cpy[name];
            }
        });
        // The remaining elements of data are added as
        // `&amp;` separated parameters to the url.
        after = canParam_1_0_4_canParam(cpy);
        // if we are paraming for setting the hash
        // we also want to make sure the route value is updated
        //if (_setRoute) {
        //    register.matched(route.route);
        //}
        return res + (after ? bindingProxy_1.call("querySeparator") + after : "");
    }
    // If no route was found, there is no hash URL, only paramters.
    return canReflect_1_16_7_canReflect.size(data) === 0 ? "" :bindingProxy_1.call("querySeparator") + canParam_1_0_4_canParam(data);
}


/**
 * @function can-route.param param
 * @parent can-route.static
 * @description Get a route path from given data.
 * @signature `route.param(data)`
 * @param {data} object The data to populate the route with.
 * @param {String} [currentRouteName] The current route name.  If provided, this
 * can be used to "stick" the url to a previous route. By "stick", we mean that
 * if there are multiple registered routes that match the `object`, the
 * the `currentRouteName` will be used.
 * @return {String} The route, with the data populated in it.
 *
 * @body
 * Parameterizes the raw JS object representation provided in data.
 *
 * ```js
 * route.param({ type: "video", id: 5 });
 *   // -> "type=video&id=5"
 * ```
 *
 * If a route matching the provided data is found, that URL is built
 * from the data. Any remaining data is added at the end of the
 * URL as &amp; separated key/value parameters.
 *
 * ```js
 * route("{type}/{id}");
 *
 * route.param({ type: "video", id: 5 }) // -> "video/5"
 * route.param({ type: "video", id: 5, isNew: false })
 *   // -> "video/5&isNew=false"
 * ```
 */
function canRoute_param(data, currentRouteName) {
 	return paramFromRoute(getMatchedRoute(data, currentRouteName), data);
}
var param_1 = canRoute_param;
canRoute_param.paramFromRoute = paramFromRoute;
canRoute_param.getMatchedRoute = getMatchedRoute;

// Returns `true` if the object can have properties (no `null`s).
var isContainer = function (current) {
    return /^f|^o/.test(typeof current);
};

/**
 * @module {function} can-util/js/get/get get
 * @parent can-util/js
 *
 * @signature `get(obj, path)`
 * @param  {Object} obj the object to use as the root for property based navigation
 * @param  {String} path a String of dot-separated keys, representing a path of properties
 * @return {*}       the value at the property path
 *
 * A *path* is a dot-delimited sequence of zero or more property names, such that "foo.bar" means "the property
 * 'bar' of the object at the property 'foo' of the root."  An empty path returns the object passed.
 *
 * ```js
 * var get = require("can-util/js/get/get");
 * console.log(get({a: {b: {c: "foo"}}}, "a.b.c")); // -> "foo"
 * console.log(get({a: {}}, "a.b.c")); // -> undefined
 * console.log(get([{a: {}}, {a: {b: "bar"}}], "a.b")); // -> "bar"
 * ```
 */
function get$2(obj, name) {
    // The parts of the name we are looking up
    // `['App','Models','Recipe']`
    var parts = typeof name !== 'undefined' ? (name + '').replace(/\[/g,'.')
    		.replace(/]/g,'').split('.') : [],
        length = parts.length,
        current, i, container;

    if (!length) {
        return obj;
    }

    current = obj;

    // Walk current to the 2nd to last object or until there
    // is not a container.
    for (i = 0; i < length && isContainer(current) && current !== null; i++) {
        container = current;
        current = container[parts[i]];
    }

    return current;
}

var get_1$1 = get$2;

var hasWarned = false;

var isArray = function(arr) {
	//!steal-remove-start
	if (!hasWarned) {
		dev.warn('js/is-array/is-array is deprecated; use Array.isArray');
		hasWarned = true;
	}
	//!steal-remove-end

	return Array.isArray(arr);
};

// ##string.js
// _Miscellaneous string utility functions._
// Several of the methods in this plugin use code adapted from Prototype
// Prototype JavaScript framework, version 1.6.0.1.
// Â© 2005-2007 Sam Stephenson
/**
 * @module {{}} can-util/js/string/string string
 * @parent can-util/js
 *
 * @description  String utilities used by CanJS libraries
 */
var strUndHash$1 = /_|-/,
	strColons$1 = /\=\=/,
	strWords$1 = /([A-Z]+)([A-Z][a-z])/g,
	strLowUp$1 = /([a-z\d])([A-Z])/g,
	strDash$1 = /([a-z\d])([A-Z])/g,
	strReplacer = /\{([^\}]+)\}/g,
	strQuote$1 = /"/g,
	strSingleQuote$1 = /'/g,
	strHyphenMatch$1 = /-+(.)?/g,
	strCamelMatch$1 = /[a-z][A-Z]/g,
	convertBadValues$1 = function (content) {
		// Convert bad values into empty strings
		var isInvalid = content === null || content === undefined || isNaN(content) && '' + content === 'NaN';
		return '' + (isInvalid ? '' : content);
	},
	deleteAtPath = function(data, path) {
		var parts = path ? path.replace(/\[/g,'.')
			.replace(/]/g,'').split('.') : [];
		var current = data;

		for(var i = 0; i < parts.length - 1; i++) {
			if(current) {
				current = current[parts[i]];
			}
		}

		if(current) {
			delete current[parts[parts.length - 1 ]];
		}
	};

var string$1 = {
	/**
	 * @function can-util/js/string/string.esc string.esc
	 * @signature `string.esc(content)`
	 * @param  {String} content a string
	 * @return {String}         the string safely HTML-escaped
	 * 
	 * ```js
	 * var string = require("can-util/js/string/string");
	 * 
	 * string.esc("<div>&nbsp;</div>"); //-> "&lt;div&gt;&amp;nbsp;&lt;/div&gt;"
	 * ```
	 */
	esc: function (content) {
		return convertBadValues$1(content)
			.replace(/&/g, '&amp;')
			.replace(/</g, '&lt;')
			.replace(/>/g, '&gt;')
			.replace(strQuote$1, '&#34;')
			.replace(strSingleQuote$1, '&#39;');
	},
	/**
	 * @function can-util/js/string/string.getObject string.getObject
	 * @signature `string.getObject(name, roots)`
	 * @param  {String} name  a String of dot-separated keys, representing a path of properties
	 * @param  {Object|Array} roots the object to use as the root for property based navigation
	 * @return {*}       the value at the property path descending from `roots`
	 *
	 * Return the result of descending the path `name` through the properties of the object or objects
	 * `roots`
	 *
	 * If `roots` is an Array, each element of the array is evaluated, in order, until
	 * the path is found in an element's properties (and properties-of-properties, etc.).  Otherwise
	 * `roots` is evaluated as the root object, returning either the object at the property path
	 * descended from `roots` or `undefined` if any subpath is not found.
	 *
	 * A *path* is a dot-delimited sequence of zero or more property names, such that "foo.bar" means "the property
	 * 'bar' of the object at the property 'foo' of the root."  An empty path returns the first object in `roots`
	 * if it's an array, `roots` itself otherwise.
	 *
	 * ```js
	 * var string = require("can-util/js/string/string");
	 * 
	 * console.log(string.getObject("a.b.c", {a: {b: {c: "foo"}}})); // -> "foo"
	 * console.log(string.getObject("a.b.c", {a: {}})); // -> undefined
	 * console.log(string.getObject("a.b", [{a: {}}, {a: {b: "bar"}}])); // -> "bar"
	 * ```
	 */
	getObject: function (name, roots) {
		//!steal-remove-start
		dev.warn('string.getObject is deprecated, please use can-util/js/get/get instead.');
		//!steal-remove-end

		roots = isArray(roots) ? roots : [roots || window];

		var result, l = roots.length;

		for(var i = 0; i < l; i++) {
			result = get_1$1(roots[i], name);

			if(result) {
				return result;
			}
		}
	},
	/**
	 * @function can-util/js/string/string.capitalize string.capitalize
	 * @signature `string.capitalize(s)`
	 * @param  {String} s     the string to capitalize
	 * @return {String}       the supplied string with the first character uppercased if it is a letter
	 *
	 * ```js
	 * var string = require("can-util/js/string/string");
	 *
	 * console.log(string.capitalize("foo")); // -> "Foo"
	 * console.log(string.capitalize("123")); // -> "123"
	 * ```
	 */
	capitalize: function (s, cache) {
		// Used to make newId.
		return s.charAt(0)
			.toUpperCase() + s.slice(1);
	},
	/**
	 * @function can-util/js/string/string.camelize string.camelize
	 * @signature `string.camelize(s)`
	 * @param  {String} str   the string to camelCase
	 * @return {String}       the supplied string with hyphens removed and following letters capitalized.
	 *
	 * ```js
	 * var string = require("can-util/js/string/string");
	 *
	 * console.log(string.camelize("foo-bar")); // -> "fooBar"
	 * console.log(string.camelize("-webkit-flex-flow")); // -> "WebkitFlexFlow"
	 * ```
	 */
	camelize: function (str) {
		return convertBadValues$1(str)
			.replace(strHyphenMatch$1, function (match, chr) {
				return chr ? chr.toUpperCase() : '';
			});
	},
	/**
	 * @function can-util/js/string/string.hyphenate string.hyphenate
	 * @signature `string.hyphenate(s)`
	 * @param  {String} str   a string in camelCase
	 * @return {String}       the supplied string with camelCase converted to hyphen-lowercase digraphs
	 *
	 * ```js
	 * var string = require("can-util/js/string/string");
	 *
	 * console.log(string.hyphenate("fooBar")); // -> "foo-bar"
	 * console.log(string.hyphenate("WebkitFlexFlow")); // -> "Webkit-flex-flow"
	 * ```
	 */
	hyphenate: function (str) {
		return convertBadValues$1(str)
			.replace(strCamelMatch$1, function (str, offset) {
				return str.charAt(0) + '-' + str.charAt(1)
					.toLowerCase();
			});
	},
	/**
	 * @function can-util/js/string/string.underscore string.underscore
	 * @signature `string.underscore(s)`
	 * @param  {String} str   a string in camelCase
	 * @return {String}       the supplied string with camelCase converted to underscore-lowercase digraphs
	 *
	 * ```js
	 * var string = require("can-util/js/string/string");
	 *
	 * console.log(string.underscore("fooBar")); // -> "foo_bar"
	 * console.log(string.underscore("HTMLElement")); // -> "html_element"
	 * ```
	 */
	underscore: function (s) {
		return s.replace(strColons$1, '/')
			.replace(strWords$1, '$1_$2')
			.replace(strLowUp$1, '$1_$2')
			.replace(strDash$1, '_')
			.toLowerCase();
	},
	/**
	 * @function can-util/js/string/string.sub string.sub
	 * @signature `string.sub(str, data, remove)`
	 * @param {String} str   a string with {curly brace} delimited property names
	 * @param {Object} data  an object from which to read properties
	 * @return {String|null} the supplied string with delimited properties replaced with their values
	 *                       if all properties exist on the object, null otherwise
	 *
	 * If `remove` is true, the properties found in delimiters in `str` are removed from `data`.
	 *
	 * ```js
	 * var string = require("can-util/js/string/string");
	 *
	 * console.log(string.sub("foo_{bar}", {bar: "baz"}})); // -> "foo_baz"
	 * console.log(string.sub("foo_{bar}", {})); // -> null
	 * ```
	 */
	sub: function (str, data, remove) {
		var obs = [];
		str = str || '';
		obs.push(str.replace(strReplacer, function (whole, inside) {
			// Convert inside to type.
			var ob = get_1$1(data, inside);

			if(remove === true) {
				deleteAtPath(data, inside);
			}

			if (ob === undefined || ob === null) {
				obs = null;
				return '';
			}
			// If a container, push into objs (which will return objects found).
			if (isContainer(ob) && obs) {
				obs.push(ob);
				return '';
			}
			return '' + ob;
		}));
		return obs === null ? obs : obs.length <= 1 ? obs[0] : obs;
	},

	/**
	 * @function can-util/js/string/string.replaceWith string.replaceWith
	 * @signature `string.replaceWith(str, data, replacer, remove)`
	 * @param {String} str string with {curly brace} delimited property names
	 * @param {Object} data object from which to read properties
	 * @param {Function} replacer function which returns string replacements
	 * @param {Boolean} shouldRemoveMatchedPaths whether to remove properties found in delimiters in `str` from `data`
	 * @return {String} the supplied string with delimited properties replaced with their values
	 *
	 *
	 * ```js
	 * var string = require("can-util/js/string/string");
	 * var answer = string.replaceWith(
	 *   '{.}{.}{.}{.}{.} Batman!',
	 *   {},
	 *   () => 'Na'
	 * );
	 * // => 'NaNaNaNaNa Batman!'
	 * ```
	 */
	replaceWith: function (str, data, replacer, shouldRemoveMatchedPaths) {
		return str.replace(strReplacer, function (whole, path) {
			var value = get_1$1(data, path);
			if(shouldRemoveMatchedPaths) {
				deleteAtPath(data, path);
			}
			return replacer(path, value);
		});
	},

	/**
	 * @property {RegExp} can-util/js/string/string.strReplacer string.strReplacer
	 *
	 * The regex used to find replacement sections in [can-util/js/string/string.sub string.sub]
	 */
	replacer: strReplacer,
	/**
	 * @property {RegExp} can-util/js/string/string.strUndHash string.strUndHash
	 *
	 * A regex which matches an underscore or hyphen character
	 */
	undHash: strUndHash$1
};
var string_1 = string$1;

var makeProps = function (props) {
	var tags = [];
	canReflect_1_16_7_canReflect.eachKey(props, function (val, name) {
		tags.push((name === 'className' ? 'class' : name) + '="' +
			(name === "href" ? val : string_1.esc(val)) + '"');
	});
	return tags.join(" ");
};
var matchCheck = function(source, matcher){
	/*jshint eqeqeq:false*/
	for(var prop in source) {
		var s = source[prop],
			m = matcher[prop];
		if(s && m && typeof s === "object" && typeof matcher === "object") {
			return matchCheck(s, m);
		}
		if(s != m) {
			return false;
		}
	}
	return true;
};

function canRoute_url(options, merge) {

    if (merge) {
        var baseOptions = deparam_1(bindingProxy_1.call("can.getValue"));
        options = canReflect_1_16_7_canReflect.assignMap(canReflect_1_16_7_canReflect.assignMap({}, baseOptions), options);
    }
    return bindingProxy_1.call("root") +param_1(options);
}
var urlHelpers = {
    /**
     * @function can-route.url url
     * @parent can-route.static
     * @description Creates a URL fragment based on registered routes given a set of data.
     * @signature `route.url(data [, merge])`
     *
     * Make a URL fragment that when set to window.location.hash will update can-route's properties
     * to match those in `data`.
     *
     * ```js
     * route.url({ page: "home" });
     * // -> "#!page=home"
     * ```
     *
     * @param {Object} data The data to populate the route with.
     * @param {Boolean} [merge] Whether the given options should be merged into
     * the current state of the route.
     * @return {String} The route URL and query string.
     *
     * @body
     * Similar to [can-route.link], but instead of creating an anchor tag,
     * `route.url` creates only the URL based on the route options passed into it.
     *
     * ```js
     * route.url( { type: "videos", id: 5 } );
     *   // -> "#!type=videos&id=5"
     * ```
     *
     * If a route matching the provided data is found the URL is built from the
     * data. Any remaining data is added at the end of the URL as & separated
     * key/value parameters.
     *
     * ```js
     * route("{type}/{id}");
     *
     * route.url( { type: "videos", id: 5 } ) // -> "#!videos/5"
     * route.url( { type: "video", id: 5, isNew: false } )
     *   // -> "#!video/5&isNew=false"
     * ```
     */
    url: canRoute_url,
    /**
     * @function can-route.link link
     * @parent can-route.static
     * @description Creates a string representation of an anchor link using
     * data and the registered routes.
     * @signature `route.link(innerText, data, props [, merge])`
     *
     * Make an anchor tag (`<A>`) that when clicked on will update can-route's
     * properties to match those in `data`.
     *
     * @param {Object} innerText The text inside the link.
     * @param {Object} data The data to populate the route with.
     * @param {Object} props Properties for the anchor other than `href`.
     * @param {Boolean} [merge] Whether the given options should be merged into the current state of the route.
     * @return {String} A string with an anchor tag that points to the populated route.
     *
     * @body
     * Creates and returns an anchor tag with an href of the route
     * attributes passed into it, as well as any properties desired
     * for the tag.
     *
     * ```js
     * route.link( "My videos", { type: "videos" }, {}, false )
     *   // -> <a href="#!type=videos">My videos</a>
     * ```
     *
     * Other attributes besides href can be added to the anchor tag
     * by passing in a data object with the attributes desired.
     *
     * ```js
     * route.link( "My videos", { type: "videos" },
     *   { className: "new" }, false )
     *     // -> <a href="#!type=videos" class="new">My Videos</a>
     * ```
     *
     * It is possible to utilize the current route options when making anchor
     * tags in order to make your code more reusable. If merge is set to true,
     * the route options passed into `canRoute.link` will be passed into the
     * current ones.
     *
     * ```js
     * location.hash = "#!type=videos"
     * route.link( "The zoo", { id: 5 }, true )
     *   // -> <a href="#!type=videos&id=5">The zoo</true>
     *
     * location.hash = "#!type=pictures"
     * route.link( "The zoo", { id: 5 }, true )
     *   // -> <a href="#!type=pictures&id=5">The zoo</true>
     * ```
     */
    link: function canRoute_link(name, options, props, merge) {
        return "<a " + makeProps(
            canReflect_1_16_7_canReflect.assignMap({
                href: canRoute_url(options, merge)
            }, props)) + ">" + name + "</a>";
    },
    /**
     * @function can-route.isCurrent isCurrent
     * @parent can-route.static
     *
     * Check if data represents the current route.
     *
     * @signature `route.isCurrent(data [,subsetMatch] )`
     *
     * Compares `data` to the current route. Used to verify if an object is
     * representative of the current route.
     *
     * ```
     * route.data.set({page: "recipes", id: '5'});
     *
     * route.isCurrent({page: "recipes"});       //-> false
     * route.isCurrent({page: "recipes"}, true); //-> true
     * ```
     *
     *   @param {Object} data Data to check agains the current route.
     *   @param {Boolean} [subsetMatch] If true, `route.current` will return true
     *   if every value in `data` matches the current route data, even if
     *   the route data has additional properties that are not matched.  Defaults to `false`
     *   where every property needs to be present.
     *   @return {Boolean} Whether the data matches the current URL.
     *
     * @body
     *
     * ## Use
     *
     * Checks the page's current URL to see if the route represents the options
     * passed into the function.
     *
     * Returns true if the options represent the current URL.
     *
     * ```js
     * route.data.id = 5; // location.hash -> "#!id=5"
     * route.isCurrent({ id: 5 }); // -> true
     * route.isCurrent({ id: 5, type: 'videos' }); // -> false
     *
     * route.data.type = 'videos';
     *   // location.hash -> #!id=5&type=videos
     * route.isCurrent({ id: 5, type: 'videos' }); // -> true
     * ```
     */
    isCurrent: function canRoute_isCurrent(options, subsetMatch) {
		if(subsetMatch) {
			// everything in options shouhld be in baseOptions
			var baseOptions = deparam_1( bindingProxy_1.call("can.getValue") );
			return matchCheck(options, baseOptions);
		} else {
			return bindingProxy_1.call("can.getValue") === param_1(options);
		}
	}
};

// Regular expression for identifying &amp;key=value lists.
var paramsMatcher = /^(?:&[^=]+=[^&]*)+/;











function getHash(){
    var loc = location();
    return loc.href.split(/#!?/)[1] || "";
}

function HashchangeObservable() {
    var dispatchHandlers =  this.dispatchHandlers.bind(this);
    var self = this;
    this.handlers = new canKeyTree_1_0_2_canKeyTree([Object,Array],{
        onFirst: function(){
            self.value = getHash();
            canDomEvents_1_2_0_canDomEvents.addEventListener(window, 'hashchange', dispatchHandlers);
        },
        onEmpty: function(){
            canDomEvents_1_2_0_canDomEvents.removeEventListener(window, 'hashchange', dispatchHandlers);
        }
    });
}
HashchangeObservable.prototype = Object.create(canSimpleObservable_2_0_4_canSimpleObservable.prototype);
HashchangeObservable.constructor = HashchangeObservable;
canReflect_1_16_7_canReflect.assign(HashchangeObservable.prototype,{
    // STUFF NEEDED FOR can-route integration
    paramsMatcher: paramsMatcher,
    querySeparator: "&",
    // don't greedily match slashes in routing rules
    matchSlashes: false,
    root: "#!",
    dispatchHandlers: function() {
        var old = this.value;
        this.value = getHash();
        if(old !== this.value) {
            canQueues_1_1_0_canQueues.enqueueByQueue(this.handlers.getNode([]), this, [this.value, old]
                //!steal-remove-start
                /* jshint laxcomma: true */
                , null
                , [ canReflect_1_16_7_canReflect.getName(this), "changed to", this.value, "from", old ]
                /* jshint laxcomma: false */
                //!steal-remove-end
            );
        }
    },
    get: function(){
        canObservationRecorder_1_1_2_canObservationRecorder.add(this);
        return getHash();
    },
    set: function(path){
        var loc = location();
        if(!path && !loc.path) {

        } else if(loc.hash !== "#" + path) {
            loc.hash = "!" + path;
        }
        return path;
    }
});

canReflect_1_16_7_canReflect.assignSymbols(HashchangeObservable.prototype,{
	"can.getValue": HashchangeObservable.prototype.get,
	"can.setValue": HashchangeObservable.prototype.set,
	"can.onValue": HashchangeObservable.prototype.on,
	"can.offValue": HashchangeObservable.prototype.off,
	"can.isMapLike": false,
	"can.valueHasDependencies": function(){
		return true;
	},
	//!steal-remove-start
	"can.getName": function() {
		return "HashchangeObservable<" + this.value + ">";
	},
	//!steal-remove-end
});

var hashchange = new HashchangeObservable();

/* globals WorkerGlobalScope */
// A bit of weirdness to avoid complaining linters
var funcConstructor = Function;


/**
 * @module {function} can-globals/is-browser-window/is-web-worker is-web-worker
 * @parent can-globals/modules
 * @signature `isWebWorker()`
 *
 * Returns `true` if the code is running within a [web worker](https://developer.mozilla.org/en-US/docs/Web/API/Worker).
 *
 * ```js
 * var isWebWorker = require("can-globals/is-web-worker/is-web-worker");
 * var GLOBAL = require("can-globals/global/global");
 *
 * if(isWebWorker()) {
 *   ...
 * }
 * ```
 *
 * @return {Boolean} True if the environment is a web worker.
 */

canGlobals_1_1_1_canGlobalsInstance.define('isWebWorker', function(){
    var global = funcConstructor('return this')();
    return typeof WorkerGlobalScope !== "undefined" &&
        (global instanceof WorkerGlobalScope);
});

var isWebWorker = canGlobals_1_1_1_canGlobalsInstance.makeExport('isWebWorker');

/*jshint -W079 */






















bindingProxy_1.bindings.hashchange = hashchange;
bindingProxy_1.defaultBinding = "hashchange";

// ## route.js
// `can-route`
// _Helps manage browser history (and client state) by synchronizing the
// `window.location.hash` with a `Map`._

function canRoute(url, defaults){
	//!steal-remove-start
	dev.warn('Call route.register(url,defaults) instead of calling route(url, defaults)');
	//!steal-remove-end
	register.register(url, defaults);
	return canRoute;
}


// Helper methods used for matching routes.


// A ~~throttled~~ debounced function called multiple times will only fire once the
// timer runs down. Each call resets the timer.
var timer;
// A dummy events object used to dispatch url change events on.
var currentRuleObservable = new canObservation_4_0_1_canObservation(function canRoute_matchedRoute(){
	var url = bindingProxy_1.call("can.getValue");
	return canRoute.rule(url);
});


// If the `route.data` changes, update the hash.
// Using `.serialize()` retrieves the raw data contained in the `observable`.
// This function is ~~throttled~~ debounced so it only updates once even if multiple values changed.
// This might be able to use batchNum and avoid this.
function updateUrl(serializedData) {
	// collect attributes that are changing
	clearTimeout(timer);
	timer = setTimeout(function () {
		// indicate that the hash is set to look like the data
		var serialized = canReflect_1_16_7_canReflect.serialize( canRoute.data ),
			currentRouteName = currentRuleObservable.get(),
			route = param_1.getMatchedRoute(serialized, currentRouteName),
			path = param_1.paramFromRoute(route, serialized);

		bindingProxy_1.call("can.setValue", path);
	}, 10);
}

//!steal-remove-start
Object.defineProperty(updateUrl, "name", {
	value: "can-route.updateUrl"
});
//!steal-remove-end


// Deparameterizes the portion of the hash of interest and assign the
// values to the `route.data` removing existing values no longer in the hash.
// updateRouteData is called typically by hashchange which fires asynchronously
// So itâ€™s possible that someone started changing the data before the
// hashchange event fired.  For this reason, it will not set the route data
// if the data is changing or the hash already matches the hash that was set.
function updateRouteData() {
	var hash = bindingProxy_1.call("can.getValue");
	// if the hash data is currently changing, or
	// the hash is what we set it to anyway, do NOT change the hash

	canQueues_1_1_0_canQueues.batch.start();

	var state = canRoute.deparam(hash);
	delete state.route;
	canReflect_1_16_7_canReflect.update(canRoute.data,state);
	canQueues_1_1_0_canQueues.batch.stop();

}
//!steal-remove-start
Object.defineProperty(updateRouteData, "name", {
	value: "can-route.updateRouteData"
});
//!steal-remove-end


/**
 * @static
 */
Object.defineProperty(canRoute,"routes",{
	/**
	 * @property {Object} routes
	 * @hide
	 *
	 * A list of routes recognized by the router indixed by the url used to add it.
	 * Each route is an object with these members:
	 *
	 *  - test - A regular expression that will match the route when variable values
	 *    are present; i.e. for {page}/{type} the `RegExp` is /([\w\.]*)/([\w\.]*)/ which
	 *    will match for any value of {page} and {type} (word chars or period).
	 *
	 *  - route - The original URL, same as the index for this entry in routes.
	 *
	 *  - names - An array of all the variable names in this route
	 *
	 *  - defaults - Default values provided for the variables or an empty object.
	 *
	 *  - length - The number of parts in the URL separated by '/'.
	 */
 	get: function() {
 		return register.routes;
 	},
	set: function(newVal) {
		return register.routes = newVal;
	}
});
Object.defineProperty(canRoute,"defaultBinding",{
 	get: function(){
		return bindingProxy_1.defaultBinding;
	},
	set: function(newVal){
		bindingProxy_1.defaultBinding = newVal;
	}
});
Object.defineProperty(canRoute,"currentBinding",{
 	get: function(){
		return bindingProxy_1.currentBinding;
	},
	set: function(newVal){
		bindingProxy_1.currentBinding = newVal;
	}
});

canReflect_1_16_7_canReflect.assignMap(canRoute, {
	param: param_1,
	deparam: deparam_1,
	map: function(data){
		//!steal-remove-start
		dev.warn('Set route.data directly instead of calling route.map');
		//!steal-remove-end
		canRoute.data = data;
	},


	start: function (val) {
		if (val !== true) {
			canRoute._setup();
			if(isBrowserWindow() || isWebWorker()) {
				// We can't use updateRouteData because we want to merge the route data
				// into .data
				var hash = bindingProxy_1.call("can.getValue");
				canQueues_1_1_0_canQueues.batch.start();
				// get teh data
				var state = canRoute.deparam(hash);
				delete state.route;

				canReflect_1_16_7_canReflect.assign(canRoute.data,state);
				canQueues_1_1_0_canQueues.batch.stop();
				updateUrl();
			}
		}
		return canRoute;
	},
	url: urlHelpers.url,
	link: urlHelpers.link,
	isCurrent: urlHelpers.isCurrent,
	bindings: bindingProxy_1.bindings,

	// ready calls setup
	// setup binds and listens to data changes
	// bind listens to whatever you should be listening to
	// data changes tries to set the path

	// we need to be able to
	// easily kick off calling updateRouteData
	// 	teardown whatever is there
	//  turn on a particular binding

	// called when the route is ready
	_setup: function () {
		if (!canRoute.currentBinding) {
			bindingProxy_1.call("can.onValue", updateRouteData);
			canReflect_1_16_7_canReflect.onValue( canRoute.serializedObservation, updateUrl, "notify");
			canRoute.currentBinding =canRoute.defaultBinding;
		}
	},
	_teardown: function () {
		if (canRoute.currentBinding) {
			bindingProxy_1.call("can.offValue", updateRouteData);
			canReflect_1_16_7_canReflect.offValue( canRoute.serializedObservation, updateUrl, "notify");
			canRoute.currentBinding = null;
		}
		clearTimeout(timer);
	},

	stop: function() {
		this._teardown();
		return canRoute;
	},

	currentRule: makeCompute( currentRuleObservable ),
	register: register.register,
	rule: function(url){
		var rule = deparam_1.getRule(url);
		if(rule) {
			return rule.route;
		}
	}
});

// The functions in the following list applied to `canRoute` (e.g. `canRoute.attr('...')`) will
// instead act on the `canRoute.data` observe.

var bindToCanRouteData = function(name, args) {
	if (!canRoute.data[name]) {
		return canRoute.data.addEventListener.apply(canRoute.data, args);
	}
	return canRoute.data[name].apply(canRoute.data, args);
};

['addEventListener','removeEventListener','bind', 'unbind', 'on', 'off'].forEach(function(name) {
	// exposing all internal eventQueue evtâ€™s to canRoute
	canRoute[name] = function(eventName, handler) {
		if (eventName === '__url') {
			return bindingProxy_1.call("can.onValue", handler );
		}
		return bindToCanRouteData(name, arguments);
	};
});

['delegate', 'undelegate', 'removeAttr', 'compute', '_get', '___get', 'each'].forEach(function (name) {
	canRoute[name] = function () {
		// `delegate` and `undelegate` require
		// the `can/map/delegate` plugin
		return bindToCanRouteData(name, arguments);
	};
});


var routeData;
var setRouteData = function(data){
	routeData = data;
	return routeData;
};
var serializedObservation;
var serializedCompute;

Object.defineProperty(canRoute,"serializedObservation", {
	get: function(){
		if(!serializedObservation) {
			serializedObservation = new canObservation_4_0_1_canObservation(function canRoute_data_serialized(){
				return canReflect_1_16_7_canReflect.serialize( canRoute.data );
			});
		}
		return serializedObservation;
	}
});
Object.defineProperty(canRoute,"serializedCompute", {
	get: function(){
		if(!serializedCompute) {
			serializedCompute = makeCompute(canRoute.serializedObservation);
		}
		return serializedCompute;
	}
});
// Helper for convert any object (or value) to stringified object (or value)
var stringify = function (obj) {
	// Object is array, plain object, Map or List
	if (obj && typeof obj === "object") {
		if (obj && typeof obj === "object" && ("serialize" in obj)) {
			obj = obj.serialize();
		} else {
			// Get array from array-like or shallow-copy object
			obj = typeof obj.slice === "function" ? obj.slice() : canReflect_1_16_7_canReflect.assign({}, obj);
		}
		// Convert each object property or array item into stringified new
		canReflect_1_16_7_canReflect.eachKey(obj, function (val, prop) {
			obj[prop] = stringify(val);
		});
		// Object supports toString function
	} else if (obj !== undefined && obj !== null && (typeof obj.toString === "function" )) {
		obj = obj.toString();
	}

	return obj;
};
// everything in the backing Map is a string
// add type coercion during Map setter to coerce all values to strings so unexpected conflicts don't happen.
// https://github.com/canjs/canjs/issues/2206
var stringCoercingMapDecorator = function(map) {
	var sym = canSymbol_1_6_1_canSymbol.for("can.route.stringCoercingMapDecorator");
	if(!map.attr[sym]) {
		var attrSuper = map.attr;

		map.attr = function(prop, val) {
			var serializable = this.define === undefined || this.define[prop] === undefined || !!this.define[prop].serialize,
				args;

			if (serializable) { // if setting non-str non-num attr
				args = stringify(Array.apply(null, arguments));
			} else {
				args = arguments;
			}

			return attrSuper.apply(this, args);
		};
		canReflect_1_16_7_canReflect.setKeyValue(map.attr, sym, true);
	}

	return map;
};

var viewModelSymbol$1 = canSymbol_1_6_1_canSymbol.for("can.viewModel");
Object.defineProperty(canRoute,"data", {
	get: function(){
		if(routeData) {
			return routeData;
		} else {
			return setRouteData( stringCoercingMapDecorator( new canSimpleMap_4_1_1_canSimpleMap() ) );
		}
	},
	set: function(data) {
		if( canReflect_1_16_7_canReflect.isConstructorLike(data) ){
			data = new data();
		}
		if(data && data[viewModelSymbol$1] !== undefined) {
			data = data[viewModelSymbol$1];
		}
		// if itâ€™s a map, we make it always set strings for backwards compat
		if( "attr" in data ) {
			setRouteData( stringCoercingMapDecorator(data) );
		} else {
			setRouteData(data);
		}
	}
});

canRoute.attr = function(prop, value){
	console.warn("can-route: can-route.attr is deprecated. Use methods on can-route.data instead.");
	if("attr" in canRoute.data) {
		return canRoute.data.attr.apply(canRoute.data, arguments);
	} else {
		if(arguments.length > 1) {
			canReflect_1_16_7_canReflect.setKeyValue(canRoute.data, prop, value);
			return canRoute.data;
		} else if(typeof prop === 'object') {
			canReflect_1_16_7_canReflect.assignDeep(canRoute.data,prop);
			return canRoute.data;
		} else if(arguments.length === 1){
			return canReflect_1_16_7_canReflect.getKeyValue(canRoute.data, prop);
		} else {
			return canReflect_1_16_7_canReflect.unwrap(canRoute.data);
		}
	}
};


canReflect_1_16_7_canReflect.setKeyValue(canRoute, canSymbol_1_6_1_canSymbol.for("can.isFunctionLike"), false);

// LEGACY
canRoute.matched = canRoute.currentRule;
canRoute.current = canRoute.isCurrent;

var canRoute_4_1_2_canRoute = canNamespace_1_0_0_canNamespace.route = canRoute;

var looksLikeOptions$1 = core$2.looksLikeOptions;

var calculateArgs = function(){
	var finalParams,
		finalMerge,
		optionsArg;

	canReflect_1_16_7_canReflect.eachIndex(arguments, function(arg){
		if(typeof arg === "boolean") {
			finalMerge = arg;
		} else if( arg && typeof arg === "object"  ) {
			if(!looksLikeOptions$1(arg) ) {
				finalParams = core$2.resolveHash(arg);
			} else {
				optionsArg = arg;
			}
		}
	});

	if(!finalParams && optionsArg) {
		finalParams = core$2.resolveHash(optionsArg.hash);
	}
	return {
		finalParams: finalParams || {},
		finalMerge: finalMerge,
		optionsArg: optionsArg
	};
};


// go through arguments ... if there's a boolean ... if there's a plain object
core$2.registerHelper('routeUrl',function(){
	var args = calculateArgs.apply(this, arguments);

	return canRoute_4_1_2_canRoute.url(args.finalParams, typeof args.finalMerge === "boolean" ? args.finalMerge : undefined);

});

var routeCurrent = function(){

	var args = calculateArgs.apply(this, arguments);
	var result = canRoute_4_1_2_canRoute.current( args.finalParams, typeof args.finalMerge === "boolean" ? args.finalMerge : undefined );

	if( args.optionsArg && !(args.optionsArg instanceof expression_1.Call) ) {
		if( result ) {
			return args.optionsArg.fn();
		} else {
			return args.optionsArg.inverse();
		}
	} else {
		return result;
	}
};
routeCurrent.callAsMethod = true;

core$2.registerHelper('routeCurrent', routeCurrent);

var canStacheRouteHelpers_1_0_0_canStacheRouteHelpers = {

};

var baseEventType = 'keyup';

function isEnterEvent (event) {
	var hasEnterKey = event.key === 'Enter';
	var hasEnterCode = event.keyCode === 13;
	return hasEnterKey || hasEnterCode;
}

/**
 * @module {events} can-event-dom-enter
 * @parent can-dom-utilities
 * @collection can-infrastructure
 * @group can-event-dom-enter.modules modules
 * @package ./package.json
 *
 * Watch for when enter keys are pressed on a DomEventTarget.
 *
 * ```js
 * var domEvents = require('can-dom-events');
 * var enterEvent = require('can-event-dom-enter');
 *
 * domEvents.addEvent(enterEvent);
 *
 * var input = document.createElement('input');
 * function enterEventHandler() {
 * 	console.log('enter key pressed');
 * }
 *
 * domEvents.addEventHandler(input, 'enter', enterEventHandler);
 * domEvents.dispatch(input, {
 *   type: 'keyup',
 *   keyCode: keyCode
 * });
 * ```
 */
var enterEvent = {
	defaultEventType: 'enter',

	addEventListener: function (target, eventType, handler) {
		var keyHandler = function (event) {
			if (isEnterEvent(event)) {
				return handler.apply(this, arguments);
			}
		};

		var handlerMap = enterEvent._eventTypeHandlerMap[eventType];
		if (!handlerMap) {
			handlerMap = enterEvent._eventTypeHandlerMap[eventType] = new Map();
		}

		handlerMap.set(handler, keyHandler);
		this.addEventListener(target, baseEventType, keyHandler);
	},

	removeEventListener: function (target, eventType, handler) {
		var handlerMap = enterEvent._eventTypeHandlerMap[eventType];
		if (handlerMap) {
			var keyHandler = handlerMap.get(handler);
			if (keyHandler) {
				handlerMap.delete(handler);
				if (handlerMap.size === 0) {
					delete enterEvent._eventTypeHandlerMap[eventType];
				}
				this.removeEventListener(target, baseEventType, keyHandler);
			}
		}
	},

	// {[eventType: string]: WeakMap<OriginalHandler, KeyEventHandler>}
	_eventTypeHandlerMap: {}
};

var canEventDomEnter_2_1_2_canEventDomEnter = canNamespace_1_0_0_canNamespace.domEventEnter = enterEvent;

var setValueSymbol$2 = canSymbol_1_6_1_canSymbol.for("can.setValue");

/**
 * @module {function} can-key/set/set
 * @parent can-key
 * @description Set properties on deep/nested objects of different types: Object, Map, [can-reflect] types, etc.
 *
 * @signature `set(object, path, value)`
 * @param  {Object} object The object to use as the root for property-based navigation.
 * @param  {String} path A String of dot-separated keys, representing a path of properties.
 * @param  {*} value The new value to be set at the property path.
 * @return {*} The object passed to set (for chaining calls).
 *
 * @body
 *
 * A *path* is a dot-delimited sequence of one or more property names, such that "foo.bar" means "the property
 * 'bar' of the object at the property 'foo' of the root."
 *
 * ```js
 * import set from "can-key/set/set";
 *
 * const object = {a: {b: {c: "foo"}}};
 * set(object, "a.b.c", "bar");
 * // Now object.a.b.c === "bar"
 *
 * var map = new Map();
 * map.set("first", {second: "third"});
 *
 * set(map, "first.second", "3rd");
 * // Now map.first.second === "3rd"
 * ```
 *
 * > **Note:** an error will be thrown if one of the objects in the key path does not exist.
 */
function set$2(object, path, value) {
    var parts = canKey_0_5_0_utils.parts(path);

    var current = object;
    var length = parts.length;

    // Walk current until there is not a container
    for (var i = 0; i < length - 1; i++) {
        if (canKey_0_5_0_utils.isContainer(current)) {
            current = canReflect_1_16_7_canReflect.getKeyValue(current, parts[i]);
        } else {
            break;
        }
    }

    // Set the value
    if (current) {
        canReflect_1_16_7_canReflect.setKeyValue(current, parts[i], value);
    } else {
        throw new TypeError("Cannot set value at key path '" + path + "'");
    }

    return object;
}

var set_1$1 = set$2;

/**
 * @module {function} can-key/walk/walk
 * @parent can-key
 *
 * @signature `walk(obj, name, keyCallback(info) )`
 *
 * ```js
 * import walk from "can-key/walk/walk";
 *
 * var user = {name: {first: "Justin"}}
 * walk(user, "name.first", (keyInfo)=> {
 *   // Called 2 times.
 *   // first call:
 *   keyInfo //-> {parent: user, key: "name", value: user.name}
 *   // second call:
 *   keyInfo //-> {parent: user.name, key: "first", value: user.name.first}
 * })
 * ```
 *
 * @param {Object} obj An object to read key values from.
 * @param {String} name A string key name like "foo.bar".
 * @param {function(Object)} keyCallback(info) For every key value,
 * `keyCallback` will be called back with an `info` object containing:
 *
 * - `info.parent` - The object the property value is being read from.
 * - `info.key` - The key being read.
 * - `info.value` - The key's value.
 *
 * If `keyCallback` returns a value other than `undefined`, the next key value
 * will be read from that value.
 */
var walk = function walk(obj, name, keyCallback){

    // The parts of the name we are looking up
    // `['App','Models','Recipe']`
    var parts = canKey_0_5_0_utils.parts(name);

    var length = parts.length,
        current, i, container, part;


    if (!length) {
        return;
    }

    current = obj;

    // Walk current to the 2nd to last object or until there
    // is not a container.
    for (i = 0; i < length; i++) {
        container = current;
        part = parts[i];
        current = canKey_0_5_0_utils.isContainer(container) && canReflect_1_16_7_canReflect.getKeyValue( container, part );

        var result = keyCallback({
            parent:container,
            key: part,
            value: current
        }, i);
        if(result !== undefined) {
            current = result;
        }
    }
};

function deleteKeys(parentsAndKeys) {
    for(var i  = parentsAndKeys.length - 1; i >= 0; i--) {
        var parentAndKey = parentsAndKeys[i];
        delete  parentAndKey.parent[parentAndKey.key];
        if(canReflect_1_16_7_canReflect.size(parentAndKey.parent) !== 0) {
            return;
        }
    }
}
/**
 * @module {function} can-key/transform/transform
 * @parent can-key
 */
var transform = function(obj, transformer){
    var copy = canReflect_1_16_7_canReflect.serialize( obj);

    canReflect_1_16_7_canReflect.eachKey(transformer, function(writeKey, readKey){
        var readParts = canKey_0_5_0_utils.parts(readKey),
            writeParts = canKey_0_5_0_utils.parts(writeKey);

        // find the value
        var parentsAndKeys = [];
        walk(copy, readParts, function(info){
            parentsAndKeys.push(info);
        });
        var last = parentsAndKeys[parentsAndKeys.length - 1];
        var value = last.value;
        if(value !== undefined) {
            // write the value
            walk(copy, writeParts, function(info, i){
                if(i < writeParts.length - 1 && !info.value) {
                    return info.parent[info.key] = {};
                } else if(i === writeParts.length - 1){
                    info.parent[info.key] = value;
                }
            });
            // delete the keys on old
            deleteKeys(parentsAndKeys);

        }
    });
    return copy;
};

var canKey_0_5_0_canKey = canNamespace_1_0_0_canNamespace.key = {
    deleteKey: _delete,
    get: get_1,
    replaceWith: replaceWith,
    set: set_1$1,
    transform: transform,
    walk: walk
};

/**
 * @module {function} can-diff/map/map
 * @parent can-diff
 *
 * @description Return a difference of two maps or objects.
 *
 * @signature `diffMap(oldObject, newObject)`
 *
 * Find the differences between two objects, based on properties and values.
 *
 * ```js
 * var diffObject = require("can-diff/map/map");
 *
 * diffMap({a: 1, b: 2}, {b: 3, c: 4})) // ->
 *   [{key: "a", type: "remove"},
 *    {key: "b", type: "set": value: 3},
 *    {key: "c", type: "add", "value": 4}]
 * ```
 *
 * @param {Object} oldObject The object to diff from.
 * @param {Object} newObject The object to diff to.
 * @return {Array} An array of object-[can-symbol/types/Patch patch] objects
 *
 * The object-patch object format has the following keys:
 * - **type**:  the type of operation on this property: add, remove, or set
 * - **key**:   the mutated property on the new object
 * - **value**: the new value (if type is "add" or "set")
 *
 */
var map$5 = function(oldObject, newObject){
	var oldObjectClone,
		patches = [];

	// clone oldObject so properties can be deleted
	oldObjectClone = canReflect_1_16_7_canReflect.assignMap({}, oldObject);

    canReflect_1_16_7_canReflect.eachKey(newObject, function(value, newProp){
        // look for added properties
        if (!oldObject || !oldObject.hasOwnProperty(newProp)) {
            patches.push({
                key: newProp,
                type: 'add',
                value: value
            });
        // look for changed properties
        } else if (newObject[newProp] !== oldObject[newProp]) {
            patches.push({
                key: newProp,
                type: 'set',
                value: value
            });
        }

        // delete properties found in newObject
        // so we can find removed properties
        delete oldObjectClone[newProp];
    });

	// loop over removed properties
	for (var oldProp in oldObjectClone) {
		patches.push({
			key: oldProp,
			type: 'delete'
		});
	}

	return patches;
};

function shouldCheckSet(patch, destVal, sourceVal) {
    return patch.type === "set" && destVal && sourceVal &&
        typeof destVal === "object" &&
        typeof sourceVal === "object";
}

function diffDeep(dest, source, parentKey){

    if (dest && canReflect_1_16_7_canReflect.isMoreListLikeThanMapLike(dest)) {
		return list(dest, source).map(function(patch){
            if(parentKey) {
                patch.key = parentKey;
            }
            return patch;
        });
	} else {
        parentKey = parentKey ? parentKey+".": "";
		var patches = map$5(dest, source);
        // any sets we are going to recurse within
        var finalPatches = [];
        patches.forEach(function(patch){
            var key = patch.key;

            patch.key = parentKey + patch.key;
            var destVal = dest && canReflect_1_16_7_canReflect.getKeyValue(dest, key),
                sourceVal = source && canReflect_1_16_7_canReflect.getKeyValue(source, key);
            if(shouldCheckSet(patch, destVal, sourceVal)) {

                var deepPatches = diffDeep(destVal, sourceVal, patch.key);
                finalPatches.push.apply(finalPatches, deepPatches);
            } else {
                finalPatches.push(patch);
            }
        });
        return finalPatches;
	}
}

var deep = diffDeep;

var diff$1 = {
    deep: deep,
    list: list,
    map: map$5,
    mergeDeep: mergeDeep,
    Patcher: patcher
};

var canDiff_1_0_4_canDiff = canNamespace_1_0_0_canNamespace.diff = diff$1;

var forEach$2 = [].forEach;


/**
 * @module can-connect/cache-requests/cache-requests cache-requests
 * @parent can-connect.behaviors
 * @group can-connect/cache-requests/cache-requests.data data interface
 * @group can-connect/cache-requests/cache-requests.queryLogic queryLogic
 *
 * Cache response data and use it to prevent unnecessary future requests or make future requests smaller.
 *
 * @signature `cacheRequests( baseConnection )`
 *
 *   Provide an implementation of [can-connect/cache-requests/cache-requests.getListData] that uses [can-connect/base/base.queryLogic] to
 *   determine what data is already in the [can-connect/base/base.cacheConnection cache] and what data needs to be
 *   loaded from the base connection.
 *
 *   It then gets data from the cache and the base connection (if needed), merges it, and returns it. Any data returned
 *   from the base connection is added to the cache.
 *
 *   @param {{}} baseConnection `can-connect` connection object that is having the `cache-requests` behavior added
 *   on to it. Should already contain the behaviors that provide the [can-connect/DataInterface]
 *   (e.g [can-connect/data/url/url]). If the `connect` helper is used to build the connection, the behaviors will
 *   automatically be ordered as required.
 *
 *   @return {Object} A `can-connect` connection containing the methods provided by `cache-requests`.
 *
 *
 * @body
 *
 * ## Use
 *
 * Use `cache-requests` in combination with a cache like [can-connect/data/memory-cache/memory-cache] or
 * [can-connect/data/localstorage-cache/localstorage-cache].  For example, to make it so response data is cached
 * in memory:
 *
 * ```js
 * var memoryStore = require("can-memory-store");
 * var dataUrl = require("can-connect/data/url/url");
 * var cacheRequests = require("can-connect/cache-requests/cache-requests");
 * var queryLogic = require("can-query-logic");
 *
 * var todoQueryLogic = new QueryLogic({});
 *
 * var cacheConnection = memoryStore({queryLogic: todoQueryLogic});
 * var todoConnection = connect([dataUrl, cacheRequests],{
 *   cacheConnection: cacheConnection,
 *   url: "/todos",
 *   queryLogic: todoQueryLogic
 * });
 * ```
 *
 * Now if today's todos are loaded:
 *
 * ```js
 * todoConnection.getListData({filter: {due: "today"}});
 * ```
 *
 * And later, a subset of those todos are loaded:
 *
 * ```js
 * todoConnection.getListData({filter: {due: "today", status: "critical"}});
 * ```
 *
 * The second request will be created from the original request's data.
 *
 * ## QueryLogic Usage
 *
 * `cache-requests` will "fill-in" the `cacheConnection` using [can-query-logic queryLogic].
 *
 * For example, if you requested paginated data like:
 *
 * ```
 * todoConnection.getListData({filter: {status: "critical"}})
 * ```
 *
 * And then later requested:
 *
 * ```
 * todoConnection.getListData({})
 * ```
 *
 * `cache-requests` will only request `{filter: {status: ["low","medium"]}}`, merging
 * that response with the data already present in the cache.
 *
 * That configuration looks like:
 *
 * ```js
 * var memoryStore = require("can-memory-store");
 * var dataUrl = require("can-connect/data/url/url");
 * var cacheRequests = require("can-connect/cache-requests/cache-requests");
 * var queryLogic = require("can-query-logic");
 *
 * var todoQueryLogic = new QueryLogic({
 *   keys: {
 *     status: QueryLogic.makeEnum(["low","medium","critical"])
 *   }
 * });
 *
 * var cacheConnection = memoryStore({queryLogic: todoQueryLogic});
 * var todoConnection = connect([dataUrl, cacheRequests], {
 *   cacheConnection: cacheConnection,
 *   url: "/todos",
 *   queryLogic: todoQueryLogic
 * })
 * ```
 *
 * **Note:** `cacheConnection` shares the same queryLogic configuration as the primary connection.
 */
var cacheRequestsBehaviour = canConnect_3_0_0Pre_14_canConnect.behavior("cache-requests",function(baseConnection){

	return {

		/**
		 * @function can-connect/cache-requests/cache-requests.getDiff getDiff
		 * @parent can-connect/cache-requests/cache-requests.queryLogic
		 *
		 * Compares the cached queries to the requested query and returns a description of what subset can be loaded from the
		 * cache and what subset must be loaded from the base connection.
		 *
		 * @signature `connection.getDiff( query, availableQueries )`
		 *
		 *   This determines the minimal amount of data that must be loaded from the base connection by going through each
		 *   cached query (`availableQueries`) and doing a [can-query-logic.prototype.isSubset isSubset] check and a
		 *   [can-query-logic.prototype.difference query difference] with the requested query (`query`).
		 *
		 *   If `query` is a subset of an `availableSet`, `{cached: query}` will be returned.
		 *
		 *   If `query` is neither a subset of, nor intersects with any `availableQueries`, `{needed: query}` is returned.
		 *
		 *   If `query` has an intersection with one or more `availableQueries`, a description of the difference that has the fewest
		 *   missing elements will be returned. An example diff description looks like:
		 *
		 *   ```
		 *   {
		 *     needed: {start: 50, end: 99}, // the difference, the query that is not cached
		 *     cached: {start: 0, end: 49}, // the intersection, the query that is cached
		 *     count: 49 // the size of the needed query
		 *   }
		 *   ```
		 *
		 *   @param {can-query-logic/query} query The query that is being requested.
		 *   @param {Array<can-query-logic/query>} availableQueries An array of [can-connect/connection.getSets available queries] in the
		 *     [can-connect/base/base.cacheConnection cache].
		 *   @return {Promise<{needed: can-query-logic/query, cached: can-query-logic/query, count: Integer}>} a difference description object. Described above.
		 *
		 */
		getDiff: function( params, availableQueries ){

			var minSets,
				self = this;

			forEach$2.call(availableQueries, function(query){
				var curSets;
				var difference = self.queryLogic.difference(params, query );
				if( self.queryLogic.isDefinedAndHasMembers(difference) ) {
					var intersection = self.queryLogic.intersection(params, query);
					curSets = {
						needed: difference,
						cached: self.queryLogic.isDefinedAndHasMembers(intersection) ? intersection : false,
						count: self.queryLogic.count(difference)
					};
				} else if( self.queryLogic.isSubset(params, query) ){
					curSets = {
						cached: params,
						count: 0
					};
				}
				if(curSets) {
					if(!minSets || curSets.count < minSets.count) {
						minSets = curSets;
					}
				}
			});

			if(!minSets) {
				return {
					needed: params
				};
			} else {
				return {
					needed: minSets.needed,
					cached: minSets.cached
				};
			}
		},

		/**
		 * @function can-connect/cache-requests/cache-requests.unionMembers unionMembers
		 * @parent can-connect/cache-requests/cache-requests.queryLogic
		 *
		 * Create the requested data set, a union of the cached and un-cached data.
		 *
		 * @signature `connection.unionMembers(set, diff, neededData, cachedData)`
		 *
		 *   Uses [can-query-logic.prototype.unionMembers] to merge the two queries of data (`neededData` & `cachedData`).
		 *
		 * @param {can-query-logic/query} query The parameters of the data set requested.
		 * @param {Object} diff The result of [can-connect/cache-requests/cache-requests.getDiff].
		 * @param {can-connect.listData} neededData The data loaded from the base connection.
		 * @param {can-connect.listData} cachedData The data loaded from the [can-connect/base/base.cacheConnection].
		 *
		 * @return {can-connect.listData} A merged [can-connect.listData] representation of the the cached and requested data.
		 */
		unionMembers: function(params, diff, neededItems, cachedItems){
			// using the diff, re-construct everything
			return {data: this.queryLogic.unionMembers(diff.needed, diff.cached, getItems$1(neededItems), getItems$1(cachedItems))};
		},

		/**
		 * @function can-connect/cache-requests/cache-requests.getListData getListData
		 * @parent can-connect/cache-requests/cache-requests.data
		 *
		 * Only request data that isn't already present in the [can-connect/base/base.cacheConnection cache].
		 *
		 * @signature `connection.getListData(set)`
		 *
		 *   Overwrites a base connection's `getListData` to use data in the [can-connect/base/base.cacheConnection cache]
		 *   whenever possible.  This works by [can-connect/connection.getSets getting the stored queries]
		 *   from the [can-connect/base/base.cacheConnection cache] and
		 *   doing a [can-connect/cache-requests/cache-requests.getDiff diff] to see what needs to be loaded from the base
		 *   connection and what can be loaded from the [can-connect/base/base.cacheConnection cache].
		 *
		 *   With that information, this `getListData` requests data from the cache or the base connection as needed.
		 *   Data loaded from different sources is combined via [can-connect/cache-requests/cache-requests.unionMembers].
		 *
		 * @param {can-query-logic/query} query the parameters of the list that is being requested.
		 * @return {Promise<can-connect.listData>} a promise that returns an object conforming to the [can-connect.listData] format.
		 */
		getListData: function(set){
			set = set || {};
			var self = this;

			return this.cacheConnection.getSets(set).then(function(queries){

				var diff = self.getDiff(set, queries);

				if(!diff.needed) {
					return self.cacheConnection.getListData(diff.cached);
				} else if(!diff.cached) {
					return baseConnection.getListData(diff.needed).then(function(data){

						return self.cacheConnection.updateListData(getItems$1(data), diff.needed ).then(function(){
							return data;
						});

					});
				} else {
					var cachedPromise = self.cacheConnection.getListData(diff.cached);
					var needsPromise = baseConnection.getListData(diff.needed);

					var savedPromise = needsPromise.then(function(data){
						return self.cacheConnection.updateListData(  getItems$1(data), diff.needed ).then(function(){
							return data;
						});
					});
					// start the combine while we might be saving param and adding to cache
					var combinedPromise = Promise.all([
						cachedPromise,
						needsPromise
					]).then(function(result){
						var cached = result[0],
							needed = result[1];
						return self.unionMembers( set, diff, needed, cached);
					});

					return Promise.all([combinedPromise, savedPromise]).then(function(data){
						return data[0];
					});
				}

			});
		}
	};

});

var cacheRequests = cacheRequestsBehaviour;

//!steal-remove-start

var cacheRequests = validate(cacheRequestsBehaviour, ['getListData', 'cacheConnection']);
//!steal-remove-end

var require$$0 = cacheRequests;

/**
 * @module can-connect/data/memory-cache/memory-cache memory-cache
 * @parent can-connect.deprecated
 * @group can-connect/data/memory-cache/memory-cache.data-methods data methods
 *
 * Saves raw data in JavaScript memory that disappears when the page refreshes.
 *
 * @deprecated {5.0} Use [can-memory-store] instead.
 *
 * @signature `memoryCache( baseConnection )`
 *
 *   Creates a cache of instances and a cache of sets of instances that is
 *   accessible to read via [can-connect/data/memory-cache/memory-cache.getSets],
 *   [can-connect/data/memory-cache/memory-cache.getData], and [can-connect/data/memory-cache/memory-cache.getListData].
 *   The caches are updated via [can-connect/data/memory-cache/memory-cache.createData],
 *   [can-connect/data/memory-cache/memory-cache.updateData], [can-connect/data/memory-cache/memory-cache.destroyData],
 *   and [can-connect/data/memory-cache/memory-cache.updateListData].
 *
 *   [can-connect/data/memory-cache/memory-cache.createData],
 *   [can-connect/data/memory-cache/memory-cache.updateData],
 *   [can-connect/data/memory-cache/memory-cache.destroyData] are able to move items in and out
 *   of sets.
 *
 * @body
 *
 * ## Use
 *
 * `data/memory-cache` is often used with a caching strategy like [can-connect/fall-through-cache/fall-through-cache] or
 * [can-connect/cache-requests/cache-requests].
 *
 * ```js
 * var cacheConnection = connect([
 *   require("can-connect/data/memory-cache/memory-cache")
 * ],{});
 *
 * var todoConnection = connect([
 *   require("can-connect/data/url/url"),
 *   require("can-connect/fall-through-cache/fall-through-cache")
 * ],
 * {
 *   url: "/services/todos",
 *   cacheConnection: cacheConnection
 * });
 * ```
 */


var memoryCache = canMemoryStore_1_0_0_canMemoryStore;

var $ = global_1().$;

canConnect_3_0_0Pre_14_canConnect.superMap = function(options){

	var behaviors = [
		constructor_1,
		canMap,
		ref,
		store,
		dataCallbacks,
		combineRequests$1,
		parse,
		dataUrl,
		realTime,
		callbacksOnce$1];

	if(typeof localStorage !== "undefined") {
		if(!options.cacheConnection) {
			options.cacheConnection = canConnect_3_0_0Pre_14_canConnect([localstorageCache],{
				name: options.name+"Cache",
				idProp: options.idProp,
				queryLogic: options.queryLogic
			});
		}
		behaviors.push(callbacksCache$1,fallThroughCache$1);
	}
	// Handles if jQuery isn't provided.
	if($ && $.ajax) {
		options.ajax = $.ajax;
	}
	return canConnect_3_0_0Pre_14_canConnect(behaviors,options);
};

var superMap = canConnect_3_0_0Pre_14_canConnect.superMap;

var $$1 = global_1().$;

canConnect_3_0_0Pre_14_canConnect.baseMap = function(options){

	var behaviors = [
		constructor_1,
		canMap,
		ref,
		store,
		dataCallbacks,
		parse,
		dataUrl,
		realTime,
		callbacksOnce$1
	];

	// Handles if jQuery isn't provided.
	if($$1 && $$1.ajax) {
		options.ajax = $$1.ajax;
	}

	return canConnect_3_0_0Pre_14_canConnect(behaviors,options);
};

var baseMap = canConnect_3_0_0Pre_14_canConnect.baseMap;

canConnect_3_0_0Pre_14_canConnect.cacheRequests = require$$0;

canConnect_3_0_0Pre_14_canConnect.constructor = constructor_1;
canConnect_3_0_0Pre_14_canConnect.constructorCallbacksOnce = callbacksOnce$1;
canConnect_3_0_0Pre_14_canConnect.constructorStore = store;
canConnect_3_0_0Pre_14_canConnect.dataCallbacks = dataCallbacks;
canConnect_3_0_0Pre_14_canConnect.dataCallbacksCache = callbacksCache$1;
canConnect_3_0_0Pre_14_canConnect.dataCombineRequests = combineRequests$1;
canConnect_3_0_0Pre_14_canConnect.dataLocalStorageCache = localstorageCache;
canConnect_3_0_0Pre_14_canConnect.dataMemoryCache = memoryCache;
canConnect_3_0_0Pre_14_canConnect.dataParse = parse;
canConnect_3_0_0Pre_14_canConnect.dataUrl = dataUrl;
canConnect_3_0_0Pre_14_canConnect.fallThroughCache = fallThroughCache$1;
canConnect_3_0_0Pre_14_canConnect.realTime = realTime;

canConnect_3_0_0Pre_14_canConnect.superMap = superMap;
canConnect_3_0_0Pre_14_canConnect.baseMap = baseMap;

var canConnect_3_0_0Pre_14_all = canConnect_3_0_0Pre_14_canConnect;

function getIdProp (Model) {
	var algebraIdProp;
	var algebraClause = Model.algebra && Model.algebra.clauses && Model.algebra.clauses.id;
	if (algebraClause) {
		algebraIdProp = Object.keys(algebraClause)[0];
	}
	if (!algebraIdProp && !Model.idProp) {
		throw new Error('An idProp was not set in the Model for ' + Model + '. Things may not work as expected.');
	}
	return algebraIdProp || Model.idProp;
}

var service = canConnect_3_0_0Pre_14_canConnect.behavior('data/feathers-service', function (base) {
	var helpURL = 'https://canjs.com/doc/can-connect-feathers.html';
	if (!this.feathersService) {
		throw new Error('You must provide a feathersService to the feathers-service behavior: ' + helpURL);
	}

	var service = this.feathersService;

	return {
		init: function () {
			base.init.apply(this, arguments);
			var self = this;
			// Connect to real-time events.
			service.on('created', function (message) { self.createInstance(message); });
			service.on('updated', function (message) { self.updateInstance(message); });
			service.on('patched', function (message) { self.updateInstance(message); });
			service.on('removed', function (message) { self.destroyInstance(message); });
		},

		getListData: function (params) {
			return service.find({query: params});
		},

		getData: function (params) {
			var id = null;
			var idProp = getIdProp(this);
			if (typeof params === 'string' || typeof params === 'number') {
				id = params;
				params = {};
			} else if (params && typeof params[idProp] !== 'undefined') {
				id = params[idProp];
				delete params[idProp];
			}
			return service.get(id, {query: params});
		},

		createData: function (data) {
			return service.create(data);
		},

		updateData: function (instance) {
			var idProp = getIdProp(this);
			return service.update(instance[idProp], instance);
		},

		destroyData: function (instance) {
			var idProp = getIdProp(this);
			return service.remove(instance[idProp]);
		}
	};
});

/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

var ms_2_0_0_index = function(val, options) {
  options = options || {};
  var type = typeof val;
  if (type === 'string' && val.length > 0) {
    return parse$2(val);
  } else if (type === 'number' && isNaN(val) === false) {
    return options.long ? fmtLong(val) : fmtShort(val);
  }
  throw new Error(
    'val is not a non-empty string or a valid number. val=' +
      JSON.stringify(val)
  );
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse$2(str) {
  str = String(str);
  if (str.length > 100) {
    return;
  }
  var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(
    str
  );
  if (!match) {
    return;
  }
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
    default:
      return undefined;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtShort(ms) {
  if (ms >= d) {
    return Math.round(ms / d) + 'd';
  }
  if (ms >= h) {
    return Math.round(ms / h) + 'h';
  }
  if (ms >= m) {
    return Math.round(ms / m) + 'm';
  }
  if (ms >= s) {
    return Math.round(ms / s) + 's';
  }
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtLong(ms) {
  return plural(ms, d, 'day') ||
    plural(ms, h, 'hour') ||
    plural(ms, m, 'minute') ||
    plural(ms, s, 'second') ||
    ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, n, name) {
  if (ms < n) {
    return;
  }
  if (ms < n * 1.5) {
    return Math.floor(ms / n) + ' ' + name;
  }
  return Math.ceil(ms / n) + ' ' + name + 's';
}

var debug = createCommonjsModule(function (module, exports) {
/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = createDebug.debug = createDebug['default'] = createDebug;
exports.coerce = coerce;
exports.disable = disable;
exports.enable = enable;
exports.enabled = enabled;
exports.humanize = ms_2_0_0_index;

/**
 * Active `debug` instances.
 */
exports.instances = [];

/**
 * The currently active debug mode names, and names to skip.
 */

exports.names = [];
exports.skips = [];

/**
 * Map of special "%n" handling functions, for the debug "format" argument.
 *
 * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
 */

exports.formatters = {};

/**
 * Select a color.
 * @param {String} namespace
 * @return {Number}
 * @api private
 */

function selectColor(namespace) {
  var hash = 0, i;

  for (i in namespace) {
    hash  = ((hash << 5) - hash) + namespace.charCodeAt(i);
    hash |= 0; // Convert to 32bit integer
  }

  return exports.colors[Math.abs(hash) % exports.colors.length];
}

/**
 * Create a debugger with the given `namespace`.
 *
 * @param {String} namespace
 * @return {Function}
 * @api public
 */

function createDebug(namespace) {

  var prevTime;

  function debug() {
    // disabled?
    if (!debug.enabled) return;

    var self = debug;

    // set `diff` timestamp
    var curr = +new Date();
    var ms = curr - (prevTime || curr);
    self.diff = ms;
    self.prev = prevTime;
    self.curr = curr;
    prevTime = curr;

    // turn the `arguments` into a proper Array
    var args = new Array(arguments.length);
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }

    args[0] = exports.coerce(args[0]);

    if ('string' !== typeof args[0]) {
      // anything else let's inspect with %O
      args.unshift('%O');
    }

    // apply any `formatters` transformations
    var index = 0;
    args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {
      // if we encounter an escaped % then don't increase the array index
      if (match === '%%') return match;
      index++;
      var formatter = exports.formatters[format];
      if ('function' === typeof formatter) {
        var val = args[index];
        match = formatter.call(self, val);

        // now we need to remove `args[index]` since it's inlined in the `format`
        args.splice(index, 1);
        index--;
      }
      return match;
    });

    // apply env-specific formatting (colors, etc.)
    exports.formatArgs.call(self, args);

    var logFn = debug.log || exports.log || console.log.bind(console);
    logFn.apply(self, args);
  }

  debug.namespace = namespace;
  debug.enabled = exports.enabled(namespace);
  debug.useColors = exports.useColors();
  debug.color = selectColor(namespace);
  debug.destroy = destroy;

  // env-specific initialization logic for debug instances
  if ('function' === typeof exports.init) {
    exports.init(debug);
  }

  exports.instances.push(debug);

  return debug;
}

function destroy () {
  var index = exports.instances.indexOf(this);
  if (index !== -1) {
    exports.instances.splice(index, 1);
    return true;
  } else {
    return false;
  }
}

/**
 * Enables a debug mode by namespaces. This can include modes
 * separated by a colon and wildcards.
 *
 * @param {String} namespaces
 * @api public
 */

function enable(namespaces) {
  exports.save(namespaces);

  exports.names = [];
  exports.skips = [];

  var i;
  var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
  var len = split.length;

  for (i = 0; i < len; i++) {
    if (!split[i]) continue; // ignore empty strings
    namespaces = split[i].replace(/\*/g, '.*?');
    if (namespaces[0] === '-') {
      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
    } else {
      exports.names.push(new RegExp('^' + namespaces + '$'));
    }
  }

  for (i = 0; i < exports.instances.length; i++) {
    var instance = exports.instances[i];
    instance.enabled = exports.enabled(instance.namespace);
  }
}

/**
 * Disable debug output.
 *
 * @api public
 */

function disable() {
  exports.enable('');
}

/**
 * Returns true if the given mode name is enabled, false otherwise.
 *
 * @param {String} name
 * @return {Boolean}
 * @api public
 */

function enabled(name) {
  if (name[name.length - 1] === '*') {
    return true;
  }
  var i, len;
  for (i = 0, len = exports.skips.length; i < len; i++) {
    if (exports.skips[i].test(name)) {
      return false;
    }
  }
  for (i = 0, len = exports.names.length; i < len; i++) {
    if (exports.names[i].test(name)) {
      return true;
    }
  }
  return false;
}

/**
 * Coerce `val`.
 *
 * @param {Mixed} val
 * @return {Mixed}
 * @api private
 */

function coerce(val) {
  if (val instanceof Error) return val.stack || val.message;
  return val;
}
});
var debug_1 = debug.coerce;
var debug_2 = debug.disable;
var debug_3 = debug.enable;
var debug_4 = debug.enabled;
var debug_5 = debug.humanize;
var debug_6 = debug.instances;
var debug_7 = debug.names;
var debug_8 = debug.skips;
var debug_9 = debug.formatters;

var browser = createCommonjsModule(function (module, exports) {
/**
 * This is the web browser implementation of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = debug;
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = 'undefined' != typeof chrome
               && 'undefined' != typeof chrome.storage
                  ? chrome.storage.local
                  : localstorage();

/**
 * Colors.
 */

exports.colors = [
  '#0000CC', '#0000FF', '#0033CC', '#0033FF', '#0066CC', '#0066FF', '#0099CC',
  '#0099FF', '#00CC00', '#00CC33', '#00CC66', '#00CC99', '#00CCCC', '#00CCFF',
  '#3300CC', '#3300FF', '#3333CC', '#3333FF', '#3366CC', '#3366FF', '#3399CC',
  '#3399FF', '#33CC00', '#33CC33', '#33CC66', '#33CC99', '#33CCCC', '#33CCFF',
  '#6600CC', '#6600FF', '#6633CC', '#6633FF', '#66CC00', '#66CC33', '#9900CC',
  '#9900FF', '#9933CC', '#9933FF', '#99CC00', '#99CC33', '#CC0000', '#CC0033',
  '#CC0066', '#CC0099', '#CC00CC', '#CC00FF', '#CC3300', '#CC3333', '#CC3366',
  '#CC3399', '#CC33CC', '#CC33FF', '#CC6600', '#CC6633', '#CC9900', '#CC9933',
  '#CCCC00', '#CCCC33', '#FF0000', '#FF0033', '#FF0066', '#FF0099', '#FF00CC',
  '#FF00FF', '#FF3300', '#FF3333', '#FF3366', '#FF3399', '#FF33CC', '#FF33FF',
  '#FF6600', '#FF6633', '#FF9900', '#FF9933', '#FFCC00', '#FFCC33'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

function useColors() {
  // NB: In an Electron preload script, document will be defined but not fully
  // initialized. Since we know we're in Chrome, we'll just detect this case
  // explicitly
  if (typeof window !== 'undefined' && window.process && window.process.type === 'renderer') {
    return true;
  }

  // Internet Explorer and Edge do not support colors.
  if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
    return false;
  }

  // is webkit? http://stackoverflow.com/a/16459606/376773
  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
  return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||
    // is firebug? http://stackoverflow.com/a/398120/376773
    (typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||
    // is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||
    // double check webkit in userAgent just in case we are in a worker
    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
}

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

exports.formatters.j = function(v) {
  try {
    return JSON.stringify(v);
  } catch (err) {
    return '[UnexpectedJSONParseError]: ' + err.message;
  }
};


/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs(args) {
  var useColors = this.useColors;

  args[0] = (useColors ? '%c' : '')
    + this.namespace
    + (useColors ? ' %c' : ' ')
    + args[0]
    + (useColors ? '%c ' : ' ')
    + '+' + exports.humanize(this.diff);

  if (!useColors) return;

  var c = 'color: ' + this.color;
  args.splice(1, 0, c, 'color: inherit');

  // the final "%c" is somewhat tricky, because there could be other
  // arguments passed either before or after the %c, so we need to
  // figure out the correct index to insert the CSS into
  var index = 0;
  var lastC = 0;
  args[0].replace(/%[a-zA-Z%]/g, function(match) {
    if ('%%' === match) return;
    index++;
    if ('%c' === match) {
      // we only are interested in the *last* %c
      // (the user may have provided their own)
      lastC = index;
    }
  });

  args.splice(lastC, 0, c);
}

/**
 * Invokes `console.log()` when available.
 * No-op when `console.log` is not a "function".
 *
 * @api public
 */

function log() {
  // this hackery is required for IE8/9, where
  // the `console.log` function doesn't have 'apply'
  return 'object' === typeof console
    && console.log
    && Function.prototype.apply.call(console.log, console, arguments);
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */

function save(namespaces) {
  try {
    if (null == namespaces) {
      exports.storage.removeItem('debug');
    } else {
      exports.storage.debug = namespaces;
    }
  } catch(e) {}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
  var r;
  try {
    r = exports.storage.debug;
  } catch(e) {}

  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG
  if (!r && typeof process !== 'undefined' && 'env' in process) {
    r = process.env.DEBUG;
  }

  return r;
}

/**
 * Enable namespaces listed in `localStorage.debug` initially.
 */

exports.enable(load());

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage() {
  try {
    return window.localStorage;
  } catch (e) {}
}
});
var browser_1 = browser.log;
var browser_2 = browser.formatArgs;
var browser_3 = browser.save;
var browser_4 = browser.load;
var browser_5 = browser.useColors;
var browser_6 = browser.storage;
var browser_7 = browser.colors;

var feathersErrors_2_9_2_lib = createCommonjsModule(function (module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var debug = browser('feathers-errors');

function FeathersError(msg, name, code, className, data) {
  msg = msg || 'Error';

  var errors = void 0;
  var message = void 0;
  var newData = void 0;

  if (msg instanceof Error) {
    message = msg.message || 'Error';

    // NOTE (EK): This is typically to handle validation errors
    if (msg.errors) {
      errors = msg.errors;
    }
  } else if ((typeof msg === 'undefined' ? 'undefined' : _typeof(msg)) === 'object') {
    // Support plain old objects
    message = msg.message || 'Error';
    data = msg;
  } else {
    // message is just a string
    message = msg;
  }

  if (data) {
    // NOTE(EK): To make sure that we are not messing
    // with immutable data, just make a copy.
    // https://github.com/feathersjs/feathers-errors/issues/19
    newData = JSON.parse(JSON.stringify(data));

    if (newData.errors) {
      errors = newData.errors;
      delete newData.errors;
    } else if (data.errors) {
      // The errors property from data could be
      // stripped away while cloning resulting newData not to have it
      // For example: when cloning arrays this property
      errors = JSON.parse(JSON.stringify(data.errors));
    }
  }

  // NOTE (EK): Babel doesn't support this so
  // we have to pass in the class name manually.
  // this.name = this.constructor.name;
  this.type = 'FeathersError';
  this.name = name;
  this.message = message;
  this.code = code;
  this.className = className;
  this.data = newData;
  this.errors = errors || {};

  debug(this.name + '(' + this.code + '): ' + this.message);
  debug(this.errors);

  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, FeathersError);
  } else {
    this.stack = new Error().stack;
  }
}

FeathersError.prototype = Object.create(Error.prototype);

// NOTE (EK): A little hack to get around `message` not
// being included in the default toJSON call.
Object.defineProperty(FeathersError.prototype, 'toJSON', {
  value: function value() {
    return {
      name: this.name,
      message: this.message,
      code: this.code,
      className: this.className,
      data: this.data,
      errors: this.errors
    };
  }
});

// 400 - Bad Request
function BadRequest(message, data) {
  FeathersError.call(this, message, 'BadRequest', 400, 'bad-request', data);
}

BadRequest.prototype = FeathersError.prototype;

// 401 - Not Authenticated
function NotAuthenticated(message, data) {
  FeathersError.call(this, message, 'NotAuthenticated', 401, 'not-authenticated', data);
}

NotAuthenticated.prototype = FeathersError.prototype;

// 402 - Payment Error
function PaymentError(message, data) {
  FeathersError.call(this, message, 'PaymentError', 402, 'payment-error', data);
}

PaymentError.prototype = FeathersError.prototype;

// 403 - Forbidden
function Forbidden(message, data) {
  FeathersError.call(this, message, 'Forbidden', 403, 'forbidden', data);
}

Forbidden.prototype = FeathersError.prototype;

// 404 - Not Found
function NotFound(message, data) {
  FeathersError.call(this, message, 'NotFound', 404, 'not-found', data);
}

NotFound.prototype = FeathersError.prototype;

// 405 - Method Not Allowed
function MethodNotAllowed(message, data) {
  FeathersError.call(this, message, 'MethodNotAllowed', 405, 'method-not-allowed', data);
}

MethodNotAllowed.prototype = FeathersError.prototype;

// 406 - Not Acceptable
function NotAcceptable(message, data) {
  FeathersError.call(this, message, 'NotAcceptable', 406, 'not-acceptable', data);
}

NotAcceptable.prototype = FeathersError.prototype;

// 408 - Timeout
function Timeout(message, data) {
  FeathersError.call(this, message, 'Timeout', 408, 'timeout', data);
}

Timeout.prototype = FeathersError.prototype;

// 409 - Conflict
function Conflict(message, data) {
  FeathersError.call(this, message, 'Conflict', 409, 'conflict', data);
}

Conflict.prototype = FeathersError.prototype;

// 411 - Length Required
function LengthRequired(message, data) {
  FeathersError.call(this, message, 'LengthRequired', 411, 'length-required', data);
}

LengthRequired.prototype = FeathersError.prototype;

// 422 Unprocessable
function Unprocessable(message, data) {
  FeathersError.call(this, message, 'Unprocessable', 422, 'unprocessable', data);
}

Unprocessable.prototype = FeathersError.prototype;

// 429 Too Many Requests
function TooManyRequests(message, data) {
  FeathersError.call(this, message, 'TooManyRequests', 429, 'too-many-requests', data);
}

TooManyRequests.prototype = FeathersError.prototype;

// 500 - General Error
function GeneralError(message, data) {
  FeathersError.call(this, message, 'GeneralError', 500, 'general-error', data);
}

GeneralError.prototype = FeathersError.prototype;

// 501 - Not Implemented
function NotImplemented(message, data) {
  FeathersError.call(this, message, 'NotImplemented', 501, 'not-implemented', data);
}

NotImplemented.prototype = FeathersError.prototype;

// 502 - Bad Gateway
function BadGateway(message, data) {
  FeathersError.call(this, message, 'BadGateway', 502, 'bad-gateway', data);
}

BadGateway.prototype = FeathersError.prototype;

// 503 - Unavailable
function Unavailable(message, data) {
  FeathersError.call(this, message, 'Unavailable', 503, 'unavailable', data);
}

Unavailable.prototype = FeathersError.prototype;

var errors = {
  FeathersError: FeathersError,
  BadRequest: BadRequest,
  NotAuthenticated: NotAuthenticated,
  PaymentError: PaymentError,
  Forbidden: Forbidden,
  NotFound: NotFound,
  MethodNotAllowed: MethodNotAllowed,
  NotAcceptable: NotAcceptable,
  Timeout: Timeout,
  Conflict: Conflict,
  LengthRequired: LengthRequired,
  Unprocessable: Unprocessable,
  TooManyRequests: TooManyRequests,
  GeneralError: GeneralError,
  NotImplemented: NotImplemented,
  BadGateway: BadGateway,
  Unavailable: Unavailable,
  400: BadRequest,
  401: NotAuthenticated,
  402: PaymentError,
  403: Forbidden,
  404: NotFound,
  405: MethodNotAllowed,
  406: NotAcceptable,
  408: Timeout,
  409: Conflict,
  411: LengthRequired,
  422: Unprocessable,
  429: TooManyRequests,
  500: GeneralError,
  501: NotImplemented,
  502: BadGateway,
  503: Unavailable
};

function convert(error) {
  if (!error) {
    return error;
  }

  var FeathersError = errors[error.name];
  var result = FeathersError ? new FeathersError(error.message, error.data) : new Error(error.message || error);

  if ((typeof error === 'undefined' ? 'undefined' : _typeof(error)) === 'object') {
    _extends(result, error);
  }

  return result;
}

exports.default = _extends({
  convert: convert,
  types: errors,
  errors: errors
}, errors);
module.exports = exports['default'];
});

var errors = unwrapExports(feathersErrors_2_9_2_lib);

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

function EventEmitter() {
  this._events = this._events || {};
  this._maxListeners = this._maxListeners || undefined;
}
var events_1_1_1_events = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
EventEmitter.defaultMaxListeners = 10;

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function(n) {
  if (!isNumber(n) || n < 0 || isNaN(n))
    throw TypeError('n must be a positive number');
  this._maxListeners = n;
  return this;
};

EventEmitter.prototype.emit = function(type) {
  var er, handler, len, args, i, listeners;

  if (!this._events)
    this._events = {};

  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events.error ||
        (isObject(this._events.error) && !this._events.error.length)) {
      er = arguments[1];
      if (er instanceof Error) {
        throw er; // Unhandled 'error' event
      } else {
        // At least give some kind of context to the user
        var err = new Error('Uncaught, unspecified "error" event. (' + er + ')');
        err.context = er;
        throw err;
      }
    }
  }

  handler = this._events[type];

  if (isUndefined(handler))
    return false;

  if (isFunction$2(handler)) {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        args = Array.prototype.slice.call(arguments, 1);
        handler.apply(this, args);
    }
  } else if (isObject(handler)) {
    args = Array.prototype.slice.call(arguments, 1);
    listeners = handler.slice();
    len = listeners.length;
    for (i = 0; i < len; i++)
      listeners[i].apply(this, args);
  }

  return true;
};

EventEmitter.prototype.addListener = function(type, listener) {
  var m;

  if (!isFunction$2(listener))
    throw TypeError('listener must be a function');

  if (!this._events)
    this._events = {};

  // To avoid recursion in the case that type === "newListener"! Before
  // adding it to the listeners, first emit "newListener".
  if (this._events.newListener)
    this.emit('newListener', type,
              isFunction$2(listener.listener) ?
              listener.listener : listener);

  if (!this._events[type])
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  else if (isObject(this._events[type]))
    // If we've already got an array, just append.
    this._events[type].push(listener);
  else
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];

  // Check for listener leak
  if (isObject(this._events[type]) && !this._events[type].warned) {
    if (!isUndefined(this._maxListeners)) {
      m = this._maxListeners;
    } else {
      m = EventEmitter.defaultMaxListeners;
    }

    if (m && m > 0 && this._events[type].length > m) {
      this._events[type].warned = true;
      console.error('(node) warning: possible EventEmitter memory ' +
                    'leak detected. %d listeners added. ' +
                    'Use emitter.setMaxListeners() to increase limit.',
                    this._events[type].length);
      if (typeof console.trace === 'function') {
        // not supported in IE 10
        console.trace();
      }
    }
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  if (!isFunction$2(listener))
    throw TypeError('listener must be a function');

  var fired = false;

  function g() {
    this.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }

  g.listener = listener;
  this.on(type, g);

  return this;
};

// emits a 'removeListener' event iff the listener was removed
EventEmitter.prototype.removeListener = function(type, listener) {
  var list, position, length, i;

  if (!isFunction$2(listener))
    throw TypeError('listener must be a function');

  if (!this._events || !this._events[type])
    return this;

  list = this._events[type];
  length = list.length;
  position = -1;

  if (list === listener ||
      (isFunction$2(list.listener) && list.listener === listener)) {
    delete this._events[type];
    if (this._events.removeListener)
      this.emit('removeListener', type, listener);

  } else if (isObject(list)) {
    for (i = length; i-- > 0;) {
      if (list[i] === listener ||
          (list[i].listener && list[i].listener === listener)) {
        position = i;
        break;
      }
    }

    if (position < 0)
      return this;

    if (list.length === 1) {
      list.length = 0;
      delete this._events[type];
    } else {
      list.splice(position, 1);
    }

    if (this._events.removeListener)
      this.emit('removeListener', type, listener);
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  var key, listeners;

  if (!this._events)
    return this;

  // not listening for removeListener, no need to emit
  if (!this._events.removeListener) {
    if (arguments.length === 0)
      this._events = {};
    else if (this._events[type])
      delete this._events[type];
    return this;
  }

  // emit removeListener for all listeners on all events
  if (arguments.length === 0) {
    for (key in this._events) {
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners('removeListener');
    this._events = {};
    return this;
  }

  listeners = this._events[type];

  if (isFunction$2(listeners)) {
    this.removeListener(type, listeners);
  } else if (listeners) {
    // LIFO order
    while (listeners.length)
      this.removeListener(type, listeners[listeners.length - 1]);
  }
  delete this._events[type];

  return this;
};

EventEmitter.prototype.listeners = function(type) {
  var ret;
  if (!this._events || !this._events[type])
    ret = [];
  else if (isFunction$2(this._events[type]))
    ret = [this._events[type]];
  else
    ret = this._events[type].slice();
  return ret;
};

EventEmitter.prototype.listenerCount = function(type) {
  if (this._events) {
    var evlistener = this._events[type];

    if (isFunction$2(evlistener))
      return 1;
    else if (evlistener)
      return evlistener.length;
  }
  return 0;
};

EventEmitter.listenerCount = function(emitter, type) {
  return emitter.listenerCount(type);
};

function isFunction$2(arg) {
  return typeof arg === 'function';
}

function isNumber(arg) {
  return typeof arg === 'number';
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isUndefined(arg) {
  return arg === void 0;
}

var feathersAuthenticationPopups = createCommonjsModule(function (module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.authAgent = undefined;
exports.default = openLoginPopup;
exports.getCenterCoordinates = getCenterCoordinates;



var _events2 = _interopRequireDefault(events_1_1_1_events);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

window.authAgent = new _events2.default();

var authAgent = exports.authAgent = window.authAgent;

/*
 * A helper template to that opens the provided URL in a centered popup.
 * Accepts an `options` object with `width` and `height` number properties.
 */
function openLoginPopup(url) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  var width = options.width || 1024;
  var height = options.height || 640;

  var _getCenterCoordinates = getCenterCoordinates(window, width, height),
      top = _getCenterCoordinates.top,
      left = _getCenterCoordinates.left;

  var params = 'width=' + width + ', height=' + height + ', top=' + top + ', left=' + left;
  return window.open(url, 'authWindow', params);
}

/*
 * Returns the coordinates to center a popup window in the viewport with
 * the provided width and height args.
 */
function getCenterCoordinates(window, width, height) {
  return {
    left: window.screenX + (window.outerWidth - width) / 2,
    top: window.screenY + (window.outerHeight - height) / 2
  };
}
});

var require$$0$1 = unwrapExports(feathersAuthenticationPopups);
var feathersAuthenticationPopups_1 = feathersAuthenticationPopups.authAgent;
var feathersAuthenticationPopups_2 = feathersAuthenticationPopups.getCenterCoordinates;

/**
 * The code was extracted from:
 * https://github.com/davidchambers/Base64.js
 */

var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';

function InvalidCharacterError(message) {
  this.message = message;
}

InvalidCharacterError.prototype = new Error();
InvalidCharacterError.prototype.name = 'InvalidCharacterError';

function polyfill (input) {
  var str = String(input).replace(/=+$/, '');
  if (str.length % 4 == 1) {
    throw new InvalidCharacterError("'atob' failed: The string to be decoded is not correctly encoded.");
  }
  for (
    // initialize result and counters
    var bc = 0, bs, buffer, idx = 0, output = '';
    // get next character
    buffer = str.charAt(idx++);
    // character found in table? initialize bit storage and add its ascii value;
    ~buffer && (bs = bc % 4 ? bs * 64 + buffer : buffer,
      // and if not first of each 4 characters,
      // convert the first 8 bits to one ascii character
      bc++ % 4) ? output += String.fromCharCode(255 & bs >> (-2 * bc & 6)) : 0
  ) {
    // try to find character in table (0-63, not found => -1)
    buffer = chars.indexOf(buffer);
  }
  return output;
}


var atob = typeof window !== 'undefined' && window.atob && window.atob.bind(window) || polyfill;

function b64DecodeUnicode(str) {
  return decodeURIComponent(atob(str).replace(/(.)/g, function (m, p) {
    var code = p.charCodeAt(0).toString(16).toUpperCase();
    if (code.length < 2) {
      code = '0' + code;
    }
    return '%' + code;
  }));
}

var base64_url_decode = function(str) {
  var output = str.replace(/-/g, "+").replace(/_/g, "/");
  switch (output.length % 4) {
    case 0:
      break;
    case 2:
      output += "==";
      break;
    case 3:
      output += "=";
      break;
    default:
      throw "Illegal base64url string!";
  }

  try{
    return b64DecodeUnicode(output);
  } catch (err) {
    return atob(output);
  }
};

function InvalidTokenError(message) {
  this.message = message;
}

InvalidTokenError.prototype = new Error();
InvalidTokenError.prototype.name = 'InvalidTokenError';

var jwtDecode_2_2_0_lib = function (token,options) {
  if (typeof token !== 'string') {
    throw new InvalidTokenError('Invalid token specified');
  }

  options = options || {};
  var pos = options.header === true ? 0 : 1;
  try {
    return JSON.parse(base64_url_decode(token.split('.')[pos]));
  } catch (e) {
    throw new InvalidTokenError('Invalid token specified: ' + e.message);
  }
};

var InvalidTokenError_1 = InvalidTokenError;
jwtDecode_2_2_0_lib.InvalidTokenError = InvalidTokenError_1;

//var canDev = require("can-log/dev/dev");

/**
 * @module can-util/js/assign/assign assign
 * @parent deprecated
 * @description Deprecated. Use [can-assign] instead.
 */

 //!steal-remove-start
//  canDev.warn('js/assign/assign is deprecated; please use can-assign instead: https://github.com/canjs/can-assign');
 //!steal-remove-end

var assign$7 = canAssign_1_1_1_canAssign;

// Reads and returns the contents of a cookie with the provided name.
function readCookie (name) {
	var nameEQ = name + '=';
	var ca = document.cookie.split(';');
	for (var i = 0; i < ca.length; i++) {
		var c = ca[i];
		while (c.charAt(0) === ' ') {
			c = c.substring(1, c.length);
		}
		if (c.indexOf(nameEQ) === 0) {
			return c.substring(nameEQ.length, c.length);
		}
	}
	return null;
}

// Reads the token from a cookie, sessionStorage, or localStorage, in that order.
function getStoredToken (storageLocation) {
	var token = readCookie(storageLocation);
	if (!token && (window && window.localStorage || window.sessionStorage)) {
		token = window.sessionStorage.getItem(storageLocation) || window.localStorage.getItem(storageLocation);
	}
	return token;
}

// Pass a decoded payload and it will return a boolean based on if it hasn't expired.
function payloadIsValid (payload) {
	return payload && payload.exp * 1000 > new Date().getTime();
}

// Gets a stored token and returns a boolean of whether it was valid.
function hasValidToken (storageLocation) {
	var token = getStoredToken(storageLocation);
	if (token) {
		try {
			var payload = jwtDecode_2_2_0_lib(token);
			return payloadIsValid(payload);
		} catch (error) {
			return false;
		}
	}
	return false;
}

function convertLocalAuthData (originalData) {
	var data = assign$7({}, originalData);
	if (data && data.strategy === 'local' && data.user) {
		Object.keys(data.user).forEach(function (key) {
			data[key] = data.user[key];
		});
		delete data.user;
	}
	return data;
}

var utils$2 = {
	readCookie: readCookie,
	getStoredToken: getStoredToken,
	hasValidToken: hasValidToken,
	payloadIsValid: payloadIsValid,
	convertLocalAuthData: convertLocalAuthData
};

var storage = {
  data: {},

  getStore: function () {
    if (window.doneSsr) {
      var CanZone = window.CanZone || undefined;
      return typeof CanZone === 'undefined' ? this.data : CanZone.current.data;
    }
    return this.data;
  },

  setItem: function (prop, value) {
    var store = this.getStore();
    store[prop] = value;
  },

  getItem: function (prop) {
    var store = this.getStore();
    return store[prop];
  },

  removeItem: function (prop) {
    var store = this.getStore();
    delete store[prop];
  }
};

var authAgent = require$$0$1.authAgent;

var payloadIsValid$1 = utils$2.payloadIsValid;
var hasValidToken$1 = utils$2.hasValidToken;
var convertLocalAuthData$1 = utils$2.convertLocalAuthData;



var session = canConnect_3_0_0Pre_14_canConnect.behavior('data/feathers-session', function (base) {
	var helpURL = 'https://canjs.com/doc/can-connect-feathers.html';
	var feathersClient = this.feathersClient;

	if (!feathersClient) {
		throw new Error('You must provide a feathersClient instance to the feathers-session behavior. See ' + helpURL);
	}
	if (!this.Map) {
		throw new Error('You must provide a Map instance to the feathers-session behavior. See ' + helpURL);
	}
	if (!feathersClient.passport) {
		throw new Error('You must register the feathers-authentication-client plugin before using the feathers-session behavior. See ' + helpURL);
	}

	var options = feathersClient.passport.options;
	var Session = this.Map;

	Object.defineProperty(Session, 'current', {
		get: function () {
			canObservationRecorder_1_1_2_canObservationRecorder.add(Session, 'current');
			if (storage.getItem('can-connect-feathers-session') === undefined) {

				// set session to `undefined` when we start authentication:
				storage.removeItem('can-connect-feathers-session');

				Session.get().then(function (session) {
					storage.setItem('can-connect-feathers-session', session);
					Session.dispatch('current', [session]);
				})
				.catch(function (error) {

					// set session to `null` since we know that user is non-authenticated:
					storage.setItem('can-connect-feathers-session', null);
					Session.dispatch('current', [null]);

					if (!error.className || error.className.indexOf('not-authenticated') < 0) {
						return Promise.reject(error);
					}
				});
			}
			return storage.getItem('can-connect-feathers-session');
		}
	});

	Session.on('created', function (ev, session) {
		storage.setItem('can-connect-feathers-session', session);
		Session.dispatch('current', [session]);
	});
	Session.on('destroyed', function () {
		storage.removeItem('can-connect-feathers-session');
		Session.dispatch('current', [undefined, storage.getItem('can-connect-feathers-session')]);
	});

	return {
		init: function () {
			base.init.apply(this, arguments);
			var connection = this;
			// Listen to feathers-authentication-popups messages.
			authAgent.on('login', function (token) {
				try {
					var payload = jwtDecode_2_2_0_lib(token);
					if (!payloadIsValid$1(payload)) {
						throw new Error('invalid token');
					}
				} catch (error) {
					throw new Error('An invalid token was received through the feathers-authentication-popups authAgent');
				}
				feathersClient.authenticate({strategy: 'jwt', accessToken: token})
					.then(function (data) {
						var payload = jwtDecode_2_2_0_lib(data.accessToken);
						connection.createInstance(payload);
					});
			});
		},
		createData: function (data) {
			var requestData = convertLocalAuthData$1(data);
			return feathersClient.authenticate(requestData)
				.then(function (response) {
					return response.accessToken ? jwtDecode_2_2_0_lib(response.accessToken) : response;
				});
		},
		getData: function () {

			return new Promise(function (resolve, reject) {
				var tokenLocation = options.tokenKey || options.cookie;
				if (hasValidToken$1(tokenLocation) && !window.doneSsr) {
					feathersClient.authenticate()
						.then(function (data) {
							var payload = jwtDecode_2_2_0_lib(data.accessToken);
							return resolve(payload);
						})
						.catch(reject);
				} else {
					reject(new errors.NotAuthenticated('Not Authenticated'));
				}
			});
		},
		destroyData: function (session) {
			return feathersClient.logout().then(function () {
				return session;
			});
		}
	};
});

var canConnectFeathers_5_0_0Pre_3_canConnectFeathers = {
	service: service,
	session: session
};

var warned = false;

var proxyNamespace = function proxyNamespace(namespace) {
	return new Proxy(namespace, {
		get: function get(target, name) {
			if (!warned) {
				console.warn("Warning: use of 'can' global should be for debugging purposes only.");
				warned = true;
			}
			return target[name];
		}
	});
};

var onValueSymbol$4 = canSymbol_1_6_1_canSymbol.for("can.onValue");
var offValueSymbol$2 = canSymbol_1_6_1_canSymbol.for("can.offValue");
var onKeyValueSymbol$3 = canSymbol_1_6_1_canSymbol.for("can.onKeyValue");
var offKeyValueSymbol$2 = canSymbol_1_6_1_canSymbol.for("can.offKeyValue");

var noop$4 = function noop() {};

function isFunction$3(value) {
	return typeof value === "function";
}

function withKey(obj, key, fn) {
	var result;

	if (isFunction$3(obj[onKeyValueSymbol$3])) {
		canReflect_1_16_7_canReflect.onKeyValue(obj, key, noop$4);
	}

	result = fn(obj, key);

	if (isFunction$3(obj[offKeyValueSymbol$2])) {
		canReflect_1_16_7_canReflect.offKeyValue(obj, key, noop$4);
	}

	return result;
}

function withoutKey(obj, fn) {
	var result;

	if (isFunction$3(obj[onValueSymbol$4])) {
		canReflect_1_16_7_canReflect.onValue(obj, noop$4);
	}

	result = fn(obj);

	if (isFunction$3(obj[offValueSymbol$2])) {
		canReflect_1_16_7_canReflect.offValue(obj, noop$4);
	}

	return result;
}

// Takes a function with signature `fn(obj, [key])`
// Makes sure that the argument is bound before calling 
// the function and unbinds it after the call is done.
var temporarilyBind$1 = function temporarilyBind(fn) {
	return function(obj, key) {
		var gotKey = arguments.length === 2;
		return gotKey ? withKey(obj, key, fn) : withoutKey(obj, fn);
	};
};

function Graph() {
	this.nodes = [];
	this.arrows = new Map();
	this.arrowsMeta = new Map();
}

// Adds the node, but it does not check if the node exists, callers will have
// to check that through [findNode]
Graph.prototype.addNode = function addNode(node) {
	this.nodes.push(node);
	this.arrows.set(node, new Set());
};

// Adds an arrow from head to tail with optional metadata
// The method does not check whether head and tail are already
// nodes in the graph, this should be done by the caller.
Graph.prototype.addArrow = function addArrow(head, tail, meta) {
	var graph = this;

	graph.arrows.get(head).add(tail);

	// optional
	if (meta) {
		addArrowMeta(graph, head, tail, meta);
	}
};

// Tests whether there is an arrow from head to tail
Graph.prototype.hasArrow = function hasArrow(head, tail) {
	return this.getNeighbors(head).has(tail);
};

// Returns the metadata associated to the head -> tail arrow
Graph.prototype.getArrowMeta = function getArrowMeta(head, tail) {
	return this.arrowsMeta.get(head) && this.arrowsMeta.get(head).get(tail);
};

// Sets metadata about the arrow from head to tail
// Merges the passed object into existing metadata
Graph.prototype.setArrowMeta = function setArrowMeta(head, tail, meta) {
	addArrowMeta(this, head, tail, meta);
};

// Returns a Set of all nodes 'y' such that there is an arrow
// from the node 'x' to the node 'y'.
Graph.prototype.getNeighbors = function getNeighbors(node) {
	return this.arrows.get(node);
};

// Returns the first node that satisfies the provided testing function.
// The Graph is traversed using depth first search
Graph.prototype.findNode = function findNode(cb) {
	var found = null;
	var graph = this;

	for (var node of graph.nodes) {
		if (cb(node)) {
			found = node;
			break;
		}
	}

	return found;
};

Graph.prototype.bfs = function bfs(visit) {
	var graph = this;

	var node = graph.nodes[0];
	var queue = [node];
	var visited = new Map([[node, true]]);

	while (queue.length) {
		node = queue.shift();

		visit(node);

		graph.arrows.get(node).forEach(function(adj) {
			if (!visited.has(adj)) {
				queue.push(adj);
				visited.set(adj, true);
			}
		});
	}
};

Graph.prototype.dfs = function dfs(visit) {
	var graph = this;

	var node = graph.nodes[0];
	var stack = [node];
	var visited = new Map();

	while (stack.length) {
		node = stack.pop();

		visit(node);

		if (!visited.has(node)) {
			visited.set(node, true);
			graph.arrows.get(node).forEach(function(adj) {
				stack.push(adj);
			});
		}
	}
};

// Returns a new graph where the arrows point to the opposite direction, that is:
// For each arrow (u, v) in [this], there will be a (v, u) in the returned graph
// This is also called Transpose or Converse a graph
Graph.prototype.reverse = function reverse() {
	var graph = this;
	var reversed = new Graph();

	// copy over the nodes
	graph.nodes.forEach(reversed.addNode.bind(reversed));

	graph.nodes.forEach(function(node) {
		graph.getNeighbors(node).forEach(function(adj) {
			// add the arrow in the opposite direction, copy over metadata
			var meta = graph.getArrowMeta(node, adj);
			reversed.addArrow(adj, node, meta);
		});
	});

	return reversed;
};

// Helpers
function addArrowMeta(graph, head, tail, meta) {
	var entry = graph.arrowsMeta.get(head);

	if (entry) {
		var arrowMeta = entry.get(tail);
		if (!arrowMeta) {
			arrowMeta = {};
		}
		entry.set(tail, Object.assign(arrowMeta, meta));
	} else {
		entry = new Map([[tail, meta]]);
		graph.arrowsMeta.set(head, entry);
	}
}

var graph = Graph;

var makeNode = function makeNode(obj, key) {
	var gotKey = arguments.length === 2;

	var node = {
		obj: obj,
		name: canReflect_1_16_7_canReflect.getName(obj),
		value: gotKey ? canReflect_1_16_7_canReflect.getKeyValue(obj, key) : canReflect_1_16_7_canReflect.getValue(obj)
	};

	if (gotKey) {
		node.key = key;
	}

	return node;
};

// Returns a directed graph of the dependencies of obj (key is optional)
//
// Signature:
//	getDirectedGraph(obj)
//	getDirectedGraph(obj, key)
var getGraph = function getGraph(obj, key) {
	var order = 0;
	var graph$$1 = new graph();
	var gotKey = arguments.length === 2;

	var addArrow = function addArrow(direction, parent, child, meta) {
		switch (direction) {
			case "whatIChange":
				graph$$1.addArrow(parent, child, meta); break;
			case "whatChangesMe":
				graph$$1.addArrow(child, parent, meta); break;
			default:
				throw new Error("Unknown direction value: ", meta.direction);
		}
	};

	// keyDependencies :: Map<obj, Set<key>>
	var visitKeyDependencies = function visitKeyDependencies(source, meta, cb) {
		canReflect_1_16_7_canReflect.eachKey(source.keyDependencies || {}, function(keys, obj) {
			canReflect_1_16_7_canReflect.each(keys, function(key) {
				cb(obj, meta, key);
			});
		});
	};

	// valueDependencies :: Set<obj>
	var visitValueDependencies = function visitValueDependencies(source, meta, cb) {
		canReflect_1_16_7_canReflect.eachIndex(source.valueDependencies || [], function(obj) {
			cb(obj, meta);
		});
	};

	var visit = function visit(obj, meta, key) {
		var gotKey = arguments.length === 3;

		var node = graph$$1.findNode(function(node) {
			return gotKey ?
				node.obj === obj && node.key === key :
				node.obj === obj;
		});

		// if there is a node already in the graph, add the arrow and prevent
		// infinite calls to `visit` by returning early
		if (node) {
			if (meta.parent) {
				addArrow(meta.direction, meta.parent, node, {
					kind: meta.kind,
					direction: meta.direction
				});
			}
			return graph$$1;
		}

		// create and add a node to the graph
		order += 1;
		node = gotKey ? makeNode(obj, key) : makeNode(obj);
		node.order = order;
		graph$$1.addNode(node);

		// if there is a known parent node, add the arrow in the given direction
		if (meta.parent) {
			addArrow(meta.direction, meta.parent, node, {
				kind: meta.kind,
				direction: meta.direction
			});
		}

		// get the dependencies of the new node and recursively visit those
		var nextMeta;
		var data = gotKey ?
			canReflectDependencies_1_0_2_canReflectDependencies.getDependencyDataOf(obj, key) :
			canReflectDependencies_1_0_2_canReflectDependencies.getDependencyDataOf(obj);

		if (data && data.whatIChange) {
			nextMeta = { direction: "whatIChange", parent: node };

			// kind :: derive | mutate
			canReflect_1_16_7_canReflect.eachKey(data.whatIChange, function(dependencyRecord, kind) {
				nextMeta.kind = kind;
				visitKeyDependencies(dependencyRecord, nextMeta, visit);
				visitValueDependencies(dependencyRecord, nextMeta, visit);
			});
		}

		if (data && data.whatChangesMe) {
			nextMeta = { direction: "whatChangesMe", parent: node };

			// kind :: derive | mutate
			canReflect_1_16_7_canReflect.eachKey(data.whatChangesMe, function(dependencyRecord, kind) {
				nextMeta.kind = kind;
				visitKeyDependencies(dependencyRecord, nextMeta, visit);
				visitValueDependencies(dependencyRecord, nextMeta, visit);
			});
		}

		return graph$$1;
	};

	return gotKey ? visit(obj, {}, key) : visit(obj, {});
};

// Converts the graph into a data structure that vis.js requires to draw the graph
var formatGraph = function formatGraph(graph) {
	// { [node]: Number }
	var nodeIdMap = new Map(
		graph.nodes.map(function(node, index) {
			return [node, index + 1];
		})
	);

	// collects nodes in the shape of { id: Number, label: String }
	var nodesDataSet = graph.nodes.map(function(node) {
		return {
			shape: "box",
			id: nodeIdMap.get(node),
			label:
				canReflect_1_16_7_canReflect.getName(node.obj) +
				(node.key ? "." + node.key : "")
		};
	});

	var getArrowData = function getArrowData(meta) {
		var regular = { arrows: "to" };
		var withDashes = { arrows: "to", dashes: true };

		var map = {
			derive: regular,
			mutate: withDashes
		};

		return map[meta.kind];
	};

	// collect edges in the shape of { from: Id, to: Id }
	var visited = new Map();
	var arrowsDataSet = [];
	graph.nodes.forEach(function(node) {
		var visit = function(node) {
			if (!visited.has(node)) {
				visited.set(node, true);
				var arrows = graph.arrows.get(node);
				var headId = nodeIdMap.get(node);

				arrows.forEach(function(neighbor) {
					var tailId = nodeIdMap.get(neighbor);
					var meta = graph.arrowsMeta.get(node).get(neighbor);

					arrowsDataSet.push(
						Object.assign(
							{ from: headId, to: tailId },
							getArrowData(meta)
						)
					);

					visit(neighbor);
				});
			}
		};

		visit(node);
	});
	
	return {
		nodes: nodesDataSet,
		edges: arrowsDataSet
	};
};

var drawGraph = function drawGraph(obj, key) {
	var gotKey = arguments.length === 2;
	var graph = gotKey ? getGraph(obj, key) : getGraph(obj);

	fetch(__dirname + "/vis.js")
		.then(function(res) {
			return res.text();
		})
		.then(function(code) {
			var w = window.open("", "can-debug: Dependency Graph");
			var doc = w.document;
	
			// inject the visualization library code into the new window
			var script = doc.createElement("script");
			script.text = code;
			doc.body.appendChild(script);
	
			var data = formatGraph(graph);
			var drawScript = doc.createElement("script");
			drawScript.text = ` 
				var container = document.createElement("div");
	
				var options = {
					physics: {
						solver: "repulsion"
					}
				};

				document.title = "can-debug: Dependency Graph";
				document.body.appendChild(container);

				new vis.Network(
					container, 
					{
						nodes: new vis.DataSet(${ JSON.stringify(data.nodes) }),
						edges: new vis.DataSet(${ JSON.stringify(data.edges) })
					},
					options
				);
			`;
			doc.body.appendChild(drawScript);
		});
};

var quoteString$2 = function quoteString(x) {
	return typeof x === "string" ? JSON.stringify(x) : x;
};

var logData = function log(data) {
	var node = data.node;
	var nameParts = [node.name, "key" in node ? "." + node.key : ""];

	console.group(nameParts.join(""));
	console.log("value  ", quoteString$2(node.value));
	console.log("object ", node.obj);

	if (data.derive.length) {
		console.group("DERIVED FROM");
		canReflect_1_16_7_canReflect.eachIndex(data.derive, log);
		console.groupEnd();
	}

	if (data.mutations.length) {
		console.group("MUTATED BY");
		canReflect_1_16_7_canReflect.eachIndex(data.mutations, log);
		console.groupEnd();
	}

	if (data.twoWay.length) {
		console.group("TWO WAY");
		canReflect_1_16_7_canReflect.eachIndex(data.twoWay, log);
		console.groupEnd();
	}

	console.groupEnd();
};

// Returns a new graph with all the arrows not involved in a circuit
var labelCycles = function labelCycles(graph$$1) {
	var visited = new Map();
	var result = new graph();

	// copy over all nodes
	graph$$1.nodes.forEach(function(node) {
		result.addNode(node);
	});

	var visit = function visit(node) {
		visited.set(node, true);

		graph$$1.getNeighbors(node).forEach(function(adj) {
			// back arrow found
			if (visited.has(adj)) {
				// if isTwoWay is false it means the cycle involves more than 2 nodes,
				// e.g: A -> B -> C -> A
				// what to do in these cases? (currently ignoring these)
				var isTwoWay = graph$$1.hasArrow(node, adj);

				if (isTwoWay) {
					result.addArrow(adj, node, { kind: "twoWay" });
				}
			// copy over arrows not involved in a cycle
			} else {
				result.addArrow(node, adj, graph$$1.getArrowMeta(node, adj));
				visit(adj);
			}
		});
	};

	visit(graph$$1.nodes[0]);
	return result;
};

var isDisconnected = function isDisconnected(data) {
	return (
		!data.derive.length &&
		!data.mutations.length &&
		!data.twoWay.length
	);
};

// Returns a deeply nested object from the graph
var getData = function getDebugData(inputGraph, direction) {
	var visited = new Map();

	var graph = labelCycles(
		direction === "whatChangesMe" ? inputGraph.reverse() : inputGraph
	);

	var visit = function visit(node) {
		var data = { node: node, derive: [], mutations: [], twoWay: [] };

		visited.set(node, true);

		graph.getNeighbors(node).forEach(function(adj) {
			var meta = graph.getArrowMeta(node, adj);

			if (!visited.has(adj)) {
				switch (meta.kind) {
					case "twoWay":
						data.twoWay.push(visit(adj));
						break;

					case "derive":
						data.derive.push(visit(adj));
						break;

					case "mutate":
						data.mutations.push(visit(adj));
						break;

					default:
						throw new Error("Unknow meta.kind value: ", meta.kind);
				}
			}
		});

		return data;
	};

	// discard data if there are no arrows registered, this happens when
	// [direction] is passed in and no arrow metadada matches its value
	var result = visit(graph.nodes[0]);
	return isDisconnected(result) ? null : result;
};

// key :: string | number | null | undefined
var whatIChange = function logWhatIChange(obj, key) {
	var gotKey = arguments.length === 2;

	var data = getData(
		gotKey ? getGraph(obj, key) : getGraph(obj),
		"whatIChange"
	);

	if (data) {
		logData(data);
	}
};

// key :: string | number | null | undefined
var whatChangesMe = function logWhatChangesMe(obj, key) {
	var gotKey = arguments.length === 2;

	var data = getData(
		gotKey ? getGraph(obj, key) : getGraph(obj),
		"whatChangesMe"
	);

	if (data) {
		logData(data);
	}
};

var getWhatIChange$1 = function getWhatChangesMe(obj, key) {
	var gotKey = arguments.length === 2;

	return getData(
		gotKey ? getGraph(obj, key) : getGraph(obj),
		"whatIChange"
	);
};

var getWhatChangesMe$1 = function getWhatChangesMe(obj, key) {
	var gotKey = arguments.length === 2;

	return getData(
		gotKey ? getGraph(obj, key) : getGraph(obj),
		"whatChangesMe"
	);
};

var canDebug_1_2_1_canDebug = canNamespace_1_0_0_canNamespace.debug = {
	getGraph: temporarilyBind$1(getGraph),
	formatGraph: temporarilyBind$1(formatGraph),
	drawGraph: temporarilyBind$1(drawGraph),
	getWhatIChange: temporarilyBind$1(getWhatIChange$1),
	getWhatChangesMe: temporarilyBind$1(getWhatChangesMe$1),
	logWhatIChange: temporarilyBind$1(whatIChange),
	logWhatChangesMe: temporarilyBind$1(whatChangesMe)
};

var global$2 = canGlobals_1_1_1_canGlobals.getKeyValue("global");

global$2.can = typeof Proxy !== "undefined" ? proxyNamespace(canNamespace_1_0_0_canNamespace) : canNamespace_1_0_0_canNamespace;

var devtoolsCanModules = {
	Symbol: canSymbol_1_6_1_canSymbol,
	Reflect: canReflect_1_16_7_canReflect,
	queues: canQueues_1_1_0_canQueues,
	getGraph: canNamespace_1_0_0_canNamespace.debug.getGraph,
	formatGraph: canNamespace_1_0_0_canNamespace.debug.formatGraph,
	mergeDeep: mergeDeep
};

if (global$2.__CANJS_DEVTOOLS__) {
	global$2.__CANJS_DEVTOOLS__.register(devtoolsCanModules);
} else {
	Object.defineProperty(global$2, "__CANJS_DEVTOOLS__", {
		set: function(devtoolsGlobal) {
			devtoolsGlobal.register(devtoolsCanModules);
			return devtoolsGlobal;
		}
	});
}

var canDefineBackup_2_0_0Pre_2_canDefineBackup = createCommonjsModule(function (module, exports) {
//allows you to backup and restore a map instance






var flatProps = function (a, cur) {
	var obj = {};
	for (var prop in a) {
		if (typeof a[prop] !== 'object' || a[prop] === null || a[prop] instanceof Date) {
			obj[prop] = a[prop];
		} else {
			obj[prop] = cur[prop];//cur.attr(prop);
		}
	}
	return obj;
};

var observables = new WeakMap();

function getBackup(map) {
	var obs = observables.get(map);
	if(!obs) {
		obs = new canSimpleObservable_2_0_4_canSimpleObservable();
		observables.set(map, obs);
	}
	return obs;
}

function defineBackup(Map) {
	canAssign_1_1_1_canAssign(Map.prototype, {

		backup: function () {
			var store = getBackup(this);
			canReflect_1_16_7_canReflect.setValue(store, this.serialize());
			return this;
		},

		isDirty: function (checkAssociations) {
			var store = getBackup(this);
			var backupStore = canReflect_1_16_7_canReflect.getValue(store);
			if(!backupStore){
				return false;
			}
			var currentValue = this.serialize();
			var patches;
			if(!! checkAssociations) {
				patches = deep(currentValue, backupStore);
			} else {
				patches = map$5(currentValue, backupStore).filter(function(patch){
					// only keep those that are not a set of deep object
					if(patch.type !== "set") {
						return true;
					} else {
						// check values .. if both objects ... we are not dirty ...
						var curVal = currentValue[patch.key],
							backupVal = backupStore[patch.key];
						var twoObjectsCompared = curVal && backupVal && typeof curVal === "object" && typeof backupVal === "object";
						return !twoObjectsCompared;
					}
				});
			}
			return patches.length;
		},

		restore: function (restoreAssociations) {
			var store = getBackup(this);
			var curVal = canReflect_1_16_7_canReflect.getValue(store);
			var props = restoreAssociations ? curVal : flatProps(curVal, this);
			if (this.isDirty(restoreAssociations)) {
				for(var prop in props) {
					this[prop] = props[prop];
				}
			}
			return this;
		}
	});
	return;
}

module.exports = exports = defineBackup;
});

var canDefineStream_1_0_1_canDefineStream = function(canStream) {
	return function(DefineMapType) {
		["toStream","toStreamFromProperty","toStreamFromEvent"] .forEach(function(name){
			DefineMapType.prototype[name] = function(){
				return canStream[name].apply(canStream, [this].concat( [].slice.call(arguments) ));
			};
		});

		DefineMapType.prototype.stream = DefineMapType.prototype.toStream;

		// figure out how to rebuild definitions.
		var definitions = DefineMapType.prototype._define.definitions,
			dataInitializers = DefineMapType.prototype._define.dataInitializers,
			computedInitializers = DefineMapType.prototype._define.computedInitializers;

		canReflect_1_16_7_canReflect.eachKey(definitions, function(definition, property) {
			var streamDefinition = definition.stream;
			if(streamDefinition) {
				var newDefinition = canAssign_1_1_1_canAssign({
					default: function() {
						return canStream.toCompute(streamDefinition, this);
					}
				}, canDefine_2_3_5_canDefine.types.compute);
				canDefine_2_3_5_canDefine.property(
					DefineMapType.prototype,
					property,
					newDefinition,
					dataInitializers,
					computedInitializers
				);
			}
		});
	};
};

var kefir = createCommonjsModule(function (module, exports) {
/*! Kefir.js v3.8.3
 *  https://github.com/kefirjs/kefir
 */

(function (global, factory) {
	factory(exports);
}(commonjsGlobal, (function (exports) {
function createObj(proto) {
  var F = function () {};
  F.prototype = proto;
  return new F();
}

function extend(target /*, mixin1, mixin2...*/) {
  var length = arguments.length,
      i = void 0,
      prop = void 0;
  for (i = 1; i < length; i++) {
    for (prop in arguments[i]) {
      target[prop] = arguments[i][prop];
    }
  }
  return target;
}

function inherit(Child, Parent /*, mixin1, mixin2...*/) {
  var length = arguments.length,
      i = void 0;
  Child.prototype = createObj(Parent.prototype);
  Child.prototype.constructor = Child;
  for (i = 2; i < length; i++) {
    extend(Child.prototype, arguments[i]);
  }
  return Child;
}

var NOTHING = ['<nothing>'];
var END = 'end';
var VALUE = 'value';
var ERROR = 'error';
var ANY = 'any';

function concat(a, b) {
  var result = void 0,
      length = void 0,
      i = void 0,
      j = void 0;
  if (a.length === 0) {
    return b;
  }
  if (b.length === 0) {
    return a;
  }
  j = 0;
  result = new Array(a.length + b.length);
  length = a.length;
  for (i = 0; i < length; i++, j++) {
    result[j] = a[i];
  }
  length = b.length;
  for (i = 0; i < length; i++, j++) {
    result[j] = b[i];
  }
  return result;
}

function find(arr, value) {
  var length = arr.length,
      i = void 0;
  for (i = 0; i < length; i++) {
    if (arr[i] === value) {
      return i;
    }
  }
  return -1;
}

function findByPred(arr, pred) {
  var length = arr.length,
      i = void 0;
  for (i = 0; i < length; i++) {
    if (pred(arr[i])) {
      return i;
    }
  }
  return -1;
}

function cloneArray(input) {
  var length = input.length,
      result = new Array(length),
      i = void 0;
  for (i = 0; i < length; i++) {
    result[i] = input[i];
  }
  return result;
}

function remove(input, index) {
  var length = input.length,
      result = void 0,
      i = void 0,
      j = void 0;
  if (index >= 0 && index < length) {
    if (length === 1) {
      return [];
    } else {
      result = new Array(length - 1);
      for (i = 0, j = 0; i < length; i++) {
        if (i !== index) {
          result[j] = input[i];
          j++;
        }
      }
      return result;
    }
  } else {
    return input;
  }
}

function map(input, fn) {
  var length = input.length,
      result = new Array(length),
      i = void 0;
  for (i = 0; i < length; i++) {
    result[i] = fn(input[i]);
  }
  return result;
}

function forEach(arr, fn) {
  var length = arr.length,
      i = void 0;
  for (i = 0; i < length; i++) {
    fn(arr[i]);
  }
}

function fillArray(arr, value) {
  var length = arr.length,
      i = void 0;
  for (i = 0; i < length; i++) {
    arr[i] = value;
  }
}

function contains(arr, value) {
  return find(arr, value) !== -1;
}

function slide(cur, next, max) {
  var length = Math.min(max, cur.length + 1),
      offset = cur.length - length + 1,
      result = new Array(length),
      i = void 0;
  for (i = offset; i < length; i++) {
    result[i - offset] = cur[i];
  }
  result[length - 1] = next;
  return result;
}

function callSubscriber(type, fn, event) {
  if (type === ANY) {
    fn(event);
  } else if (type === event.type) {
    if (type === VALUE || type === ERROR) {
      fn(event.value);
    } else {
      fn();
    }
  }
}

function Dispatcher() {
  this._items = [];
  this._spies = [];
  this._inLoop = 0;
  this._removedItems = null;
}

extend(Dispatcher.prototype, {
  add: function (type, fn) {
    this._items = concat(this._items, [{ type: type, fn: fn }]);
    return this._items.length;
  },
  remove: function (type, fn) {
    var index = findByPred(this._items, function (x) {
      return x.type === type && x.fn === fn;
    });

    // if we're currently in a notification loop,
    // remember this subscriber was removed
    if (this._inLoop !== 0 && index !== -1) {
      if (this._removedItems === null) {
        this._removedItems = [];
      }
      this._removedItems.push(this._items[index]);
    }

    this._items = remove(this._items, index);
    return this._items.length;
  },
  addSpy: function (fn) {
    this._spies = concat(this._spies, [fn]);
    return this._spies.length;
  },


  // Because spies are only ever a function that perform logging as
  // their only side effect, we don't need the same complicated
  // removal logic like in remove()
  removeSpy: function (fn) {
    this._spies = remove(this._spies, this._spies.indexOf(fn));
    return this._spies.length;
  },
  dispatch: function (event) {
    this._inLoop++;
    for (var i = 0, spies = this._spies; this._spies !== null && i < spies.length; i++) {
      spies[i](event);
    }

    for (var _i = 0, items = this._items; _i < items.length; _i++) {
      // cleanup was called
      if (this._items === null) {
        break;
      }

      // this subscriber was removed
      if (this._removedItems !== null && contains(this._removedItems, items[_i])) {
        continue;
      }

      callSubscriber(items[_i].type, items[_i].fn, event);
    }
    this._inLoop--;
    if (this._inLoop === 0) {
      this._removedItems = null;
    }
  },
  cleanup: function () {
    this._items = null;
    this._spies = null;
  }
});

function Observable() {
  this._dispatcher = new Dispatcher();
  this._active = false;
  this._alive = true;
  this._activating = false;
  this._logHandlers = null;
  this._spyHandlers = null;
}

extend(Observable.prototype, {
  _name: 'observable',

  _onActivation: function () {},
  _onDeactivation: function () {},
  _setActive: function (active) {
    if (this._active !== active) {
      this._active = active;
      if (active) {
        this._activating = true;
        this._onActivation();
        this._activating = false;
      } else {
        this._onDeactivation();
      }
    }
  },
  _clear: function () {
    this._setActive(false);
    this._dispatcher.cleanup();
    this._dispatcher = null;
    this._logHandlers = null;
  },
  _emit: function (type, x) {
    switch (type) {
      case VALUE:
        return this._emitValue(x);
      case ERROR:
        return this._emitError(x);
      case END:
        return this._emitEnd();
    }
  },
  _emitValue: function (value) {
    if (this._alive) {
      this._dispatcher.dispatch({ type: VALUE, value: value });
    }
  },
  _emitError: function (value) {
    if (this._alive) {
      this._dispatcher.dispatch({ type: ERROR, value: value });
    }
  },
  _emitEnd: function () {
    if (this._alive) {
      this._alive = false;
      this._dispatcher.dispatch({ type: END });
      this._clear();
    }
  },
  _on: function (type, fn) {
    if (this._alive) {
      this._dispatcher.add(type, fn);
      this._setActive(true);
    } else {
      callSubscriber(type, fn, { type: END });
    }
    return this;
  },
  _off: function (type, fn) {
    if (this._alive) {
      var count = this._dispatcher.remove(type, fn);
      if (count === 0) {
        this._setActive(false);
      }
    }
    return this;
  },
  onValue: function (fn) {
    return this._on(VALUE, fn);
  },
  onError: function (fn) {
    return this._on(ERROR, fn);
  },
  onEnd: function (fn) {
    return this._on(END, fn);
  },
  onAny: function (fn) {
    return this._on(ANY, fn);
  },
  offValue: function (fn) {
    return this._off(VALUE, fn);
  },
  offError: function (fn) {
    return this._off(ERROR, fn);
  },
  offEnd: function (fn) {
    return this._off(END, fn);
  },
  offAny: function (fn) {
    return this._off(ANY, fn);
  },
  observe: function (observerOrOnValue, onError, onEnd) {
    var _this = this;
    var closed = false;

    var observer = !observerOrOnValue || typeof observerOrOnValue === 'function' ? { value: observerOrOnValue, error: onError, end: onEnd } : observerOrOnValue;

    var handler = function (event) {
      if (event.type === END) {
        closed = true;
      }
      if (event.type === VALUE && observer.value) {
        observer.value(event.value);
      } else if (event.type === ERROR && observer.error) {
        observer.error(event.value);
      } else if (event.type === END && observer.end) {
        observer.end(event.value);
      }
    };

    this.onAny(handler);

    return {
      unsubscribe: function () {
        if (!closed) {
          _this.offAny(handler);
          closed = true;
        }
      },

      get closed() {
        return closed;
      }
    };
  },


  // A and B must be subclasses of Stream and Property (order doesn't matter)
  _ofSameType: function (A, B) {
    return A.prototype.getType() === this.getType() ? A : B;
  },
  setName: function (sourceObs /* optional */, selfName) {
    this._name = selfName ? sourceObs._name + '.' + selfName : sourceObs;
    return this;
  },
  log: function () {
    var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.toString();

    var isCurrent = void 0;
    var handler = function (event) {
      var type = '<' + event.type + (isCurrent ? ':current' : '') + '>';
      if (event.type === END) {
        console.log(name, type);
      } else {
        console.log(name, type, event.value);
      }
    };

    if (this._alive) {
      if (!this._logHandlers) {
        this._logHandlers = [];
      }
      this._logHandlers.push({ name: name, handler: handler });
    }

    isCurrent = true;
    this.onAny(handler);
    isCurrent = false;

    return this;
  },
  offLog: function () {
    var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.toString();

    if (this._logHandlers) {
      var handlerIndex = findByPred(this._logHandlers, function (obj) {
        return obj.name === name;
      });
      if (handlerIndex !== -1) {
        this.offAny(this._logHandlers[handlerIndex].handler);
        this._logHandlers.splice(handlerIndex, 1);
      }
    }

    return this;
  },
  spy: function () {
    var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.toString();

    var handler = function (event) {
      var type = '<' + event.type + '>';
      if (event.type === END) {
        console.log(name, type);
      } else {
        console.log(name, type, event.value);
      }
    };
    if (this._alive) {
      if (!this._spyHandlers) {
        this._spyHandlers = [];
      }
      this._spyHandlers.push({ name: name, handler: handler });
      this._dispatcher.addSpy(handler);
    }
    return this;
  },
  offSpy: function () {
    var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.toString();

    if (this._spyHandlers) {
      var handlerIndex = findByPred(this._spyHandlers, function (obj) {
        return obj.name === name;
      });
      if (handlerIndex !== -1) {
        this._dispatcher.removeSpy(this._spyHandlers[handlerIndex].handler);
        this._spyHandlers.splice(handlerIndex, 1);
      }
    }
    return this;
  }
});

// extend() can't handle `toString` in IE8
Observable.prototype.toString = function () {
  return '[' + this._name + ']';
};

function Stream() {
  Observable.call(this);
}

inherit(Stream, Observable, {
  _name: 'stream',

  getType: function () {
    return 'stream';
  }
});

function Property() {
  Observable.call(this);
  this._currentEvent = null;
}

inherit(Property, Observable, {
  _name: 'property',

  _emitValue: function (value) {
    if (this._alive) {
      this._currentEvent = { type: VALUE, value: value };
      if (!this._activating) {
        this._dispatcher.dispatch({ type: VALUE, value: value });
      }
    }
  },
  _emitError: function (value) {
    if (this._alive) {
      this._currentEvent = { type: ERROR, value: value };
      if (!this._activating) {
        this._dispatcher.dispatch({ type: ERROR, value: value });
      }
    }
  },
  _emitEnd: function () {
    if (this._alive) {
      this._alive = false;
      if (!this._activating) {
        this._dispatcher.dispatch({ type: END });
      }
      this._clear();
    }
  },
  _on: function (type, fn) {
    if (this._alive) {
      this._dispatcher.add(type, fn);
      this._setActive(true);
    }
    if (this._currentEvent !== null) {
      callSubscriber(type, fn, this._currentEvent);
    }
    if (!this._alive) {
      callSubscriber(type, fn, { type: END });
    }
    return this;
  },
  getType: function () {
    return 'property';
  }
});

var neverS = new Stream();
neverS._emitEnd();
neverS._name = 'never';

function never() {
  return neverS;
}

function timeBased(mixin) {
  function AnonymousStream(wait, options) {
    var _this = this;

    Stream.call(this);
    this._wait = wait;
    this._intervalId = null;
    this._$onTick = function () {
      return _this._onTick();
    };
    this._init(options);
  }

  inherit(AnonymousStream, Stream, {
    _init: function () {},
    _free: function () {},
    _onTick: function () {},
    _onActivation: function () {
      this._intervalId = setInterval(this._$onTick, this._wait);
    },
    _onDeactivation: function () {
      if (this._intervalId !== null) {
        clearInterval(this._intervalId);
        this._intervalId = null;
      }
    },
    _clear: function () {
      Stream.prototype._clear.call(this);
      this._$onTick = null;
      this._free();
    }
  }, mixin);

  return AnonymousStream;
}

var S = timeBased({
  _name: 'later',

  _init: function (_ref) {
    var x = _ref.x;

    this._x = x;
  },
  _free: function () {
    this._x = null;
  },
  _onTick: function () {
    this._emitValue(this._x);
    this._emitEnd();
  }
});

function later(wait, x) {
  return new S(wait, { x: x });
}

var S$1 = timeBased({
  _name: 'interval',

  _init: function (_ref) {
    var x = _ref.x;

    this._x = x;
  },
  _free: function () {
    this._x = null;
  },
  _onTick: function () {
    this._emitValue(this._x);
  }
});

function interval(wait, x) {
  return new S$1(wait, { x: x });
}

var S$2 = timeBased({
  _name: 'sequentially',

  _init: function (_ref) {
    var xs = _ref.xs;

    this._xs = cloneArray(xs);
  },
  _free: function () {
    this._xs = null;
  },
  _onTick: function () {
    if (this._xs.length === 1) {
      this._emitValue(this._xs[0]);
      this._emitEnd();
    } else {
      this._emitValue(this._xs.shift());
    }
  }
});

function sequentially(wait, xs) {
  return xs.length === 0 ? never() : new S$2(wait, { xs: xs });
}

var S$3 = timeBased({
  _name: 'fromPoll',

  _init: function (_ref) {
    var fn = _ref.fn;

    this._fn = fn;
  },
  _free: function () {
    this._fn = null;
  },
  _onTick: function () {
    var fn = this._fn;
    this._emitValue(fn());
  }
});

function fromPoll(wait, fn) {
  return new S$3(wait, { fn: fn });
}

function emitter(obs) {
  function value(x) {
    obs._emitValue(x);
    return obs._active;
  }

  function error(x) {
    obs._emitError(x);
    return obs._active;
  }

  function end() {
    obs._emitEnd();
    return obs._active;
  }

  function event(e) {
    obs._emit(e.type, e.value);
    return obs._active;
  }

  return {
    value: value,
    error: error,
    end: end,
    event: event,

    // legacy
    emit: value,
    emitEvent: event
  };
}

var S$4 = timeBased({
  _name: 'withInterval',

  _init: function (_ref) {
    var fn = _ref.fn;

    this._fn = fn;
    this._emitter = emitter(this);
  },
  _free: function () {
    this._fn = null;
    this._emitter = null;
  },
  _onTick: function () {
    var fn = this._fn;
    fn(this._emitter);
  }
});

function withInterval(wait, fn) {
  return new S$4(wait, { fn: fn });
}

function S$5(fn) {
  Stream.call(this);
  this._fn = fn;
  this._unsubscribe = null;
}

inherit(S$5, Stream, {
  _name: 'stream',

  _onActivation: function () {
    var fn = this._fn;
    var unsubscribe = fn(emitter(this));
    this._unsubscribe = typeof unsubscribe === 'function' ? unsubscribe : null;

    // fix https://github.com/kefirjs/kefir/issues/35
    if (!this._active) {
      this._callUnsubscribe();
    }
  },
  _callUnsubscribe: function () {
    if (this._unsubscribe !== null) {
      this._unsubscribe();
      this._unsubscribe = null;
    }
  },
  _onDeactivation: function () {
    this._callUnsubscribe();
  },
  _clear: function () {
    Stream.prototype._clear.call(this);
    this._fn = null;
  }
});

function stream(fn) {
  return new S$5(fn);
}

function fromCallback(callbackConsumer) {
  var called = false;

  return stream(function (emitter) {
    if (!called) {
      callbackConsumer(function (x) {
        emitter.emit(x);
        emitter.end();
      });
      called = true;
    }
  }).setName('fromCallback');
}

function fromNodeCallback(callbackConsumer) {
  var called = false;

  return stream(function (emitter) {
    if (!called) {
      callbackConsumer(function (error, x) {
        if (error) {
          emitter.error(error);
        } else {
          emitter.emit(x);
        }
        emitter.end();
      });
      called = true;
    }
  }).setName('fromNodeCallback');
}

function spread(fn, length) {
  switch (length) {
    case 0:
      return function () {
        return fn();
      };
    case 1:
      return function (a) {
        return fn(a[0]);
      };
    case 2:
      return function (a) {
        return fn(a[0], a[1]);
      };
    case 3:
      return function (a) {
        return fn(a[0], a[1], a[2]);
      };
    case 4:
      return function (a) {
        return fn(a[0], a[1], a[2], a[3]);
      };
    default:
      return function (a) {
        return fn.apply(null, a);
      };
  }
}

function apply(fn, c, a) {
  var aLength = a ? a.length : 0;
  if (c == null) {
    switch (aLength) {
      case 0:
        return fn();
      case 1:
        return fn(a[0]);
      case 2:
        return fn(a[0], a[1]);
      case 3:
        return fn(a[0], a[1], a[2]);
      case 4:
        return fn(a[0], a[1], a[2], a[3]);
      default:
        return fn.apply(null, a);
    }
  } else {
    switch (aLength) {
      case 0:
        return fn.call(c);
      default:
        return fn.apply(c, a);
    }
  }
}

function fromSubUnsub(sub, unsub, transformer /* Function | falsey */) {
  return stream(function (emitter) {
    var handler = transformer ? function () {
      emitter.emit(apply(transformer, this, arguments));
    } : function (x) {
      emitter.emit(x);
    };

    sub(handler);
    return function () {
      return unsub(handler);
    };
  }).setName('fromSubUnsub');
}

var pairs = [['addEventListener', 'removeEventListener'], ['addListener', 'removeListener'], ['on', 'off']];

function fromEvents(target, eventName, transformer) {
  var sub = void 0,
      unsub = void 0;

  for (var i = 0; i < pairs.length; i++) {
    if (typeof target[pairs[i][0]] === 'function' && typeof target[pairs[i][1]] === 'function') {
      sub = pairs[i][0];
      unsub = pairs[i][1];
      break;
    }
  }

  if (sub === undefined) {
    throw new Error("target don't support any of " + 'addEventListener/removeEventListener, addListener/removeListener, on/off method pair');
  }

  return fromSubUnsub(function (handler) {
    return target[sub](eventName, handler);
  }, function (handler) {
    return target[unsub](eventName, handler);
  }, transformer).setName('fromEvents');
}

// HACK:
//   We don't call parent Class constructor, but instead putting all necessary
//   properties into prototype to simulate ended Property
//   (see Propperty and Observable classes).

function P(value) {
  this._currentEvent = { type: 'value', value: value, current: true };
}

inherit(P, Property, {
  _name: 'constant',
  _active: false,
  _activating: false,
  _alive: false,
  _dispatcher: null,
  _logHandlers: null
});

function constant(x) {
  return new P(x);
}

// HACK:
//   We don't call parent Class constructor, but instead putting all necessary
//   properties into prototype to simulate ended Property
//   (see Propperty and Observable classes).

function P$1(value) {
  this._currentEvent = { type: 'error', value: value, current: true };
}

inherit(P$1, Property, {
  _name: 'constantError',
  _active: false,
  _activating: false,
  _alive: false,
  _dispatcher: null,
  _logHandlers: null
});

function constantError(x) {
  return new P$1(x);
}

function createConstructor(BaseClass, name) {
  return function AnonymousObservable(source, options) {
    var _this = this;

    BaseClass.call(this);
    this._source = source;
    this._name = source._name + '.' + name;
    this._init(options);
    this._$handleAny = function (event) {
      return _this._handleAny(event);
    };
  };
}

function createClassMethods(BaseClass) {
  return {
    _init: function () {},
    _free: function () {},
    _handleValue: function (x) {
      this._emitValue(x);
    },
    _handleError: function (x) {
      this._emitError(x);
    },
    _handleEnd: function () {
      this._emitEnd();
    },
    _handleAny: function (event) {
      switch (event.type) {
        case VALUE:
          return this._handleValue(event.value);
        case ERROR:
          return this._handleError(event.value);
        case END:
          return this._handleEnd();
      }
    },
    _onActivation: function () {
      this._source.onAny(this._$handleAny);
    },
    _onDeactivation: function () {
      this._source.offAny(this._$handleAny);
    },
    _clear: function () {
      BaseClass.prototype._clear.call(this);
      this._source = null;
      this._$handleAny = null;
      this._free();
    }
  };
}

function createStream(name, mixin) {
  var S = createConstructor(Stream, name);
  inherit(S, Stream, createClassMethods(Stream), mixin);
  return S;
}

function createProperty(name, mixin) {
  var P = createConstructor(Property, name);
  inherit(P, Property, createClassMethods(Property), mixin);
  return P;
}

var P$2 = createProperty('toProperty', {
  _init: function (_ref) {
    var fn = _ref.fn;

    this._getInitialCurrent = fn;
  },
  _onActivation: function () {
    if (this._getInitialCurrent !== null) {
      var getInitial = this._getInitialCurrent;
      this._emitValue(getInitial());
    }
    this._source.onAny(this._$handleAny); // copied from patterns/one-source
  }
});

function toProperty(obs) {
  var fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

  if (fn !== null && typeof fn !== 'function') {
    throw new Error('You should call toProperty() with a function or no arguments.');
  }
  return new P$2(obs, { fn: fn });
}

var S$6 = createStream('changes', {
  _handleValue: function (x) {
    if (!this._activating) {
      this._emitValue(x);
    }
  },
  _handleError: function (x) {
    if (!this._activating) {
      this._emitError(x);
    }
  }
});

function changes(obs) {
  return new S$6(obs);
}

function fromPromise(promise) {
  var called = false;

  var result = stream(function (emitter) {
    if (!called) {
      var onValue = function (x) {
        emitter.emit(x);
        emitter.end();
      };
      var onError = function (x) {
        emitter.error(x);
        emitter.end();
      };
      var _promise = promise.then(onValue, onError);

      // prevent libraries like 'Q' or 'when' from swallowing exceptions
      if (_promise && typeof _promise.done === 'function') {
        _promise.done();
      }

      called = true;
    }
  });

  return toProperty(result, null).setName('fromPromise');
}

function getGlodalPromise() {
  if (typeof Promise === 'function') {
    return Promise;
  } else {
    throw new Error("There isn't default Promise, use shim or parameter");
  }
}

var toPromise = function (obs) {
  var Promise = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : getGlodalPromise();

  var last = null;
  return new Promise(function (resolve, reject) {
    obs.onAny(function (event) {
      if (event.type === END && last !== null) {
        (last.type === VALUE ? resolve : reject)(last.value);
        last = null;
      } else {
        last = event;
      }
    });
  });
};

var commonjsGlobal$$1 = typeof window !== 'undefined' ? window : typeof commonjsGlobal !== 'undefined' ? commonjsGlobal : typeof self !== 'undefined' ? self : {};





function createCommonjsModule$$1(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

var ponyfill = createCommonjsModule$$1(function (module, exports) {

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports['default'] = symbolObservablePonyfill;
function symbolObservablePonyfill(root) {
	var result;
	var _Symbol = root.Symbol;

	if (typeof _Symbol === 'function') {
		if (_Symbol.observable) {
			result = _Symbol.observable;
		} else {
			result = _Symbol('observable');
			_Symbol.observable = result;
		}
	} else {
		result = '@@observable';
	}

	return result;
}
});

var index$1 = createCommonjsModule$$1(function (module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});



var _ponyfill2 = _interopRequireDefault(ponyfill);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { 'default': obj };
}

var root; /* global window */

if (typeof self !== 'undefined') {
  root = self;
} else if (typeof window !== 'undefined') {
  root = window;
} else if (typeof commonjsGlobal$$1 !== 'undefined') {
  root = commonjsGlobal$$1;
} else {
  root = module;
}

var result = (0, _ponyfill2['default'])(root);
exports['default'] = result;
});

var index = index$1;

// this file contains some hot JS modules systems stuff

var $$observable = index.default ? index.default : index;

function fromESObservable(_observable) {
  var observable = _observable[$$observable] ? _observable[$$observable]() : _observable;
  return stream(function (emitter) {
    var unsub = observable.subscribe({
      error: function (error) {
        emitter.error(error);
        emitter.end();
      },
      next: function (value) {
        emitter.emit(value);
      },
      complete: function () {
        emitter.end();
      }
    });

    if (unsub.unsubscribe) {
      return function () {
        unsub.unsubscribe();
      };
    } else {
      return unsub;
    }
  }).setName('fromESObservable');
}

function ESObservable(observable) {
  this._observable = observable.takeErrors(1);
}

extend(ESObservable.prototype, {
  subscribe: function (observerOrOnNext, onError, onComplete) {
    var _this = this;

    var observer = typeof observerOrOnNext === 'function' ? { next: observerOrOnNext, error: onError, complete: onComplete } : observerOrOnNext;

    var fn = function (event) {
      if (event.type === END) {
        closed = true;
      }

      if (event.type === VALUE && observer.next) {
        observer.next(event.value);
      } else if (event.type === ERROR && observer.error) {
        observer.error(event.value);
      } else if (event.type === END && observer.complete) {
        observer.complete(event.value);
      }
    };

    this._observable.onAny(fn);
    var closed = false;

    var subscription = {
      unsubscribe: function () {
        closed = true;
        _this._observable.offAny(fn);
      },
      get closed() {
        return closed;
      }
    };
    return subscription;
  }
});

// Need to assign directly b/c Symbols aren't enumerable.
ESObservable.prototype[$$observable] = function () {
  return this;
};

function toESObservable() {
  return new ESObservable(this);
}

function collect(source, keys, values) {
  for (var prop in source) {
    if (source.hasOwnProperty(prop)) {
      keys.push(prop);
      values.push(source[prop]);
    }
  }
}

function defaultErrorsCombinator(errors) {
  var latestError = void 0;
  for (var i = 0; i < errors.length; i++) {
    if (errors[i] !== undefined) {
      if (latestError === undefined || latestError.index < errors[i].index) {
        latestError = errors[i];
      }
    }
  }
  return latestError.error;
}

function Combine(active, passive, combinator) {
  var _this = this;

  Stream.call(this);
  this._activeCount = active.length;
  this._sources = concat(active, passive);
  this._combinator = combinator;
  this._aliveCount = 0;
  this._latestValues = new Array(this._sources.length);
  this._latestErrors = new Array(this._sources.length);
  fillArray(this._latestValues, NOTHING);
  this._emitAfterActivation = false;
  this._endAfterActivation = false;
  this._latestErrorIndex = 0;

  this._$handlers = [];

  var _loop = function (i) {
    _this._$handlers.push(function (event) {
      return _this._handleAny(i, event);
    });
  };

  for (var i = 0; i < this._sources.length; i++) {
    _loop(i);
  }
}

inherit(Combine, Stream, {
  _name: 'combine',

  _onActivation: function () {
    this._aliveCount = this._activeCount;

    // we need to suscribe to _passive_ sources before _active_
    // (see https://github.com/kefirjs/kefir/issues/98)
    for (var i = this._activeCount; i < this._sources.length; i++) {
      this._sources[i].onAny(this._$handlers[i]);
    }
    for (var _i = 0; _i < this._activeCount; _i++) {
      this._sources[_i].onAny(this._$handlers[_i]);
    }

    if (this._emitAfterActivation) {
      this._emitAfterActivation = false;
      this._emitIfFull();
    }
    if (this._endAfterActivation) {
      this._emitEnd();
    }
  },
  _onDeactivation: function () {
    var length = this._sources.length,
        i = void 0;
    for (i = 0; i < length; i++) {
      this._sources[i].offAny(this._$handlers[i]);
    }
  },
  _emitIfFull: function () {
    var hasAllValues = true;
    var hasErrors = false;
    var length = this._latestValues.length;
    var valuesCopy = new Array(length);
    var errorsCopy = new Array(length);

    for (var i = 0; i < length; i++) {
      valuesCopy[i] = this._latestValues[i];
      errorsCopy[i] = this._latestErrors[i];

      if (valuesCopy[i] === NOTHING) {
        hasAllValues = false;
      }

      if (errorsCopy[i] !== undefined) {
        hasErrors = true;
      }
    }

    if (hasAllValues) {
      var combinator = this._combinator;
      this._emitValue(combinator(valuesCopy));
    }
    if (hasErrors) {
      this._emitError(defaultErrorsCombinator(errorsCopy));
    }
  },
  _handleAny: function (i, event) {
    if (event.type === VALUE || event.type === ERROR) {
      if (event.type === VALUE) {
        this._latestValues[i] = event.value;
        this._latestErrors[i] = undefined;
      }
      if (event.type === ERROR) {
        this._latestValues[i] = NOTHING;
        this._latestErrors[i] = {
          index: this._latestErrorIndex++,
          error: event.value
        };
      }

      if (i < this._activeCount) {
        if (this._activating) {
          this._emitAfterActivation = true;
        } else {
          this._emitIfFull();
        }
      }
    } else {
      // END

      if (i < this._activeCount) {
        this._aliveCount--;
        if (this._aliveCount === 0) {
          if (this._activating) {
            this._endAfterActivation = true;
          } else {
            this._emitEnd();
          }
        }
      }
    }
  },
  _clear: function () {
    Stream.prototype._clear.call(this);
    this._sources = null;
    this._latestValues = null;
    this._latestErrors = null;
    this._combinator = null;
    this._$handlers = null;
  }
});

function combineAsArray(active) {
  var passive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  var combinator = arguments[2];

  if (!Array.isArray(passive)) {
    throw new Error('Combine can only combine active and passive collections of the same type.');
  }

  combinator = combinator ? spread(combinator, active.length + passive.length) : function (x) {
    return x;
  };
  return active.length === 0 ? never() : new Combine(active, passive, combinator);
}

function combineAsObject(active) {
  var passive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var combinator = arguments[2];

  if (typeof passive !== 'object' || Array.isArray(passive)) {
    throw new Error('Combine can only combine active and passive collections of the same type.');
  }

  var keys = [],
      activeObservables = [],
      passiveObservables = [];

  collect(active, keys, activeObservables);
  collect(passive, keys, passiveObservables);

  var objectify = function (values) {
    var event = {};
    for (var i = values.length - 1; 0 <= i; i--) {
      event[keys[i]] = values[i];
    }
    return combinator ? combinator(event) : event;
  };

  return activeObservables.length === 0 ? never() : new Combine(activeObservables, passiveObservables, objectify);
}

function combine(active, passive, combinator) {
  if (typeof passive === 'function') {
    combinator = passive;
    passive = undefined;
  }

  return Array.isArray(active) ? combineAsArray(active, passive, combinator) : combineAsObject(active, passive, combinator);
}

var Observable$2 = {
  empty: function () {
    return never();
  },


  // Monoid based on merge() seems more useful than one based on concat().
  concat: function (a, b) {
    return a.merge(b);
  },
  of: function (x) {
    return constant(x);
  },
  map: function (fn, obs) {
    return obs.map(fn);
  },
  bimap: function (fnErr, fnVal, obs) {
    return obs.mapErrors(fnErr).map(fnVal);
  },


  // This ap strictly speaking incompatible with chain. If we derive ap from chain we get
  // different (not very useful) behavior. But spec requires that if method can be derived
  // it must have the same behavior as hand-written method. We intentionally violate the spec
  // in hope that it won't cause many troubles in practice. And in return we have more useful type.
  ap: function (obsFn, obsVal) {
    return combine([obsFn, obsVal], function (fn, val) {
      return fn(val);
    });
  },
  chain: function (fn, obs) {
    return obs.flatMap(fn);
  }
};



var staticLand = Object.freeze({
	Observable: Observable$2
});

var mixin = {
  _init: function (_ref) {
    var fn = _ref.fn;

    this._fn = fn;
  },
  _free: function () {
    this._fn = null;
  },
  _handleValue: function (x) {
    var fn = this._fn;
    this._emitValue(fn(x));
  }
};

var S$7 = createStream('map', mixin);
var P$3 = createProperty('map', mixin);

var id = function (x) {
  return x;
};

function map$1(obs) {
  var fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : id;

  return new (obs._ofSameType(S$7, P$3))(obs, { fn: fn });
}

var mixin$1 = {
  _init: function (_ref) {
    var fn = _ref.fn;

    this._fn = fn;
  },
  _free: function () {
    this._fn = null;
  },
  _handleValue: function (x) {
    var fn = this._fn;
    if (fn(x)) {
      this._emitValue(x);
    }
  }
};

var S$8 = createStream('filter', mixin$1);
var P$4 = createProperty('filter', mixin$1);

var id$1 = function (x) {
  return x;
};

function filter(obs) {
  var fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : id$1;

  return new (obs._ofSameType(S$8, P$4))(obs, { fn: fn });
}

var mixin$2 = {
  _init: function (_ref) {
    var n = _ref.n;

    this._n = n;
    if (n <= 0) {
      this._emitEnd();
    }
  },
  _handleValue: function (x) {
    if (this._n === 0) {
      return;
    }
    this._n--;
    this._emitValue(x);
    if (this._n === 0) {
      this._emitEnd();
    }
  }
};

var S$9 = createStream('take', mixin$2);
var P$5 = createProperty('take', mixin$2);

function take(obs, n) {
  return new (obs._ofSameType(S$9, P$5))(obs, { n: n });
}

var mixin$3 = {
  _init: function (_ref) {
    var n = _ref.n;

    this._n = n;
    if (n <= 0) {
      this._emitEnd();
    }
  },
  _handleError: function (x) {
    if (this._n === 0) {
      return;
    }
    this._n--;
    this._emitError(x);
    if (this._n === 0) {
      this._emitEnd();
    }
  }
};

var S$10 = createStream('takeErrors', mixin$3);
var P$6 = createProperty('takeErrors', mixin$3);

function takeErrors(obs, n) {
  return new (obs._ofSameType(S$10, P$6))(obs, { n: n });
}

var mixin$4 = {
  _init: function (_ref) {
    var fn = _ref.fn;

    this._fn = fn;
  },
  _free: function () {
    this._fn = null;
  },
  _handleValue: function (x) {
    var fn = this._fn;
    if (fn(x)) {
      this._emitValue(x);
    } else {
      this._emitEnd();
    }
  }
};

var S$11 = createStream('takeWhile', mixin$4);
var P$7 = createProperty('takeWhile', mixin$4);

var id$2 = function (x) {
  return x;
};

function takeWhile(obs) {
  var fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : id$2;

  return new (obs._ofSameType(S$11, P$7))(obs, { fn: fn });
}

var mixin$5 = {
  _init: function () {
    this._lastValue = NOTHING;
  },
  _free: function () {
    this._lastValue = null;
  },
  _handleValue: function (x) {
    this._lastValue = x;
  },
  _handleEnd: function () {
    if (this._lastValue !== NOTHING) {
      this._emitValue(this._lastValue);
    }
    this._emitEnd();
  }
};

var S$12 = createStream('last', mixin$5);
var P$8 = createProperty('last', mixin$5);

function last(obs) {
  return new (obs._ofSameType(S$12, P$8))(obs);
}

var mixin$6 = {
  _init: function (_ref) {
    var n = _ref.n;

    this._n = Math.max(0, n);
  },
  _handleValue: function (x) {
    if (this._n === 0) {
      this._emitValue(x);
    } else {
      this._n--;
    }
  }
};

var S$13 = createStream('skip', mixin$6);
var P$9 = createProperty('skip', mixin$6);

function skip(obs, n) {
  return new (obs._ofSameType(S$13, P$9))(obs, { n: n });
}

var mixin$7 = {
  _init: function (_ref) {
    var fn = _ref.fn;

    this._fn = fn;
  },
  _free: function () {
    this._fn = null;
  },
  _handleValue: function (x) {
    var fn = this._fn;
    if (this._fn !== null && !fn(x)) {
      this._fn = null;
    }
    if (this._fn === null) {
      this._emitValue(x);
    }
  }
};

var S$14 = createStream('skipWhile', mixin$7);
var P$10 = createProperty('skipWhile', mixin$7);

var id$3 = function (x) {
  return x;
};

function skipWhile(obs) {
  var fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : id$3;

  return new (obs._ofSameType(S$14, P$10))(obs, { fn: fn });
}

var mixin$8 = {
  _init: function (_ref) {
    var fn = _ref.fn;

    this._fn = fn;
    this._prev = NOTHING;
  },
  _free: function () {
    this._fn = null;
    this._prev = null;
  },
  _handleValue: function (x) {
    var fn = this._fn;
    if (this._prev === NOTHING || !fn(this._prev, x)) {
      this._prev = x;
      this._emitValue(x);
    }
  }
};

var S$15 = createStream('skipDuplicates', mixin$8);
var P$11 = createProperty('skipDuplicates', mixin$8);

var eq = function (a, b) {
  return a === b;
};

function skipDuplicates(obs) {
  var fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : eq;

  return new (obs._ofSameType(S$15, P$11))(obs, { fn: fn });
}

var mixin$9 = {
  _init: function (_ref) {
    var fn = _ref.fn,
        seed = _ref.seed;

    this._fn = fn;
    this._prev = seed;
  },
  _free: function () {
    this._prev = null;
    this._fn = null;
  },
  _handleValue: function (x) {
    if (this._prev !== NOTHING) {
      var fn = this._fn;
      this._emitValue(fn(this._prev, x));
    }
    this._prev = x;
  }
};

var S$16 = createStream('diff', mixin$9);
var P$12 = createProperty('diff', mixin$9);

function defaultFn(a, b) {
  return [a, b];
}

function diff(obs, fn) {
  var seed = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : NOTHING;

  return new (obs._ofSameType(S$16, P$12))(obs, { fn: fn || defaultFn, seed: seed });
}

var P$13 = createProperty('scan', {
  _init: function (_ref) {
    var fn = _ref.fn,
        seed = _ref.seed;

    this._fn = fn;
    this._seed = seed;
    if (seed !== NOTHING) {
      this._emitValue(seed);
    }
  },
  _free: function () {
    this._fn = null;
    this._seed = null;
  },
  _handleValue: function (x) {
    var fn = this._fn;
    if (this._currentEvent === null || this._currentEvent.type === ERROR) {
      this._emitValue(this._seed === NOTHING ? x : fn(this._seed, x));
    } else {
      this._emitValue(fn(this._currentEvent.value, x));
    }
  }
});

function scan(obs, fn) {
  var seed = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : NOTHING;

  return new P$13(obs, { fn: fn, seed: seed });
}

var mixin$10 = {
  _init: function (_ref) {
    var fn = _ref.fn;

    this._fn = fn;
  },
  _free: function () {
    this._fn = null;
  },
  _handleValue: function (x) {
    var fn = this._fn;
    var xs = fn(x);
    for (var i = 0; i < xs.length; i++) {
      this._emitValue(xs[i]);
    }
  }
};

var S$17 = createStream('flatten', mixin$10);

var id$4 = function (x) {
  return x;
};

function flatten(obs) {
  var fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : id$4;

  return new S$17(obs, { fn: fn });
}

var END_MARKER = {};

var mixin$11 = {
  _init: function (_ref) {
    var _this = this;

    var wait = _ref.wait;

    this._wait = Math.max(0, wait);
    this._buff = [];
    this._$shiftBuff = function () {
      var value = _this._buff.shift();
      if (value === END_MARKER) {
        _this._emitEnd();
      } else {
        _this._emitValue(value);
      }
    };
  },
  _free: function () {
    this._buff = null;
    this._$shiftBuff = null;
  },
  _handleValue: function (x) {
    if (this._activating) {
      this._emitValue(x);
    } else {
      this._buff.push(x);
      setTimeout(this._$shiftBuff, this._wait);
    }
  },
  _handleEnd: function () {
    if (this._activating) {
      this._emitEnd();
    } else {
      this._buff.push(END_MARKER);
      setTimeout(this._$shiftBuff, this._wait);
    }
  }
};

var S$18 = createStream('delay', mixin$11);
var P$14 = createProperty('delay', mixin$11);

function delay(obs, wait) {
  return new (obs._ofSameType(S$18, P$14))(obs, { wait: wait });
}

var now = Date.now ? function () {
  return Date.now();
} : function () {
  return new Date().getTime();
};

var mixin$12 = {
  _init: function (_ref) {
    var _this = this;

    var wait = _ref.wait,
        leading = _ref.leading,
        trailing = _ref.trailing;

    this._wait = Math.max(0, wait);
    this._leading = leading;
    this._trailing = trailing;
    this._trailingValue = null;
    this._timeoutId = null;
    this._endLater = false;
    this._lastCallTime = 0;
    this._$trailingCall = function () {
      return _this._trailingCall();
    };
  },
  _free: function () {
    this._trailingValue = null;
    this._$trailingCall = null;
  },
  _handleValue: function (x) {
    if (this._activating) {
      this._emitValue(x);
    } else {
      var curTime = now();
      if (this._lastCallTime === 0 && !this._leading) {
        this._lastCallTime = curTime;
      }
      var remaining = this._wait - (curTime - this._lastCallTime);
      if (remaining <= 0) {
        this._cancelTrailing();
        this._lastCallTime = curTime;
        this._emitValue(x);
      } else if (this._trailing) {
        this._cancelTrailing();
        this._trailingValue = x;
        this._timeoutId = setTimeout(this._$trailingCall, remaining);
      }
    }
  },
  _handleEnd: function () {
    if (this._activating) {
      this._emitEnd();
    } else {
      if (this._timeoutId) {
        this._endLater = true;
      } else {
        this._emitEnd();
      }
    }
  },
  _cancelTrailing: function () {
    if (this._timeoutId !== null) {
      clearTimeout(this._timeoutId);
      this._timeoutId = null;
    }
  },
  _trailingCall: function () {
    this._emitValue(this._trailingValue);
    this._timeoutId = null;
    this._trailingValue = null;
    this._lastCallTime = !this._leading ? 0 : now();
    if (this._endLater) {
      this._emitEnd();
    }
  }
};

var S$19 = createStream('throttle', mixin$12);
var P$15 = createProperty('throttle', mixin$12);

function throttle(obs, wait) {
  var _ref2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
      _ref2$leading = _ref2.leading,
      leading = _ref2$leading === undefined ? true : _ref2$leading,
      _ref2$trailing = _ref2.trailing,
      trailing = _ref2$trailing === undefined ? true : _ref2$trailing;

  return new (obs._ofSameType(S$19, P$15))(obs, { wait: wait, leading: leading, trailing: trailing });
}

var mixin$13 = {
  _init: function (_ref) {
    var _this = this;

    var wait = _ref.wait,
        immediate = _ref.immediate;

    this._wait = Math.max(0, wait);
    this._immediate = immediate;
    this._lastAttempt = 0;
    this._timeoutId = null;
    this._laterValue = null;
    this._endLater = false;
    this._$later = function () {
      return _this._later();
    };
  },
  _free: function () {
    this._laterValue = null;
    this._$later = null;
  },
  _handleValue: function (x) {
    if (this._activating) {
      this._emitValue(x);
    } else {
      this._lastAttempt = now();
      if (this._immediate && !this._timeoutId) {
        this._emitValue(x);
      }
      if (!this._timeoutId) {
        this._timeoutId = setTimeout(this._$later, this._wait);
      }
      if (!this._immediate) {
        this._laterValue = x;
      }
    }
  },
  _handleEnd: function () {
    if (this._activating) {
      this._emitEnd();
    } else {
      if (this._timeoutId && !this._immediate) {
        this._endLater = true;
      } else {
        this._emitEnd();
      }
    }
  },
  _later: function () {
    var last = now() - this._lastAttempt;
    if (last < this._wait && last >= 0) {
      this._timeoutId = setTimeout(this._$later, this._wait - last);
    } else {
      this._timeoutId = null;
      if (!this._immediate) {
        this._emitValue(this._laterValue);
        this._laterValue = null;
      }
      if (this._endLater) {
        this._emitEnd();
      }
    }
  }
};

var S$20 = createStream('debounce', mixin$13);
var P$16 = createProperty('debounce', mixin$13);

function debounce(obs, wait) {
  var _ref2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
      _ref2$immediate = _ref2.immediate,
      immediate = _ref2$immediate === undefined ? false : _ref2$immediate;

  return new (obs._ofSameType(S$20, P$16))(obs, { wait: wait, immediate: immediate });
}

var mixin$14 = {
  _init: function (_ref) {
    var fn = _ref.fn;

    this._fn = fn;
  },
  _free: function () {
    this._fn = null;
  },
  _handleError: function (x) {
    var fn = this._fn;
    this._emitError(fn(x));
  }
};

var S$21 = createStream('mapErrors', mixin$14);
var P$17 = createProperty('mapErrors', mixin$14);

var id$5 = function (x) {
  return x;
};

function mapErrors(obs) {
  var fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : id$5;

  return new (obs._ofSameType(S$21, P$17))(obs, { fn: fn });
}

var mixin$15 = {
  _init: function (_ref) {
    var fn = _ref.fn;

    this._fn = fn;
  },
  _free: function () {
    this._fn = null;
  },
  _handleError: function (x) {
    var fn = this._fn;
    if (fn(x)) {
      this._emitError(x);
    }
  }
};

var S$22 = createStream('filterErrors', mixin$15);
var P$18 = createProperty('filterErrors', mixin$15);

var id$6 = function (x) {
  return x;
};

function filterErrors(obs) {
  var fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : id$6;

  return new (obs._ofSameType(S$22, P$18))(obs, { fn: fn });
}

var mixin$16 = {
  _handleValue: function () {}
};

var S$23 = createStream('ignoreValues', mixin$16);
var P$19 = createProperty('ignoreValues', mixin$16);

function ignoreValues(obs) {
  return new (obs._ofSameType(S$23, P$19))(obs);
}

var mixin$17 = {
  _handleError: function () {}
};

var S$24 = createStream('ignoreErrors', mixin$17);
var P$20 = createProperty('ignoreErrors', mixin$17);

function ignoreErrors(obs) {
  return new (obs._ofSameType(S$24, P$20))(obs);
}

var mixin$18 = {
  _handleEnd: function () {}
};

var S$25 = createStream('ignoreEnd', mixin$18);
var P$21 = createProperty('ignoreEnd', mixin$18);

function ignoreEnd(obs) {
  return new (obs._ofSameType(S$25, P$21))(obs);
}

var mixin$19 = {
  _init: function (_ref) {
    var fn = _ref.fn;

    this._fn = fn;
  },
  _free: function () {
    this._fn = null;
  },
  _handleEnd: function () {
    var fn = this._fn;
    this._emitValue(fn());
    this._emitEnd();
  }
};

var S$26 = createStream('beforeEnd', mixin$19);
var P$22 = createProperty('beforeEnd', mixin$19);

function beforeEnd(obs, fn) {
  return new (obs._ofSameType(S$26, P$22))(obs, { fn: fn });
}

var mixin$20 = {
  _init: function (_ref) {
    var min = _ref.min,
        max = _ref.max;

    this._max = max;
    this._min = min;
    this._buff = [];
  },
  _free: function () {
    this._buff = null;
  },
  _handleValue: function (x) {
    this._buff = slide(this._buff, x, this._max);
    if (this._buff.length >= this._min) {
      this._emitValue(this._buff);
    }
  }
};

var S$27 = createStream('slidingWindow', mixin$20);
var P$23 = createProperty('slidingWindow', mixin$20);

function slidingWindow(obs, max) {
  var min = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

  return new (obs._ofSameType(S$27, P$23))(obs, { min: min, max: max });
}

var mixin$21 = {
  _init: function (_ref) {
    var fn = _ref.fn,
        flushOnEnd = _ref.flushOnEnd;

    this._fn = fn;
    this._flushOnEnd = flushOnEnd;
    this._buff = [];
  },
  _free: function () {
    this._buff = null;
  },
  _flush: function () {
    if (this._buff !== null && this._buff.length !== 0) {
      this._emitValue(this._buff);
      this._buff = [];
    }
  },
  _handleValue: function (x) {
    this._buff.push(x);
    var fn = this._fn;
    if (!fn(x)) {
      this._flush();
    }
  },
  _handleEnd: function () {
    if (this._flushOnEnd) {
      this._flush();
    }
    this._emitEnd();
  }
};

var S$28 = createStream('bufferWhile', mixin$21);
var P$24 = createProperty('bufferWhile', mixin$21);

var id$7 = function (x) {
  return x;
};

function bufferWhile(obs, fn) {
  var _ref2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
      _ref2$flushOnEnd = _ref2.flushOnEnd,
      flushOnEnd = _ref2$flushOnEnd === undefined ? true : _ref2$flushOnEnd;

  return new (obs._ofSameType(S$28, P$24))(obs, { fn: fn || id$7, flushOnEnd: flushOnEnd });
}

var mixin$22 = {
  _init: function (_ref) {
    var count = _ref.count,
        flushOnEnd = _ref.flushOnEnd;

    this._count = count;
    this._flushOnEnd = flushOnEnd;
    this._buff = [];
  },
  _free: function () {
    this._buff = null;
  },
  _flush: function () {
    if (this._buff !== null && this._buff.length !== 0) {
      this._emitValue(this._buff);
      this._buff = [];
    }
  },
  _handleValue: function (x) {
    this._buff.push(x);
    if (this._buff.length >= this._count) {
      this._flush();
    }
  },
  _handleEnd: function () {
    if (this._flushOnEnd) {
      this._flush();
    }
    this._emitEnd();
  }
};

var S$29 = createStream('bufferWithCount', mixin$22);
var P$25 = createProperty('bufferWithCount', mixin$22);

function bufferWhile$1(obs, count) {
  var _ref2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
      _ref2$flushOnEnd = _ref2.flushOnEnd,
      flushOnEnd = _ref2$flushOnEnd === undefined ? true : _ref2$flushOnEnd;

  return new (obs._ofSameType(S$29, P$25))(obs, { count: count, flushOnEnd: flushOnEnd });
}

var mixin$23 = {
  _init: function (_ref) {
    var _this = this;

    var wait = _ref.wait,
        count = _ref.count,
        flushOnEnd = _ref.flushOnEnd;

    this._wait = wait;
    this._count = count;
    this._flushOnEnd = flushOnEnd;
    this._intervalId = null;
    this._$onTick = function () {
      return _this._flush();
    };
    this._buff = [];
  },
  _free: function () {
    this._$onTick = null;
    this._buff = null;
  },
  _flush: function () {
    if (this._buff !== null) {
      this._emitValue(this._buff);
      this._buff = [];
    }
  },
  _handleValue: function (x) {
    this._buff.push(x);
    if (this._buff.length >= this._count) {
      clearInterval(this._intervalId);
      this._flush();
      this._intervalId = setInterval(this._$onTick, this._wait);
    }
  },
  _handleEnd: function () {
    if (this._flushOnEnd && this._buff.length !== 0) {
      this._flush();
    }
    this._emitEnd();
  },
  _onActivation: function () {
    this._intervalId = setInterval(this._$onTick, this._wait);
    this._source.onAny(this._$handleAny); // copied from patterns/one-source
  },
  _onDeactivation: function () {
    if (this._intervalId !== null) {
      clearInterval(this._intervalId);
      this._intervalId = null;
    }
    this._source.offAny(this._$handleAny); // copied from patterns/one-source
  }
};

var S$30 = createStream('bufferWithTimeOrCount', mixin$23);
var P$26 = createProperty('bufferWithTimeOrCount', mixin$23);

function bufferWithTimeOrCount(obs, wait, count) {
  var _ref2 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {},
      _ref2$flushOnEnd = _ref2.flushOnEnd,
      flushOnEnd = _ref2$flushOnEnd === undefined ? true : _ref2$flushOnEnd;

  return new (obs._ofSameType(S$30, P$26))(obs, { wait: wait, count: count, flushOnEnd: flushOnEnd });
}

function xformForObs(obs) {
  return {
    '@@transducer/step': function (res, input) {
      obs._emitValue(input);
      return null;
    },
    '@@transducer/result': function () {
      obs._emitEnd();
      return null;
    }
  };
}

var mixin$24 = {
  _init: function (_ref) {
    var transducer = _ref.transducer;

    this._xform = transducer(xformForObs(this));
  },
  _free: function () {
    this._xform = null;
  },
  _handleValue: function (x) {
    if (this._xform['@@transducer/step'](null, x) !== null) {
      this._xform['@@transducer/result'](null);
    }
  },
  _handleEnd: function () {
    this._xform['@@transducer/result'](null);
  }
};

var S$31 = createStream('transduce', mixin$24);
var P$27 = createProperty('transduce', mixin$24);

function transduce(obs, transducer) {
  return new (obs._ofSameType(S$31, P$27))(obs, { transducer: transducer });
}

var mixin$25 = {
  _init: function (_ref) {
    var fn = _ref.fn;

    this._handler = fn;
    this._emitter = emitter(this);
  },
  _free: function () {
    this._handler = null;
    this._emitter = null;
  },
  _handleAny: function (event) {
    this._handler(this._emitter, event);
  }
};

var S$32 = createStream('withHandler', mixin$25);
var P$28 = createProperty('withHandler', mixin$25);

function withHandler(obs, fn) {
  return new (obs._ofSameType(S$32, P$28))(obs, { fn: fn });
}

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

function Zip(sources, combinator) {
  var _this = this;

  Stream.call(this);

  this._buffers = map(sources, function (source) {
    return isArray(source) ? cloneArray(source) : [];
  });
  this._sources = map(sources, function (source) {
    return isArray(source) ? never() : source;
  });

  this._combinator = combinator ? spread(combinator, this._sources.length) : function (x) {
    return x;
  };
  this._aliveCount = 0;

  this._$handlers = [];

  var _loop = function (i) {
    _this._$handlers.push(function (event) {
      return _this._handleAny(i, event);
    });
  };

  for (var i = 0; i < this._sources.length; i++) {
    _loop(i);
  }
}

inherit(Zip, Stream, {
  _name: 'zip',

  _onActivation: function () {
    // if all sources are arrays
    while (this._isFull()) {
      this._emit();
    }

    var length = this._sources.length;
    this._aliveCount = length;
    for (var i = 0; i < length && this._active; i++) {
      this._sources[i].onAny(this._$handlers[i]);
    }
  },
  _onDeactivation: function () {
    for (var i = 0; i < this._sources.length; i++) {
      this._sources[i].offAny(this._$handlers[i]);
    }
  },
  _emit: function () {
    var values = new Array(this._buffers.length);
    for (var i = 0; i < this._buffers.length; i++) {
      values[i] = this._buffers[i].shift();
    }
    var combinator = this._combinator;
    this._emitValue(combinator(values));
  },
  _isFull: function () {
    for (var i = 0; i < this._buffers.length; i++) {
      if (this._buffers[i].length === 0) {
        return false;
      }
    }
    return true;
  },
  _handleAny: function (i, event) {
    if (event.type === VALUE) {
      this._buffers[i].push(event.value);
      if (this._isFull()) {
        this._emit();
      }
    }
    if (event.type === ERROR) {
      this._emitError(event.value);
    }
    if (event.type === END) {
      this._aliveCount--;
      if (this._aliveCount === 0) {
        this._emitEnd();
      }
    }
  },
  _clear: function () {
    Stream.prototype._clear.call(this);
    this._sources = null;
    this._buffers = null;
    this._combinator = null;
    this._$handlers = null;
  }
});

function zip(observables, combinator /* Function | falsey */) {
  return observables.length === 0 ? never() : new Zip(observables, combinator);
}

var id$8 = function (x) {
  return x;
};

function AbstractPool() {
  var _this = this;

  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      _ref$queueLim = _ref.queueLim,
      queueLim = _ref$queueLim === undefined ? 0 : _ref$queueLim,
      _ref$concurLim = _ref.concurLim,
      concurLim = _ref$concurLim === undefined ? -1 : _ref$concurLim,
      _ref$drop = _ref.drop,
      drop = _ref$drop === undefined ? 'new' : _ref$drop;

  Stream.call(this);

  this._queueLim = queueLim < 0 ? -1 : queueLim;
  this._concurLim = concurLim < 0 ? -1 : concurLim;
  this._drop = drop;
  this._queue = [];
  this._curSources = [];
  this._$handleSubAny = function (event) {
    return _this._handleSubAny(event);
  };
  this._$endHandlers = [];
  this._currentlyAdding = null;

  if (this._concurLim === 0) {
    this._emitEnd();
  }
}

inherit(AbstractPool, Stream, {
  _name: 'abstractPool',

  _add: function (obj, toObs /* Function | falsey */) {
    toObs = toObs || id$8;
    if (this._concurLim === -1 || this._curSources.length < this._concurLim) {
      this._addToCur(toObs(obj));
    } else {
      if (this._queueLim === -1 || this._queue.length < this._queueLim) {
        this._addToQueue(toObs(obj));
      } else if (this._drop === 'old') {
        this._removeOldest();
        this._add(obj, toObs);
      }
    }
  },
  _addAll: function (obss) {
    var _this2 = this;

    forEach(obss, function (obs) {
      return _this2._add(obs);
    });
  },
  _remove: function (obs) {
    if (this._removeCur(obs) === -1) {
      this._removeQueue(obs);
    }
  },
  _addToQueue: function (obs) {
    this._queue = concat(this._queue, [obs]);
  },
  _addToCur: function (obs) {
    if (this._active) {
      // HACK:
      //
      // We have two optimizations for cases when `obs` is ended. We don't want
      // to add such observable to the list, but only want to emit events
      // from it (if it has some).
      //
      // Instead of this hacks, we could just did following,
      // but it would be 5-8 times slower:
      //
      //     this._curSources = concat(this._curSources, [obs]);
      //     this._subscribe(obs);
      //

      // #1
      // This one for cases when `obs` already ended
      // e.g., Kefir.constant() or Kefir.never()
      if (!obs._alive) {
        if (obs._currentEvent) {
          this._emit(obs._currentEvent.type, obs._currentEvent.value);
        }
        if (this._queue.length !== 0) {
          this._pullQueue();
        } else if (this._curSources.length === 0) {
          this._onEmpty();
        }
        return;
      }

      // #2
      // This one is for cases when `obs` going to end synchronously on
      // first subscriber e.g., Kefir.stream(em => {em.emit(1); em.end()})
      this._currentlyAdding = obs;
      obs.onAny(this._$handleSubAny);
      this._currentlyAdding = null;
      if (obs._alive) {
        this._curSources = concat(this._curSources, [obs]);
        if (this._active) {
          this._subToEnd(obs);
        }
      }
    } else {
      this._curSources = concat(this._curSources, [obs]);
    }
  },
  _subToEnd: function (obs) {
    var _this3 = this;

    var onEnd = function () {
      return _this3._removeCur(obs);
    };
    this._$endHandlers.push({ obs: obs, handler: onEnd });
    obs.onEnd(onEnd);
  },
  _subscribe: function (obs) {
    obs.onAny(this._$handleSubAny);

    // it can become inactive in responce of subscribing to `obs.onAny` above
    if (this._active) {
      this._subToEnd(obs);
    }
  },
  _unsubscribe: function (obs) {
    obs.offAny(this._$handleSubAny);

    var onEndI = findByPred(this._$endHandlers, function (obj) {
      return obj.obs === obs;
    });
    if (onEndI !== -1) {
      obs.offEnd(this._$endHandlers[onEndI].handler);
      this._$endHandlers.splice(onEndI, 1);
    }
  },
  _handleSubAny: function (event) {
    if (event.type === VALUE) {
      this._emitValue(event.value);
    } else if (event.type === ERROR) {
      this._emitError(event.value);
    }
  },
  _removeQueue: function (obs) {
    var index = find(this._queue, obs);
    this._queue = remove(this._queue, index);
    return index;
  },
  _removeCur: function (obs) {
    if (this._active) {
      this._unsubscribe(obs);
    }
    var index = find(this._curSources, obs);
    this._curSources = remove(this._curSources, index);
    if (index !== -1) {
      if (this._queue.length !== 0) {
        this._pullQueue();
      } else if (this._curSources.length === 0) {
        this._onEmpty();
      }
    }
    return index;
  },
  _removeOldest: function () {
    this._removeCur(this._curSources[0]);
  },
  _pullQueue: function () {
    if (this._queue.length !== 0) {
      this._queue = cloneArray(this._queue);
      this._addToCur(this._queue.shift());
    }
  },
  _onActivation: function () {
    for (var i = 0, sources = this._curSources; i < sources.length && this._active; i++) {
      this._subscribe(sources[i]);
    }
  },
  _onDeactivation: function () {
    for (var i = 0, sources = this._curSources; i < sources.length; i++) {
      this._unsubscribe(sources[i]);
    }
    if (this._currentlyAdding !== null) {
      this._unsubscribe(this._currentlyAdding);
    }
  },
  _isEmpty: function () {
    return this._curSources.length === 0;
  },
  _onEmpty: function () {},
  _clear: function () {
    Stream.prototype._clear.call(this);
    this._queue = null;
    this._curSources = null;
    this._$handleSubAny = null;
    this._$endHandlers = null;
  }
});

function Merge(sources) {
  AbstractPool.call(this);
  this._addAll(sources);
  this._initialised = true;
}

inherit(Merge, AbstractPool, {
  _name: 'merge',

  _onEmpty: function () {
    if (this._initialised) {
      this._emitEnd();
    }
  }
});

function merge(observables) {
  return observables.length === 0 ? never() : new Merge(observables);
}

function S$33(generator) {
  var _this = this;

  Stream.call(this);
  this._generator = generator;
  this._source = null;
  this._inLoop = false;
  this._iteration = 0;
  this._$handleAny = function (event) {
    return _this._handleAny(event);
  };
}

inherit(S$33, Stream, {
  _name: 'repeat',

  _handleAny: function (event) {
    if (event.type === END) {
      this._source = null;
      this._getSource();
    } else {
      this._emit(event.type, event.value);
    }
  },
  _getSource: function () {
    if (!this._inLoop) {
      this._inLoop = true;
      var generator = this._generator;
      while (this._source === null && this._alive && this._active) {
        this._source = generator(this._iteration++);
        if (this._source) {
          this._source.onAny(this._$handleAny);
        } else {
          this._emitEnd();
        }
      }
      this._inLoop = false;
    }
  },
  _onActivation: function () {
    if (this._source) {
      this._source.onAny(this._$handleAny);
    } else {
      this._getSource();
    }
  },
  _onDeactivation: function () {
    if (this._source) {
      this._source.offAny(this._$handleAny);
    }
  },
  _clear: function () {
    Stream.prototype._clear.call(this);
    this._generator = null;
    this._source = null;
    this._$handleAny = null;
  }
});

var repeat = function (generator) {
  return new S$33(generator);
};

function concat$1(observables) {
  return repeat(function (index) {
    return observables.length > index ? observables[index] : false;
  }).setName('concat');
}

function Pool() {
  AbstractPool.call(this);
}

inherit(Pool, AbstractPool, {
  _name: 'pool',

  plug: function (obs) {
    this._add(obs);
    return this;
  },
  unplug: function (obs) {
    this._remove(obs);
    return this;
  }
});

function FlatMap(source, fn, options) {
  var _this = this;

  AbstractPool.call(this, options);
  this._source = source;
  this._fn = fn;
  this._mainEnded = false;
  this._lastCurrent = null;
  this._$handleMain = function (event) {
    return _this._handleMain(event);
  };
}

inherit(FlatMap, AbstractPool, {
  _onActivation: function () {
    AbstractPool.prototype._onActivation.call(this);
    if (this._active) {
      this._source.onAny(this._$handleMain);
    }
  },
  _onDeactivation: function () {
    AbstractPool.prototype._onDeactivation.call(this);
    this._source.offAny(this._$handleMain);
    this._hadNoEvSinceDeact = true;
  },
  _handleMain: function (event) {
    if (event.type === VALUE) {
      // Is latest value before deactivation survived, and now is 'current' on this activation?
      // We don't want to handle such values, to prevent to constantly add
      // same observale on each activation/deactivation when our main source
      // is a `Kefir.conatant()` for example.
      var sameCurr = this._activating && this._hadNoEvSinceDeact && this._lastCurrent === event.value;
      if (!sameCurr) {
        this._add(event.value, this._fn);
      }
      this._lastCurrent = event.value;
      this._hadNoEvSinceDeact = false;
    }

    if (event.type === ERROR) {
      this._emitError(event.value);
    }

    if (event.type === END) {
      if (this._isEmpty()) {
        this._emitEnd();
      } else {
        this._mainEnded = true;
      }
    }
  },
  _onEmpty: function () {
    if (this._mainEnded) {
      this._emitEnd();
    }
  },
  _clear: function () {
    AbstractPool.prototype._clear.call(this);
    this._source = null;
    this._lastCurrent = null;
    this._$handleMain = null;
  }
});

function FlatMapErrors(source, fn) {
  FlatMap.call(this, source, fn);
}

inherit(FlatMapErrors, FlatMap, {
  // Same as in FlatMap, only VALUE/ERROR flipped
  _handleMain: function (event) {
    if (event.type === ERROR) {
      var sameCurr = this._activating && this._hadNoEvSinceDeact && this._lastCurrent === event.value;
      if (!sameCurr) {
        this._add(event.value, this._fn);
      }
      this._lastCurrent = event.value;
      this._hadNoEvSinceDeact = false;
    }

    if (event.type === VALUE) {
      this._emitValue(event.value);
    }

    if (event.type === END) {
      if (this._isEmpty()) {
        this._emitEnd();
      } else {
        this._mainEnded = true;
      }
    }
  }
});

function createConstructor$1(BaseClass, name) {
  return function AnonymousObservable(primary, secondary, options) {
    var _this = this;

    BaseClass.call(this);
    this._primary = primary;
    this._secondary = secondary;
    this._name = primary._name + '.' + name;
    this._lastSecondary = NOTHING;
    this._$handleSecondaryAny = function (event) {
      return _this._handleSecondaryAny(event);
    };
    this._$handlePrimaryAny = function (event) {
      return _this._handlePrimaryAny(event);
    };
    this._init(options);
  };
}

function createClassMethods$1(BaseClass) {
  return {
    _init: function () {},
    _free: function () {},
    _handlePrimaryValue: function (x) {
      this._emitValue(x);
    },
    _handlePrimaryError: function (x) {
      this._emitError(x);
    },
    _handlePrimaryEnd: function () {
      this._emitEnd();
    },
    _handleSecondaryValue: function (x) {
      this._lastSecondary = x;
    },
    _handleSecondaryError: function (x) {
      this._emitError(x);
    },
    _handleSecondaryEnd: function () {},
    _handlePrimaryAny: function (event) {
      switch (event.type) {
        case VALUE:
          return this._handlePrimaryValue(event.value);
        case ERROR:
          return this._handlePrimaryError(event.value);
        case END:
          return this._handlePrimaryEnd(event.value);
      }
    },
    _handleSecondaryAny: function (event) {
      switch (event.type) {
        case VALUE:
          return this._handleSecondaryValue(event.value);
        case ERROR:
          return this._handleSecondaryError(event.value);
        case END:
          this._handleSecondaryEnd(event.value);
          this._removeSecondary();
      }
    },
    _removeSecondary: function () {
      if (this._secondary !== null) {
        this._secondary.offAny(this._$handleSecondaryAny);
        this._$handleSecondaryAny = null;
        this._secondary = null;
      }
    },
    _onActivation: function () {
      if (this._secondary !== null) {
        this._secondary.onAny(this._$handleSecondaryAny);
      }
      if (this._active) {
        this._primary.onAny(this._$handlePrimaryAny);
      }
    },
    _onDeactivation: function () {
      if (this._secondary !== null) {
        this._secondary.offAny(this._$handleSecondaryAny);
      }
      this._primary.offAny(this._$handlePrimaryAny);
    },
    _clear: function () {
      BaseClass.prototype._clear.call(this);
      this._primary = null;
      this._secondary = null;
      this._lastSecondary = null;
      this._$handleSecondaryAny = null;
      this._$handlePrimaryAny = null;
      this._free();
    }
  };
}

function createStream$1(name, mixin) {
  var S = createConstructor$1(Stream, name);
  inherit(S, Stream, createClassMethods$1(Stream), mixin);
  return S;
}

function createProperty$1(name, mixin) {
  var P = createConstructor$1(Property, name);
  inherit(P, Property, createClassMethods$1(Property), mixin);
  return P;
}

var mixin$26 = {
  _handlePrimaryValue: function (x) {
    if (this._lastSecondary !== NOTHING && this._lastSecondary) {
      this._emitValue(x);
    }
  },
  _handleSecondaryEnd: function () {
    if (this._lastSecondary === NOTHING || !this._lastSecondary) {
      this._emitEnd();
    }
  }
};

var S$34 = createStream$1('filterBy', mixin$26);
var P$29 = createProperty$1('filterBy', mixin$26);

function filterBy(primary, secondary) {
  return new (primary._ofSameType(S$34, P$29))(primary, secondary);
}

var id2 = function (_, x) {
  return x;
};

function sampledBy(passive, active, combinator) {
  var _combinator = combinator ? function (a, b) {
    return combinator(b, a);
  } : id2;
  return combine([active], [passive], _combinator).setName(passive, 'sampledBy');
}

var mixin$27 = {
  _handlePrimaryValue: function (x) {
    if (this._lastSecondary !== NOTHING) {
      this._emitValue(x);
    }
  },
  _handleSecondaryEnd: function () {
    if (this._lastSecondary === NOTHING) {
      this._emitEnd();
    }
  }
};

var S$35 = createStream$1('skipUntilBy', mixin$27);
var P$30 = createProperty$1('skipUntilBy', mixin$27);

function skipUntilBy(primary, secondary) {
  return new (primary._ofSameType(S$35, P$30))(primary, secondary);
}

var mixin$28 = {
  _handleSecondaryValue: function () {
    this._emitEnd();
  }
};

var S$36 = createStream$1('takeUntilBy', mixin$28);
var P$31 = createProperty$1('takeUntilBy', mixin$28);

function takeUntilBy(primary, secondary) {
  return new (primary._ofSameType(S$36, P$31))(primary, secondary);
}

var mixin$29 = {
  _init: function () {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$flushOnEnd = _ref.flushOnEnd,
        flushOnEnd = _ref$flushOnEnd === undefined ? true : _ref$flushOnEnd;

    this._buff = [];
    this._flushOnEnd = flushOnEnd;
  },
  _free: function () {
    this._buff = null;
  },
  _flush: function () {
    if (this._buff !== null) {
      this._emitValue(this._buff);
      this._buff = [];
    }
  },
  _handlePrimaryEnd: function () {
    if (this._flushOnEnd) {
      this._flush();
    }
    this._emitEnd();
  },
  _onActivation: function () {
    this._primary.onAny(this._$handlePrimaryAny);
    if (this._alive && this._secondary !== null) {
      this._secondary.onAny(this._$handleSecondaryAny);
    }
  },
  _handlePrimaryValue: function (x) {
    this._buff.push(x);
  },
  _handleSecondaryValue: function () {
    this._flush();
  },
  _handleSecondaryEnd: function () {
    if (!this._flushOnEnd) {
      this._emitEnd();
    }
  }
};

var S$37 = createStream$1('bufferBy', mixin$29);
var P$32 = createProperty$1('bufferBy', mixin$29);

function bufferBy(primary, secondary, options /* optional */) {
  return new (primary._ofSameType(S$37, P$32))(primary, secondary, options);
}

var mixin$30 = {
  _init: function () {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$flushOnEnd = _ref.flushOnEnd,
        flushOnEnd = _ref$flushOnEnd === undefined ? true : _ref$flushOnEnd,
        _ref$flushOnChange = _ref.flushOnChange,
        flushOnChange = _ref$flushOnChange === undefined ? false : _ref$flushOnChange;

    this._buff = [];
    this._flushOnEnd = flushOnEnd;
    this._flushOnChange = flushOnChange;
  },
  _free: function () {
    this._buff = null;
  },
  _flush: function () {
    if (this._buff !== null) {
      this._emitValue(this._buff);
      this._buff = [];
    }
  },
  _handlePrimaryEnd: function () {
    if (this._flushOnEnd) {
      this._flush();
    }
    this._emitEnd();
  },
  _handlePrimaryValue: function (x) {
    this._buff.push(x);
    if (this._lastSecondary !== NOTHING && !this._lastSecondary) {
      this._flush();
    }
  },
  _handleSecondaryEnd: function () {
    if (!this._flushOnEnd && (this._lastSecondary === NOTHING || this._lastSecondary)) {
      this._emitEnd();
    }
  },
  _handleSecondaryValue: function (x) {
    if (this._flushOnChange && !x) {
      this._flush();
    }

    // from default _handleSecondaryValue
    this._lastSecondary = x;
  }
};

var S$38 = createStream$1('bufferWhileBy', mixin$30);
var P$33 = createProperty$1('bufferWhileBy', mixin$30);

function bufferWhileBy(primary, secondary, options /* optional */) {
  return new (primary._ofSameType(S$38, P$33))(primary, secondary, options);
}

var f = function () {
  return false;
};
var t = function () {
  return true;
};

function awaiting(a, b) {
  var result = merge([map$1(a, t), map$1(b, f)]);
  result = skipDuplicates(result);
  result = toProperty(result, f);
  return result.setName(a, 'awaiting');
}

var mixin$31 = {
  _init: function (_ref) {
    var fn = _ref.fn;

    this._fn = fn;
  },
  _free: function () {
    this._fn = null;
  },
  _handleValue: function (x) {
    var fn = this._fn;
    var result = fn(x);
    if (result.convert) {
      this._emitError(result.error);
    } else {
      this._emitValue(x);
    }
  }
};

var S$39 = createStream('valuesToErrors', mixin$31);
var P$34 = createProperty('valuesToErrors', mixin$31);

var defFn = function (x) {
  return { convert: true, error: x };
};

function valuesToErrors(obs) {
  var fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defFn;

  return new (obs._ofSameType(S$39, P$34))(obs, { fn: fn });
}

var mixin$32 = {
  _init: function (_ref) {
    var fn = _ref.fn;

    this._fn = fn;
  },
  _free: function () {
    this._fn = null;
  },
  _handleError: function (x) {
    var fn = this._fn;
    var result = fn(x);
    if (result.convert) {
      this._emitValue(result.value);
    } else {
      this._emitError(x);
    }
  }
};

var S$40 = createStream('errorsToValues', mixin$32);
var P$35 = createProperty('errorsToValues', mixin$32);

var defFn$1 = function (x) {
  return { convert: true, value: x };
};

function errorsToValues(obs) {
  var fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defFn$1;

  return new (obs._ofSameType(S$40, P$35))(obs, { fn: fn });
}

var mixin$33 = {
  _handleError: function (x) {
    this._emitError(x);
    this._emitEnd();
  }
};

var S$41 = createStream('endOnError', mixin$33);
var P$36 = createProperty('endOnError', mixin$33);

function endOnError(obs) {
  return new (obs._ofSameType(S$41, P$36))(obs);
}

// Create a stream
// -----------------------------------------------------------------------------

// () -> Stream
// (number, any) -> Stream
// (number, any) -> Stream
// (number, Array<any>) -> Stream
// (number, Function) -> Stream
// (number, Function) -> Stream
// (Function) -> Stream
// (Function) -> Stream
// Target = {addEventListener, removeEventListener}|{addListener, removeListener}|{on, off}
// (Target, string, Function|undefined) -> Stream
// (Function) -> Stream
// Create a property
// -----------------------------------------------------------------------------

// (any) -> Property
// (any) -> Property
// Convert observables
// -----------------------------------------------------------------------------

// (Stream|Property, Function|undefined) -> Property
Observable.prototype.toProperty = function (fn) {
  return toProperty(this, fn);
};

// (Stream|Property) -> Stream
Observable.prototype.changes = function () {
  return changes(this);
};

// Interoperation with other implimentations
// -----------------------------------------------------------------------------

// (Promise) -> Property
// (Stream|Property, Function|undefined) -> Promise
Observable.prototype.toPromise = function (Promise) {
  return toPromise(this, Promise);
};

// (ESObservable) -> Stream
// (Stream|Property) -> ES7 Observable
Observable.prototype.toESObservable = toESObservable;
Observable.prototype[$$observable] = toESObservable;

// Modify an observable
// -----------------------------------------------------------------------------

// (Stream, Function|undefined) -> Stream
// (Property, Function|undefined) -> Property
Observable.prototype.map = function (fn) {
  return map$1(this, fn);
};

// (Stream, Function|undefined) -> Stream
// (Property, Function|undefined) -> Property
Observable.prototype.filter = function (fn) {
  return filter(this, fn);
};

// (Stream, number) -> Stream
// (Property, number) -> Property
Observable.prototype.take = function (n) {
  return take(this, n);
};

// (Stream, number) -> Stream
// (Property, number) -> Property
Observable.prototype.takeErrors = function (n) {
  return takeErrors(this, n);
};

// (Stream, Function|undefined) -> Stream
// (Property, Function|undefined) -> Property
Observable.prototype.takeWhile = function (fn) {
  return takeWhile(this, fn);
};

// (Stream) -> Stream
// (Property) -> Property
Observable.prototype.last = function () {
  return last(this);
};

// (Stream, number) -> Stream
// (Property, number) -> Property
Observable.prototype.skip = function (n) {
  return skip(this, n);
};

// (Stream, Function|undefined) -> Stream
// (Property, Function|undefined) -> Property
Observable.prototype.skipWhile = function (fn) {
  return skipWhile(this, fn);
};

// (Stream, Function|undefined) -> Stream
// (Property, Function|undefined) -> Property
Observable.prototype.skipDuplicates = function (fn) {
  return skipDuplicates(this, fn);
};

// (Stream, Function|falsey, any|undefined) -> Stream
// (Property, Function|falsey, any|undefined) -> Property
Observable.prototype.diff = function (fn, seed) {
  return diff(this, fn, seed);
};

// (Stream|Property, Function, any|undefined) -> Property
Observable.prototype.scan = function (fn, seed) {
  return scan(this, fn, seed);
};

// (Stream, Function|undefined) -> Stream
// (Property, Function|undefined) -> Property
Observable.prototype.flatten = function (fn) {
  return flatten(this, fn);
};

// (Stream, number) -> Stream
// (Property, number) -> Property
Observable.prototype.delay = function (wait) {
  return delay(this, wait);
};

// Options = {leading: boolean|undefined, trailing: boolean|undefined}
// (Stream, number, Options|undefined) -> Stream
// (Property, number, Options|undefined) -> Property
Observable.prototype.throttle = function (wait, options) {
  return throttle(this, wait, options);
};

// Options = {immediate: boolean|undefined}
// (Stream, number, Options|undefined) -> Stream
// (Property, number, Options|undefined) -> Property
Observable.prototype.debounce = function (wait, options) {
  return debounce(this, wait, options);
};

// (Stream, Function|undefined) -> Stream
// (Property, Function|undefined) -> Property
Observable.prototype.mapErrors = function (fn) {
  return mapErrors(this, fn);
};

// (Stream, Function|undefined) -> Stream
// (Property, Function|undefined) -> Property
Observable.prototype.filterErrors = function (fn) {
  return filterErrors(this, fn);
};

// (Stream) -> Stream
// (Property) -> Property
Observable.prototype.ignoreValues = function () {
  return ignoreValues(this);
};

// (Stream) -> Stream
// (Property) -> Property
Observable.prototype.ignoreErrors = function () {
  return ignoreErrors(this);
};

// (Stream) -> Stream
// (Property) -> Property
Observable.prototype.ignoreEnd = function () {
  return ignoreEnd(this);
};

// (Stream, Function) -> Stream
// (Property, Function) -> Property
Observable.prototype.beforeEnd = function (fn) {
  return beforeEnd(this, fn);
};

// (Stream, number, number|undefined) -> Stream
// (Property, number, number|undefined) -> Property
Observable.prototype.slidingWindow = function (max, min) {
  return slidingWindow(this, max, min);
};

// Options = {flushOnEnd: boolean|undefined}
// (Stream, Function|falsey, Options|undefined) -> Stream
// (Property, Function|falsey, Options|undefined) -> Property
Observable.prototype.bufferWhile = function (fn, options) {
  return bufferWhile(this, fn, options);
};

// (Stream, number) -> Stream
// (Property, number) -> Property
Observable.prototype.bufferWithCount = function (count, options) {
  return bufferWhile$1(this, count, options);
};

// Options = {flushOnEnd: boolean|undefined}
// (Stream, number, number, Options|undefined) -> Stream
// (Property, number, number, Options|undefined) -> Property
Observable.prototype.bufferWithTimeOrCount = function (wait, count, options) {
  return bufferWithTimeOrCount(this, wait, count, options);
};

// (Stream, Function) -> Stream
// (Property, Function) -> Property
Observable.prototype.transduce = function (transducer) {
  return transduce(this, transducer);
};

// (Stream, Function) -> Stream
// (Property, Function) -> Property
Observable.prototype.withHandler = function (fn) {
  return withHandler(this, fn);
};

// (Stream, Stream -> a) -> a
// (Property, Property -> a) -> a
Observable.prototype.thru = function (fn) {
  return fn(this);
};

// Combine observables
// -----------------------------------------------------------------------------

// (Array<Stream|Property>, Function|undefiend) -> Stream
// (Array<Stream|Property>, Array<Stream|Property>, Function|undefiend) -> Stream
Observable.prototype.combine = function (other, combinator) {
  return combine([this, other], combinator);
};

// (Array<Stream|Property>, Function|undefiend) -> Stream
Observable.prototype.zip = function (other, combinator) {
  return zip([this, other], combinator);
};

// (Array<Stream|Property>) -> Stream
Observable.prototype.merge = function (other) {
  return merge([this, other]);
};

// (Array<Stream|Property>) -> Stream
Observable.prototype.concat = function (other) {
  return concat$1([this, other]);
};

// () -> Pool
var pool = function () {
  return new Pool();
};

// (Function) -> Stream
// Options = {concurLim: number|undefined, queueLim: number|undefined, drop: 'old'|'new'|undefiend}
// (Stream|Property, Function|falsey, Options|undefined) -> Stream
Observable.prototype.flatMap = function (fn) {
  return new FlatMap(this, fn).setName(this, 'flatMap');
};
Observable.prototype.flatMapLatest = function (fn) {
  return new FlatMap(this, fn, { concurLim: 1, drop: 'old' }).setName(this, 'flatMapLatest');
};
Observable.prototype.flatMapFirst = function (fn) {
  return new FlatMap(this, fn, { concurLim: 1 }).setName(this, 'flatMapFirst');
};
Observable.prototype.flatMapConcat = function (fn) {
  return new FlatMap(this, fn, { queueLim: -1, concurLim: 1 }).setName(this, 'flatMapConcat');
};
Observable.prototype.flatMapConcurLimit = function (fn, limit) {
  return new FlatMap(this, fn, { queueLim: -1, concurLim: limit }).setName(this, 'flatMapConcurLimit');
};

// (Stream|Property, Function|falsey) -> Stream
Observable.prototype.flatMapErrors = function (fn) {
  return new FlatMapErrors(this, fn).setName(this, 'flatMapErrors');
};

// Combine two observables
// -----------------------------------------------------------------------------

// (Stream, Stream|Property) -> Stream
// (Property, Stream|Property) -> Property
Observable.prototype.filterBy = function (other) {
  return filterBy(this, other);
};

// (Stream, Stream|Property, Function|undefiend) -> Stream
// (Property, Stream|Property, Function|undefiend) -> Property
Observable.prototype.sampledBy = function (other, combinator) {
  return sampledBy(this, other, combinator);
};

// (Stream, Stream|Property) -> Stream
// (Property, Stream|Property) -> Property
Observable.prototype.skipUntilBy = function (other) {
  return skipUntilBy(this, other);
};

// (Stream, Stream|Property) -> Stream
// (Property, Stream|Property) -> Property
Observable.prototype.takeUntilBy = function (other) {
  return takeUntilBy(this, other);
};

// Options = {flushOnEnd: boolean|undefined}
// (Stream, Stream|Property, Options|undefined) -> Stream
// (Property, Stream|Property, Options|undefined) -> Property
Observable.prototype.bufferBy = function (other, options) {
  return bufferBy(this, other, options);
};

// Options = {flushOnEnd: boolean|undefined}
// (Stream, Stream|Property, Options|undefined) -> Stream
// (Property, Stream|Property, Options|undefined) -> Property
Observable.prototype.bufferWhileBy = function (other, options) {
  return bufferWhileBy(this, other, options);
};

// Deprecated
// -----------------------------------------------------------------------------

var DEPRECATION_WARNINGS = true;
function dissableDeprecationWarnings() {
  DEPRECATION_WARNINGS = false;
}

function warn(msg) {
  if (DEPRECATION_WARNINGS && console && typeof console.warn === 'function') {
    var msg2 = '\nHere is an Error object for you containing the call stack:';
    console.warn(msg, msg2, new Error());
  }
}

// (Stream|Property, Stream|Property) -> Property
Observable.prototype.awaiting = function (other) {
  warn('You are using deprecated .awaiting() method, see https://github.com/kefirjs/kefir/issues/145');
  return awaiting(this, other);
};

// (Stream, Function|undefined) -> Stream
// (Property, Function|undefined) -> Property
Observable.prototype.valuesToErrors = function (fn) {
  warn('You are using deprecated .valuesToErrors() method, see https://github.com/kefirjs/kefir/issues/149');
  return valuesToErrors(this, fn);
};

// (Stream, Function|undefined) -> Stream
// (Property, Function|undefined) -> Property
Observable.prototype.errorsToValues = function (fn) {
  warn('You are using deprecated .errorsToValues() method, see https://github.com/kefirjs/kefir/issues/149');
  return errorsToValues(this, fn);
};

// (Stream) -> Stream
// (Property) -> Property
Observable.prototype.endOnError = function () {
  warn('You are using deprecated .endOnError() method, see https://github.com/kefirjs/kefir/issues/150');
  return endOnError(this);
};

// Exports
// --------------------------------------------------------------------------

var Kefir = {
  Observable: Observable,
  Stream: Stream,
  Property: Property,
  never: never,
  later: later,
  interval: interval,
  sequentially: sequentially,
  fromPoll: fromPoll,
  withInterval: withInterval,
  fromCallback: fromCallback,
  fromNodeCallback: fromNodeCallback,
  fromEvents: fromEvents,
  stream: stream,
  constant: constant,
  constantError: constantError,
  fromPromise: fromPromise,
  fromESObservable: fromESObservable,
  combine: combine,
  zip: zip,
  merge: merge,
  concat: concat$1,
  Pool: Pool,
  pool: pool,
  repeat: repeat,
  staticLand: staticLand
};

Kefir.Kefir = Kefir;

exports.dissableDeprecationWarnings = dissableDeprecationWarnings;
exports.Kefir = Kefir;
exports.Observable = Observable;
exports.Stream = Stream;
exports.Property = Property;
exports.never = never;
exports.later = later;
exports.interval = interval;
exports.sequentially = sequentially;
exports.fromPoll = fromPoll;
exports.withInterval = withInterval;
exports.fromCallback = fromCallback;
exports.fromNodeCallback = fromNodeCallback;
exports.fromEvents = fromEvents;
exports.stream = stream;
exports.constant = constant;
exports.constantError = constantError;
exports.fromPromise = fromPromise;
exports.fromESObservable = fromESObservable;
exports.combine = combine;
exports.zip = zip;
exports.merge = merge;
exports.concat = concat$1;
exports.Pool = Pool;
exports.pool = pool;
exports.repeat = repeat;
exports.staticLand = staticLand;
exports['default'] = Kefir;

Object.defineProperty(exports, '__esModule', { value: true });

})));
});

var Kefir = unwrapExports(kefir);

var metaSymbol$2 = canSymbol_1_6_1_canSymbol.for("can.meta");
var onKeyValueSymbol$4 = canSymbol_1_6_1_canSymbol.for("can.onKeyValue");
var offKeyValueSymbol$3 = canSymbol_1_6_1_canSymbol.for("can.offKeyValue");

var keyNames = {
	value: {
		on: "onValue",
		off: "offValue",
		handler: "onValueHandler",
		handlers: "onValueHandlers"
	},
	error: {
		on: "onError",
		off: "offError",
		handler: "onErrorHandler",
		handlers: "onErrorHandlers"
	}
};

function ensureMeta$3(obj) {
	var meta = obj[metaSymbol$2];

	if (!meta) {
		meta = {};
		canReflect_1_16_7_canReflect.setKeyValue(obj, metaSymbol$2, meta);
	}

	return meta;
}

// get the current value from a stream
function getCurrentValue(stream, key) {
	if (stream._currentEvent && stream._currentEvent.type === key) {
		return stream._currentEvent.value;
	} else {
		var names = keyNames[key];
		if (!names) {
			return stream[key];
		}
		var VALUE,
			valueHandler = function(value) {
				VALUE = value;
			};
		stream[names.on](valueHandler);
		stream[names.off](valueHandler);
		return VALUE;
	}
}

// The conditional is needed or the global CanJS build,
// this code should not break if Kefir is not bundled
if (Kefir) {
	Kefir.Observable.prototype._eventSetup = function eventSetup() {
		var stream = this;
		var meta = ensureMeta$3(stream);

		meta.bound = true;

		meta.onValueHandler = function onValueHandler(newValue) {
			var oldValue = meta.value;
			meta.value = newValue;

			// only send events for a change
			if (newValue !== oldValue) {
				map$1.dispatch.call(
					stream,
					{ type: "value" },
					[newValue, oldValue]
				);
			}
		};

		meta.onErrorHandler = function onErrorHandler(error) {
			var prevError = meta.error;
			meta.error = error;

			map$1.dispatch.call(
				stream,
				{ type: "error" },
				[error, prevError]
			);
		};

		stream.onValue(meta.onValueHandler);
		stream.onError(meta.onErrorHandler);
	};

	Kefir.Observable.prototype._eventTeardown = function eventTeardown() {
		var stream = this;
		var meta = ensureMeta$3(stream);

		meta.bound = false;

		stream.offValue(meta.onValueHandler);
		stream.offError(meta.onErrorHandler);
	};

	// Observable is parent of Kefir.Stream
	canReflect_1_16_7_canReflect.assignSymbols(Kefir.Observable.prototype, {
		"can.onKeyValue": function onKeyValue() {
			return map$1[onKeyValueSymbol$4].apply(
				this,
				arguments
			);
		},
		"can.offKeyValue": function() {
			return map$1[offKeyValueSymbol$3].apply(
				this,
				arguments
			);
		},
		"can.getKeyValue": function(key) {
			var stream = this;
			var meta = ensureMeta$3(stream);

			if (!keyNames[key]) {
				return stream[key];
			}

			canObservationRecorder_1_1_2_canObservationRecorder.add(stream, key);

			if (meta.bound) {
				return meta[key];
			} else {
				// we haven't been bound ... see what we can get from the observable
				// using internals for performance ...
				var currentValue = getCurrentValue(stream, key);

				// save current value so we won't through events if we provided a value
				meta[key] = currentValue;

				return currentValue;
			}
		},
		"can.getValueDependencies": function getValueDependencies() {
			var sources;
			var stream = this;

			// streams created by methods like .scan have a single source,
			// stored in stream._source
			if (stream._source != null) {
				sources = [stream._source];

			// ... while methods like .combine have multiple sources
			// stored as an array in stream._sources
			} else if (stream._sources != null) {
				sources = stream._sources;
			}

			if (sources != null) {
				return {
					valueDependencies: new Set(sources)
				};
			}
		}
	});

	Kefir.emitterProperty = function() {
		var emitter;
		var setLastValue = false;
		var lastValue;

		var stream = Kefir.stream(function(EMITTER) {
			emitter = EMITTER;
			if (setLastValue) {
				emitter.value(lastValue);
			}
			return function() {
				emitter = undefined;
			};
		});

		var property = stream.toProperty(function() {
			return lastValue;
		});
		property.emitter = {
			value: function(newValue) {
				if (emitter) {
					return emitter.emit(newValue);
				} else {
					setLastValue = true;
					lastValue = newValue;
				}
			},
			error: function(error) {
				if (emitter) {
					return emitter.error(error);
				} else {
				}
			}
		};
		property.emitter.emit = property.emitter.value;

		canReflect_1_16_7_canReflect.assignSymbols(property, {
			"can.setKeyValue": function setKeyValue(key, value) {
				this.emitter[key](value);
			}
		});

		return property;
	};
}

var canKefir_1_0_2_canKefir = Kefir;

var singleReference$1;

function getKeyName$1(key, extraKey) {
	var keyName = extraKey ? canCid_1_1_2_canCid(key) + ":" + extraKey : canCid_1_1_2_canCid(key);
	return keyName || key;
}

// weak maps are slow
/* if(typeof WeakMap !== "undefined") {
	var globalMap = new WeakMap();
	singleReference = {
		set: function(obj, key, value){
			var localMap = globalMap.get(obj);
			if( !localMap ) {
				globalMap.set(obj, localMap = new WeakMap());
			}
			localMap.set(key, value);
		},
		getAndDelete: function(obj, key){
			return globalMap.get(obj).get(key);
		},
		references: globalMap
	};
} else {*/
	singleReference$1 = {
		// obj is a function ... we need to place `value` on it so we can retreive it
		// we can't use a global map
		set: function(obj, key, value, extraKey){
			// check if it has a single reference map
			obj[getKeyName$1(key, extraKey)] = value;
		},

		getAndDelete: function(obj, key, extraKey){
			var keyName = getKeyName$1(key, extraKey);
			var value = obj[keyName];
			delete obj[keyName];
			return value;
		}
	};
/*}*/

var singleReference_1 = singleReference$1;

var canCompute_4_0_3_protoCompute = createCommonjsModule(function (module, exports) {
// # can/compute/proto_compute (aka can.Compute)
//
// Allows the creation of observablue values. This
// is a prototype based version of [can.compute](compute.html).
//
// can.Computes come in different flavors:
//
// - [Getter / Setter functional computes](#setup-getter-setter-functional-computes).
// - [Property computes](#setup-property-computes).
// - [Setter computes](#setup-setter-computes).
// - [Async computes](#setup-async-computes).
// - [Settings computes](#setup-settings-computes).
// - [Simple value computes](#setup-simple-value-computes).
//
//
// can.Computes have public `.get`, `.set`, `.on`, and `.off` methods that call
// internal methods that are configured differently depending on what flavor of
// compute is being created.  Those methods are:
//
// - `_on(updater)` - Called the first time the compute is bound. This should bind to
//    any source observables.  When any of the source observables have changed, it should call
//    `updater(newVal, oldVal, batchNum)`.
//
// - `_off(updater)` - Called when the compute has no more event handlers.  This should unbind to any source observables.
// - `_get` - Called to get the current value of the compute.
// - `_set` - Called to set the value of the compute.
//
//
//
// Other internal flags and values:
// - `value` - the cached value
// - `_setUpdates` - if calling `_set` will have updated the cached value itself so `_get` does not need to be called.
// - `_canObserve` - if this compute can be observed.
// - `hasDependencies` - if this compute has source observable values.










// ## can.Compute
// Checks the arguments and calls different setup methods.
var Compute = function(getterSetter, context, eventName, bindOnce) {
	var args = [];

	for(var i = 0, arglen = arguments.length; i < arglen; i++) {
		args[i] = arguments[i];
	}

	var contextType = typeof args[1];

	if (typeof args[0] === 'function') {
		// Getter/Setter functional computes.
		// `new can.Compute(function(){ ... })`
		this._setupGetterSetterFn(args[0], args[1], args[2], args[3]);
	} else if (args[1] !== undefined) {
		if (contextType === 'string' || contextType === 'number') {
			// Property computes.
			// `new can.Compute(object, propertyName[, eventName])`
			var isListLike = canReflect_1_16_7_canReflect.isObservableLike(args[0]) && canReflect_1_16_7_canReflect.isListLike(args[0]);
			var isMapLike = canReflect_1_16_7_canReflect.isObservableLike(args[0]) && canReflect_1_16_7_canReflect.isMapLike(args[0]);
			if(isMapLike || isListLike) {
				var map = args[0];
				var propertyName = args[1];
				var mapGetterSetter = function(newValue){
					if(arguments.length) {
						canStacheKey_1_3_2_canStacheKey.set(map,propertyName, newValue);
					} else {
						// forces length to be read
						if(isListLike) {
							canStacheKey_1_3_2_canStacheKey.get(map,"length");
						}
						return canStacheKey_1_3_2_canStacheKey.get(map,""+propertyName);
					}
				};
				this._setupGetterSetterFn(mapGetterSetter, args[1], args[2], args[3]);
			} else {
				this._setupProperty(args[0], args[1], args[2]);
			}

		} else if(contextType === 'function') {
			// Setter computes.
			// `new can.Compute(initialValue, function(newValue){ ... })`
			this._setupSetter(args[0], args[1], args[2]);
		} else {

			if(args[1] && args[1].fn) {
				// Async computes.
				this._setupAsyncCompute(args[0], args[1]);
			} else {
				// Settings computes.
				//`new can.Compute(initialValue, {on, off, get, set})`
				this._setupSettings(args[0], args[1]);
			}

		}
	} else {
		// Simple value computes.
		// `new can.Compute(initialValue)`
		this._setupSimpleValue(args[0]);
	}

	this._args = args;
	this._primaryDepth = 0;

	this.isComputed = true;

};

// ## Helpers

// ## updateOnChange
// A helper to trigger an event when a value changes
var updateOnChange = function(compute, newValue, oldValue, batchNum){

	var valueChanged = newValue !== oldValue && !(newValue !== newValue && oldValue !== oldValue);
	// Only trigger event when value has changed
	if (valueChanged) {
		compute.dispatch({type: "change", batchNum: batchNum}, [
			newValue,
			oldValue
		]);
	}
};

// ### setupComputeHandlers
// A helper that creates an `_on` and `_off` function that
// will bind on source observables and update the value of the compute.
var setupComputeHandlers = function(compute, func, context) {
	var observation = new canObservation_4_0_1_canObservation(func, context, compute);
	var updater = compute.updater.bind(compute);
	//!steal-remove-start
	Object.defineProperty(updater,"name",{
		value: canReflect_1_16_7_canReflect.getName(compute) + ".updater",
	});
	//!steal-remove-end
	compute.observation = observation;
	return {
		// Call `onchanged` when any source observables change.
		_on: function() {
			canReflect_1_16_7_canReflect.onValue( observation, updater,"notify");
			compute.value = observation.value;
		},
		// Unbind `onchanged` from all source observables.
		_off: function() {
			canReflect_1_16_7_canReflect.offValue( observation, updater,"notify");
		},
		getDepth: function() {
			return observation.getDepth();
		}
	};
};
map$1(Compute.prototype);
canAssign_1_1_1_canAssign(Compute.prototype, {
	setPrimaryDepth: function(depth) {
		this._primaryDepth = depth;
	},

	// ## Setup getter / setter functional computes
	// Uses the function as both a getter and setter.
	_setupGetterSetterFn: function(getterSetter, context, eventName) {
		this._set = context ? getterSetter.bind(context) : getterSetter;
		this._get = context ? getterSetter.bind(context) : getterSetter;
		this._canObserve = eventName === false ? false : true;
		// The helper provides the on and off methods that use `getValueAndBind`.
		var handlers = setupComputeHandlers(this, getterSetter, context || this);

		canAssign_1_1_1_canAssign(this, handlers);
	},
	// ## Setup property computes
	// Listen to a property changing on an object.
	_setupProperty: function(target, propertyName, eventName) {
		var self = this,
			handler;


		// This is objects that can be bound to with can.bind.
		handler = function () {
			self.updater(self._get(), self.value);
		};
		this._get = function() {
			return get_1$1(target, propertyName);
		};
		this._set = function(value) {
			// allow setting properties n levels deep, if separated with dot syntax
			var properties = propertyName.split("."),
				leafPropertyName = properties.pop();

			if(properties.length) {
				var targetProperty = get_1$1(target, properties.join('.'));
				targetProperty[leafPropertyName] = value;
			} else {
				target[propertyName] = value;
			}
		};

		this._on = function(update) {
			map$1.on.call(target, eventName || propertyName, handler);
			// Set the cached value
			this.value = this._get();
		};
		this._off = function() {
			return map$1.off.call( target, eventName || propertyName, handler);
		};
	},
	// ## Setup Setter Computes
	// Only a setter function is specified.
	_setupSetter: function(initialValue, setter, eventName) {
		this.value = initialValue;
		this._set = setter;
		canAssign_1_1_1_canAssign(this, eventName);
	},
	// ## Setup settings computes
	// Use whatever `on`, `off`, `get`, `set` the users provided
	// as the internal methods.
	_setupSettings: function(initialValue, settings) {

		this.value = initialValue;

		this._set = settings.set || this._set;
		this._get = settings.get || this._get;

		// This allows updater to be called without any arguments.
		// selfUpdater flag can be set by things that want to call updater themselves.
		if(!settings.__selfUpdater) {
			var self = this,
				oldUpdater = this.updater;
			this.updater = function() {
				oldUpdater.call(self, self._get(), self.value);
			};
		}


		this._on = settings.on ? settings.on : this._on;
		this._off = settings.off ? settings.off : this._off;
	},
	// ## Setup async computes
	// This is a special, non-documented form of a compute
	// rhat can asynchronously update its value.
	_setupAsyncCompute: function(initialValue, settings){
		var self = this;
		// This is the async getter function.  Depending on how many arguments the function takes,
		// we setup bindings differently.
		var getter = settings.fn;
		var bindings;

		this.value = initialValue;

		// This compute will call update with the new value itself.
		this._setUpdates = true;

		// An "async" compute has a `lastSetValue` that represents
		// the last value `compute.set` was called with.
		// The following creates `lastSetValue` as a can.Compute so when
		//  `lastSetValue` is changed, the `getter` can see that change
		// and automatically update itself.
		this.lastSetValue = new Compute(initialValue);

		// Wires up setting this compute to set `lastSetValue`.
		// If the new value matches the last setValue, do nothing.
		this._set = function(newVal){
			if(newVal === self.lastSetValue.get()) {
				return this.value;
			}

			return self.lastSetValue.set(newVal);
		};

		// Wire up the get to pass the lastNewValue
		this._get = function() {
			return getter.call(settings.context, self.lastSetValue.get() );
		};

		if(getter.length === 0) {
			// If it takes no arguments, it should behave just like a Getter compute.
			bindings = setupComputeHandlers(this, getter, settings.context);
		} else if(getter.length === 1) {
			// If it has a single argument, pass it the last setValue.
			bindings = setupComputeHandlers(this, function() {
				return getter.call(settings.context, self.lastSetValue.get() );
			}, settings);

		} else {
			// If the function takes 2 arguments, the second argument is a function
			// that should update the value of the compute (`setValue`). To make this we need
			// the "normal" updater function because we are about to overwrite it.
			var oldUpdater = this.updater,
				resolve = canObservationRecorder_1_1_2_canObservationRecorder.ignore(function(newVal) {
					oldUpdater.call(self, newVal, self.value);
				});

			// Because `setupComputeHandlers` calls `updater` internally with its
			// observation.value as `oldValue` and that might not be up to date,
			// we overwrite updater to always use self.value.
			this.updater = function(newVal) {
				oldUpdater.call(self, newVal, self.value);
			};


			bindings = setupComputeHandlers(this, function() {
				// Call getter, and get new value
				var res = getter.call(settings.context, self.lastSetValue.get(), resolve);
				// If undefined is returned, don't update the value.
				return res !== undefined ? res : this.value;
			}, this);
		}

		canAssign_1_1_1_canAssign(this, bindings);
	},
	// ## Setup simple value computes
	// Uses the default `_get`, `_set` behaviors.
	_setupSimpleValue: function(initialValue) {
		this.value = initialValue;
	},
	// ## _bindsetup
	// When a compute is first bound, call the internal `this._on` method.
	// `can.__notObserve` makes sure if `_on` is listening to any observables,
	// they will not be observed by any outer compute.
	_eventSetup: canObservationRecorder_1_1_2_canObservationRecorder.ignore(function () {
		this.bound = true;
		this._on(this.updater);
	}),
	// ## _bindteardown
	// When a compute has no other bindings, call the internal `this._off` method.
	_eventTeardown: function () {
		this._off(this.updater);
		this.bound = false;
	},

	// ## clone
	// Copies this compute, but for a different context.
	// This is mostly used for computes on a map's prototype.
	clone: function(context) {
		if(context && typeof this._args[0] === 'function') {
			this._args[1] = context;
		} else if(context) {
			this._args[2] = context;
		}

		return new Compute(this._args[0], this._args[1], this._args[2], this._args[3]);
	},
	// ## _on and _off
	// Default _on and _off do nothing.
	_on: function(){},
	_off: function(){},
	// ## get
	// Returns the cached value if `bound`, otherwise, returns
	// the _get value.
	get: function() {
		// If an external compute is tracking observables and
		// this compute can be listened to by "function" based computes ....
		var recordingObservation = canObservationRecorder_1_1_2_canObservationRecorder.isRecording();
		if(recordingObservation && this._canObserve !== false) {

			// ... tell the tracking compute to listen to change on this computed.
			canObservationRecorder_1_1_2_canObservationRecorder.add(this, 'change');
			// ... if we are not bound, we should bind so that
			// we don't have to re-read to get the value of this compute.
			if (!this.bound) {
				Compute.temporarilyBind(this);
			}
		}
		// If computed is bound, use the cached value.
		if (this.bound) {
			// if it has dependencies ... it should do some stuff ...
			if(this.observation) {
				return this.observation.get();
			} else {
				return this.value;
			}
		} else {
			return this._get();
		}
	},
	// ## _get
	// Returns the cached value.
	_get: function() {
		return this.value;
	},
	// ## set
	// Sets the value of the compute.
	// Depending on the type of the compute and what `_set` returns, it might need to call `_get` after
	// `_set` to get the final value.
	set: function(newVal) {

		var old = this.value;

		// Setter may return the value if setter
		// is for a value maintained exclusively by this compute.
		var setVal = this._set(newVal, old);

		// If the setter updated this.value, just return that.
		if(this._setUpdates) {
			return this.value;
		}

		// If the computed function has dependencies,
		// we should call the getter.
		if (this.hasDependencies) {
			return this._get();
		}

		// Setting may not fire a change event, in which case
		// the value must be read
		this.updater(setVal === undefined ? this._get() : setVal, old);

		return this.value;
	},
	// ## _set
	// Updates the cached value.
	_set: function(newVal) {
		return this.value = newVal;
	},
	// ## updater
	// Updates the cached value and fires an event if the value has changed.
	updater: function(newVal, oldVal, batchNum) {
		this.value = newVal;
		if(this.observation) {
			// it's possible the observation doesn't actually
			// have any dependencies
			this.observation.value = newVal;
		}
		updateOnChange(this, newVal, oldVal, batchNum);
	},
	// ## toFunction
	// Returns a proxy form of this compute.
	toFunction: function() {
		return this._computeFn.bind( this);
	},
	_computeFn: function(newVal) {
		if(arguments.length) {
			return this.set(newVal);
		}

		return this.get();
	}
});

Compute.prototype.on = Compute.prototype.bind = Compute.prototype.addEventListener;
Compute.prototype.off = Compute.prototype.unbind = Compute.prototype.removeEventListener;

var hasDependencies = function hasDependencies() {
	return this.observation && this.observation.hasDependencies();
};
Object.defineProperty(Compute.prototype, "hasDependencies", {
	get: hasDependencies
});

// ### temporarilyBind
// Binds computes for a moment to cache their value and prevent re-calculating it.
Compute.temporarilyBind = canObservation_4_0_1_canObservation.temporarilyBind;

// ### async
// A simple helper that makes an async compute a bit easier.
Compute.async = function(initialValue, asyncComputer, context){
	return new Compute(initialValue, {
		fn: asyncComputer,
		context: context
	});
};

// ### truthy
// Wraps a compute with another compute that only changes when
// the wrapped compute's `truthiness` changes.
Compute.truthy = function(compute) {
	return new Compute(function() {
		var res = compute.get();
		if(typeof res === 'function') {
			res = res.get();
		}
		return !!res;
	});
};

canReflect_1_16_7_canReflect.assignSymbols(Compute.prototype, {
	"can.isValueLike": true,
	"can.isMapLike": false,
	"can.isListLike": false,
	"can.setValue": Compute.prototype.set,
	"can.getValue": Compute.prototype.get,
	"can.valueHasDependencies": hasDependencies,
	"can.onValue": function onValue(handler, queue) {
		function translationHandler(ev, newValue, oldValue) {
			handler(newValue, oldValue);
		}
		singleReference_1.set(handler, this, translationHandler);
		//!steal-remove-start
		Object.defineProperty(translationHandler, "name", {
			value: canReflect_1_16_7_canReflect.getName(handler) + "::onValue"
		});
		//!steal-remove-end
		this.addEventListener("change", translationHandler, queue);
	},
	"can.offValue": function offValue(handler, queue) {
		this.removeEventListener(
			"change",
			singleReference_1.getAndDelete(handler, this),
			queue
		);
	},
	"can.getValueDependencies": function getValueDependencies() {
		var ret;

		if (this.observation) {
			ret = {
				valueDependencies: new Set([this.observation])
			};
		}

		return ret;
	}
});

module.exports = exports = Compute;
});

/* jshint maxdepth:7*/

// # can.compute
//
// `can.compute` allows the creation of observable values in different forms.
// This module is now just a facade around [proto_compute.js](proto_compute.html).
// `proto_compute.js` provides `can.Compute` as a constructor function where this file,
// `compute.js` wraps an instance of a `can.Compute` with a function.
//
// Other files:
// - [get_value_and_bind.js](get_value_and_bind.js) provides the low-level utility for observing functions.
// - [read.js](read.html) provides a helper that read properties and values in an observable way.









var canOnValueSymbol = canSymbol_1_6_1_canSymbol.for("can.onValue"),
	canOffValueSymbol = canSymbol_1_6_1_canSymbol.for("can.offValue"),
	canGetValue = canSymbol_1_6_1_canSymbol.for("can.getValue"),
	canSetValue = canSymbol_1_6_1_canSymbol.for("can.setValue"),
	isValueLike$1 = canSymbol_1_6_1_canSymbol.for("can.isValueLike"),
	isMapLike$1 = canSymbol_1_6_1_canSymbol.for("can.isMapLike"),
	isListLike$1 = canSymbol_1_6_1_canSymbol.for("can.isListLike"),
	isFunctionLike$1 = canSymbol_1_6_1_canSymbol.for("can.isFunctionLike"),
	canValueHasDependencies = canSymbol_1_6_1_canSymbol.for("can.valueHasDependencies"),
	canGetValueDependencies = canSymbol_1_6_1_canSymbol.for("can.getValueDependencies");

// The `can.compute` generator function.
var addEventListener = function(ev, handler){
	var compute = this;
	var translationHandler;
	if(handler){
		translationHandler = function() {
		   handler.apply(compute, arguments);
	   };
	   singleReference_1.set(handler, this, translationHandler);
	}
	return compute.computeInstance.addEventListener(ev, translationHandler);
};

var removeEventListener = function(ev, handler){
		var args = [];
		if (typeof ev !== 'undefined') {
			args.push(ev);
			if (typeof handler !== 'undefined') {
				args.push(singleReference_1.getAndDelete(handler, this));
			}
		}
		return this.computeInstance.removeEventListener.apply(this.computeInstance, args);
};
var onValue = function(handler, queue){
		return this.computeInstance[canOnValueSymbol](handler, queue);
	},
	offValue = function(handler, queue){
		return this.computeInstance[canOffValueSymbol](handler, queue);
	},
	getValue$1 = function(){
		return this.computeInstance.get();
	},
	setValue = function(value){
		return this.computeInstance.set(value);
	},
	hasDependencies = function(){
		return this.computeInstance.hasDependencies;
	},
	getDependencies = function() {
		return this.computeInstance[canGetValueDependencies]();
	};


var COMPUTE = function (getterSetter, context, eventName, bindOnce) {

	function compute(val) {
		if(arguments.length) {
			return compute.computeInstance.set(val);
		}

		return compute.computeInstance.get();
	}

	// Create an internal `can.Compute`.
	compute.computeInstance = new canCompute_4_0_3_protoCompute(getterSetter, context, eventName, bindOnce);

	compute.on = compute.bind = compute.addEventListener = addEventListener;
	compute.off = compute.unbind = compute.removeEventListener = removeEventListener;
	compute.isComputed = compute.computeInstance.isComputed;

	compute.clone = function(ctx) {
		if(typeof getterSetter === 'function') {
			context = ctx;
		}
		return COMPUTE(getterSetter, context, ctx, bindOnce);
	};

	// forward on and off to the computeInstance as this doesn't matter
	getSet.set(compute, canOnValueSymbol, onValue);
	getSet.set(compute, canOffValueSymbol, offValue);
	getSet.set(compute, canGetValue, getValue$1);
	getSet.set(compute, canSetValue, setValue);
	getSet.set(compute, isValueLike$1, true);
	getSet.set(compute, isMapLike$1, false);
	getSet.set(compute, isListLike$1, false);
	getSet.set(compute, isFunctionLike$1, false);
	getSet.set(compute, canValueHasDependencies, hasDependencies);
	getSet.set(compute, canGetValueDependencies, getDependencies);
	return compute;
};

// ## Helpers

// ### truthy
// Wraps a compute with another compute that only changes when
// the wrapped compute's `truthiness` changes.
COMPUTE.truthy = function (compute) {
	return COMPUTE(function () {
		var res = compute();
		return !!res;
	});
};

// ### async
// A simple helper that makes an async compute a bit easier.
COMPUTE.async = function(initialValue, asyncComputer, context){
	return COMPUTE(initialValue, {
		fn: asyncComputer,
		context: context
	});
};

// ### compatability
// Setting methods that should not be around in 3.0.
COMPUTE.temporarilyBind = canCompute_4_0_3_protoCompute.temporarilyBind;

var canCompute_4_0_3_canCompute = canNamespace_1_0_0_canNamespace.compute = COMPUTE;

var toComputeFromEvent = function(observable, eventName){
	var handler,
		lastSet;
	return canCompute_4_0_3_canCompute(undefined, {
		on: function(updated) {
			handler = function(ev, val) {
				lastSet = canAssign_1_1_1_canAssign({
					args: [].slice.call(arguments, 1)
				}, ev);
				updated();
			};
			observable.on(eventName, handler);
		},
		off: function(updated) {
			observable.off(eventName, handler);
			lastSet = undefined;
		},
		get: function(){
			return lastSet;
		}
	});
};


var STREAM = function(canStreamInterface) {

	var canStream;

	var toStreamFromProperty = function(obs, propName) {
		return canStreamInterface.toStream(canCompute_4_0_3_canCompute(obs, propName));
	};

	var toStreamFromEvent = function() {
		var obs = arguments[0];
		var eventName, propName, lastValue, internalCompute;


		if(arguments.length === 2) {
			//.toStreamFromEvent(obs, event);

			internalCompute = toComputeFromEvent(obs,  arguments[1]);

			return canStreamInterface.toStream(internalCompute);
		} else {
			//.toStreamFromEvent(obs, propName, event);
			propName = arguments[1];
			eventName = arguments[2];
			lastValue = obs[propName];

			var valuePropCompute = canCompute_4_0_3_canCompute(obs, propName);

			var eventHandler;
			var propChangeHandler;

			internalCompute = canCompute_4_0_3_canCompute(undefined,{
				on: function(updater){
					eventHandler = function(ev, newVal, oldVal) {
						lastValue = newVal;
						updater(lastValue);
					};

					propChangeHandler = function(ev, newVal, oldVal) {
						oldVal.off(eventName, eventHandler);
						newVal.on(eventName, eventHandler);
					};

					valuePropCompute.on('change', propChangeHandler);

					valuePropCompute().on(eventName, eventHandler);
				},
				off: function(){
					valuePropCompute().off(eventName, eventHandler);
					valuePropCompute.off('change', propChangeHandler);
				},
				get: function(){
					return lastValue;
				},
				set: function(val){
					throw new Error("can-stream: you can't set this type of compute");
				}
			});

			var stream = canStreamInterface.toStream(internalCompute);

			return stream;
		}
	};

	//.toStream(observable, propAndOrEvent[,event])
	var toStream = function() {

		if(arguments.length === 1) {
			//we expect it to be a compute:
			return canStreamInterface.toStream(arguments[0]); //toStream(compute)
		}
		else if(arguments.length > 1) {
			var obs = arguments[0];
			var eventNameOrPropName = arguments[1].trim();

			if(eventNameOrPropName.indexOf(" ") === -1) {
				//no space found (so addressing the first three)
				if(eventNameOrPropName.indexOf(".") === 0) {
					//starts with a dot
					return canStream.toStreamFromProperty(obs, eventNameOrPropName.slice(1)); //toStream(obj, "tasks")
				}
				else {
					return canStream.toStreamFromEvent(obs, eventNameOrPropName); //toStream( obj, "close")
				}
			}
			else {
				var splitEventNameAndProperty = eventNameOrPropName.split(" ");
				return canStream.toStreamFromEvent(obs, splitEventNameAndProperty[0].slice(1), splitEventNameAndProperty[1]);  //toStream(obj, "tasks add")
			}
		}
		return undefined;
	};

	var toCompute = function(makeStream, context) {
		var args = canReflect_1_16_7_canReflect.toArray(arguments);
		return canStreamInterface.toCompute.apply(this, args);
	};

	canStream = toStream;
	canStream.toStream = canStream;
	canStream.toStreamFromProperty = toStreamFromProperty;
	canStream.toStreamFromEvent = toStreamFromEvent;
	canStream.toCompute = toCompute;

	return canStream;
};
STREAM.toComputeFromEvent = toComputeFromEvent;

var canStream_1_0_1_canStream = canNamespace_1_0_0_canNamespace.stream = STREAM;

var canStreamKefir_1_0_1_canStreamKefir = createCommonjsModule(function (module) {
var getValueDependenciesSymbol = canSymbol_1_6_1_canSymbol.for('can.getValueDependencies');
var getKeyDependenciesSymbol = canSymbol_1_6_1_canSymbol.for('can.getKeyDependencies');

var canStreamKefir = {};

/*
 * Converts all arguments passed into a single stream and resolves the resulting
 * streams into a single stream. Assumes all arguments are computes and last
 * argument is optionally a function.
 */
canStreamKefir.toStream = function (compute) {
	var stream = canKefir_1_0_2_canKefir.stream(function (emitter) {
		var changeHandler = function (ev, newVal) {
			emitter.emit(newVal);
		};

		compute.on('change', changeHandler);

		var currentValue = compute();
		if(currentValue !== undefined) {
			emitter.emit(currentValue);
		}

		return function () {
			compute.off('change', changeHandler);
		};
	});

	stream[getValueDependenciesSymbol] = function getValueDependencies() {
		return {
			valueDependencies: new Set([compute])
		};
	};

	return stream;
};

canStreamKefir.toCompute = function(makeStream, context){
	var emitter,
		lastValue,
		streamHandler,
		lastSetValue;

	var setterStream = canKefir_1_0_2_canKefir.stream(function (e) {
		emitter = e;
		if (lastSetValue !== undefined) {
			emitter.emit(lastSetValue);
		}
	});
	var valueStream = makeStream.call(context, setterStream);

	// Create a compute that will bind to the resolved stream when bound
	var streamCompute = canCompute_4_0_3_canCompute(undefined, {
		// When the compute is read, use that last value
		get: function () {
			return lastValue;
		},
		set: function (val) {
			if(emitter) {
				emitter.emit(val);
			} else {
				lastSetValue = val;
			}
			return val;
		},

		// When the compute is bound, bind to the resolved stream
		on: function (updated) {

			// When the stream passes a new values, save a reference to it and call
			// the compute's internal `updated` method (which ultimately calls `get`)
			streamHandler = function (val) {
				lastValue = val;
				updated();
			};
			valueStream.onValue(streamHandler);
		},

		// When the compute is unbound, unbind from the resolved stream
		off: function () {
			valueStream.offValue(streamHandler);
		}
	});

	// the symbol should ideally be implemented in the compute wrapper instead of
	// the internal instance, this should be fixed once can-compute is removed
	var _compute = streamCompute.computeInstance;
	_compute[getKeyDependenciesSymbol] = function getKeyDependencies(key) {
		if (key === 'change') {
			return {
				valueDependencies: new Set([valueStream])
			};
		}
	};

	return streamCompute;
};

if (!canNamespace_1_0_0_canNamespace.streamKefir) {
	/*
	 * Exposes a simple toStream method that takes an observable and event or propname and returns a Kefir stream object
	 */
	module.exports = canNamespace_1_0_0_canNamespace.streamKefir = canStream_1_0_1_canStream(canStreamKefir);
}
});

var canDefineStreamKefir_1_0_0_canDefineStreamKefir = canNamespace_1_0_0_canNamespace.defineStreamKefir = canDefineStream_1_0_1_canDefineStream(canStreamKefir_1_0_1_canStreamKefir);

var validate_js_0_11_1_validate = createCommonjsModule(function (module, exports) {
/*!
 * validate.js 0.11.1
 *
 * (c) 2013-2016 Nicklas Ansman, 2013 Wrapp
 * Validate.js may be freely distributed under the MIT license.
 * For all details and documentation:
 * http://validatejs.org/
 */

(function(exports, module, define) {

  // The main function that calls the validators specified by the constraints.
  // The options are the following:
  //   - format (string) - An option that controls how the returned value is formatted
  //     * flat - Returns a flat array of just the error messages
  //     * grouped - Returns the messages grouped by attribute (default)
  //     * detailed - Returns an array of the raw validation data
  //   - fullMessages (boolean) - If `true` (default) the attribute name is prepended to the error.
  //
  // Please note that the options are also passed to each validator.
  var validate = function(attributes, constraints, options) {
    options = v.extend({}, v.options, options);

    var results = v.runValidations(attributes, constraints, options)
      , attr
      , validator;

    for (attr in results) {
      for (validator in results[attr]) {
        if (v.isPromise(results[attr][validator])) {
          throw new Error("Use validate.async if you want support for promises");
        }
      }
    }
    return validate.processValidationResults(results, options);
  };

  var v = validate;

  // Copies over attributes from one or more sources to a single destination.
  // Very much similar to underscore's extend.
  // The first argument is the target object and the remaining arguments will be
  // used as sources.
  v.extend = function(obj) {
    [].slice.call(arguments, 1).forEach(function(source) {
      for (var attr in source) {
        obj[attr] = source[attr];
      }
    });
    return obj;
  };

  v.extend(validate, {
    // This is the version of the library as a semver.
    // The toString function will allow it to be coerced into a string
    version: {
      major: 0,
      minor: 11,
      patch: 1,
      metadata: null,
      toString: function() {
        var version = v.format("%{major}.%{minor}.%{patch}", v.version);
        if (!v.isEmpty(v.version.metadata)) {
          version += "+" + v.version.metadata;
        }
        return version;
      }
    },

    // Below is the dependencies that are used in validate.js

    // The constructor of the Promise implementation.
    // If you are using Q.js, RSVP or any other A+ compatible implementation
    // override this attribute to be the constructor of that promise.
    // Since jQuery promises aren't A+ compatible they won't work.
    Promise: typeof Promise !== "undefined" ? Promise : /* istanbul ignore next */ null,

    EMPTY_STRING_REGEXP: /^\s*$/,

    // Runs the validators specified by the constraints object.
    // Will return an array of the format:
    //     [{attribute: "<attribute name>", error: "<validation result>"}, ...]
    runValidations: function(attributes, constraints, options) {
      var results = []
        , attr
        , validatorName
        , value
        , validators
        , validator
        , validatorOptions
        , error;

      if (v.isDomElement(attributes) || v.isJqueryElement(attributes)) {
        attributes = v.collectFormValues(attributes);
      }

      // Loops through each constraints, finds the correct validator and run it.
      for (attr in constraints) {
        value = v.getDeepObjectValue(attributes, attr);
        // This allows the constraints for an attribute to be a function.
        // The function will be called with the value, attribute name, the complete dict of
        // attributes as well as the options and constraints passed in.
        // This is useful when you want to have different
        // validations depending on the attribute value.
        validators = v.result(constraints[attr], value, attributes, attr, options, constraints);

        for (validatorName in validators) {
          validator = v.validators[validatorName];

          if (!validator) {
            error = v.format("Unknown validator %{name}", {name: validatorName});
            throw new Error(error);
          }

          validatorOptions = validators[validatorName];
          // This allows the options to be a function. The function will be
          // called with the value, attribute name, the complete dict of
          // attributes as well as the options and constraints passed in.
          // This is useful when you want to have different
          // validations depending on the attribute value.
          validatorOptions = v.result(validatorOptions, value, attributes, attr, options, constraints);
          if (!validatorOptions) {
            continue;
          }
          results.push({
            attribute: attr,
            value: value,
            validator: validatorName,
            globalOptions: options,
            attributes: attributes,
            options: validatorOptions,
            error: validator.call(validator,
                value,
                validatorOptions,
                attr,
                attributes,
                options)
          });
        }
      }

      return results;
    },

    // Takes the output from runValidations and converts it to the correct
    // output format.
    processValidationResults: function(errors, options) {
      errors = v.pruneEmptyErrors(errors, options);
      errors = v.expandMultipleErrors(errors, options);
      errors = v.convertErrorMessages(errors, options);

      var format = options.format || "grouped";

      if (typeof v.formatters[format] === 'function') {
        errors = v.formatters[format](errors);
      } else {
        throw new Error(v.format("Unknown format %{format}", options));
      }

      return v.isEmpty(errors) ? undefined : errors;
    },

    // Runs the validations with support for promises.
    // This function will return a promise that is settled when all the
    // validation promises have been completed.
    // It can be called even if no validations returned a promise.
    async: function(attributes, constraints, options) {
      options = v.extend({}, v.async.options, options);

      var WrapErrors = options.wrapErrors || function(errors) {
        return errors;
      };

      // Removes unknown attributes
      if (options.cleanAttributes !== false) {
        attributes = v.cleanAttributes(attributes, constraints);
      }

      var results = v.runValidations(attributes, constraints, options);

      return new v.Promise(function(resolve, reject) {
        v.waitForResults(results).then(function() {
          var errors = v.processValidationResults(results, options);
          if (errors) {
            reject(new WrapErrors(errors, options, attributes, constraints));
          } else {
            resolve(attributes);
          }
        }, function(err) {
          reject(err);
        });
      });
    },

    single: function(value, constraints, options) {
      options = v.extend({}, v.single.options, options, {
        format: "flat",
        fullMessages: false
      });
      return v({single: value}, {single: constraints}, options);
    },

    // Returns a promise that is resolved when all promises in the results array
    // are settled. The promise returned from this function is always resolved,
    // never rejected.
    // This function modifies the input argument, it replaces the promises
    // with the value returned from the promise.
    waitForResults: function(results) {
      // Create a sequence of all the results starting with a resolved promise.
      return results.reduce(function(memo, result) {
        // If this result isn't a promise skip it in the sequence.
        if (!v.isPromise(result.error)) {
          return memo;
        }

        return memo.then(function() {
          return result.error.then(function(error) {
            result.error = error || null;
          });
        });
      }, new v.Promise(function(r) { r(); })); // A resolved promise
    },

    // If the given argument is a call: function the and: function return the value
    // otherwise just return the value. Additional arguments will be passed as
    // arguments to the function.
    // Example:
    // ```
    // result('foo') // 'foo'
    // result(Math.max, 1, 2) // 2
    // ```
    result: function(value) {
      var args = [].slice.call(arguments, 1);
      if (typeof value === 'function') {
        value = value.apply(null, args);
      }
      return value;
    },

    // Checks if the value is a number. This function does not consider NaN a
    // number like many other `isNumber` functions do.
    isNumber: function(value) {
      return typeof value === 'number' && !isNaN(value);
    },

    // Returns false if the object is not a function
    isFunction: function(value) {
      return typeof value === 'function';
    },

    // A simple check to verify that the value is an integer. Uses `isNumber`
    // and a simple modulo check.
    isInteger: function(value) {
      return v.isNumber(value) && value % 1 === 0;
    },

    // Checks if the value is a boolean
    isBoolean: function(value) {
      return typeof value === 'boolean';
    },

    // Uses the `Object` function to check if the given argument is an object.
    isObject: function(obj) {
      return obj === Object(obj);
    },

    // Simply checks if the object is an instance of a date
    isDate: function(obj) {
      return obj instanceof Date;
    },

    // Returns false if the object is `null` of `undefined`
    isDefined: function(obj) {
      return obj !== null && obj !== undefined;
    },

    // Checks if the given argument is a promise. Anything with a `then`
    // function is considered a promise.
    isPromise: function(p) {
      return !!p && v.isFunction(p.then);
    },

    isJqueryElement: function(o) {
      return o && v.isString(o.jquery);
    },

    isDomElement: function(o) {
      if (!o) {
        return false;
      }

      if (!o.querySelectorAll || !o.querySelector) {
        return false;
      }

      if (v.isObject(document) && o === document) {
        return true;
      }

      // http://stackoverflow.com/a/384380/699304
      /* istanbul ignore else */
      if (typeof HTMLElement === "object") {
        return o instanceof HTMLElement;
      } else {
        return o &&
          typeof o === "object" &&
          o !== null &&
          o.nodeType === 1 &&
          typeof o.nodeName === "string";
      }
    },

    isEmpty: function(value) {
      var attr;

      // Null and undefined are empty
      if (!v.isDefined(value)) {
        return true;
      }

      // functions are non empty
      if (v.isFunction(value)) {
        return false;
      }

      // Whitespace only strings are empty
      if (v.isString(value)) {
        return v.EMPTY_STRING_REGEXP.test(value);
      }

      // For arrays we use the length property
      if (v.isArray(value)) {
        return value.length === 0;
      }

      // Dates have no attributes but aren't empty
      if (v.isDate(value)) {
        return false;
      }

      // If we find at least one property we consider it non empty
      if (v.isObject(value)) {
        for (attr in value) {
          return false;
        }
        return true;
      }

      return false;
    },

    // Formats the specified strings with the given values like so:
    // ```
    // format("Foo: %{foo}", {foo: "bar"}) // "Foo bar"
    // ```
    // If you want to write %{...} without having it replaced simply
    // prefix it with % like this `Foo: %%{foo}` and it will be returned
    // as `"Foo: %{foo}"`
    format: v.extend(function(str, vals) {
      if (!v.isString(str)) {
        return str;
      }
      return str.replace(v.format.FORMAT_REGEXP, function(m0, m1, m2) {
        if (m1 === '%') {
          return "%{" + m2 + "}";
        } else {
          return String(vals[m2]);
        }
      });
    }, {
      // Finds %{key} style patterns in the given string
      FORMAT_REGEXP: /(%?)%\{([^\}]+)\}/g
    }),

    // "Prettifies" the given string.
    // Prettifying means replacing [.\_-] with spaces as well as splitting
    // camel case words.
    prettify: function(str) {
      if (v.isNumber(str)) {
        // If there are more than 2 decimals round it to two
        if ((str * 100) % 1 === 0) {
          return "" + str;
        } else {
          return parseFloat(Math.round(str * 100) / 100).toFixed(2);
        }
      }

      if (v.isArray(str)) {
        return str.map(function(s) { return v.prettify(s); }).join(", ");
      }

      if (v.isObject(str)) {
        return str.toString();
      }

      // Ensure the string is actually a string
      str = "" + str;

      return str
        // Splits keys separated by periods
        .replace(/([^\s])\.([^\s])/g, '$1 $2')
        // Removes backslashes
        .replace(/\\+/g, '')
        // Replaces - and - with space
        .replace(/[_-]/g, ' ')
        // Splits camel cased words
        .replace(/([a-z])([A-Z])/g, function(m0, m1, m2) {
          return "" + m1 + " " + m2.toLowerCase();
        })
        .toLowerCase();
    },

    stringifyValue: function(value) {
      return v.prettify(value);
    },

    isString: function(value) {
      return typeof value === 'string';
    },

    isArray: function(value) {
      return {}.toString.call(value) === '[object Array]';
    },

    // Checks if the object is a hash, which is equivalent to an object that
    // is neither an array nor a function.
    isHash: function(value) {
      return v.isObject(value) && !v.isArray(value) && !v.isFunction(value);
    },

    contains: function(obj, value) {
      if (!v.isDefined(obj)) {
        return false;
      }
      if (v.isArray(obj)) {
        return obj.indexOf(value) !== -1;
      }
      return value in obj;
    },

    unique: function(array) {
      if (!v.isArray(array)) {
        return array;
      }
      return array.filter(function(el, index, array) {
        return array.indexOf(el) == index;
      });
    },

    forEachKeyInKeypath: function(object, keypath, callback) {
      if (!v.isString(keypath)) {
        return undefined;
      }

      var key = ""
        , i
        , escape = false;

      for (i = 0; i < keypath.length; ++i) {
        switch (keypath[i]) {
          case '.':
            if (escape) {
              escape = false;
              key += '.';
            } else {
              object = callback(object, key, false);
              key = "";
            }
            break;

          case '\\':
            if (escape) {
              escape = false;
              key += '\\';
            } else {
              escape = true;
            }
            break;

          default:
            escape = false;
            key += keypath[i];
            break;
        }
      }

      return callback(object, key, true);
    },

    getDeepObjectValue: function(obj, keypath) {
      if (!v.isObject(obj)) {
        return undefined;
      }

      return v.forEachKeyInKeypath(obj, keypath, function(obj, key) {
        if (v.isObject(obj)) {
          return obj[key];
        }
      });
    },

    // This returns an object with all the values of the form.
    // It uses the input name as key and the value as value
    // So for example this:
    // <input type="text" name="email" value="foo@bar.com" />
    // would return:
    // {email: "foo@bar.com"}
    collectFormValues: function(form, options) {
      var values = {}
        , i
        , j
        , input
        , inputs
        , option
        , value;

      if (v.isJqueryElement(form)) {
        form = form[0];
      }

      if (!form) {
        return values;
      }

      options = options || {};

      inputs = form.querySelectorAll("input[name], textarea[name]");
      for (i = 0; i < inputs.length; ++i) {
        input = inputs.item(i);

        if (v.isDefined(input.getAttribute("data-ignored"))) {
          continue;
        }

        value = v.sanitizeFormValue(input.value, options);
        if (input.type === "number") {
          value = value ? +value : null;
        } else if (input.type === "checkbox") {
          if (input.attributes.value) {
            if (!input.checked) {
              value = values[input.name] || null;
            }
          } else {
            value = input.checked;
          }
        } else if (input.type === "radio") {
          if (!input.checked) {
            value = values[input.name] || null;
          }
        }
        values[input.name] = value;
      }

      inputs = form.querySelectorAll("select[name]");
      for (i = 0; i < inputs.length; ++i) {
        input = inputs.item(i);
        if (input.multiple) {
          value = [];
          for (j in input.options) {
            option = input.options[j];
            if (option.selected) {
              value.push(v.sanitizeFormValue(option.value, options));
            }
          }
        } else {
          value = v.sanitizeFormValue(input.options[input.selectedIndex].value, options);
        }
        values[input.name] = value;
      }

      return values;
    },

    sanitizeFormValue: function(value, options) {
      if (options.trim && v.isString(value)) {
        value = value.trim();
      }

      if (options.nullify !== false && value === "") {
        return null;
      }
      return value;
    },

    capitalize: function(str) {
      if (!v.isString(str)) {
        return str;
      }
      return str[0].toUpperCase() + str.slice(1);
    },

    // Remove all errors who's error attribute is empty (null or undefined)
    pruneEmptyErrors: function(errors) {
      return errors.filter(function(error) {
        return !v.isEmpty(error.error);
      });
    },

    // In
    // [{error: ["err1", "err2"], ...}]
    // Out
    // [{error: "err1", ...}, {error: "err2", ...}]
    //
    // All attributes in an error with multiple messages are duplicated
    // when expanding the errors.
    expandMultipleErrors: function(errors) {
      var ret = [];
      errors.forEach(function(error) {
        // Removes errors without a message
        if (v.isArray(error.error)) {
          error.error.forEach(function(msg) {
            ret.push(v.extend({}, error, {error: msg}));
          });
        } else {
          ret.push(error);
        }
      });
      return ret;
    },

    // Converts the error mesages by prepending the attribute name unless the
    // message is prefixed by ^
    convertErrorMessages: function(errors, options) {
      options = options || {};

      var ret = [];
      errors.forEach(function(errorInfo) {
        var error = v.result(errorInfo.error,
            errorInfo.value,
            errorInfo.attribute,
            errorInfo.options,
            errorInfo.attributes,
            errorInfo.globalOptions);

        if (!v.isString(error)) {
          ret.push(errorInfo);
          return;
        }

        if (error[0] === '^') {
          error = error.slice(1);
        } else if (options.fullMessages !== false) {
          error = v.capitalize(v.prettify(errorInfo.attribute)) + " " + error;
        }
        error = error.replace(/\\\^/g, "^");
        error = v.format(error, {value: v.stringifyValue(errorInfo.value)});
        ret.push(v.extend({}, errorInfo, {error: error}));
      });
      return ret;
    },

    // In:
    // [{attribute: "<attributeName>", ...}]
    // Out:
    // {"<attributeName>": [{attribute: "<attributeName>", ...}]}
    groupErrorsByAttribute: function(errors) {
      var ret = {};
      errors.forEach(function(error) {
        var list = ret[error.attribute];
        if (list) {
          list.push(error);
        } else {
          ret[error.attribute] = [error];
        }
      });
      return ret;
    },

    // In:
    // [{error: "<message 1>", ...}, {error: "<message 2>", ...}]
    // Out:
    // ["<message 1>", "<message 2>"]
    flattenErrorsToArray: function(errors) {
      return errors
        .map(function(error) { return error.error; })
        .filter(function(value, index, self) {
          return self.indexOf(value) === index;
        });
    },

    cleanAttributes: function(attributes, whitelist) {
      function whitelistCreator(obj, key, last) {
        if (v.isObject(obj[key])) {
          return obj[key];
        }
        return (obj[key] = last ? true : {});
      }

      function buildObjectWhitelist(whitelist) {
        var ow = {}
          , attr;
        for (attr in whitelist) {
          if (!whitelist[attr]) {
            continue;
          }
          v.forEachKeyInKeypath(ow, attr, whitelistCreator);
        }
        return ow;
      }

      function cleanRecursive(attributes, whitelist) {
        if (!v.isObject(attributes)) {
          return attributes;
        }

        var ret = v.extend({}, attributes)
          , w
          , attribute;

        for (attribute in attributes) {
          w = whitelist[attribute];

          if (v.isObject(w)) {
            ret[attribute] = cleanRecursive(ret[attribute], w);
          } else if (!w) {
            delete ret[attribute];
          }
        }
        return ret;
      }

      if (!v.isObject(whitelist) || !v.isObject(attributes)) {
        return {};
      }

      whitelist = buildObjectWhitelist(whitelist);
      return cleanRecursive(attributes, whitelist);
    },

    exposeModule: function(validate, root, exports, module, define) {
      if (exports) {
        if (module && module.exports) {
          exports = module.exports = validate;
        }
        exports.validate = validate;
      } else {
        root.validate = validate;
        if (validate.isFunction(define) && define.amd) {
          define([], function () { return validate; });
        }
      }
    },

    warn: function(msg) {
      if (typeof console !== "undefined" && console.warn) {
        console.warn("[validate.js] " + msg);
      }
    },

    error: function(msg) {
      if (typeof console !== "undefined" && console.error) {
        console.error("[validate.js] " + msg);
      }
    }
  });

  validate.validators = {
    // Presence validates that the value isn't empty
    presence: function(value, options) {
      options = v.extend({}, this.options, options);
      if (options.allowEmpty ? !v.isDefined(value) : v.isEmpty(value)) {
        return options.message || this.message || "can't be blank";
      }
    },
    length: function(value, options, attribute) {
      // Empty values are allowed
      if (!v.isDefined(value)) {
        return;
      }

      options = v.extend({}, this.options, options);

      var is = options.is
        , maximum = options.maximum
        , minimum = options.minimum
        , tokenizer = options.tokenizer || function(val) { return val; }
        , err
        , errors = [];

      value = tokenizer(value);
      var length = value.length;
      if(!v.isNumber(length)) {
        v.error(v.format("Attribute %{attr} has a non numeric value for `length`", {attr: attribute}));
        return options.message || this.notValid || "has an incorrect length";
      }

      // Is checks
      if (v.isNumber(is) && length !== is) {
        err = options.wrongLength ||
          this.wrongLength ||
          "is the wrong length (should be %{count} characters)";
        errors.push(v.format(err, {count: is}));
      }

      if (v.isNumber(minimum) && length < minimum) {
        err = options.tooShort ||
          this.tooShort ||
          "is too short (minimum is %{count} characters)";
        errors.push(v.format(err, {count: minimum}));
      }

      if (v.isNumber(maximum) && length > maximum) {
        err = options.tooLong ||
          this.tooLong ||
          "is too long (maximum is %{count} characters)";
        errors.push(v.format(err, {count: maximum}));
      }

      if (errors.length > 0) {
        return options.message || errors;
      }
    },
    numericality: function(value, options) {
      // Empty values are fine
      if (!v.isDefined(value)) {
        return;
      }

      options = v.extend({}, this.options, options);

      var errors = []
        , name
        , count
        , checks = {
            greaterThan:          function(v, c) { return v > c; },
            greaterThanOrEqualTo: function(v, c) { return v >= c; },
            equalTo:              function(v, c) { return v === c; },
            lessThan:             function(v, c) { return v < c; },
            lessThanOrEqualTo:    function(v, c) { return v <= c; },
            divisibleBy:          function(v, c) { return v % c === 0; }
          };

      // Strict will check that it is a valid looking number
      if (v.isString(value) && options.strict) {
        var pattern = "^(0|[1-9]\\d*)";
        if (!options.onlyInteger) {
          pattern += "(\\.\\d+)?";
        }
        pattern += "$";

        if (!(new RegExp(pattern).test(value))) {
          return options.message ||
            options.notValid ||
            this.notValid ||
            this.message ||
            "must be a valid number";
        }
      }

      // Coerce the value to a number unless we're being strict.
      if (options.noStrings !== true && v.isString(value) && !v.isEmpty(value)) {
        value = +value;
      }

      // If it's not a number we shouldn't continue since it will compare it.
      if (!v.isNumber(value)) {
        return options.message ||
          options.notValid ||
          this.notValid ||
          this.message ||
          "is not a number";
      }

      // Same logic as above, sort of. Don't bother with comparisons if this
      // doesn't pass.
      if (options.onlyInteger && !v.isInteger(value)) {
        return options.message ||
          options.notInteger ||
          this.notInteger ||
          this.message ||
          "must be an integer";
      }

      for (name in checks) {
        count = options[name];
        if (v.isNumber(count) && !checks[name](value, count)) {
          // This picks the default message if specified
          // For example the greaterThan check uses the message from
          // this.notGreaterThan so we capitalize the name and prepend "not"
          var key = "not" + v.capitalize(name);
          var msg = options[key] ||
            this[key] ||
            this.message ||
            "must be %{type} %{count}";

          errors.push(v.format(msg, {
            count: count,
            type: v.prettify(name)
          }));
        }
      }

      if (options.odd && value % 2 !== 1) {
        errors.push(options.notOdd ||
            this.notOdd ||
            this.message ||
            "must be odd");
      }
      if (options.even && value % 2 !== 0) {
        errors.push(options.notEven ||
            this.notEven ||
            this.message ||
            "must be even");
      }

      if (errors.length) {
        return options.message || errors;
      }
    },
    datetime: v.extend(function(value, options) {
      if (!v.isFunction(this.parse) || !v.isFunction(this.format)) {
        throw new Error("Both the parse and format functions needs to be set to use the datetime/date validator");
      }

      // Empty values are fine
      if (!v.isDefined(value)) {
        return;
      }

      options = v.extend({}, this.options, options);

      var err
        , errors = []
        , earliest = options.earliest ? this.parse(options.earliest, options) : NaN
        , latest = options.latest ? this.parse(options.latest, options) : NaN;

      value = this.parse(value, options);

      // 86400000 is the number of seconds in a day, this is used to remove
      // the time from the date
      if (isNaN(value) || options.dateOnly && value % 86400000 !== 0) {
        err = options.notValid ||
          options.message ||
          this.notValid ||
          "must be a valid date";
        return v.format(err, {value: arguments[0]});
      }

      if (!isNaN(earliest) && value < earliest) {
        err = options.tooEarly ||
          options.message ||
          this.tooEarly ||
          "must be no earlier than %{date}";
        err = v.format(err, {
          value: this.format(value, options),
          date: this.format(earliest, options)
        });
        errors.push(err);
      }

      if (!isNaN(latest) && value > latest) {
        err = options.tooLate ||
          options.message ||
          this.tooLate ||
          "must be no later than %{date}";
        err = v.format(err, {
          date: this.format(latest, options),
          value: this.format(value, options)
        });
        errors.push(err);
      }

      if (errors.length) {
        return v.unique(errors);
      }
    }, {
      parse: null,
      format: null
    }),
    date: function(value, options) {
      options = v.extend({}, options, {dateOnly: true});
      return v.validators.datetime.call(v.validators.datetime, value, options);
    },
    format: function(value, options) {
      if (v.isString(options) || (options instanceof RegExp)) {
        options = {pattern: options};
      }

      options = v.extend({}, this.options, options);

      var message = options.message || this.message || "is invalid"
        , pattern = options.pattern
        , match;

      // Empty values are allowed
      if (!v.isDefined(value)) {
        return;
      }
      if (!v.isString(value)) {
        return message;
      }

      if (v.isString(pattern)) {
        pattern = new RegExp(options.pattern, options.flags);
      }
      match = pattern.exec(value);
      if (!match || match[0].length != value.length) {
        return message;
      }
    },
    inclusion: function(value, options) {
      // Empty values are fine
      if (!v.isDefined(value)) {
        return;
      }
      if (v.isArray(options)) {
        options = {within: options};
      }
      options = v.extend({}, this.options, options);
      if (v.contains(options.within, value)) {
        return;
      }
      var message = options.message ||
        this.message ||
        "^%{value} is not included in the list";
      return v.format(message, {value: value});
    },
    exclusion: function(value, options) {
      // Empty values are fine
      if (!v.isDefined(value)) {
        return;
      }
      if (v.isArray(options)) {
        options = {within: options};
      }
      options = v.extend({}, this.options, options);
      if (!v.contains(options.within, value)) {
        return;
      }
      var message = options.message || this.message || "^%{value} is restricted";
      return v.format(message, {value: value});
    },
    email: v.extend(function(value, options) {
      options = v.extend({}, this.options, options);
      var message = options.message || this.message || "is not a valid email";
      // Empty values are fine
      if (!v.isDefined(value)) {
        return;
      }
      if (!v.isString(value)) {
        return message;
      }
      if (!this.PATTERN.exec(value)) {
        return message;
      }
    }, {
      PATTERN: /^[a-z0-9\u007F-\uffff!#$%&'*+\/=?^_`{|}~-]+(?:\.[a-z0-9\u007F-\uffff!#$%&'*+\/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z]{2,}$/i
    }),
    equality: function(value, options, attribute, attributes) {
      if (!v.isDefined(value)) {
        return;
      }

      if (v.isString(options)) {
        options = {attribute: options};
      }
      options = v.extend({}, this.options, options);
      var message = options.message ||
        this.message ||
        "is not equal to %{attribute}";

      if (v.isEmpty(options.attribute) || !v.isString(options.attribute)) {
        throw new Error("The attribute must be a non empty string");
      }

      var otherValue = v.getDeepObjectValue(attributes, options.attribute)
        , comparator = options.comparator || function(v1, v2) {
          return v1 === v2;
        };

      if (!comparator(value, otherValue, options, attribute, attributes)) {
        return v.format(message, {attribute: v.prettify(options.attribute)});
      }
    },

    // A URL validator that is used to validate URLs with the ability to
    // restrict schemes and some domains.
    url: function(value, options) {
      if (!v.isDefined(value)) {
        return;
      }

      options = v.extend({}, this.options, options);

      var message = options.message || this.message || "is not a valid url"
        , schemes = options.schemes || this.schemes || ['http', 'https']
        , allowLocal = options.allowLocal || this.allowLocal || false;

      if (!v.isString(value)) {
        return message;
      }

      // https://gist.github.com/dperini/729294
      var regex =
        "^" +
        // protocol identifier
        "(?:(?:" + schemes.join("|") + ")://)" +
        // user:pass authentication
        "(?:\\S+(?::\\S*)?@)?" +
        "(?:";

      var tld = "(?:\\.(?:[a-z\\u00a1-\\uffff]{2,}))";

      if (allowLocal) {
        tld += "?";
      } else {
        regex +=
          // IP address exclusion
          // private & local networks
          "(?!(?:10|127)(?:\\.\\d{1,3}){3})" +
          "(?!(?:169\\.254|192\\.168)(?:\\.\\d{1,3}){2})" +
          "(?!172\\.(?:1[6-9]|2\\d|3[0-1])(?:\\.\\d{1,3}){2})";
      }

      regex +=
          // IP address dotted notation octets
          // excludes loopback network 0.0.0.0
          // excludes reserved space >= 224.0.0.0
          // excludes network & broacast addresses
          // (first & last IP address of each class)
          "(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])" +
          "(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}" +
          "(?:\\.(?:[1-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))" +
        "|" +
          // host name
          "(?:(?:[a-z\\u00a1-\\uffff0-9]-*)*[a-z\\u00a1-\\uffff0-9]+)" +
          // domain name
          "(?:\\.(?:[a-z\\u00a1-\\uffff0-9]-*)*[a-z\\u00a1-\\uffff0-9]+)*" +
          tld +
        ")" +
        // port number
        "(?::\\d{2,5})?" +
        // resource path
        "(?:[/?#]\\S*)?" +
      "$";

      var PATTERN = new RegExp(regex, 'i');
      if (!PATTERN.exec(value)) {
        return message;
      }
    }
  };

  validate.formatters = {
    detailed: function(errors) {return errors;},
    flat: v.flattenErrorsToArray,
    grouped: function(errors) {
      var attr;

      errors = v.groupErrorsByAttribute(errors);
      for (attr in errors) {
        errors[attr] = v.flattenErrorsToArray(errors[attr]);
      }
      return errors;
    },
    constraint: function(errors) {
      var attr;
      errors = v.groupErrorsByAttribute(errors);
      for (attr in errors) {
        errors[attr] = errors[attr].map(function(result) {
          return result.validator;
        }).sort();
      }
      return errors;
    }
  };

  validate.exposeModule(validate, this, exports, module, define);
}).call(commonjsGlobal,
        exports,
        module,
        typeof undefined !== 'undefined' ? /* istanbul ignore next */ undefined : null);
});

var makeValidator = function(constraints) {
	return function(value) {
		// Returns an array or undefined
		return validate_js_0_11_1_validate.single(value, constraints);
	};
};

makeValidator.many = function(constraints) {
	return function(values) {
		var rawErrors = validate_js_0_11_1_validate(values, constraints, {
			format: "detailed",
			fullMessages: false
		});
		var errors;

		if (rawErrors) {
			errors = [];
			canReflect_1_16_7_canReflect.eachIndex(rawErrors, function(error) {
				errors.push({
					message: error.options.message || error.error,
					related: [error.attribute]
				});
			});
		}
		return errors;
	};
};

makeValidator.validatejs = validate_js_0_11_1_validate;

var canValidateValidatejs_0_1_3_canValidateValidatejs = makeValidator;

var validate$1 = {};

var helpers$2 = {
	'object': function (normalizedErrors) {
		var errors = normalizedErrors.length > 0 ? {}: undefined;

		canReflect_1_16_7_canReflect.eachIndex(normalizedErrors, function (error) {
			canReflect_1_16_7_canReflect.eachIndex(error.related, function (related) {
				if (!errors[related]) {
					errors[related] = [];
				}
				errors[related].push(error.message);
			});
		});
		return errors;
	},
	'flat': function (normalizedErrors) {
		var errors = normalizedErrors.length > 0 ? []: undefined;
		canReflect_1_16_7_canReflect.eachIndex(normalizedErrors, function (error) {
			errors.push(error.message);
		});
		return errors;
	},
	'errors': function (normalizedErrors) {
		return normalizedErrors.length > 0 ? normalizedErrors: undefined;
	},
	'errors-object': function (normalizedErrors) {
		var errors = normalizedErrors.length > 0 ? {}: undefined;
		canReflect_1_16_7_canReflect.eachIndex(normalizedErrors, function (error) {
			canReflect_1_16_7_canReflect.eachIndex(error.related, function (related) {
				if (!errors[related]) {
					errors[related] = [];
				}
				errors[related].push(error);
			});
		});
		return errors;
	}
};

var parseErrorItem = function (rawErrors) {
	var errors = [];
	if (typeof rawErrors === 'string') {
		errors.push({message: rawErrors, related: ['*']});
	}
	if (typeof rawErrors === 'object' && !Array.isArray(rawErrors)) {
		// Although related can be a string, internally, it is easier if it is
		// always an array
		if (rawErrors.related) {
			if (!Array.isArray(rawErrors.related)) {
				rawErrors.related = [rawErrors.related];
			}
		} else {
			rawErrors.related = '*';
		}
		errors.push(rawErrors);
	}
	if (Array.isArray(rawErrors)) {
		canReflect_1_16_7_canReflect.eachIndex(rawErrors, function (error) {
			[].push.apply(errors, parseErrorItem(error));
		});
	}
	return errors;
};

// Takes errors and normalizes them
var normalizeErrors = function (rawErrors) {
	var normalizedErrors = [];
  if (
    typeof rawErrors === 'string' ||
    (typeof rawErrors === 'object' && !Array.isArray(rawErrors))
  ) {
		// Only one error set, which we can assume was for a single property
		rawErrors = [rawErrors];
	}

  if (rawErrors != null) {
    canReflect_1_16_7_canReflect.eachIndex(rawErrors, function (error) {
      [].push.apply(normalizedErrors, parseErrorItem(error));
    });
  }

	return normalizedErrors;
};

validate$1.formatErrors = function (errors, format) {
	var normalized = normalizeErrors(errors);
	if (format) {
		if (helpers$2[format]) {
			return helpers$2[format](normalized);
		} else {
			return normalized;
		}
	} else {
		return normalized;
	}
};

var canValidate_1_1_4_canValidate = validate$1;

/* jshint unused: false */

/**
 * @module {function} can-util/js/is-empty-object/is-empty-object is-empty-object
 * @parent can-util/js
 * @signature `isEmptyObject(obj)`
 *
 * Used to determine if an object is an empty object (an object with no enumerable properties) such as `{}`.
 *
 * ```js
 * var isEmptyObject = require("can-util/js/is-empty-object/is-empty-object");
 *
 * console.log(isEmptyObject({})); // -> true
 *
 * console.log(isEmptyObject({ a: 1 })); // -> false
 *
 * var obj = {};
 * Object.defineProperty(obj, "foo", {
 *     enumerable: false,
 *     value: "bar"
 * });
 * console.log(isEmptyObject(obj)); // -> true
 * ```
 *
 * @param {Object} obj Any object.
 * @return {Boolean} True if the object is an object with no enumerable properties.
 */
var isEmptyObject = function(obj){
	for(var prop in obj) {
		return false;
	}
	return true;
};

var formatErrors = canValidate_1_1_4_canValidate.formatErrors;


var getMapConstraints = function(Map) {
	var constraints = {};
	canReflect_1_16_7_canReflect.eachKey(Map.prototype._define.definitions, function(prop, key) {
		if (prop.validate && !isEmptyObject(prop.validate)) {
			constraints[key] = prop.validate;
		}
	});
	return constraints;
};

var validateMap = function(Map, validator) {
	var mapDefinition = Map.prototype._define;

	Map.prototype.testSet = function() {
		var values = {};
		var useNewObject = false;
		if (arguments.length) {
			// Check if testing many values or just one
			if (typeof arguments[0] === "object" && Boolean(arguments[0])) {
				values = arguments[0];
				useNewObject = Boolean(arguments[1]);
			}

			// Check if testing single value
			if (typeof arguments[0] === "string") {
				values[arguments[0]] = arguments[1];
			}

			// Merge values with existing map or with a new map
			if (useNewObject) {
				values = new Map(values);
			} else {
				var mapClone = this.serialize();
				canAssign_1_1_1_canAssign(mapClone, values);
				values = mapClone;
			}
			return validator(values);
		} else {
			return this.errors();
		}
	};

	Map.prototype.errors = function() {
		var _errors = this._errors;
		var errors;
		if (arguments.length) {
			var errorsObj = formatErrors(_errors, "errors-object");
			errors = [];

			canReflect_1_16_7_canReflect.eachIndex(arguments, function(key) {
				[].push.apply(errors, errorsObj ? errorsObj[key] : []);
			});
			errors = errors.length > 0 ? errors : undefined;
		} else {
			errors = _errors;
		}
		return errors;
	};

	canDefine_2_3_5_canDefine.property(
		Map.prototype,
		"_errors",
		{
			get: function() {
				var errors = validator(this);
				return errors;
			}
		},
		mapDefinition.dataInitializers,
		mapDefinition.computedInitializers
	);
};

var decorator = function(Map) {
	var constraints = getMapConstraints(Map);
	var validator = canValidateValidatejs_0_1_3_canValidateValidatejs.many(constraints);

	validateMap(Map, function(map) {
		var errors = validator(map);
		return formatErrors(errors, "errors");
	});
};

decorator.validatejs = canValidateValidatejs_0_1_3_canValidateValidatejs.validatejs;

var canDefineValidateValidatejs_1_0_1_canDefineValidateValidatejs = decorator;

/*exported ndjsonStream*/



var ndjsonStream = function(response) {
  // For cancellation
  var is_reader, cancellationRequest = false;
  return new ReadableStream({
    start: function(controller) {
      var reader = response.getReader();
      is_reader = reader;
      var decoder = new TextDecoder();
      var data_buf = "";

      reader.read().then(function processResult(result) {
        if (result.done) {
          if (cancellationRequest) {
            // Immediately exit
            return;
          }

          data_buf = data_buf.trim();
          if (data_buf.length !== 0) {
            try {
              var data_l = JSON.parse(data_buf);
              controller.enqueue(data_l);
            } catch(e) {
              controller.error(e);
              return;
            }
          }
          controller.close();
          return;
        }

        var data = decoder.decode(result.value, {stream: true});
        data_buf += data;
        var lines = data_buf.split("\n");
        for(var i = 0; i < lines.length - 1; ++i) {
          var l = lines[i].trim();
          if (l.length > 0) {
            try {
              var data_line = JSON.parse(l);
              controller.enqueue(data_line);
            } catch(e) {
              controller.error(e);
              cancellationRequest = true;
              reader.cancel();
              return;
            }
          }
        }
        data_buf = lines[lines.length-1];

        return reader.read().then(processResult);
      });

    },
    cancel: function(reason) {
      console.log("Cancel registered due to ", reason);
      cancellationRequest = true;
      is_reader.cancel();
    }
  });
};

var canNdjsonStream_0_1_8_canNdjsonStream = canNamespace_1_0_0_canNamespace.ndjsonStream = ndjsonStream;

var Symbols = {
	metaSymbol: canSymbol_1_6_1_canSymbol.for("can.meta"),
	// not an actual symbol. This is so it can be enumerable
	// by default. We could create a KeyTree with a type where symbols are
	// enumerable.
	patchesSymbol: "can.patches",
	keysSymbol: "can.keys"
};

var ObservableStore = {
	proxiedObjects: new WeakMap(),
	proxies: new WeakSet()
};

var metaSymbol$3 = canSymbol_1_6_1_canSymbol.for("can.meta");
var classTest = /^\s*class\s+/;

var helpers$3 = {
	assignEverything: function(d, s) {
		Object.getOwnPropertyNames(s).concat(Object.getOwnPropertySymbols(s)).forEach(function(key) {
			Object.defineProperty(d,key, Object.getOwnPropertyDescriptor(s,key));
		});
		return d;
	},
	isBuiltInButNotArrayOrPlainObject: function(obj) {
		if (Array.isArray(obj)) {
			return false;
		}
		if (typeof obj === "function") {
			var fnCode = obj.toString();
			if (fnCode.indexOf("[native code]") > 0) {
				return true;
			} else {
				return false;
			}
		} else {
			var toString = Object.prototype.toString.call(obj);
			return toString !== '[object Object]' && toString.indexOf('[object ') !== -1;
		}

	},
	inheritsFromArray: function(obj) {
		var cur = obj;
		do {
			if (Array.isArray(cur)) {
				return true;
			}
			cur = Object.getPrototypeOf(cur);
		} while (cur);
		return false;
	},
	isClass: function(obj) {
		return typeof obj === 'function' && classTest.test(obj.toString());
	},
	supportsClass: (function() {
		try {
			eval('"use strict"; class A{};');
			return true;
		} catch (e) {
			return false;
		}
	})(),
	makeSimpleExtender: function(BaseType){
		return function extend(name, staticProps, prototypeProps){
		    var Type = function(){
		        var source = this;
				var instance = BaseType.apply(this, arguments);
		        if(source.init) {
		            // makes sure nothing can leak out
		            instance[metaSymbol$3].preventSideEffects++;
		            source.init.apply(instance, arguments);
		            instance[metaSymbol$3].preventSideEffects--;
		        }
		        return instance;
			};


			helpers$3.assignEverything(Type,BaseType);
			helpers$3.assignEverything(Type, staticProps || {});
			Type.extend = helpers$3.makeSimpleExtender(Type);
			Type.prototype = Object.create( BaseType.prototype );
			helpers$3.assignEverything(Type.prototype, prototypeProps || {});
			Type.prototype.constructor = Type;

			//!steal-remove-start
			Object.defineProperty(Type, "name", {
				value: name
			});
			//!steal-remove-end

			return Type;
		};
	},
	assignNonEnumerable: function(obj, key, value){
		return Object.defineProperty(obj,key,{
		    enumerable: false,
		    writable: true,
		    configurable: true,
		    value: value
		});
	}
};


var Helpers = helpers$3;

var ComputedHelpers = createCommonjsModule(function (module) {
var canMeta = canSymbol_1_6_1_canSymbol.for("can.meta");
var computedPropertyDefinitionSymbol = canSymbol_1_6_1_canSymbol.for("can.computedPropertyDefinitions");
var onKeyValueSymbol = canSymbol_1_6_1_canSymbol.for("can.onKeyValue");
var offKeyValueSymbol = canSymbol_1_6_1_canSymbol.for("can.offKeyValue");
// var getKeyDependenciesSymbol = canSymbol.for("can.getKeyDependencies");

// ## ComputedObjectObservationData
// Instances of this are created to wrap the observation.
// The `.bind` and `.unbind` methods should be called when the
// instance's prop is bound or unbound.
function ComputedObjectObservationData(instance, prop, observation){
	this.instance = instance;
    this.prop = prop;
    this.observation = observation;
	this.forward = this.forward.bind(this);
}

ComputedObjectObservationData.prototype.bind = function(){
    this.bindingCount++;
    if(this.bindingCount === 1) {
        this.observation.on(this.forward, "notify");
    }
};

ComputedObjectObservationData.prototype.unbind = function(){
    this.bindingCount--;
    if(this.bindingCount === 0) {
        this.observation.off(this.forward, "notify");
    }
};

ComputedObjectObservationData.prototype.forward = function(newValue, oldValue){
	map$1.dispatch.call(this.instance, {
		type: this.prop,
		target: this.instance

		// patches: [{
		// 	key: this.prop,
		// 	type: "set",
		// 	value: newValue
		// }]
		// keyChanged: undefined
	}, [newValue, oldValue]);
};

ComputedObjectObservationData.prototype.bindingCount = 0;

function findComputed(instance, key) {
	var meta = instance[canMeta];
	var target = meta.target;

	var computedPropertyDefinitions = target[computedPropertyDefinitionSymbol];
	if (computedPropertyDefinitions === undefined) {
		return;
	}
	var computedPropertyDefinition = computedPropertyDefinitions[key];
	if (computedPropertyDefinition === undefined) {
		return;
	}

	if (meta.computedKeys[key] === undefined) {
		meta.computedKeys[key] = new ComputedObjectObservationData(
			instance, key,
			computedPropertyDefinition(instance, key)
		);
	}

	return meta.computedKeys[key];
}

var computedHelpers = module.exports = {
	get: function(instance, key) {
		var computedObj = findComputed(instance, key);
		if (computedObj === undefined) {
			return;
		}

		canObservationRecorder_1_1_2_canObservationRecorder.add(instance, key.toString());
		if(computedObj.bindingCount === 0 && canObservationRecorder_1_1_2_canObservationRecorder.isRecording()) {
			canObservation_4_0_1_canObservation.temporarilyBind(computedObj.observation);
		}

		return {
			value: canReflect_1_16_7_canReflect.getValue(computedObj.observation),
		};
	},
	set: function(instance, key, value) {
		var computedObj = findComputed(instance, key);
		if (computedObj === undefined) {
			return false;
		}

		//!steal-remove-start
		if (computedObj.observation[canSymbol_1_6_1_canSymbol.for("can.setValue")] === undefined) {
			throw new Error("Cannot set \"" + key + "\" on " + canReflect_1_16_7_canReflect.getName(instance));
		}
		//!steal-remove-end

		canReflect_1_16_7_canReflect.setValue(computedObj.observation, value);
		return true;
	},
	bind: function(instance, key) {
		var computedObj = findComputed(instance, key);
		if (computedObj === undefined) {
			return;
		}

		computedObj.bind();
	},
	unbind: function(instance, key) {
		var computedObj = findComputed(instance, key);
		if (computedObj === undefined) {
			return;
		}

		computedObj.unbind();
	},
	addKeyDependencies: function(proxyKeys) {
		var onKeyValue = proxyKeys[onKeyValueSymbol];
		var offKeyValue = proxyKeys[offKeyValueSymbol];
		// var getKeyDependencies = proxyKeys[getKeyDependenciesSymbol];

		canReflect_1_16_7_canReflect.assignSymbols(proxyKeys, {
			"can.onKeyValue": function(key, handler, queue) {
				computedHelpers.bind(this, key);

				// var handlers = this[canMeta].handlers;
				// handlers.add([ key, "onKeyValue", queue || "notify", handler ]);

				return onKeyValue.apply(this, arguments);
			},
			"can.offKeyValue": function(key, handler, queue) {
				computedHelpers.unbind(this, key);

				// var handlers = this[canMeta].handlers;
				// handlers.delete([ key, "onKeyValue", queue || "notify", handler ]);

				return offKeyValue.apply(this, arguments);
			},
			"can.getKeyDependencies": function(key) {
				var computedObj = findComputed(this, key);
				if (computedObj === undefined) {
					return;
				}

				return {
					valueDependencies: new Set([ computedObj.observation ])
				};
			},
		});
	},
	addMethodsAndSymbols: function(Type) {
		Type.prototype.addEventListener = function(key, handler, queue) {
			computedHelpers.bind(this, key);
			return map$1.addEventListener.call(this, key, handler, queue);
		};

		Type.prototype.removeEventListener = function(key, handler, queue) {
			computedHelpers.unbind(this, key);
			return map$1.removeEventListener.call(this, key, handler, queue);
		};
	},
	ensureDefinition: function(prototype) {
		if (!prototype.hasOwnProperty(computedPropertyDefinitionSymbol)) {
			var parent = prototype[computedPropertyDefinitionSymbol];
			var definitions = prototype[computedPropertyDefinitionSymbol] = Object.create(parent || null);

			Object.getOwnPropertyNames(prototype).forEach(function(prop) {
				if (prop === "constructor") {
					return;
				}

				// auto-binding for getters
				var descriptor = Object.getOwnPropertyDescriptor(prototype, prop);
				if(descriptor.get !== undefined) {
					var getter = descriptor.get;
					definitions[prop] = function(instance, property) {
						return new canObservation_4_0_1_canObservation(getter, instance);
					};
				}
			});
		}

		return prototype[computedPropertyDefinitionSymbol];
	},
};
});
var ComputedHelpers_1 = ComputedHelpers.get;
var ComputedHelpers_2 = ComputedHelpers.set;
var ComputedHelpers_3 = ComputedHelpers.bind;
var ComputedHelpers_4 = ComputedHelpers.unbind;
var ComputedHelpers_5 = ComputedHelpers.addKeyDependencies;
var ComputedHelpers_6 = ComputedHelpers.addMethodsAndSymbols;
var ComputedHelpers_7 = ComputedHelpers.ensureDefinition;

// # -make-object.js
// This module's `.observable` method proxies an object to make it observable.
// The other exports are used by other make-TYPE modules.









var hasOwn = Object.prototype.hasOwnProperty;
var isSymbolLike$1 = canReflect_1_16_7_canReflect.isSymbolLike;

// These are the "overwrites" for the proxy.
// Copy the symbols from the map bindings mixin.
var proxyKeys = Object.create(null);
Object.getOwnPropertySymbols(map$1).forEach(function(symbol){
	Helpers.assignNonEnumerable(proxyKeys, symbol, map$1[symbol]);
});

ComputedHelpers.addKeyDependencies(proxyKeys);

var makeObject = {
	// Returns a proxied version of the object.
	// - `object` - An object to proxy.
	// - `options` - Configurable behaviors.
	//   - `proxyKeys` - Keys that will override any keys on `object`. Defaults to `makeObject.proxyKeys`.
	//   - `observe(nonObservable)` - A function that converts a nested value to an observable.
	//   - `shouldRecordObservation(keyInfo, meta)` - Returns if `ObservationRecorder`
	//     should be called.  Defaults to `makeObject.shouldRecordObservationOnOwnAndMissingKeys`.
	observable: function(object, options) {
		if(options.shouldRecordObservation === undefined) {
			options.shouldRecordObservation = makeObject.shouldRecordObservationOnOwnAndMissingKeys;
		}

		var meta = {
			target: object,
			proxyKeys: options.proxyKeys !== undefined ? options.proxyKeys : Object.create(makeObject.proxyKeys()),
			computedKeys: Object.create(null),
			options: options,
			// `preventSideEffects` is a counter used to "turn off" the proxy.  This is incremented when some
			// function (like `Array.splice`) wants to handle event dispatching and/or calling
			// `ObservationRecorder` itself for performance reasons.
			preventSideEffects: 0
		};

		Helpers.assignNonEnumerable(meta.proxyKeys, Symbols.metaSymbol, meta);

		// We `bind` so the `meta` is immediately available as `this`.
		var traps = {
			get: makeObject.get.bind(meta),
			set: makeObject.set.bind(meta),
			ownKeys: makeObject.ownKeys.bind(meta),
			deleteProperty: makeObject.deleteProperty.bind(meta),
			getOwnPropertyDescriptor: makeObject.getOwnPropertyDescriptor.bind(meta),
			meta: meta
		};

		if(options.getPrototypeOf) {
			traps.getPrototypeOf = options.getPrototypeOf;
		}

		meta.proxy = new Proxy(object, traps);
		map$1.addHandlers(meta.proxy, meta);
		return meta.proxy;
	},
	proxyKeys: function() {
		return proxyKeys;
	},
	// `get` checks the target for un-proxied objects.
	// If it finds an un-proxied object:
	//   - it creates one (which registers itself in the observableStore) and
	//   - returns the proxied value without modifying the underlying target
	get: function(target, key, receiver) {
		// If getting a key for the proxy, return that value.
		var proxyKey = this.proxyKeys[key];
		if (proxyKey !== undefined) {
			return proxyKey;
		}

		// Symbols are not observable and their values are not made observable.
		if (isSymbolLike$1(key)) {
			return target[key];
		}

		// If it has a defined property definiition
		var computedValue = ComputedHelpers.get(receiver, key);
		if(computedValue !== undefined ) {
			return computedValue.value;
		}

		// Gets information about the key on `target` or on `target`'s prototype.
		var keyInfo = makeObject.getKeyInfo(target, key, receiver, this);
		var value = keyInfo.targetValue;

		// If the return value can be changed ...
		if (!keyInfo.valueIsInvariant) {
			// Convert the value into an observable
			// or get it if already converted from the store.
			value = makeObject.getValueFromStore(key, value, this);
		}

		if (this.options.shouldRecordObservation(keyInfo, this)) {
			canObservationRecorder_1_1_2_canObservationRecorder.add(this.proxy, key.toString());
		}

		// if the parent object is observable, we need to observe there too.
		if (keyInfo.parentObservableGetCalledOn) {
			canObservationRecorder_1_1_2_canObservationRecorder.add(keyInfo.parentObservableGetCalledOn, key.toString());
		}
		return value;
	},
	// `set` is called when a property is set on the proxy or an object
	// that has the proxy on its prototype.
	set: function(target, key, value, receiver) {
		// If the receiver is not this observable (the observable might be on the proto chain),
		// set the key on the reciever.
		if (receiver !== this.proxy) {
			return makeObject.setKey(receiver, key, value, this);
		}

		// If it has a defined property definiition
		var computedValue = ComputedHelpers.set(receiver, key, value);
		if(computedValue === true ) {
			return true;
		}

		// Gets the observable value to set.
		value = makeObject.getValueToSet(key, value, this);

		// Sets the value on the target.  If there
		// is a change, calls the callback.
		makeObject.setValueAndOnChange(key, value, this, function(key, value, meta, hadOwn, old) {

			//!steal-remove-start
			var reasonLog = [canReflect_1_16_7_canReflect.getName(meta.proxy)+" set", key,"to", value];
			//!steal-remove-end

			// Fire event handlers for this key change.
			map$1.dispatch.call( meta.proxy, {
				type: key,
				//!steal-remove-start
				/* jshint laxcomma: true */
				reasonLog: reasonLog,
				/* jshint laxcomma: false */
				//!steal-remove-end
				patches: [{
					key: key,
					type: hadOwn ? "set" : "add",
					value: value
				}],
				keyChanged: !hadOwn ? key : undefined
			},[value, old]);

		});

		return true;
	},
	// `deleteProperty` is called when a property is deleted on the proxy.
	deleteProperty: function(target, key) {

		var old = this.target[key],
			deleteSuccessful = delete this.target[key];

		// Fire event handlers if we were able to delete and the value changed.
		if (deleteSuccessful && this.preventSideEffects === 0 && old !== undefined) {
			//!steal-remove-start
			var reasonLog = [canReflect_1_16_7_canReflect.getName(this.proxy)+" deleted", key];
			//!steal-remove-end

			map$1.dispatch.call( this.proxy, {
				type: key,
				//!steal-remove-start
				/* jshint laxcomma: true */
				reasonLog: reasonLog,
				/* jshint laxcomma: false */
				//!steal-remove-end
				patches: [{
					key: key,
					type: "delete"
				}],
				keyChanged: key
			},[undefined, old]);

		}
		return deleteSuccessful;
	},
	// `ownKeys` returns the proxies keys.
	// Proxies should return the keys and symbols from proxyOnly
	// as well as from the target, so operators like `in` and
	// functions like `hasOwnProperty` can be used to determine
	// that the Proxy is observable.
	ownKeys: function(target, key) {
		canObservationRecorder_1_1_2_canObservationRecorder.add(this.proxy, Symbols.keysSymbol);

		return Object.getOwnPropertyNames(this.target)
			.concat(Object.getOwnPropertySymbols(this.target))
			.concat(Object.getOwnPropertySymbols(this.proxyKeys));
	},
	getOwnPropertyDescriptor: function(target, key) {
		var desc = Object.getOwnPropertyDescriptor(target, key);

		if(!desc && (key in this.proxyKeys)) {
			return Object.getOwnPropertyDescriptor(this.proxyKeys, key);
		}

		return desc;
	},
	// Returns a `keyInfo` object with useful information about the key
	// and its value.  This function is _heavily_ optimized.
	getKeyInfo: function(target, key, receiver, meta) {
		var descriptor = Object.getOwnPropertyDescriptor(target, key);
		var propertyInfo = {
			// The key being read.
			key: key,
			// The property descriptor.
			descriptor: descriptor,
			// If the `target` has the key.
			targetHasOwnKey: Boolean(descriptor),
			// If the proxy is on the proto chain.
			getCalledOnParent: receiver !== meta.proxy,
			// If the prototype of the target has this key.
			protoHasKey: false,
			// If the property is sealed or not.
			valueIsInvariant: false,
			// The value of the key wherever it is found.
			targetValue: undefined,
			// If reading the key went through a getter.
			isAccessor: false
		};
		if (propertyInfo.getCalledOnParent === true) {
			propertyInfo.parentObservableGetCalledOn = ObservableStore.proxiedObjects.get(receiver);
		}
		if (descriptor !== undefined) {
			propertyInfo.valueIsInvariant = descriptor.writable === false;
			if (descriptor.get !== undefined) {
				propertyInfo.targetValue = descriptor.get.call( propertyInfo.parentObservableGetCalledOn || receiver);
				propertyInfo.isAccessor = true;
			} else {
				propertyInfo.targetValue = descriptor.value;
			}
		} else {
			propertyInfo.targetValue = meta.target[key];
			propertyInfo.protoHasKey = propertyInfo.targetValue !== undefined ? true : (key in target);
		}

		return propertyInfo;
	},
	// Returns `true` if `ObservationRecorder.add` should be called.
	// This is the default `options.shouldRecordObservation` behavior.
	// `observe.Object` changes this to record all keys except functions on the
	// proto chain.
	shouldRecordObservationOnOwnAndMissingKeys: function(keyInfo, meta) {
		return meta.preventSideEffects === 0 &&
			// The read is not a getter AND ...
			!keyInfo.isAccessor &&
			(
				// (the read is on the proxy OR
				(keyInfo.targetHasOwnKey ) ||
				// it's not on the proto chain and we are not sealed).
				(!keyInfo.protoHasKey && !Object.isSealed(meta.target))
			);
	},
	// `setKey` sets a value on an object. Use `Object.defineProperty`
	// because it won't try setting up the proto chain.
	setKey: function(receiver, key, value) {
		Object.defineProperty(receiver, key, {
			value: value,
			configurable: true,
			enumerable: true,
			writable: true
		});
		return true;
	},
	// `getValueToSet` gets the value we will set on the object.  It only
	// converts set values to observables if we have actually bound.
	getValueToSet: function(key, value, meta) {
		if (!canReflect_1_16_7_canReflect.isSymbolLike(key) && meta.handlers.getNode([key])) {
			return makeObject.getValueFromStore(key, value, meta);
		}
		return value;
	},
	// Get a value from the store if we can.
	getValueFromStore: function(key, value, meta) {
		// We never convert primitives or things that are already observable.
		// However, there are some builtIns that we premptively convert, namely
		// Array.prototype methods.
		if (!canReflect_1_16_7_canReflect.isPrimitive(value) &&
			!canReflect_1_16_7_canReflect.isObservableLike(value) &&
			// Do nothing if the value is already a converted proxy.
			!ObservableStore.proxies.has(value)) {

			// If the `value` already been made into a proxy, use the value.
			if (ObservableStore.proxiedObjects.has(value)) {
				value = ObservableStore.proxiedObjects.get(value);
			}
			else if (!Helpers.isBuiltInButNotArrayOrPlainObject(value)) {
				value = meta.options.observe(value);
			}
		}
		return value;
	},

	// `setValueAndOnChange` sets the value.  If the value changed,
	// calls the `onChange` callback.
	setValueAndOnChange: function(key, value, data, onChange) {
		var old, change;
		var hadOwn = hasOwn.call(data.target, key);

		var descriptor = Object.getOwnPropertyDescriptor(data.target, key);
		// call the setter on the Proxy to properly do any side-effect sets (and run corresponding handlers)
		// -- setters do not return values, so it is unnecessary to check for changes.
		if (descriptor && descriptor.set) {
			descriptor.set.call(data.proxy, value);
		} else {
			// otherwise check for a changed value
			old = data.target[key];
			change = old !== value;
			if (change) {
				data.target[key] = value;
				if (data.preventSideEffects === 0) {
					onChange(key, value, data, hadOwn, old);
				}
			}
		}
	}
};


var MakeObject = makeObject;

// # -make-array.js
// This module's `.observable` method proxies an Array to make it observable.
// The other exports are not used elsewhere.
// `.set` is the only proxy method that differs from `make-object`'s.










var isSymbolLike$2 = canReflect_1_16_7_canReflect.isSymbolLike;

// Returns if prop is an integer
var isInteger = Number.isInteger || function(value) {
  return typeof value === 'number' &&
    isFinite(value) &&
    Math.floor(value) === value;
};

// Returns `true` if the length was set and it deleted indexed
// properties.
function didLengthChangeCauseDeletions(key, value, old) {
	return key === "length" && value < old;
}


// ## Rewrite array methods
// The following rewrites array methods to generate events and
// for performance reasons.
//
// Array's methods that mutate are rewritten to generate patch events.
// Other methods on array are rewritten to:
// - Avoid calling `ObservationRecorder.add` on every property.
// - Make the returned result observable.
//
// ### Rewrite mutating methods
// The following defines a relationship between an array
// mutation method and the patch events that should be dispatched
// for that mutation.
var mutateMethods = {
	"push": function(arr, args) {
		return [{
			index: arr.length - args.length,
			deleteCount: 0,
			insert: args,
			type: "splice"
		}];
	},
	"pop": function(arr) {
		return [{
			index: arr.length,
			deleteCount: 1,
			insert: [],
			type: "splice"
		}];
	},
	"shift": function() {
		return [{
			index: 0,
			deleteCount: 1,
			insert: [],
			type: "splice"
		}];
	},
	"unshift": function(arr, args) {
		return [{
			index: 0,
			deleteCount: 0,
			insert: args,
			type: "splice"
		}];
	},
	"splice": function(arr, args) {
		return [{
			index: args[0],
			deleteCount: args[1],
			insert: args.slice(2),
			type: "splice"
		}];
	},
	"sort": function(arr) {
		// The array replaced everything.
		return [{
			index: 0,
			deleteCount: arr.length,
			insert: arr,
			type: "splice"
		}];
	},
	"reverse": function(arr, args, old) {
		// The array replaced everything.
		return [{
			index: 0,
			deleteCount: arr.length,
			insert: arr,
			type: "splice"
		}];
	}
};
// Overwrite Array's methods that mutate to:
// - prevent other events from being fired off (index events and length events.)
// - dispatch patches events.
canReflect_1_16_7_canReflect.eachKey(mutateMethods, function(makePatches, prop){
	var protoFn = Array.prototype[prop];
	var mutateMethod = function() {
		var meta = this[Symbols.metaSymbol],
			// Capture if this function should be making sideEffects
			makeSideEffects = meta.preventSideEffects === 0,
			oldLength = meta.target.length;

		// Prevent proxy from calling ObservationRecorder and sending events.
		meta.preventSideEffects++;

		// Call the function -- note that *this* is the Proxy here, so
		// accesses in the function still go through `get()` and `set()`.
		var ret = protoFn.apply(meta.target, arguments);
		var patches = makePatches(meta.target, Array.from(arguments), oldLength);

		if (makeSideEffects === true) {
			//!steal-remove-start
			var reasonLog = [canReflect_1_16_7_canReflect.getName(meta.proxy)+"."+prop+" called with", arguments];
			//!steal-remove-end

			map$1.dispatch.call( meta.proxy, {
				type: "length",
				//!steal-remove-start
				reasonLog: reasonLog,
				//!steal-remove-end
				patches: patches
			}, [meta.target.length, oldLength]);
		}

		meta.preventSideEffects--;
		return ret;
	};
	//!steal-remove-start
	Object.defineProperty(mutateMethod, "name", {
		value: prop
	});
	//!steal-remove-end

	// Store the proxied method so it will be used instead of the
	// prototype method.
	ObservableStore.proxiedObjects.set(protoFn, mutateMethod);
	ObservableStore.proxies.add(mutateMethod);
});

// ### Rewrite non-mutating methods
// The following rewrites the Array methods to signal
// to `ObservationRecorder` to bind on patches events.
// It also prevents the proxy handlers calling `ObservationRecorder`
// themselves.
Object.getOwnPropertyNames(Array.prototype).forEach(function(prop) {
	var protoFn = Array.prototype[prop];
	if (ObservableStore.proxiedObjects.has(protoFn)) {
		return;
	}

	if (prop !== "constructor" && typeof protoFn === "function") {
		var arrayMethod = function() {
			canObservationRecorder_1_1_2_canObservationRecorder.add(this, Symbols.patchesSymbol);
			var meta = this[Symbols.metaSymbol];
			meta.preventSideEffects++;
			var ret = protoFn.apply(this, arguments);
			meta.preventSideEffects--;
			return meta.options.observe(ret);
		};
		//!steal-remove-start
		Object.defineProperty(arrayMethod, "name", {
			value: prop
		});
		//!steal-remove-end
		ObservableStore.proxiedObjects.set(protoFn, arrayMethod);
		ObservableStore.proxies.add(arrayMethod);
	}
});


// Array's have the same proxy keys as objects.
var proxyKeys$1 = Helpers.assignEverything(Object.create(null), MakeObject.proxyKeys());


var makeArray$1 = {
	// Returns a proxied version of the array.
	// - `array` - An array to proxy.
	// - `options` - Configurable behaviors.
	//   - `proxyKeys` - Keys that will override any keys on `array`. Defaults to `makeObject.proxyKeys`.
	//   - `observe(nonObservable)` - A function that converts a nested value to an observable.
	//   - `shouldRecordObservation(keyInfo, meta)` - Returns if `ObservationRecorder`
	//     should be called.  Defaults to `makeObject.shouldRecordObservationOnOwnAndMissingKeys`.
	observable: function(array, options) {
		if(options.shouldRecordObservation === undefined) {
			options.shouldRecordObservation = MakeObject.shouldRecordObservationOnOwnAndMissingKeys;
		}
		var meta = {
			target: array,
			proxyKeys: options.proxyKeys !== undefined ? options.proxyKeys : Object.create(makeArray$1.proxyKeys()),
			computedKeys: Object.create(null),
			options: options,
			// `preventSideEffects` is a counter used to "turn off" the proxy.  This is incremented when some
			// function (like `Array.splice`) wants to handle event dispatching and/or calling
			// `ObservationRecorder` itself for performance reasons.
			preventSideEffects: 0
		};
		meta.proxyKeys[Symbols.metaSymbol] = meta;
		meta.proxy = new Proxy(array, {
			get: MakeObject.get.bind(meta),
			set: makeArray$1.set.bind(meta),
			ownKeys: MakeObject.ownKeys.bind(meta),
			deleteProperty: MakeObject.deleteProperty.bind(meta),
			meta: meta
		});
		map$1.addHandlers(meta.proxy, meta);
		return meta.proxy;
	},
	proxyKeys: function() {
		return proxyKeys$1;
	},
	// `set` is called when a property is set on the proxy or an object
	// that has the proxy on its prototype.
	set: function(target, key, value, receiver) {
		// If the receiver is not this observable (the observable might be on the proto chain),
		// set the key on the reciever.
		if (receiver !== this.proxy) {
			return MakeObject.setKey(receiver, key, value, this);
		}

		// If it has a defined property definiition
		var computedValue = ComputedHelpers.set(receiver, key, value);
		if(computedValue === true ) {
			return true;
		}

		// Gets the observable value to set.
		value = MakeObject.getValueToSet(key, value, this);
		var startingLength = target.length;

		// Sets the value on the target.  If there
		// is a change, calls the callback.
		MakeObject.setValueAndOnChange(key, value, this, function(key, value, meta, hadOwn, old) {

			// Determine the patches this change should dispatch
			var patches = [{
				key: key,
				type: hadOwn ? "set" : "add",
				value: value
			}];

			var numberKey = !isSymbolLike$2(key) && +key;

			// If we are adding an indexed value like `arr[5] =value` ...
			if ( isInteger(numberKey) ) {
				// If we set an enumerable property after the length ...
				if (!hadOwn && numberKey > startingLength) {
					// ... add patches for those values.
					patches.push({
						index: startingLength,
						deleteCount: 0,
						insert: target.slice(startingLength),
						type: "splice"
					});
				} else {
					// Otherwise, splice the value into the array.
					patches.push.apply(patches, mutateMethods.splice(target, [numberKey, 1, value]));
				}
			}

			// In the case of deleting items by setting the length of the array,
			// add patches that splice the items removed.
			// (deleting individual items from an array doesn't change the length; it just creates holes)
			if (didLengthChangeCauseDeletions(key, value, old, meta)) {
				patches.push({
					index: value,
					deleteCount: old - value,
					insert: [],
					type: "splice"
				});
			}
			//!steal-remove-start
			var reasonLog = [canReflect_1_16_7_canReflect.getName(meta.proxy)+" set", key,"to", value];
			//!steal-remove-end

			map$1.dispatch.call( meta.proxy, {
				type: key,
				//!steal-remove-start
				/* jshint laxcomma: true */
				reasonLog: reasonLog,
				/* jshint laxcomma: false */
				//!steal-remove-end
				patches: patches,
				keyChanged: !hadOwn ? key : undefined
			},[value, old]);

		});

		return true;
	}
};


var MakeArray = makeArray$1;

var makeObserve = {
	observe: function(value) {
		if (canReflect_1_16_7_canReflect.isPrimitive(value)) {
			return value;
		}
		var observable = ObservableStore.proxiedObjects.get(value);
		if (observable) {
			return observable;
		}
		if (ObservableStore.proxies.has(value)) {
			return value;
		}
		if (Helpers.isBuiltInButNotArrayOrPlainObject(value)) {
			return value;
		}
		if (typeof value === "function") {
			observable = makeObserve.function(value);
		} else if (Helpers.inheritsFromArray(value)) {
			observable = makeObserve.array(value);
		} else {
			observable = makeObserve.object(value);
		}
		ObservableStore.proxiedObjects.set(value, observable);
		ObservableStore.proxies.add(observable);
		return observable;
	},
	// Set to a function that converts non-observable
	// objects to observable objects
	"object": null,
	// Set to a function that converts non-observable
	// arrays to observable arrays
	"array": null,
	// Set to a function that converts non-observable
	// functions to observable functions
	"function": null
};

var MakeObserve = makeObserve;

// # -make-function.js
// This module's `.observable` method proxies an function to make it an any instances
// created by it observable.









// ## proxyKeys
// A function's proxyKeys is a combination of:
// - object's symbols (`.onKeyValue`)
// - type event symbols (`.onInstancePatches`, `.onInstanceBound`)
// - type definition symbols (`.defineInstanceKey`)
var proxyKeys$2 = Helpers.assignEverything(Object.create(null), MakeObject.proxyKeys());
type$1(proxyKeys$2);
canReflect_1_16_7_canReflect.assignSymbols(proxyKeys$2, {
	"can.defineInstanceKey": function(prop, value) {
		this[Symbols.metaSymbol].definitions[prop] = value;
	}
});

var makeFunction = {

	observable: function(object, options) {

		if(options.shouldRecordObservation === undefined) {
			options.shouldRecordObservation = MakeObject.shouldRecordObservationOnOwnAndMissingKeys;
		}
		var proxyKeys = Object.create(makeFunction.proxyKeys());

		var meta = {
			target: object,
			proxyKeys: proxyKeys,
			computedKeys: Object.create(null),
			options: options,
			definitions: {},
			isClass: Helpers.isClass(object),
			preventSideEffects: 0
		};

		proxyKeys[Symbols.metaSymbol] = meta;
		meta.proxy = new Proxy(object, {
			get: MakeObject.get.bind(meta),
			set: MakeObject.set.bind(meta),
			ownKeys: MakeObject.ownKeys.bind(meta),
			deleteProperty: MakeObject.deleteProperty.bind(meta),
			construct: makeFunction.construct.bind(meta),
			apply: makeFunction.apply.bind(meta),
			meta: meta
		});

		map$1.addHandlers(meta.proxy, meta);
		type$1.addHandlers(meta.proxy, meta);

		// Store the function and its proxy now, before we
		// convert the prototype and its constructor to proxies.
		ObservableStore.proxiedObjects.set(object, meta.proxy);
		ObservableStore.proxies.add(meta.proxy);

		// Change prototype and its constructor
		if (meta.target.prototype && meta.target.prototype.constructor === meta.target) {
			var newPrototype = MakeObject.observable(meta.target.prototype, {
				getPrototypeOf: function(){
					return meta.target.prototype;
				},
				observe: MakeObserve.observe
			});

			ObservableStore.proxiedObjects.set(meta.target.prototype, newPrototype);
			ObservableStore.proxies.add(newPrototype);

			var prototype = meta.proxy.prototype;
			prototype.constructor = meta.proxy;
		}

		return meta.proxy;
	},
	// `construct` is called when the `new` operator is used.
	// It needs to return an observable instance.
	construct: function(target, argumentsList, newTarget) {
		var instanceTarget, key;
		if (this.isClass) {
			// If the `target` a class, we can't call the function without new. We
			// can create the instance with `Reflect.construct`.
			instanceTarget = Reflect.construct(target, argumentsList, newTarget);
			// Support `can.defineInstanceKey`.
			for (key in this.definitions) {
				Object.defineProperty(instanceTarget, key, this.definitions[key]);
			}
			return this.options.observe(instanceTarget);
		} else {
			// Create an empty object that inherits from the constructor function.
			instanceTarget = Object.create(this.proxy.prototype);
			// Support `can.defineInstanceKey`.
			for (key in this.definitions) {
				Object.defineProperty(instanceTarget, key, this.definitions[key]);
			}
			var instance = this.options.observe(instanceTarget);
			instance[Symbols.metaSymbol].preventSideEffects++;
			var res = target.apply(instance, argumentsList);
			instance[Symbols.metaSymbol].preventSideEffects--;
			if (res) {
				return res;
			} else {
				return instance;
			}
		}
	},
	// `apply` makes sure the function returns an observable.
	apply: function(target, thisArg, argumentsList) {
		var ret = this.target.apply(thisArg, argumentsList);
		return this.options.observe(ret);
	},
	proxyKeys: function() {
		return proxyKeys$2;
	}
};

var MakeFunction = makeFunction;

var TypeHelpers = createCommonjsModule(function (module) {
var canMeta = canSymbol_1_6_1_canSymbol.for("can.meta");
var typeDefinitionsSymbol = canSymbol_1_6_1_canSymbol.for("can.typeDefinitions");

var helpers = module.exports = {
	ensureDefinition: function(prototype) {
		var typeDefs = prototype[typeDefinitionsSymbol];
		if (!typeDefs) {
			var parent = prototype[typeDefinitionsSymbol];
			typeDefs = prototype[typeDefinitionsSymbol] = Object.create(parent || null);
		}

		return typeDefs;
	},
	addMethodsAndSymbols: function(Type) {
		canReflect_1_16_7_canReflect.assignSymbols(Type, {
			"can.defineInstanceKey": function(prop, value) {
				helpers.ensureDefinition(this.prototype)[prop] = value;
			},
			"can.dispatchInstanceBoundChange": function(obj, isBound) {
				var meta = this[canMeta];
				if (meta) {
					var lifecycleHandlers = meta.lifecycleHandlers;
					if (lifecycleHandlers) {
						canQueues_1_1_0_canQueues.enqueueByQueue(lifecycleHandlers.getNode([]), this, [obj, isBound]);
					}
				}
			},
		});
	},
	shouldRecordObservationOnAllKeysExceptFunctionsOnProto: function(keyInfo, meta){
		return meta.preventSideEffects === 0 && !keyInfo.isAccessor && (
			// it's on us
			(keyInfo.targetHasOwnKey ) ||
			// it's "missing", and we are not sealed
			(!keyInfo.protoHasKey && !Object.isSealed(meta.target)) ||
			// it's on our proto, but not a function
			(keyInfo.protoHasKey && (typeof targetValue !== "function"))
		);
	},
};
});
var TypeHelpers_1 = TypeHelpers.ensureDefinition;
var TypeHelpers_2 = TypeHelpers.addMethodsAndSymbols;
var TypeHelpers_3 = TypeHelpers.shouldRecordObservationOnAllKeysExceptFunctionsOnProto;

var definitionsSymbol = canSymbol_1_6_1_canSymbol.for("can.typeDefinitions");



// Setup proxyKeys to look for observations when doing onKeyValue and offKeyValue
var proxyKeys$3 = Helpers.assignEverything({},MakeObject.proxyKeys());
ComputedHelpers.addKeyDependencies(proxyKeys$3);

// ## ObserveObject constructor function
// Works by returning the proxy-wrapped instance.
var ObserveObject = function(props) {
    var prototype = Object.getPrototypeOf(this);

    ComputedHelpers.ensureDefinition(prototype);
    TypeHelpers.ensureDefinition(prototype);

    // Define expando properties from `can.defineInstanceProperty`
    var sourceInstance = this;
    var definitions = prototype[definitionsSymbol] || {};
    for (var key in definitions) {
        Object.defineProperty(sourceInstance, key, definitions[key]);
    }
    // Add properties passed to the constructor.
    if (props !== undefined) {
        canReflect_1_16_7_canReflect.assign(sourceInstance, props);
    }
    // Create a copy of the proxy keys
    var localProxyKeys = Object.create(proxyKeys$3);

    // Make sure that the .constructor property isn't proxied.  If it was,
    // `this.constructor` would not be the type.
    localProxyKeys.constructor = this.constructor;

    // Wrap the sourceInstance
    var observable = MakeObject.observable(sourceInstance, {
        observe: MakeObserve.observe,
        proxyKeys: localProxyKeys,
        shouldRecordObservation: TypeHelpers.shouldRecordObservationOnAllKeysExceptFunctionsOnProto
    });
    // Add the proxy to the stores.
    ObservableStore.proxiedObjects.set(sourceInstance, observable);
    ObservableStore.proxies.add(observable);
    return observable;
};

map$1(ObserveObject.prototype);
type$1(ObserveObject);
ComputedHelpers.addMethodsAndSymbols(ObserveObject);
TypeHelpers.addMethodsAndSymbols(ObserveObject);

// Allows this to be extended w/o `class`
ObserveObject.extend = Helpers.makeSimpleExtender(ObserveObject);



var object = ObserveObject;

// ## can-observe/array/array
//










var definitionsSymbol$1 = canSymbol_1_6_1_canSymbol.for("can.typeDefinitions");

// Setup proxyKeys to look for observations when doing onKeyValue and offKeyValue
var proxyKeys$4 = Helpers.assignEverything({},MakeArray.proxyKeys());

var ObserveArray;
{

    var ObserveArray = function(items) {
        var prototype = Object.getPrototypeOf(this);

        ComputedHelpers.ensureDefinition(prototype);
        TypeHelpers.ensureDefinition(prototype);

        var instance = this;
        var definitions = prototype[definitionsSymbol$1] || {};
        for (var key in definitions) {
            Object.defineProperty(instance, key, definitions[key]);
        }
        this.push.apply(this, items || []);

        var localProxyKeys = Object.create(proxyKeys$4);
        localProxyKeys.constructor = this.constructor;

        var observable = MakeArray.observable(instance, {
            observe: MakeObserve.observe,
            proxyKeys: localProxyKeys,
            shouldRecordObservation: TypeHelpers.shouldRecordObservationOnAllKeysExceptFunctionsOnProto
        });
        ObservableStore.proxiedObjects.set(instance, observable);
        ObservableStore.proxies.add(observable);
        return observable;
    };
    ObserveArray.prototype = Object.create(Array.prototype);
}

map$1(ObserveArray.prototype);
type$1(ObserveArray);
ComputedHelpers.addMethodsAndSymbols(ObserveArray);
TypeHelpers.addMethodsAndSymbols(ObserveArray);

ObserveArray.extend = Helpers.makeSimpleExtender(ObserveArray);



var array = ObserveArray;

// This is an observable that is like `settable`, but passed a `resolve`
// function that can resolve the value of this observable late.
function AsyncObservable$1(fn, context, initialValue) {
	this.resolve = this.resolve.bind(this);
	this.lastSetValue = new canSimpleObservable_2_0_4_canSimpleObservable(initialValue);
	this.handler = this.handler.bind(this);

	function observe() {
		this.resolveCalled = false;

		// set inGetter flag to avoid calling `resolve` redundantly if it is called
		// synchronously in the getter
		this.inGetter = true;
		var newVal = fn.call(
			context,
			this.lastSetValue.get(),
			this.bound === true ? this.resolve : undefined
		);
		this.inGetter = false;

		// if the getter returned a value, resolve with the value
		if (newVal !== undefined) {
			this.resolve(newVal);
		}
		// otherwise, if `resolve` was called synchronously in the getter,
		// resolve with the value passed to `resolve`
		else if (this.resolveCalled) {
			this.resolve(this.value);
		}

		// if bound, the handlers will be called by `resolve`
		// returning here would cause a duplicate event
		if (this.bound !== true) {
			return newVal;
		}
	}

	//!steal-remove-start
	canReflect_1_16_7_canReflect.assignSymbols(this, {
		"can.getName": function() {
			return (
				canReflect_1_16_7_canReflect.getName(this.constructor) +
				"<" +
				canReflect_1_16_7_canReflect.getName(fn) +
				">"
			);
		}
	});
	Object.defineProperty(this.handler, "name", {
		value: canReflect_1_16_7_canReflect.getName(this) + ".handler"
	});
	Object.defineProperty(observe, "name", {
		value: canReflect_1_16_7_canReflect.getName(fn) + "::" + canReflect_1_16_7_canReflect.getName(this.constructor)
	});
	//!steal-remove-end

	this.observation = new canObservation_4_0_1_canObservation(observe, this);
}
AsyncObservable$1.prototype = Object.create(settable$1.prototype);
AsyncObservable$1.prototype.constructor = AsyncObservable$1;

AsyncObservable$1.prototype.handler = function(newVal) {
	if (newVal !== undefined) {
		settable$1.prototype.handler.apply(this, arguments);
	}
};

var peek$5 = canObservationRecorder_1_1_2_canObservationRecorder.ignore(canReflect_1_16_7_canReflect.getValue.bind(canReflect_1_16_7_canReflect));
AsyncObservable$1.prototype.activate = function() {
	canReflect_1_16_7_canReflect.onValue(this.observation, this.handler, "notify");
	if (!this.resolveCalled) {
		this.value = peek$5(this.observation);
	}
};

AsyncObservable$1.prototype.resolve = function resolve(newVal) {
	this.resolveCalled = true;
	var old = this.value;
	this.value = newVal;

	//!steal-remove-start
	if (typeof this._log === "function") {
		this._log(old, newVal);
	}
	//!steal-remove-end

	// if resolve was called synchronously from the getter, do not enqueue changes
	// the observation will handle calling resolve again if required
	if (!this.inGetter) {
		// adds callback handlers to be called w/i their respective queue.
		canQueues_1_1_0_canQueues.enqueueByQueue(
			this.handlers.getNode([]),
			this,
			[newVal, old],
			null
			//!steal-remove-start
			/* jshint laxcomma: true */
			, [canReflect_1_16_7_canReflect.getName(this), "resolved with", newVal]
			/* jshint laxcomma: false */
			//!steal-remove-end
		);
	}
};

var async$1 = AsyncObservable$1;

var getChangesSymbol$3 = canSymbol_1_6_1_canSymbol.for("can.getChangesDependencyRecord");

function ResolverObservable$1(resolver, context) {
	this.resolver = resolver;
	this.context = context;
	this.valueOptions = {
		resolve: this.resolve.bind(this),
		listenTo: this.listenTo.bind(this),
		stopListening: this.stopListening.bind(this),
		lastSet: new canSimpleObservable_2_0_4_canSimpleObservable(undefined)
	};

	this.update = this.update.bind(this);

	this.contextHandlers = new WeakMap();
	this.teardown = null;
	// a place holder for remembering where we bind
	this.binder = {};
	//!steal-remove-start
	canReflect_1_16_7_canReflect.assignSymbols(this, {
		"can.getName": function() {
			return (
				canReflect_1_16_7_canReflect.getName(this.constructor) +
				"<" +
				canReflect_1_16_7_canReflect.getName(resolver) +
				">"
			);
		}
	});
	Object.defineProperty(this.update, "name", {
		value: canReflect_1_16_7_canReflect.getName(this) + ".update"
	});

	canReflect_1_16_7_canReflect.assignSymbols(this.valueOptions.lastSet, {
		"can.getName": function() {
			return (
				canReflect_1_16_7_canReflect.getName(this.constructor)  +"::lastSet"+
				"<" +
				canReflect_1_16_7_canReflect.getName(resolver) +
				">"
			);
		}
	});
	//!steal-remove-end
}
ResolverObservable$1.prototype = Object.create(settable$1.prototype);

function deleteHandler$1(bindTarget, event, queue, handler){
	map$1.off.call(bindTarget, event, handler, queue);
}

canReflect_1_16_7_canReflect.assignMap(ResolverObservable$1.prototype, {
	constructor: ResolverObservable$1,
	listenTo: function(bindTarget, event, handler, queueName) {
		//Object.defineProperty(this.handler, "name", {
		//	value: canReflect.getName(this) + ".handler"
		//});
		if(canReflect_1_16_7_canReflect.isPrimitive(bindTarget)) {
			handler = event;
			event = bindTarget;
			bindTarget = this.context;
		}
		if(typeof event === "function") {
			handler = event;
			event = undefined;
		}

		var resolverInstance = this;

		//!steal-remove-start
		if(!handler.name) {
			Object.defineProperty(handler, "name", {
				value:
					(bindTarget ?
						 canReflect_1_16_7_canReflect.getName(bindTarget) : "")+
					 (event ? ".on('"+event+"',handler)" : ".on(handler)")+
					 "::"+canReflect_1_16_7_canReflect.getName(this)
			});
		}
		//!steal-remove-end

		var contextHandler = handler.bind(this.context);
		contextHandler[getChangesSymbol$3] = function getChangesDependencyRecord() {
			return {
				valueDependencies: new Set([ resolverInstance ])
			};
		};

		this.contextHandlers.set(handler, contextHandler);
		map$1.listenTo.call(this.binder, bindTarget, event, contextHandler, queueName || "notify");
	},
	stopListening: function(){

		var meta = this.binder[canSymbol_1_6_1_canSymbol.for("can.meta")];
		var listenHandlers = meta && meta.listenHandlers;
		if(listenHandlers) {
			var keys = map$1.stopListeningArgumentsToKeys.call({context: this.context, defaultQueue: "notify"});

			listenHandlers.delete(keys, deleteHandler$1);
		}
		return this;
	},
	resolve: function(newVal) {
		this.value = newVal;
		// if we are setting up the initial binding and we get a resolved value
		// do not emit events for it.

		if(this.isBinding) {
			this.lastValue = this.value;
			return newVal;
		}

		if(this.value !== this.lastValue) {
			canQueues_1_1_0_canQueues.batch.start();
			canQueues_1_1_0_canQueues.deriveQueue.enqueue(
				this.update,
				this,
				[],
				{
					//!steal-remove-start
					/* jshint laxcomma: true */
					log: [canReflect_1_16_7_canReflect.getName(this.update)],
					reasonLog: [canReflect_1_16_7_canReflect.getName(this), "resolved with", newVal]
					/* jshint laxcomma: false */
					//!steal-remove-end
				}
			);
			canQueues_1_1_0_canQueues.batch.stop();
		}
		return newVal;
	},
	update: function(){

		if(this.lastValue !== this.value) {

			var old = this.lastValue;
			this.lastValue = this.value;
			//!steal-remove-start
			if (typeof this._log === "function") {
				this._log(old, this.value);
			}
			//!steal-remove-end

			// adds callback handlers to be called w/i their respective queue.
			canQueues_1_1_0_canQueues.enqueueByQueue(
				this.handlers.getNode([]),
				this,
				[this.value, old]
			);
		}
	},
	activate: function() {
		this.isBinding = true;
		this.teardown = this.resolver.call(this.context, this.valueOptions);
		this.isBinding = false;
	},
	onUnbound: function() {
		this.bound = false;
		map$1.stopListening.call(this.binder);
		if(this.teardown != null) {
			this.teardown();
			this.teardown = null;
		}
	},
	set: function(value) {
		this.valueOptions.lastSet.set(value);

		/*if (newVal !== this.lastSetValue.get()) {
			this.lastSetValue.set(newVal);
		}*/
	},
	get: function() {
		if (canObservationRecorder_1_1_2_canObservationRecorder.isRecording()) {
			canObservationRecorder_1_1_2_canObservationRecorder.add(this);
			if (!this.bound) {
				this.onBound();
			}
		}

		if (this.bound === true) {
			return this.value;
		} else {
			var handler = function(){};
			this.on(handler);
			var val = this.value;
			this.off(handler);
			return val;
		}
	},
	hasDependencies: function hasDependencies() {
		var hasDependencies = false;

		if (this.bound) {
			var meta = this.binder[canSymbol_1_6_1_canSymbol.for("can.meta")];
			var listenHandlers = meta && meta.listenHandlers;
			hasDependencies = !!listenHandlers.size();
		}

		return hasDependencies;
	},
	getValueDependencies: function getValueDependencies() {
		if (this.bound) {
			var meta = this.binder[canSymbol_1_6_1_canSymbol.for("can.meta")];
			var listenHandlers = meta && meta.listenHandlers;

			var keyDeps = new Map();
			var valueDeps = new Set();

			if (listenHandlers) {
				canReflect_1_16_7_canReflect.each(listenHandlers.root, function(events, obj) {
					canReflect_1_16_7_canReflect.each(events, function(queues, eventName) {
						if (eventName === undefined) {
							valueDeps.add(obj);
						} else {
							var entry = keyDeps.get(obj);
							if (!entry) {
								entry = new Set();
								keyDeps.set(obj, entry);
							}
							entry.add(eventName);
						}
					});
				});

				if (valueDeps.size || keyDeps.size) {
					var result = {};

					if (keyDeps.size) {
						result.keyDependencies = keyDeps;
					}
					if (valueDeps.size) {
						result.valueDependencies = valueDeps;
					}

					return result;
				}
			}
		}
	}
});

canReflect_1_16_7_canReflect.assignSymbols(ResolverObservable$1.prototype, {
	"can.getValue": ResolverObservable$1.prototype.get,
	"can.setValue": ResolverObservable$1.prototype.set,
	"can.isMapLike": false,
	"can.getPriority": function() {
		// TODO: the priority should come from any underlying values
		return this.priority || 0;
	},
	"can.setPriority": function(newPriority) {
		this.priority = newPriority;
	},
	"can.valueHasDependencies": ResolverObservable$1.prototype.hasDependencies,
	"can.getValueDependencies": ResolverObservable$1.prototype.getValueDependencies
});


var resolver$1 = ResolverObservable$1;

function defineProperty(prototype, prop, makeObservable) {
	ComputedHelpers.ensureDefinition(prototype)[prop] = makeObservable;
}

function asyncBase(config) {
	return function(target, key, descriptor) {
		if (descriptor.get !== undefined) {
			var getter = descriptor.get;
			//!steal-remove-start
			if (getter.length !== 0) {
				throw new Error("async decorated " + key + " on " + canReflect_1_16_7_canReflect.getName(target) + ": getters should take no arguments.");
			}
			//!steal-remove-end

			return defineProperty(target, key, function(instance, property) {
				function fn(lastSet, resolve) {
					if (!resolve) {
						return config.default;
					}

					var promise = getter.call(this, true);
					if (canReflect_1_16_7_canReflect.isPromise(promise)) {
						promise.then(resolve);
						return config.default;
					}
					//!steal-remove-start
					else if (promise !== undefined) {
						throw new Error("async decorated " + key + " on " + canReflect_1_16_7_canReflect.getName(target) + ": getters must return undefined or a promise.");
					}
					//!steal-remove-end
				}

				//!steal-remove-start
				canReflect_1_16_7_canReflect.assignSymbols(fn, {
					"can.getName": function() {
						return canReflect_1_16_7_canReflect.getName(getter);					},
				});
				//!steal-remove-end

				return new async$1(fn, instance, config.default);
			});
		}

		if (descriptor.value !== undefined) {
			var method = descriptor.value;
			//!steal-remove-start
			if (method.length !== 1) {
				throw new Error("async decorated " + key + " on " + canReflect_1_16_7_canReflect.getName(target) + ": methods should take 1 argument (resolve).");
			}
			//!steal-remove-end

			return defineProperty(target, key, function(instance, property) {
				return new async$1(function(lastSet, resolve) {
					return method.call(this, resolve);
				}, instance, config.default);
			});
		}

		//!steal-remove-start
		throw new Error("async decorated " + key + " on " + canReflect_1_16_7_canReflect.getName(target) + ": Unrecognized descriptor.");
		//!steal-remove-end
	};
}

function resolverBase(config) {
	return function(target, key, descriptor) {
		if (descriptor.value !== undefined) {
			var method = descriptor.value;
			//!steal-remove-start
			if (method.length !== 1) {
				throw new Error("resolver decorated " + key + " on " + canReflect_1_16_7_canReflect.getName(target) + ": methods should take 1 argument (value).");
			}
			//!steal-remove-end

			return defineProperty(target, key, function(instance, property) {
				return new resolver$1(method, instance);
			});
		}

		//!steal-remove-start
		throw new Error("resolver decorated " + key + " on " + canReflect_1_16_7_canReflect.getName(target) + ": Unrecognized descriptor.");
		//!steal-remove-end
	};
}

function optionalConfig(decorator) {
	function wrapper(config) {
		if (arguments.length === 3) {
			return decorator({}).apply(null, arguments);
		}

		return decorator(config);
	}

	//!steal-remove-start
	Object.defineProperty(wrapper, "name", {
		value: canReflect_1_16_7_canReflect.getName(decorator.name)
	});
	//!steal-remove-end

	return wrapper;
}

var decorators = {
	async: optionalConfig(asyncBase),
	resolver: optionalConfig(resolverBase),
};

var canObserve_2_1_3_canObserve = createCommonjsModule(function (module) {
// # can-observe.js
// Assembles the final observe export.










MakeObserve.object = function(object$$1) {
	return MakeObject.observable(object$$1, MakeObserve);
};
MakeObserve.array = function(array$$1) {
	return MakeArray.observable(array$$1, MakeObserve);
};
MakeObserve.function = function(array$$1) {
	return MakeFunction.observable(array$$1, MakeObserve);
};
MakeObserve.observe.Object = object;
MakeObserve.observe.Array = array;

module.exports = MakeObserve.observe;

module.exports.defineProperty = function(prototype, prop, makeObservable) {
	ComputedHelpers.ensureDefinition(prototype)[prop] = makeObservable;
};

for (var key in decorators) {
	module.exports[key] = decorators[key];
}
});
var canObserve_2_1_3_canObserve_1 = canObserve_2_1_3_canObserve.defineProperty;

var stringToAny$1 = function(str){
	switch(str) {
		case "NaN":
		case "Infinity":
			return +str;
		case "null":
			return null;
		case "undefined":
			return undefined;
		case "true":
		case "false":
			return str === "true";
		default:
			var val = +str;
			if(!isNaN(val)) {
				return val;
			} else {
				return str;
			}
	}
};

/**
 * @module {function} can-util/js/make-array/make-array make-array
 * @parent can-util/js
 * @signature `makeArray(element)`
 * @param  {ArrayLike|Object} element any array-like or object data structure
 * @return {Array}     a JavaScript array object with the same elements as the passed-in ArrayLike
 *
 * makeArray takes any array-like object (can-list, NodeList, etc.) and converts it to a JavaScript array
 * 
 * ```
 * var makeArray = require("can-util/js/make-array/make-array");
 * 
 * makeArray({0: "a", length: 1}); //-> ["a"]
 * 
 * ```
 */
function makeArray$2(element) {
	var ret = [];
	if (isArrayLike_1(element)) {
		each_1(element, function (a, i) {
			ret[i] = a;
		});
	} else if(element === 0 || element) {
		ret.push(element);
	}
	return ret;
}

var makeArray_1 = makeArray$2;

//var canDev = require("can-log/dev/dev");

/**
 * @module can-util/js/dev/dev dev
 * @parent deprecated
 * @description Deprecated. Use [can-dev] instead.
 */

 //!steal-remove-start
//  canDev.warn('js/dev/dev is deprecated; please use can-log/dev/dev instead: https://github.com/canjs/can-log');
 //!steal-remove-end

var dev$3 = dev;

canStache_4_5_10_canStache.registerConverter("boolean-to-inList", {
	get: function(item, list){
		if(!list) {
			return false;
		} else {
			return list.indexOf(item) !== -1;
		}
	},
	set: function(newVal, item, list){
		if(!list) {
			return;
		}
		if(!newVal) {
			var idx = list.indexOf(item);
			if(idx !== -1) {
				list.splice(idx, 1);
			}
		} else {
			list.push(item);
		}
	}
});

canStache_4_5_10_canStache.addConverter("string-to-any", {
	get: function(obs){
		return "" + canReflect_1_16_7_canReflect.getValue(obs);
	},
	set: function(newVal, obs){
		var converted = stringToAny$1(newVal);
		canReflect_1_16_7_canReflect.setValue(obs, converted);
	}
});

canStache_4_5_10_canStache.addConverter("not", {
	get: function(obs){
		return !canReflect_1_16_7_canReflect.getValue(obs);
	},
	set: function(newVal, obs){
		canReflect_1_16_7_canReflect.setValue(obs, !newVal);
	}
});

canStache_4_5_10_canStache.addConverter("index-to-selected", {
	get: function(item, list){
		var val = canReflect_1_16_7_canReflect.getValue(item);
		var idx = canReflect_1_16_7_canReflect.getValue(list).indexOf(val);
		return idx;
	},
	set: function(idx, item, list){
		var newVal = canReflect_1_16_7_canReflect.getValue(list)[idx];
		canReflect_1_16_7_canReflect.setValue(item, newVal);
	}
});

canStache_4_5_10_canStache.addConverter("selected-to-index", {
	get: function(idx, list){
		var val = canReflect_1_16_7_canReflect.getValue(idx),
			listValue = canReflect_1_16_7_canReflect.getValue(list);
		var item = listValue[val];
		return item;
	},
	set: function(item, idx, list){
		var newVal = canReflect_1_16_7_canReflect.getValue(list).indexOf(item);
		canReflect_1_16_7_canReflect.setValue(idx, newVal);
	}
});

canStache_4_5_10_canStache.addConverter("either-or", {
	get: function(chosen, a, b){
		var chosenVal = canReflect_1_16_7_canReflect.getValue(chosen),
			aValue = canReflect_1_16_7_canReflect.getValue(a),
			bValue = canReflect_1_16_7_canReflect.getValue(b);
		var matchA = (aValue === chosenVal);
		var matchB = (bValue === chosenVal);

		if (!matchA && !matchB) {
			//!steal-remove-start
			dev$3.warn(
				"can-stache-converter.either-or:",
				"`" + chosenVal + "`",
				"does not match `" + aValue + "`",
				"or `" + bValue + "`"
			);
			//!steal-remove-end

			return;
		}
		else {
			return matchA;
		}
	},
	set: function(newVal, chosen, a, b){
		var setVal = newVal ? canReflect_1_16_7_canReflect.getValue(a) : canReflect_1_16_7_canReflect.getValue(b);
		canReflect_1_16_7_canReflect.setValue(chosen, setVal);
	}
});

canStache_4_5_10_canStache.addConverter("equal", {
	get: function(){
		var args = makeArray_1(arguments);
		// We don't need the helperOptions
		args.pop();
		if (args.length > 1) {
			var comparer = canReflect_1_16_7_canReflect.getValue( args.pop() );

			return args.every(function(obs) {
				var value = canReflect_1_16_7_canReflect.getValue(obs);
				return value === comparer;
			});
		}
	},
	set: function(){
		var args = makeArray_1(arguments);
		// Ignore the helperOptions
		args.pop();
		if (args.length > 2) {
			var b = args.shift();
			var comparer = args.pop();
			if(b) {
				for(var i = 0; i < args.length; i++) {
					canReflect_1_16_7_canReflect.setValue(args[i], comparer);
				}
			}
		}
	}
});

var canStacheConverters_4_0_2_canStacheConverters = {

};

var isNode$1 = typeof process !== "undefined" && {}.toString.call(process) === "[object process]";
var nodeRequire = typeof System !== "undefined" && System._nodeRequire ?
	System._nodeRequire : typeof commonjsRequire === "function" ? commonjsRequire : function(){};
var isNW = isNode$1 && (function(){
  try {
	return nodeRequire("nw.gui") !== "undefined";
  } catch(e) {
	return false;
  }
})();
var isWorker = typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope;
var g = isWorker ?
	self :
	isNW ? window :
	isNode$1 ? commonjsGlobal : window;

var isNode_1 = isNode$1;
var isNW_1 = isNW;
var isWorker_1 = isWorker;
var global_1$1 = g;

var env = {
	isNode: isNode_1,
	isNW: isNW_1,
	isWorker: isWorker_1,
	global: global_1$1
};

var forEach$3 = Array.prototype.forEach || function(fn){
	for(var i = 0, len = this.length; i < len; i++) {
		fn.call(this, this[i], i);
	}
};

var supportsSymbol = typeof Symbol === "function";
var symbol = function(str){
	return supportsSymbol ? Symbol(str) : str;
};

var defineProperty$1 = function(obj, prop, defn){
	if(Object.defineProperty) {
		Object.defineProperty(obj, prop, defn);
	} else {
		obj[prop] = defn.value;
	}
};

var util$1 = {
	forEach: forEach$3,
	symbol: symbol,
	defineProperty: defineProperty$1
};

var g$1 = env.global;

var globals = function(){
	var globals, overrides = [];

	return {
		name: "globals",
		plugins: [promiseZone],
		created: function(){
			globals = this.globals || {};

			function findObj(name, obj){
				var parts = name.split(".");
				var property = parts.pop();
				util$1.forEach.call(parts, function(prop){
					var n = obj[prop];
					if(!n) {
						n = obj[prop] = {};
					}
					obj = n;
				});
				return {
					obj: obj,
					prop: property
				};
			}

			// Turn globals into overrides
			function addGlobal(name, value){
				var info = findObj(name, g$1);

				overrides.push(new Override(info.obj, info.prop, function(){
					return value;
				}));
			}
			for(var name in globals) {
				addGlobal(name, globals[name]);
			}
		},

		beforeTask: function(task){
			if(task.nestedTask) return;
			util$1.forEach.call(overrides, function(o){
				o.trap();
			});
		},

		afterTask: function(task){
			if(task.nestedTask) return;
			util$1.forEach.call(overrides, function(o){
				o.release();
			});
		}
	};
};

function Override(obj, name, fn) {
	this.oldValue = obj[name];
	this.obj = obj;
	this.name = name;
	this.value = fn(this.oldValue, this);
}

Override.prototype.trap = function(){
	this.obj[this.name] = this.value;
};

Override.prototype.release = function(){
	this.obj[this.name] = this.oldValue;
};

function promiseZone(){
	var promiseThen = function(){
		if(!zone.current || oldPromiseThen.zoneWrapped) {
			return oldPromiseThen.apply(this, arguments);
		}
		return zone.tasks.then(oldPromiseThen).apply(this, arguments);
	}, oldPromiseThen;

	return {
		beforeTask: function(task){
			if(task.nestedTask) return;
			oldPromiseThen = Promise.prototype.then;
			Promise.prototype.then = promiseThen;
		},
		afterTask: function(task){
			if(task.nestedTask) return;
			Promise.prototype.then = oldPromiseThen;
		}
	};

}

var canZone_0_6_20_register = createCommonjsModule(function (module) {
"format cjs";
(function(){
	var isNode = typeof process !== "undefined" && {}.toString.call(process) === "[object process]";
	var isWorker = typeof WorkerGlobalScope !== "undefined" &&
		typeof self !== "undefined" &&
		self instanceof WorkerGlobalScope;
	var g = typeof WorkerGlobalScope !== "undefined" && (self instanceof WorkerGlobalScope)
		? self
		: isNode
		? commonjsGlobal
		: window;

	if(!!module.exports) {
		module.exports = wrapAll;
	}

	var forEach = Array.prototype.forEach || function(cb){
		var i = 0, len = this.length;
		for(; i < len; i++) {
			cb.call(this, this[i], i);
		}
	};

	var props = Array.prototype.concat.call(
		[
			"setTimeout",
			"clearTimeout",
			"requestAnimationFrame",
			"cancelAnimationFrame",
			"Promise.prototype.then",
			"XMLHttpRequest.prototype.send",
			"Node.prototype.addEventListener",
			"Node.prototype.removeEventListener",
			"process.nextTick",
			"setImmediate",
			"clearImmediate",
			{
				prop: "MutationObserver",
				fn: function(MutationObserver) {
					return function(fn) {
						return new MutationObserver(fn);
					};
				}
			}
		],

		// add all event handlers methods like `onclick` and `onload`.
		getGlobalEventHandlersNames().map(function(name) {
			return "HTMLElement.prototype." + name;
		})
	);

	wrapAll(g);

	if(g.Promise) {
		monitor(g, "Promise", "Promise.prototype.then", g);
	}

	function extract(obj, prop) {
		var parts = prop.split(".");
		while(parts.length > 1) {
			prop = parts.shift();
			obj = obj[prop];
			if(!obj) break;
			if(parts.length === 1) prop = parts[0];
		}
		return [obj, prop];
	}

	function wrapAll(globalObj){
		var global = globalObj || g;

		var wrapped = global.__canZoneWrapped;
		if(!wrapped) {
			wrapped = global.__canZoneWrapped = {};
		}

		forEach.call(props, function(prop){
			var fn;
			if(typeof prop === "object") {
				fn = prop.fn;
				prop = prop.prop;
			}

			var key = prop;

			// If this has already been wrapped
			if(wrapped[key]) {
				return;
			}

			var results = extract(global, prop);
			var obj = results[0];
			prop = results[1];

			// This happens if the environment doesn't support this property
			// obj[prop] throws Illegal invocation when prop is an event handler
			if(!isGlobalEventHandler(prop) && (!obj || !obj[prop])) {
				return;
			} else {
				wrapped[key] = true;
			}

			wrapInZone(obj, prop, fn, global);
		});
	}

	function wrapInZone(object, property, fn, global) {
		var wrappedFn = function() {
			var Zone = global.CanZone;
			if (typeof Zone !== "undefined" && !!Zone.current) {
				return Zone.tasks[property](fn, Zone).apply(this, arguments);
			}

			return fn.apply(this, arguments);
		};

		var descriptor = Object.getOwnPropertyDescriptor(object, property) || {};

		if (isGlobalEventHandler(property)) {
			fn = descriptor.set;
			descriptor.set = wrappedFn;
		} else {
			fn = fn ? fn(object[property]) : object[property];
			descriptor.value = wrappedFn;
			descriptor.writable = true;	// fix: allow third-party libraries to also wrap functions
		}

		Object.defineProperty(object, property, descriptor);
		wrappedFn.zoneWrapped = true;
	}

	function isGlobalEventHandler(property) {
		return property.substr(0, 2) === "on";
	}

	// Returns an array of global event handlers names
	// https://developer.mozilla.org/en-US/docs/Web/API/GlobalEventHandlers
	function getGlobalEventHandlersNames() {
		var names = [];

		if (!isNode && !isWorker) {
			names = Object.getOwnPropertyNames(HTMLElement.prototype).filter(
				isGlobalEventHandler
			);
		}

		return names;
	}

	function monitor(object, property, thingToRewrap, global) {
		var current = object[property];

		Object.defineProperty(object, property, {
			get: function(){
				return current;
			},
			set: function(val){
				var hasChanged = !val.zoneWrapped && val !== current;
				current = val;

				if(hasChanged) {
					var results = extract(object, thingToRewrap);
					var localObject = results[0];
					var localProperty = results[1];
					wrapInZone(localObject, localProperty, null, global);
					monitor(object, property, thingToRewrap, global);
				}
			}
		});
	}

})();
});

var tasks = createCommonjsModule(function (module, exports) {
var slice = Array.prototype.slice;

var isWorker = typeof WorkerGlobalScope !== "undefined" &&
              typeof self !== "undefined" &&
              self instanceof WorkerGlobalScope;

if(env.isNode) {
	var globalTimeoutId = 1;
}

var addTimer = function(callback, Zone){
	var timeoutId = callback();
	var id = timeoutId;
	if(env.isNode && typeof id !== "number") {
		id = timeoutId.__timeoutId = globalTimeoutId++;
	}
	var zone = Zone.current;
	if(!zone.isResolved) {
		zone.ids[id] = timeoutId;
	}
	return {
		timeoutId: timeoutId,
		id: id
	};
};

var removeTimer = function(timeoutId, callback, Zone){
	// If no timeoutId is passed just call the parent
	// https://developer.mozilla.org/en-US/docs/Web/API/WindowTimers/clearTimeout#Notes
	if(timeoutId == null) {
		return callback();
	}
	var zone = Zone.current;
	var ids = zone.ids;
	var id = (env.isNode && typeof timeoutId !== "number") ?
		timeoutId.__timeoutId : timeoutId;
	if(!zone.isResolved && ids[id]) {
		delete ids[id];
		zone.removeWait();
	}
	return callback();
};

var getGlobalEventHandlersNames = function getGlobalEventHandlersNames() {
	var names = [];

	if (!env.isNode && !isWorker) {
		names = Object.getOwnPropertyNames(HTMLElement.prototype).filter(
			function isGlobalEventHandler(name) {
				return name.substr(0, 2) === "on";
			}
		);
	}

	return names;
};

var defineSetTask = function defineSetTask(set, Zone) {
	return function setTask(newValue) {
		if (newValue) {
			var outHandler = newValue[EVENT_HANDLER];

			if (outHandler === undefined) {
				outHandler = Zone.current.wrap(newValue);
				newValue[EVENT_HANDLER] = outHandler;
			}

			set.call(this, outHandler);
		} else {
			set.call(this, newValue);
		}
	};
};

// Add tasks to wrap event handlers set using `.on[eventname] = handler` syntax
// e.g: `el.onclick = function doSomething() {};`
getGlobalEventHandlersNames().forEach(function(name) {
	exports[name] = defineSetTask;
});

exports.setTimeout = function(setTimeout, Zone){
	return function(fn, timeout){
		var args = Array.prototype.slice.call(arguments);
		var zone = Zone.current;
		var idInfo;
		args[0] = zone.waitFor(function(){
			delete zone.ids[idInfo.id];
			return fn.apply(this, arguments);
		});

		var self = this;
		idInfo = addTimer(function(){
			return setTimeout.apply(self, args);
		}, Zone);

		return idInfo.timeoutId;
	};
};

exports.clearTimeout = function(clearTimeout, Zone){
	return function(timeoutId){
		var args = arguments, self = this;
		return removeTimer(timeoutId, function(){
			return clearTimeout.apply(self, args);
		}, Zone);
	};
};

exports.setImmediate = function(setImmediate, Zone){
	return function(fn){
		var idInfo;
		var zone = Zone.current;
		var callback = zone.waitFor(function(){
			delete zone.ids[idInfo.id];
			return fn.apply(this, arguments);
		});

		var self = this, args = slice.call(arguments, 1);
		idInfo = addTimer(function(){
			return setImmediate.apply(self, [callback].concat(args));
		}, Zone);
		return idInfo.timeoutId;
	};
};

exports.clearImmediate = function(clearImmediate, Zone){
	return function(immediateId){
		var args = arguments, self = this;
		return removeTimer(immediateId, function(){
			return clearImmediate.apply(self, args);
		}, Zone);
	};
};

exports.requestAnimationFrame = function(rAF, Zone){
	return function(fn){
		var zone = Zone.current;
		var callback = zone.waitFor(fn);
		var id = rAF.call(this, callback);
		zone.rafs[id] = true;
		return id;
	};
};

exports.cancelAnimationFrame = function(cAF, Zone){
	return function(id){
		var zone = Zone.current;
		var ids = zone.rafs;
		var res = cAF.call(this, id);
		if(!zone.isResolved && ids[id]) {
			delete ids[id];
			zone.removeWait();
		}
		return res;
	};
};

exports.then = function(then, Zone){
	return function(onFulfilled, onRejected){
		var fn;
		var rejected;
		var callback = Zone.current.waitFor(function(val){
			if(fn) {
				return fn.apply(this, arguments);
			} else if(rejected) {
				return Promise.reject(val);
			}
			return val;
		}, false);

		var callWith = function(cb, isError){
			return function(){
				fn = cb;
				rejected = !!isError;
				return callback.apply(this, arguments);
			};
		};

		return then.call(this, callWith(onFulfilled),
						 callWith(onRejected, true));
	};
};

var supportsOnload = undefined;
exports.send = function(send, Zone){
	if(typeof supportsOnload === "undefined") {
		supportsOnload = ("onload" in new XMLHttpRequest());
	}

	return function(){
		var onreadystatechange = this.onreadystatechange,
			onload = this.onload,
			onerror = this.onerror,
			thisXhr = this,
			zone = Zone.current;

		zone.addWait();

		if(supportsOnload && this.onload) {
			this.onload = createCallback(onload);
			this.onerror = createCallback(onerror);
		} else {
			onreadystatechange = onreadystatechange || function(){};
			var callback = createCallback(onreadystatechange);
			this.onreadystatechange = function(ev){
				var xhr = ev ? ev.target : thisXhr;

				if(xhr.readyState === 4) {
					return callback.apply(this, arguments);
				} else {
					return onreadystatechange.apply(this, arguments);
				}
			};
		}

		function createCallback(fn){
			fn = fn || function(){};
			return function(){
				var task = new Zone.Task(zone, fn);
				var res = task.run(this, arguments);
				zone.removeWait();
				return res;
			};
		}

		return send.apply(this, arguments);
	};
};

exports.nextTick = function(nextTick, Zone){
	return function(fn/*, ...args */){
		var callback = Zone.current.waitFor(fn);
		var args = slice.call(arguments, 1);
		args.unshift(callback);
		return nextTick.apply(process, args);
	};
};

exports.MutationObserver = function(MutationObserver, Zone){
	return function(fn){
		fn = Zone.current.wrap(fn);
		return new MutationObserver(fn);
	};
};

var EVENT_HANDLER = util$1.symbol("zone-eventhandler");

exports.addEventListener = function(addEventListener, Zone){
	return function(eventName, handler, useCapture){
		var outHandler = handler[EVENT_HANDLER];
		if(outHandler === undefined) {
			outHandler = Zone.current.wrap(handler);
			handler[EVENT_HANDLER] = outHandler;
		}

		return addEventListener.call(this, eventName, outHandler, useCapture);
	};
};

exports.removeEventListener = function(removeEventListener, Zone){
	return function(eventName, handler, useCapture){
		var outHandler = handler && handler[EVENT_HANDLER] || handler;
		return removeEventListener.call(this, eventName, outHandler, useCapture);
	};
};
});
var tasks_1 = tasks.setTimeout;
var tasks_2 = tasks.clearTimeout;
var tasks_3 = tasks.setImmediate;
var tasks_4 = tasks.clearImmediate;
var tasks_5 = tasks.requestAnimationFrame;
var tasks_6 = tasks.cancelAnimationFrame;
var tasks_7 = tasks.then;
var tasks_8 = tasks.send;
var tasks_9 = tasks.nextTick;
var tasks_10 = tasks.MutationObserver;
var tasks_11 = tasks.addEventListener;
var tasks_12 = tasks.removeEventListener;

var zone = createCommonjsModule(function (module) {
var g = env.global;

// Keep a local reference since we will be overriding this later.
var Promise = g.Promise;


var forEach = util$1.forEach;


var slice = Array.prototype.slice;
var noop = function(){};

function Deferred(){
	var dfd = this;
	this.promise = new Promise(function(resolve, reject){
		dfd.resolve = resolve;
		dfd.reject = reject;
	});
}

function Task(zone, fn, catchErrors){
	this.zone = zone;
	this.fn = fn;
	this.catchErrors = catchErrors;
	this.nestedTask = zone.runningTask;
}

Task.prototype.run = function(ctx, args){
	var Zone = this.zone.constructor;
	var previousZone = Zone.current;
	var zone = Zone.current = this.zone;
	if(!this.nestedTask)
		zone.execHook("beforeTask", this);

	var res;
	try {
		zone.runningTask = true;
		res = this.fn.apply(ctx, args);
		Zone.current = previousZone;
		if(!this.nestedTask)
			zone.execHookR("afterTask", this);
	} catch(err) {
		Zone.current = previousZone;
		if(!this.nestedTask)
			zone.execHookR("afterTask", this);
		if(this.catchErrors !== false) {
			zone.errors.push(err);
		} else {
			throw err;
		}
	} finally {
		// If this is a nested task (a task run synchronously then this will
		// remain as true
		zone.runningTask = this.nestedTask;
	}

	return res;
};

var hooks = [
	"beforeTask",
	"afterTask",
	"created",
	"ended",
	"beforeRun",
	"afterRun"
];

var commonGlobals = [
	"document",
	"window",
	"location"
];

function buildZoneSpec(zone, spec, plugins, processedSpecs){
	spec = spec || {};

	// Check and see if this has already run (if a plugin is used by
	// more than 1 other plugins
	processedSpecs = processedSpecs || [];
	if(processedSpecs.indexOf(spec) !== -1) {
		return;
	} else {
		processedSpecs.push(spec);
	}

	plugins = plugins || [];
	if(typeof spec === "function") {
		spec = spec(zone.data);
	} else if(Array.isArray(spec)) {
		spec = { plugins: spec };
	}

	// Depth-first, call all of the plugins.
	if(spec.plugins){
		plugins = plugins.concat(spec.plugins);
	}
	forEach.call(plugins, function(plugin){
		buildZoneSpec(zone, plugin, null, processedSpecs);
	});

	if(spec.hooks) {
		zone.hooks = zone.hooks.concat(spec.hooks);
	}

	forEach.call(zone.hooks, function(hook){
		var propName = hook + "s";
		var array = zone[propName];
		if(!array) {
			array = zone[propName] = [];
		}

		if(spec[hook]) {
			array.push(spec[hook]);
		}
	});

	var globals$$1 = extend({}, spec.globals || {});
	// Add in the common globals that can go directly on the spec
	forEach.call(commonGlobals, function(name){
		if(spec[name]) globals$$1[name] = spec[name];
	});
	for(var p in globals$$1) {
		zone.globals[p] = globals$$1[p];
	}
}

function Zone(spec) {
	spec = spec || {};
	this.deferred = new Deferred();
	this.waits = 0;
	this.ids = Object.create(null);
	this.rafs = Object.create(null);
	this.errors = [];
	this.data = {};
	this.globals = {};
	this.parent = this.constructor.current;
	this.hooks = slice.call(hooks);

	buildZoneSpec(this, spec, [globals]);

	this.execHook("created");
}

Zone.waitFor = function(fn, catchErrors){
	var fun = fn || noop;
	var zone = this.current;
	if(!zone) return fun;
	return zone.waitFor(fun, catchErrors);
};

Zone.error = function(error){
	var zone = this.current;
	if(!zone) return error;
	zone.errors.push(error);
	return error;
};

Zone.ignore = function(fn){
	var Zone = this;
	return function(){
		var zone = Zone.current;
		if(!zone) return fn.apply(this, arguments);

		// Use the original versions
		var task = new Task(zone);

		Zone.current = undefined;
		zone.execHookR("afterTask", task);
		var res = fn.apply(this, arguments);
		zone.execHook("beforeTask", task);
		Zone.current = zone;
		return res;
	};
};

Zone.prototype.runTask = function(fn, ctx, args, catchErrors, decrementWaits){
	var res, error;
	var task = new Task(this, fn, catchErrors);
	try {
		res = task.run(ctx, args);
	} catch(err) {
		error = err;
	}
	if(decrementWaits && this.removeWait)
		this.removeWait();
	if(error)
		throw error;
	return res;
};

Zone.prototype.run = function(fn){
	if(this.isResolved) {
		this.deferred = new Deferred();
		this.isResolved = false;
	} else {
		this.execHook("beforeRun");
	}

	var task = new Task(this, fn);

	// Call the function
	this.data.result = task.run();

	if(!this.isResolved) {
		this.execHook("afterRun");
	}

	// If we are already done
	if(!this.waits || this.errors.length) {
		this.end();
	}

	return this.deferred.promise;
};

Zone.prototype.fork = function(zoneSpec){
	var Zone = this.constructor;
	var plugins = [];
	if(zoneSpec) plugins.push(zoneSpec);
	plugins.unshift(this);
	var newZone = new Zone({
		plugins: plugins
	});

	return newZone;
};

Zone.prototype.execHook = function(hook /* , args */){
	var args = slice.call(arguments, 1);
	var zone = this;
	var prop = hook + "s";
	var array = this[prop];
	if(array){
		forEach.call(array, function(fn){
			fn.apply(zone, args);
		});
	}
};

Zone.prototype.execHookR = function(hook /* , args */){
	var args = slice.call(arguments, 1);
	var zone = this;
	var prop = hook + "s";
	var array = this[prop];
	if(array){
		var i = array.length - 1;
		for(; i >= 0; i--) {
			array[i].apply(zone, args);
		}
	}
};

Zone.prototype.wrap = function(fn, catchErrors){
	var zone = this;

	return function(){
		return zone.runTask(fn, this, arguments, catchErrors);
	};
};

Zone.prototype.end = function(){
	if(!this.isResolved) {
		this.execHook("ended");
	}
	var dfd = this.deferred;
	if(this.errors.length) {
		var error = this.errors[0];
		error.errors = this.errors;
		dfd.reject(error);
	} else {
		dfd.resolve(this.data);
	}
	this.isResolved = true;
};

Zone.prototype.waitFor = function(fn, catchErrors){
	this.addWait();
	var zone = this;

	return function(){
		return zone.runTask(fn, this, arguments, catchErrors, true);
	};
};

Zone.prototype.addWait = function(){
	this.waits++;
	if(this.parent) {
		this.parent.addWait();
	}
};

Zone.prototype.removeWait = function(){
	this.waits--;
	if(this.waits === 0) {
		this.end();
	}
	if(this.parent) {
		this.parent.removeWait();
	}
};

Zone.Task = Task;
Zone.register = canZone_0_6_20_register;

function extend(a, b){
	if(!b) return a;
	for(var p in b) {
		a[p] = b[p];
	}
	return a;
}

Zone.tasks = {};
addTasks(tasks);

function addTasks(tasks$$1){
	for(var p in tasks$$1) {
		Zone.tasks[p] = tasks$$1[p];
	}
}

g.CanZone = g.CanZone || Zone;

if(module.exports) {
	module.exports = Zone;
}
});

/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
/* eslint-disable no-unused-vars */
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;

function toObject(val) {
	if (val === null || val === undefined) {
		throw new TypeError('Object.assign cannot be called with null or undefined');
	}

	return Object(val);
}

function shouldUseNative() {
	try {
		if (!Object.assign) {
			return false;
		}

		// Detect buggy property enumeration order in older V8 versions.

		// https://bugs.chromium.org/p/v8/issues/detail?id=4118
		var test1 = new String('abc');  // eslint-disable-line no-new-wrappers
		test1[5] = 'de';
		if (Object.getOwnPropertyNames(test1)[0] === '5') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test2 = {};
		for (var i = 0; i < 10; i++) {
			test2['_' + String.fromCharCode(i)] = i;
		}
		var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
			return test2[n];
		});
		if (order2.join('') !== '0123456789') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test3 = {};
		'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
			test3[letter] = letter;
		});
		if (Object.keys(Object.assign({}, test3)).join('') !==
				'abcdefghijklmnopqrst') {
			return false;
		}

		return true;
	} catch (err) {
		// We don't expect any of the above to throw, but better to be safe.
		return false;
	}
}

var objectAssign_4_1_1_index = shouldUseNative() ? Object.assign : function (target, source) {
	var from;
	var to = toObject(target);
	var symbols;

	for (var s = 1; s < arguments.length; s++) {
		from = Object(arguments[s]);

		for (var key in from) {
			if (hasOwnProperty.call(from, key)) {
				to[key] = from[key];
			}
		}

		if (getOwnPropertySymbols) {
			symbols = getOwnPropertySymbols(from);
			for (var i = 0; i < symbols.length; i++) {
				if (propIsEnumerable.call(from, symbols[i])) {
					to[symbols[i]] = from[symbols[i]];
				}
			}
		}
	}

	return to;
};

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */

/**
 * Use invariant() to assert state which your program assumes to be true.
 *
 * Provide sprintf-style format (only %s is supported) and arguments
 * to provide information about what broke and what you were
 * expecting.
 *
 * The invariant message will be stripped in production, but the invariant
 * will remain to ensure logic does not differ in production.
 */

var validateFormat = function validateFormat(format) {};

if (process.env.NODE_ENV !== 'production') {
  validateFormat = function validateFormat(format) {
    if (format === undefined) {
      throw new Error('invariant requires an error message argument');
    }
  };
}

function invariant(condition, format, a, b, c, d, e, f) {
  validateFormat(format);

  if (!condition) {
    var error;
    if (format === undefined) {
      error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');
    } else {
      var args = [a, b, c, d, e, f];
      var argIndex = 0;
      error = new Error(format.replace(/%s/g, function () {
        return args[argIndex++];
      }));
      error.name = 'Invariant Violation';
    }

    error.framesToPop = 1; // we don't care about invariant's own frame
    throw error;
  }
}

var invariant_1 = invariant;

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */

var emptyObject = {};

if (process.env.NODE_ENV !== 'production') {
  Object.freeze(emptyObject);
}

var emptyObject_1 = emptyObject;

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

function makeEmptyFunction(arg) {
  return function () {
    return arg;
  };
}

/**
 * This function accepts and discards inputs; it has no side effects. This is
 * primarily useful idiomatically for overridable function endpoints which
 * always need to be callable, since JS lacks a null-call idiom ala Cocoa.
 */
var emptyFunction = function emptyFunction() {};

emptyFunction.thatReturns = makeEmptyFunction;
emptyFunction.thatReturnsFalse = makeEmptyFunction(false);
emptyFunction.thatReturnsTrue = makeEmptyFunction(true);
emptyFunction.thatReturnsNull = makeEmptyFunction(null);
emptyFunction.thatReturnsThis = function () {
  return this;
};
emptyFunction.thatReturnsArgument = function (arg) {
  return arg;
};

var emptyFunction_1 = emptyFunction;

var r="function"===typeof Symbol&&Symbol.for,t=r?Symbol.for("react.element"):60103,u=r?Symbol.for("react.portal"):60106,v=r?Symbol.for("react.fragment"):60107,w=r?Symbol.for("react.strict_mode"):60108,x=r?Symbol.for("react.profiler"):60114,y$1=r?Symbol.for("react.provider"):60109,z=r?Symbol.for("react.context"):60110,A=r?Symbol.for("react.async_mode"):60111,B=
r?Symbol.for("react.forward_ref"):60112;var C="function"===typeof Symbol&&Symbol.iterator;function D(a){for(var b=arguments.length-1,e="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=0;c<b;c++)e+="&args[]="+encodeURIComponent(arguments[c+1]);invariant_1(!1,"Minified React error #"+a+"; visit %s for the full message or use the non-minified dev environment for full errors and additional helpful warnings. ",e);}
var E={isMounted:function(){return!1},enqueueForceUpdate:function(){},enqueueReplaceState:function(){},enqueueSetState:function(){}};function F(a,b,e){this.props=a;this.context=b;this.refs=emptyObject_1;this.updater=e||E;}F.prototype.isReactComponent={};F.prototype.setState=function(a,b){"object"!==typeof a&&"function"!==typeof a&&null!=a?D("85"):void 0;this.updater.enqueueSetState(this,a,b,"setState");};F.prototype.forceUpdate=function(a){this.updater.enqueueForceUpdate(this,a,"forceUpdate");};function G(){}
G.prototype=F.prototype;function H(a,b,e){this.props=a;this.context=b;this.refs=emptyObject_1;this.updater=e||E;}var I=H.prototype=new G;I.constructor=H;objectAssign_4_1_1_index(I,F.prototype);I.isPureReactComponent=!0;var J={current:null},K=Object.prototype.hasOwnProperty,L={key:!0,ref:!0,__self:!0,__source:!0};
function M(a,b,e){var c=void 0,d={},g=null,h=null;if(null!=b)for(c in void 0!==b.ref&&(h=b.ref),void 0!==b.key&&(g=""+b.key),b)K.call(b,c)&&!L.hasOwnProperty(c)&&(d[c]=b[c]);var f=arguments.length-2;if(1===f)d.children=e;else if(1<f){for(var l=Array(f),m=0;m<f;m++)l[m]=arguments[m+2];d.children=l;}if(a&&a.defaultProps)for(c in f=a.defaultProps,f)void 0===d[c]&&(d[c]=f[c]);return{$$typeof:t,type:a,key:g,ref:h,props:d,_owner:J.current}}
function N(a){return"object"===typeof a&&null!==a&&a.$$typeof===t}function escape(a){var b={"=":"=0",":":"=2"};return"$"+(""+a).replace(/[=:]/g,function(a){return b[a]})}var O=/\/+/g,P=[];function Q(a,b,e,c){if(P.length){var d=P.pop();d.result=a;d.keyPrefix=b;d.func=e;d.context=c;d.count=0;return d}return{result:a,keyPrefix:b,func:e,context:c,count:0}}function R(a){a.result=null;a.keyPrefix=null;a.func=null;a.context=null;a.count=0;10>P.length&&P.push(a);}
function S(a,b,e,c){var d=typeof a;if("undefined"===d||"boolean"===d)a=null;var g=!1;if(null===a)g=!0;else switch(d){case "string":case "number":g=!0;break;case "object":switch(a.$$typeof){case t:case u:g=!0;}}if(g)return e(c,a,""===b?"."+T(a,0):b),1;g=0;b=""===b?".":b+":";if(Array.isArray(a))for(var h=0;h<a.length;h++){d=a[h];var f=b+T(d,h);g+=S(d,f,e,c);}else if(null===a||"undefined"===typeof a?f=null:(f=C&&a[C]||a["@@iterator"],f="function"===typeof f?f:null),"function"===typeof f)for(a=f.call(a),
h=0;!(d=a.next()).done;)d=d.value,f=b+T(d,h++),g+=S(d,f,e,c);else"object"===d&&(e=""+a,D("31","[object Object]"===e?"object with keys {"+Object.keys(a).join(", ")+"}":e,""));return g}function T(a,b){return"object"===typeof a&&null!==a&&null!=a.key?escape(a.key):b.toString(36)}function U(a,b){a.func.call(a.context,b,a.count++);}
function V(a,b,e){var c=a.result,d=a.keyPrefix;a=a.func.call(a.context,b,a.count++);Array.isArray(a)?W(a,c,e,emptyFunction_1.thatReturnsArgument):null!=a&&(N(a)&&(b=d+(!a.key||b&&b.key===a.key?"":(""+a.key).replace(O,"$&/")+"/")+e,a={$$typeof:t,type:a.type,key:b,ref:a.ref,props:a.props,_owner:a._owner}),c.push(a));}function W(a,b,e,c,d){var g="";null!=e&&(g=(""+e).replace(O,"$&/")+"/");b=Q(b,g,c,d);null==a||S(a,"",V,b);R(b);}
var X={Children:{map:function(a,b,e){if(null==a)return a;var c=[];W(a,c,null,b,e);return c},forEach:function(a,b,e){if(null==a)return a;b=Q(null,null,b,e);null==a||S(a,"",U,b);R(b);},count:function(a){return null==a?0:S(a,"",emptyFunction_1.thatReturnsNull,null)},toArray:function(a){var b=[];W(a,b,null,emptyFunction_1.thatReturnsArgument);return b},only:function(a){N(a)?void 0:D("143");return a}},createRef:function(){return{current:null}},Component:F,PureComponent:H,createContext:function(a,b){void 0===b&&(b=null);a={$$typeof:z,
_calculateChangedBits:b,_defaultValue:a,_currentValue:a,_currentValue2:a,_changedBits:0,_changedBits2:0,Provider:null,Consumer:null};a.Provider={$$typeof:y$1,_context:a};return a.Consumer=a},forwardRef:function(a){return{$$typeof:B,render:a}},Fragment:v,StrictMode:w,unstable_AsyncMode:A,unstable_Profiler:x,createElement:M,cloneElement:function(a,b,e){null===a||void 0===a?D("267",a):void 0;var c=void 0,d=objectAssign_4_1_1_index({},a.props),g=a.key,h=a.ref,f=a._owner;if(null!=b){void 0!==b.ref&&(h=b.ref,f=J.current);void 0!==
b.key&&(g=""+b.key);var l=void 0;a.type&&a.type.defaultProps&&(l=a.type.defaultProps);for(c in b)K.call(b,c)&&!L.hasOwnProperty(c)&&(d[c]=void 0===b[c]&&void 0!==l?l[c]:b[c]);}c=arguments.length-2;if(1===c)d.children=e;else if(1<c){l=Array(c);for(var m=0;m<c;m++)l[m]=arguments[m+2];d.children=l;}return{$$typeof:t,type:a.type,key:g,ref:h,props:d,_owner:f}},createFactory:function(a){var b=M.bind(null,a);b.type=a;return b},isValidElement:N,version:"16.4.1",__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED:{ReactCurrentOwner:J,
assign:objectAssign_4_1_1_index}},Y={default:X},Z=Y&&X||Y;var react_production_min=Z.default?Z.default:Z;

/**
 * Similar to invariant but only logs a warning if the condition is not met.
 * This can be used to log issues in development environments in critical
 * paths. Removing the logging code for production environments will keep the
 * same logic and follow the same code paths.
 */

var warning = emptyFunction_1;

if (process.env.NODE_ENV !== 'production') {
  var printWarning = function printWarning(format) {
    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    var argIndex = 0;
    var message = 'Warning: ' + format.replace(/%s/g, function () {
      return args[argIndex++];
    });
    if (typeof console !== 'undefined') {
      console.error(message);
    }
    try {
      // --- Welcome to debugging React ---
      // This error was thrown as a convenience so that you can use this stack
      // to find the callsite that caused this warning to fire.
      throw new Error(message);
    } catch (x) {}
  };

  warning = function warning(condition, format) {
    if (format === undefined) {
      throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');
    }

    if (format.indexOf('Failed Composite propType: ') === 0) {
      return; // Ignore CompositeComponent proptype check.
    }

    if (!condition) {
      for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
        args[_key2 - 2] = arguments[_key2];
      }

      printWarning.apply(undefined, [format].concat(args));
    }
  };
}

var warning_1 = warning;

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';

var ReactPropTypesSecret_1 = ReactPropTypesSecret;

var printWarning$1 = function() {};

if (process.env.NODE_ENV !== 'production') {
  var ReactPropTypesSecret$1 = ReactPropTypesSecret_1;
  var loggedTypeFailures = {};

  printWarning$1 = function(text) {
    var message = 'Warning: ' + text;
    if (typeof console !== 'undefined') {
      console.error(message);
    }
    try {
      // --- Welcome to debugging React ---
      // This error was thrown as a convenience so that you can use this stack
      // to find the callsite that caused this warning to fire.
      throw new Error(message);
    } catch (x) {}
  };
}

/**
 * Assert that the values match with the type specs.
 * Error messages are memorized and will only be shown once.
 *
 * @param {object} typeSpecs Map of name to a ReactPropType
 * @param {object} values Runtime values that need to be type-checked
 * @param {string} location e.g. "prop", "context", "child context"
 * @param {string} componentName Name of the component for error messages.
 * @param {?Function} getStack Returns the component stack.
 * @private
 */
function checkPropTypes(typeSpecs, values, location, componentName, getStack) {
  if (process.env.NODE_ENV !== 'production') {
    for (var typeSpecName in typeSpecs) {
      if (typeSpecs.hasOwnProperty(typeSpecName)) {
        var error;
        // Prop type validation may throw. In case they do, we don't want to
        // fail the render phase where it didn't fail before. So we log it.
        // After these have been cleaned up, we'll let them throw.
        try {
          // This is intentionally an invariant that gets caught. It's the same
          // behavior as without this statement except with a better message.
          if (typeof typeSpecs[typeSpecName] !== 'function') {
            var err = Error(
              (componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' +
              'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.'
            );
            err.name = 'Invariant Violation';
            throw err;
          }
          error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret$1);
        } catch (ex) {
          error = ex;
        }
        if (error && !(error instanceof Error)) {
          printWarning$1(
            (componentName || 'React class') + ': type specification of ' +
            location + ' `' + typeSpecName + '` is invalid; the type checker ' +
            'function must return `null` or an `Error` but returned a ' + typeof error + '. ' +
            'You may have forgotten to pass an argument to the type checker ' +
            'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' +
            'shape all require an argument).'
          );

        }
        if (error instanceof Error && !(error.message in loggedTypeFailures)) {
          // Only monitor this failure once because there tends to be a lot of the
          // same error.
          loggedTypeFailures[error.message] = true;

          var stack = getStack ? getStack() : '';

          printWarning$1(
            'Failed ' + location + ' type: ' + error.message + (stack != null ? stack : '')
          );
        }
      }
    }
  }
}

var propTypes_15_6_2_checkPropTypes = checkPropTypes;

var react_development = createCommonjsModule(function (module) {



if (process.env.NODE_ENV !== "production") {
  (function() {

var _assign = objectAssign_4_1_1_index;
var invariant = invariant_1;
var emptyObject = emptyObject_1;
var warning = warning_1;
var emptyFunction = emptyFunction_1;
var checkPropTypes = propTypes_15_6_2_checkPropTypes;

// TODO: this is special because it gets imported during build.

var ReactVersion = '16.4.1';

// The Symbol used to tag the ReactElement-like types. If there is no native Symbol
// nor polyfill, then a plain number is used for performance.
var hasSymbol = typeof Symbol === 'function' && Symbol.for;

var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for('react.element') : 0xeac7;
var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for('react.portal') : 0xeaca;
var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for('react.fragment') : 0xeacb;
var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for('react.strict_mode') : 0xeacc;
var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for('react.profiler') : 0xead2;
var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for('react.provider') : 0xeacd;
var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for('react.context') : 0xeace;
var REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for('react.async_mode') : 0xeacf;
var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for('react.forward_ref') : 0xead0;
var REACT_TIMEOUT_TYPE = hasSymbol ? Symbol.for('react.timeout') : 0xead1;

var MAYBE_ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
var FAUX_ITERATOR_SYMBOL = '@@iterator';

function getIteratorFn(maybeIterable) {
  if (maybeIterable === null || typeof maybeIterable === 'undefined') {
    return null;
  }
  var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
  if (typeof maybeIterator === 'function') {
    return maybeIterator;
  }
  return null;
}

// Relying on the `invariant()` implementation lets us
// have preserve the format and params in the www builds.

// Exports ReactDOM.createRoot


// Experimental error-boundary API that can recover from errors within a single
// render phase

// Suspense
var enableSuspense = false;
// Helps identify side effects in begin-phase lifecycle hooks and setState reducers:


// In some cases, StrictMode should also double-render lifecycles.
// This can be confusing for tests though,
// And it can be bad for performance in production.
// This feature flag can be used to control the behavior:


// To preserve the "Pause on caught exceptions" behavior of the debugger, we
// replay the begin phase of a failed component inside invokeGuardedCallback.


// Warn about deprecated, async-unsafe lifecycles; relates to RFC #6:


// Warn about legacy context API


// Gather advanced timing metrics for Profiler subtrees.


// Only used in www builds.

/**
 * Forked from fbjs/warning:
 * https://github.com/facebook/fbjs/blob/e66ba20ad5be433eb54423f2b097d829324d9de6/packages/fbjs/src/__forks__/warning.js
 *
 * Only change is we use console.warn instead of console.error,
 * and do nothing when 'console' is not supported.
 * This really simplifies the code.
 * ---
 * Similar to invariant but only logs a warning if the condition is not met.
 * This can be used to log issues in development environments in critical
 * paths. Removing the logging code for production environments will keep the
 * same logic and follow the same code paths.
 */

var lowPriorityWarning = function () {};

{
  var printWarning = function (format) {
    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    var argIndex = 0;
    var message = 'Warning: ' + format.replace(/%s/g, function () {
      return args[argIndex++];
    });
    if (typeof console !== 'undefined') {
      console.warn(message);
    }
    try {
      // --- Welcome to debugging React ---
      // This error was thrown as a convenience so that you can use this stack
      // to find the callsite that caused this warning to fire.
      throw new Error(message);
    } catch (x) {}
  };

  lowPriorityWarning = function (condition, format) {
    if (format === undefined) {
      throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');
    }
    if (!condition) {
      for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
        args[_key2 - 2] = arguments[_key2];
      }

      printWarning.apply(undefined, [format].concat(args));
    }
  };
}

var lowPriorityWarning$1 = lowPriorityWarning;

var didWarnStateUpdateForUnmountedComponent = {};

function warnNoop(publicInstance, callerName) {
  {
    var _constructor = publicInstance.constructor;
    var componentName = _constructor && (_constructor.displayName || _constructor.name) || 'ReactClass';
    var warningKey = componentName + '.' + callerName;
    if (didWarnStateUpdateForUnmountedComponent[warningKey]) {
      return;
    }
    warning(false, "Can't call %s on a component that is not yet mounted. " + 'This is a no-op, but it might indicate a bug in your application. ' + 'Instead, assign to `this.state` directly or define a `state = {};` ' + 'class property with the desired state in the %s component.', callerName, componentName);
    didWarnStateUpdateForUnmountedComponent[warningKey] = true;
  }
}

/**
 * This is the abstract API for an update queue.
 */
var ReactNoopUpdateQueue = {
  /**
   * Checks whether or not this composite component is mounted.
   * @param {ReactClass} publicInstance The instance we want to test.
   * @return {boolean} True if mounted, false otherwise.
   * @protected
   * @final
   */
  isMounted: function (publicInstance) {
    return false;
  },

  /**
   * Forces an update. This should only be invoked when it is known with
   * certainty that we are **not** in a DOM transaction.
   *
   * You may want to call this when you know that some deeper aspect of the
   * component's state has changed but `setState` was not called.
   *
   * This will not invoke `shouldComponentUpdate`, but it will invoke
   * `componentWillUpdate` and `componentDidUpdate`.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {?function} callback Called after component is updated.
   * @param {?string} callerName name of the calling function in the public API.
   * @internal
   */
  enqueueForceUpdate: function (publicInstance, callback, callerName) {
    warnNoop(publicInstance, 'forceUpdate');
  },

  /**
   * Replaces all of the state. Always use this or `setState` to mutate state.
   * You should treat `this.state` as immutable.
   *
   * There is no guarantee that `this.state` will be immediately updated, so
   * accessing `this.state` after calling this method may return the old value.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {object} completeState Next state.
   * @param {?function} callback Called after component is updated.
   * @param {?string} callerName name of the calling function in the public API.
   * @internal
   */
  enqueueReplaceState: function (publicInstance, completeState, callback, callerName) {
    warnNoop(publicInstance, 'replaceState');
  },

  /**
   * Sets a subset of the state. This only exists because _pendingState is
   * internal. This provides a merging strategy that is not available to deep
   * properties which is confusing. TODO: Expose pendingState or don't use it
   * during the merge.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {object} partialState Next partial state to be merged with state.
   * @param {?function} callback Called after component is updated.
   * @param {?string} Name of the calling function in the public API.
   * @internal
   */
  enqueueSetState: function (publicInstance, partialState, callback, callerName) {
    warnNoop(publicInstance, 'setState');
  }
};

/**
 * Base class helpers for the updating state of a component.
 */
function Component(props, context, updater) {
  this.props = props;
  this.context = context;
  this.refs = emptyObject;
  // We initialize the default updater but the real one gets injected by the
  // renderer.
  this.updater = updater || ReactNoopUpdateQueue;
}

Component.prototype.isReactComponent = {};

/**
 * Sets a subset of the state. Always use this to mutate
 * state. You should treat `this.state` as immutable.
 *
 * There is no guarantee that `this.state` will be immediately updated, so
 * accessing `this.state` after calling this method may return the old value.
 *
 * There is no guarantee that calls to `setState` will run synchronously,
 * as they may eventually be batched together.  You can provide an optional
 * callback that will be executed when the call to setState is actually
 * completed.
 *
 * When a function is provided to setState, it will be called at some point in
 * the future (not synchronously). It will be called with the up to date
 * component arguments (state, props, context). These values can be different
 * from this.* because your function may be called after receiveProps but before
 * shouldComponentUpdate, and this new state, props, and context will not yet be
 * assigned to this.
 *
 * @param {object|function} partialState Next partial state or function to
 *        produce next partial state to be merged with current state.
 * @param {?function} callback Called after state is updated.
 * @final
 * @protected
 */
Component.prototype.setState = function (partialState, callback) {
  !(typeof partialState === 'object' || typeof partialState === 'function' || partialState == null) ? invariant(false, 'setState(...): takes an object of state variables to update or a function which returns an object of state variables.') : void 0;
  this.updater.enqueueSetState(this, partialState, callback, 'setState');
};

/**
 * Forces an update. This should only be invoked when it is known with
 * certainty that we are **not** in a DOM transaction.
 *
 * You may want to call this when you know that some deeper aspect of the
 * component's state has changed but `setState` was not called.
 *
 * This will not invoke `shouldComponentUpdate`, but it will invoke
 * `componentWillUpdate` and `componentDidUpdate`.
 *
 * @param {?function} callback Called after update is complete.
 * @final
 * @protected
 */
Component.prototype.forceUpdate = function (callback) {
  this.updater.enqueueForceUpdate(this, callback, 'forceUpdate');
};

/**
 * Deprecated APIs. These APIs used to exist on classic React classes but since
 * we would like to deprecate them, we're not going to move them over to this
 * modern base class. Instead, we define a getter that warns if it's accessed.
 */
{
  var deprecatedAPIs = {
    isMounted: ['isMounted', 'Instead, make sure to clean up subscriptions and pending requests in ' + 'componentWillUnmount to prevent memory leaks.'],
    replaceState: ['replaceState', 'Refactor your code to use setState instead (see ' + 'https://github.com/facebook/react/issues/3236).']
  };
  var defineDeprecationWarning = function (methodName, info) {
    Object.defineProperty(Component.prototype, methodName, {
      get: function () {
        lowPriorityWarning$1(false, '%s(...) is deprecated in plain JavaScript React classes. %s', info[0], info[1]);
        return undefined;
      }
    });
  };
  for (var fnName in deprecatedAPIs) {
    if (deprecatedAPIs.hasOwnProperty(fnName)) {
      defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
    }
  }
}

function ComponentDummy() {}
ComponentDummy.prototype = Component.prototype;

/**
 * Convenience component with default shallow equality check for sCU.
 */
function PureComponent(props, context, updater) {
  this.props = props;
  this.context = context;
  this.refs = emptyObject;
  this.updater = updater || ReactNoopUpdateQueue;
}

var pureComponentPrototype = PureComponent.prototype = new ComponentDummy();
pureComponentPrototype.constructor = PureComponent;
// Avoid an extra prototype jump for these methods.
_assign(pureComponentPrototype, Component.prototype);
pureComponentPrototype.isPureReactComponent = true;

// an immutable object with a single mutable value
function createRef() {
  var refObject = {
    current: null
  };
  {
    Object.seal(refObject);
  }
  return refObject;
}

/**
 * Keeps track of the current owner.
 *
 * The current owner is the component who should own any components that are
 * currently being constructed.
 */
var ReactCurrentOwner = {
  /**
   * @internal
   * @type {ReactComponent}
   */
  current: null
};

var hasOwnProperty = Object.prototype.hasOwnProperty;

var RESERVED_PROPS = {
  key: true,
  ref: true,
  __self: true,
  __source: true
};

var specialPropKeyWarningShown = void 0;
var specialPropRefWarningShown = void 0;

function hasValidRef(config) {
  {
    if (hasOwnProperty.call(config, 'ref')) {
      var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;
      if (getter && getter.isReactWarning) {
        return false;
      }
    }
  }
  return config.ref !== undefined;
}

function hasValidKey(config) {
  {
    if (hasOwnProperty.call(config, 'key')) {
      var getter = Object.getOwnPropertyDescriptor(config, 'key').get;
      if (getter && getter.isReactWarning) {
        return false;
      }
    }
  }
  return config.key !== undefined;
}

function defineKeyPropWarningGetter(props, displayName) {
  var warnAboutAccessingKey = function () {
    if (!specialPropKeyWarningShown) {
      specialPropKeyWarningShown = true;
      warning(false, '%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://fb.me/react-special-props)', displayName);
    }
  };
  warnAboutAccessingKey.isReactWarning = true;
  Object.defineProperty(props, 'key', {
    get: warnAboutAccessingKey,
    configurable: true
  });
}

function defineRefPropWarningGetter(props, displayName) {
  var warnAboutAccessingRef = function () {
    if (!specialPropRefWarningShown) {
      specialPropRefWarningShown = true;
      warning(false, '%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://fb.me/react-special-props)', displayName);
    }
  };
  warnAboutAccessingRef.isReactWarning = true;
  Object.defineProperty(props, 'ref', {
    get: warnAboutAccessingRef,
    configurable: true
  });
}

/**
 * Factory method to create a new React element. This no longer adheres to
 * the class pattern, so do not use new to call it. Also, no instanceof check
 * will work. Instead test $$typeof field against Symbol.for('react.element') to check
 * if something is a React Element.
 *
 * @param {*} type
 * @param {*} key
 * @param {string|object} ref
 * @param {*} self A *temporary* helper to detect places where `this` is
 * different from the `owner` when React.createElement is called, so that we
 * can warn. We want to get rid of owner and replace string `ref`s with arrow
 * functions, and as long as `this` and owner are the same, there will be no
 * change in behavior.
 * @param {*} source An annotation object (added by a transpiler or otherwise)
 * indicating filename, line number, and/or other information.
 * @param {*} owner
 * @param {*} props
 * @internal
 */
var ReactElement = function (type, key, ref, self, source, owner, props) {
  var element = {
    // This tag allows us to uniquely identify this as a React Element
    $$typeof: REACT_ELEMENT_TYPE,

    // Built-in properties that belong on the element
    type: type,
    key: key,
    ref: ref,
    props: props,

    // Record the component responsible for creating this element.
    _owner: owner
  };

  {
    // The validation flag is currently mutative. We put it on
    // an external backing store so that we can freeze the whole object.
    // This can be replaced with a WeakMap once they are implemented in
    // commonly used development environments.
    element._store = {};

    // To make comparing ReactElements easier for testing purposes, we make
    // the validation flag non-enumerable (where possible, which should
    // include every environment we run tests in), so the test framework
    // ignores it.
    Object.defineProperty(element._store, 'validated', {
      configurable: false,
      enumerable: false,
      writable: true,
      value: false
    });
    // self and source are DEV only properties.
    Object.defineProperty(element, '_self', {
      configurable: false,
      enumerable: false,
      writable: false,
      value: self
    });
    // Two elements created in two different places should be considered
    // equal for testing purposes and therefore we hide it from enumeration.
    Object.defineProperty(element, '_source', {
      configurable: false,
      enumerable: false,
      writable: false,
      value: source
    });
    if (Object.freeze) {
      Object.freeze(element.props);
      Object.freeze(element);
    }
  }

  return element;
};

/**
 * Create and return a new ReactElement of the given type.
 * See https://reactjs.org/docs/react-api.html#createelement
 */
function createElement(type, config, children) {
  var propName = void 0;

  // Reserved names are extracted
  var props = {};

  var key = null;
  var ref = null;
  var self = null;
  var source = null;

  if (config != null) {
    if (hasValidRef(config)) {
      ref = config.ref;
    }
    if (hasValidKey(config)) {
      key = '' + config.key;
    }

    self = config.__self === undefined ? null : config.__self;
    source = config.__source === undefined ? null : config.__source;
    // Remaining properties are added to a new props object
    for (propName in config) {
      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
        props[propName] = config[propName];
      }
    }
  }

  // Children can be more than one argument, and those are transferred onto
  // the newly allocated props object.
  var childrenLength = arguments.length - 2;
  if (childrenLength === 1) {
    props.children = children;
  } else if (childrenLength > 1) {
    var childArray = Array(childrenLength);
    for (var i = 0; i < childrenLength; i++) {
      childArray[i] = arguments[i + 2];
    }
    {
      if (Object.freeze) {
        Object.freeze(childArray);
      }
    }
    props.children = childArray;
  }

  // Resolve default props
  if (type && type.defaultProps) {
    var defaultProps = type.defaultProps;
    for (propName in defaultProps) {
      if (props[propName] === undefined) {
        props[propName] = defaultProps[propName];
      }
    }
  }
  {
    if (key || ref) {
      if (typeof props.$$typeof === 'undefined' || props.$$typeof !== REACT_ELEMENT_TYPE) {
        var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;
        if (key) {
          defineKeyPropWarningGetter(props, displayName);
        }
        if (ref) {
          defineRefPropWarningGetter(props, displayName);
        }
      }
    }
  }
  return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);
}

/**
 * Return a function that produces ReactElements of a given type.
 * See https://reactjs.org/docs/react-api.html#createfactory
 */


function cloneAndReplaceKey(oldElement, newKey) {
  var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);

  return newElement;
}

/**
 * Clone and return a new ReactElement using element as the starting point.
 * See https://reactjs.org/docs/react-api.html#cloneelement
 */
function cloneElement(element, config, children) {
  !!(element === null || element === undefined) ? invariant(false, 'React.cloneElement(...): The argument must be a React element, but you passed %s.', element) : void 0;

  var propName = void 0;

  // Original props are copied
  var props = _assign({}, element.props);

  // Reserved names are extracted
  var key = element.key;
  var ref = element.ref;
  // Self is preserved since the owner is preserved.
  var self = element._self;
  // Source is preserved since cloneElement is unlikely to be targeted by a
  // transpiler, and the original source is probably a better indicator of the
  // true owner.
  var source = element._source;

  // Owner will be preserved, unless ref is overridden
  var owner = element._owner;

  if (config != null) {
    if (hasValidRef(config)) {
      // Silently steal the ref from the parent.
      ref = config.ref;
      owner = ReactCurrentOwner.current;
    }
    if (hasValidKey(config)) {
      key = '' + config.key;
    }

    // Remaining properties override existing props
    var defaultProps = void 0;
    if (element.type && element.type.defaultProps) {
      defaultProps = element.type.defaultProps;
    }
    for (propName in config) {
      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
        if (config[propName] === undefined && defaultProps !== undefined) {
          // Resolve default props
          props[propName] = defaultProps[propName];
        } else {
          props[propName] = config[propName];
        }
      }
    }
  }

  // Children can be more than one argument, and those are transferred onto
  // the newly allocated props object.
  var childrenLength = arguments.length - 2;
  if (childrenLength === 1) {
    props.children = children;
  } else if (childrenLength > 1) {
    var childArray = Array(childrenLength);
    for (var i = 0; i < childrenLength; i++) {
      childArray[i] = arguments[i + 2];
    }
    props.children = childArray;
  }

  return ReactElement(element.type, key, ref, self, source, owner, props);
}

/**
 * Verifies the object is a ReactElement.
 * See https://reactjs.org/docs/react-api.html#isvalidelement
 * @param {?object} object
 * @return {boolean} True if `object` is a valid component.
 * @final
 */
function isValidElement(object) {
  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
}

var ReactDebugCurrentFrame = {};

{
  // Component that is being worked on
  ReactDebugCurrentFrame.getCurrentStack = null;

  ReactDebugCurrentFrame.getStackAddendum = function () {
    var impl = ReactDebugCurrentFrame.getCurrentStack;
    if (impl) {
      return impl();
    }
    return null;
  };
}

var SEPARATOR = '.';
var SUBSEPARATOR = ':';

/**
 * Escape and wrap key so it is safe to use as a reactid
 *
 * @param {string} key to be escaped.
 * @return {string} the escaped key.
 */
function escape(key) {
  var escapeRegex = /[=:]/g;
  var escaperLookup = {
    '=': '=0',
    ':': '=2'
  };
  var escapedString = ('' + key).replace(escapeRegex, function (match) {
    return escaperLookup[match];
  });

  return '$' + escapedString;
}

/**
 * TODO: Test that a single child and an array with one item have the same key
 * pattern.
 */

var didWarnAboutMaps = false;

var userProvidedKeyEscapeRegex = /\/+/g;
function escapeUserProvidedKey(text) {
  return ('' + text).replace(userProvidedKeyEscapeRegex, '$&/');
}

var POOL_SIZE = 10;
var traverseContextPool = [];
function getPooledTraverseContext(mapResult, keyPrefix, mapFunction, mapContext) {
  if (traverseContextPool.length) {
    var traverseContext = traverseContextPool.pop();
    traverseContext.result = mapResult;
    traverseContext.keyPrefix = keyPrefix;
    traverseContext.func = mapFunction;
    traverseContext.context = mapContext;
    traverseContext.count = 0;
    return traverseContext;
  } else {
    return {
      result: mapResult,
      keyPrefix: keyPrefix,
      func: mapFunction,
      context: mapContext,
      count: 0
    };
  }
}

function releaseTraverseContext(traverseContext) {
  traverseContext.result = null;
  traverseContext.keyPrefix = null;
  traverseContext.func = null;
  traverseContext.context = null;
  traverseContext.count = 0;
  if (traverseContextPool.length < POOL_SIZE) {
    traverseContextPool.push(traverseContext);
  }
}

/**
 * @param {?*} children Children tree container.
 * @param {!string} nameSoFar Name of the key path so far.
 * @param {!function} callback Callback to invoke with each child found.
 * @param {?*} traverseContext Used to pass information throughout the traversal
 * process.
 * @return {!number} The number of children in this subtree.
 */
function traverseAllChildrenImpl(children, nameSoFar, callback, traverseContext) {
  var type = typeof children;

  if (type === 'undefined' || type === 'boolean') {
    // All of the above are perceived as null.
    children = null;
  }

  var invokeCallback = false;

  if (children === null) {
    invokeCallback = true;
  } else {
    switch (type) {
      case 'string':
      case 'number':
        invokeCallback = true;
        break;
      case 'object':
        switch (children.$$typeof) {
          case REACT_ELEMENT_TYPE:
          case REACT_PORTAL_TYPE:
            invokeCallback = true;
        }
    }
  }

  if (invokeCallback) {
    callback(traverseContext, children,
    // If it's the only child, treat the name as if it was wrapped in an array
    // so that it's consistent if the number of children grows.
    nameSoFar === '' ? SEPARATOR + getComponentKey(children, 0) : nameSoFar);
    return 1;
  }

  var child = void 0;
  var nextName = void 0;
  var subtreeCount = 0; // Count of children found in the current subtree.
  var nextNamePrefix = nameSoFar === '' ? SEPARATOR : nameSoFar + SUBSEPARATOR;

  if (Array.isArray(children)) {
    for (var i = 0; i < children.length; i++) {
      child = children[i];
      nextName = nextNamePrefix + getComponentKey(child, i);
      subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
    }
  } else {
    var iteratorFn = getIteratorFn(children);
    if (typeof iteratorFn === 'function') {
      {
        // Warn about using Maps as children
        if (iteratorFn === children.entries) {
          !didWarnAboutMaps ? warning(false, 'Using Maps as children is unsupported and will likely yield ' + 'unexpected results. Convert it to a sequence/iterable of keyed ' + 'ReactElements instead.%s', ReactDebugCurrentFrame.getStackAddendum()) : void 0;
          didWarnAboutMaps = true;
        }
      }

      var iterator = iteratorFn.call(children);
      var step = void 0;
      var ii = 0;
      while (!(step = iterator.next()).done) {
        child = step.value;
        nextName = nextNamePrefix + getComponentKey(child, ii++);
        subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
      }
    } else if (type === 'object') {
      var addendum = '';
      {
        addendum = ' If you meant to render a collection of children, use an array ' + 'instead.' + ReactDebugCurrentFrame.getStackAddendum();
      }
      var childrenString = '' + children;
      invariant(false, 'Objects are not valid as a React child (found: %s).%s', childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString, addendum);
    }
  }

  return subtreeCount;
}

/**
 * Traverses children that are typically specified as `props.children`, but
 * might also be specified through attributes:
 *
 * - `traverseAllChildren(this.props.children, ...)`
 * - `traverseAllChildren(this.props.leftPanelChildren, ...)`
 *
 * The `traverseContext` is an optional argument that is passed through the
 * entire traversal. It can be used to store accumulations or anything else that
 * the callback might find relevant.
 *
 * @param {?*} children Children tree object.
 * @param {!function} callback To invoke upon traversing each child.
 * @param {?*} traverseContext Context for traversal.
 * @return {!number} The number of children in this subtree.
 */
function traverseAllChildren(children, callback, traverseContext) {
  if (children == null) {
    return 0;
  }

  return traverseAllChildrenImpl(children, '', callback, traverseContext);
}

/**
 * Generate a key string that identifies a component within a set.
 *
 * @param {*} component A component that could contain a manual key.
 * @param {number} index Index that is used if a manual key is not provided.
 * @return {string}
 */
function getComponentKey(component, index) {
  // Do some typechecking here since we call this blindly. We want to ensure
  // that we don't block potential future ES APIs.
  if (typeof component === 'object' && component !== null && component.key != null) {
    // Explicit key
    return escape(component.key);
  }
  // Implicit key determined by the index in the set
  return index.toString(36);
}

function forEachSingleChild(bookKeeping, child, name) {
  var func = bookKeeping.func,
      context = bookKeeping.context;

  func.call(context, child, bookKeeping.count++);
}

/**
 * Iterates through children that are typically specified as `props.children`.
 *
 * See https://reactjs.org/docs/react-api.html#reactchildrenforeach
 *
 * The provided forEachFunc(child, index) will be called for each
 * leaf child.
 *
 * @param {?*} children Children tree container.
 * @param {function(*, int)} forEachFunc
 * @param {*} forEachContext Context for forEachContext.
 */
function forEachChildren(children, forEachFunc, forEachContext) {
  if (children == null) {
    return children;
  }
  var traverseContext = getPooledTraverseContext(null, null, forEachFunc, forEachContext);
  traverseAllChildren(children, forEachSingleChild, traverseContext);
  releaseTraverseContext(traverseContext);
}

function mapSingleChildIntoContext(bookKeeping, child, childKey) {
  var result = bookKeeping.result,
      keyPrefix = bookKeeping.keyPrefix,
      func = bookKeeping.func,
      context = bookKeeping.context;


  var mappedChild = func.call(context, child, bookKeeping.count++);
  if (Array.isArray(mappedChild)) {
    mapIntoWithKeyPrefixInternal(mappedChild, result, childKey, emptyFunction.thatReturnsArgument);
  } else if (mappedChild != null) {
    if (isValidElement(mappedChild)) {
      mappedChild = cloneAndReplaceKey(mappedChild,
      // Keep both the (mapped) and old keys if they differ, just as
      // traverseAllChildren used to do for objects as children
      keyPrefix + (mappedChild.key && (!child || child.key !== mappedChild.key) ? escapeUserProvidedKey(mappedChild.key) + '/' : '') + childKey);
    }
    result.push(mappedChild);
  }
}

function mapIntoWithKeyPrefixInternal(children, array, prefix, func, context) {
  var escapedPrefix = '';
  if (prefix != null) {
    escapedPrefix = escapeUserProvidedKey(prefix) + '/';
  }
  var traverseContext = getPooledTraverseContext(array, escapedPrefix, func, context);
  traverseAllChildren(children, mapSingleChildIntoContext, traverseContext);
  releaseTraverseContext(traverseContext);
}

/**
 * Maps children that are typically specified as `props.children`.
 *
 * See https://reactjs.org/docs/react-api.html#reactchildrenmap
 *
 * The provided mapFunction(child, key, index) will be called for each
 * leaf child.
 *
 * @param {?*} children Children tree container.
 * @param {function(*, int)} func The map function.
 * @param {*} context Context for mapFunction.
 * @return {object} Object containing the ordered map of results.
 */
function mapChildren(children, func, context) {
  if (children == null) {
    return children;
  }
  var result = [];
  mapIntoWithKeyPrefixInternal(children, result, null, func, context);
  return result;
}

/**
 * Count the number of children that are typically specified as
 * `props.children`.
 *
 * See https://reactjs.org/docs/react-api.html#reactchildrencount
 *
 * @param {?*} children Children tree container.
 * @return {number} The number of children.
 */
function countChildren(children) {
  return traverseAllChildren(children, emptyFunction.thatReturnsNull, null);
}

/**
 * Flatten a children object (typically specified as `props.children`) and
 * return an array with appropriately re-keyed children.
 *
 * See https://reactjs.org/docs/react-api.html#reactchildrentoarray
 */
function toArray(children) {
  var result = [];
  mapIntoWithKeyPrefixInternal(children, result, null, emptyFunction.thatReturnsArgument);
  return result;
}

/**
 * Returns the first child in a collection of children and verifies that there
 * is only one child in the collection.
 *
 * See https://reactjs.org/docs/react-api.html#reactchildrenonly
 *
 * The current implementation of this function assumes that a single child gets
 * passed without a wrapper, but the purpose of this helper function is to
 * abstract away the particular structure of children.
 *
 * @param {?object} children Child collection structure.
 * @return {ReactElement} The first and only `ReactElement` contained in the
 * structure.
 */
function onlyChild(children) {
  !isValidElement(children) ? invariant(false, 'React.Children.only expected to receive a single React element child.') : void 0;
  return children;
}

function createContext(defaultValue, calculateChangedBits) {
  if (calculateChangedBits === undefined) {
    calculateChangedBits = null;
  } else {
    {
      !(calculateChangedBits === null || typeof calculateChangedBits === 'function') ? warning(false, 'createContext: Expected the optional second argument to be a ' + 'function. Instead received: %s', calculateChangedBits) : void 0;
    }
  }

  var context = {
    $$typeof: REACT_CONTEXT_TYPE,
    _calculateChangedBits: calculateChangedBits,
    _defaultValue: defaultValue,
    _currentValue: defaultValue,
    // As a workaround to support multiple concurrent renderers, we categorize
    // some renderers as primary and others as secondary. We only expect
    // there to be two concurrent renderers at most: React Native (primary) and
    // Fabric (secondary); React DOM (primary) and React ART (secondary).
    // Secondary renderers store their context values on separate fields.
    _currentValue2: defaultValue,
    _changedBits: 0,
    _changedBits2: 0,
    // These are circular
    Provider: null,
    Consumer: null
  };

  context.Provider = {
    $$typeof: REACT_PROVIDER_TYPE,
    _context: context
  };
  context.Consumer = context;

  {
    context._currentRenderer = null;
    context._currentRenderer2 = null;
  }

  return context;
}

function forwardRef(render) {
  {
    !(typeof render === 'function') ? warning(false, 'forwardRef requires a render function but was given %s.', render === null ? 'null' : typeof render) : void 0;

    if (render != null) {
      !(render.defaultProps == null && render.propTypes == null) ? warning(false, 'forwardRef render functions do not support propTypes or defaultProps. ' + 'Did you accidentally pass a React component?') : void 0;
    }
  }

  return {
    $$typeof: REACT_FORWARD_REF_TYPE,
    render: render
  };
}

var describeComponentFrame = function (name, source, ownerName) {
  return '\n    in ' + (name || 'Unknown') + (source ? ' (at ' + source.fileName.replace(/^.*[\\\/]/, '') + ':' + source.lineNumber + ')' : ownerName ? ' (created by ' + ownerName + ')' : '');
};

function isValidElementType(type) {
  return typeof type === 'string' || typeof type === 'function' ||
  // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
  type === REACT_FRAGMENT_TYPE || type === REACT_ASYNC_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_TIMEOUT_TYPE || typeof type === 'object' && type !== null && (type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE);
}

function getComponentName(fiber) {
  var type = fiber.type;

  if (typeof type === 'function') {
    return type.displayName || type.name;
  }
  if (typeof type === 'string') {
    return type;
  }
  switch (type) {
    case REACT_ASYNC_MODE_TYPE:
      return 'AsyncMode';
    case REACT_CONTEXT_TYPE:
      return 'Context.Consumer';
    case REACT_FRAGMENT_TYPE:
      return 'ReactFragment';
    case REACT_PORTAL_TYPE:
      return 'ReactPortal';
    case REACT_PROFILER_TYPE:
      return 'Profiler(' + fiber.pendingProps.id + ')';
    case REACT_PROVIDER_TYPE:
      return 'Context.Provider';
    case REACT_STRICT_MODE_TYPE:
      return 'StrictMode';
    case REACT_TIMEOUT_TYPE:
      return 'Timeout';
  }
  if (typeof type === 'object' && type !== null) {
    switch (type.$$typeof) {
      case REACT_FORWARD_REF_TYPE:
        var functionName = type.render.displayName || type.render.name || '';
        return functionName !== '' ? 'ForwardRef(' + functionName + ')' : 'ForwardRef';
    }
  }
  return null;
}

/**
 * ReactElementValidator provides a wrapper around a element factory
 * which validates the props passed to the element. This is intended to be
 * used only in DEV and could be replaced by a static type checker for languages
 * that support it.
 */

var currentlyValidatingElement = void 0;
var propTypesMisspellWarningShown = void 0;

var getDisplayName = function () {};
var getStackAddendum = function () {};

{
  currentlyValidatingElement = null;

  propTypesMisspellWarningShown = false;

  getDisplayName = function (element) {
    if (element == null) {
      return '#empty';
    } else if (typeof element === 'string' || typeof element === 'number') {
      return '#text';
    } else if (typeof element.type === 'string') {
      return element.type;
    }

    var type = element.type;
    if (type === REACT_FRAGMENT_TYPE) {
      return 'React.Fragment';
    } else if (typeof type === 'object' && type !== null && type.$$typeof === REACT_FORWARD_REF_TYPE) {
      var functionName = type.render.displayName || type.render.name || '';
      return functionName !== '' ? 'ForwardRef(' + functionName + ')' : 'ForwardRef';
    } else {
      return type.displayName || type.name || 'Unknown';
    }
  };

  getStackAddendum = function () {
    var stack = '';
    if (currentlyValidatingElement) {
      var name = getDisplayName(currentlyValidatingElement);
      var owner = currentlyValidatingElement._owner;
      stack += describeComponentFrame(name, currentlyValidatingElement._source, owner && getComponentName(owner));
    }
    stack += ReactDebugCurrentFrame.getStackAddendum() || '';
    return stack;
  };
}

function getDeclarationErrorAddendum() {
  if (ReactCurrentOwner.current) {
    var name = getComponentName(ReactCurrentOwner.current);
    if (name) {
      return '\n\nCheck the render method of `' + name + '`.';
    }
  }
  return '';
}

function getSourceInfoErrorAddendum(elementProps) {
  if (elementProps !== null && elementProps !== undefined && elementProps.__source !== undefined) {
    var source = elementProps.__source;
    var fileName = source.fileName.replace(/^.*[\\\/]/, '');
    var lineNumber = source.lineNumber;
    return '\n\nCheck your code at ' + fileName + ':' + lineNumber + '.';
  }
  return '';
}

/**
 * Warn if there's no key explicitly set on dynamic arrays of children or
 * object keys are not valid. This allows us to keep track of children between
 * updates.
 */
var ownerHasKeyUseWarning = {};

function getCurrentComponentErrorInfo(parentType) {
  var info = getDeclarationErrorAddendum();

  if (!info) {
    var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;
    if (parentName) {
      info = '\n\nCheck the top-level render call using <' + parentName + '>.';
    }
  }
  return info;
}

/**
 * Warn if the element doesn't have an explicit key assigned to it.
 * This element is in an array. The array could grow and shrink or be
 * reordered. All children that haven't already been validated are required to
 * have a "key" property assigned to it. Error statuses are cached so a warning
 * will only be shown once.
 *
 * @internal
 * @param {ReactElement} element Element that requires a key.
 * @param {*} parentType element's parent's type.
 */
function validateExplicitKey(element, parentType) {
  if (!element._store || element._store.validated || element.key != null) {
    return;
  }
  element._store.validated = true;

  var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);
  if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
    return;
  }
  ownerHasKeyUseWarning[currentComponentErrorInfo] = true;

  // Usually the current owner is the offender, but if it accepts children as a
  // property, it may be the creator of the child that's responsible for
  // assigning it a key.
  var childOwner = '';
  if (element && element._owner && element._owner !== ReactCurrentOwner.current) {
    // Give the component that originally created this child.
    childOwner = ' It was passed a child from ' + getComponentName(element._owner) + '.';
  }

  currentlyValidatingElement = element;
  {
    warning(false, 'Each child in an array or iterator should have a unique "key" prop.' + '%s%s See https://fb.me/react-warning-keys for more information.%s', currentComponentErrorInfo, childOwner, getStackAddendum());
  }
  currentlyValidatingElement = null;
}

/**
 * Ensure that every element either is passed in a static location, in an
 * array with an explicit keys property defined, or in an object literal
 * with valid key property.
 *
 * @internal
 * @param {ReactNode} node Statically passed child of any type.
 * @param {*} parentType node's parent's type.
 */
function validateChildKeys(node, parentType) {
  if (typeof node !== 'object') {
    return;
  }
  if (Array.isArray(node)) {
    for (var i = 0; i < node.length; i++) {
      var child = node[i];
      if (isValidElement(child)) {
        validateExplicitKey(child, parentType);
      }
    }
  } else if (isValidElement(node)) {
    // This element was passed in a valid location.
    if (node._store) {
      node._store.validated = true;
    }
  } else if (node) {
    var iteratorFn = getIteratorFn(node);
    if (typeof iteratorFn === 'function') {
      // Entry iterators used to provide implicit keys,
      // but now we print a separate warning for them later.
      if (iteratorFn !== node.entries) {
        var iterator = iteratorFn.call(node);
        var step = void 0;
        while (!(step = iterator.next()).done) {
          if (isValidElement(step.value)) {
            validateExplicitKey(step.value, parentType);
          }
        }
      }
    }
  }
}

/**
 * Given an element, validate that its props follow the propTypes definition,
 * provided by the type.
 *
 * @param {ReactElement} element
 */
function validatePropTypes(element) {
  var type = element.type;
  var name = void 0,
      propTypes = void 0;
  if (typeof type === 'function') {
    // Class or functional component
    name = type.displayName || type.name;
    propTypes = type.propTypes;
  } else if (typeof type === 'object' && type !== null && type.$$typeof === REACT_FORWARD_REF_TYPE) {
    // ForwardRef
    var functionName = type.render.displayName || type.render.name || '';
    name = functionName !== '' ? 'ForwardRef(' + functionName + ')' : 'ForwardRef';
    propTypes = type.propTypes;
  } else {
    return;
  }
  if (propTypes) {
    currentlyValidatingElement = element;
    checkPropTypes(propTypes, element.props, 'prop', name, getStackAddendum);
    currentlyValidatingElement = null;
  } else if (type.PropTypes !== undefined && !propTypesMisspellWarningShown) {
    propTypesMisspellWarningShown = true;
    warning(false, 'Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?', name || 'Unknown');
  }
  if (typeof type.getDefaultProps === 'function') {
    !type.getDefaultProps.isReactClassApproved ? warning(false, 'getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.') : void 0;
  }
}

/**
 * Given a fragment, validate that it can only be provided with fragment props
 * @param {ReactElement} fragment
 */
function validateFragmentProps(fragment) {
  currentlyValidatingElement = fragment;

  var keys = Object.keys(fragment.props);
  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    if (key !== 'children' && key !== 'key') {
      warning(false, 'Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.%s', key, getStackAddendum());
      break;
    }
  }

  if (fragment.ref !== null) {
    warning(false, 'Invalid attribute `ref` supplied to `React.Fragment`.%s', getStackAddendum());
  }

  currentlyValidatingElement = null;
}

function createElementWithValidation(type, props, children) {
  var validType = isValidElementType(type);

  // We warn in this case but don't throw. We expect the element creation to
  // succeed and there will likely be errors in render.
  if (!validType) {
    var info = '';
    if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {
      info += ' You likely forgot to export your component from the file ' + "it's defined in, or you might have mixed up default and named imports.";
    }

    var sourceInfo = getSourceInfoErrorAddendum(props);
    if (sourceInfo) {
      info += sourceInfo;
    } else {
      info += getDeclarationErrorAddendum();
    }

    info += getStackAddendum() || '';

    var typeString = void 0;
    if (type === null) {
      typeString = 'null';
    } else if (Array.isArray(type)) {
      typeString = 'array';
    } else {
      typeString = typeof type;
    }

    warning(false, 'React.createElement: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', typeString, info);
  }

  var element = createElement.apply(this, arguments);

  // The result can be nullish if a mock or a custom function is used.
  // TODO: Drop this when these are no longer allowed as the type argument.
  if (element == null) {
    return element;
  }

  // Skip key warning if the type isn't valid since our key validation logic
  // doesn't expect a non-string/function type and can throw confusing errors.
  // We don't want exception behavior to differ between dev and prod.
  // (Rendering will throw with a helpful message and as soon as the type is
  // fixed, the key warnings will appear.)
  if (validType) {
    for (var i = 2; i < arguments.length; i++) {
      validateChildKeys(arguments[i], type);
    }
  }

  if (type === REACT_FRAGMENT_TYPE) {
    validateFragmentProps(element);
  } else {
    validatePropTypes(element);
  }

  return element;
}

function createFactoryWithValidation(type) {
  var validatedFactory = createElementWithValidation.bind(null, type);
  validatedFactory.type = type;
  // Legacy hook: remove it
  {
    Object.defineProperty(validatedFactory, 'type', {
      enumerable: false,
      get: function () {
        lowPriorityWarning$1(false, 'Factory.type is deprecated. Access the class directly ' + 'before passing it to createFactory.');
        Object.defineProperty(this, 'type', {
          value: type
        });
        return type;
      }
    });
  }

  return validatedFactory;
}

function cloneElementWithValidation(element, props, children) {
  var newElement = cloneElement.apply(this, arguments);
  for (var i = 2; i < arguments.length; i++) {
    validateChildKeys(arguments[i], newElement.type);
  }
  validatePropTypes(newElement);
  return newElement;
}

var React = {
  Children: {
    map: mapChildren,
    forEach: forEachChildren,
    count: countChildren,
    toArray: toArray,
    only: onlyChild
  },

  createRef: createRef,
  Component: Component,
  PureComponent: PureComponent,

  createContext: createContext,
  forwardRef: forwardRef,

  Fragment: REACT_FRAGMENT_TYPE,
  StrictMode: REACT_STRICT_MODE_TYPE,
  unstable_AsyncMode: REACT_ASYNC_MODE_TYPE,
  unstable_Profiler: REACT_PROFILER_TYPE,

  createElement: createElementWithValidation,
  cloneElement: cloneElementWithValidation,
  createFactory: createFactoryWithValidation,
  isValidElement: isValidElement,

  version: ReactVersion,

  __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: {
    ReactCurrentOwner: ReactCurrentOwner,
    // Used by renderers to avoid bundling object-assign twice in UMD bundles:
    assign: _assign
  }
};

if (enableSuspense) {
  React.Timeout = REACT_TIMEOUT_TYPE;
}

{
  _assign(React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, {
    // These should not be included in production.
    ReactDebugCurrentFrame: ReactDebugCurrentFrame,
    // Shim for React DOM 16.0.0 which still destructured (but not used) this.
    // TODO: remove in React 17.0.
    ReactComponentTreeHook: {}
  });
}



var React$2 = Object.freeze({
	default: React
});

var React$3 = ( React$2 && React ) || React$2;

// TODO: decide on the top-level export form.
// This is hacky but makes it work with both Rollup and Jest.
var react = React$3.default ? React$3.default : React$3;

module.exports = react;
  })();
}
});

var react_16_4_1_index = createCommonjsModule(function (module) {

if (process.env.NODE_ENV === 'production') {
  module.exports = react_production_min;
} else {
  module.exports = react_development;
}
});

var ORDER = undefined;

function Observer(onUpdate) {
	this.newDependencies = canObservationRecorder_1_1_2_canObservationRecorder.makeDependenciesRecorder();
	this.oldDependencies = null;
	this.onUpdate = onUpdate;

	var self = this;
	this.onDependencyChange = function(newVal, oldVal) {
		self.dependencyChange(this, newVal, oldVal);
	};
}

var weLeftSomethingOnTheStack = false;
Observer.prototype.startRecording = function() {
	if(weLeftSomethingOnTheStack){
		var deps = canObservationRecorder_1_1_2_canObservationRecorder.stop();
		if(!deps.reactViewModel){
			throw new Error('One of these things is not like the others');
		}
	}

	this.oldDependencies = this.newDependencies;
	this.nextDependencies = canObservationRecorder_1_1_2_canObservationRecorder.start();
	this.nextDependencies.reactViewModel = true;
	weLeftSomethingOnTheStack = true;

	if(this.order !== undefined) {
		ORDER = this.order;
	}
	else {
		if(ORDER !== undefined) {
			this.order = ++ORDER;
		}
		else {
			// the root component
			this.order = ORDER = 0;
		}
	}

	// console.log(canReflect.getName(this), this.order)
};

Observer.prototype.stopRecording = function() {
	if(weLeftSomethingOnTheStack){
		var deps = canObservationRecorder_1_1_2_canObservationRecorder.stop();
		weLeftSomethingOnTheStack = false;

		if(!deps.reactViewModel){
			throw new Error('One of these things is not like the others');
		}
	}
	this.newDependencies = this.nextDependencies;
	canObservation_4_0_1_recorderDependencyHelpers.updateObservations(this);
};

Observer.prototype.dependencyChange = function() {
	canQueues_1_1_0_canQueues.deriveQueue.enqueue(this.onUpdate, this, [], { priority: this.order });
};

Observer.prototype.teardown = function() {
	canQueues_1_1_0_canQueues.deriveQueue.dequeue(this.onUpdate);
};

Observer.prototype.ignore = function(fn) {
	canObservation_4_0_1_canObservation.ignore(fn)();
};

//!steal-remove-start
canReflect_1_16_7_canReflect.assignSymbols(Observer.prototype, {
	"can.getName": function() {
		return canReflect_1_16_7_canReflect.getName(this.constructor) + "<" + canReflect_1_16_7_canReflect.getName(this.onUpdate) + ">";
	},
});
//!steal-remove-end

var reactViewModel_1_0_0_observer = Observer;

var makeEnumerable = function makeEnumerable(Type, recursive) {
	if (isEnumerable(Type)) {
		return;
	}

	if (recursive === undefined) {
		recursive = true;
	}

	var setup = Type.prototype.setup;
	Type.prototype.setup = function() {
		if (this._define) {
			var map = this;

			each_1(this._define.definitions, function(value, prop) {
				var descriptor = Object.getOwnPropertyDescriptor(map.constructor.prototype, prop);
				descriptor.enumerable = true;
				Object.defineProperty(map, prop, descriptor);

				if (recursive && value.Type) {
					makeEnumerable(value.Type, recursive);
				}
			});

			each_1(this._define.methods, function(method, prop) {
				if (prop === 'constructor') {
					return;
				}

				var descriptor = Object.getOwnPropertyDescriptor(map.constructor.prototype, prop);
				descriptor.enumerable = true;
				Object.defineProperty(map, prop, descriptor);
			});
		}

		return setup.apply(this, arguments);
	};

	Object.defineProperty(Type, "__isEnumerable", {
		enumerable: false,
		value: true,
	});
};

function isEnumerable(Type) {
	return !!Type.__isEnumerable;
}

var isEnumerable_1 = isEnumerable;
makeEnumerable.isEnumerable = isEnumerable_1;

var METHODS_TO_AUTOBIND_KEY = '_methodsToAutobind-react-view-models';

var autobindMethods = function autobindMethods(ViewModel) {
	if (ViewModel[METHODS_TO_AUTOBIND_KEY]) {
		return;
	}
	var setup = ViewModel.prototype.setup;
	var methods = getMethods(ViewModel.prototype, {});
	Object.defineProperty(ViewModel, METHODS_TO_AUTOBIND_KEY, {
		enumerable: false,
		value: methods
	});
	ViewModel.prototype.setup = function setUpWithAutobind() {
		for (var key in methods) {
			this[key] = methods[key].bind(this);
		}
		// call original setup
		return setup.apply(this, arguments);
	};
};

function getMethods(proto, methods) {
	if (proto && proto !== Object.prototype && proto !== map$2.prototype) {
		each_1(proto._define.methods, function (property, key) {
			if (!(key in methods) && key !== 'constructor') {
				methods[key] = property;
			}
		});
		return getMethods(Object.getPrototypeOf(proto), methods);
	}
	return methods;
}

var reactViewModel_1_0_0_component = createCommonjsModule(function (module) {
if (react_16_4_1_index) {
	var Component = function Component() {
		react_16_4_1_index.Component.call(this);

		if (this.constructor.ViewModel) {
			autobindMethods(this.constructor.ViewModel, true);
			makeEnumerable(this.constructor.ViewModel, true);
		}

		var observer = function () {
			if (typeof this._shouldComponentUpdate !== "function" || this._shouldComponentUpdate()) {
				this.forceUpdate();
			}
		}.bind(this);

		//!steal-remove-start
		Object.defineProperty(observer, "name", {
			value: canReflect_1_16_7_canReflect.getName(this),
		});
		//!steal-remove-end

		this._observer = new reactViewModel_1_0_0_observer(observer);

		if (typeof this.shouldComponentUpdate === "function") {
			this._shouldComponentUpdate = this.shouldComponentUpdate;
		}
		this.shouldComponentUpdate = function () { return false; };

		//!steal-remove-start
		if (typeof process === "undefined" || process.env.NODE_ENV !== "production") {
			if (!this.constructor.ViewModel) {
				dev$3.warn("The ReactViewModel Component " + this.constructor.name + " was created without a ViewModel.");
			}

			var methods = [
				"componentWillReceiveProps",
				"componentWillMount",
				"componentDidMount",
				"componentWillUpdate",
				"componentDidUpdate",
				"componentWillUnmount",
			];

			methods.forEach(function (method) {
				var methodAsString = this[method].toString();
				if (
					this[method] !== Component.prototype[method]
					&& !methodAsString.includes(method, methodAsString.indexOf(") {"))
				) {
					throw new Error("super." + method + "() must be called on " + this.constructor.name + ".");
				}
			}.bind(this));
		}
		//!steal-remove-end
	};

	Component.prototype = Object.create(react_16_4_1_index.Component.prototype);
	Component.prototype.constructor = Component;

	assign$7(Component.prototype, {
		constructor: Component,

		componentWillReceiveProps: function(nextProps) {
			var props = {};

			for (var key in nextProps) {
				if (!(key in this.props) || nextProps[key] !== this.props[key]) {
					props[key] = nextProps[key];
				}
			}

			this._observer.ignore(function () {
				this.viewModel.assign(props);
			}.bind(this));
		},

		componentWillMount: function() {
			var ViewModel = this.constructor.ViewModel || map$2;
			this.viewModel = new ViewModel( this.props );

			this._observer.startRecording();
		},

		componentDidMount: function() {
			this._observer.stopRecording();
		},

		componentWillUpdate: function() {
			this._observer.startRecording();
		},

		componentDidUpdate: function() {
			this._observer.stopRecording();
		},

		componentWillUnmount: function() {
			this._observer.teardown();
			this.viewModel = null;
		},
	});

	//!steal-remove-start
	canReflect_1_16_7_canReflect.assignSymbols(Component.prototype, {
		"can.getName": function() {
			return canReflect_1_16_7_canReflect.getName(this.constructor) + "{}";
		},
	});
	//!steal-remove-end

	module.exports = canNamespace_1_0_0_canNamespace.ReactViewModelComponent = Component;
}
else {
	module.exports = canNamespace_1_0_0_canNamespace.ReactViewModelComponent = function Component() {
		throw new Error("You must provide React before can.all.js");
	};
}
});

var ObservablePromise = map$2.extend("ObservablePromise", {
	init: function (promise) {
		this.promise = promise;
	},

	promise: "any",
	isPending: {
		get: function () {
			return canStacheKey_1_3_2_canStacheKey.read(this, canStacheKey_1_3_2_canStacheKey.reads("promise.isPending")).value;
		}
	},
	isResolved: {
		get: function () {
			return canStacheKey_1_3_2_canStacheKey.read(this, canStacheKey_1_3_2_canStacheKey.reads("promise.isResolved")).value;
		}
	},
	isRejected: {
		get: function () {
			return canStacheKey_1_3_2_canStacheKey.read(this, canStacheKey_1_3_2_canStacheKey.reads("promise.isRejected")).value;
		}
	},
	reason: {
		get: function () {
			return canStacheKey_1_3_2_canStacheKey.read(this, canStacheKey_1_3_2_canStacheKey.reads("promise.reason")).value;
		}
	},
	value: {
		get: function () {
			return canStacheKey_1_3_2_canStacheKey.read(this, canStacheKey_1_3_2_canStacheKey.reads("promise.value")).value;
		}
	}
});

var reactViewModel_1_0_0_reactViewModel = canNamespace_1_0_0_canNamespace.reactViewModel = function reactViewModel(displayName, ViewModel, render) {
	if (arguments.length === 1) {
		render = arguments[0];
		ViewModel = null;
		displayName = null;
	}
	if (arguments.length === 2) {
		render = arguments[1];

		if (typeof arguments[0] === "string") {
			displayName = arguments[0];
			ViewModel = null;
		}
		else {
			ViewModel = arguments[0];
			displayName = null;
		}
	}
	if (!displayName) {
		displayName = (render.displayName || render.name || "ReactVMComponent" ) + 'Wrapper';
	}

	function App() {
		reactViewModel_1_0_0_component.call(this);
	}

	App.ViewModel = ViewModel;
	App.displayName = displayName;

	App.prototype = Object.create(reactViewModel_1_0_0_component.prototype);

	assign$7(App.prototype, {
		constructor: App,

		render: function() {
			return render(this.viewModel);
		}
	});

	try {
		Object.defineProperty(App, "name", {
			writable: false,
			enumerable: false,
			configurable: true,
			value: displayName
		});
	}
	catch(e) {
		//
	}

	return App;
};

// Expose Component and helpers to named imports
var Component_1 = reactViewModel_1_0_0_component;
var ObservablePromise_1 = ObservablePromise;
var autobindMethods_1 = autobindMethods;
var makeEnumerable_1 = makeEnumerable;
reactViewModel_1_0_0_reactViewModel.Component = Component_1;
reactViewModel_1_0_0_reactViewModel.ObservablePromise = ObservablePromise_1;
reactViewModel_1_0_0_reactViewModel.autobindMethods = autobindMethods_1;
reactViewModel_1_0_0_reactViewModel.makeEnumerable = makeEnumerable_1;

var camelize = canString_0_0_5_canString.camelize;



var ignoreAttributesRegExp = /^(dataViewId|class|id|type|src)$/i;

var typeMatch = /\s*text\/(stache)\s*/;
function isIn(element, type) {
	while(element.parentNode) {
		element = element.parentNode;
		if(element.nodeName.toLowerCase() === type.toLowerCase()) {
			return true;
		}
	}
}
function setAttr(el, attr, scope){
	var camelized = camelize(attr);
	if (!ignoreAttributesRegExp.test(camelized) ) {
		var value = el.getAttribute(attr);
		if(scope.attr) {
			scope.attr(camelized, value);
		} else if(scope.set) {
			scope.set(camelized, value);
		} else {
			scope[camelized] = value;
		}
	}
}
function insertAfter(ref, element) {
	if(ref.nextSibling){
		ref.parentNode.insertBefore(element, ref.nextSibling);
	} else {
		ref.parentNode.appendChild(element);
	}
}

function render(renderer, scope, el) {
	var frag = renderer(scope);
	if( isIn(el, "head") ) {
		document.body.appendChild(frag);
	} else if(el.nodeName.toLowerCase() === "script") {
		insertAfter(el, frag);
	} else {
		insertAfter(el, frag);
		el.parentNode.removeChild(el);
	}
}
function setupScope(el) {
	var scope = canViewModel_4_0_1_canViewModel(el);

	canReflect_1_16_7_canReflect.each(el.attributes || [], function(attr) {
		setAttr(el, attr.name, scope);
	});

	canDomEvents_1_2_0_canDomEvents.addEventListener(el, "attributes", function(ev) {
		setAttr(el, ev.attributeName, scope);
	});

	return scope;
}

var promise = new Promise(function(resolve, reject) {
	function autoload(){
		var promises = [];

		canReflect_1_16_7_canReflect.each(document.querySelectorAll("[can-autorender]"), function( el, i){
			el.style.display = "none";

			var text = el.innerHTML || el.text,
				typeAttr = el.getAttribute("type"),
				typeInfo = typeAttr.match( typeMatch ),
				type = typeInfo && typeInfo[1],
				typeModule = "can-" + type;

			promises.push(canImportModule_1_0_0_canImportModule(typeModule).then(function(engine){
				if(engine.async) {
					return engine.async(text).then(function(renderer){
						render(renderer, setupScope(el), el);
					});
				} else {
					var renderer = engine(text);
					render(renderer, setupScope(el), el);
				}
			}));

		});

		Promise.all(promises).then(resolve, reject);
	}

	if (document.readyState === "complete") {
		autoload();
	} else {
		canDomEvents_1_2_0_canDomEvents.addEventListener(window, "load", autoload);
	}
});

var canViewAutorender_5_0_0Pre_0_canViewAutorender = canNamespace_1_0_0_canNamespace.autorender = function autorender(success, error){
	return promise.then(success, error);
};

var extractResponse = canFixture_3_0_0Pre_11_core.extractResponse;

/**
 * @function can-fixture-socket.requestHandlerToListener requestHandlerToListener
 * @parent can-fixture-socket.properties
 * 
 * Transforms XHR request handler into socket event listener.
 * 
 * @signature `requestHandlerToListener( reqHandler )`
 *
 * Transforms request handler that expects two arguments `request` and `response` into socket event listener.
 * 
 * ```js
 * server.on("news find", requestHandlerToListener( fixtureStore.getListData ));
 * ```
 *     
 * @param {Function} reqHandler A request handler, e.g. [can-fixture/StoreType.prototype.getListData].
 * @returns {can-fixture-store.socket-event-listener}
 * 
 * @body
 * 
 * ## Use
 *
 * Fixture [can-fixture.store] methods expect two arguments `req` and `res` and work like this:
 *   - grab query from `req.data`;
 *   - on error call `res( 403, err )`;
 *   - on success call `res( data )`.
 *   
 * The format of the returned data is:
 *   - for [can-fixture/StoreType.prototype.getDataList]: {count: <number>, limit: <number>, offset: <number> , data: [{...},{...}, ...]}
 *   - for [can-fixture/StoreType.prototype.getData]: the item object.
 * 
 * We can use the helper to transform fixture store methods into event listeners:
 * ```js
 * var fixture = require("can-fixture");
 * var canSet = require("can-set");
 * var io = require("socket.io-client");
 * var fixtureSocket = require("can-fixture-socket");
 * 
 * // Create fixture store:
 * var fixtureStore = fixture.store([
 *   {id: 1, title: 'One'},
 *   {id: 2, title: 'Two'},
 *   {id: 3, title: 'Three'}
 * ], new canSet.Algebra({}));
 * 
 * var mockedServer = new fixtureSocket.Server(io);
 * mockedServer.on("books find", fixtureStore.requestHandlerToListener( fixtureStore.getListData ));
 * ```
 */
function requestHandlerToListener(method){
	return function(query, fn){
		var req = {data: query};
		var res = function(){
			var response = extractResponse.apply(null, arguments);
			if (response[0] === 200){
				fn(null, response[1]);
			} else {
				fn(response[1]);
			}
		};
		method(req, res);
	}
}

/**
 * @function can-fixture-socket.storeToListeners storeToListeners
 * @parent can-fixture-socket.properties
 * 
 * Returns a set of listeners transformed from fixture store request handlers. Useful for working with REST-ful resources.
 * 
 * @signature `storeToListeners( fixtureStore )`
 * 
 * Wraps methods of fixture.store to make them socket event listener.
 * 
 * ```js
 * var listeners = storeToListeners( fixtureStore );
 * 
 * server.on({
 *   "news find": listeners.getListData,
 *   "news get": listeners.getData,
 * })
 * ```
 * 
 * @param fixtureStore
 * @returns {*}
 * 
 * @body
 * 
 * ## Use
 * 
 * Fixture [can-fixture.store] provides REST-ful resource storage. Its designed to work with XHR requests thus its methods expect two arguments `request` and `response`. To work with socket events we need to transform request handlers into socket event listeners.
 * 
 * Here is how we can do this:
 * 
 * ```js
 * var fixture = require("can-fixture");
 * var canSet = require("can-set");
 * var io = require("socket.io-client");
 * var fixtureSocket = require("can-fixture-socket");
 *
 * // Create fixture store:
 * var fixtureStore = fixture.store([
 *   {id: 1, title: 'One'},
 *   {id: 2, title: 'Two'},
 *   {id: 3, title: 'Three'}
 * ], new canSet.Algebra({}));
 * 
 * // Instantiate mocked socket server:
 * var mockedServer = new fixtureSocket.Server(io);
 * 
 * // Now use fixture store to emulate REST-ful service:
 * var toListener = fixtureStore.requestHandlerToListener;
 * mockedServer.on({
 *   "books find":   toListener( fixtureStore.getListData ),
 *   "books get":    toListener( fixtureStore.getData ),
 *   "books create": toListener( fixtureStore.createData ),
 *   "books update": toListener( fixtureStore.updateData ),
 *   "books delete": toListener( fixtureStore.destroyData )
 * });
 * ```
 */
function storeToListeners(fixtureStore){
	var methods = ['getListData', 'getData', 'updateData', 'createData', 'destroyData'];
	return methods.reduce(function(listeners, method){
		listeners[method] = requestHandlerToListener(fixtureStore[method]);
		return listeners;
	}, {});
}

var store$1 = {
	requestHandlerToListener: requestHandlerToListener,
	storeToListeners: storeToListeners
};

/*
 * FEATHERS protocol.
 * Feathers service api (REST provider): https://docs.feathersjs.com/rest/readme.html
 * 
 * 
 * - Common Error Response Packet:
 * REQ: 422["messages::get",111,{}]
 * RES: 432[{"stack":"NotFound: No record found for id '111' ...","message":"No record found for id '111'","type":"FeathersError","name":"NotFound","code":404,"className":"not-found","errors":{}}]
 * 
 * 
 * - socket.emit('messages::find', {}, function(error, data){});
 * REQ: 421["messages::find",{"$sort":{"createdAt":-1},"$limit":10}]
 * RES: 434[null,{"total":10,"limit":5,"skip":0,"data":[]}]
 * 
 * 
 * - socket.emit('messages::get', 'uOybkd5RVe5wKoxy', {}, function(error, data){});
 * REQ: 422["messages::get","uOybkd5RVe5wKoxy",{}]
 * RES: 432[null,{"text":"Hello from cmd!","createdAt":1475294332699,"_id":"uOybkd5RVe5wKoxy"}]
 * 
 * 
 * - socket.emit('messages::create', {text: 'New message'}, {}, function(error, data){});
 * REQ: 422["messages::create",{"text":"new message"},{}]
 * RES: 432[null,{"text":"new message","userId":"Ke8I0Kmn0lCyrEaq","createdAt":1476722319537,"_id":"ttnWkW4YhGRc1CDM","sentBy":{"email":"fadeev.ilya@gmail.com","password":"$2a$10$QqI4Uamr/mTH8P/.W0TNTuofjRuNDZLuyNaQzl3vHXhpzrWBwCo7q","avatar":"https://s.gravatar.com/avatar/44751bab986933e4405394fb32d6b91d?s=60","_id":"Ke8I0Kmn0lCyrEaq"}}]
 * EXT: 42["messages created",{"text":"new message","userId":"Ke8I0Kmn0lCyrEaq","createdAt":1476722319537,"_id":"ttnWkW4YhGRc1CDM","sentBy":{"email":"fadeev.ilya@gmail.com","password":"$2a$10$QqI4Uamr/mTH8P/.W0TNTuofjRuNDZLuyNaQzl3vHXhpzrWBwCo7q","avatar":"https://s.gravatar.com/avatar/44751bab986933e4405394fb32d6b91d?s=60","_id":"Ke8I0Kmn0lCyrEaq"}}]
 * 
 * 
 * - socket.emit('messages::remove', 'yDLARueVwSF0S6v8', {}, function(error, data){});
 * REQ: 422["messages::remove","yDLARueVwSF0S6v8",{}]
 * RES: 432[null,{"text":"helllllo","userId":"Ke8I0Kmn0lCyrEaq","createdAt":1476722461622,"_id":"yDLARueVwSF0S6v8"}]
 * EXT: 42["messages removed",{"text":"helllllo","userId":"Ke8I0Kmn0lCyrEaq","createdAt":1476722461622,"_id":"yDLARueVwSF0S6v8"}]
 * 
 * 
 * - socket.emit('messages::update', 'ttnWkW4YhGRc1CDM', {}, function(error, data){});
 * REQ: 422["messages::update","ttnWkW4YhGRc1CDM",{"text":"Updated text!"},{}]
 * RES: 432[null,{"text":"Updated text!","_id":"ttnWkW4YhGRc1CDM"}]
 * EXT: 42 ["messages updated",{"text":"Updated text!","_id":"ttnWkW4YhGRc1CDM"}]
 * 
 */

var storeToListeners$1 = store$1.storeToListeners;


/**
 * Subscribes to mocked socket server events for FeathersJS service.
 * Transforms ((query, fn))
 * @param serviceName
 * @param fixtureStore
 * @param mockServer
 * @param options
 * @returns {*}
 * @hide
 *
 * fixture.store data:
 * 		getListData: {}
 */
function subscribeFeathersStoreToServer(serviceName, fixtureStore, mockServer, options){
	var listeners = storeToListeners$1(fixtureStore);
	mockServer.on(serviceName + '::find', toFeathersDataHandler(listeners.getListData, null, toFeathersFind));
	mockServer.on(serviceName + '::get', toFeathersDataHandler(listeners.getData, wrapToId(options), null));
	
	// fixture.store.destroyData returns back the passed set, e.g. {id: 1}
	// https://github.com/canjs/can-connect/blob/master/data/memory-cache/memory-cache.js#L416
	// Feathers.remove returns back the whole object.
	mockServer.on(serviceName + '::remove', toFeathersRemoveHandler(listeners.getData, listeners.destroyData, options));
	
	mockServer.on(serviceName + '::create', toFeathersCreateHandler(listeners.createData));
	mockServer.on(serviceName + '::update', toFeathersUpdateHandler(listeners.updateData, options));
}

function toFeathersDataHandler(method, queryTransformer, dataTransformer){
	return function(query){
		var args = Array.prototype.slice.call(arguments),
			fn;
		if (typeof args[args.length-1] === 'function'){
			fn = args[args.length-1];
		}
		query = queryTransformer ? queryTransformer(query) : query;
		method(query, function(err, data){
			if (err){
				fn && fn(err);
			} else {
				data = dataTransformer ? dataTransformer(data) : data;
				fn && fn(null, data);
			}
		});
	}
}
/**
 * Wraps given id into an object with property name `id` (or options.id).
 * @param options
 * @returns {Function}
 * @hide
 */
function wrapToId(options){
	return function(id){
		var o = {},
			idProp = options && options.id || 'id';
		o[idProp] = id;
		return o;
	}
}

/**
 * Transforms getListData from fixture to feathers format.
 *   - fixture.store.getListData: {count, limit, offset, data}
 *   - feathers.find:             {total, limit, skip, data}
 * @param data
 * @returns {{total: number, limit: number, skip: number, data: *}}
 */
// fixture.store.getListData: {count, limit, offset, data}
// feathers.find:             {total, limit, skip, data}
function toFeathersFind(data){
	return {
		total: data.count,
		limit: data.limit,
		skip: data.offset,
		data: data.data
	};
}

/**
 * FeathersJS's `remove` method returns the whole item back, when fixture.store's `destroyData` gives back only the given query (e.g. {id: 123}).
 * Find the item by id first, then remove from fixture.store and return the item back.
 * 
 * Feathers `remove` method emits 2 arguments with data: `id` and `query`. But we ignore 2nd data argument for now.
 * 
 * @param destroyData The wrapped fixture.store.destroyData method.
 * @param getData The wrapped fixture.store.getData method.
 * @returns {Function}
 * @hide
 */
function toFeathersRemoveHandler(getData, destroyData, options){
	return function(id, query, fn){
		var setQuery = wrapToId(options)(id);
		getData(setQuery, function(err, item){
			if (err){
				fn(err);
			} else {
				destroyData(setQuery, function(err, data){
					if (err){
						fn(err);
					} else {
						fn(null, item);
					}
				});
			}
		});
	}
}
function toFeathersUpdateHandler(updateData, options){
	return function(id, data, query, fn){
		var setQuery = wrapToId(options)(id);
		updateData(assign$7(setQuery, data), function(err, data2){
			if (err){
				fn(err);
			} else {
				fn(null, assign$7(setQuery, assign$7(data, data2)));
			}
		});
	}
}
function toFeathersCreateHandler(createData){
	return function(data, query, fn){
		createData(data, function(err, data2){
			if (err){
				fn(err);
			} else {
				fn(null, assign$7(data, data2));
			}
		});
	}
}

var feathersClient = {
	subscribeFeathersStoreToServer: subscribeFeathersStoreToServer
};

/*
 * Summary: `io(url)` creates an instance of `io.Manager` for the given url and stores it in cache of managers `io.managers`.
 * If `io` is called with the same URL several times it will lookup Manager in the cache.
 * One manager creates one physical (transport) connection and can create several "virtual" connections within
 * the transport connection.
 * Manager has two main methods: `open` (alias `connect`) and `socket`. The first one establishes a transport connection
 * (e.g. http://localhost), the second one creates a socket.io connection (e.g. http://localhost/users).
 *
 * To fixture socket.io we need to:
 *   - mock a socket server;
 *   - override io.Manager.prototype methods to work with the mocked server.
 */

var subscribeFeathersStoreToServer$1 = feathersClient.subscribeFeathersStoreToServer;

/* 
 * See/update `docs/can-fixture-socket.server.md`.
 *
 * Mocked socket.io server that intercepts socket.io connection and can simulate socket.io server behaviour.
 * @constructor
 * @param {Object} io Imported `socket.io-client` object.
 */
var MockedServer = function(io){
	this.io = io;
	
	// PubSub:
	this.events = {};
	this.subscribers = {};

	// SocketIO stores an instantiated Manager in cache to reuse it for the same URL.
	// Reset cache of managers since we override Manager prototype to work with this particular instance of the mocked server:
	resetManagerCache(io.managers);

	// Override Manager's prototype:
	this.origs = mockManager(io.Manager.prototype, this);
};

/**
 * @function can-fixture-socket.Server.prototype.on on
 * @parent can-fixture-socket.Server.prototype
 * 
 * Adds a socket event listener.
 * 
 * @signature `server.on(event, handler)`
 * 
 * Adds a socket event listener.
 * 
 * ```js
 * server.on("notifications", function(data, ackFn){
 *   console.log("Received " + data);
 *   ackFn("Acknowledged, thank you");
 * });
 * ```
 * 
 *   @param {string} event The name of the socket event to listen for.
 *   @param {can-fixture-socket.socket-event-listener} handler The handler that will be executed to handle the socket event.
 * 
 * @signature `server.on(eventsObject)`
 * 
 * A short hand method to add multiple event listeners.
 * 
 * ```js
 * server.on({
 *   "news": handleNews,
 *   "tweets": handleTweets,
 *   "users": handleUsers
 * });
 * ```
 * 
 *   @param {object} eventsObject 
 */
MockedServer.prototype.on = function(event, cb){
	var self = this;
	var events = {};
	if (typeof event === 'string'){
		events[event] = cb;
	}
	if (typeof event === 'object'){
		events = event;
	}
	Object.keys(events).forEach(function(name){
		sub$1(self.events,  name, events[name]);
	});
};

/**
 * @function can-fixture-socket.Server.prototype.emit emit
 * @parent can-fixture-socket.Server.prototype
 * 
 * Emits a socket event.
 *
 * @signature `server.emit(event, ...data, [ackFn])`
 *
 * Emits a socket event.
 *
 * ```js
 * server.emit("news", data1, data2, function(ackData){
 *   console.log("Client acknowledged", ackData);
 * });
 * ```
 *
 *   @param {string} event The name of the socket event.
 *   @param {*} data Data to be sent with the event. Socket.io allows to send more than one data objects.
 *   @param {function} [ackFn] The acknowledgement function that will be executed if the receiver calls the acknowledgement callback.
 */
MockedServer.prototype.emit = function(event){
	var dataArgs = Array.prototype.slice.call(arguments, 1);
	pub(this.subscribers, event, dataArgs);
};

/* 
 * See/update `docs/can-fixture-socket.on-feathers-service.md`.
 * 
 * Subscribes to mocked server socket events to work as FeathersJS CRUD service. Uses fixture store [can-fixture.Store] as a resource storage.
 * 
 * @param {String} name The name of Feathers service.
 * @param {can-fixture.Store} fixtureStore An instance of [can-fixture.Store].
 * @param {Object} [options] Options, e.g. property name for id.
 */
MockedServer.prototype.onFeathersService = function(serviceName, fixtureStore, options){
	subscribeFeathersStoreToServer$1(serviceName, fixtureStore, this, options);
};

/**
 * @function can-fixture-socket.Server.prototype.restore restore
 * @parent can-fixture-socket.Server.prototype
 * 
 * @signature `server.restore()`
 * 
 * Restores `io.Manager.prototype` and clears `io.managers` cache.
 * 
 * ```
 * server.restore();
 * ```
 */
MockedServer.prototype.restore = function(){
	restoreManager(this.io.Manager.prototype, this.origs);
	resetManagerCache(this.io.managers);
};

/*
 * @constructor can-fixture-socket.Socket Socket
 * @private
 * @parent can-fixture-socket.types
 * 
 * @signature `new Socket(server)`
 * 
 * Manager instantiates Socket. We mock Socket's methods to work with the mocked server instance.
 * 
 *   @param {can-fixture-socket.Server} server Mocked server.
 */
var MockedSocket = function(server){
	this._server = server;
	this.io = {
		engine: this
	};
};
MockedSocket.prototype = {
	on: function(event, cb){
		debug$1('MockedSocket.on ... ' + event);
		sub$1(this._server.subscribers, event, cb);
	},
	/*
	 * The first argument is always `event`
	 * The middle arguments are data (usually one or two arguments).
	 * If the last argument is a function then its the ACK callback.
     */
	emit: function(event){
		var dataArgs = Array.prototype.slice.call(arguments, 1);
		debug$1('MockedSocket.emit ...' + event);
		pub(this._server.events, event, dataArgs);
	},
	once: function(){
		debug$1('MockedSocket.once ...');
	},
	off: function(event, cb){
		debug$1('MockedSocket.off ... ' + event);
		unsub(this._server.subscribers, event, cb);
	},
	open: function(){
		return this.connect();
	},
	connect: function(){
		this.connected = true;
		this.disconnected = false;
	},
	close: function(){
		return this.disconnect();
	},
	disconnect: function(){
		this.connected = false;
		this.disconnected = true;
	},
};

/*
 * PubSub helpers.
 * @param pubsub A list of pubs or subs.
 * @param event {String} A name for a pubsub item (e.g. a name of event that we emit or subscribe to).
 * @param dataArgs There could be either one or more data arguments (e.g. FeathersJS) and the last argument can be used for ACK callback. 
 */
function pub(pubsub, event, dataArgs){
	debug$1(' >>> pub ' + event);
	var subscribers = pubsub[event] || [];
	subscribers.forEach(function(subscriber){
		subscriber.apply(null, dataArgs);
	});
}
function sub$1(pubsub, event, cb){
	debug$1(' <<< sub ' + event);
	if (!pubsub[event]){
		pubsub[event] = [];
	}
	pubsub[event].push(cb);
}
function unsub(pubsub, event, cb){
	debug$1(' <<< unsub ' + event);
	pubsub[event].forEach(function(registeredCb, index){
		if(registeredCb === cb){
			pubsub[event].splice(index, 1);
		}
	});
}

/*
 * Override Manager.prototype's method to work with the instantiated mocked server.
 * @param managerProto
 * @param server
 * @returns {Array}
 */
function mockManager(managerProto, server){
	// We need to override `open` and `socket` methods:
	var methods = ['open','socket'];
	var origs = methods.map(function(name){
		return {
			name: name,
			method: managerProto[name]
		};
	});
	managerProto.open = managerProto.connect = function(){
		debug$1('MockedManager.prototype.open or connect ... arguments:', arguments);
		setTimeout(function(){
			pub(server.subscribers, 'connect');
			pub(server.events, 'connection');
		}, 0);
	};
	managerProto.socket = function(){
		debug$1('MockedManager.prototype.socket ...');
		var socket = new MockedSocket(server);
		socket.connected = true;
		socket.disconnected = false;
		return socket;
	};
	return origs;
}

/*
 * Restore Manager prototype.
 * @param managerProto
 * @param origs
 */
function restoreManager(managerProto, origs){
	debug$1('Restore.');
	origs.forEach(function(orig){
		managerProto[orig.name] = orig.method;
	});
}

/*
 * We need to reset cache of Managers so that the new mocked server would create a new Manager for the same URL.
 * @param cache
 */
function resetManagerCache(cache){
	for (var i in cache){
		if (cache.hasOwnProperty(i)){
			delete cache[i];
		}
	}
}

var _DEBUG = false;
function debug$1(msg, obj){
	if (_DEBUG){
		console.log.apply(console, arguments);
	}
}

var canFixtureSocket_2_0_0Pre_1_src = {
	Server: MockedServer,
	mockSocketManager: mockManager,
	restoreManager: restoreManager
};

var canFixtureSocket_2_0_0Pre_1_canFixtureSocket = {
	Server: canFixtureSocket_2_0_0Pre_1_src.Server,
	requestHandlerToListener: store$1.requestHandlerToListener,
	storeToListeners: store$1.storeToListeners
};

var each$6 = canReflect_1_16_7_canReflect.each;



var convertToValue = function(arg){
	if(typeof arg === "function") {
		return convertToValue( arg() );
	} else {
		return arg;
	}
};

function connectTag(tagName, connection){

	var removeBrackets = function(value, open, close){
		open = open || "{";
		close = close || "}";

		if(value[0] === open && value[value.length-1] === close) {
			return value.substr(1, value.length - 2);
		}
		return value;
	};


	canViewCallbacks_4_1_2_canViewCallbacks.tag(tagName, function(el, tagData){
		var getList = el.getAttribute("getList") || el.getAttribute("get-list");
		var getInstance = el.getAttribute("get");

		var attrValue = getList || getInstance;
		var method = getList ? "getList" : "get";

		var attrInfo = expression_1.parse('tmp(' + removeBrackets(attrValue)+")", {baseMethodType: "Call"});
		// -> {hash: {foo: 'bar', zed: 5, abc: {get: 'myValue'}}}


		var addedToPageData = false;
		var addToPageData = canObservationRecorder_1_1_2_canObservationRecorder.ignore(function(set, promise){
			if(!addedToPageData) {
				var root = tagData.scope.peek("%root") || tagData.scope.peek("@root");
				if( root && root.pageData ) {
					if(method === "get"){
						set = connection.id(set);
					}
					root.pageData(connection.name, set, promise);
				}
			}
			addedToPageData = true;
		});

		var request = new canObservation_4_0_1_canObservation(function(){
			var hash = {};
			if(typeof attrInfo.hash === "object") {
				// old expression data
				each$6(attrInfo.hash, function(val, key) {
					if (val && val.hasOwnProperty("get")) {
						hash[key] = tagData.scope.read(val.get, {}).value;
					} else {
						hash[key] = val;
					}
				});
			} else if(typeof attrInfo.hash === "function"){
				// new expression data
				var getHash = attrInfo.hash(tagData.scope, tagData.options, {});
				each$6(getHash(), function(val, key) {
					hash[key] = convertToValue(val);
				});
			} else {
				hash = attrInfo.argExprs.length ? canReflect_1_16_7_canReflect.getValue(attrInfo.argExprs[0].value(tagData.scope, tagData.options))
					: {};
			}

			var promise = connection[method](hash);
			addToPageData(hash, promise);
			return promise;
		});

		el[canSymbol_1_6_1_canSymbol.for('can.viewModel')] = request;

		var nodeList = canViewNodelist_4_2_0_canViewNodelist.register([], undefined, tagData.parentNodeList || true);

		var frag = tagData.subtemplate ?
					tagData.subtemplate( tagData.scope.add(request), tagData.options, nodeList ) :
					document.createDocumentFragment();

		// Append the resulting document fragment to the element
		canDomMutate_1_0_4_node.appendChild.call(el, frag);

		// update the nodeList with the new children so the mapping gets applied
		canViewNodelist_4_2_0_canViewNodelist.update(nodeList, el.childNodes);

		var removalDisposal = canDomMutate_1_0_4_canDomMutate.onNodeRemoval(el, function () {
			if (!el.ownerDocument.contains(el)) {
				removalDisposal();
				canViewNodelist_4_2_0_canViewNodelist.unregister(nodeList);
			}
		});
	});
}

var canConnectTag_1_0_0_canConnectTag = canNamespace_1_0_0_canNamespace.connectTag = connectTag;

// # can/map/map_helpers
// Helpers that enable bubbling of an event on a child object to a
// parent event on a parent object. Bubbling works by listening on the child object
// and forwarding events to the parent object.
//
// Bubbling is complicated because bubbling setup can happen before or after
// items are added to the parent object.
//
// This means that:
// - When bubbling is first initialied, by binding to an event that bubbles,
//   all child objects need to be setup to bubble. This is managed by [bubble.bind](#bubble-bind).
// - When bubbling is stopped, by removing all listeners to events that bubble,
//   all child objects need to have bubbling torn down. This is managed by [bubble.unbind](#bubble-unbind).
// - While bubbling is running, as child items are added,
//   the child elements need to be setup to bubble.  This is managed by [bubble.add](#bubble-add) and [bubble.addMany](#bubble-addmany).
// - While bubbling is running, as child items are removed,
//   the child elements need to stop bubbling. This is managed by
//   [bubble.remove](#bubble-remove) and [bubble.removeMany](#bubble-removeMany).
// - While bubbling is running, as child item replaces another child, the old child needs bubbling removed
//   and the new child needs bubbling setup. This is managed by [bubble.set](bubble-set).
//
// [bubble.events](bubble-events) controls which events setup bubbling.








var bubble = {
		// ## bubble.bind
		// Called when an event is bound to an object. This
		// should setup bubbling if this is the first time
		// an event that bubbles is bound.
		bind: function(parent, eventName) {
			if (!parent.__inSetup ) {

				var bubbleEvents = bubble.events(parent, eventName),
					len = bubbleEvents.length,
					bubbleEvent;

				if(!parent._bubbleBindings) {
					parent._bubbleBindings = {};
				}

				for (var i = 0; i < len; i++) {
					bubbleEvent = bubbleEvents[i];

					// If there isn't a bubbling setup for this binding,
					// bubble all the children; otherwise, increment the
					// number of bubble bindings.
					if (!parent._bubbleBindings[bubbleEvent]) {
						parent._bubbleBindings[bubbleEvent] = 1;
						bubble.childrenOf(parent, bubbleEvent);
					} else {
						parent._bubbleBindings[bubbleEvent]++;
					}
				}
			}
		},

		// ## bubble.unbind
		// Called when an event is unbound from an object.  This should
		// teardown bubbling if there are no more bubbling event handlers.
		unbind: function(parent, eventName) {
			var bubbleEvents = bubble.events(parent, eventName),
				len = bubbleEvents.length,
				bubbleEvent;

			for (var i = 0; i < len; i++) {
				bubbleEvent = bubbleEvents[i];

				if (parent._bubbleBindings ) {
					parent._bubbleBindings[bubbleEvent]--;
				}

				if (parent._bubbleBindings && !parent._bubbleBindings[bubbleEvent] ) {
					delete parent._bubbleBindings[bubbleEvent];
					bubble.teardownChildrenFrom(parent, bubbleEvent);
					if(isEmptyObject(parent._bubbleBindings)) {
						delete parent._bubbleBindings;
					}
				}
			}
		},

		// ## bubble.add
		// Called when a new `child` value has been added to `parent`.
		// If the `parent` is bubbling and the child is observable,
		// setup bubbling on the child to the parent. This calls
		// `teardownFromParent` to ensure we aren't bubbling the same
		// child more than once.
		add: function(parent, child, prop){
			if(canReflect_1_16_7_canReflect.isObservableLike(child) && canReflect_1_16_7_canReflect.isMapLike(child) && parent._bubbleBindings) {
				for(var eventName in parent._bubbleBindings) {
					if( parent._bubbleBindings[eventName] ) {
						bubble.teardownFromParent(parent, child, eventName);
						bubble.toParent(child, parent, prop, eventName);
					}
				}
			}
		},
		// ## bubble.addMany
		// Called when many `children` are added to `parent`.
		addMany: function(parent, children){
			for (var i = 0, len = children.length; i < len; i++) {
				bubble.add(parent, children[i], i);
			}
		},
		// ## bubble.remove
		// Called when a `child` has been removed from `parent`.
		// Removes all bubbling events from `child` to `parent`.
		remove: function(parent, child){
			if(canReflect_1_16_7_canReflect.isObservableLike(child) && canReflect_1_16_7_canReflect.isMapLike(child) && parent._bubbleBindings) {
				for(var eventName in parent._bubbleBindings) {
					if( parent._bubbleBindings[eventName] ) {
						bubble.teardownFromParent(parent, child, eventName);
					}
				}
			}
		},
		// ## bubble.removeMany
		// Called when many `children` are removed from `parent`.
		removeMany: function(parent, children){
			for(var i = 0, len = children.length; i < len; i++) {
				bubble.remove(parent, children[i]);
			}
		},
		// ## bubble.set
		// Called when a new child `value` replaces `current` value.
		set: function(parent, prop, value, current){

			if(canReflect_1_16_7_canReflect.isObservableLike(value) && canReflect_1_16_7_canReflect.isMapLike(value)) {
				bubble.add(parent, value, prop);
			}
			// bubble.add will remove, so only remove if we are replacing another object
			if(canReflect_1_16_7_canReflect.isObservableLike(current) && canReflect_1_16_7_canReflect.isMapLike(current)) {
				bubble.remove(parent, current);
			}
			return value;
		},

		// ## bubble.events
		// For an event binding on an object, returns the events that should be bubbled.
		// For example, `"change" -> ["change"]`.
		events: function(map, boundEventName) {
			return map.constructor._bubbleRule(boundEventName, map);
		},


		// ## bubble.toParent
		// Forwards an event on `child` to `parent`.  `child` is
		// the `prop` property of `parent`.
		toParent: function(child, parent, prop, eventName) {
			map$1.listenTo.call(parent, child, eventName, function ( /* ev, attr */ ) {

				var args = makeArray_1(arguments),
					ev = args.shift();

				// Updates the nested property name that will be dispatched.
				// If the parent is a list, the index of the child needs to
				// be calculated every time.
				args[0] =
					((canReflect_1_16_7_canReflect.isObservableLike(parent) && canReflect_1_16_7_canReflect.isListLike(parent)) ?
						parent.indexOf(child) :
						prop ) + (args[0] ? "."+args[0] : "");

				// Track all objects that we have bubbled this event to.
				// If we have already bubbled to this object, do not dispatch another
				// event on it. This prevents cycles.
				ev.triggeredNS = ev.triggeredNS || {};
				if (ev.triggeredNS[parent._cid]) {
					return;
				}
				ev.triggeredNS[parent._cid] = true;

				// Send bubbled event to parent.
				map$1.dispatch.call(parent, ev, args);

				// Trigger named event.
				if(eventName === "change") {
					map$1.dispatch.call(parent, args[0], [args[2], args[3]]);
				}

			});
		},

		// ## bubble.childrenOf
		// Bubbles all the children of `parent`.
		childrenOf: function (parent, eventName) {

			parent._each(function (child, prop) {
				if (child && child.bind) {
					bubble.toParent(child, parent, prop, eventName);
				}
			});
		},

		// ## bubble.teardownFromParent
		// Undo the bubbling from `child` to `parent`.
		teardownFromParent: function (parent, child, eventName ) {
			if(child && child.unbind ) {
				map$1.stopListening.call(parent, child, eventName);
			}
		},

		// ## bubble.teardownChildrenFrom
		// Undo the bubbling of every child of `parent`
		teardownChildrenFrom: function(parent, eventName){
			parent._each(function (child) {

				bubble.teardownFromParent(parent, child, eventName);
			});
		},

		// ## bubble.isBubbling
		// Returns true or false if `parent` is bubbling `eventName`.
		isBubbling: function(parent, eventName){
			return parent._bubbleBindings && parent._bubbleBindings[eventName];
		}
	};

var canMap_4_0_1_bubble = bubble;

var core_hasOwn = Object.prototype.hasOwnProperty;

function isWindow(obj) {
	// In IE8 window.window !== window.window, so we allow == here.
	/*jshint eqeqeq:false*/
	return obj !== null && obj == obj.window;
}

function isPlainObject$2(obj) {
	// Must be an Object.
	// Because of IE, we also have to check the presence of the constructor property.
	// Make sure that DOM nodes and window objects don't pass through, as well
	if (!obj || typeof obj !== 'object' || obj.nodeType || isWindow(obj) || obj.constructor && obj.constructor.shortName) {
		return false;
	}
	try {
		// Not own constructor property must be Object
		if (obj.constructor && !core_hasOwn.call(obj, 'constructor') && !core_hasOwn.call(obj.constructor.prototype, 'isPrototypeOf')) {
			return false;
		}
	} catch (e) {
		// IE8,9 Will throw exceptions on certain host objects #9897
		return false;
	}
	// Own properties are enumerated firstly, so to speed up,
	// if last one is own, then all properties are own.
	var key;
	for (key in obj) {}
	return key === undefined || core_hasOwn.call(obj, key);
}

var isPlainObject_1 = isPlainObject$2;

/**
 * @module {function} can-util/js/is-promise/is-promise is-promise
 * @parent can-util/js
 * @signature `isPromise(obj)`
 *
 * Determines if object is a [Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise).
 *
 * ```js
 * var isPromise = require("can-util/js/is-promise/is-promise");
 *
 * var promise = new Promise(function(resolve){
 *   resolve();
 * });
 *
 * console.log(isPromise(promise)); // -> true
 * console.log(isPromise("foo bar")); // -> false
 * ```
 *
 * @param {Object} obj An object to be tested.
 * @return {Boolean} True if the object is a Promise.
 */
var isPromise = function(obj) {
	return canReflect_1_16_7_canReflect.isPromise(obj);
};

var canMap_4_0_1_mapHelpers = createCommonjsModule(function (module, exports) {
// # can/map/map_hepers
// Helper functions that are primarily used to serialize
// a map, or track the maps created from plain JavaScript objects.
// `can.Map` handles cycles in objects nicely!





// ## POJOs to Map instance helpers

// ### madeMap
// A temporary map of Maps that have been made from plain JS objects.
// `{POJO_CID: {obj: POJO, instance: MAP, added: Boolean}}`
var madeMap = null;

// ### teardownMap
// Clears out map of converted objects and removes temporary `cids`.
var teardownMap = function () {
	for (var cid in madeMap) {
		if (madeMap[cid].added) {
			delete madeMap[cid].obj._cid;
		}
	}
	madeMap = null;
};

var mapHelpers = {
	// ### mapHelpers.attrParts
	// Parses attribute name into its parts.
	attrParts: function (attr, keepKey) {
		//Keep key intact
		if (keepKey ) {
			return [attr];
		}
		// Split key on '.'
		return typeof attr === "object" ? attr : ("" + attr)
			.split(".");
	},

	// ### can.mapHelpers.canMakeObserve
	// Determines if an object can be made into an observable.
	canMakeObserve: function (obj) {
		return obj && !isPromise(obj) && (Array.isArray(obj) || isPlainObject_1(obj) );
	},
	reflectSerialize: function(unwrapped){
		this.forEach(function(val, name){
			if( this.___serialize ) {
				val = this.___serialize(name, val);
			} else {
				val = canReflect_1_16_7_canReflect.serialize(val);
			}
			if(val !== undefined) {
				unwrapped[name] = val;
			}
		}, this);
		return unwrapped;
	},
	reflectUnwrap: function(unwrapped){
		this.forEach(function(value, key){
			if(value !== undefined) {
				unwrapped[key] = canReflect_1_16_7_canReflect.unwrap(value);
			}
		});
		return unwrapped;
	},
	removeSpecialKeys: function(map) {
		if(map) {
			["_data", "constructor", "_cid", "__bindEvents"].forEach(function(key) {
				delete map[key];
			});
		}
		return map;
	},
	// ### mapHelpers.serialize
	// Serializes a Map or Map.List by recursively calling the `how`
	// method on any child objects. This is able to handle
	// cycles.
	// `map` - the map or list to serialize.
	// `how` - the method to call recursively.
	// `where` - the target Object or Array that becomes the serialized result.
	/*serialize: (function(){

		// A temporary mapping of map cids to the serialized result.
		var serializeMap = null;

		return function (map, how, where) {
			var cid = CID(map),
				firstSerialize = false;

			// If there isn't an existing serializeMap, this means
			// this is the initial non-recursive call to this function.
			// We mark this  as the first call, and then setup the serializeMap.
			// The serialize map is further devided into `how` because
			// `.serialize` might call `.attr`.
			if(!serializeMap) {
				firstSerialize = true;
				serializeMap = {
					attr: {},
					serialize: {}
				};
			}

			serializeMap[how][cid] = where;
			// Go through each property.
			map.forEach(function (val, name) {
				// If the value is an `object`, and has an `attr` or `serialize` function.
				var result,
					isObservable = canReflect.isObservableLike(val),
					serialized = isObservable && serializeMap[how][CID(val)];

				if( serialized ) {
					result = serialized;
				} else {
					// special attr or serializer
					if(map["___"+how]) {
						result =  map["___"+how](name, val);
					} else {
						result = mapHelpers.getValue(map, name, val, how);
					}
				}
				// this is probably removable
				if(result !== undefined){
					where[name] = result;
				}
			});

			if(firstSerialize) {
				serializeMap = null;
			}
			return where;
		};
	})(),*/

	// ## getValue
	// If `val` is an observable, calls `how` on it; otherwise
	// returns the value of `val`.
	/*getValue: function(map, name, val, how){
		if(how === "attr") {
			how = canSymbol.for("can.getValue");
		}
		if( canReflect.isObservableLike(val) && val[how] ) {
			return val[how]();
		} else {
			return val;
		}
	},*/

	// ## define
	// A hook to call whenever a Map is defined.
	// We need a better place for this.
	define: null,

	// ## addComputedAttr
	// Adds a compute so it will control the behavior of an
	// attribute.  Each computedAttrs object has:
	// - `compute` - the compute that will be read and updated.
	// - `count` - the number of bindings to this individual property.
	//   This is used to know when to bind `handler` to the compute.
	// - `handler` - a function that when bound to `compute` forwards all
	//   events to `map`.
	addComputedAttr: function(map, attrName, compute){
		map._computedAttrs[attrName] = {
			compute: compute,
			count: 0,
			handler: function (newVal, oldVal) {
				map._triggerChange(attrName, "set", newVal, oldVal);
			}
		};
	},

	// ### can.mapHelpers.addToMap
	// Tracks map instances created from JS objects.
	// This should be called whenever an instance is created for a particular object.
	// This may return a `teardown` function that should be called after all instances
	// might be created.
	//
	// While creating map instances from plain ole JS objects (POJOs), it's
	// possible that the same JS object exists as two different properties and
	// we want only one map instance created for one JS object.
	//
	// ```
	// var obj = {name: "I am everywhere"}
	// var map = new can.Map({obj1: obj, obj2: obj});
	// ok( map.attr("obj1") === map.attr("obj2") )
	// ```
	//
	// This works by temporarily adding a `cid` to any found POJO object
	// and storing it in a temporary Object that maps those `cid`s to
	// the POJO and the instance created for it.
	// The `teardown` function removes those temporary `cid`s and
	// clears the map for memory safety.
	addToMap: function addToMap(obj, instance) {
		var teardown;

		// Setup a fresh mapping if `madeMap` is missing.
		if (!madeMap) {
			teardown = teardownMap;
			madeMap = {};
		}

		// Record if Object has a `_cid` before adding one.
		var hasCid = obj._cid;
		var cid = canCid_1_1_2_canCid(obj);

		// Only update if there already isn't one already.
		if (!madeMap[cid]) {

			madeMap[cid] = {
				obj: obj,
				instance: instance,
				added: !hasCid
			};
		}
		return teardown;
	},

	// ### getMapFromObject
	// Returns the map instance already created for this object `obj` or
	// `undefined` if nothing has been already created.
	getMapFromObject: function (obj) {
		return madeMap && madeMap[obj._cid] && madeMap[obj._cid].instance;
	},
	twoLevelDeepExtend: function (destination, source) {
		for (var prop in source) {
			destination[prop] = destination[prop] || {};
			assign$7(destination[prop], source[prop]);
		}
	}
};

module.exports = exports = mapHelpers;
});

/**
 * @module {function} can-util/js/is-function/is-function is-function
 * @parent can-util/js
 *
 * @signature `isFunction(value)`
 *
 * @param {*} value the item to test for being a function
 * @return {Boolean} True if the provided argument is a function.
 *
 * ```js
 * var isFunction = require("can-util/js/is-function/is-function");
 *
 * console.log(isFunction(function(){})); // -> true
 *
 * console.log(isFunction({})); // -> false
 * ```
 *
 */
var isFunction$4 = (function() {
	if (typeof document !== 'undefined' && typeof document.getElementsByTagName('body') === 'function') {
		return function(value) {
			return Object.prototype.toString.call(value) === '[object Function]';
		};
	}
	return function(value) {
		return typeof value === 'function';
	};
}());

var isFunction_1 = isFunction$4;

function deepAssign() {
	/*jshint maxdepth:6 */
	var options, name, src, copy, copyIsArray, clone,
		target = arguments[0] || {},
		i = 1,
		length = arguments.length;

	// Handle case when target is a string or something (possible in deep copy)
	if (typeof target !== "object" && !isFunction_1(target)) {
		target = {};
	}

	// extend jQuery itself if only one argument is passed
	if (length === i) {
		/*jshint validthis:true*/
		target = this;
		--i;
	}

	for (; i < length; i++) {
		// Only deal with non-null/undefined values
		if ((options = arguments[i]) != null) {
			// Extend the base object
			for (name in options) {
				src = target[name];
				copy = options[name];

				// Prevent never-ending loop
				if (target === copy) {
					continue;
				}

				// Recurse if we're merging plain objects or arrays
				if (copy && (isPlainObject_1(copy) || (copyIsArray = Array.isArray(copy)))) {
					if (copyIsArray) {
						copyIsArray = false;
						clone = src && Array.isArray(src) ? src : [];

					} else {
						clone = src && isPlainObject_1(src) ? src : {};
					}

					// Never move original objects, clone them
					target[name] = deepAssign(clone, copy);

					// Don't bring in undefined values
				} else if (copy !== undefined) {
					target[name] = copy;
				}
			}
		}
	}

	// Return the modified object
	return target;
}

var deepAssign_1 = deepAssign;

var canTypes_1_1_7_canTypes = createCommonjsModule(function (module) {
/**
 * @module {Object} can-types
 * @parent can-typed-data
 * @collection can-infrastructure
 * @package ./package.json
 * @description A stateful container for CanJS type information.
 *
 * @body
 *
 * ## Use
 *
 * `can-types` exports an object with placeholder functions that
 * can be used to provide default types or test if something is of a certain type.
 *
 * For example, `can-define/map/map` might overwrite `DefeaultMap` to return DefineMap
 *
 * ```js
 * types.DefaultMap = DefineMap;
 * ```
 */

var types = {
	isMapLike: function(obj){
		//!steal-remove-start
		dev.warn('can-types.isMapLike(obj) is deprecated, please use `canReflect.isObservableLike(obj) && canReflect.isMapLike(obj)` instead.');
		//!steal-remove-end
		return canReflect_1_16_7_canReflect.isObservableLike(obj) && canReflect_1_16_7_canReflect.isMapLike(obj);
	},

	isListLike: function(obj){
		//!steal-remove-start
		dev.warn('can-types.isListLike(obj) is deprecated, please use `canReflect.isObservableLike(obj) && canReflect.isListLike(obj)` instead.');
		//!steal-remove-end
		return canReflect_1_16_7_canReflect.isObservableLike(obj) && canReflect_1_16_7_canReflect.isListLike(obj);
	},

	isPromise: function(obj){
		//!steal-remove-start
		dev.warn('can-types.isPromise is deprecated, please use canReflect.isPromise instead.');
		//!steal-remove-end
		return canReflect_1_16_7_canReflect.isPromise(obj);
	},

	isConstructor: function(func){
		//!steal-remove-start
		dev.warn('can-types.isConstructor is deprecated, please use canReflect.isConstructorLike instead.');
		//!steal-remove-end
		return canReflect_1_16_7_canReflect.isConstructorLike(func);
	},

	isCallableForValue: function(obj){
		//!steal-remove-start
		dev.warn('can-types.isCallableForValue(obj) is deprecated, please use `canReflect.isFunctionLike(obj) && !canReflect.isConstructorLike(obj)` instead.');
		//!steal-remove-end
		return obj && canReflect_1_16_7_canReflect.isFunctionLike(obj) && !canReflect_1_16_7_canReflect.isConstructorLike(obj);
	},

	isCompute: function(obj){
		//!steal-remove-start
		dev.warn('can-types.isCompute is deprecated.');
		//!steal-remove-end
		return obj && obj.isComputed;
	},

	get iterator() {
		//!steal-remove-start
		dev.warn('can-types.iterator is deprecated, use `canSymbol.iterator || canSymbol.for("iterator")` instead.');
		//!steal-remove-end
		return canSymbol_1_6_1_canSymbol.iterator || canSymbol_1_6_1_canSymbol.for("iterator");
	},
	/**
	 * @property {Map} can-types.DefaultMap DefaultMap
	 *
	 * @option {Map}
	 *
	 *   The default map type to create if a map is needed.  If both [can-map] and [can-define/map/map]
	 *   are imported, the default type will be [can-define/map/map].
	 */
	DefaultMap: null,
	/**
	 * @property {can-connect.List} can-types.DefaultList DefaultList
	 *
	 * @option {can-connect.List}
	 *
	 *   The default list type to create if a list is needed. If both [can-list] and [can-define/list/list]
	 *   are imported, the default type will be [can-define/list/list].
	 */
	DefaultList: null,
	/**
	 * @function can-types.queueTask queueTask
	 * @signature `types.queueTask(task)`
	 *   Run code that will be queued at the end of the current batch.
	 *   @param {Array} task
	 */
	queueTask: function(task){
		var args = task[2] || [];
		task[0].apply(task[1], args);
	},
	/**
	 * @function can-types.wrapElement wrapElement
	 * @signature `types.wrapElement(element)`
	 *   Wraps an element into an object useful by DOM libraries ala jQuery.
	 *
	 *   @param {Node} element Any object inheriting from the [Node interface](https://developer.mozilla.org/en-US/docs/Web/API/Node).
	 *   @return {{}} A wrapped object.
	 */
	wrapElement: function(element){
		return element;
	},
	/**
	 * @function can-types.unwrapElement unwrapElement
	 * @signature `types.unwrapElement(object)`
	 *   Unwraps an object that contains an element within.
	 *
	 *   @param {{}} object Any object that can be unwrapped into a Node.
	 *   @return {Node} A Node.
	 */
	unwrapElement: function(element){
		return element;
	}
};

if (canNamespace_1_0_0_canNamespace.types) {
	throw new Error("You can't have two versions of can-types, check your dependencies");
} else {
	module.exports = canNamespace_1_0_0_canNamespace.types = types;
}
});

var canCid_1_1_2_helpers = {
    each: function(obj, cb, context) {
        for(var prop in obj) {
            cb.call(context, obj[prop], prop);
        }
        return obj;
    }
};

var getCID = canCid_1_1_2_canCid.get;


var CIDSet;

if(typeof Set !== "undefined") {
	CIDSet = Set;
} else {
	var CIDSet = function(){
		this.values = {};
	};
	CIDSet.prototype.add = function(value){
		this.values[getCID(value)] = value;
	};
	CIDSet.prototype["delete"] = function(key){
		var has = getCID(key) in this.values;
		if(has) {
			delete this.values[getCID(key)];
		}
		return has;
	};
	CIDSet.prototype.forEach = function(cb, thisArg) {
		canCid_1_1_2_helpers.each(this.values, cb, thisArg);
	};
	CIDSet.prototype.has = function(value) {
		return getCID(value) in this.values;
	};
	CIDSet.prototype.clear = function() {
		return this.values = {};
	};
	Object.defineProperty(CIDSet.prototype,"size",{
		get: function(){
			var size = 0;
			canCid_1_1_2_helpers.each(this.values, function(){
				size++;
			});
			return size;
		}
	});
}

var set$3 = CIDSet;

//var canDev = require("can-log/dev/dev");

/**
 * @module can-util/js/cid-set/cid-set cid-set
 * @parent deprecated
 * @description Deprecated. Use [can-cid/set/set] instead.
 */

//!steal-remove-start
// canDev.warn('js/cid-set/cid-set is deprecated; please use can-globals instead: https://github.com/canjs/can-cid');
//!steal-remove-end

var cidSet = set$3;

var getCID$1 = canCid_1_1_2_canCid.get;


var CIDMap;

if(typeof Map !== "undefined") {
	CIDMap = Map;
} else {
	var CIDMap = function(){
		this.values = {};
	};
	CIDMap.prototype.set = function(key, value){
		this.values[getCID$1(key)] = {key: key, value: value};
	};
	CIDMap.prototype["delete"] = function(key){
		var has = getCID$1(key) in this.values;
		if(has) {
			delete this.values[getCID$1(key)];
		}
		return has;
	};
	CIDMap.prototype.forEach = function(cb, thisArg) {
		canCid_1_1_2_helpers.each(this.values, function(pair){
			return cb.call(thisArg || this, pair.value, pair.key, this);
		}, this);
	};
	CIDMap.prototype.has = function(key) {
		return getCID$1(key) in this.values;
	};
	CIDMap.prototype.get = function(key) {
		var obj = this.values[getCID$1(key)];
		return obj && obj.value;
	};
	CIDMap.prototype.clear = function() {
		return this.values = {};
	};
	Object.defineProperty(CIDMap.prototype,"size",{
		get: function(){
			var size = 0;
			canCid_1_1_2_helpers.each(this.values, function(){
				size++;
			});
			return size;
		}
	});
}

var map$6 = CIDMap;

//var canDev = require("can-log/dev/dev");

/**
 * @module can-util/js/cid-map/cid-map cid-map
 * @parent deprecated
 * @description Deprecated. Use [can-cid/map/map] instead.
 */

//!steal-remove-start
// canDev.warn('js/cid-map/cid-map is deprecated; please use can-globals instead: https://github.com/canjs/can-cid');
//!steal-remove-end

var cidMap = map$6;

/* jshint -W079 */
// # can/map/map.js (aka can.Map)
// `can.Map` provides the observable pattern for JavaScript objects. It
// provides an `attr` and `removeAttr` method that can be used to get/set and
// remove properties and nested properties by calling a "pipeline" of protected
// methods:
//
// - `_get`, `_set`, `_remove` - handle nested properties.
// - `__get`, `__set`, `__remove` - handle triggering events.
// - `___get`, `___set`, `___remove` - read / write / remove raw values.
//
// When `attr` gets or sets multiple properties it calls `_getAttrs` or `_setAttrs`.
//
// [bubble.js](bubble.html) - Handles bubbling of child events to parent events.
// [map_helpers.js](map_helpers.html) - Assorted helpers for handling cycles during serialization or
// instantition of objects.














//var isFunction = require("can-util/js/is-function/is-function");








// properties that can't be observed on ... no matter what
var unobservable = {
	"constructor": true
};

var hasOwnProperty$1 = ({}).hasOwnProperty;

// Extend [can.Construct](../construct/construct.html) to make inheriting a `can.Map` easier.
var Map$1 = canConstruct_3_4_4_canConstruct.extend(
	/**
	 * @static
	 */
	// ## Static Properties and Methods
	{
		// ### setup
		// Called when a Map constructor is defined/extended to
		// perform any initialization behavior for the new constructor
		// function.
		setup: function (baseMap) {

			canConstruct_3_4_4_canConstruct.setup.apply(this, arguments);

			// A cached list of computed properties on the prototype.
			this._computedPropertyNames = [];

			// Do not run if we are defining can.Map.
			if (Map$1) {
				type$1(this);
				this[canSymbol_1_6_1_canSymbol.for("can.defineInstanceKey")] = function(prop, definition){
					if(definition.value !== undefined) {
						this.defaults[prop] = definition.value;
					}
					if(definition.enumerable === false ) {
						this.enumerable[prop] = false;
					}
				};
				// Provide warnings if can.Map is used incorrectly.
				//!steal-remove-start
				if(this.prototype.define && !canMap_4_0_1_mapHelpers.define) {
					dev$3.warn("can/map/define is not included, yet there is a define property "+
					"used. You may want to add this plugin.");
				}
				if(this.define && !canMap_4_0_1_mapHelpers.define) {
					dev$3.warn("The define property should be on the map's prototype properties, "+
					"not the static properties. Also, can/map/define is not included.");
				}
				//!steal-remove-end

				// Create a placeholder for default values.
				if (!this.defaults) {
					this.defaults = {};
				}
				if(!this.enumerable) {
					this.enumerable = {};
				}


				// Go through everything on the prototype.  If it's a primitive,
				// treat it as a default value.  If it's a compute, identify it so
				// it can be setup as a computed property.
				for (var prop in this.prototype) {
					if (
						prop !== "define" &&
						prop !== "constructor" &&
						(typeof this.prototype[prop] !== "function" ||
							this.prototype[prop].prototype instanceof canConstruct_3_4_4_canConstruct)
					) {
						this.defaults[prop] = this.prototype[prop];
					} else if (canReflect_1_16_7_canReflect.isObservableLike(this.prototype[prop])) {
						this._computedPropertyNames.push(prop);
					}
				}

				// If define is a function, call it with this can.Map
				if(canMap_4_0_1_mapHelpers.define) {
					canMap_4_0_1_mapHelpers.define(this, baseMap.prototype.define);
				}
			}

			// If we inherit from can.Map, but not can.List, create a can.List that
			// creates instances of this Map type.
            // This is something List should weave in.
			/*if (can.List && !(this.prototype instanceof can.List)) {
				this.List = Map.List.extend({
					Map: this
				}, {});
			}*/

		},
		// ### shortName
		// Tells `can.Construct` to show instance as `Map` in the debugger.
		shortName: "Map",

		// ### _bubbleRule
		// Returns which events to setup bubbling on for a given bound event.
		// By default, only bubbles "change" events if someone listens to a
		// "change" event or a nested event like "foo.bar".
		_bubbleRule: function(eventName) {
			return (eventName === "change" || eventName.indexOf(".") >= 0 ) ?
				["change"] :
				[];
		},

		// ### bind,  unbind
		// Listen to events on the Map constructor.  These
		// are here mostly for can.Model.
		addEventListener: map$1.addEventListener,
		removeEventListener: map$1.removeEventListener,

		// ### keys
		// An observable way to get the keys from a map.
		keys: function (map) {
			return canReflect_1_16_7_canReflect.getOwnEnumerableKeys(map);
		}
	},
	/**
	 * @prototype
	 */
	// ## Prototype Properties and Methods
	{
		// ### setup
		// Initializes the map instance's behavior.
		setup: function (obj) {

			if(canReflect_1_16_7_canReflect.isObservableLike(obj) && typeof obj.serialize === "function"){
				obj = obj.serialize();
			}

			// Where we keep the values of the compute.
			this._data = Object.create(null);

			// The namespace this `object` uses to listen to events.
			canCid_1_1_2_canCid(this, ".map");

			this._setupComputedProperties();
			var teardownMapping = obj && canMap_4_0_1_mapHelpers.addToMap(obj, this);

			var defaultValues = this._setupDefaults(obj);
			var data = assign$7(deepAssign_1(true, {}, defaultValues), obj);

			this.attr(data);

			if (teardownMapping) {
				teardownMapping();
			}
		},

		// ### _setupComputes
		// Sets up computed properties on a Map.
		// Stores information for each computed property on
		//  `this._computedAttrs` that looks like:
		//
		// ```
		// {
		//   // the number of bindings on this property
		//   count: 1,
		//   // a handler that forwards events on the compute
		//   // to the map instance
		//   handler: handler,
		//   compute: compute  // the compute
		// }
		// ```
		_setupComputedProperties: function () {
			this._computedAttrs = Object.create(null);

			var computes = this.constructor._computedPropertyNames;

			for (var i = 0, len = computes.length; i < len; i++) {
				var attrName = computes[i];
				canMap_4_0_1_mapHelpers.addComputedAttr(this, attrName, this[attrName]);
			}
		},

		// ### _setupDefaults
		// Returns the default values for the instance.
		_setupDefaults: function(){
			return this.constructor.defaults || {};
		},

		// ### attr
		// The primary get/set interface for can.Map.
		// Calls `_get`, `_set` or `_attrs` depending on
		// how it is called.
		attr: function (attr, val) {
			var type = typeof attr;
			if(attr === undefined) {
				return this._getAttrs();
			} else if (type !== "string" && type !== "number") {
				// Get or set multiple attributes.
				return this._setAttrs(attr, val);
			}
			else if (arguments.length === 1) {
				// Get a single attribute.
				return this._get(attr+"");
			} else {
				// Set an attribute.
				this._set(attr+"", val);
				return this;
			}
		},

		// ### _get
		// Handles reading nested properties like "foo.bar" by
		// getting the value of "foo" and recursively
		// calling `_get` for the value of "bar".
		// To read the actual values, `_get` calls
		// `___get`.
		_get: function (attr) {
			var dotIndex = attr.indexOf('.');

			if( dotIndex >= 0 ) {

				// Attempt to get the value anyway in case
				// somone wrote `new can.Map({"foo.bar": 1})`.
				var value = this.___get(attr);
				if (value !== undefined) {
					canObservationRecorder_1_1_2_canObservationRecorder.add(this, attr);
					return value;
				}

				var first = attr.substr(0, dotIndex),
					second = attr.substr(dotIndex+1);

				var current = this.__get( first );

				return current && canReflect_1_16_7_canReflect.getKeyValue(current, second);
			} else {
				return this.__get( attr );
			}
		},

		// ### __get
		// Signals `can.compute` that an observable
		// property is being read.
		__get: function(attr){
			if(!unobservable[attr] && !this._computedAttrs[attr]) {
				canObservationRecorder_1_1_2_canObservationRecorder.add(this, attr);
			}
			return this.___get( attr );
		},

		// ### ___get
		// When called with an argument, returns the value of this property. If that
		// property is represented by a computed attribute, return the value of that compute.
		// If no argument is provided, return the raw data.
		___get: function (attr) {
			if (attr !== undefined) {
				var computedAttr = this._computedAttrs[attr];
				if (computedAttr) {
					// return computedAttr.compute();
					return canReflect_1_16_7_canReflect.getValue(computedAttr.compute);
				} else {
					return hasOwnProperty$1.call(this._data, attr) ? this._data[attr] : undefined;
				}
			} else {
				return this._data;
			}
		},

		// ### _set
		// Handles setting nested properties by finding the
		// nested observable and recursively calling `_set` on it. Eventually,
		// it calls `__set` with the `__type` converted value to set
		// and the current value.  The current value is passed for two reasons:
		//  - so `__set` can trigger an event if the value has changed.
		//  - for advanced setting behavior that define.set can do.
		//
		// If the map is initializing, the current value does not need to be
		// read because no change events are dispatched anyway.
		_set: function (attr, value, keepKey) {

			var dotIndex = attr.indexOf('.'),
				current;

			if(dotIndex >= 0 && !keepKey){
				var first = attr.substr(0, dotIndex),
					second = attr.substr(dotIndex+1);

				current =  this.__inSetup ? undefined : this.___get( first );

				if( canReflect_1_16_7_canReflect.isMapLike(current) ) {
					canReflect_1_16_7_canReflect.setKeyValue(current, second, value);
				} else {
					current = this.__inSetup ? undefined : this.___get( attr );

					// //Convert if there is a converter.  Remove in 3.0.
					if (this.__convert) {
						value = this.__convert(attr, value);
					}

					this.__set(attr, this.__type(value, attr), current);
				}

			} else {
				current = this.__inSetup ? undefined : this.___get( attr );

				// //Convert if there is a converter.  Remove in 3.0.
				if (this.__convert) {
					value = this.__convert(attr, value);
				}

				this.__set(attr, this.__type(value, attr), current);
			}
		},

		// ## __type
		// Converts set values to another type.  By default,
		// this converts Objects to can.Maps and Arrays to
		// can.Lists.
		// This also makes it so if a plain JavaScript object
		// has already been converted to a list or map, that same
		// list or map instance is used.
		__type: function(value, prop){

			if (typeof value === "object" &&
				!canReflect_1_16_7_canReflect.isObservableLike( value ) &&
				canMap_4_0_1_mapHelpers.canMakeObserve(value) &&
				!canReflect_1_16_7_canReflect.isListLike(value)
			) {

				var cached = canMap_4_0_1_mapHelpers.getMapFromObject(value);
				if(cached) {
					return cached;
				}
				var MapConstructor = this.constructor.Map || Map$1;
				return new MapConstructor(value);

			}
			return value;
		},

		// ## __set
		// Handles firing events if the value has changed and
		// works with the `bubble` helpers to setup bubbling.
		// Calls `___set` to do the actual setting.
		__set: function (prop, value, current) {

			if (value !== current) {
				var computedAttr = this._computedAttrs[prop];

				// Dispatch an "add" event if adding a new property.
				var changeType = computedAttr || current !== undefined ||
					hasOwnProperty$1.call(this.___get(), prop) ? "set" : "add";

				// Set the value on `_data` and set up bubbling.
				this.___set(prop, typeof value === "object" ? canMap_4_0_1_bubble.set(this, prop, value, current) : value );

				// Computed properties change events are already forwarded except if
				// no one is listening to them.
				if(!computedAttr || !computedAttr.count) {
					this._triggerChange(prop, changeType, value, current);
				}


				// Stop bubbling old nested maps.
				if (typeof current === "object") {
					canMap_4_0_1_bubble.teardownFromParent(this, current);
				}
			}
		},

		// ### ___set
		// Directly saves the set value as a property on `_data`
		// or sets the computed attribute.
		___set: function (prop, val) {
			var computedAttr = this._computedAttrs[prop];
			if ( computedAttr ) {
				canReflect_1_16_7_canReflect.setValue(computedAttr.compute, val);
			} else {
				this._data[prop] = val;
			}

			// Adds the property directly to the map instance. But first,
			// checks that it's not overwriting a method. This should be removed
			// in 3.0.
			if ( typeof this.constructor.prototype[prop] !== 'function' && !computedAttr ) {
				this[prop] = val;
			}
		},

		removeAttr: function (attr) {
			return this._remove(attr);
		},

		// ### _remove
		// Handles removing nested observes.
		_remove: function(attr){
			// If this is List.
			var parts = canMap_4_0_1_mapHelpers.attrParts(attr),
			// The actual property to remove.
				prop = parts.shift(),
			// The current value.
				current = this.___get(prop);

			// If we have more parts, call `removeAttr` on that part.
			if (parts.length && current) {
				return canReflect_1_16_7_canReflect.deleteKeyValue(current, parts.join("."));
			} else {

				// If attr does not have a `.`
				if (typeof attr === 'string' && !!~attr.indexOf('.')) {
					prop = attr;
				}

				this.__remove(prop, current);
				return current;
			}
		},

		// ### __remove
		// Handles triggering an event if a property could be removed.
		__remove: function(prop, current){
			if (prop in this._data) {
				this.___remove(prop);
				// Let others now this property has been removed.
				this._triggerChange(prop, "remove", undefined, current);
			}
		},

		// ### ___remove
		// Deletes a property from `_data` and the map instance.
		___remove: function(prop){
			delete this._data[prop];
			if (!(prop in this.constructor.prototype)) {
				delete this[prop];
			}
		},

		// ### ___serialize
		// Serializes a property.  Uses map helpers to
		// recursively serialize nested observables.
		___serialize: function(name, val){
			return canReflect_1_16_7_canReflect.serialize(val, cidMap);
		},

		// ### _getAttrs
		// Returns the values of all attributes as a plain JavaScript object.
		_getAttrs: function(){
			return canReflect_1_16_7_canReflect.unwrap(this, cidMap);
		},
		// ### _setAttrs
		// Sets multiple properties on this object at once.
		// First, goes through all current properties and either merges
		// or removes old properties.
		// Then it goes through the remaining ones to be added and sets those properties.
		_setAttrs: function (props, remove) {
			if(remove === true) {
				this[canSymbol_1_6_1_canSymbol.for("can.updateDeep")](props);
			} else {
				this[canSymbol_1_6_1_canSymbol.for("can.assignDeep")](props);
			}
			return this;
		},

		serialize: function () {
			return canReflect_1_16_7_canReflect.serialize(this, cidMap);
		},


		// ### _triggerChange
		// A helper function used to trigger events on this map.
		// If the map is bubbling, this will fire a change event.
		// Otherwise, it only fires a "named" event. Triggers a
		// "__keys" event if a property has been added or removed.
		_triggerChange: function (attr, how, newVal, oldVal, batchNum) {
			canQueues_1_1_0_canQueues.batch.start();
			if(canMap_4_0_1_bubble.isBubbling(this, "change")) {
				map$1.dispatch.call(this, {
					type: "change",
					target: this,
					batchNum: batchNum
				}, [attr, how, newVal, oldVal]);

			}

			map$1.dispatch.call(this, {
				type: attr,
				target: this,
				batchNum: batchNum,
				patches: [{type: "set", key: attr, value: newVal}]
			}, [newVal, oldVal]);

			if(how === "remove" || how === "add") {
				map$1.dispatch.call(this, {
					type: "__keys",
					target: this,
					batchNum: batchNum
				});
			}

			canQueues_1_1_0_canQueues.batch.stop();
		},



		// ### compute
		// Creates a compute that represents a value on this map. If the property is a function
		// on the prototype, a "function" compute wil be created.
		// Otherwise, a compute will be created that reads the observable attributes
		compute: function (prop) {
			if (typeof this.constructor.prototype[prop] === "function") {
				return canCompute_4_0_3_canCompute(this[prop], this);
			} else {
				var reads = canStacheKey_1_3_2_canStacheKey.reads(prop);
				var last = reads.length - 1;

				return canCompute_4_0_3_canCompute(function (newVal) {
					if (arguments.length) {
						canStacheKey_1_3_2_canStacheKey.write(this, reads[last].key, newVal, {});
					} else {
						return canStacheKey_1_3_2_canStacheKey.get(this, prop);
					}
				}, this);
			}
		},

		// ### each
		// loops through all the key-value pairs on this map.
		forEach: function (callback, context) {
				var key, item;
			var keys = canReflect_1_16_7_canReflect.getOwnEnumerableKeys(this);
			for(var i =0, len = keys.length; i < len; i++) {
			    key = keys[i];
			    item = this.attr(key);
			    if (callback.call(context || item, item, key, this) === false) {
			        break;
			    }
			}
			return this;
		},

		// ### _each
		// Iterator that does not trigger live binding.
		_each: function (callback) {
			var data = this.___get();
			for (var prop in data) {
				if (hasOwnProperty$1.call(data, prop)) {
					callback(data[prop], prop);
				}
			}
		},

		dispatch: map$1.dispatch
	});

// makes it so things can read this.
map$1(Map$1.prototype);

// ### bind
// Listens to an event on a map.
// If the event is a  computed property,
// listen to the compute and forward its events
// to this map.
Map$1.prototype.addEventListener = function (eventName, handler) {

	var computedBinding = this._computedAttrs && this._computedAttrs[eventName];
	if (computedBinding && computedBinding.compute) {
		if (!computedBinding.count) {
			computedBinding.count = 1;
			canReflect_1_16_7_canReflect.onValue(computedBinding.compute, computedBinding.handler, "notify");
		} else {
			computedBinding.count++;
		}

	}

	// Sets up bubbling if needed.
	canMap_4_0_1_bubble.bind(this, eventName);

	return map$1.addEventListener.apply(this, arguments);
};

// ### unbind
// Stops listening to an event.
// If this is the last listener of a computed property,
// stop forwarding events of the computed property to this map.
Map$1.prototype.removeEventListener = function (eventName, handler) {
	var computedBinding = this._computedAttrs && this._computedAttrs[eventName];
	if (computedBinding) {
		if (computedBinding.count === 1) {
			computedBinding.count = 0;
			canReflect_1_16_7_canReflect.offValue(computedBinding.compute, computedBinding.handler);
		} else {
			computedBinding.count--;
		}

	}

	// Teardown bubbling if needed.
	canMap_4_0_1_bubble.unbind(this, eventName);
	return map$1.removeEventListener.apply(this, arguments);

};

// ### etc
// Setup on/off aliases
Map$1.prototype.on = Map$1.prototype.bind = Map$1.prototype.addEventListener;
Map$1.prototype.off = Map$1.prototype.unbind = Map$1.prototype.removeEventListener;
Map$1.on = Map$1.bind = Map$1.addEventListener;
Map$1.off = Map$1.unbind = Map$1.removeEventListener;

// - type -

canReflect_1_16_7_canReflect.assignSymbols(Map$1.prototype,{
	// -type-
	"can.isMapLike": true,
	"can.isListLike":  false,
	"can.isValueLike": false,

	// -get/set-
	"can.getKeyValue": Map$1.prototype._get,
	"can.setKeyValue": Map$1.prototype._set,
	"can.deleteKeyValue": Map$1.prototype._remove,

	// -shape
	"can.getOwnEnumerableKeys": function(){
		canObservationRecorder_1_1_2_canObservationRecorder.add(this, '__keys');
		var enumerable = this.constructor.enumerable;
		if(enumerable) {
			return Object.keys(this._data).filter(function(key){
				return enumerable[key] !== false;
			},this);
		} else {
			return Object.keys(this._data);
		}
	},

	// -shape get/set-
	"can.assignDeep": function(source){
		canQueues_1_1_0_canQueues.batch.start();
		// TODO: we should probably just throw an error instead of cleaning
		canReflect_1_16_7_canReflect.assignDeepMap(this, canMap_4_0_1_mapHelpers.removeSpecialKeys(canReflect_1_16_7_canReflect.assignMap({}, source)));
		canQueues_1_1_0_canQueues.batch.stop();
	},
	"can.updateDeep": function(source){
		canQueues_1_1_0_canQueues.batch.start();
		// TODO: we should probably just throw an error instead of cleaning
		canReflect_1_16_7_canReflect.updateDeepMap(this, canMap_4_0_1_mapHelpers.removeSpecialKeys(canReflect_1_16_7_canReflect.assignMap({}, source)));
		canQueues_1_1_0_canQueues.batch.stop();
	},
	"can.unwrap": canMap_4_0_1_mapHelpers.reflectUnwrap,
	"can.serialize": canMap_4_0_1_mapHelpers.reflectSerialize,

	// observable
	"can.onKeyValue": function(key, handler, queue){
		var translationHandler = function(ev, newValue, oldValue){
			handler.call(this, newValue, oldValue);
		};
		singleReference_1.set(handler, this, translationHandler, key);

		this.addEventListener(key, translationHandler, queue);
	},
	"can.offKeyValue": function(key, handler, queue){
		this.removeEventListener(key, singleReference_1.getAndDelete(handler, this, key), queue );
	},
	"can.keyHasDependencies": function(key) {
		return !!(this._computedAttrs && this._computedAttrs[key] &&
			this._computedAttrs[key].compute);
	},
	"can.getKeyDependencies": function(key) {
		var ret;
		if(this._computedAttrs && this._computedAttrs[key] && this._computedAttrs[key].compute) {
			ret = {};
			ret.valueDependencies = new cidSet();
			ret.valueDependencies.add(this._computedAttrs[key].compute);
		}
		return ret;
	}
});


if(!canTypes_1_1_7_canTypes.DefaultMap) {
	canTypes_1_1_7_canTypes.DefaultMap = Map$1;
}

var canMap_4_0_1_canMap = canNamespace_1_0_0_canNamespace.Map = Map$1;

/* jshint -W079 */



















// Helpers for `observable` lists.
var splice$3 = [].splice,
	// test if splice works correctly
	spliceRemovesProps = (function () {
		// IE's splice doesn't remove properties
		var obj = {
			0: "a",
			length: 1
		};
		splice$3.call(obj, 0, 1);
		return !obj[0];
	})();

// Function that serializes the passed arg if
// type does not match MapType of `this` list
// then adds to args array
var serializeNonTypes = function(MapType, arg, args) {
	if(arg && arg.serialize && !(arg instanceof MapType)) {
		args.push(new MapType(arg.serialize()));
	} else {
		args.push(arg);
	}
};

var List = canMap_4_0_1_canMap.extend(
	{
		Map: canMap_4_0_1_canMap
	},
	{
		setup: function (instances, options) {
			this.length = 0;
			canCid_1_1_2_canCid(this, ".map");
			this._setupComputedProperties();
			instances = instances || [];
			var teardownMapping;

			if (isPromise(instances)) {
				this.replace(instances);
			} else {
				teardownMapping = instances.length && canMap_4_0_1_mapHelpers.addToMap(instances, this);
				this.push.apply(this, makeArray_1(instances || []));
			}

			if (teardownMapping) {
				teardownMapping();
			}

			// this change needs to be ignored
			assign$7(this, options);
		},
		_triggerChange: function (attr, how, newVal, oldVal) {
			canQueues_1_1_0_canQueues.batch.start();
			// `batchTrigger` direct add and remove events...
			var index = +attr, patches;
			// Make sure this is not nested and not an expando

			if (!~(""+attr).indexOf('.') && !isNaN(index)) {
				if(canMap_4_0_1_bubble.isBubbling(this, "change")) {
					map$1.dispatch.call(this, {
						type: "change",
						target: this
					}, [attr, how, newVal, oldVal]);
				}
				if (how === 'add') {
					patches = [{insert: newVal, index: index, deleteCount: 0, type: "splice"}];
					map$1.dispatch.call(this, {type: how, patches: patches}, [newVal, index]);
					map$1.dispatch.call(this, 'length', [this.length]);
					//canEvent.dispatch.call(this, 'can.patches', [patches]);
				} else if (how === 'remove') {
					patches = [{index: index, deleteCount: oldVal.length, type: "splice"}];
					map$1.dispatch.call(this, {type: how, patches: patches}, [oldVal, index]);
					map$1.dispatch.call(this, 'length', [this.length]);
					//canEvent.dispatch.call(this, 'can.patches', [patches]);
				} else {
					map$1.dispatch.call(this, how, [newVal, index]);
				}

			} else {
				canMap_4_0_1_canMap.prototype._triggerChange.apply(this, arguments);
			}
			canQueues_1_1_0_canQueues.batch.stop();
		},
		___get: function (attr) {
			if (attr) {
				var computedAttr = this._computedAttrs[attr];
				if(computedAttr && computedAttr.compute) {
					return canReflect_1_16_7_canReflect.getValue(computedAttr.compute);
				}

				if (this[attr] && this[attr].isComputed && typeof this.constructor.prototype[attr] === "function" ) {
					return canReflect_1_16_7_canReflect.getValue(this[attr]);
				} else {
					return this[attr];
				}
			} else {
				return this;
			}
		},
		__set: function (prop, value, current) {
			// We want change events to notify using integers if we're
			// setting an integer index. Note that <float> % 1 !== 0;
			prop = isNaN(+prop) || (prop % 1) ? prop : +prop;

			// Check to see if we're doing a .attr() on an out of
			// bounds index property.
			if (typeof prop === "number") {
				if( prop > this.length - 1 ) {
					var newArr = new Array((prop + 1) - this.length);
					newArr[newArr.length-1] = value;
					this.push.apply(this, newArr);
					return newArr;
				} else {
					this.splice(prop,1,value);
					return this;
				}
			}

			return canMap_4_0_1_canMap.prototype.__set.call(this, ""+prop, value, current);
		},
		___set: function (attr, val) {
			this[attr] = val;
			if (+attr >= this.length) {
				this.length = (+attr + 1);
			}
		},
		__remove: function(prop, current) {
			// if removing an expando property
			if(isNaN(+prop)) {
				delete this[prop];
				this._triggerChange(prop, "remove", undefined, current);
			} else {
				this.splice(prop, 1);
			}
		},
		_each: function (callback) {
			var data = this.___get();
			for (var i = 0; i < data.length; i++) {
				callback(data[i], i);
			}
		},
		// Returns the serialized form of this list.
		/**
		 * @hide
		 * Returns the serialized form of this list.
		 */
		serialize: function () {
			return canReflect_1_16_7_canReflect.serialize(this, cidMap);
		},
		splice: function (index, howMany) {
			var args = makeArray_1(arguments),
				added =[],
				i, len, listIndex,
				allSame = args.length > 2;

			index = index || 0;

			// converting the arguments to the right type
			for (i = 0, len = args.length-2; i < len; i++) {
				listIndex = i + 2;
				args[listIndex] = this.__type(args[listIndex], listIndex);
				added.push(args[listIndex]);

				// Now lets check if anything will change
				if(this[i+index] !== args[listIndex]) {
					allSame = false;
				}
			}

			// if nothing has changed, then return
			if(allSame && this.length <= added.length) {
				return added;
			}

			// default howMany if not provided
			if (howMany === undefined) {
				howMany = args[1] = this.length - index;
			}

			var removed = splice$3.apply(this, args);

			// delete properties for browsers who's splice sucks (old ie)
			if (!spliceRemovesProps) {
				for (i = this.length; i < removed.length + this.length; i++) {
					delete this[i];
				}
			}

			canQueues_1_1_0_canQueues.batch.start();
			if (howMany > 0) {
				// tears down bubbling
				canMap_4_0_1_bubble.removeMany(this, removed);
				this._triggerChange("" + index, "remove", undefined, removed);
			}
			if (args.length > 2) {
				// make added items bubble to this list
				canMap_4_0_1_bubble.addMany(this, added);
				this._triggerChange("" + index, "add", added, removed);
			}
			canQueues_1_1_0_canQueues.batch.stop();
			return removed;
		}
	}),

	// Converts to an `array` of arguments.
	getArgs$1 = function (args) {
		return args[0] && Array.isArray(args[0]) ?
			args[0] :
			makeArray_1(args);
	};
// Create `push`, `pop`, `shift`, and `unshift`
each_1({
		/**
		 * @function can-list.prototype.push push
		 * @parent can-list.prototype
		 * @description Add elements to the end of a list.
		 * @signature `list.push(...elements)`
		 *
		 * `push` adds elements onto the end of a List.
		 *
		 * @param {*} elements the elements to add to the List
		 *
		 * @return {Number} the new length of the List
		 *
		 * @body
		 * `push` adds elements onto the end of a List here is an example:
		 *
		 * ```
		 * var list = new List(['Alice']);
		 *
		 * list.push('Bob', 'Eve');
		 * list.attr(); // ['Alice', 'Bob', 'Eve']
		 * ```
		 *
		 * If you have an array you want to concatenate to the end
		 * of the List, you can use `apply`:
		 *
		 * ```
		 * var names = ['Bob', 'Eve'],
		 *     list = new List(['Alice']);
		 *
		 * list.push.apply(list, names);
		 * list.attr(); // ['Alice', 'Bob', 'Eve']
		 * ```
		 *
		 * ## Events
		 *
		 * `push` causes _change_, _add_, and _length_ events to be fired.
		 *
		 * ## See also
		 *
		 * `push` has a counterpart in [can-list.prototype.pop], or you may be
		 * looking for [can-list.prototype.unshift] and its counterpart [can-list.prototype.shift].
		 */
		push: "length",
		/**
		 * @function can-list.prototype.unshift unshift
		 * @parent can-list.prototype
		 * @description Add elements to the beginning of a List.
		 * @signature `list.unshift(...elements)`
		 *
		 * `unshift` adds elements onto the beginning of a List.
		 *
		 * @param {*} elements the elements to add to the List
		 *
		 * @return {Number} the new length of the List
		 *
		 * @body
		 * `unshift` adds elements to the front of the list in bulk in the order specified:
		 *
		 * ```
		 * var list = new List(['Alice']);
		 *
		 * list.unshift('Bob', 'Eve');
		 * list.attr(); // ['Bob', 'Eve', 'Alice']
		 * ```
		 *
		 * If you have an array you want to concatenate to the beginning
		 * of the List, you can use `apply`:
		 *
		 * ```
		 * var names = ['Bob', 'Eve'],
		 *     list = new List(['Alice']);
		 *
		 * list.unshift.apply(list, names);
		 * list.attr(); // ['Bob', 'Eve', 'Alice']
		 * ```
		 *
		 * ## Events
		 *
		 * `unshift` causes _change_, _add_, and _length_ events to be fired.
		 *
		 * ## See also
		 *
		 * `unshift` has a counterpart in [can-list.prototype.shift], or you may be
		 * looking for [can-list.prototype.push] and its counterpart [can-list.prototype.pop].
		 */
		unshift: 0
	},
	// Adds a method
	// `name` - The method name.
	// `where` - Where items in the `array` should be added.
	function (where, name) {
		var orig = [][name];
		List.prototype[name] = function () {
			// Get the items being added.
			var args = [],
				// Where we are going to add items.
				len = where ? this.length : 0,
				i = arguments.length,
				res, val;

			// Go through and convert anything to a `map` that needs to be converted.
			while (i--) {
				val = arguments[i];
				args[i] = canMap_4_0_1_bubble.set(this, i, this.__type(val, i) );
			}

			// Call the original method.
			res = orig.apply(this, args);

			if (!this.comparator || args.length) {

				this._triggerChange("" + len, "add", args, undefined);
			}

			return res;
		};
	});

each_1({
		/**
		 * @function can-list.prototype.pop pop
		 * @parent can-list.prototype
		 * @description Remove an element from the end of a List.
		 * @signature `list.pop()`
		 *
		 * `pop` removes an element from the end of a List.
		 *
		 * @return {*} the element just popped off the List, or `undefined` if the List was empty
		 *
		 * @body
		 * `pop` is the opposite action from [can-list.prototype.push]:
		 *
		 * ```
		 * var list = new List(['Alice', 'Bob', 'Eve']);
		 * list.attr(); // ['Alice', 'Bob', 'Eve']
		 *
		 * list.pop(); // 'Eve'
		 * list.pop(); // 'Bob'
		 * list.pop(); // 'Alice'
		 * list.pop(); // undefined
		 * ```
		 *
		 * ## Events
		 *
		 * `pop` causes _change_, _remove_, and _length_ events to be fired if the List is not empty
		 * when it is called.
		 *
		 * ## See also
		 *
		 * `pop` has its counterpart in [can-list.prototype.push], or you may be
		 * looking for [can-list.prototype.unshift] and its counterpart [can-list.prototype.shift].
		 */
		pop: "length",
		/**
		 * @function can-list.prototype.shift shift
		 * @parent can-list.prototype
		 * @description Remove en element from the front of a list.
		 * @signature `list.shift()`
		 *
		 * `shift` removes an element from the beginning of a List.
		 *
		 * @return {*} the element just shifted off the List, or `undefined` if the List is empty
		 *
		 * @body
		 * `shift` is the opposite action from `[can-list.prototype.unshift]`:
		 *
		 * ```
		 * var list = new List(['Alice']);
		 *
		 * list.unshift('Bob', 'Eve');
		 * list.attr(); // ['Bob', 'Eve', 'Alice']
		 *
		 * list.shift(); // 'Bob'
		 * list.shift(); // 'Eve'
		 * list.shift(); // 'Alice'
		 * list.shift(); // undefined
		 * ```
		 *
		 * ## Events
		 *
		 * `pop` causes _change_, _remove_, and _length_ events to be fired if the List is not empty
		 * when it is called.
		 *
		 * ## See also
		 *
		 * `shift` has a counterpart in [can-list.prototype.unshift], or you may be
		 * looking for [can-list.prototype.push] and its counterpart [can-list.prototype.pop].
		 */
		shift: 0
	},
	// Creates a `remove` type method
	function (where, name) {
		List.prototype[name] = function () {
			if (!this.length) {
				// For shift and pop, we just return undefined without
				// triggering events.
				return undefined;
			}

			var args = getArgs$1(arguments),
				len = where && this.length ? this.length - 1 : 0;

			var res = [][name].apply(this, args);

			// Create a change where the args are
			// `len` - Where these items were removed.
			// `remove` - Items removed.
			// `undefined` - The new values (there are none).
			// `res` - The old, removed values (should these be unbound).
			this._triggerChange("" + len, "remove", undefined, [res]);

			if (res && res.removeEventListener) {
				canMap_4_0_1_bubble.remove(this, res);
			}

			return res;
		};
	});

assign$7(List.prototype, {
	/**
	 * @function can-list.prototype.indexOf indexOf
	 * @parent can-list.prototype
	 * @description Look for an item in a List.
	 * @signature `list.indexOf(item)`
	 *
	 * `indexOf` finds the position of a given item in the List.
	 *
	 * @param {*} item the item to find
	 *
	 * @return {Number} the position of the item in the List, or -1 if the item is not found.
	 *
	 * @body
	 * ```
	 * var list = new List(['Alice', 'Bob', 'Eve']);
	 * list.indexOf('Alice');   // 0
	 * list.indexOf('Charlie'); // -1
	 * ```
	 *
	 * It is trivial to make a `contains`-type function using `indexOf`:
	 *
	 * ```
	 * function(list, item) {
	 *     return list.indexOf(item) >= 0;
	 * }
	 * ```
	 */
	indexOf: function (item, fromIndex) {
		canObservationRecorder_1_1_2_canObservationRecorder.add(this, "length");
		for(var i = fromIndex || 0, len = this.length; i < len; i++) {
			if(this.attr(i) === item) {
				return i;
			}
		}
		return -1;
	},

	/**
	 * @function can-list.prototype.join join
	 * @parent can-list.prototype
	 * @description Join a List's elements into a string.
	 * @signature `list.join(separator)`
	 *
	 * `join` turns a List into a string by inserting _separator_ between the string representations
	 * of all the elements of the List.
	 *
	 * @param {String} separator the string to seperate elements with
	 *
	 * @return {String} the joined string
	 *
	 * @body
	 * ```
	 * var list = new List(['Alice', 'Bob', 'Eve']);
	 * list.join(', '); // 'Alice, Bob, Eve'
	 *
	 * var beatles = new List(['John', 'Paul', 'Ringo', 'George']);
	 * beatles.join('&'); // 'John&Paul&Ringo&George'
	 * ```
	 */
	join: function () {
		canObservationRecorder_1_1_2_canObservationRecorder.add(this, "length");
		return [].join.apply(this, arguments);
	},

	/**
	 * @function can-list.prototype.reverse reverse
	 * @parent can-list.prototype
	 * @description Reverse the order of a List.
	 * @signature `list.reverse()`
	 *
	 * `reverse` reverses the elements of the List in place.
	 *
	 * @return {can-list} the List, for chaining
	 *
	 * @body
	 * ```
	 * var list = new List(['Alice', 'Bob', 'Eve']);
	 * var reversedList = list.reverse();
	 *
	 * reversedList.attr(); // ['Eve', 'Bob', 'Alice'];
	 * list === reversedList; // true
	 * ```
	 */
	reverse: function() {
		var list = [].reverse.call(makeArray_1(this));
		return this.replace(list);
	},

	/**
	 * @function can-list.prototype.slice slice
	 * @parent can-list.prototype
	 * @description Make a copy of a part of a List.
	 * @signature `list.slice([start[, end]])`
	 *
	 * `slice` creates a copy of a portion of the List.
	 *
	 * @param {Number} [start=0] the index to start copying from
	 *
	 * @param {Number} [end] the first index not to include in the copy
	 * If _end_ is not supplied, `slice` will copy until the end of the list.
	 *
	 * @return {can-list} a new `can-list` with the extracted elements
	 *
	 * @body
	 * ```
	 * var list = new List(['Alice', 'Bob', 'Charlie', 'Daniel', 'Eve']);
	 * var newList = list.slice(1, 4);
	 * newList.attr(); // ['Bob', 'Charlie', 'Daniel']
	 * ```
	 *
	 * `slice` is the simplest way to copy a List:
	 *
	 * ```
	 * var list = new List(['Alice', 'Bob', 'Eve']);
	 * var copy = list.slice();
	 *
	 * copy.attr();   // ['Alice', 'Bob', 'Eve']
	 * list === copy; // false
	 * ```
	 */
	slice: function () {
		// tells computes to listen on length for changes.
		canObservationRecorder_1_1_2_canObservationRecorder.add(this, "length");
		var temp = Array.prototype.slice.apply(this, arguments);
		return new this.constructor(temp);
	},

	/**
	 * @function can-list.prototype.concat concat
	 * @parent can-list.prototype
	 * @description Merge many collections together into a List.
	 * @signature `list.concat(...args)`
	 * @param {Array|can-list|*} args Any number of arrays, Lists, or values to add in
	 * For each parameter given, if it is an Array or a List, each of its elements will be added to
	 * the end of the concatenated List. Otherwise, the parameter itself will be added.
	 *
	 * @body
	 * `concat` makes a new List with the elements of the List followed by the elements of the parameters.
	 *
	 * ```
	 * var list = new List();
	 * var newList = list.concat(
	 *     'Alice',
	 *     ['Bob', 'Charlie']),
	 *     new List(['Daniel', 'Eve']),
	 *     {f: 'Francis'}
	 * );
	 * newList.attr(); // ['Alice', 'Bob', 'Charlie', 'Daniel', 'Eve', {f: 'Francis'}]
	 * ```
	 */
	concat: function() {
		var args = [],
			MapType = this.constructor.Map;
		// Go through each of the passed `arguments` and
		// see if it is list-like, an array, or something else
		each_1(arguments, function(arg) {
			if((canReflect_1_16_7_canReflect.isObservableLike(arg) && canReflect_1_16_7_canReflect.isListLike(arg)) || Array.isArray(arg)) {
				// If it is list-like we want convert to a JS array then
				// pass each item of the array to serializeNonTypes
				var arr = (canReflect_1_16_7_canReflect.isObservableLike(arg) && canReflect_1_16_7_canReflect.isListLike(arg)) ? makeArray_1(arg) : arg;
				each_1(arr, function(innerArg) {
					serializeNonTypes(MapType, innerArg, args);
				});
			}
			else {
				// If it is a Map, Object, or some primitive
				// just pass arg to serializeNonTypes
				serializeNonTypes(MapType, arg, args);
			}
		});

		// We will want to make `this` list into a JS array
		// as well (We know it should be list-like), then
		// concat with our passed in args, then pass it to
		// list constructor to make it back into a list
		return new this.constructor(Array.prototype.concat.apply(makeArray_1(this), args));
	},

	/**
	 * @function can-list.prototype.forEach forEach
	 * @parent can-list.prototype
	 * @description Call a function for each element of a List.
	 * @signature `list.forEach(callback[, thisArg])`
	 * @param {function(element, index, list)} callback a function to call with each element of the List
	 * The three parameters that _callback_ gets passed are _element_, the element at _index_, _index_ the
	 * current element of the list, and _list_ the List the elements are coming from. _callback_ is
	 * not invoked for List elements that were never initialized.
	 * @param {Object} [thisArg] the object to use as `this` inside the callback
	 *
	 * @body
	 * `forEach` calls a callback for each element in the List.
	 *
	 * ```
	 * var list = new List([1, 2, 3]);
	 * list.forEach(function(element, index, list) {
	 *     list.attr(index, element * element);
	 * });
	 * list.attr(); // [1, 4, 9]
	 * ```
	 */
	forEach: function (cb, thisarg) {
		var item;
		for (var i = 0, len = this.attr("length"); i < len; i++) {
			item = this.attr(i);
			if (item !== undefined && cb.call(thisarg || item, item, i, this) === false) {
				break;
			}
		}
		return this;
	},

	/**
	 * @function can-list.prototype.replace replace
	 * @parent can-list.prototype
	 * @description Replace all the elements of a List.
	 * @signature `list.replace(collection)`
	 * @param {Array|can-list|can.Deferred} collection the collection of new elements to use
	 * If a [can.Deferred] is passed, it must resolve to an `Array` or `can-list`.
	 * The elements of the list are not actually removed until the Deferred resolves.
	 *
	 * @body
	 * `replace` replaces all the elements of this List with new ones.
	 *
	 * `replace` is especially useful when `can-list`s are live-bound into `[can-control]`s,
	 * and you intend to populate them with the results of a `[can-model]` call:
	 *
	 * ```
	 * can.Control({
	 *     init: function() {
	 *         this.list = new Todo.List();
	 *         // live-bind the list into the DOM
	 *         this.element.html(can.view('list.stache', this.list));
	 *         // when this AJAX call returns, the live-bound DOM will be updated
	 *         this.list.replace(Todo.findAll());
	 *     }
	 * });
	 * ```
	 *
	 * Learn more about [can.Model.List making Lists of models].
	 *
	 * ## Events
	 *
	 * A major difference between `replace` and `attr(newElements, true)` is that `replace` always emits
	 * an _add_ event and a _remove_ event, whereas `attr` will cause _set_ events along with an _add_ or _remove_
	 * event if needed. Corresponding _change_ and _length_ events will be fired as well.
	 *
	 * The differences in the events fired by `attr` and `replace` are demonstrated concretely by this example:
	 * ```
	 * var attrList = new List(['Alexis', 'Bill']);
	 * attrList.bind('change', function(ev, index, how, newVals, oldVals) {
	 *     console.log(index + ', ' + how + ', ' + newVals + ', ' + oldVals);
	 * });
	 *
	 * var replaceList = new List(['Alexis', 'Bill']);
	 * replaceList.bind('change', function(ev, index, how, newVals, oldVals) {
	 *     console.log(index + ', ' + how + ', ' + newVals + ', ' + oldVals);
	 * });
	 *
	 * attrList.attr(['Adam', 'Ben'], true);         // 0, set, Adam, Alexis
	 *                                               // 1, set, Ben, Bill
	 * replaceList.replace(['Adam', 'Ben']);         // 0, remove, undefined, ['Alexis', 'Bill']
	 *                                               // 0, add, ['Adam', 'Ben'], ['Alexis', 'Bill']
	 *
	 * attrList.attr(['Amber'], true);               // 0, set, Amber, Adam
	 *                                               // 1, remove, undefined, Ben
	 * replaceList.replace(['Amber']);               // 0, remove, undefined, ['Adam', 'Ben']
	 *                                               // 0, add, Amber, ['Adam', 'Ben']
	 *
	 * attrList.attr(['Alice', 'Bob', 'Eve'], true); // 0, set, Alice, Amber
	 *                                               // 1, add, ['Bob', 'Eve'], undefined
	 * replaceList.replace(['Alice', 'Bob', 'Eve']); // 0, remove, undefined, Amber
	 *                                               // 0, add, ['Alice', 'Bob', 'Eve'], Amber
	 * ```
	 */
	replace: function (newList) {
		if (isPromise(newList)) {
			if(this._promise) {
				this._promise.__isCurrentPromise = false;
			}
			var promise = this._promise = newList;
			promise.__isCurrentPromise = true;
			var self = this;
			newList.then(function(newList){
				if(promise.__isCurrentPromise) {
					self.replace(newList);
				}
			});
		} else {
			this.splice.apply(this, [0, this.length].concat(makeArray_1(newList || [])));
		}

		return this;
	},
	filter: function (callback, thisArg) {
		var filteredList = new this.constructor(),
			self = this,
			filtered;
		this.forEach(function(item, index, list){
			filtered = callback.call( thisArg || self, item, index, self);
			if(filtered){
				filteredList.push(item);
			}
		});
		return filteredList;
	},
	map: function (callback, thisArg) {
		var filteredList = new List(),
			self = this;
		this.forEach(function(item, index, list){
			var mapped = callback.call( thisArg || self, item, index, self);
			filteredList.push(mapped);

		});
		return filteredList;
	}
});

// change some map stuff to include list stuff
var oldType = canMap_4_0_1_canMap.prototype.__type;
canMap_4_0_1_canMap.prototype.__type = function(value, prop){

	if (typeof value === "object" && Array.isArray(value) ) {

		var cached = canMap_4_0_1_mapHelpers.getMapFromObject(value);
		if(cached) {
			return cached;
		}

		return new List(value);

	}
	return oldType.apply(this, arguments);
};

var oldSetup = canMap_4_0_1_canMap.setup;
canMap_4_0_1_canMap.setup = function(){
	oldSetup.apply(this, arguments);
	if (!(this.prototype instanceof List)) {
		this.List = canMap_4_0_1_canMap.List.extend({
			Map: this
		}, {});
	}
};

if(!canTypes_1_1_7_canTypes.DefaultList) {
	canTypes_1_1_7_canTypes.DefaultList = List;
}

// Setup other symbols

canReflect_1_16_7_canReflect.assignSymbols(List.prototype,{
	// -type-

	"can.isMoreListLikeThanMapLike":  true,
	"can.isListLike":  true,

	// -get/set-
	"can.getKeyValue": List.prototype._get,
	"can.setKeyValue": List.prototype._set,
	"can.deleteKeyValue": List.prototype._remove,

	// -shape
	"can.getOwnEnumerableKeys": function(){
		return Object.keys(this._data || {}).concat(this.map(function(val, index) {
			return index;
		}));
	},

	// -shape get/set-
	"can.assignDeep": function(source){
		canQueues_1_1_0_canQueues.batch.start();
		// TODO: we should probably just throw an error instead of cleaning
		canReflect_1_16_7_canReflect.assignDeepList(this, source);
		canQueues_1_1_0_canQueues.batch.stop();
	},
	"can.updateDeep": function(source){
		canQueues_1_1_0_canQueues.batch.start();
		// TODO: we should probably just throw an error instead of cleaning
		canReflect_1_16_7_canReflect.updateDeepList(this, source);
		canQueues_1_1_0_canQueues.batch.stop();
	},

	"can.unwrap": canMap_4_0_1_mapHelpers.reflectUnwrap,
	"can.serialize": canMap_4_0_1_mapHelpers.reflectSerialize,

	// observable
	"can.onKeysAdded": function(handler) {
		this[canSymbol_1_6_1_canSymbol.for("can.onKeyValue")]("add", handler);
	},
	"can.onKeysRemoved":  function(handler) {
		this[canSymbol_1_6_1_canSymbol.for("can.onKeyValue")]("remove", handler);
	},
	"can.splice": function(index, deleteCount, insert){
		this.splice.apply(this, [index, deleteCount].concat(insert));
	}
});




// @@can.keyHasDependencies and @@can.getKeyDependencies same as can-map

canMap_4_0_1_canMap.List = List;
var canList_4_0_2_canList = canNamespace_1_0_0_canNamespace.List = List;

var define$1 = {}; // jshint ignore:line

var getPropDefineBehavior = function(behavior, attr, define) {
	var prop, defaultProp;

	if (define) {
		prop = define[attr];
		defaultProp = define['*'];

		if (prop && prop[behavior] !== undefined) {
			return prop[behavior];
		} else if (defaultProp && defaultProp[behavior] !== undefined) {
			return defaultProp[behavior];
		}
	}
};

// This is called when the Map is defined
canMap_4_0_1_mapHelpers.define = function(Map, baseDefine) {
	var definitions = Map.prototype.define;

	if (baseDefine) {
		var defines = {};
		canMap_4_0_1_mapHelpers.twoLevelDeepExtend(defines, baseDefine);
		canMap_4_0_1_mapHelpers.twoLevelDeepExtend(defines, definitions);
		assign$7(definitions, defines);
	}
	//!steal-remove-start
	if (Map.define) {
		dev$3.warn("The define property should be on the map's prototype properties, " +
			"not the static properties.");
	}
	//!steal-remove-end
	Map.defaultGenerators = {};
	for (var prop in definitions) {
		var type = definitions[prop].type;
		if (typeof type === "string") {
			if (typeof define$1.types[type] === "object") {
				delete definitions[prop].type;
				assign$7(definitions[prop], define$1.types[type]);
			}
		}
		if ("value" in definitions[prop]) {
			if (typeof definitions[prop].value === "function") {
				Map.defaultGenerators[prop] = definitions[prop].value;
			} else {
				Map.defaults[prop] = definitions[prop].value;
			}
		}
		if (typeof definitions[prop].Value === "function") {
			(function(Constructor) {
				Map.defaultGenerators[prop] = function() {
					return new Constructor();
				};
			})(definitions[prop].Value);
		}
	}
};


var oldSetupDefaults = canMap_4_0_1_canMap.prototype._setupDefaults;
canMap_4_0_1_canMap.prototype._setupDefaults = function(obj) {
	var defaults = assign$7({},oldSetupDefaults.call(this)),
		propsCommittedToAttr = {},
		Map = this.constructor,
		originalGet = this._get;

	// Overwrite this._get with a version that commits defaults to
	// this.attr() as needed. Because calling this.attr() for each
	// individual default would be expensive.
	this._get = function(originalProp) {
		// If a this.attr() was called using dot syntax (e.g number.0),
		// disregard everything after the "." until we call the
		// original this._get().
		var prop = (originalProp.indexOf('.') !== -1 ?
			originalProp.substr(0, originalProp.indexOf('.')) :
			originalProp);

		// If this property has a default and we haven't yet committed it to
		// this.attr()
		if ((prop in defaults) && !(prop in propsCommittedToAttr)) {

			// Commit the property's default so that it can be read in
			// other defaultGenerators.
			this.attr(prop, defaults[prop]);

			// Make not so that we don't commit this property again.
			propsCommittedToAttr[prop] = true;
		}

		return originalGet.apply(this, arguments);
	};

	for (var prop in Map.defaultGenerators) {
		// Only call the prop's value method if the property wasn't provided
		// during instantiation.
		if (!obj || !(prop in obj)) {
			defaults[prop] = Map.defaultGenerators[prop].call(this);
		}
	}

	// delete this._get which will default to the one on the prototype.
	delete this._get;

	return defaults;
};


var proto = canMap_4_0_1_canMap.prototype,
	oldSet = proto.__set;
proto.__set = function(prop, value, current, success, error) {
	//!steal-remove-start
	var asyncTimer;
	//!steal-remove-end

	var self = this;

	// check if there's a setter
	var errorCallback = function(errors) {
			//!steal-remove-start
			clearTimeout(asyncTimer);
			//!steal-remove-end

			var stub = error && error.call(self, errors);
			// if 'validations' is on the page it will trigger
			// the error itself and we dont want to trigger
			// the event twice. :)
			if (stub !== false) {
				map$1.dispatch.call(self, 'error', [ prop, errors ], true);
			}
			return false;
		},
		setter = getPropDefineBehavior("set", prop, this.define),
		getter = getPropDefineBehavior("get", prop, this.define);


	// if we have a setter
	if (setter) {
		// call the setter, if returned value is undefined,
		// this means the setter is async so we
		// do not call update property and return right away
		canQueues_1_1_0_canQueues.batch.start();
		var setterCalled = false,

			setValue = setter.call(this, value, function(value) {
				if (getter) {
					self[prop](value);
				} else {
					oldSet.call(self, prop, value, current, success, errorCallback);
				}

				setterCalled = true;
				//!steal-remove-start
				clearTimeout(asyncTimer);
				//!steal-remove-end
			}, errorCallback, getter ? this._computedAttrs[prop].compute.computeInstance.lastSetValue.get() : current);
		if (getter) {
			// if there's a getter we don't call old set
			// instead we call the getter's compute with the new value
			if (setValue !== undefined && !setterCalled && setter.length >= 1) {
				this._computedAttrs[prop].compute(setValue);
			}

			canQueues_1_1_0_canQueues.batch.stop();
			return;
		}
		// if it took a setter and returned nothing, don't set the value
		else if (setValue === undefined && !setterCalled && setter.length > 1) {
			//!steal-remove-start
			asyncTimer = setTimeout(function() {
				dev$3.warn('can/map/define: Setter "' + prop + '" did not return a value or call the setter callback.');
			}, dev$3.warnTimeout);
			//!steal-remove-end
			canQueues_1_1_0_canQueues.batch.stop();
			return;
		} else {
			if (!setterCalled) {
				oldSet.call(self, prop,
					// if no arguments, we are side-effects only
					setter.length === 0 && setValue === undefined ? value : setValue,
					current,
					success,
					errorCallback);
			}
			canQueues_1_1_0_canQueues.batch.stop();
			return this;
		}

	} else {
		oldSet.call(self, prop, value, current, success, errorCallback);
	}

	return this;
};

define$1.types = {
	'date': function(str) {
		var type = typeof str;
		if (type === 'string') {
			str = Date.parse(str);
			return isNaN(str) ? null : new Date(str);
		} else if (type === 'number') {
			return new Date(str);
		} else {
			return str;
		}
	},
	'number': function(val) {
		if (val == null) {
			return val;
		}
		return +(val);
	},
	'boolean': function(val) {
		if(val == null) {
			return val;
		}
		if (val === 'false' || val === '0' || !val) {
			return false;
		}
		return true;
	},
	'htmlbool': function(val) {
		return typeof val === "string" || !!val;
	},
	'*': function(val) {
		return val;
	},
	'string': function(val) {
		if (val == null) {
			return val;
		}
		return '' + val;
	},
	'compute': {
		set: function(newValue, setVal, setErr, oldValue) {
			if (newValue && newValue.isComputed) {
				return newValue;
			}
			if (oldValue && oldValue.isComputed) {
				oldValue(newValue);
				return oldValue;
			}
			return newValue;
		},
		get: function(value) {
			return value && value.isComputed ? value() : value;
		}
	}
};

// the old type sets up bubbling
var oldType$1 = proto.__type;
proto.__type = function(value, prop) {
	var type = getPropDefineBehavior("type", prop, this.define),
		Type = getPropDefineBehavior("Type", prop, this.define),
		newValue = value;

	if (typeof type === "string") {
		type = define$1.types[type];
	}

	if (type || Type) {
		// If there's a type, convert it.
		if (type) {
			newValue = type.call(this, newValue, prop);
		}
		// If there's a Type and newValue is non-null create a new instance of it
		if (Type && newValue != null && !(newValue instanceof Type)) {
			newValue = new Type(newValue);
		}
		// If the newValue is a Map, we need to hook it up
		return newValue;

	}
	// If we pass in a object with define
	else if (isPlainObject_1(newValue) && newValue.define) {
		newValue = canMap_4_0_1_canMap.extend(newValue);
		newValue = new newValue();
	}
	return oldType$1.call(this, newValue, prop);
};

var oldRemove = proto.__remove;
proto.__remove = function(prop, current) {
	var remove = getPropDefineBehavior("remove", prop, this.define),
		res;
	if (remove) {
		canQueues_1_1_0_canQueues.batch.start();
		res = remove.call(this, current);

		if (res === false) {
			canQueues_1_1_0_canQueues.batch.stop();
			return;
		} else {

			res = oldRemove.call(this, prop, current);
			canQueues_1_1_0_canQueues.batch.stop();
			return res;
		}
	}
	return oldRemove.call(this, prop, current);
};

var oldSetupComputes = proto._setupComputedProperties;
proto._setupComputedProperties = function() {
	oldSetupComputes.apply(this, arguments);
	for (var attr in this.define) {
		var def = this.define[attr],
			get = def.get;
		if (get) {
			canMap_4_0_1_mapHelpers.addComputedAttr(this, attr, canCompute_4_0_3_canCompute.async(undefined, get, this));
		}
	}
};
// Overwrite the invidual property serializer b/c we will overwrite it.
var oldSingleSerialize = proto.___serialize;
// If the map has a define serializer for the given attr, run it.
var serializeProp = function(map, attr, val) {
	var serializer = attr === "*" ? false : getPropDefineBehavior("serialize", attr, map.define);
	if (serializer === undefined) {
		return oldSingleSerialize.call(map, attr, val);
	} else if (serializer !== false) {
		return typeof serializer === "function" ? serializer.call(map, val, attr) : oldSingleSerialize.call(map, attr, val);
	}
};

proto.___serialize = function(name, val) {
	return serializeProp(this, name, val);
};

// Overwrite serialize to add in any missing define serialized properties.
var oldSerialize = proto.serialize;
proto.serialize = function(property) {
	var serialized = oldSerialize.apply(this, arguments);
	if (property) {
		return serialized;
	}
	// add in properties not already serialized

	var serializer,
		val;
	// Go through each property.
	for (var attr in this.define) {
		// if it's not already defined
		if (!(attr in serialized)) {
			// check there is a serializer so we aren't doing extra work on serializer:false
			// also check for a wildcard serializer
			serializer = this.define && (this.define[attr] && this.define[attr].serialize || this.define['*'] && this.define['*'].serialize);
			if (serializer) {
				val = serializeProp(this, attr, this.attr(attr));
				if (val !== undefined) {
					serialized[attr] = val;
				}
			}
		}
	}
	return serialized;
};

var canMapDefine_4_0_0_canMapDefine = define$1;

// for can-set compat









var IsBoolean = function(){

};
makeEnum_1(IsBoolean,[true, false], function(value) {

    if(value === "true") {
        return true;
    } else if(value === "false") {
        return false;
    } else {
        return value;
    }

});

function hasKey(obj, keys, parent, parentKey) {
    if(obj && typeof obj === "object") {
        for(var key in obj) {
            if(keys[key]) {
                if(typeof keys[key] === "function") {
                    parent[parentKey] = keys[key](obj);
                } else {
                    return true;
                }

            } else {
                if( hasKey(obj[key], keys, obj, key) ) {
                    return true;
                }
            }
        }
    }
    return false;
}

function convertToJSONAPISort(sortPropValue){
    var parts = sortPropValue.split(' ');
    var isDesc = (parts[1] || '').toLowerCase()	=== 'desc';

    return isDesc ? "-"+parts[0] : parts[0];
}
function convertToLegacySort(value) {
    var result = helpers_1$1.sortData(value);
    return result.desc ? "-"+result.prop : result.prop;
}

var defaultAlgebra;

var set$4 = {
    UNIVERSAL: set_1.UNIVERSAL,
    // Nothing
    EMPTY: set_1.EMPTY,
    // The set exists, but we lack the language to represent it.
    UNDEFINABLE: set_1.UNDEFINABLE,

    // We don't know if this exists. Intersection between two paginated sets.
    UNKNOWABLE: set_1.UNKNOWABLE,
    Algebra: function(){
        var mutators = {
            schema: [],
            hydrate: [],
            serialize: []
        };
        canReflect_1_16_7_canReflect.eachIndex(arguments, function(value){
            for(var prop in value) {
                if(mutators[prop]) {
                    mutators[prop].push(value[prop]);
                } else {
                    throw new Error("can-query-logic: This type of configuration is not supported. Please use can-query-logic directly.");
                }

            }
        });

        var obj = canReflect_1_16_7_canReflect.assignSymbols({},{
            "can.getSchema": function(){
                var schema = {
                    kind: "record",
                    identity: [],
                    keys: {}
                };
                mutators.schema.forEach(function(updateSchema){
                    updateSchema(schema);
                });
                if(!schema.identity.length) {
                    schema.identity.push("id");
                }

                return schema;
            }
        });
        return new canQueryLogic_0_8_11_canQueryLogic(obj, {
            toQuery: function(data){
                return mutators.hydrate.reduce(function(last, hydrator){
                    return hydrator(last);
                }, {filter: data});
            },
            toParams: function(data){
                if(set_1.isSpecial(data)) {
                    return data;
                }
                /*if(data === SET.EMPTY) {
                    return false;
                }
                if(data === SET.UNDEFINABLE) {
                    return true;
                }*/
                if(Array.isArray(data.filter)){
                    // OR is not supported ...
                    return set_1.UNDEFINABLE;
                }

                var filter = data.filter || {};
                if(hasKey(filter, {
                    "$ne": true,
                    "$in": function(val){ return val.$in; }
                })) {
                    return set_1.UNDEFINABLE;
                }

                var out = mutators.serialize.reduce(function(last, serializer){
                    return serializer(last);
                }, data);

                filter = out.filter || {};
                delete out.filter;
                return canReflect_1_16_7_canReflect.assign(out, filter);
            }
        });
    },
    Translate: function(clause, prop){
        if(clause !== "where") {
            throw new Error("can-query-logic/compat.Translate is only able to translate the where clause");
        }
        return {
            // {filter: {$where: {a:b}}} -> {filter: {a:b}}
            hydrate: function(raw){
                var clone = canReflect_1_16_7_canReflect.serialize(raw);
                var value = clone.filter[prop];
                delete clone.filter[prop];
                if(value) {
                    canReflect_1_16_7_canReflect.assign(clone.filter, value);
                }

                return clone;
            },
            // {filter: {foo:bar}} -> {filter: {where: {foo: bar}}}
            serialize: function(query){

                if(query.filter) {
                    var clone = canReflect_1_16_7_canReflect.serialize(query);
                    var filter = query.filter;
                    clone.filter = {};
                    clone.filter[prop] = filter;
                    return clone;
                } else {
                    return query;
                }
            }
        };
    },
    props: {

        boolean: function(prop){
            // create boolean or enum
            return {
                schema: function(schema) {
                    schema.keys[prop] = IsBoolean;
                }
            };
        },
        dotNotation: function(){
            // This will be supported by default
            return {};
        },
        enum: function(property, propertyValues) {
            function Enum(){}
            makeEnum_1(Enum, propertyValues);
            return {
                schema: function(schema) {
                    schema.keys[property] = Enum;
                }
            };
        },
        id: function(id){
            return {
                "schema": function(schema){
                    schema.identity.push(id);
                }
            };
        },
        offsetLimit: function(offset, limit){
            offset = offset || "offset";
            limit = limit || "limit";

            return {
                // taking what was given and making it a raw query look
                // start -> page.start
                // end -> page.end
                hydrate: function(raw){
                    var clone = canReflect_1_16_7_canReflect.serialize(raw);
                    if((offset in clone.filter) || (limit in clone.filter)) {
                        clone.page = {};
                    }
                    if(offset in clone.filter) {
                        clone.page.start = parseInt(clone.filter[offset], 10);
                        delete clone.filter[offset];
                    }
                    if(limit in clone.filter) {
                        clone.page.end = (clone.page.start || 0 ) + parseInt(clone.filter[limit], 10) - 1;
                        delete clone.filter[limit];
                    }
                    return clone;
                },
                // taking the normal format and putting it back
                // page.start -> start
                // page.end -> end
                serialize: function(raw){
                    var clone = canReflect_1_16_7_canReflect.serialize(raw);
                    if(clone.page) {
                        clone[offset] = clone.page.start;
                        clone[limit] = (clone.page.end - clone.page.start) + 1;
                        delete clone.page;
                    }
                    return clone;
                }
            };
        },
        rangeInclusive: function(start, end){
            var hydrateTransfomer = {};
            hydrateTransfomer["filter."+start] = "page.start";
            hydrateTransfomer["filter."+end] = "page.end";

            var serializeTransformer = {
                "page.start": start,
                "page.end": end
            };
            return {
                // taking what was given and making it a raw query look
                // start -> page.start
                // end -> page.end
                hydrate: function(raw){
                    var res = transform(raw, hydrateTransfomer);
                    if(res.page) {
                        if(res.page.start) {
                            res.page.start = parseInt(res.page.start, 10);
                        }
                        if(res.page.end) {
                            res.page.end = parseInt(res.page.end, 10);
                        }
                    }
                    return res;
                },
                // taking the normal format and putting it back
                // page.start -> start
                // page.end -> end
                serialize: function(raw){
                    return transform(raw, serializeTransformer);
                }
            };
        },
        ignore: function(prop){
            return {
                hydrate: function(raw){
                    var clone = canReflect_1_16_7_canReflect.serialize(raw);
                    delete clone.filter[prop];
                    return clone;
                }
            };
        },
        sort: function(prop, sortFunc){
            /**
             * var parts = sortPropValue.split(' ');
                 return {
                     prop: parts[0],
                     desc: (parts[1] || '').toLowerCase()	=== 'desc'
                 };
             */
            if(!prop) {
                prop = "sort";
            }
            if(sortFunc) {
                throw new Error("can-query-logic/compat.sort - sortFunc is not supported");
            }

            return {
                hydrate: function(raw){
                    var clone = canReflect_1_16_7_canReflect.serialize(raw);
                    var sort = get_1(clone,"filter."+prop);
                    if(sort !== undefined) {
                        _delete(clone,"filter."+prop);
                        clone.sort = convertToJSONAPISort(sort);
                    }

                    return clone;
                },
                serialize: function(raw){
                    var clone = canReflect_1_16_7_canReflect.serialize(raw);
                    var sort = clone.sort;
                    if(sort !== undefined) {
                        delete clone.sort;
                        clone[prop] = convertToLegacySort(sort);
                    }
                    return clone;
                }
            };
        }
    }
};

function makeAlgebra(algebra) {
    if(!algebra) {
        return defaultAlgebra;
    }
    else if(!(algebra instanceof canQueryLogic_0_8_11_canQueryLogic) ) {
        return new set$4.Algebra(algebra);
    }
    return algebra;
}

function makeFromTwoQueries(prop) {
    set$4[prop] = function( a, b, algebra ){
        return makeAlgebra(algebra)[prop](a, b);
    };
}
makeFromTwoQueries("difference");
makeFromTwoQueries("union");
makeFromTwoQueries("intersection");
makeFromTwoQueries("isSubset");
makeFromTwoQueries("isEqual");
makeFromTwoQueries("isProperSubset");

set$4.count = function(query, algebra) {
    return makeAlgebra(algebra).count(query);
};

set$4.comparators = set$4.props;

defaultAlgebra = new set$4.Algebra();

var canSetLegacy_0_3_0_canSetLegacy = set$4;

// Core

export default canNamespace_1_0_0_canNamespace;
export { canDefine_2_3_5_canDefine as define, map$2 as DefineMap, list$1 as DefineList, canFixture_3_0_0Pre_11_fixture as fixture, canRestModel_0_1_4_canRestModel as restModel, canSuperModel_1_0_0_canSuperModel as superModel, canRealtimeRestModel_0_1_1_canRealtimeRestModel as realtimeRestModel, canQueryLogic_0_8_11_canQueryLogic as QueryLogic, canComponent_4_1_2_canComponent as Component, canStache_4_5_10_canStache as stache, canStacheBindings_4_2_5_canStacheBindings as stacheBindings, canStacheRouteHelpers_1_0_0_canStacheRouteHelpers as stacheRouteHelpers, canRoute_4_1_2_canRoute as route, canSimpleObservable_2_0_4_canSimpleObservable as SimpleObservable, canNamespace_1_0_0_canNamespace as can, canAssign_1_1_1_canAssign as assign, canAttributeEncoder_1_0_5_canAttributeEncoder as attributeEncoder, canAjax_1_1_4_canAjax as ajax, canGlobals_1_1_1_canGlobals as globals, canReflect_1_16_7_canReflect as Reflect, canDefineLazyValue_1_0_2_defineLazyValue as defineLazyValue, canDomEvents_1_2_0_canDomEvents as domEvents, canEventDomRadiochange_2_1_0_canEventDomRadiochange as radioChangeEvent, canEventDomEnter_2_1_2_canEventDomEnter as enterEvent, canValidateInterface_1_0_2_index as makeInterfaceValidator, canViewModel_4_0_1_canViewModel as viewModel, canObservation_4_0_1_canObservation as Observation, canKey_0_5_0_canKey as key, canDiff_1_0_4_canDiff as diff, canParseUri_1_1_0_canParseUri as parseURI, canStringToAny_1_0_1_canStringToAny as stringToAny, canViewCallbacks_4_1_2_canViewCallbacks as viewCallbacks, canQueues_1_1_0_canQueues as queues, canConnect_3_0_0Pre_14_all as connect, canMemoryStore_1_0_0_canMemoryStore as memoryStore, canLocalStore_1_0_0_canLocalStore as localStore, maybeBoolean as MaybeBoolean, maybeDate as MaybeDate, maybeNumber as MaybeNumber, maybeString as MaybeString, canConnectFeathers_5_0_0Pre_3_canConnectFeathers as connectFeathers, canDebug_1_2_1_canDebug as debug, canDefineBackup_2_0_0Pre_2_canDefineBackup as defineBackup, canDefineStream_1_0_1_canDefineStream as defineStream, canDefineStreamKefir_1_0_0_canDefineStreamKefir as defineStreamKefir, canDefineValidateValidatejs_1_0_1_canDefineValidateValidatejs as defineValidateValidatejs, canKefir_1_0_2_canKefir as kefir, canNdjsonStream_0_1_8_canNdjsonStream as ndjsonStream, canObserve_2_1_3_canObserve as observe, canStacheConverters_4_0_2_canStacheConverters as stacheConverters, canValidate_1_1_4_canValidate as validate, canValidateValidatejs_0_1_3_canValidateValidatejs as validateValidatejs, canStream_1_0_1_canStream as stream, canStreamKefir_1_0_1_canStreamKefir as streamKefir, zone as Zone, reactViewModel_1_0_0_reactViewModel as reactViewModel, canViewAutorender_5_0_0Pre_0_canViewAutorender as viewAutorender, canFixtureSocket_2_0_0Pre_1_canFixtureSocket as fixtureSocket, canConnectTag_1_0_0_canConnectTag as connectTag, canCompute_4_0_3_canCompute as compute, canMap_4_0_1_canMap as CanMap, canList_4_0_2_canList as CanList, canMapDefine_4_0_0_canMapDefine as canMapDefine, canSetLegacy_0_3_0_canSetLegacy as set };
