<link rel="stylesheet" type="text/css" href="./cc.css"/>
<div id="demo">
<div id='out'></div>

</div>

<script type='text/stache' id='demo-html'>
<form on:submit="pay(%event)">
  {{#if showCardError.value}}
   <div class="message">{{cardError.value}}</div>
  {{/if}}

  {{#if showExpiryError.value}}
     <div class="message">{{expiryError.value}}</div>
  {{/if}}

  {{#if showCVCError.value}}
     <div class="message">{{cvcError.value}}</div>
  {{/if}}

  <input type='text' name='number' placeholder='Card Number'
    {{#if showCardError.value}}class='is-error'{{/if}}
  	on:blur="userCardNumberFocused.value(false)"
  	on:input:value:to="userCardNumber.value"/>

  <input type='text' name='expiry' placeholder='MM-YY'
    {{#if showExpiryError.value}}class='is-error'{{/if}}
  	on:blur="userExpiryFocused.value(false)"
  	on:input:value:to="userExpiry.value"/>

  <input type='text' name='cvc' placeholder='CVC'
    {{#if showCVCError.value}}class='is-error'{{/if}}
  	on:blur="userCVCFocused.value(false)"
  	on:input:value:to="userCVC.value"/>

  <button disabled:from="disablePaymentButton.value">
  	{{#eq paymentStatus.value.status "pending"}}Paying{{else}}Pay{{/eq}} $1000
  </button>
</form>
</script>
<script src="../../node_modules/steal/steal-sans-promises.js" main="@empty">
var stache = require("can-stache");
require("can-stache-bindings");
var Kefir = require("can-kefir");

// INITIAL
var viewModel = {
	userCardNumber: Kefir.emitterProperty(),
	userCardNumberFocused: Kefir.emitterProperty(),

	userExpiry: Kefir.emitterProperty(),
	userExpiryFocused: Kefir.emitterProperty(),

	userCVC: Kefir.emitterProperty(),
	userCVCFocused: Kefir.emitterProperty(),

	payClicked: Kefir.emitterProperty(),

	pay: function(event) {
		event.preventDefault();
		this.payClicked.value(true)
	}
};

// DERIVED cardNumber values
viewModel.cardNumber = viewModel.userCardNumber.map(function(card) {
	if (card) {
		return card.replace(/[\s-]/g, "");
	}
});
viewModel.cardError = viewModel.cardNumber.map(validateCard).toProperty(); // weâ€™ll need this in the future
viewModel.showCardError = showOnlyWhenBlurredOnce(viewModel.cardError, viewModel.userCardNumberFocused);

// EXPIRY
viewModel.expiry = viewModel.userExpiry.map(function(expiry) {
	if (expiry) {
		return expiry.split("-")
	}
});
viewModel.expiryError = viewModel.expiry.map(validateExpiry).toProperty();
viewModel.showExpiryError = showOnlyWhenBlurredOnce(viewModel.expiryError, viewModel.userExpiryFocused);

// CVC
viewModel.cvc = viewModel.userCVC;
viewModel.cvcError = viewModel.cvc.map(validateCVC).toProperty();
viewModel.showCVCError = showOnlyWhenBlurredOnce(viewModel.cvcError, viewModel.userCVCFocused);

viewModel.isCardInvalid = Kefir.combine([viewModel.cardError, viewModel.expiryError, viewModel.cvcError],
	function(cardError, expiryError, cvcError) {
		return !!(cardError || expiryError || cvcError)
	});


// STREAM< Promise<Number> | undefined >
var paymentPromises = viewModel.payClicked.map((payClicked) => {
	if (payClicked) {
		return new Promise(function(resolve) {
			setTimeout(function() {
				resolve(1000);
			}, 2000);
		})
	}
});

var peoplePromise = Task.getList().then(function(){
	return Person.getList({...})
})

// STREAM< STREAM<STATUS> >
// This is a stream of streams of status objects.
var paymentStatusStream = paymentPromises.map((promise) => {
	if (promise) {
		// STREAM<STATUS>
		return Kefir.concat([
			Kefir.constant({
				status: "pending"
			}),
			Kefir.fromPromise(promise).map((value) => {
				return {
					status: "resolved",
					value: value
				};
			})
		]);
	} else {
		// STREAM
		return Kefir.constant({
			status: "waiting"
		});
	}
});

// STREAM<STATUS> //{status: "waiting"} | {status: "resolved"}
viewModel.paymentStatus = paymentStatusStream.flatMap().toProperty();

viewModel.disablePaymentButton = Kefir.combine([viewModel.isCardInvalid, viewModel.paymentStatus],
	function(isCardInvalid, paymentStatus) {
		return (isCardInvalid === true) || !paymentStatus || paymentStatus.status === "pending";
	}).toProperty(function() {
	return true;
});

//viewModel.paymentStatus.log("paymentStatus");

function validateCard(card) {
	if (!card) {
		return "There is no card"
	}
	if (card.length !== 16) {
		return "There should be 16 characters in a card";
	}
}

function validateExpiry(expiry) {
	if (!expiry) {
		return "There is no expiry. Format  MM-YY";
	}
	if (expiry.length !== 2 || expiry[0].length !== 2 || expiry[1].length !== 2) {
		return "Expirty must be formatted like MM-YY";
	}
}

function validateCVC(cvc) {
	if (!cvc) {
		return "There is no CVC code";
	}
	if (cvc.length !== 3) {
		return "The CVC must be at least 3 numbers";
	}
	if (isNaN(parseInt(cvc))) {
		return "The CVC must be numbers";
	}
}

function showOnlyWhenBlurredOnce(errorStream, focusedStream) {
	var errorEvent = errorStream.map((error) => {
		if (!error) {
			return {
				type: "valid"
			}
		} else {
			return {
				type: "invalid",
				message: error
			}
		}
	});

	var focusedEvents = focusedStream.map((isFocused) => {
		if (isFocused === undefined) {
			return {};
		}
		return isFocused ? {
			type: "focused"
		} : {
			type: "blurred"
		};
	});

	return Kefir.merge([errorEvent, focusedEvents])
		.scan((previous, event) => {
			switch (event.type) {
				case "valid":
					return Object.assign({}, previous, {
						isValid: true,
						showCardError: false
					});
				case "invalid":
					return Object.assign({}, previous, {
						isValid: false,
						showCardError: previous.hasBeenBlurred
					});
				case "blurred":
					return Object.assign({}, previous, {
						hasBeenBlurred: true,
						showCardError: !previous.isValid
					});
				default:
					return previous;
			}
		}, {
			hasBeenBlurred: false,
			showCardError: false,
			isValid: false
		}).map((state) => {
			return state.showCardError
		});
}

var template = stache.from("demo-html");

document.body.appendChild( template(viewModel) );
</script>
