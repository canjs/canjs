<link rel="stylesheet" type="text/css" href="./cc.css"/>
<div id="demo">
<div id='out'></div>

</div>

<script type='text/stache' id='app-view'>


  <form on:submit="pay(%event)">

    {{#if showCardError.value}}
	   <div class="message">{{cardError.value}}</div>
	{{/if}}
	{{#if showExpiryError.value}}
	   <div class="message">{{expiryError.value}}</div>
	{{/if}}
	{{#if showCVCError.value}}
	   <div class="message">{{cvcError.value}}</div>
	{{/if}}

	<input type='text' name='number' placeholder='Card Number'
        {{#if showCardError.value}}class='is-error'{{/if}}
		on:blur="userCardNumberFocused.value(false)"
		on:input:value:to="userCardNumber.value"/>

	<input type='text' name='expiry' placeholder='MM-YY'

        {{#if showExpiryError.value}}class='is-error'{{/if}}
		on:blur="userExpiryFocused.value(false)"
		on:input:value:to="userExpiry.value"/>

    <input type='text' name='cvc' placeholder='CVC'
        {{#if showCVCError.value}}class='is-error'{{/if}}
		on:blur="userCVCFocused.value(false)"
		on:input:value:to="userCVC.value"/>

	<button disabled:from="disablePaymentButton.value">
		{{#eq paymentStatus.value.status "pending"}}Paying{{else}}Pay{{/eq}} $1000
	</button>

  </form>


</script>
<script src="../../node_modules/steal/steal-sans-promises.js" main="@empty">
var stache = require("can-stache");
require("can-stache-bindings");
var Kefir = require("can-kefir");

// INITIAL
var viewModel = {
	userCardNumber: Kefir.emitterProperty(),
	userCardNumberFocused: Kefir.emitterProperty(),

	userExpiry: Kefir.emitterProperty(),
	userExpiryFocused: Kefir.emitterProperty(),

	userCVC: Kefir.emitterProperty(),
	userCVCFocused: Kefir.emitterProperty(),

	payClicked: Kefir.emitterProperty(),

	pay: function(event) {
		event.preventDefault();
		this.payClicked.value(true)
	}
};

// DERIVED cardNumber values
viewModel.cardNumber = viewModel.userCardNumber.map(function(card) {
	if (card) {
		return card.replace(/[\s-]/g, "");
	}
});
viewModel.cardError = viewModel.cardNumber.map(validateCard).toProperty(); // we'll need this in the future
viewModel.showCardError = showOnlyWhenBlurredOnce(viewModel.cardError, viewModel.userCardNumberFocused);

// EXPIRY
viewModel.expiry = viewModel.userExpiry.map(function(expiry) {
	if (expiry) {
		return expiry.split("-")
	}
});
viewModel.expiryError = viewModel.expiry.map(validateExpiry).toProperty();
viewModel.showExpiryError = showOnlyWhenBlurredOnce(viewModel.expiryError, viewModel.userExpiryFocused);

// CVC
viewModel.cvc = viewModel.userCVC;
viewModel.cvcError = viewModel.cvc.map(validateCVC).toProperty();
viewModel.showCVCError = showOnlyWhenBlurredOnce(viewModel.cvcError, viewModel.userCVCFocused);

viewModel.isCardInvalid = Kefir.combine([viewModel.cardError, viewModel.expiryError, viewModel.cvcError],
	function(cardError, expiryError, cvcError) {
		return !!(cardError || expiryError || cvcError)
	});


// STREAM< Promise<Number> | undefined >
var paymentPromises = viewModel.payClicked.map((payClicked) => {
	if (payClicked) {
		return new Promise(function(resolve) {
			setTimeout(function() {
				resolve(1000);
			}, 2000);
		})
	}
});

var peoplePromise = Task.getList().then(function(){
	return Person.getList({...})
})

// STREAM< STREAM<STATUS> >
// This is a stream of streams of status objects.
var paymentStatusStream = paymentPromises.map((promise) => {
	if (promise) {
		// STREAM<STATUS>
		return Kefir.concat([
			Kefir.constant({
				status: "pending"
			}),
			Kefir.fromPromise(promise).map((value) => {
				return {
					status: "resolved",
					value: value
				};
			})
		]);
	} else {
		// STREAM
		return Kefir.constant({
			status: "waiting"
		});
	}
});

// STREAM<STATUS> //{status: "waiting"} | {status: "resolved"}
viewModel.paymentStatus = paymentStatusStream.flatMap().toProperty();

viewModel.disablePaymentButton = Kefir.combine([viewModel.isCardInvalid, viewModel.paymentStatus],
	function(isCardInvalid, paymentStatus) {
		return (isCardInvalid === true) || !paymentStatus || paymentStatus.status === "pending";
	}).toProperty(function() {
	return true;
});

//viewModel.paymentStatus.log("paymentStatus");

function validateCard(card) {
	if (!card) {
		return "There is no card"
	}
	if (card.length !== 16) {
		return "There should be 16 characters in a card";
	}
}

function validateExpiry(expiry) {
	if (!expiry) {
		return "There is no expiry. Format  MM-YY";
	}
	if (expiry.length !== 2 || expiry[0].length !== 2 || expiry[1].length !== 2) {
		return "Expirty must be formatted like MM-YY";
	}
}

function validateCVC(cvc) {
	if (!cvc) {
		return "There is no CVC code";
	}
	if (cvc.length !== 3) {
		return "The CVC must be at least 3 numbers";
	}
	if (isNaN(parseInt(cvc))) {
		return "The CVC must be numbers";
	}
}

function showOnlyWhenBlurredOnce(errorStream, focusedStream) {
	var errorEvent = errorStream.map((error) => {
		if (!error) {
			return {
				type: "valid"
			}
		} else {
			return {
				type: "invalid",
				message: error
			}
		}
	});

	var focusedEvents = focusedStream.map((isFocused) => {
		if (isFocused === undefined) {
			return {};
		}
		return isFocused ? {
			type: "focused"
		} : {
			type: "blurred"
		};
	});

	return Kefir.merge([errorEvent, focusedEvents])
		.scan((previous, event) => {
			switch (event.type) {
				case "valid":
					return Object.assign({}, previous, {
						isValid: true,
						showCardError: false
					});
				case "invalid":
					return Object.assign({}, previous, {
						isValid: false,
						showCardError: previous.hasBeenBlurred
					});
				case "blurred":
					return Object.assign({}, previous, {
						hasBeenBlurred: true,
						showCardError: !previous.isValid
					});
				default:
					return previous;
			}
		}, {
			hasBeenBlurred: false,
			showCardError: false,
			isValid: false
		}).map((state) => {
			return state.showCardError
		});
}

var template = stache.from("app-view");

document.body.appendChild( template(viewModel) );
</script>
<script>
	DEMO_HTML = document.getElementById("demo").innerHTML
</script>
