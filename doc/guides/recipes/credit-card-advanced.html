<!DOCTYPE html>
<!--####################################################################
	THIS IS A GENERATED FILE — ANY CHANGES MADE WILL BE OVERWRITTEN

	INSTEAD CHANGE:
	source: docs/can-guides/commitment/recipes/credit-card-advanced/credit-card-advanced.md
	@page guides/recipes/credit-card-advanced
######################################################################## -->
<html lang="en">
<head>
	<meta charset="utf-8">
	<title>Credit Card | advanced recipes | Guides | CanJS — Build CRUD apps in fewer lines of code.</title>
	<meta name="description" content="This advanced guide walks through building a simple credit card payment form with validations. It doesn’t use can-define. Instead it uses Kefir.js streams to make a ViewModel. can-kefir is used to make the Kefir streams observable to can-stache.">
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
	<meta property="og:image" content="https://www.bitovi.com/hubfs/open-source/os-canjs.png">
	<meta property="og:description" content="This advanced guide walks through building a simple credit card payment form with validations. It doesn’t use can-define. Instead it uses Kefir.js streams to make a ViewModel. can-kefir is used to make the Kefir streams observable to can-stache.">
	<meta property="og:title" content="Credit Card | advanced recipes | Guides | CanJS — Build CRUD apps in fewer lines of code.">
	<script type="application/ld+json">
		{
			"@context": "http://www.schema.org",
			"@type": "SoftwareSourceCode",
			"applicationCategory": "DeveloperApplication",
			"brand": "Bitovi",
			"category": "JavaScript Frameworks",
			"codeRepository": "https://github.com/canjs/canjs",
			"description": "This advanced guide walks through building a simple credit card payment form with validations. It doesn’t use can-define. Instead it uses Kefir.js streams to make a ViewModel. can-kefir is used to make the Kefir streams observable to can-stache.",
			"image": "https://www.bitovi.com/hubfs/open-source/os-canjs.png",
			"license": "https://github.com/canjs/canjs/blob/master/license.md",
			"logo": "https://www.bitovi.com/hubfs/open-source/os-canjs.png",
			"name": "Credit Card | advanced recipes | Guides | CanJS — Build CRUD apps in fewer lines of code.",
			"programmingLanguage": "JavaScript",
			"softwareVersion" : "6.6.1"
		}
	</script>
	
		<link rel="stylesheet" type="text/css" href="../../static/bundles/bit-docs-site/static.css">
		<link rel="shortcut icon" sizes="16x16 24x24 32x32 48x48 64x64" href="/docs/images/canjs_favicon.ico">
		<link rel="apple-touch-icon" sizes="57x57" href="../../../docs/images/canjs_favicon_57x57.png">
		<link rel="apple-touch-icon-precomposed" sizes="57x57" href="../../../docs/images/canjs_favicon_57x57.png">
		<link rel="apple-touch-icon" sizes="72x72" href="../../../docs/images/canjs_favicon_72x72.png">
		<link rel="apple-touch-icon" sizes="114x114" href="../../../docs/images/canjs_favicon_114x114.png">
		<link rel="apple-touch-icon" sizes="120x120" href="../../../docs/images/canjs_favicon_128x128.png">
		<link rel="apple-touch-icon" sizes="144x144" href="../../../docs/images/canjs_favicon_144x144.png">
		<link rel="apple-touch-icon" sizes="152x152" href="../../../docs/images/canjs_favicon_152x152.png">
		<meta content="yes" name="apple-mobile-web-app-capable">
	  	<meta name="apple-mobile-web-app-status-bar-style" content="white-translucent">
	
	
		<script>
			(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
				(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
				m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
			})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

			ga('create', 'UA-2302003-11', 'auto');
			ga('send', 'pageview');
		</script>
	
</head>
	<body>
		<input type="checkbox" id="nav-trigger" class="nav-trigger"/>
	  	<div data-current-page="guides/recipes/credit-card-advanced" id="everything">
  <div class="header">
    
	<label for="nav-trigger">Menu</label>
	<div class="brand">
		<div class="logo">
			<a href="../../../index.html" alt="CanJS"></a>
			<div class="dropdown project-dropdown">
				<a href="https://donejs.com/">DoneJS</a>
				<a href="https://stealjs.com/">StealJS</a>
				<a href="https://jquerypp.com/">jQuery++</a>
				<a href="https://funcunit.com/">FuncUnit</a>
				<a href="https://documentjs.com/">DocumentJS</a>
			</div>
		</div>
		<div class="version">
			<div class="version-number">
				6.6.1
			</div>
			<div class="dropdown version-dropdown">
				
					<a href="https://v5.canjs.com">5.33.3</a>
				
					<a href="https://v4.canjs.com">4.3.0</a>
				
					<a href="https://v3.canjs.com">3.14.1</a>
				
					<a href="https://v2.canjs.com">2.3.35</a>
				
			</div>
		</div>
	</div>


	
	<ul class="top-right-links">
		
			
				
					<li class="">
						<a class="page"
							href="../../about.html"
							title="Learn about CanJS’s mission, technical highlights, who uses CanJS, and our future roadmap.">
							About
						</a>
					</li>
				
			
		
			
				
					<li class="current">
						<a class="page"
							href="../../guides.html"
							title="Welcome to CanJS! These guides are here to help you master CanJS development, get involved with the CanJS community, and contribute back to CanJS.">
							Guides
						</a>
					</li>
				
			
		
			
				
					<li class="">
						<a class="page"
							href="../../api.html"
							title="Welcome to the CanJS API documentation! This page is a CHEAT-SHEET for the most common APIs within CanJS. Read the technology-overview page for background on the following APIs.">
							API Docs
						</a>
					</li>
				
			
		
			
				
					<li class="">
						<a class="page"
							href="../../community.html"
							title="Get involved with one of the most inviting communities on the internet!">
							Community
						</a>
					</li>
				
			
		
			
				
					<li class="">
						<a class="page"
							href="../contribute.html"
							title="Learn how to contribute to CanJS!">
							Contributing
						</a>
					</li>
				
			
		
	</ul>



<div class="search-section">
	<div class="search-bar">
	<div class="search-wrap" style="display:none;">
		<span class="search-icon"></span>
		<input
			type="text"
			size="6"
			class="search"
			placeholder="Search"
			autocomplete="off"
			autocorrect="off"
			autocapitalize="none"
			spellcheck="false"/>
			<span class="search-icon-cancel"></span>
	</div>
</div>

	<div class="search-bar-container">
	</div>
	<div class="search-results-container">
	<div class="search-results-wrap"></div>
</div>

</div>
<ul class="top-right-bitovi">
	<li class="dropdown">
		<a href="https://www.bitovi.com" class="bitovi by-bitovi">Bitovi</a>
		<ul class="dropdown-menu">
			<li><a href="https://www.bitovi.com/">Bitovi.com</a></li>
			<li><a href="https://www.bitovi.com/blog">Blog</a></li>
			<li><a href="https://www.bitovi.com/design">Design</a></li>
			<li><a href="https://www.bitovi.com/development">Development</a></li>
			<li><a href="https://www.bitovi.com/training">Training</a></li>
			<li><a href="https://www.bitovi.com/open-source">Open Source</a></li>
			<li><a href="https://www.bitovi.com/about">About</a></li>
			<li><a href="https://www.bitovi.com/contact">Contact Us</a></li>
		</ul>
	</li>
</ul>

  </div>
  <div id="left" class="column">

      <div class="nav-menu">
        
            
	<ul>
		
			
				
					<li class="
           						
           						">
						<a class="page"
							href="../../about.html"
							title="Learn about CanJS’s mission, technical highlights, who uses CanJS, and our future roadmap.">
							About
						</a>
						

					</li>
				
			
		
			
				
					<li class="
           						parent
           						expanded">
						<a class="page"
							href="../../guides.html"
							title="Welcome to CanJS! These guides are here to help you master CanJS development, get involved with the CanJS community, and contribute back to CanJS.">
							Guides
						</a>
						
	<ul>
		
			
				
					<li>
						<span>getting started</span>
						
	<ul>
		
			
				
					<li class="
           						
           						">
						<a class="page"
							href="../crud-beginner.html"
							title="Learn how to build a basic CRUD app with CanJS in 30 minutes.">
							CRUD Guide
						</a>
						

					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="page"
							href="../setup.html"
							title="Learn how to install CanJS in your environment.">
							Setting Up CanJS
						</a>
						

					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="page"
							href="../technology-overview.html"
							title="Learn the basics of CanJS’s technology.">
							Technology Overview
						</a>
						

					</li>
				
			
		
	</ul>


					</li>
				
			
		
			
				
					<li>
						<span>topics</span>
						
	<ul>
		
			
				
					<li class="
           						
           						">
						<a class="page"
							href="../html.html"
							title="Learn how to update HTML and listen to user interactions.">
							HTML
						</a>
						

					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="page"
							href="../routing.html"
							title="Learn how to make your application respond to changes in the URL and work with the browser’s back and forward buttons.">
							Routing
						</a>
						

					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="page"
							href="../data.html"
							title="Learn how to use can-connect to integrate service layer APIs into your CanJS application.">
							Service Layer
						</a>
						

					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="page"
							href="../debugging.html"
							title="Learn how to debug CanJS applications.">
							Debugging
						</a>
						

					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="page"
							href="../forms.html"
							title="Learn how to create amazing &lt;form&gt;s with CanJS.">
							Forms
						</a>
						

					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="page"
							href="../testing.html"
							title="Learn how to test CanJS applications.">
							Testing
						</a>
						

					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="page"
							href="../logic.html"
							title="Learn how to write observables in an organized, maintainable, and testable way.">
							Logic
						</a>
						

					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="page"
							href="../server-side-rendering.html"
							title="Learn how to set up SSR for CanJS.">
							Server-Side Rendering
						</a>
						

					</li>
				
			
		
	</ul>


					</li>
				
			
		
			
				
					<li>
						<span>app guides</span>
						
	<ul>
		
			
				
					<li class="
           						
           						">
						<a class="page"
							href="../chat.html"
							title="This guide will walk you through building a real-time chat application with CanJS’s Core libraries.  It takes about 30 minutes to complete.">
							Chat Guide
						</a>
						

					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="page"
							href="../todomvc.html"
							title="This guide will walk you through building a slightly modified version of TodoMVC with CanJS’s Core libraries and can-fixture. It takes about 1 hour to complete.">
							TodoMVC Guide
						</a>
						

					</li>
				
			
		
			
		
			
				
					<li class="
           						
           						">
						<a class="page"
							href="todomvc-with-steal.html"
							title="This tutorial walks through building TodoMVC with StealJS. It includes KeyNote presentations covering CanJS core libraries.">
							TodoMVC with StealJS
						</a>
						

					</li>
				
			
		
	</ul>


					</li>
				
			
		
			
				
					<li>
						<span>beginner recipes</span>
						
	<ul>
		
			
				
					<li class="
           						
           						">
						<a class="page"
							href="canvas-clock.html"
							title="This beginner guide walks you through building a clock with the Canvas API.">
							Canvas Clock
						</a>
						

					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="page"
							href="credit-card-simple.html"
							title="This beginner guide walks through building a very simple credit card payment form.  It uses Stripe.js v2 API to create a token which can be used to create a charge.  It also performs simple validation on the payment form values.">
							Credit Card
						</a>
						

					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="page"
							href="file-navigator-simple.html"
							title="This beginner guide walks you through building a simple file navigation widget.  It takes about 25 minutes to complete.  It was written with CanJS 6.0.0. Check out the file-navigator-advanced for an example that makes AJAX requests for its data and uses can-stache-element.">
							File Navigator
						</a>
						

					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="page"
							href="signup-simple.html"
							title="This beginner guide walks through building simple signup, login forms and a logout button.">
							Signup and Login
						</a>
						

					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="page"
							href="video-player.html"
							title="This beginner guide walks you through building custom video controls around a video element.">
							Video Player
						</a>
						

					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="page"
							href="weather-report-simple.html"
							title="This beginner guide walks you through building a simple weather report widget.  It takes about 25 minutes to complete.  It was written with CanJS 6.2.">
							Weather Report
						</a>
						

					</li>
				
			
		
	</ul>


					</li>
				
			
		
			
				
					<li>
						<span>intermediate recipes</span>
						
	<ul>
		
			
				
					<li class="
           						
           						">
						<a class="page"
							href="cta-bus-map.html"
							title="This intermediate guide walks you through showing Chicago Transit Authority (CTA) bus locations on a Google Map. You&#x27;ll learn how to create a StacheElement that integrates with 3rd party widgets.">
							CTA Bus Map
						</a>
						

					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="page"
							href="modals.html"
							title="This intermediate guide shows how to create a multiple modal form.">
							Multiple Modals
						</a>
						

					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="page"
							href="text-editor.html"
							title="This intermediate guide walks you through building a basic rich text editor.">
							Text Editor
						</a>
						

					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="page"
							href="tinder-carousel.html"
							title="This intermediate guide walks you through building a Tinder-like carousel. Learn how to build apps that use dragging user interactions.">
							Tinder Carousel
						</a>
						

					</li>
				
			
		
	</ul>


					</li>
				
			
		
			
				
					<li>
						<span>advanced recipes</span>
						
	<ul>
		
			
				
					<li class="current
           						
           						expanded">
						<a class="page"
							href="credit-card-advanced.html"
							title="This advanced guide walks through building a simple credit card payment form with validations. It doesn’t use can-define. Instead it uses Kefir.js streams to make a ViewModel. can-kefir is used to make the Kefir streams observable to can-stache.">
							Credit Card
						</a>
						

					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="page"
							href="file-navigator-advanced.html"
							title="This advanced guide walks you through building a file navigation widget that requests data with fetch. It takes about 45 minutes to complete.">
							File Navigator
						</a>
						

					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="page"
							href="playlist-editor.html"
							title="Learn how to use YouTube’s API to search for videos and make a playlist.  This makes authenticated requests with OAuth2. It uses jQuery++ for drag/drop events. It shows using custom attributes and custom events.  This advanced guide takes an hour to complete.  This recipe uses YouTube API Services and follows YouTube Terms of Service and Google Privacy Policy">
							Playlist Editor
						</a>
						

					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="page"
							href="search-list-details.html"
							title="This advanced guide walks through building a Search, List, Details flow with lazy-loaded routes.">
							Search, List, Details
						</a>
						

					</li>
				
			
		
			
		
	</ul>


					</li>
				
			
		
			
				
					<li>
						<span>upgrade</span>
						
	<ul>
		
			
				
					<li class="
           						
           						">
						<a class="page"
							href="../../migrate-3.html"
							title="This guide walks you through the step-by-step process to upgrade a 2.x app to CanJS 3.">
							Migrating to CanJS 3
						</a>
						

					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="page"
							href="../../migrate-4.html"
							title="This guide walks you through the step-by-step process to upgrade a 3.x app to CanJS 4.">
							Migrating to CanJS 4
						</a>
						

					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="page"
							href="../../migrate-5.html"
							title="This guide walks you through the process to upgrade a 4.x app to CanJS 5.x.">
							Migrating to CanJS 5
						</a>
						

					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="page"
							href="../../migrate-6.html"
							title="This guide walks you through the process to upgrade a 5.x app to CanJS 6.x.">
							Migrating to CanJS 6
						</a>
						

					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="page"
							href="../upgrade/using-codemods.html"
							title="Learn how to migrate your app to CanJS 6 using can-migrate.">
							Using Codemods
						</a>
						

					</li>
				
			
		
	</ul>


					</li>
				
			
		
			
				
					<li>
						<span>other</span>
						
	<ul>
		
			
				
					<li class="
           						
           						">
						<a class="page"
							href="../api.html"
							title="This page walks through how to use and understand CanJS’s API documentation.">
							Reading the API Docs
						</a>
						

					</li>
				
			
		
	</ul>


					</li>
				
			
		
	</ul>


					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="page"
							href="../../api.html"
							title="Welcome to the CanJS API documentation! This page is a CHEAT-SHEET for the most common APIs within CanJS. Read the technology-overview page for background on the following APIs.">
							API Docs
						</a>
						

					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="page"
							href="../../community.html"
							title="Get involved with one of the most inviting communities on the internet!">
							Community
						</a>
						

					</li>
				
			
		
			
				
					<li class="
           						
           						">
						<a class="page"
							href="../contribute.html"
							title="Learn how to contribute to CanJS!">
							Contributing
						</a>
						

					</li>
				
			
		
	</ul>


        
      </div>
      <div class="social-side-container">
        <ul class="social-side">
  <li>
    <a class="header-mobile github" href="https://github.com/canjs/canjs" target="_blank"><img class="social-icon-small" src="../../../docs/images/github.png">GitHub</a>
  </li>
  <li>
    <a class="header-mobile twitter" href="https://twitter.com/canjs" target="_blank"><img class="social-icon-small" src="../../../docs/images/twitter.png">Twitter</a>
  </li>
</ul>
<ul class="social-side">
  <li>
    <a class="header-mobile" href="https://www.bitovi.com/community/slack" target="_blank">Chat</a>
  </li>
  <li>
    <a class="header-mobile" href="https://forums.bitovi.com/c/canjs" target="_blank">Forum</a>
  </li>
</ul>
<ul class="social-side">
  <li>
    <a class="header-mobile" href="https://www.bitovi.com/blog/topic/canjs" target="_blank">News</a>
  </li>
  <li></li>
</ul>

      </div>
      <div class="by-bitovi-container">
        <a href="https://www.bitovi.com" target="_blank" class="bitovi by-bitovi">Bitovi</a>
      </div>

  </div>
  <div id="right" class="column">

      <article>
  <section class="title">
	<div class="page-type">
		<h1>Credit Card</h1>
			<ul class="title-social">
				
				
				<li>
					<a class="button-link" href="//github.com/canjs/canjs/edit/master/docs/can-guides/commitment/recipes/credit-card-advanced/credit-card-advanced.md">Edit on GitHub</a>
				</li>
				
			</ul>
	</div>
	<div class="clear-both"></div>
	
  
	<section class="description">
    <p>This advanced guide walks through building a simple credit card payment form with validations. It doesn’t use
<a href="../../can-define.html" title="Defines observable properties and their behavior on a prototype object. This function is not commonly used directly. map
and list are more commonly used. Types and
behaviors shared by both map
and list are documented here.">can-define</a>. Instead it uses <code>Kefir.js</code> streams to make a ViewModel.
<a href="../../can-kefir.html" title="Integrate KefirJS streams directly within can-stache and other parts of CanJS.">can-kefir</a> is used to make the Kefir streams observable to <a href="../../can-stache.html" title="Live binding templates.">can-stache</a>.</p>

</section>

  
	
</section>
<section class="on-this-page-table">
	<!--<h2 class="on-this-page-title" data-skip>Page Content</h2>-->
</section>










  
    <section class="body">
    <p>In this guide, you will learn how to:</p>
<ul>
<li>Use Kefir streams.</li>
<li>Use the event-reducer pattern.</li>
<li>Handle promises (and side-effects) with streams.</li>
</ul>
<p>The final widget looks like:</p>
<p class="codepen" data-height="416" data-theme-id="0" data-default-tab="result" data-user="bitovi" data-slug-hash="QWLKWQB" style="height: 416px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid black; margin: 1em 0; padding: 1em;" data-pen-title="Credit Card Guide (Advanced)">
  <span>See the Pen <a href="https://codepen.io/bitovi/pen/QWLKWQB/">
  Credit Card Guide (Advanced)</a> by Bitovi (<a href="https://codepen.io/bitovi">@bitovi</a>)
  on <a href="https://codepen.io">CodePen</a>.</span>
</p>
<p>To use the widget:</p>
<ol>
<li><strong>Enter</strong> a <em>Card Number</em>, <em>Expiration Date</em>, and <em>CVC</em>.</li>
<li><strong>Click</strong> on the form so those inputs lose focus.  The
<em>Pay</em> button should become enabled.</li>
<li><strong>Click</strong> the <em>Pay</em> button to see the <strong>Pay</strong> button disabled for 2 seconds.</li>
<li><strong>Change</strong> the inputs to invalid values.  An error message should appear,
the invalid inputs should be highlighted red, and the <em>Pay</em>
button should become disabled.</li>
</ol>
<p><strong>START THIS TUTORIAL BY CLICKING THE “EDIT ON CODEPEN” BUTTON IN THE TOP RIGHT CORNER OF THE FOLLOWING EMBED:</strong>:</p>
<p class="codepen" data-height="164" data-theme-id="0" data-default-tab="result" data-user="bitovi" data-slug-hash="qwqVKp" style="height: 164px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid black; margin: 1em 0; padding: 1em;" data-pen-title="Credit Card Guide (Starter)">
  <span>See the Pen <a href="https://codepen.io/bitovi/pen/qwqVKp/">
  Credit Card Guide (Starter)</a> by Bitovi (<a href="https://codepen.io/bitovi">@bitovi</a>)
  on <a href="https://codepen.io">CodePen</a>.</span>
</p>
<p>This CodePen has initial prototype HTML and CSS which is useful for
getting the application to look right.</p>
<p>The following sections are broken down into:</p>
<ul>
<li><strong>The problem</strong> — A description of what the section is trying to accomplish.</li>
<li><strong>What you need to know</strong> — Information about CanJS that is useful for solving the problem.</li>
<li><strong>The solution</strong> — The solution to the problem.</li>
</ul>
<p>The following video walks through the entire guide; it was recorded for CanJS 3,
but most of the same basic info applies:</p>
<iframe width="560" height="315" src="https://www.youtube.com/embed/UA4606-W3Sg" frameborder="0" allowfullscreen></iframe>
<h2>Setup</h2>
<h3>The problem</h3>
<p>We are going to try an alternate form of the basic CanJS setup.  We
will have an <a href="../../can-stache-element.html" title="Create a custom element with ObservableObject-like properties and stache views.">StacheElement</a> with <code>cc-payment</code> as a custom tag.
The component properties are all <a href="https://kefirjs.github.io/kefir/">Kefir.js</a>
streams.</p>
<p>We will render the static content in the component view, but use a
constant stream to hold the <code>amount</code> value.</p>
<h3>What you need to know</h3>
<ul>
<li><p><a href="https://kefirjs.github.io/kefir/">Kefir.js</a> allows you to create streams
of events and transform those streams into other streams. For example,
the following <code>numbers</code> stream produces three numbers with interval of 100 milliseconds:</p>
<pre><code class="language-js">const numbers = Kefir.sequentially(100, [1, 2, 3]);
</code></pre>
<p>Now let’s create another stream based on the first one. As you might guess,
it will produce 2, 4, and 6.</p>
<pre><code class="language-js">const numbers2 = numbers.map(x =&gt; x * 2);
</code></pre></li>
<li><p>Kefir supports both streams and properties.  It’s worth reading <a href="https://kefirjs.github.io/kefir/#about-observables">Kefir’s documentation on the difference between streams and properties</a>.  In short:</p>
<ul>
<li>Properties retain their value</li>
<li>Streams do not</li>
</ul></li>
<li><p><a href="https://kefirjs.github.io/kefir/#constant">Kefir.constant</a> creates a property with the specified value:</p>
<pre><code class="language-js">const property = Kefir.constant(1);
</code></pre></li>
<li><p><a href="../../can-kefir.html" title="Integrate KefirJS streams directly within can-stache and other parts of CanJS.">can-kefir</a> integrates streams into CanJS, including <a href="../../can-stache.html" title="Live binding templates.">can-stache</a>
templates.  Output the value of a stream like:</p>
<pre><code>{{ stream.value }}
</code></pre>
<p>Or the error like:</p>
<pre><code>{{ stream.error }}
</code></pre></li>
</ul>
<h3>The solution</h3>
<p>Update the <strong>HTML</strong> tab to:</p>
<pre><code class="language-html">&lt;cc-payment&gt;&lt;/cc-payment&gt;

</code></pre>
<div line-highlight='1'></div>
<p>Update the <strong>JavaScript</strong> tab to:</p>
<pre><code class="language-js">import { kefir as Kefir, StacheElement } from &quot;//unpkg.com/can@6/ecosystem.mjs&quot;;

class CCPayment extends StacheElement {
  static view = `
    &lt;form&gt;
      &lt;input type=&quot;text&quot; name=&quot;number&quot; placeholder=&quot;Card Number&quot;&gt;

      &lt;input type=&quot;text&quot; name=&quot;expiry&quot; placeholder=&quot;MM-YY&quot;&gt;

      &lt;input type=&quot;text&quot; name=&quot;cvc&quot; placeholder=&quot;CVC&quot;&gt;

      &lt;button&gt;Pay \${{ this.amount.value }}&lt;/button&gt;
    &lt;/form&gt;
  `;

  static props = {
    amount: {
      get default() {
        return Kefir.constant(1000);
      }
    }
  };
}

customElements.define(&quot;cc-payment&quot;, CCPayment);

</code></pre>
<div line-highlight='1-25,only'></div>
<h2>Read the card number</h2>
<h3>The problem</h3>
<p>Users will be able to enter a card number like <code>1234-1234-1234-1234</code>.</p>
<p>Let’s read the card number entered by the user, print it back,
and also print back the cleaned card number (the entered number with no dashes).</p>
<h3>What you need to know</h3>
<ul>
<li><p><a href="../../can-kefir.html" title="Integrate KefirJS streams directly within can-stache and other parts of CanJS.">can-kefir</a> adds an <a href="../../can-kefir/emitterProperty.html" title=".emitterProperty()">emitterProperty</a> method that returns a
Kefir property, but also adds an <code>emitter</code> object with with <code>.value()</code> and <code>.error()</code> methods. The end result is a single object that has methods of a stream and property access to its emitter methods.</p>
<pre><code class="language-js">import { kefir as Kefir } from &quot;//unpkg.com/can@6/ecosystem.mjs&quot;;

const age = Kefir.emitterProperty();

age.onValue(function(age) {
  console.log(age)
});

age.emitter.value(20) //-&gt; logs 20

age.emitter.value(30) //-&gt; logs 30
</code></pre>
<p><code>emitterProperty</code> property streams are useful data sinks when getting
user data.</p></li>
<li><p>Kefir streams and properties have a <a href="https://kefirjs.github.io/kefir/#map">map</a> method
that maps values on one stream to values in a new stream:</p>
<pre><code class="language-js">const source = Kefir.sequentially(100, [1, 2, 3]);
const result = source.map(x =&gt; x + 1);
// source: ---1---2---3X
// result: ---2---3---4X
</code></pre></li>
<li><p><code>&lt;input on:input:value:to=&quot;KEY&quot;/&gt;</code> Listens to the <code>input</code> events produced
by the <code>&lt;input&gt;</code> element and writes the <code>&lt;input&gt;</code>’s value to <code>KEY</code>.</p></li>
<li><p><a href="../../can-kefir.html" title="Integrate KefirJS streams directly within can-stache and other parts of CanJS.">can-kefir</a> allows you to write to a <code>emitterProperty</code>’s with:</p>
<pre><code class="language-html">&lt;input value:to=&quot;emitterProperty.value&quot;&gt;
</code></pre></li>
</ul>
<h3>The solution</h3>
<p>Update the <strong>JavaScript</strong> tab to:</p>
<pre><code class="language-js">import { kefir as Kefir, StacheElement } from &quot;//unpkg.com/can@6/ecosystem.mjs&quot;;

class CCPayment extends StacheElement {
  static view = `
    &lt;form&gt;
      User Entered: {{ this.userCardNumber.value }},
      Card Number: {{ this.cardNumber.value }}

      &lt;input type=&quot;text&quot; name=&quot;number&quot; placeholder=&quot;Card Number&quot;
          on:input:value:to=&quot;this.userCardNumber.value&quot;&gt;

      &lt;input type=&quot;text&quot; name=&quot;expiry&quot; placeholder=&quot;MM-YY&quot;&gt;

      &lt;input type=&quot;text&quot; name=&quot;cvc&quot; placeholder=&quot;CVC&quot;&gt;

      &lt;button&gt;Pay \${{ this.amount.value }}&lt;/button&gt;
    &lt;/form&gt;
  `;

  static props = {
    amount: {
      get default() {
        return Kefir.constant(1000);
      }
    },

    userCardNumber: {
      get default() {
        return Kefir.emitterProperty();
      }
    },

    get cardNumber() {
      return this.userCardNumber.map(card =&gt; {
        if (card) {
          return card.replace(/[\s-]/g, &quot;&quot;);
        }
      });
    }
  };
}

customElements.define(&quot;cc-payment&quot;, CCPayment);

</code></pre>
<div line-highlight='6-7,10,27-40,only'></div>
<h2>Output the card error</h2>
<h3>The problem</h3>
<p>As someone types a card number, let’s show the user a warning message
about what they need to enter for the card number. It should go away
if the card number is 16 characters.</p>
<h3>What you need to know</h3>
<ul>
<li><p>Add the <code>cardError</code> message above the input like:</p>
<pre><code class="language-html">&lt;div class=&quot;message&quot;&gt;{{cardError.value}}&lt;/div&gt;
</code></pre></li>
<li><p>Validate a card with:</p>
<pre><code class="language-js">function validateCard(card) {
  if (!card) {
    return &quot;There is no card&quot;
  }
  if (card.length !== 16) {
    return &quot;There should be 16 characters in a card&quot;;
  }
}
</code></pre></li>
</ul>
<h3>The solution</h3>
<p>Update the <strong>JavaScript</strong> tab to:</p>
<pre><code class="language-js">import { kefir as Kefir, StacheElement } from &quot;//unpkg.com/can@6/ecosystem.mjs&quot;;

class CCPayment extends StacheElement {
  static view = `
    &lt;form&gt;
      &lt;div class=&quot;message&quot;&gt;{{ this.cardError.value }}&lt;/div&gt;

      &lt;input type=&quot;text&quot; name=&quot;number&quot; placeholder=&quot;Card Number&quot;
          on:input:value:to=&quot;this.userCardNumber.value&quot;&gt;
  
      &lt;input type=&quot;text&quot; name=&quot;expiry&quot; placeholder=&quot;MM-YY&quot;&gt;
  
      &lt;input type=&quot;text&quot; name=&quot;cvc&quot; placeholder=&quot;CVC&quot;&gt;
  
      &lt;button&gt;Pay \${{ this.amount.value }}&lt;/button&gt;
    &lt;/form&gt;
  `;

  static props = {
    amount: {
      get default() {
        return Kefir.constant(1000);
      }
    },

    userCardNumber: {
      get default() {
        return Kefir.emitterProperty();
      }
    },

    get cardNumber() {
      return this.userCardNumber.map(card =&gt; {
        if (card) {
          return card.replace(/[\s-]/g, &quot;&quot;);
        }
      });
    },

    get cardError() {
      return this.cardNumber.map(this.validateCard);
    }
  };

  validateCard(card) {
    if (!card) {
      return &quot;There is no card&quot;;
    }
    if (card.length !== 16) {
      return &quot;There should be 16 characters in a card&quot;;
    }
  }
}

customElements.define(&quot;cc-payment&quot;, CCPayment);

</code></pre>
<div line-highlight='6,40-42,45-52,only'></div>
<h2>Only show the card error when blurred</h2>
<h3>The problem</h3>
<p>Let’s only show the cardNumber error if the user blurs the
card number input. Once the user blurs, we will update the card number error,
if there is one, on every keystroke.</p>
<p>We should also add <code>class=&quot;is-error&quot;</code> to the input when it has an error.</p>
<p>For this to work, we will need to track if the user has blurred
the input in a <code>userCardNumberBlurred</code> <code>emitterProperty</code>.</p>
<h3>What you need to know</h3>
<ul>
<li><p>We can call an <code>emitterProperty</code>’s value in the template when something happens like:</p>
<pre><code class="language-html">&lt;div on:click=&quot;emitterProperty.emitter.value(true)&quot;&gt;
</code></pre></li>
<li><p>One of the most useful patterns in constructing streams is the event-reducer
pattern. On a high-level it involves making streams events, and using those
events to update a stateful object.</p>
<p>For example, we might have a <code>first</code> and a <code>last</code> stream:</p>
<pre><code class="language-js">const first = Kefir.sequentially(100, [&quot;Justin&quot;, &quot;Ramiya&quot;])
const last = Kefir.sequentially(100, [&quot;Shah&quot;, &quot;Meyer&quot;]).delay(50);
// first: ---Justin---RamiyaX
// last:  ------Shah__---Meyer_X
</code></pre>
<p>We can promote these to event-like objects with <code>.map</code>:</p>
<pre><code class="language-js">const firstEvents = first.map(first =&gt; {
  return { type: &quot;first&quot;, value: first };
});
const lastEvents = first.map(last =&gt; {
  return { type: &quot;last&quot;, value: last };
});
// firstEvents: ---{t:&quot;f&quot;}---{t:&quot;f&quot;}X
// lastEvents:  ------{t:&quot;l&quot;}---{t:&quot;l&quot;}X
</code></pre>
<p>Next, we can merge these into a single stream:</p>
<pre><code class="language-js">const merged = Kefir.merge([firstEvents,lastEvents])
// merged: ---{t:&quot;f&quot;}-{t:&quot;l&quot;}-{t:&quot;f&quot;}-{t:&quot;l&quot;}X
</code></pre>
<p>We can &quot;reduce&quot; (or <code>.scan</code>) these events based on a previous
state. The following copies the old state and updates it using the event
data:</p>
<pre><code class="language-js">const state = merged.scan(
  (previous, event) =&gt; {
    const copy = Object.assign({}, previous);
    copy[event.type] = event.value;
    return copy;
  },
  { first: &quot;&quot;, last: &quot;&quot; }
);
// state: ---{first:&quot;Justin&quot;, last:&quot;&quot;}
//          -{first:&quot;Justin&quot;, last:&quot;Shah&quot;}
//          -{first:&quot;Ramiya&quot;, last:&quot;Shah&quot;}
//          -{first:&quot;Ramiya&quot;, last:&quot;Meyer&quot;}X
</code></pre>
<p>The following is a more common structure for the reducer pattern:</p>
<pre><code class="language-js">const state = merged.scan(
  (previous, event) =&gt; {
    switch (event.type) {
      case &quot;first&quot;:
        return Object.assign({}, previous, {
          first: event.value
        });
      case &quot;last&quot;:
        return Object.assign({}, previous, {
          last: event.value
        });
      default:
        return previous;
    }
  },
  { first: &quot;&quot;, last: &quot;&quot; }
);
</code></pre>
<p>Finally, we can map this state to another value:</p>
<pre><code class="language-js">const fullName = state.map(state =&gt; state.first + &quot; &quot; + state.last);
// fullName: ---Justin
//             -Justin Shah
//             -Ramiya Shah
//             -Ramiya MeyerX
</code></pre>
<blockquote>
<p><strong>Note:</strong> <code>fullName</code> can be derived more simply from <code>Kefir.combine</code>. The reducer
pattern is used here for illustrative purposes. It is able to support a larger
set of stream transformations than <code>Kefir.combine</code>.</p>
</blockquote></li>
<li><p>On any stream, you can call <code>stream.toProperty()</code> to return a property that
will retain its values. This can be useful if you want a stream’s immediate value.</p></li>
</ul>
<h3>The solution</h3>
<p>Update the <strong>JavaScript</strong> tab to:</p>
<pre><code class="language-js">import { kefir as Kefir, StacheElement } from &quot;//unpkg.com/can@6/ecosystem.mjs&quot;;

class CCPayment extends StacheElement {
  static view = `
    &lt;form&gt;
      {{# if(this.showCardError.value) }}
        &lt;div class=&quot;message&quot;&gt;{{ this.cardError.value }}&lt;/div&gt;
      {{/ if }}

      &lt;input type=&quot;text&quot; name=&quot;number&quot; placeholder=&quot;Card Number&quot;
          on:input:value:to=&quot;this.userCardNumber.value&quot;
          on:blur=&quot;this.userCardNumberBlurred.emitter.value(true)&quot;
          {{# if(this.showCardError.value) }}class=&quot;is-error&quot;{{/ if }}&gt;

      &lt;input type=&quot;text&quot; name=&quot;expiry&quot; placeholder=&quot;MM-YY&quot;&gt;

      &lt;input type=&quot;text&quot; name=&quot;cvc&quot; placeholder=&quot;CVC&quot;&gt;

      &lt;button&gt;Pay \${{ this.amount.value }}&lt;/button&gt;
    &lt;/form&gt;
  `;

  static props = {
    amount: {
      get default() {
        return Kefir.constant(1000);
      }
    },

    userCardNumber: {
      get default() {
        return Kefir.emitterProperty();
      }
    },

    userCardNumberBlurred: {
      get default() {
        return Kefir.emitterProperty();
      }
    },

    get cardNumber() {
      return this.userCardNumber.map(card =&gt; {
        if (card) {
          return card.replace(/[\s-]/g, &quot;&quot;);
        }
      });
    },

    get cardError() {
      return this.cardNumber.map(this.validateCard);
    },

    get showCardError() {
      return this.showOnlyWhenBlurredOnce(
        this.cardError,
        this.userCardNumberBlurred
      );
    }
  };

  validateCard(card) {
    if (!card) {
      return &quot;There is no card&quot;;
    }
    if (card.length !== 16) {
      return &quot;There should be 16 characters in a card&quot;;
    }
  }

  showOnlyWhenBlurredOnce(errorStream, blurredStream) {
    const errorEvent = errorStream.map(error =&gt; {
      if (!error) {
        return {
          type: &quot;valid&quot;
        };
      } else {
        return {
          type: &quot;invalid&quot;,
          message: error
        };
      }
    });

    const focusEvents = blurredStream.map(isBlurred =&gt; {
      if (isBlurred === undefined) {
        return {};
      }
      return isBlurred
        ? {
            type: &quot;blurred&quot;
          }
        : {
            type: &quot;focused&quot;
          };
    });

    return Kefir.merge([errorEvent, focusEvents])
      .scan(
        (previous, event) =&gt; {
          switch (event.type) {
            case &quot;valid&quot;:
              return Object.assign({}, previous, {
                isValid: true,
                showCardError: false
              });
            case &quot;invalid&quot;:
              return Object.assign({}, previous, {
                isValid: false,
                showCardError: previous.hasBeenBlurred
              });
            case &quot;blurred&quot;:
              return Object.assign({}, previous, {
                hasBeenBlurred: true,
                showCardError: !previous.isValid
              });
            default:
              return previous;
          }
        },
        {
          hasBeenBlurred: false,
          showCardError: false,
          isValid: false
        }
      )
      .map(state =&gt; {
        return state.showCardError;
      });
  }
}

customElements.define(&quot;cc-payment&quot;, CCPayment);

</code></pre>
<div line-highlight='6-8,12-13,36-40,50-60,71-130,only'></div>
<h2>Read, validate, and show the error of the expiry</h2>
<h3>The problem</h3>
<p>Let’s make the <code>expiry</code> input element just like the <code>cardNumber</code>
element.  The expiry should be entered like <code>12-17</code> and be stored as an
array like <code>[&quot;12&quot;, &quot;16&quot;]</code>.  Make sure to:</p>
<ul>
<li>validate the expiry</li>
<li>show a warning validation message in a <code>&lt;div class=&quot;message&quot;&gt;</code> element</li>
<li>add <code>class=&quot;is-error&quot;</code> to the element if we should show the <code>expiry</code> error.</li>
</ul>
<h3>What you need to know</h3>
<ul>
<li>Use <code>expiry.split(&quot;-&quot;)</code> to convert what a user typed into an array of numbers.</li>
<li>To validate the expiry use:
<pre><code class="language-js">function validateExpiry(expiry) {
  if (!expiry) {
    return &quot;There is no expiry. Format  MM-YY&quot;;
  }
  if (expiry.length !== 2 || expiry[0].length !== 2 || expiry[1].length !== 2) {
    return &quot;Expiry must be formatted like MM-YY&quot;;
  }
}
</code></pre></li>
</ul>
<h3>The solution</h3>
<p>Update the <strong>JavaScript</strong> tab to:</p>
<pre><code class="language-js">import { kefir as Kefir, StacheElement } from &quot;//unpkg.com/can@6/ecosystem.mjs&quot;;

class CCPayment extends StacheElement {
  static view = `
    &lt;form&gt;
      {{# if(this.showCardError.value) }}
        &lt;div class=&quot;message&quot;&gt;{{ this.cardError.value }}&lt;/div&gt;
      {{/ if }}

      {{# if(this.showExpiryError.value) }}
        &lt;div class=&quot;message&quot;&gt;{{ this.expiryError.value }}&lt;/div&gt;
      {{/ if }}

      &lt;input type=&quot;text&quot; name=&quot;number&quot; placeholder=&quot;Card Number&quot;
          on:input:value:to=&quot;this.userCardNumber.value&quot;
          on:blur=&quot;this.userCardNumberBlurred.emitter.value(true)&quot;
          {{# if(this.showCardError.value) }}class=&quot;is-error&quot;{{/ if }}&gt;

      &lt;input type=&quot;text&quot; name=&quot;expiry&quot; placeholder=&quot;MM-YY&quot;
          on:input:value:to=&quot;this.userExpiry.value&quot;
          on:blur=&quot;this.userExpiryBlurred.emitter.value(true)&quot;
          {{# if(this.showExpiryError.value) }}class=&quot;is-error&quot;{{/ if }}&gt;

      &lt;input type=&quot;text&quot; name=&quot;cvc&quot; placeholder=&quot;CVC&quot;&gt;

      &lt;button&gt;Pay \${{ this.amount.value }}&lt;/button&gt;
    &lt;/form&gt;
  `;

  static props = {
    amount: {
      get default() {
        return Kefir.constant(1000);
      }
    },

    userCardNumber: {
      get default() {
        return Kefir.emitterProperty();
      }
    },

    userCardNumberBlurred: {
      get default() {
        return Kefir.emitterProperty();
      }
    },

    userExpiry: {
      get default() {
        return Kefir.emitterProperty();
      }
    },

    userExpiryBlurred: {
      get default() {
        return Kefir.emitterProperty();
      }
    },

    get cardNumber() {
      return this.userCardNumber.map(card =&gt; {
        if (card) {
          return card.replace(/[\s-]/g, &quot;&quot;);
        }
      });
    },

    get cardError() {
      return this.cardNumber.map(this.validateCard);
    },

    get showCardError() {
      return this.showOnlyWhenBlurredOnce(
        this.cardError,
        this.userCardNumberBlurred
      );
    },

    // EXPIRY
    get expiry() {
      return this.userExpiry.map(expiry =&gt; {
        if (expiry) {
          return expiry.split(&quot;-&quot;);
        }
      });
    },

    get expiryError() {
      return this.expiry.map(this.validateExpiry).toProperty();
    },

    get showExpiryError() {
      return this.showOnlyWhenBlurredOnce(
        this.expiryError,
        this.userExpiryBlurred
      );
    }
  };

  validateCard(card) {
    if (!card) {
      return &quot;There is no card&quot;;
    }
    if (card.length !== 16) {
      return &quot;There should be 16 characters in a card&quot;;
    }
  }

  validateExpiry(expiry) {
    if (!expiry) {
      return &quot;There is no expiry. Format  MM-YY&quot;;
    }
    if (
      expiry.length !== 2 ||
      expiry[0].length !== 2 ||
      expiry[1].length !== 2
    ) {
      return &quot;Expiry must be formatted like MM-YY&quot;;
    }
  }

  showOnlyWhenBlurredOnce(errorStream, blurredStream) {
    const errorEvent = errorStream.map(error =&gt; {
      if (!error) {
        return {
          type: &quot;valid&quot;
        };
      } else {
        return {
          type: &quot;invalid&quot;,
          message: error
        };
      }
    });

    const focusEvents = blurredStream.map(isBlurred =&gt; {
      if (isBlurred === undefined) {
        return {};
      }
      return isBlurred
        ? {
            type: &quot;blurred&quot;
          }
        : {
            type: &quot;focused&quot;
          };
    });

    return Kefir.merge([errorEvent, focusEvents])
      .scan(
        (previous, event) =&gt; {
          switch (event.type) {
            case &quot;valid&quot;:
              return Object.assign({}, previous, {
                isValid: true,
                showCardError: false
              });
            case &quot;invalid&quot;:
              return Object.assign({}, previous, {
                isValid: false,
                showCardError: previous.hasBeenBlurred
              });
            case &quot;blurred&quot;:
              return Object.assign({}, previous, {
                hasBeenBlurred: true,
                showCardError: !previous.isValid
              });
            default:
              return previous;
          }
        },
        {
          hasBeenBlurred: false,
          showCardError: false,
          isValid: false
        }
      )
      .map(state =&gt; {
        return state.showCardError;
      });
  }
}

customElements.define(&quot;cc-payment&quot;, CCPayment);

</code></pre>
<div line-highlight='10-12,20-22,43-53,81-98,110-121,only'></div>
<h2>Read, validate, and show the error of the CVC</h2>
<h3>The problem</h3>
<p>Let’s make the <code>CVC</code> input element just like the <code>cardNumber</code> and <code>expiry</code>
element.  Make sure to:</p>
<ul>
<li>validate the cvc</li>
<li>show a warning validation message in a <code>&lt;div class=&quot;message&quot;&gt;</code> element</li>
<li>add <code>class=&quot;is-error&quot;</code> to the element if we should show the <code>CVC</code> error.</li>
</ul>
<h3>What you need to know</h3>
<ul>
<li>The <code>cvc</code> can be saved as whatever the user entered. No special processing necessary.</li>
<li>To validate CVC:
<pre><code class="language-js">function validateCVC(cvc) {
  if (!cvc) {
    return &quot;There is no CVC code&quot;;
  }
  if (cvc.length !== 3) {
    return &quot;The CVC must be at least 3 numbers&quot;;
  }
  if (Number.isNaN(parseInt(cvc))) {
    return &quot;The CVC must be numbers&quot;;
  }
}
</code></pre></li>
</ul>
<h3>The solution</h3>
<p>Update the <strong>JavaScript</strong> tab to:</p>
<pre><code class="language-js">import { kefir as Kefir, StacheElement } from &quot;//unpkg.com/can@6/ecosystem.mjs&quot;;

class CCPayment extends StacheElement {
  static view = `
    &lt;form&gt;
      {{# if(this.showCardError.value) }}
        &lt;div class=&quot;message&quot;&gt;{{ this.cardError.value }}&lt;/div&gt;
      {{/ if }}

      {{# if(this.showExpiryError.value) }}
        &lt;div class=&quot;message&quot;&gt;{{ this.expiryError.value }}&lt;/div&gt;
      {{/ if }}

      {{# if(this.showCVCError.value) }}
        &lt;div class=&quot;message&quot;&gt;{{ this.cvcError.value }}&lt;/div&gt;
      {{/ if }}

      &lt;input type=&quot;text&quot; name=&quot;number&quot; placeholder=&quot;Card Number&quot;
          on:input:value:to=&quot;this.userCardNumber.value&quot;
          on:blur=&quot;this.userCardNumberBlurred.emitter.value(true)&quot;
          {{# if(this.showCardError.value) }}class=&quot;is-error&quot;{{/ if }}&gt;

      &lt;input type=&quot;text&quot; name=&quot;expiry&quot; placeholder=&quot;MM-YY&quot;
          on:input:value:to=&quot;this.userExpiry.value&quot;
          on:blur=&quot;this.userExpiryBlurred.emitter.value(true)&quot;
          {{# if(this.showExpiryError.value) }}class=&quot;is-error&quot;{{/ if }}&gt;

      &lt;input type=&quot;text&quot; name=&quot;cvc&quot; placeholder=&quot;CVC&quot;
          on:input:value:to=&quot;this.userCVC.value&quot;
          on:blur=&quot;this.userCVCBlurred.emitter.value(true)&quot;
          {{# if(this.showCVCError.value) }}class=&quot;is-error&quot;{{/ if }}&gt;

      &lt;button&gt;Pay \${{ this.amount.value }}&lt;/button&gt;
    &lt;/form&gt;
  `;

  static props = {
    amount: {
      get default() {
        return Kefir.constant(1000);
      }
    },

    userCardNumber: {
      get default() {
        return Kefir.emitterProperty();
      }
    },

    userCardNumberBlurred: {
      get default() {
        return Kefir.emitterProperty();
      }
    },

    userExpiry: {
      get default() {
        return Kefir.emitterProperty();
      }
    },

    userExpiryBlurred: {
      get default() {
        return Kefir.emitterProperty();
      }
    },

    userCVC: {
      get default() {
        return Kefir.emitterProperty();
      }
    },

    userCVCBlurred: {
      get default() {
        return Kefir.emitterProperty();
      }
    },

    get cardNumber() {
      return this.userCardNumber.map(card =&gt; {
        if (card) {
          return card.replace(/[\s-]/g, &quot;&quot;);
        }
      });
    },

    get cardError() {
      return this.cardNumber.map(this.validateCard);
    },

    get showCardError() {
      return this.showOnlyWhenBlurredOnce(
        this.cardError,
        this.userCardNumberBlurred
      );
    },

    // EXPIRY
    get expiry() {
      return this.userExpiry.map(expiry =&gt; {
        if (expiry) {
          return expiry.split(&quot;-&quot;);
        }
      });
    },

    get expiryError() {
      return this.expiry.map(this.validateExpiry).toProperty();
    },

    get showExpiryError() {
      return this.showOnlyWhenBlurredOnce(
        this.expiryError,
        this.userExpiryBlurred
      );
    },

    // CVC
    get cvc() {
      return this.userCVC;
    },

    get cvcError() {
      return this.cvc.map(this.validateCVC).toProperty();
    },

    get showCVCError() {
      return this.showOnlyWhenBlurredOnce(this.cvcError, this.userCVCBlurred);
    }
  };

  validateCard(card) {
    if (!card) {
      return &quot;There is no card&quot;;
    }
    if (card.length !== 16) {
      return &quot;There should be 16 characters in a card&quot;;
    }
  }

  validateExpiry(expiry) {
    if (!expiry) {
      return &quot;There is no expiry. Format  MM-YY&quot;;
    }
    if (
      expiry.length !== 2 ||
      expiry[0].length !== 2 ||
      expiry[1].length !== 2
    ) {
      return &quot;Expiry must be formatted like MM-YY&quot;;
    }
  }

  validateCVC(cvc) {
    if (!cvc) {
      return &quot;There is no CVC code&quot;;
    }
    if (cvc.length !== 3) {
      return &quot;The CVC must be at least 3 numbers&quot;;
    }
    if (Number.isNaN(parseInt(cvc))) {
      return &quot;The CVC must be numbers&quot;;
    }
  }

  showOnlyWhenBlurredOnce(errorStream, blurredStream) {
    const errorEvent = errorStream.map(error =&gt; {
      if (!error) {
        return {
          type: &quot;valid&quot;
        };
      } else {
        return {
          type: &quot;invalid&quot;,
          message: error
        };
      }
    });

    const focusEvents = blurredStream.map(isBlurred =&gt; {
      if (isBlurred === undefined) {
        return {};
      }
      return isBlurred
        ? {
            type: &quot;blurred&quot;
          }
        : {
            type: &quot;focused&quot;
          };
    });

    return Kefir.merge([errorEvent, focusEvents])
      .scan(
        (previous, event) =&gt; {
          switch (event.type) {
            case &quot;valid&quot;:
              return Object.assign({}, previous, {
                isValid: true,
                showCardError: false
              });
            case &quot;invalid&quot;:
              return Object.assign({}, previous, {
                isValid: false,
                showCardError: previous.hasBeenBlurred
              });
            case &quot;blurred&quot;:
              return Object.assign({}, previous, {
                hasBeenBlurred: true,
                showCardError: !previous.isValid
              });
            default:
              return previous;
          }
        },
        {
          hasBeenBlurred: false,
          showCardError: false,
          isValid: false
        }
      )
      .map(state =&gt; {
        return state.showCardError;
      });
  }
}

customElements.define(&quot;cc-payment&quot;, CCPayment);

</code></pre>
<div line-highlight='14-16,29-31,68-78,120-130,155-165,only'></div>
<h2>Disable the pay button if any part of the card has an error</h2>
<h3>The problem</h3>
<p>Let’s disable the <strong>Pay</strong> button until the card, expiry, and cvc are valid.</p>
<h3>What you need to know</h3>
<ul>
<li><code>Kefir.combine</code> can combine several values into a single value:
<pre><code class="language-js">const first = Kefir.sequentially(100, [&quot;Justin&quot;, &quot;Ramiya&quot;])
const last = Kefir.sequentially(100, [&quot;Shah&quot;, &quot;Meyer&quot;]).delay(50);
// first: ---Justin---RamiyaX
// last:  ------Shah__---Meyer_X
const fullName = Kefir.combine([first, last], (first, last) =&gt; {
  return first + &quot; &quot; + last;
});
// fullName: ---Justin Shah
//             -Ramiya Shah
//             -Ramiya MeyerX
</code></pre></li>
<li><a href="../../can-stache-bindings.toChild.html" title="One-way bind a value in the parent scope to the StacheElement, can-component ViewModel, or element.">childProp:from</a> can set a property from another value:
<pre><code class="language-js">&lt;input checked:from=&quot;someKey&quot;&gt;
</code></pre></li>
</ul>
<h3>The solution</h3>
<p>Update the <strong>JavaScript</strong> tab to:</p>
<pre><code class="language-js">import { kefir as Kefir, StacheElement } from &quot;//unpkg.com/can@6/ecosystem.mjs&quot;;

class CCPayment extends StacheElement {
  static view = `
    &lt;form&gt;
      {{# if(this.showCardError.value) }}
        &lt;div class=&quot;message&quot;&gt;{{ this.cardError.value }}&lt;/div&gt;
      {{/ if }}

      {{# if(this.showExpiryError.value) }}
        &lt;div class=&quot;message&quot;&gt;{{ this.expiryError.value }}&lt;/div&gt;
      {{/ if }}

      {{# if(this.showCVCError.value) }}
        &lt;div class=&quot;message&quot;&gt;{{ this.cvcError.value }}&lt;/div&gt;
      {{/ if }}

      &lt;input type=&quot;text&quot; name=&quot;number&quot; placeholder=&quot;Card Number&quot;
          on:input:value:to=&quot;this.userCardNumber.value&quot;
          on:blur=&quot;this.userCardNumberBlurred.emitter.value(true)&quot;
          {{# if(this.showCardError.value) }}class=&quot;is-error&quot;{{/ if }}&gt;

      &lt;input type=&quot;text&quot; name=&quot;expiry&quot; placeholder=&quot;MM-YY&quot;
          on:input:value:to=&quot;this.userExpiry.value&quot;
          on:blur=&quot;this.userExpiryBlurred.emitter.value(true)&quot;
          {{# if(this.showExpiryError.value) }}class=&quot;is-error&quot;{{/ if }}&gt;

      &lt;input type=&quot;text&quot; name=&quot;cvc&quot; placeholder=&quot;CVC&quot;
          on:input:value:to=&quot;this.userCVC.value&quot;
          on:blur=&quot;this.userCVCBlurred.emitter.value(true)&quot;
          {{# if(this.showCVCError.value) }}class=&quot;is-error&quot;{{/ if }}&gt;

      &lt;button disabled:from=&quot;this.isCardInvalid.value&quot;&gt;
        Pay \${{ this.amount.value }}
      &lt;/button&gt;
    &lt;/form&gt;
  `;

  static props = {
    amount: {
      get default() {
        return Kefir.constant(1000);
      }
    },

    userCardNumber: {
      get default() {
        return Kefir.emitterProperty();
      }
    },

    userCardNumberBlurred: {
      get default() {
        return Kefir.emitterProperty();
      }
    },

    userExpiry: {
      get default() {
        return Kefir.emitterProperty();
      }
    },

    userExpiryBlurred: {
      get default() {
        return Kefir.emitterProperty();
      }
    },

    userCVC: {
      get default() {
        return Kefir.emitterProperty();
      }
    },

    userCVCBlurred: {
      get default() {
        return Kefir.emitterProperty();
      }
    },

    get cardNumber() {
      return this.userCardNumber.map(card =&gt; {
        if (card) {
          return card.replace(/[\s-]/g, &quot;&quot;);
        }
      });
    },

    get cardError() {
      return this.cardNumber.map(this.validateCard);
    },

    get showCardError() {
      return this.showOnlyWhenBlurredOnce(
        this.cardError,
        this.userCardNumberBlurred
      );
    },

    // EXPIRY
    get expiry() {
      return this.userExpiry.map(expiry =&gt; {
        if (expiry) {
          return expiry.split(&quot;-&quot;);
        }
      });
    },

    get expiryError() {
      return this.expiry.map(this.validateExpiry).toProperty();
    },

    get showExpiryError() {
      return this.showOnlyWhenBlurredOnce(
        this.expiryError,
        this.userExpiryBlurred
      );
    },

    // CVC
    get cvc() {
      return this.userCVC;
    },

    get cvcError() {
      return this.cvc.map(this.validateCVC).toProperty();
    },

    get showCVCError() {
      return this.showOnlyWhenBlurredOnce(this.cvcError, this.userCVCBlurred);
    },

    get isCardInvalid() {
      return Kefir.combine(
        [this.cardError, this.expiryError, this.cvcError],
        (cardError, expiryError, cvcError) =&gt; {
          return !!(cardError || expiryError || cvcError);
        }
      );
    }
  };

  validateCard(card) {
    if (!card) {
      return &quot;There is no card&quot;;
    }
    if (card.length !== 16) {
      return &quot;There should be 16 characters in a card&quot;;
    }
  }

  validateExpiry(expiry) {
    if (!expiry) {
      return &quot;There is no expiry. Format  MM-YY&quot;;
    }
    if (
      expiry.length !== 2 ||
      expiry[0].length !== 2 ||
      expiry[1].length !== 2
    ) {
      return &quot;Expiry must be formatted like MM-YY&quot;;
    }
  }

  validateCVC(cvc) {
    if (!cvc) {
      return &quot;There is no CVC code&quot;;
    }
    if (cvc.length !== 3) {
      return &quot;The CVC must be at least 3 numbers&quot;;
    }
    if (isNaN(parseInt(cvc))) {
      return &quot;The CVC must be numbers&quot;;
    }
  }

  showOnlyWhenBlurredOnce(errorStream, blurredStream) {
    const errorEvent = errorStream.map(error =&gt; {
      if (!error) {
        return {
          type: &quot;valid&quot;
        };
      } else {
        return {
          type: &quot;invalid&quot;,
          message: error
        };
      }
    });

    const focusEvents = blurredStream.map(isBlurred =&gt; {
      if (isBlurred === undefined) {
        return {};
      }
      return isBlurred
        ? {
            type: &quot;blurred&quot;
          }
        : {
            type: &quot;focused&quot;
          };
    });

    return Kefir.merge([errorEvent, focusEvents])
      .scan(
        (previous, event) =&gt; {
          switch (event.type) {
            case &quot;valid&quot;:
              return Object.assign({}, previous, {
                isValid: true,
                showCardError: false
              });
            case &quot;invalid&quot;:
              return Object.assign({}, previous, {
                isValid: false,
                showCardError: previous.hasBeenBlurred
              });
            case &quot;blurred&quot;:
              return Object.assign({}, previous, {
                hasBeenBlurred: true,
                showCardError: !previous.isValid
              });
            default:
              return previous;
          }
        },
        {
          hasBeenBlurred: false,
          showCardError: false,
          isValid: false
        }
      )
      .map(state =&gt; {
        return state.showCardError;
      });
  }
}

customElements.define(&quot;cc-payment&quot;, CCPayment);

</code></pre>
<div line-highlight='33-35,134-141,only'></div>
<h2>Implement the payment button</h2>
<h3>The problem</h3>
<p>When the user submits the form, let’s simulate making a 2 second AJAX
request to create a payment.  While the request is being made,
we will change the <strong>Pay</strong> button to say <strong>Paying</strong>.</p>
<h3>What you need to know</h3>
<ul>
<li><p>Use the following to create a Promise that takes 2 seconds to resolve:</p>
<pre><code class="language-js">new Promise(function(resolve) {
  setTimeout(function() {
    resolve(1000);
  }, 2000);
});
</code></pre></li>
<li><p>Use <a href="../../can-stache-bindings.event.html" title="Respond to events on elements or component ViewModels.">on:event</a> to listen to an event on an element and call a method in <a href="../../can-stache.html" title="Live binding templates.">can-stache</a>.  For example, the following calls <code>doSomething()</code> when the <code>&lt;div&gt;</code> is clicked:</p>
<pre><code class="language-html">&lt;div on:click=&quot;doSomething(scope.event)&quot;&gt; ... &lt;/div&gt;
</code></pre>
<p>Notice that it also passed the event object with <a href="../../can-stache/keys/scope.html#scope_event" title="The template context">scope.event</a>.</p></li>
<li><p>To prevent a form from submitting, call <a href="https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault">event.preventDefault()</a>.</p></li>
<li><p><a href="https://kefirjs.github.io/kefir/#from-promise">Kefir.fromPromise</a> returns a stream from the resolved value of a promise.</p></li>
<li><p><a href="https://kefirjs.github.io/kefir/#combine">Kefir.combine</a> takes a list of passive streams
where the combinator will not be called when the passive streams emit a value.</p></li>
<li><p><a href="https://kefirjs.github.io/kefir/#concat">Kefir.concat</a> concatenates streams so events are produced in order.</p>
<pre><code class="language-js">const a = Kefir.sequentially(100, [0, 1, 2]);
const b = Kefir.sequentially(100, [3, 4, 5]);
const abc = Kefir.concat([a, b]);
//a:    ---0---1---2X
//b:                ---3---4---5X
//abc:  ---0---1---2---3---4---5X
</code></pre></li>
<li><p><a href="https://kefirjs.github.io/kefir/#flat-map">Kefir.flatMap</a> flattens a stream of
streams to a single stream of values.</p>
<pre><code class="language-js">const count = Kefir.sequentially(100, [1, 2, 3]);
const streamOfStreams = count.map(count =&gt; {
  return Kefir.interval(40, count).take(4)
});
const result = streamOfStreams.flatMap();
// source:      ----------1---------2---------3X
//
// spawned 1:             ---1---1---1---1X
// spawned 2:                       ---2---2---2---2X
// spawned 3:                                 ---3---3---3---3X
// result:      -------------1---1---1-2-1-2---2-3-2-3---3---3X
</code></pre>
<p>I think of this like promises’ ability to resolve when an “inner” promise
resolves.  For example, <code>resultPromise</code> below resolves with the <code>innerPromise</code>:</p>
<pre><code class="language-js">const outerPromise = new Promise((resolve) =&gt; {
  setTimeout(() =&gt; { resolve(&quot;outer&quot;) }, 100);
});
return innerPromise = new Promise((resolve) =&gt; {
  setTimeout(() =&gt; { resolve(&quot;inner&quot;) }, 200);
});
const resultPromise = outerPromise.then(function(value) {
  // value -&gt; &quot;outer&quot;
  return innerPromise;
});
resultPromise.then(function(value) {
  // value -&gt; &quot;inner&quot;
});
</code></pre>
<p>In some ways, <code>outerPromise</code> is a promise of promises.  Promises flatten
by default. With Kefir, you call <code>flatMap</code> to flatten streams.</p></li>
</ul>
<h3>The solution</h3>
<p>Update the <strong>JavaScript</strong> tab to:</p>
<pre><code class="language-js">import { kefir as Kefir, StacheElement } from &quot;//unpkg.com/can@6/ecosystem.mjs&quot;;

class CCPayment extends StacheElement {
  static view = `
    &lt;form on:submit=&quot;this.pay(scope.event)&quot;&gt;
      {{# if(this.showCardError.value) }}
        &lt;div class=&quot;message&quot;&gt;{{ this.cardError.value }}&lt;/div&gt;
      {{/ if }}

      {{# if(this.showExpiryError.value) }}
        &lt;div class=&quot;message&quot;&gt;{{ this.expiryError.value }}&lt;/div&gt;
      {{/ if }}

      {{# if(this.showCVCError.value) }}
        &lt;div class=&quot;message&quot;&gt;{{ this.cvcError.value }}&lt;/div&gt;
      {{/ if }}

      &lt;input type=&quot;text&quot; name=&quot;number&quot; placeholder=&quot;Card Number&quot;
          on:input:value:to=&quot;this.userCardNumber.value&quot;
          on:blur=&quot;this.userCardNumberBlurred.emitter.value(true)&quot;
          {{# if(this.showCardError.value) }}class=&quot;is-error&quot;{{/ if }}&gt;
    
      &lt;input type=&quot;text&quot; name=&quot;expiry&quot; placeholder=&quot;MM-YY&quot;
          on:input:value:to=&quot;this.userExpiry.value&quot;
          on:blur=&quot;this.userExpiryBlurred.emitter.value(true)&quot;
          {{# if(this.showExpiryError.value) }}class=&quot;is-error&quot;{{/ if }}&gt;
    
      &lt;input type=&quot;text&quot; name=&quot;cvc&quot; placeholder=&quot;CVC&quot;
          on:input:value:to=&quot;this.userCVC.value&quot;
          on:blur=&quot;this.userCVCBlurred.emitter.value(true)&quot;
          {{# if(this.showCVCError.value) }}class=&quot;is-error&quot;{{/ if }}&gt;
    
      &lt;button disabled:from=&quot;this.isCardInvalid.value&quot;&gt;
        {{# eq(this.paymentStatus.value.status, &quot;pending&quot;) }}Paying{{ else }}Pay{{/ eq }} \${{ this.amount.value }}
      &lt;/button&gt;
    &lt;/form&gt;
  `;

  static props = {
    amount: {
      get default() {
        return Kefir.constant(1000);
      }
    },

    userCardNumber: {
      get default() {
        return Kefir.emitterProperty();
      }
    },

    userCardNumberBlurred: {
      get default() {
        return Kefir.emitterProperty();
      }
    },

    userExpiry: {
      get default() {
        return Kefir.emitterProperty();
      }
    },

    userExpiryBlurred: {
      get default() {
        return Kefir.emitterProperty();
      }
    },

    userCVC: {
      get default() {
        return Kefir.emitterProperty();
      }
    },

    userCVCBlurred: {
      get default() {
        return Kefir.emitterProperty();
      }
    },

    payClicked: {
      get default() {
        return Kefir.emitterProperty();
      }
    },

    get cardNumber() {
      return this.userCardNumber.map(card =&gt; {
        if (card) {
          return card.replace(/[\s-]/g, &quot;&quot;);
        }
      });
    },

    get cardError() {
      return this.cardNumber.map(this.validateCard);
    },

    get showCardError() {
      return this.showOnlyWhenBlurredOnce(
        this.cardError,
        this.userCardNumberBlurred
      );
    },

    // EXPIRY
    get expiry() {
      return this.userExpiry.map(expiry =&gt; {
        if (expiry) {
          return expiry.split(&quot;-&quot;);
        }
      });
    },

    get expiryError() {
      return this.expiry.map(this.validateExpiry).toProperty();
    },

    get showExpiryError() {
      return this.showOnlyWhenBlurredOnce(
        this.expiryError,
        this.userExpiryBlurred
      );
    },

    // CVC
    get cvc() {
      return this.userCVC;
    },

    get cvcError() {
      return this.cvc.map(this.validateCVC).toProperty();
    },

    get showCVCError() {
      return this.showOnlyWhenBlurredOnce(this.cvcError, this.userCVCBlurred);
    },

    get isCardInvalid() {
      return Kefir.combine(
        [this.cardError, this.expiryError, this.cvcError],
        (cardError, expiryError, cvcError) =&gt; {
          return !!(cardError || expiryError || cvcError);
        }
      );
    },

    get card() {
      return Kefir.combine(
        [this.cardNumber, this.expiry, this.cvc],
        (cardNumber, expiry, cvc) =&gt; {
          return { cardNumber, expiry, cvc };
        }
      );
    },

    // STREAM&lt; Promise&lt;Number&gt; | undefined &gt;
    get paymentPromises() {
      return Kefir.combine(
        [this.payClicked],
        [this.card],
        (payClicked, card) =&gt; {
          if (payClicked) {
            console.log(&quot;Asking for token with&quot;, card);
            return new Promise(resolve =&gt; {
              setTimeout(() =&gt; {
                resolve(1000);
              }, 2000);
            });
          }
        }
      );
    },

    // STREAM&lt; STREAM&lt;STATUS&gt; &gt;
    // This is a stream of streams of status objects.
    get paymentStatusStream() {
      return this.paymentPromises.map(promise =&gt; {
        if (promise) {
          // STREAM&lt;STATUS&gt;
          return Kefir.concat([
            Kefir.constant({
              status: &quot;pending&quot;
            }),
            Kefir.fromPromise(promise).map(value =&gt; {
              return {
                status: &quot;resolved&quot;,
                value: value
              };
            })
          ]);
        } else {
          // STREAM
          return Kefir.constant({
            status: &quot;waiting&quot;
          });
        }
      });
    },

    // STREAM&lt;STATUS&gt; //{status: &quot;waiting&quot;} | {status: &quot;resolved&quot;}
    get paymentStatus() {
      return this.paymentStatusStream.flatMap().toProperty();
    }
  };

  pay(event) {
    event.preventDefault();
    this.payClicked.emitter.value(true);
  }

  validateCard(card) {
    if (!card) {
      return &quot;There is no card&quot;;
    }
    if (card.length !== 16) {
      return &quot;There should be 16 characters in a card&quot;;
    }
  }

  validateExpiry(expiry) {
    if (!expiry) {
      return &quot;There is no expiry. Format  MM-YY&quot;;
    }
    if (
      expiry.length !== 2 ||
      expiry[0].length !== 2 ||
      expiry[1].length !== 2
    ) {
      return &quot;Expiry must be formatted like MM-YY&quot;;
    }
  }

  validateCVC(cvc) {
    if (!cvc) {
      return &quot;There is no CVC code&quot;;
    }
    if (cvc.length !== 3) {
      return &quot;The CVC must be at least 3 numbers&quot;;
    }
    if (isNaN(parseInt(cvc))) {
      return &quot;The CVC must be numbers&quot;;
    }
  }

  showOnlyWhenBlurredOnce(errorStream, blurredStream) {
    const errorEvent = errorStream.map(error =&gt; {
      if (!error) {
        return {
          type: &quot;valid&quot;
        };
      } else {
        return {
          type: &quot;invalid&quot;,
          message: error
        };
      }
    });

    const focusEvents = blurredStream.map(isBlurred =&gt; {
      if (isBlurred === undefined) {
        return {};
      }
      return isBlurred
        ? {
            type: &quot;blurred&quot;
          }
        : {
            type: &quot;focused&quot;
          };
    });

    return Kefir.merge([errorEvent, focusEvents])
      .scan(
        (previous, event) =&gt; {
          switch (event.type) {
            case &quot;valid&quot;:
              return Object.assign({}, previous, {
                isValid: true,
                showCardError: false
              });
            case &quot;invalid&quot;:
              return Object.assign({}, previous, {
                isValid: false,
                showCardError: previous.hasBeenBlurred
              });
            case &quot;blurred&quot;:
              return Object.assign({}, previous, {
                hasBeenBlurred: true,
                showCardError: !previous.isValid
              });
            default:
              return previous;
          }
        },
        {
          hasBeenBlurred: false,
          showCardError: false,
          isValid: false
        }
      )
      .map(state =&gt; {
        return state.showCardError;
      });
  }
}

customElements.define(&quot;cc-payment&quot;, CCPayment);

</code></pre>
<div line-highlight='5,34,82-86,149-156,159-174,178-200,203-205,208-211,only'></div>
<h2>Disable the payment button while payments are pending</h2>
<h3>The problem</h3>
<p>Let’s prevent the <strong>Pay</strong> button from being clicked while the payment is processing.</p>
<h3>What you need to know</h3>
<ul>
<li>You know everything you need to know.</li>
</ul>
<h3>The solution</h3>
<p>Update the <strong>JavaScript</strong> tab to:</p>
<pre><code class="language-js">import { kefir as Kefir, StacheElement } from &quot;//unpkg.com/can@6/ecosystem.mjs&quot;;

class CCPayment extends StacheElement {
    static view = `
        &lt;form on:submit=&quot;this.pay(scope.event)&quot;&gt;
            {{# if(this.showCardError.value) }}
                &lt;div class=&quot;message&quot;&gt;{{ this.cardError.value }}&lt;/div&gt;
            {{/ if }}

            {{# if(this.showExpiryError.value) }}
                &lt;div class=&quot;message&quot;&gt;{{ this.expiryError.value }}&lt;/div&gt;
            {{/ if }}

            {{# if(this.showCVCError.value) }}
                &lt;div class=&quot;message&quot;&gt;{{ this.cvcError.value }}&lt;/div&gt;
            {{/ if }}

            &lt;input type=&quot;text&quot; name=&quot;number&quot; placeholder=&quot;Card Number&quot;
                    on:input:value:to=&quot;this.userCardNumber.value&quot;
                    on:blur=&quot;this.userCardNumberBlurred.emitter.value(true)&quot;
                    {{# if(this.showCardError.value) }}class=&quot;is-error&quot;{{/ if }}&gt;

            &lt;input type=&quot;text&quot; name=&quot;expiry&quot; placeholder=&quot;MM-YY&quot;
                    on:input:value:to=&quot;this.userExpiry.value&quot;
                    on:blur=&quot;this.userExpiryBlurred.emitter.value(true)&quot;
                    {{# if(this.showExpiryError.value) }}class=&quot;is-error&quot;{{/ if }}&gt;
    
            &lt;input type=&quot;text&quot; name=&quot;cvc&quot; placeholder=&quot;CVC&quot;
                    on:input:value:to=&quot;this.userCVC.value&quot;
                    on:blur=&quot;this.userCVCBlurred.emitter.value(true)&quot;
                    {{# if(this.showCVCError.value) }}class=&quot;is-error&quot;{{/ if }}&gt;

            &lt;button disabled:from=&quot;this.disablePaymentButton.value&quot;&gt;
                {{# eq(this.paymentStatus.value.status, &quot;pending&quot;) }}Paying{{ else }}Pay{{/ eq }} \${{ this.amount.value }}
            &lt;/button&gt;
        &lt;/form&gt;
  `;

    static props = {
        amount: {
            get default() {
                return Kefir.constant(1000);
            }
        },

        userCardNumber: {
            get default() {
                return Kefir.emitterProperty();
            }
        },

        userCardNumberBlurred: {
            get default() {
                return Kefir.emitterProperty();
            }
        },

        userExpiry: {
            get default() {
                return Kefir.emitterProperty();
            }
        },

        userExpiryBlurred: {
            get default() {
                return Kefir.emitterProperty();
            }
        },

        userCVC: {
            get default() {
                return Kefir.emitterProperty();
            }
        },

        userCVCBlurred: {
            get default() {
                return Kefir.emitterProperty();
            }
        },

        payClicked: {
            get default() {
                return Kefir.emitterProperty();
            }
        },

        get cardNumber() {
            return this.userCardNumber.map(card =&gt; {
                if (card) {
                    return card.replace(/[\s-]/g, &quot;&quot;);
                }
            });
        },

        get cardError() {
            return this.cardNumber.map(this.validateCard);
        },

        get showCardError() {
            return this.showOnlyWhenBlurredOnce(
                this.cardError,
                this.userCardNumberBlurred
            );
        },

        // EXPIRY
        get expiry() {
            return this.userExpiry.map(expiry =&gt; {
                if (expiry) {
                    return expiry.split(&quot;-&quot;);
                }
            });
        },

        get expiryError() {
            return this.expiry.map(this.validateExpiry).toProperty();
        },

        get showExpiryError() {
            return this.showOnlyWhenBlurredOnce(
                this.expiryError,
                this.userExpiryBlurred
            );
        },

        // CVC
        get cvc() {
            return this.userCVC;
        },

        get cvcError() {
            return this.cvc.map(this.validateCVC).toProperty();
        },

        get showCVCError() {
            return this.showOnlyWhenBlurredOnce(this.cvcError, this.userCVCBlurred);
        },

        get isCardInvalid() {
            return Kefir.combine(
                [this.cardError, this.expiryError, this.cvcError],
                (cardError, expiryError, cvcError) =&gt; {
                    return !!(cardError || expiryError || cvcError);
                }
            );
        },

        get card() {
            return Kefir.combine(
                [this.cardNumber, this.expiry, this.cvc],
                (cardNumber, expiry, cvc) =&gt; {
                    return { cardNumber, expiry, cvc };
                }
            );
        },

        // STREAM&lt; Promise&lt;Number&gt; | undefined &gt;
        get paymentPromises() {
            return Kefir.combine(
                [this.payClicked],
                [this.card],
                (payClicked, card) =&gt; {
                    if (payClicked) {
                        console.log(&quot;Asking for token with&quot;, card);
                        return new Promise(resolve =&gt; {
                            setTimeout(() =&gt; {
                                resolve(1000);
                            }, 2000);
                        });
                    }
                }
            );
        },

        // STREAM&lt; STREAM&lt;STATUS&gt; &gt;
        // This is a stream of streams of status objects.
        get paymentStatusStream() {
            return this.paymentPromises.map(promise =&gt; {
                if (promise) {
                    // STREAM&lt;STATUS&gt;
                    return Kefir.concat([
                        Kefir.constant({
                            status: &quot;pending&quot;
                        }),
                        Kefir.fromPromise(promise).map(value =&gt; {
                            return {
                                status: &quot;resolved&quot;,
                                value: value
                            };
                        })
                    ]);
                } else {
                    // STREAM
                    return Kefir.constant({
                        status: &quot;waiting&quot;
                    });
                }
            });
        },

        // STREAM&lt;STATUS&gt; //{status: &quot;waiting&quot;} | {status: &quot;resolved&quot;}
        get paymentStatus() {
            return this.paymentStatusStream.flatMap().toProperty();
        },

        get disablePaymentButton() {
            return Kefir.combine(
                [this.isCardInvalid, this.paymentStatus],
                (isCardInvalid, paymentStatus) =&gt; {
                    return (
                        isCardInvalid === true ||
                        !paymentStatus ||
                        paymentStatus.status === &quot;pending&quot;
                    );
                }
            ).toProperty(() =&gt; {
                return true;
            });
        }
    };

    pay(event) {
        event.preventDefault();
        this.payClicked.emitter.value(true);
    }

    validateCard(card) {
        if (!card) {
            return &quot;There is no card&quot;;
        }
        if (card.length !== 16) {
            return &quot;There should be 16 characters in a card&quot;;
        }
    }

    validateExpiry(expiry) {
        if (!expiry) {
            return &quot;There is no expiry. Format  MM-YY&quot;;
        }
        if (
            expiry.length !== 2 ||
            expiry[0].length !== 2 ||
            expiry[1].length !== 2
        ) {
            return &quot;Expiry must be formatted like MM-YY&quot;;
        }
    }

    validateCVC(cvc) {
        if (!cvc) {
            return &quot;There is no CVC code&quot;;
        }
        if (cvc.length !== 3) {
            return &quot;The CVC must be at least 3 numbers&quot;;
        }
        if (isNaN(parseInt(cvc))) {
            return &quot;The CVC must be numbers&quot;;
        }
    }

    showOnlyWhenBlurredOnce(errorStream, blurredStream) {
        const errorEvent = errorStream.map(error =&gt; {
            if (!error) {
                return {
                    type: &quot;valid&quot;
                };
            } else {
                return {
                    type: &quot;invalid&quot;,
                    message: error
                };
            }
        });

        const focusEvents = blurredStream.map(isBlurred =&gt; {
            if (isBlurred === undefined) {
                return {};
            }
            return isBlurred
                ? {
                        type: &quot;blurred&quot;
                  }
                : {
                        type: &quot;focused&quot;
                  };
        });

        return Kefir.merge([errorEvent, focusEvents])
            .scan(
                (previous, event) =&gt; {
                    switch (event.type) {
                        case &quot;valid&quot;:
                            return Object.assign({}, previous, {
                                isValid: true,
                                showCardError: false
                            });
                        case &quot;invalid&quot;:
                            return Object.assign({}, previous, {
                                isValid: false,
                                showCardError: previous.hasBeenBlurred
                            });
                        case &quot;blurred&quot;:
                            return Object.assign({}, previous, {
                                hasBeenBlurred: true,
                                showCardError: !previous.isValid
                            });
                        default:
                            return previous;
                    }
                },
                {
                    hasBeenBlurred: false,
                    showCardError: false,
                    isValid: false
                }
            )
            .map(state =&gt; {
                return state.showCardError;
            });
    }
}

customElements.define(&quot;cc-payment&quot;, CCPayment);

</code></pre>
<div line-highlight='33,207-221,only'></div>
<h2>Result</h2>
<p>When complete, you should have a working credit card payment form like the following CodePen:</p>
<p class="codepen" data-height="416" data-theme-id="0" data-default-tab="result" data-user="bitovi" data-slug-hash="QWLKWQB" style="height: 416px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid black; margin: 1em 0; padding: 1em;" data-pen-title="Credit Card Guide (Advanced)">
  <span>See the Pen <a href="https://codepen.io/bitovi/pen/QWLKWQB/">
  Credit Card Guide (Advanced)</a> by Bitovi (<a href="https://codepen.io/bitovi">@bitovi</a>)
  on <a href="https://codepen.io">CodePen</a>.</span>
</p>
<script async src="https://static.codepen.io/assets/embed/ei.js"></script>

</section>

  


<script type="text/javascript">
  window.docObject = {"src":{"path":"docs/can-guides/commitment/recipes/credit-card-advanced/credit-card-advanced.md"},"description":"This advanced guide walks through building a simple credit card payment form with validations. It doesn’t use\n[can-define]. Instead it uses `Kefir.js` streams to make a ViewModel.\n[can-kefir] is used to make the Kefir streams observable to [can-stache].\n\n","name":"guides/recipes/credit-card-advanced","title":"Credit Card","type":"page","parent":"guides/recipes/advanced","comment":" ","pathToRoot":"../../.."};
</script>
</article>
      
        <footer><p>CanJS is part of <a href="https://donejs.com" target="_blank">DoneJS</a>. Created and maintained by the core <a href="https://donejs.com/About.html#team" target="_blank">DoneJS team</a> and <a href="https://www.bitovi.com" target="_blank">Bitovi</a>. <strong>Currently 6.6.1.</strong></p>
</footer>
      

  </div>
  <div id="toc-sidebar" class="column">
    <nav>
      <h1 class="hide">On this page</h1>
    </nav>
    <div class="get-help">
      <h1>Get help</h1>
      <ul>
        <li><a href="https://www.bitovi.com/community/slack" target="_blank" class="icon-slack">Chat with us</a></li>
        <li><a href="https://github.com/canjs/canjs/issues/new" target="_blank" class="icon-github">File an issue</a></li>
        <li><a href="https://forums.bitovi.com/c/canjs" target="_blank" class="icon-forums">Ask questions</a></li>
        <li><a href="https://www.bitovi.com/blog/topic/canjs" target="_blank" class="icon-blog">Read latest news</a></li>
      </ul>
    </div>
  </div>
</div>

		
			<script>
				steal = {
				  	instantiated: {
				    	"bundles/bit-docs-site/static.css!$css" : null
				  	}
			  	};
			</script>
			<script type='text/javascript' data-main="bit-docs-site/static" src="../../static/steal.production.js"></script>
		
		<script async defer src="https://buttons.github.io/buttons.js"></script>

		<!-- root-level elements with attributes necessary for the app -->
		<div path-prefix="../.."></div>

	</body>
</html>
