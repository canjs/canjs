/*bundlesConfig*/
System.bundles = {"bundles/app":["stealconfig","can/lib/html5shiv","jquery","can/util/can","can/util/attr/attr","can/event/event","can/util/array/each","can/util/inserted/inserted","can/util/jquery/jquery","can/view/view","can/view/parser/parser","can/view/elements","can/view/target/target","can/view/stache/utils","can/view/node_lists/node_lists","can/view/live/live","can/view/stache/mustache_helpers","can/util/string/string","can/construct/construct","can/util/bind/bind","can/map/bubble","can/util/batch/batch","can/map/map","can/list/list","can/compute/compute","can/view/scope/scope","can/view/stache/mustache_core","can/view/stache/html_section","can/view/stache/text_section","can/view/callbacks/callbacks","can/view/stache/stache","helloworld.stache!can/view/stache/system","app"]};
/*stealconfig*/
console.log("CONFIG RUN"),function(){var e=!1;!function(){try{var t=document.createElement("a");t.innerHTML="<xyz></xyz>",e=1==t.childNodes.length||function(){document.createElement("a");var e=document.createDocumentFragment();return"undefined"==typeof e.cloneNode||"undefined"==typeof e.createDocumentFragment||"undefined"==typeof e.createElement}()}catch(n){e=!1}}(),steal.config({map:{"jquery/jquery":"jquery","can/util/util":"can/util/jquery/jquery",stache:"can/view/stache/system"},paths:{jquery:"../../../lib/jquery.1.10.2.js","can/*":"../../../*.js"},meta:{jquery:{exports:"jQuery",deps:e?void 0:["can/lib/html5shiv"]}},ext:{ejs:"view/ejs/ejs.js",mustache:"view/mustache/mustache.js",stache:"view/stache/stache.js"}}),System.buildConfig={map:{"jquery/jquery":"jquery","can/util/util":"can/util/domless/domless",stache:"can/view/stache/system"}}}();
/*can/lib/html5shiv*/
System.define("can/lib/html5shiv","/**\n* @preserve HTML5 Shiv v3.6.2 | @afarkas @jdalton @jon_neal @rem | MIT/GPL2 Licensed\n*/\n;(function(window, document) {\n/*jshint evil:true */\n  /** version */\n  var version = '3.6.2 - CanJS Mod';\n\n  /** Preset options */\n  var options = window.html5 || {};\n\n  /** Used to skip problem elements */\n  var reSkip = /^<|^(?:button|map|select|textarea|object|iframe|option|optgroup)$/i;\n\n  /** Not all elements can be cloned in IE **/\n  var saveClones = /^(?:a|b|code|div|fieldset|h1|h2|h3|h4|h5|h6|i|label|li|ol|p|q|span|strong|style|table|tbody|td|th|tr|ul)$/i;\n\n  /** Detect whether the browser supports default html5 styles */\n  var supportsHtml5Styles;\n\n  /** Name of the expando, to work with multiple documents or to re-shiv one document */\n  var expando = '_html5shiv';\n\n  /** The id for the the documents expando */\n  var expanID = 0;\n\n  /** Cached data for each document */\n  var expandoData = {};\n\n  /** Detect whether the browser supports unknown elements */\n  var supportsUnknownElements;\n\n  (function() {\n    try {\n        var a = document.createElement('a');\n        a.innerHTML = '<xyz></xyz>';\n        //if the hidden property is implemented we can assume, that the browser supports basic HTML5 Styles\n        supportsHtml5Styles = ('hidden' in a);\n\n        supportsUnknownElements = a.childNodes.length == 1 || (function() {\n          // assign a false positive if unable to shiv\n          (document.createElement)('a');\n          var frag = document.createDocumentFragment();\n          return (\n            typeof frag.cloneNode == 'undefined' ||\n            typeof frag.createDocumentFragment == 'undefined' ||\n            typeof frag.createElement == 'undefined'\n          );\n        }());\n    } catch(e) {\n      // assign a false positive if detection fails => unable to shiv\n      supportsHtml5Styles = true;\n      supportsUnknownElements = true;\n    }\n\n  }());\n\n  /*--------------------------------------------------------------------------*/\n\n  /**\n   * Creates a style sheet with the given CSS text and adds it to the document.\n   * @private\n   * @param {Document} ownerDocument The document.\n   * @param {String} cssText The CSS text.\n   * @returns {StyleSheet} The style element.\n   */\n  function addStyleSheet(ownerDocument, cssText) {\n    var p = ownerDocument.createElement('p'),\n        parent = ownerDocument.getElementsByTagName('head')[0] || ownerDocument.documentElement;\n\n    p.innerHTML = 'x<style>' + cssText + '</style>';\n    return parent.insertBefore(p.lastChild, parent.firstChild);\n  }\n\n  /**\n   * Returns the value of `html5.elements` as an array.\n   * @private\n   * @returns {Array} An array of shived element node names.\n   */\n  function getElements() {\n    var elements = html5.elements;\n    return typeof elements == 'string' ? elements.split(' ') : elements;\n  }\n\n    /**\n   * Returns the data associated to the given document\n   * @private\n   * @param {Document} ownerDocument The document.\n   * @returns {Object} An object of data.\n   */\n  function getExpandoData(ownerDocument) {\n    var data = expandoData[ownerDocument[expando]];\n    if (!data) {\n        data = {};\n        expanID++;\n        ownerDocument[expando] = expanID;\n        expandoData[expanID] = data;\n    }\n    return data;\n  }\n\n  /**\n   * returns a shived element for the given nodeName and document\n   * @memberOf html5\n   * @param {String} nodeName name of the element\n   * @param {Document} ownerDocument The context document.\n   * @returns {Object} The shived element.\n   */\n  function createElement(nodeName, ownerDocument, data){\n    if (!ownerDocument) {\n        ownerDocument = document;\n    }\n    if(supportsUnknownElements){\n        return ownerDocument.createElement(nodeName);\n    }\n    if (!data) {\n        data = getExpandoData(ownerDocument);\n    }\n    var node;\n\n    if (data.cache[nodeName]) {\n        node = data.cache[nodeName].cloneNode();\n    } else if (saveClones.test(nodeName)) {\n        node = (data.cache[nodeName] = data.createElem(nodeName)).cloneNode();\n    } else {\n        node = data.createElem(nodeName);\n    }\n\n    // Avoid adding some elements to fragments in IE < 9 because\n    // * Attributes like `name` or `type` cannot be set/changed once an element\n    //   is inserted into a document/fragment\n    // * Link elements with `src` attributes that are inaccessible, as with\n    //   a 403 response, will cause the tab/window to crash\n    // * Script elements appended to fragments will execute when their `src`\n    //   or `text` property is set\n    return node.canHaveChildren && !reSkip.test(nodeName) ? data.frag.appendChild(node) : node;\n  }\n\n  /**\n   * returns a shived DocumentFragment for the given document\n   * @memberOf html5\n   * @param {Document} ownerDocument The context document.\n   * @returns {Object} The shived DocumentFragment.\n   */\n  function createDocumentFragment(ownerDocument, data){\n    if (!ownerDocument) {\n        ownerDocument = document;\n    }\n    if(supportsUnknownElements){\n        return ownerDocument.createDocumentFragment();\n    }\n    data = data || getExpandoData(ownerDocument);\n    var clone = data.frag.cloneNode(),\n        i = 0,\n        elems = getElements(),\n        l = elems.length;\n    for(;i<l;i++){\n        clone.createElement(elems[i]);\n    }\n    return clone;\n  }\n\n  /**\n   * Shivs the `createElement` and `createDocumentFragment` methods of the document.\n   * @private\n   * @param {Document|DocumentFragment} ownerDocument The document.\n   * @param {Object} data of the document.\n   */\n  function shivMethods(ownerDocument, data) {\n    if (!data.cache) {\n        data.cache = {};\n        data.createElem = ownerDocument.createElement;\n        data.createFrag = ownerDocument.createDocumentFragment;\n        data.frag = data.createFrag();\n    }\n\n\n    ownerDocument.createElement = function(nodeName) {\n      //abort shiv\n      if (!html5.shivMethods) {\n          return data.createElem(nodeName);\n      }\n      return createElement(nodeName, ownerDocument, data);\n    };\n\n    ownerDocument.createDocumentFragment = Function('h,f', 'return function(){' +\n      'var n=f.cloneNode(),c=n.createElement;' +\n      'h.shivMethods&&(' +\n        // unroll the `createElement` calls\n        getElements().join().replace(/([\\w\\-]|[\\w\\:])+/g, function(nodeName) {\n          data.createElem(nodeName);\n          data.frag.createElement(nodeName);\n          return 'c(\"' + nodeName + '\")';\n        }) +\n      ');return n}'\n    )(html5, data.frag);\n  }\n\n  /*--------------------------------------------------------------------------*/\n\n  /**\n   * Shivs the given document.\n   * @memberOf html5\n   * @param {Document} ownerDocument The document to shiv.\n   * @returns {Document} The shived document.\n   */\n  function shivDocument(ownerDocument) {\n    if (!ownerDocument) {\n        ownerDocument = document;\n    }\n    var data = getExpandoData(ownerDocument);\n\n    if (html5.shivCSS && !supportsHtml5Styles && !data.hasCSS) {\n      data.hasCSS = !!addStyleSheet(ownerDocument,\n        // corrects block display not defined in IE6/7/8/9\n        'article,aside,dialog,figcaption,figure,footer,header,hgroup,main,nav,section{display:block}' +\n        // adds styling not present in IE6/7/8/9\n        'mark{background:#FF0;color:#000}' +\n        // hides non-rendered elements\n        'template{display:none}'\n      );\n    }\n    if (!supportsUnknownElements) {\n      shivMethods(ownerDocument, data);\n    }\n    return ownerDocument;\n  }\n\n  /*--------------------------------------------------------------------------*/\n\n  /**\n   * The `html5` object is exposed so that more elements can be shived and\n   * existing shiving can be detected on iframes.\n   * @type Object\n   * @example\n   *\n   * // options can be changed before the script is included\n   * html5 = { 'elements': 'mark section', 'shivCSS': false, 'shivMethods': false };\n   */\n  var html5 = {\n\n    /**\n     * An array or space separated string of node names of the elements to shiv.\n     * @memberOf html5\n     * @type Array|String\n     */\n    'elements': options.elements || 'abbr article aside audio bdi canvas data datalist details dialog figcaption figure footer header hgroup main mark meter nav output progress section summary template time video',\n\n    /**\n     * current version of html5shiv\n     */\n    'version': version,\n\n    /**\n     * A flag to indicate that the HTML5 style sheet should be inserted.\n     * @memberOf html5\n     * @type Boolean\n     */\n    'shivCSS': (options.shivCSS !== false),\n\n    /**\n     * Is equal to true if a browser supports creating unknown/HTML5 elements\n     * @memberOf html5\n     * @type boolean\n     */\n    'supportsUnknownElements': supportsUnknownElements,\n\n    /**\n     * A flag to indicate that the document's `createElement` and `createDocumentFragment`\n     * methods should be overwritten.\n     * @memberOf html5\n     * @type Boolean\n     */\n    'shivMethods': (options.shivMethods !== false),\n\n    /**\n     * A string to describe the type of `html5` object (\"default\" or \"default print\").\n     * @memberOf html5\n     * @type String\n     */\n    'type': 'default',\n\n    // shivs the document according to the specified `html5` object options\n    'shivDocument': shivDocument,\n\n    //creates a shived element\n    createElement: createElement,\n\n    //creates a shived documentFragment\n    createDocumentFragment: createDocumentFragment\n  };\n\n  /*--------------------------------------------------------------------------*/\n\n  // expose html5\n  window.html5 = html5;\n\n  // shiv the document\n  shivDocument(document);\n\n}(this, document));");
/*jquery*/
System.define("jquery",'/*!\n * jQuery JavaScript Library v1.10.2\n * http://jquery.com/\n *\n * Includes Sizzle.js\n * http://sizzlejs.com/\n *\n * Copyright 2005, 2013 jQuery Foundation, Inc. and other contributors\n * Released under the MIT license\n * http://jquery.org/license\n *\n * Date: 2013-07-03T13:48Z\n */\n(function( window, undefined ) {\n\n// Can\'t do this because several apps including ASP.NET trace\n// the stack via arguments.caller.callee and Firefox dies if\n// you try to trace through "use strict" call chains. (#13335)\n// Support: Firefox 18+\n//"use strict";\n	var\n	// The deferred used on DOM ready\n		readyList,\n\n	// A central reference to the root jQuery(document)\n		rootjQuery,\n\n	// Support: IE<10\n	// For `typeof xmlNode.method` instead of `xmlNode.method !== undefined`\n		core_strundefined = typeof undefined,\n\n	// Use the correct document accordingly with window argument (sandbox)\n		location = window.location,\n		document = window.document,\n		docElem = document.documentElement,\n\n	// Map over jQuery in case of overwrite\n		_jQuery = window.jQuery,\n\n	// Map over the $ in case of overwrite\n		_$ = window.$,\n\n	// [[Class]] -> type pairs\n		class2type = {},\n\n	// List of deleted data cache ids, so we can reuse them\n		core_deletedIds = [],\n\n		core_version = "1.10.2",\n\n	// Save a reference to some core methods\n		core_concat = core_deletedIds.concat,\n		core_push = core_deletedIds.push,\n		core_slice = core_deletedIds.slice,\n		core_indexOf = core_deletedIds.indexOf,\n		core_toString = class2type.toString,\n		core_hasOwn = class2type.hasOwnProperty,\n		core_trim = core_version.trim,\n\n	// Define a local copy of jQuery\n		jQuery = function( selector, context ) {\n			// The jQuery object is actually just the init constructor \'enhanced\'\n			return new jQuery.fn.init( selector, context, rootjQuery );\n		},\n\n	// Used for matching numbers\n		core_pnum = /[+-]?(?:\\d*\\.|)\\d+(?:[eE][+-]?\\d+|)/.source,\n\n	// Used for splitting on whitespace\n		core_rnotwhite = /\\S+/g,\n\n	// Make sure we trim BOM and NBSP (here\'s looking at you, Safari 5.0 and IE)\n		rtrim = /^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g,\n\n	// A simple way to check for HTML strings\n	// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)\n	// Strict HTML recognition (#11290: must start with <)\n		rquickExpr = /^(?:\\s*(<[\\w\\W]+>)[^>]*|#([\\w-]*))$/,\n\n	// Match a standalone tag\n		rsingleTag = /^<(\\w+)\\s*\\/?>(?:<\\/\\1>|)$/,\n\n	// JSON RegExp\n		rvalidchars = /^[\\],:{}\\s]*$/,\n		rvalidbraces = /(?:^|:|,)(?:\\s*\\[)+/g,\n		rvalidescape = /\\\\(?:["\\\\\\/bfnrt]|u[\\da-fA-F]{4})/g,\n		rvalidtokens = /"[^"\\\\\\r\\n]*"|true|false|null|-?(?:\\d+\\.|)\\d+(?:[eE][+-]?\\d+|)/g,\n\n	// Matches dashed string for camelizing\n		rmsPrefix = /^-ms-/,\n		rdashAlpha = /-([\\da-z])/gi,\n\n	// Used by jQuery.camelCase as callback to replace()\n		fcamelCase = function( all, letter ) {\n			return letter.toUpperCase();\n		},\n\n	// The ready event handler\n		completed = function( event ) {\n\n			// readyState === "complete" is good enough for us to call the dom ready in oldIE\n			if ( document.addEventListener || event.type === "load" || document.readyState === "complete" ) {\n				detach();\n				jQuery.ready();\n			}\n		},\n	// Clean-up method for dom ready events\n		detach = function() {\n			if ( document.addEventListener ) {\n				document.removeEventListener( "DOMContentLoaded", completed, false );\n				window.removeEventListener( "load", completed, false );\n\n			} else {\n				document.detachEvent( "onreadystatechange", completed );\n				window.detachEvent( "onload", completed );\n			}\n		};\n\n	jQuery.fn = jQuery.prototype = {\n		// The current version of jQuery being used\n		jquery: core_version,\n\n		constructor: jQuery,\n		init: function( selector, context, rootjQuery ) {\n			var match, elem;\n\n			// HANDLE: $(""), $(null), $(undefined), $(false)\n			if ( !selector ) {\n				return this;\n			}\n\n			// Handle HTML strings\n			if ( typeof selector === "string" ) {\n				if ( selector.charAt(0) === "<" && selector.charAt( selector.length - 1 ) === ">" && selector.length >= 3 ) {\n					// Assume that strings that start and end with <> are HTML and skip the regex check\n					match = [ null, selector, null ];\n\n				} else {\n					match = rquickExpr.exec( selector );\n				}\n\n				// Match html or make sure no context is specified for #id\n				if ( match && (match[1] || !context) ) {\n\n					// HANDLE: $(html) -> $(array)\n					if ( match[1] ) {\n						context = context instanceof jQuery ? context[0] : context;\n\n						// scripts is true for back-compat\n						jQuery.merge( this, jQuery.parseHTML(\n							match[1],\n							context && context.nodeType ? context.ownerDocument || context : document,\n							true\n						) );\n\n						// HANDLE: $(html, props)\n						if ( rsingleTag.test( match[1] ) && jQuery.isPlainObject( context ) ) {\n							for ( match in context ) {\n								// Properties of context are called as methods if possible\n								if ( jQuery.isFunction( this[ match ] ) ) {\n									this[ match ]( context[ match ] );\n\n									// ...and otherwise set as attributes\n								} else {\n									this.attr( match, context[ match ] );\n								}\n							}\n						}\n\n						return this;\n\n						// HANDLE: $(#id)\n					} else {\n						elem = document.getElementById( match[2] );\n\n						// Check parentNode to catch when Blackberry 4.6 returns\n						// nodes that are no longer in the document #6963\n						if ( elem && elem.parentNode ) {\n							// Handle the case where IE and Opera return items\n							// by name instead of ID\n							if ( elem.id !== match[2] ) {\n								return rootjQuery.find( selector );\n							}\n\n							// Otherwise, we inject the element directly into the jQuery object\n							this.length = 1;\n							this[0] = elem;\n						}\n\n						this.context = document;\n						this.selector = selector;\n						return this;\n					}\n\n					// HANDLE: $(expr, $(...))\n				} else if ( !context || context.jquery ) {\n					return ( context || rootjQuery ).find( selector );\n\n					// HANDLE: $(expr, context)\n					// (which is just equivalent to: $(context).find(expr)\n				} else {\n					return this.constructor( context ).find( selector );\n				}\n\n				// HANDLE: $(DOMElement)\n			} else if ( selector.nodeType ) {\n				this.context = this[0] = selector;\n				this.length = 1;\n				return this;\n\n				// HANDLE: $(function)\n				// Shortcut for document ready\n			} else if ( jQuery.isFunction( selector ) ) {\n				return rootjQuery.ready( selector );\n			}\n\n			if ( selector.selector !== undefined ) {\n				this.selector = selector.selector;\n				this.context = selector.context;\n			}\n\n			return jQuery.makeArray( selector, this );\n		},\n\n		// Start with an empty selector\n		selector: "",\n\n		// The default length of a jQuery object is 0\n		length: 0,\n\n		toArray: function() {\n			return core_slice.call( this );\n		},\n\n		// Get the Nth element in the matched element set OR\n		// Get the whole matched element set as a clean array\n		get: function( num ) {\n			return num == null ?\n\n				// Return a \'clean\' array\n				this.toArray() :\n\n				// Return just the object\n				( num < 0 ? this[ this.length + num ] : this[ num ] );\n		},\n\n		// Take an array of elements and push it onto the stack\n		// (returning the new matched element set)\n		pushStack: function( elems ) {\n\n			// Build a new jQuery matched element set\n			var ret = jQuery.merge( this.constructor(), elems );\n\n			// Add the old object onto the stack (as a reference)\n			ret.prevObject = this;\n			ret.context = this.context;\n\n			// Return the newly-formed element set\n			return ret;\n		},\n\n		// Execute a callback for every element in the matched set.\n		// (You can seed the arguments with an array of args, but this is\n		// only used internally.)\n		each: function( callback, args ) {\n			return jQuery.each( this, callback, args );\n		},\n\n		ready: function( fn ) {\n			// Add the callback\n			jQuery.ready.promise().done( fn );\n\n			return this;\n		},\n\n		slice: function() {\n			return this.pushStack( core_slice.apply( this, arguments ) );\n		},\n\n		first: function() {\n			return this.eq( 0 );\n		},\n\n		last: function() {\n			return this.eq( -1 );\n		},\n\n		eq: function( i ) {\n			var len = this.length,\n				j = +i + ( i < 0 ? len : 0 );\n			return this.pushStack( j >= 0 && j < len ? [ this[j] ] : [] );\n		},\n\n		map: function( callback ) {\n			return this.pushStack( jQuery.map(this, function( elem, i ) {\n				return callback.call( elem, i, elem );\n			}));\n		},\n\n		end: function() {\n			return this.prevObject || this.constructor(null);\n		},\n\n		// For internal use only.\n		// Behaves like an Array\'s method, not like a jQuery method.\n		push: core_push,\n		sort: [].sort,\n		splice: [].splice\n	};\n\n// Give the init function the jQuery prototype for later instantiation\n	jQuery.fn.init.prototype = jQuery.fn;\n\n	jQuery.extend = jQuery.fn.extend = function() {\n		var src, copyIsArray, copy, name, options, clone,\n			target = arguments[0] || {},\n			i = 1,\n			length = arguments.length,\n			deep = false;\n\n		// Handle a deep copy situation\n		if ( typeof target === "boolean" ) {\n			deep = target;\n			target = arguments[1] || {};\n			// skip the boolean and the target\n			i = 2;\n		}\n\n		// Handle case when target is a string or something (possible in deep copy)\n		if ( typeof target !== "object" && !jQuery.isFunction(target) ) {\n			target = {};\n		}\n\n		// extend jQuery itself if only one argument is passed\n		if ( length === i ) {\n			target = this;\n			--i;\n		}\n\n		for ( ; i < length; i++ ) {\n			// Only deal with non-null/undefined values\n			if ( (options = arguments[ i ]) != null ) {\n				// Extend the base object\n				for ( name in options ) {\n					src = target[ name ];\n					copy = options[ name ];\n\n					// Prevent never-ending loop\n					if ( target === copy ) {\n						continue;\n					}\n\n					// Recurse if we\'re merging plain objects or arrays\n					if ( deep && copy && ( jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)) ) ) {\n						if ( copyIsArray ) {\n							copyIsArray = false;\n							clone = src && jQuery.isArray(src) ? src : [];\n\n						} else {\n							clone = src && jQuery.isPlainObject(src) ? src : {};\n						}\n\n						// Never move original objects, clone them\n						target[ name ] = jQuery.extend( deep, clone, copy );\n\n						// Don\'t bring in undefined values\n					} else if ( copy !== undefined ) {\n						target[ name ] = copy;\n					}\n				}\n			}\n		}\n\n		// Return the modified object\n		return target;\n	};\n\n	jQuery.extend({\n		// Unique for each copy of jQuery on the page\n		// Non-digits removed to match rinlinejQuery\n		expando: "jQuery" + ( core_version + Math.random() ).replace( /\\D/g, "" ),\n\n		noConflict: function( deep ) {\n			if ( window.$ === jQuery ) {\n				window.$ = _$;\n			}\n\n			if ( deep && window.jQuery === jQuery ) {\n				window.jQuery = _jQuery;\n			}\n\n			return jQuery;\n		},\n\n		// Is the DOM ready to be used? Set to true once it occurs.\n		isReady: false,\n\n		// A counter to track how many items to wait for before\n		// the ready event fires. See #6781\n		readyWait: 1,\n\n		// Hold (or release) the ready event\n		holdReady: function( hold ) {\n			if ( hold ) {\n				jQuery.readyWait++;\n			} else {\n				jQuery.ready( true );\n			}\n		},\n\n		// Handle when the DOM is ready\n		ready: function( wait ) {\n\n			// Abort if there are pending holds or we\'re already ready\n			if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {\n				return;\n			}\n\n			// Make sure body exists, at least, in case IE gets a little overzealous (ticket #5443).\n			if ( !document.body ) {\n				return setTimeout( jQuery.ready );\n			}\n\n			// Remember that the DOM is ready\n			jQuery.isReady = true;\n\n			// If a normal DOM Ready event fired, decrement, and wait if need be\n			if ( wait !== true && --jQuery.readyWait > 0 ) {\n				return;\n			}\n\n			// If there are functions bound, to execute\n			readyList.resolveWith( document, [ jQuery ] );\n\n			// Trigger any bound ready events\n			if ( jQuery.fn.trigger ) {\n				jQuery( document ).trigger("ready").off("ready");\n			}\n		},\n\n		// See test/unit/core.js for details concerning isFunction.\n		// Since version 1.3, DOM methods and functions like alert\n		// aren\'t supported. They return false on IE (#2968).\n		isFunction: function( obj ) {\n			return jQuery.type(obj) === "function";\n		},\n\n		isArray: Array.isArray || function( obj ) {\n			return jQuery.type(obj) === "array";\n		},\n\n		isWindow: function( obj ) {\n			/* jshint eqeqeq: false */\n			return obj != null && obj == obj.window;\n		},\n\n		isNumeric: function( obj ) {\n			return !isNaN( parseFloat(obj) ) && isFinite( obj );\n		},\n\n		type: function( obj ) {\n			if ( obj == null ) {\n				return String( obj );\n			}\n			return typeof obj === "object" || typeof obj === "function" ?\n				class2type[ core_toString.call(obj) ] || "object" :\n				typeof obj;\n		},\n\n		isPlainObject: function( obj ) {\n			var key;\n\n			// Must be an Object.\n			// Because of IE, we also have to check the presence of the constructor property.\n			// Make sure that DOM nodes and window objects don\'t pass through, as well\n			if ( !obj || jQuery.type(obj) !== "object" || obj.nodeType || jQuery.isWindow( obj ) ) {\n				return false;\n			}\n\n			try {\n				// Not own constructor property must be Object\n				if ( obj.constructor &&\n					!core_hasOwn.call(obj, "constructor") &&\n					!core_hasOwn.call(obj.constructor.prototype, "isPrototypeOf") ) {\n					return false;\n				}\n			} catch ( e ) {\n				// IE8,9 Will throw exceptions on certain host objects #9897\n				return false;\n			}\n\n			// Support: IE<9\n			// Handle iteration over inherited properties before own properties.\n			if ( jQuery.support.ownLast ) {\n				for ( key in obj ) {\n					return core_hasOwn.call( obj, key );\n				}\n			}\n\n			// Own properties are enumerated firstly, so to speed up,\n			// if last one is own, then all properties are own.\n			for ( key in obj ) {}\n\n			return key === undefined || core_hasOwn.call( obj, key );\n		},\n\n		isEmptyObject: function( obj ) {\n			var name;\n			for ( name in obj ) {\n				return false;\n			}\n			return true;\n		},\n\n		error: function( msg ) {\n			throw new Error( msg );\n		},\n\n		// data: string of html\n		// context (optional): If specified, the fragment will be created in this context, defaults to document\n		// keepScripts (optional): If true, will include scripts passed in the html string\n		parseHTML: function( data, context, keepScripts ) {\n			if ( !data || typeof data !== "string" ) {\n				return null;\n			}\n			if ( typeof context === "boolean" ) {\n				keepScripts = context;\n				context = false;\n			}\n			context = context || document;\n\n			var parsed = rsingleTag.exec( data ),\n				scripts = !keepScripts && [];\n\n			// Single tag\n			if ( parsed ) {\n				return [ context.createElement( parsed[1] ) ];\n			}\n\n			parsed = jQuery.buildFragment( [ data ], context, scripts );\n			if ( scripts ) {\n				jQuery( scripts ).remove();\n			}\n			return jQuery.merge( [], parsed.childNodes );\n		},\n\n		parseJSON: function( data ) {\n			// Attempt to parse using the native JSON parser first\n			if ( window.JSON && window.JSON.parse ) {\n				return window.JSON.parse( data );\n			}\n\n			if ( data === null ) {\n				return data;\n			}\n\n			if ( typeof data === "string" ) {\n\n				// Make sure leading/trailing whitespace is removed (IE can\'t handle it)\n				data = jQuery.trim( data );\n\n				if ( data ) {\n					// Make sure the incoming data is actual JSON\n					// Logic borrowed from http://json.org/json2.js\n					if ( rvalidchars.test( data.replace( rvalidescape, "@" )\n						.replace( rvalidtokens, "]" )\n						.replace( rvalidbraces, "")) ) {\n\n						return ( new Function( "return " + data ) )();\n					}\n				}\n			}\n\n			jQuery.error( "Invalid JSON: " + data );\n		},\n\n		// Cross-browser xml parsing\n		parseXML: function( data ) {\n			var xml, tmp;\n			if ( !data || typeof data !== "string" ) {\n				return null;\n			}\n			try {\n				if ( window.DOMParser ) { // Standard\n					tmp = new DOMParser();\n					xml = tmp.parseFromString( data , "text/xml" );\n				} else { // IE\n					xml = new ActiveXObject( "Microsoft.XMLDOM" );\n					xml.async = "false";\n					xml.loadXML( data );\n				}\n			} catch( e ) {\n				xml = undefined;\n			}\n			if ( !xml || !xml.documentElement || xml.getElementsByTagName( "parsererror" ).length ) {\n				jQuery.error( "Invalid XML: " + data );\n			}\n			return xml;\n		},\n\n		noop: function() {},\n\n		// Evaluates a script in a global context\n		// Workarounds based on findings by Jim Driscoll\n		// http://weblogs.java.net/blog/driscoll/archive/2009/09/08/eval-javascript-global-context\n		globalEval: function( data ) {\n			if ( data && jQuery.trim( data ) ) {\n				// We use execScript on Internet Explorer\n				// We use an anonymous function so that context is window\n				// rather than jQuery in Firefox\n				( window.execScript || function( data ) {\n					window[ "eval" ].call( window, data );\n				} )( data );\n			}\n		},\n\n		// Convert dashed to camelCase; used by the css and data modules\n		// Microsoft forgot to hump their vendor prefix (#9572)\n		camelCase: function( string ) {\n			return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );\n		},\n\n		nodeName: function( elem, name ) {\n			return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();\n		},\n\n		// args is for internal usage only\n		each: function( obj, callback, args ) {\n			var value,\n				i = 0,\n				length = obj.length,\n				isArray = isArraylike( obj );\n\n			if ( args ) {\n				if ( isArray ) {\n					for ( ; i < length; i++ ) {\n						value = callback.apply( obj[ i ], args );\n\n						if ( value === false ) {\n							break;\n						}\n					}\n				} else {\n					for ( i in obj ) {\n						value = callback.apply( obj[ i ], args );\n\n						if ( value === false ) {\n							break;\n						}\n					}\n				}\n\n				// A special, fast, case for the most common use of each\n			} else {\n				if ( isArray ) {\n					for ( ; i < length; i++ ) {\n						value = callback.call( obj[ i ], i, obj[ i ] );\n\n						if ( value === false ) {\n							break;\n						}\n					}\n				} else {\n					for ( i in obj ) {\n						value = callback.call( obj[ i ], i, obj[ i ] );\n\n						if ( value === false ) {\n							break;\n						}\n					}\n				}\n			}\n\n			return obj;\n		},\n\n		// Use native String.trim function wherever possible\n		trim: core_trim && !core_trim.call("\\uFEFF\\xA0") ?\n			function( text ) {\n				return text == null ?\n					"" :\n					core_trim.call( text );\n			} :\n\n			// Otherwise use our own trimming functionality\n			function( text ) {\n				return text == null ?\n					"" :\n					( text + "" ).replace( rtrim, "" );\n			},\n\n		// results is for internal usage only\n		makeArray: function( arr, results ) {\n			var ret = results || [];\n\n			if ( arr != null ) {\n				if ( isArraylike( Object(arr) ) ) {\n					jQuery.merge( ret,\n						typeof arr === "string" ?\n							[ arr ] : arr\n					);\n				} else {\n					core_push.call( ret, arr );\n				}\n			}\n\n			return ret;\n		},\n\n		inArray: function( elem, arr, i ) {\n			var len;\n\n			if ( arr ) {\n				if ( core_indexOf ) {\n					return core_indexOf.call( arr, elem, i );\n				}\n\n				len = arr.length;\n				i = i ? i < 0 ? Math.max( 0, len + i ) : i : 0;\n\n				for ( ; i < len; i++ ) {\n					// Skip accessing in sparse arrays\n					if ( i in arr && arr[ i ] === elem ) {\n						return i;\n					}\n				}\n			}\n\n			return -1;\n		},\n\n		merge: function( first, second ) {\n			var l = second.length,\n				i = first.length,\n				j = 0;\n\n			if ( typeof l === "number" ) {\n				for ( ; j < l; j++ ) {\n					first[ i++ ] = second[ j ];\n				}\n			} else {\n				while ( second[j] !== undefined ) {\n					first[ i++ ] = second[ j++ ];\n				}\n			}\n\n			first.length = i;\n\n			return first;\n		},\n\n		grep: function( elems, callback, inv ) {\n			var retVal,\n				ret = [],\n				i = 0,\n				length = elems.length;\n			inv = !!inv;\n\n			// Go through the array, only saving the items\n			// that pass the validator function\n			for ( ; i < length; i++ ) {\n				retVal = !!callback( elems[ i ], i );\n				if ( inv !== retVal ) {\n					ret.push( elems[ i ] );\n				}\n			}\n\n			return ret;\n		},\n\n		// arg is for internal usage only\n		map: function( elems, callback, arg ) {\n			var value,\n				i = 0,\n				length = elems.length,\n				isArray = isArraylike( elems ),\n				ret = [];\n\n			// Go through the array, translating each of the items to their\n			if ( isArray ) {\n				for ( ; i < length; i++ ) {\n					value = callback( elems[ i ], i, arg );\n\n					if ( value != null ) {\n						ret[ ret.length ] = value;\n					}\n				}\n\n				// Go through every key on the object,\n			} else {\n				for ( i in elems ) {\n					value = callback( elems[ i ], i, arg );\n\n					if ( value != null ) {\n						ret[ ret.length ] = value;\n					}\n				}\n			}\n\n			// Flatten any nested arrays\n			return core_concat.apply( [], ret );\n		},\n\n		// A global GUID counter for objects\n		guid: 1,\n\n		// Bind a function to a context, optionally partially applying any\n		// arguments.\n		proxy: function( fn, context ) {\n			var args, proxy, tmp;\n\n			if ( typeof context === "string" ) {\n				tmp = fn[ context ];\n				context = fn;\n				fn = tmp;\n			}\n\n			// Quick check to determine if target is callable, in the spec\n			// this throws a TypeError, but we will just return undefined.\n			if ( !jQuery.isFunction( fn ) ) {\n				return undefined;\n			}\n\n			// Simulated bind\n			args = core_slice.call( arguments, 2 );\n			proxy = function() {\n				return fn.apply( context || this, args.concat( core_slice.call( arguments ) ) );\n			};\n\n			// Set the guid of unique handler to the same of original handler, so it can be removed\n			proxy.guid = fn.guid = fn.guid || jQuery.guid++;\n\n			return proxy;\n		},\n\n		// Multifunctional method to get and set values of a collection\n		// The value/s can optionally be executed if it\'s a function\n		access: function( elems, fn, key, value, chainable, emptyGet, raw ) {\n			var i = 0,\n				length = elems.length,\n				bulk = key == null;\n\n			// Sets many values\n			if ( jQuery.type( key ) === "object" ) {\n				chainable = true;\n				for ( i in key ) {\n					jQuery.access( elems, fn, i, key[i], true, emptyGet, raw );\n				}\n\n				// Sets one value\n			} else if ( value !== undefined ) {\n				chainable = true;\n\n				if ( !jQuery.isFunction( value ) ) {\n					raw = true;\n				}\n\n				if ( bulk ) {\n					// Bulk operations run against the entire set\n					if ( raw ) {\n						fn.call( elems, value );\n						fn = null;\n\n						// ...except when executing function values\n					} else {\n						bulk = fn;\n						fn = function( elem, key, value ) {\n							return bulk.call( jQuery( elem ), value );\n						};\n					}\n				}\n\n				if ( fn ) {\n					for ( ; i < length; i++ ) {\n						fn( elems[i], key, raw ? value : value.call( elems[i], i, fn( elems[i], key ) ) );\n					}\n				}\n			}\n\n			return chainable ?\n				elems :\n\n				// Gets\n				bulk ?\n					fn.call( elems ) :\n					length ? fn( elems[0], key ) : emptyGet;\n		},\n\n		now: function() {\n			return ( new Date() ).getTime();\n		},\n\n		// A method for quickly swapping in/out CSS properties to get correct calculations.\n		// Note: this method belongs to the css module but it\'s needed here for the support module.\n		// If support gets modularized, this method should be moved back to the css module.\n		swap: function( elem, options, callback, args ) {\n			var ret, name,\n				old = {};\n\n			// Remember the old values, and insert the new ones\n			for ( name in options ) {\n				old[ name ] = elem.style[ name ];\n				elem.style[ name ] = options[ name ];\n			}\n\n			ret = callback.apply( elem, args || [] );\n\n			// Revert the old values\n			for ( name in options ) {\n				elem.style[ name ] = old[ name ];\n			}\n\n			return ret;\n		}\n	});\n\n	jQuery.ready.promise = function( obj ) {\n		if ( !readyList ) {\n\n			readyList = jQuery.Deferred();\n\n			// Catch cases where $(document).ready() is called after the browser event has already occurred.\n			// we once tried to use readyState "interactive" here, but it caused issues like the one\n			// discovered by ChrisS here: http://bugs.jquery.com/ticket/12282#comment:15\n			if ( document.readyState === "complete" ) {\n				// Handle it asynchronously to allow scripts the opportunity to delay ready\n				setTimeout( jQuery.ready );\n\n				// Standards-based browsers support DOMContentLoaded\n			} else if ( document.addEventListener ) {\n				// Use the handy event callback\n				document.addEventListener( "DOMContentLoaded", completed, false );\n\n				// A fallback to window.onload, that will always work\n				window.addEventListener( "load", completed, false );\n\n				// If IE event model is used\n			} else {\n				// Ensure firing before onload, maybe late but safe also for iframes\n				document.attachEvent( "onreadystatechange", completed );\n\n				// A fallback to window.onload, that will always work\n				window.attachEvent( "onload", completed );\n\n				// If IE and not a frame\n				// continually check to see if the document is ready\n				var top = false;\n\n				try {\n					top = window.frameElement == null && document.documentElement;\n				} catch(e) {}\n\n				if ( top && top.doScroll ) {\n					(function doScrollCheck() {\n						if ( !jQuery.isReady ) {\n\n							try {\n								// Use the trick by Diego Perini\n								// http://javascript.nwbox.com/IEContentLoaded/\n								top.doScroll("left");\n							} catch(e) {\n								return setTimeout( doScrollCheck, 50 );\n							}\n\n							// detach all dom ready events\n							detach();\n\n							// and execute any waiting functions\n							jQuery.ready();\n						}\n					})();\n				}\n			}\n		}\n		return readyList.promise( obj );\n	};\n\n// Populate the class2type map\n	jQuery.each("Boolean Number String Function Array Date RegExp Object Error".split(" "), function(i, name) {\n		class2type[ "[object " + name + "]" ] = name.toLowerCase();\n	});\n\n	function isArraylike( obj ) {\n		var length = obj.length,\n			type = jQuery.type( obj );\n\n		if ( jQuery.isWindow( obj ) ) {\n			return false;\n		}\n\n		if ( obj.nodeType === 1 && length ) {\n			return true;\n		}\n\n		return type === "array" || type !== "function" &&\n			( length === 0 ||\n				typeof length === "number" && length > 0 && ( length - 1 ) in obj );\n	}\n\n// All jQuery objects should point back to these\n	rootjQuery = jQuery(document);\n	/*!\n	 * Sizzle CSS Selector Engine v1.10.2\n	 * http://sizzlejs.com/\n	 *\n	 * Copyright 2013 jQuery Foundation, Inc. and other contributors\n	 * Released under the MIT license\n	 * http://jquery.org/license\n	 *\n	 * Date: 2013-07-03\n	 */\n	(function( window, undefined ) {\n\n		var i,\n			support,\n			cachedruns,\n			Expr,\n			getText,\n			isXML,\n			compile,\n			outermostContext,\n			sortInput,\n\n		// Local document vars\n			setDocument,\n			document,\n			docElem,\n			documentIsHTML,\n			rbuggyQSA,\n			rbuggyMatches,\n			matches,\n			contains,\n\n		// Instance-specific data\n			expando = "sizzle" + -(new Date()),\n			preferredDoc = window.document,\n			dirruns = 0,\n			done = 0,\n			classCache = createCache(),\n			tokenCache = createCache(),\n			compilerCache = createCache(),\n			hasDuplicate = false,\n			sortOrder = function( a, b ) {\n				if ( a === b ) {\n					hasDuplicate = true;\n					return 0;\n				}\n				return 0;\n			},\n\n		// General-purpose constants\n			strundefined = typeof undefined,\n			MAX_NEGATIVE = 1 << 31,\n\n		// Instance methods\n			hasOwn = ({}).hasOwnProperty,\n			arr = [],\n			pop = arr.pop,\n			push_native = arr.push,\n			push = arr.push,\n			slice = arr.slice,\n		// Use a stripped-down indexOf if we can\'t use a native one\n			indexOf = arr.indexOf || function( elem ) {\n				var i = 0,\n					len = this.length;\n				for ( ; i < len; i++ ) {\n					if ( this[i] === elem ) {\n						return i;\n					}\n				}\n				return -1;\n			},\n\n			booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",\n\n		// Regular expressions\n\n		// Whitespace characters http://www.w3.org/TR/css3-selectors/#whitespace\n			whitespace = "[\\\\x20\\\\t\\\\r\\\\n\\\\f]",\n		// http://www.w3.org/TR/css3-syntax/#characters\n			characterEncoding = "(?:\\\\\\\\.|[\\\\w-]|[^\\\\x00-\\\\xa0])+",\n\n		// Loosely modeled on CSS identifier characters\n		// An unquoted value should be a CSS identifier http://www.w3.org/TR/css3-selectors/#attribute-selectors\n		// Proper syntax: http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier\n			identifier = characterEncoding.replace( "w", "w#" ),\n\n		// Acceptable operators http://www.w3.org/TR/selectors/#attribute-selectors\n			attributes = "\\\\[" + whitespace + "*(" + characterEncoding + ")" + whitespace +\n				"*(?:([*^$|!~]?=)" + whitespace + "*(?:([\'\\"])((?:\\\\\\\\.|[^\\\\\\\\])*?)\\\\3|(" + identifier + ")|)|)" + whitespace + "*\\\\]",\n\n		// Prefer arguments quoted,\n		//   then not containing pseudos/brackets,\n		//   then attribute selectors/non-parenthetical expressions,\n		//   then anything else\n		// These preferences are here to reduce the number of selectors\n		//   needing tokenize in the PSEUDO preFilter\n			pseudos = ":(" + characterEncoding + ")(?:\\\\((([\'\\"])((?:\\\\\\\\.|[^\\\\\\\\])*?)\\\\3|((?:\\\\\\\\.|[^\\\\\\\\()[\\\\]]|" + attributes.replace( 3, 8 ) + ")*)|.*)\\\\)|)",\n\n		// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter\n			rtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\\\\\])(?:\\\\\\\\.)*)" + whitespace + "+$", "g" ),\n\n			rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),\n			rcombinators = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*" ),\n\n			rsibling = new RegExp( whitespace + "*[+~]" ),\n			rattributeQuotes = new RegExp( "=" + whitespace + "*([^\\\\]\'\\"]*)" + whitespace + "*\\\\]", "g" ),\n\n			rpseudo = new RegExp( pseudos ),\n			ridentifier = new RegExp( "^" + identifier + "$" ),\n\n			matchExpr = {\n				"ID": new RegExp( "^#(" + characterEncoding + ")" ),\n				"CLASS": new RegExp( "^\\\\.(" + characterEncoding + ")" ),\n				"TAG": new RegExp( "^(" + characterEncoding.replace( "w", "w*" ) + ")" ),\n				"ATTR": new RegExp( "^" + attributes ),\n				"PSEUDO": new RegExp( "^" + pseudos ),\n				"CHILD": new RegExp( "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\\\(" + whitespace +\n					"*(even|odd|(([+-]|)(\\\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace +\n					"*(\\\\d+)|))" + whitespace + "*\\\\)|)", "i" ),\n				"bool": new RegExp( "^(?:" + booleans + ")$", "i" ),\n				// For use in libraries implementing .is()\n				// We use this for POS matching in `select`\n				"needsContext": new RegExp( "^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\\\(" +\n					whitespace + "*((?:-\\\\d)?\\\\d*)" + whitespace + "*\\\\)|)(?=[^-]|$)", "i" )\n			},\n\n			rnative = /^[^{]+\\{\\s*\\[native \\w/,\n\n		// Easily-parseable/retrievable ID or TAG or CLASS selectors\n			rquickExpr = /^(?:#([\\w-]+)|(\\w+)|\\.([\\w-]+))$/,\n\n			rinputs = /^(?:input|select|textarea|button)$/i,\n			rheader = /^h\\d$/i,\n\n			rescape = /\'|\\\\/g,\n\n		// CSS escapes http://www.w3.org/TR/CSS21/syndata.html#escaped-characters\n			runescape = new RegExp( "\\\\\\\\([\\\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig" ),\n			funescape = function( _, escaped, escapedWhitespace ) {\n				var high = "0x" + escaped - 0x10000;\n				// NaN means non-codepoint\n				// Support: Firefox\n				// Workaround erroneous numeric interpretation of +"0x"\n				return high !== high || escapedWhitespace ?\n					escaped :\n					// BMP codepoint\n					high < 0 ?\n						String.fromCharCode( high + 0x10000 ) :\n						// Supplemental Plane codepoint (surrogate pair)\n						String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );\n			};\n\n// Optimize for push.apply( _, NodeList )\n		try {\n			push.apply(\n				(arr = slice.call( preferredDoc.childNodes )),\n				preferredDoc.childNodes\n			);\n			// Support: Android<4.0\n			// Detect silently failing push.apply\n			arr[ preferredDoc.childNodes.length ].nodeType;\n		} catch ( e ) {\n			push = { apply: arr.length ?\n\n				// Leverage slice if possible\n				function( target, els ) {\n					push_native.apply( target, slice.call(els) );\n				} :\n\n				// Support: IE<9\n				// Otherwise append directly\n				function( target, els ) {\n					var j = target.length,\n						i = 0;\n					// Can\'t trust NodeList.length\n					while ( (target[j++] = els[i++]) ) {}\n					target.length = j - 1;\n				}\n			};\n		}\n\n		function Sizzle( selector, context, results, seed ) {\n			var match, elem, m, nodeType,\n			// QSA vars\n				i, groups, old, nid, newContext, newSelector;\n\n			if ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {\n				setDocument( context );\n			}\n\n			context = context || document;\n			results = results || [];\n\n			if ( !selector || typeof selector !== "string" ) {\n				return results;\n			}\n\n			if ( (nodeType = context.nodeType) !== 1 && nodeType !== 9 ) {\n				return [];\n			}\n\n			if ( documentIsHTML && !seed ) {\n\n				// Shortcuts\n				if ( (match = rquickExpr.exec( selector )) ) {\n					// Speed-up: Sizzle("#ID")\n					if ( (m = match[1]) ) {\n						if ( nodeType === 9 ) {\n							elem = context.getElementById( m );\n							// Check parentNode to catch when Blackberry 4.6 returns\n							// nodes that are no longer in the document #6963\n							if ( elem && elem.parentNode ) {\n								// Handle the case where IE, Opera, and Webkit return items\n								// by name instead of ID\n								if ( elem.id === m ) {\n									results.push( elem );\n									return results;\n								}\n							} else {\n								return results;\n							}\n						} else {\n							// Context is not a document\n							if ( context.ownerDocument && (elem = context.ownerDocument.getElementById( m )) &&\n								contains( context, elem ) && elem.id === m ) {\n								results.push( elem );\n								return results;\n							}\n						}\n\n						// Speed-up: Sizzle("TAG")\n					} else if ( match[2] ) {\n						push.apply( results, context.getElementsByTagName( selector ) );\n						return results;\n\n						// Speed-up: Sizzle(".CLASS")\n					} else if ( (m = match[3]) && support.getElementsByClassName && context.getElementsByClassName ) {\n						push.apply( results, context.getElementsByClassName( m ) );\n						return results;\n					}\n				}\n\n				// QSA path\n				if ( support.qsa && (!rbuggyQSA || !rbuggyQSA.test( selector )) ) {\n					nid = old = expando;\n					newContext = context;\n					newSelector = nodeType === 9 && selector;\n\n					// qSA works strangely on Element-rooted queries\n					// We can work around this by specifying an extra ID on the root\n					// and working up from there (Thanks to Andrew Dupont for the technique)\n					// IE 8 doesn\'t work on object elements\n					if ( nodeType === 1 && context.nodeName.toLowerCase() !== "object" ) {\n						groups = tokenize( selector );\n\n						if ( (old = context.getAttribute("id")) ) {\n							nid = old.replace( rescape, "\\\\$&" );\n						} else {\n							context.setAttribute( "id", nid );\n						}\n						nid = "[id=\'" + nid + "\'] ";\n\n						i = groups.length;\n						while ( i-- ) {\n							groups[i] = nid + toSelector( groups[i] );\n						}\n						newContext = rsibling.test( selector ) && context.parentNode || context;\n						newSelector = groups.join(",");\n					}\n\n					if ( newSelector ) {\n						try {\n							push.apply( results,\n								newContext.querySelectorAll( newSelector )\n							);\n							return results;\n						} catch(qsaError) {\n						} finally {\n							if ( !old ) {\n								context.removeAttribute("id");\n							}\n						}\n					}\n				}\n			}\n\n			// All others\n			return select( selector.replace( rtrim, "$1" ), context, results, seed );\n		}\n\n		/**\n		 * Create key-value caches of limited size\n		 * @returns {Function(string, Object)} Returns the Object data after storing it on itself with\n		 *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)\n		 *	deleting the oldest entry\n		 */\n		function createCache() {\n			var keys = [];\n\n			function cache( key, value ) {\n				// Use (key + " ") to avoid collision with native prototype properties (see Issue #157)\n				if ( keys.push( key += " " ) > Expr.cacheLength ) {\n					// Only keep the most recent entries\n					delete cache[ keys.shift() ];\n				}\n				return (cache[ key ] = value);\n			}\n			return cache;\n		}\n\n		/**\n		 * Mark a function for special use by Sizzle\n		 * @param {Function} fn The function to mark\n		 */\n		function markFunction( fn ) {\n			fn[ expando ] = true;\n			return fn;\n		}\n\n		/**\n		 * Support testing using an element\n		 * @param {Function} fn Passed the created div and expects a boolean result\n		 */\n		function assert( fn ) {\n			var div = document.createElement("div");\n\n			try {\n				return !!fn( div );\n			} catch (e) {\n				return false;\n			} finally {\n				// Remove from its parent by default\n				if ( div.parentNode ) {\n					div.parentNode.removeChild( div );\n				}\n				// release memory in IE\n				div = null;\n			}\n		}\n\n		/**\n		 * Adds the same handler for all of the specified attrs\n		 * @param {String} attrs Pipe-separated list of attributes\n		 * @param {Function} handler The method that will be applied\n		 */\n		function addHandle( attrs, handler ) {\n			var arr = attrs.split("|"),\n				i = attrs.length;\n\n			while ( i-- ) {\n				Expr.attrHandle[ arr[i] ] = handler;\n			}\n		}\n\n		/**\n		 * Checks document order of two siblings\n		 * @param {Element} a\n		 * @param {Element} b\n		 * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b\n		 */\n		function siblingCheck( a, b ) {\n			var cur = b && a,\n				diff = cur && a.nodeType === 1 && b.nodeType === 1 &&\n					( ~b.sourceIndex || MAX_NEGATIVE ) -\n						( ~a.sourceIndex || MAX_NEGATIVE );\n\n			// Use IE sourceIndex if available on both nodes\n			if ( diff ) {\n				return diff;\n			}\n\n			// Check if b follows a\n			if ( cur ) {\n				while ( (cur = cur.nextSibling) ) {\n					if ( cur === b ) {\n						return -1;\n					}\n				}\n			}\n\n			return a ? 1 : -1;\n		}\n\n		/**\n		 * Returns a function to use in pseudos for input types\n		 * @param {String} type\n		 */\n		function createInputPseudo( type ) {\n			return function( elem ) {\n				var name = elem.nodeName.toLowerCase();\n				return name === "input" && elem.type === type;\n			};\n		}\n\n		/**\n		 * Returns a function to use in pseudos for buttons\n		 * @param {String} type\n		 */\n		function createButtonPseudo( type ) {\n			return function( elem ) {\n				var name = elem.nodeName.toLowerCase();\n				return (name === "input" || name === "button") && elem.type === type;\n			};\n		}\n\n		/**\n		 * Returns a function to use in pseudos for positionals\n		 * @param {Function} fn\n		 */\n		function createPositionalPseudo( fn ) {\n			return markFunction(function( argument ) {\n				argument = +argument;\n				return markFunction(function( seed, matches ) {\n					var j,\n						matchIndexes = fn( [], seed.length, argument ),\n						i = matchIndexes.length;\n\n					// Match elements found at the specified indexes\n					while ( i-- ) {\n						if ( seed[ (j = matchIndexes[i]) ] ) {\n							seed[j] = !(matches[j] = seed[j]);\n						}\n					}\n				});\n			});\n		}\n\n		/**\n		 * Detect xml\n		 * @param {Element|Object} elem An element or a document\n		 */\n		isXML = Sizzle.isXML = function( elem ) {\n			// documentElement is verified for cases where it doesn\'t yet exist\n			// (such as loading iframes in IE - #4833)\n			var documentElement = elem && (elem.ownerDocument || elem).documentElement;\n			return documentElement ? documentElement.nodeName !== "HTML" : false;\n		};\n\n// Expose support vars for convenience\n		support = Sizzle.support = {};\n\n		/**\n		 * Sets document-related variables once based on the current document\n		 * @param {Element|Object} [doc] An element or document object to use to set the document\n		 * @returns {Object} Returns the current document\n		 */\n		setDocument = Sizzle.setDocument = function( node ) {\n			var doc = node ? node.ownerDocument || node : preferredDoc,\n				parent = doc.defaultView;\n\n			// If no document and documentElement is available, return\n			if ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {\n				return document;\n			}\n\n			// Set our document\n			document = doc;\n			docElem = doc.documentElement;\n\n			// Support tests\n			documentIsHTML = !isXML( doc );\n\n			// Support: IE>8\n			// If iframe document is assigned to "document" variable and if iframe has been reloaded,\n			// IE will throw "permission denied" error when accessing "document" variable, see jQuery #13936\n			// IE6-8 do not support the defaultView property so parent will be undefined\n			if ( parent && parent.attachEvent && parent !== parent.top ) {\n				parent.attachEvent( "onbeforeunload", function() {\n					setDocument();\n				});\n			}\n\n			/* Attributes\n			 ---------------------------------------------------------------------- */\n\n			// Support: IE<8\n			// Verify that getAttribute really returns attributes and not properties (excepting IE8 booleans)\n			support.attributes = assert(function( div ) {\n				div.className = "i";\n				return !div.getAttribute("className");\n			});\n\n			/* getElement(s)By*\n			 ---------------------------------------------------------------------- */\n\n			// Check if getElementsByTagName("*") returns only elements\n			support.getElementsByTagName = assert(function( div ) {\n				div.appendChild( doc.createComment("") );\n				return !div.getElementsByTagName("*").length;\n			});\n\n			// Check if getElementsByClassName can be trusted\n			support.getElementsByClassName = assert(function( div ) {\n				div.innerHTML = "<div class=\'a\'></div><div class=\'a i\'></div>";\n\n				// Support: Safari<4\n				// Catch class over-caching\n				div.firstChild.className = "i";\n				// Support: Opera<10\n				// Catch gEBCN failure to find non-leading classes\n				return div.getElementsByClassName("i").length === 2;\n			});\n\n			// Support: IE<10\n			// Check if getElementById returns elements by name\n			// The broken getElementById methods don\'t pick up programatically-set names,\n			// so use a roundabout getElementsByName test\n			support.getById = assert(function( div ) {\n				docElem.appendChild( div ).id = expando;\n				return !doc.getElementsByName || !doc.getElementsByName( expando ).length;\n			});\n\n			// ID find and filter\n			if ( support.getById ) {\n				Expr.find["ID"] = function( id, context ) {\n					if ( typeof context.getElementById !== strundefined && documentIsHTML ) {\n						var m = context.getElementById( id );\n						// Check parentNode to catch when Blackberry 4.6 returns\n						// nodes that are no longer in the document #6963\n						return m && m.parentNode ? [m] : [];\n					}\n				};\n				Expr.filter["ID"] = function( id ) {\n					var attrId = id.replace( runescape, funescape );\n					return function( elem ) {\n						return elem.getAttribute("id") === attrId;\n					};\n				};\n			} else {\n				// Support: IE6/7\n				// getElementById is not reliable as a find shortcut\n				delete Expr.find["ID"];\n\n				Expr.filter["ID"] =  function( id ) {\n					var attrId = id.replace( runescape, funescape );\n					return function( elem ) {\n						var node = typeof elem.getAttributeNode !== strundefined && elem.getAttributeNode("id");\n						return node && node.value === attrId;\n					};\n				};\n			}\n\n			// Tag\n			Expr.find["TAG"] = support.getElementsByTagName ?\n				function( tag, context ) {\n					if ( typeof context.getElementsByTagName !== strundefined ) {\n						return context.getElementsByTagName( tag );\n					}\n				} :\n				function( tag, context ) {\n					var elem,\n						tmp = [],\n						i = 0,\n						results = context.getElementsByTagName( tag );\n\n					// Filter out possible comments\n					if ( tag === "*" ) {\n						while ( (elem = results[i++]) ) {\n							if ( elem.nodeType === 1 ) {\n								tmp.push( elem );\n							}\n						}\n\n						return tmp;\n					}\n					return results;\n				};\n\n			// Class\n			Expr.find["CLASS"] = support.getElementsByClassName && function( className, context ) {\n				if ( typeof context.getElementsByClassName !== strundefined && documentIsHTML ) {\n					return context.getElementsByClassName( className );\n				}\n			};\n\n			/* QSA/matchesSelector\n			 ---------------------------------------------------------------------- */\n\n			// QSA and matchesSelector support\n\n			// matchesSelector(:active) reports false when true (IE9/Opera 11.5)\n			rbuggyMatches = [];\n\n			// qSa(:focus) reports false when true (Chrome 21)\n			// We allow this because of a bug in IE8/9 that throws an error\n			// whenever `document.activeElement` is accessed on an iframe\n			// So, we allow :focus to pass through QSA all the time to avoid the IE error\n			// See http://bugs.jquery.com/ticket/13378\n			rbuggyQSA = [];\n\n			if ( (support.qsa = rnative.test( doc.querySelectorAll )) ) {\n				// Build QSA regex\n				// Regex strategy adopted from Diego Perini\n				assert(function( div ) {\n					// Select is set to empty string on purpose\n					// This is to test IE\'s treatment of not explicitly\n					// setting a boolean content attribute,\n					// since its presence should be enough\n					// http://bugs.jquery.com/ticket/12359\n					div.innerHTML = "<select><option selected=\'\'></option></select>";\n\n					// Support: IE8\n					// Boolean attributes and "value" are not treated correctly\n					if ( !div.querySelectorAll("[selected]").length ) {\n						rbuggyQSA.push( "\\\\[" + whitespace + "*(?:value|" + booleans + ")" );\n					}\n\n					// Webkit/Opera - :checked should return selected option elements\n					// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\n					// IE8 throws error here and will not see later tests\n					if ( !div.querySelectorAll(":checked").length ) {\n						rbuggyQSA.push(":checked");\n					}\n				});\n\n				assert(function( div ) {\n\n					// Support: Opera 10-12/IE8\n					// ^= $= *= and empty values\n					// Should not select anything\n					// Support: Windows 8 Native Apps\n					// The type attribute is restricted during .innerHTML assignment\n					var input = doc.createElement("input");\n					input.setAttribute( "type", "hidden" );\n					div.appendChild( input ).setAttribute( "t", "" );\n\n					if ( div.querySelectorAll("[t^=\'\']").length ) {\n						rbuggyQSA.push( "[*^$]=" + whitespace + "*(?:\'\'|\\"\\")" );\n					}\n\n					// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)\n					// IE8 throws error here and will not see later tests\n					if ( !div.querySelectorAll(":enabled").length ) {\n						rbuggyQSA.push( ":enabled", ":disabled" );\n					}\n\n					// Opera 10-11 does not throw on post-comma invalid pseudos\n					div.querySelectorAll("*,:x");\n					rbuggyQSA.push(",.*:");\n				});\n			}\n\n			if ( (support.matchesSelector = rnative.test( (matches = docElem.webkitMatchesSelector ||\n				docElem.mozMatchesSelector ||\n				docElem.oMatchesSelector ||\n				docElem.msMatchesSelector) )) ) {\n\n				assert(function( div ) {\n					// Check to see if it\'s possible to do matchesSelector\n					// on a disconnected node (IE 9)\n					support.disconnectedMatch = matches.call( div, "div" );\n\n					// This should fail with an exception\n					// Gecko does not error, returns false instead\n					matches.call( div, "[s!=\'\']:x" );\n					rbuggyMatches.push( "!=", pseudos );\n				});\n			}\n\n			rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join("|") );\n			rbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join("|") );\n\n			/* Contains\n			 ---------------------------------------------------------------------- */\n\n			// Element contains another\n			// Purposefully does not implement inclusive descendent\n			// As in, an element does not contain itself\n			contains = rnative.test( docElem.contains ) || docElem.compareDocumentPosition ?\n				function( a, b ) {\n					var adown = a.nodeType === 9 ? a.documentElement : a,\n						bup = b && b.parentNode;\n					return a === bup || !!( bup && bup.nodeType === 1 && (\n						adown.contains ?\n							adown.contains( bup ) :\n							a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16\n						));\n				} :\n				function( a, b ) {\n					if ( b ) {\n						while ( (b = b.parentNode) ) {\n							if ( b === a ) {\n								return true;\n							}\n						}\n					}\n					return false;\n				};\n\n			/* Sorting\n			 ---------------------------------------------------------------------- */\n\n			// Document order sorting\n			sortOrder = docElem.compareDocumentPosition ?\n				function( a, b ) {\n\n					// Flag for duplicate removal\n					if ( a === b ) {\n						hasDuplicate = true;\n						return 0;\n					}\n\n					var compare = b.compareDocumentPosition && a.compareDocumentPosition && a.compareDocumentPosition( b );\n\n					if ( compare ) {\n						// Disconnected nodes\n						if ( compare & 1 ||\n							(!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {\n\n							// Choose the first element that is related to our preferred document\n							if ( a === doc || contains(preferredDoc, a) ) {\n								return -1;\n							}\n							if ( b === doc || contains(preferredDoc, b) ) {\n								return 1;\n							}\n\n							// Maintain original order\n							return sortInput ?\n								( indexOf.call( sortInput, a ) - indexOf.call( sortInput, b ) ) :\n								0;\n						}\n\n						return compare & 4 ? -1 : 1;\n					}\n\n					// Not directly comparable, sort on existence of method\n					return a.compareDocumentPosition ? -1 : 1;\n				} :\n				function( a, b ) {\n					var cur,\n						i = 0,\n						aup = a.parentNode,\n						bup = b.parentNode,\n						ap = [ a ],\n						bp = [ b ];\n\n					// Exit early if the nodes are identical\n					if ( a === b ) {\n						hasDuplicate = true;\n						return 0;\n\n						// Parentless nodes are either documents or disconnected\n					} else if ( !aup || !bup ) {\n						return a === doc ? -1 :\n							b === doc ? 1 :\n								aup ? -1 :\n									bup ? 1 :\n										sortInput ?\n											( indexOf.call( sortInput, a ) - indexOf.call( sortInput, b ) ) :\n											0;\n\n						// If the nodes are siblings, we can do a quick check\n					} else if ( aup === bup ) {\n						return siblingCheck( a, b );\n					}\n\n					// Otherwise we need full lists of their ancestors for comparison\n					cur = a;\n					while ( (cur = cur.parentNode) ) {\n						ap.unshift( cur );\n					}\n					cur = b;\n					while ( (cur = cur.parentNode) ) {\n						bp.unshift( cur );\n					}\n\n					// Walk down the tree looking for a discrepancy\n					while ( ap[i] === bp[i] ) {\n						i++;\n					}\n\n					return i ?\n						// Do a sibling check if the nodes have a common ancestor\n						siblingCheck( ap[i], bp[i] ) :\n\n						// Otherwise nodes in our document sort first\n						ap[i] === preferredDoc ? -1 :\n							bp[i] === preferredDoc ? 1 :\n								0;\n				};\n\n			return doc;\n		};\n\n		Sizzle.matches = function( expr, elements ) {\n			return Sizzle( expr, null, null, elements );\n		};\n\n		Sizzle.matchesSelector = function( elem, expr ) {\n			// Set document vars if needed\n			if ( ( elem.ownerDocument || elem ) !== document ) {\n				setDocument( elem );\n			}\n\n			// Make sure that attribute selectors are quoted\n			expr = expr.replace( rattributeQuotes, "=\'$1\']" );\n\n			if ( support.matchesSelector && documentIsHTML &&\n				( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&\n				( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {\n\n				try {\n					var ret = matches.call( elem, expr );\n\n					// IE 9\'s matchesSelector returns false on disconnected nodes\n					if ( ret || support.disconnectedMatch ||\n						// As well, disconnected nodes are said to be in a document\n						// fragment in IE 9\n						elem.document && elem.document.nodeType !== 11 ) {\n						return ret;\n					}\n				} catch(e) {}\n			}\n\n			return Sizzle( expr, document, null, [elem] ).length > 0;\n		};\n\n		Sizzle.contains = function( context, elem ) {\n			// Set document vars if needed\n			if ( ( context.ownerDocument || context ) !== document ) {\n				setDocument( context );\n			}\n			return contains( context, elem );\n		};\n\n		Sizzle.attr = function( elem, name ) {\n			// Set document vars if needed\n			if ( ( elem.ownerDocument || elem ) !== document ) {\n				setDocument( elem );\n			}\n\n			var fn = Expr.attrHandle[ name.toLowerCase() ],\n			// Don\'t get fooled by Object.prototype properties (jQuery #13807)\n				val = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?\n					fn( elem, name, !documentIsHTML ) :\n					undefined;\n\n			return val === undefined ?\n				support.attributes || !documentIsHTML ?\n					elem.getAttribute( name ) :\n					(val = elem.getAttributeNode(name)) && val.specified ?\n						val.value :\n						null :\n				val;\n		};\n\n		Sizzle.error = function( msg ) {\n			throw new Error( "Syntax error, unrecognized expression: " + msg );\n		};\n\n		/**\n		 * Document sorting and removing duplicates\n		 * @param {ArrayLike} results\n		 */\n		Sizzle.uniqueSort = function( results ) {\n			var elem,\n				duplicates = [],\n				j = 0,\n				i = 0;\n\n			// Unless we *know* we can detect duplicates, assume their presence\n			hasDuplicate = !support.detectDuplicates;\n			sortInput = !support.sortStable && results.slice( 0 );\n			results.sort( sortOrder );\n\n			if ( hasDuplicate ) {\n				while ( (elem = results[i++]) ) {\n					if ( elem === results[ i ] ) {\n						j = duplicates.push( i );\n					}\n				}\n				while ( j-- ) {\n					results.splice( duplicates[ j ], 1 );\n				}\n			}\n\n			return results;\n		};\n\n		/**\n		 * Utility function for retrieving the text value of an array of DOM nodes\n		 * @param {Array|Element} elem\n		 */\n		getText = Sizzle.getText = function( elem ) {\n			var node,\n				ret = "",\n				i = 0,\n				nodeType = elem.nodeType;\n\n			if ( !nodeType ) {\n				// If no nodeType, this is expected to be an array\n				for ( ; (node = elem[i]); i++ ) {\n					// Do not traverse comment nodes\n					ret += getText( node );\n				}\n			} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {\n				// Use textContent for elements\n				// innerText usage removed for consistency of new lines (see #11153)\n				if ( typeof elem.textContent === "string" ) {\n					return elem.textContent;\n				} else {\n					// Traverse its children\n					for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {\n						ret += getText( elem );\n					}\n				}\n			} else if ( nodeType === 3 || nodeType === 4 ) {\n				return elem.nodeValue;\n			}\n			// Do not include comment or processing instruction nodes\n\n			return ret;\n		};\n\n		Expr = Sizzle.selectors = {\n\n			// Can be adjusted by the user\n			cacheLength: 50,\n\n			createPseudo: markFunction,\n\n			match: matchExpr,\n\n			attrHandle: {},\n\n			find: {},\n\n			relative: {\n				">": { dir: "parentNode", first: true },\n				" ": { dir: "parentNode" },\n				"+": { dir: "previousSibling", first: true },\n				"~": { dir: "previousSibling" }\n			},\n\n			preFilter: {\n				"ATTR": function( match ) {\n					match[1] = match[1].replace( runescape, funescape );\n\n					// Move the given value to match[3] whether quoted or unquoted\n					match[3] = ( match[4] || match[5] || "" ).replace( runescape, funescape );\n\n					if ( match[2] === "~=" ) {\n						match[3] = " " + match[3] + " ";\n					}\n\n					return match.slice( 0, 4 );\n				},\n\n				"CHILD": function( match ) {\n					/* matches from matchExpr["CHILD"]\n					 1 type (only|nth|...)\n					 2 what (child|of-type)\n					 3 argument (even|odd|\\d*|\\d*n([+-]\\d+)?|...)\n					 4 xn-component of xn+y argument ([+-]?\\d*n|)\n					 5 sign of xn-component\n					 6 x of xn-component\n					 7 sign of y-component\n					 8 y of y-component\n					 */\n					match[1] = match[1].toLowerCase();\n\n					if ( match[1].slice( 0, 3 ) === "nth" ) {\n						// nth-* requires argument\n						if ( !match[3] ) {\n							Sizzle.error( match[0] );\n						}\n\n						// numeric x and y parameters for Expr.filter.CHILD\n						// remember that false/true cast respectively to 0/1\n						match[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === "even" || match[3] === "odd" ) );\n						match[5] = +( ( match[7] + match[8] ) || match[3] === "odd" );\n\n						// other types prohibit arguments\n					} else if ( match[3] ) {\n						Sizzle.error( match[0] );\n					}\n\n					return match;\n				},\n\n				"PSEUDO": function( match ) {\n					var excess,\n						unquoted = !match[5] && match[2];\n\n					if ( matchExpr["CHILD"].test( match[0] ) ) {\n						return null;\n					}\n\n					// Accept quoted arguments as-is\n					if ( match[3] && match[4] !== undefined ) {\n						match[2] = match[4];\n\n						// Strip excess characters from unquoted arguments\n					} else if ( unquoted && rpseudo.test( unquoted ) &&\n						// Get excess from tokenize (recursively)\n						(excess = tokenize( unquoted, true )) &&\n						// advance to the next closing parenthesis\n						(excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length) ) {\n\n						// excess is a negative index\n						match[0] = match[0].slice( 0, excess );\n						match[2] = unquoted.slice( 0, excess );\n					}\n\n					// Return only captures needed by the pseudo filter method (type and argument)\n					return match.slice( 0, 3 );\n				}\n			},\n\n			filter: {\n\n				"TAG": function( nodeNameSelector ) {\n					var nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();\n					return nodeNameSelector === "*" ?\n						function() { return true; } :\n						function( elem ) {\n							return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;\n						};\n				},\n\n				"CLASS": function( className ) {\n					var pattern = classCache[ className + " " ];\n\n					return pattern ||\n						(pattern = new RegExp( "(^|" + whitespace + ")" + className + "(" + whitespace + "|$)" )) &&\n							classCache( className, function( elem ) {\n								return pattern.test( typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== strundefined && elem.getAttribute("class") || "" );\n							});\n				},\n\n				"ATTR": function( name, operator, check ) {\n					return function( elem ) {\n						var result = Sizzle.attr( elem, name );\n\n						if ( result == null ) {\n							return operator === "!=";\n						}\n						if ( !operator ) {\n							return true;\n						}\n\n						result += "";\n\n						return operator === "=" ? result === check :\n							operator === "!=" ? result !== check :\n								operator === "^=" ? check && result.indexOf( check ) === 0 :\n									operator === "*=" ? check && result.indexOf( check ) > -1 :\n										operator === "$=" ? check && result.slice( -check.length ) === check :\n											operator === "~=" ? ( " " + result + " " ).indexOf( check ) > -1 :\n												operator === "|=" ? result === check || result.slice( 0, check.length + 1 ) === check + "-" :\n													false;\n					};\n				},\n\n				"CHILD": function( type, what, argument, first, last ) {\n					var simple = type.slice( 0, 3 ) !== "nth",\n						forward = type.slice( -4 ) !== "last",\n						ofType = what === "of-type";\n\n					return first === 1 && last === 0 ?\n\n						// Shortcut for :nth-*(n)\n						function( elem ) {\n							return !!elem.parentNode;\n						} :\n\n						function( elem, context, xml ) {\n							var cache, outerCache, node, diff, nodeIndex, start,\n								dir = simple !== forward ? "nextSibling" : "previousSibling",\n								parent = elem.parentNode,\n								name = ofType && elem.nodeName.toLowerCase(),\n								useCache = !xml && !ofType;\n\n							if ( parent ) {\n\n								// :(first|last|only)-(child|of-type)\n								if ( simple ) {\n									while ( dir ) {\n										node = elem;\n										while ( (node = node[ dir ]) ) {\n											if ( ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1 ) {\n												return false;\n											}\n										}\n										// Reverse direction for :only-* (if we haven\'t yet done so)\n										start = dir = type === "only" && !start && "nextSibling";\n									}\n									return true;\n								}\n\n								start = [ forward ? parent.firstChild : parent.lastChild ];\n\n								// non-xml :nth-child(...) stores cache data on `parent`\n								if ( forward && useCache ) {\n									// Seek `elem` from a previously-cached index\n									outerCache = parent[ expando ] || (parent[ expando ] = {});\n									cache = outerCache[ type ] || [];\n									nodeIndex = cache[0] === dirruns && cache[1];\n									diff = cache[0] === dirruns && cache[2];\n									node = nodeIndex && parent.childNodes[ nodeIndex ];\n\n									while ( (node = ++nodeIndex && node && node[ dir ] ||\n\n										// Fallback to seeking `elem` from the start\n										(diff = nodeIndex = 0) || start.pop()) ) {\n\n										// When found, cache indexes on `parent` and break\n										if ( node.nodeType === 1 && ++diff && node === elem ) {\n											outerCache[ type ] = [ dirruns, nodeIndex, diff ];\n											break;\n										}\n									}\n\n									// Use previously-cached element index if available\n								} else if ( useCache && (cache = (elem[ expando ] || (elem[ expando ] = {}))[ type ]) && cache[0] === dirruns ) {\n									diff = cache[1];\n\n									// xml :nth-child(...) or :nth-last-child(...) or :nth(-last)?-of-type(...)\n								} else {\n									// Use the same loop as above to seek `elem` from the start\n									while ( (node = ++nodeIndex && node && node[ dir ] ||\n										(diff = nodeIndex = 0) || start.pop()) ) {\n\n										if ( ( ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1 ) && ++diff ) {\n											// Cache the index of each encountered element\n											if ( useCache ) {\n												(node[ expando ] || (node[ expando ] = {}))[ type ] = [ dirruns, diff ];\n											}\n\n											if ( node === elem ) {\n												break;\n											}\n										}\n									}\n								}\n\n								// Incorporate the offset, then check against cycle size\n								diff -= last;\n								return diff === first || ( diff % first === 0 && diff / first >= 0 );\n							}\n						};\n				},\n\n				"PSEUDO": function( pseudo, argument ) {\n					// pseudo-class names are case-insensitive\n					// http://www.w3.org/TR/selectors/#pseudo-classes\n					// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters\n					// Remember that setFilters inherits from pseudos\n					var args,\n						fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||\n							Sizzle.error( "unsupported pseudo: " + pseudo );\n\n					// The user may use createPseudo to indicate that\n					// arguments are needed to create the filter function\n					// just as Sizzle does\n					if ( fn[ expando ] ) {\n						return fn( argument );\n					}\n\n					// But maintain support for old signatures\n					if ( fn.length > 1 ) {\n						args = [ pseudo, pseudo, "", argument ];\n						return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?\n							markFunction(function( seed, matches ) {\n								var idx,\n									matched = fn( seed, argument ),\n									i = matched.length;\n								while ( i-- ) {\n									idx = indexOf.call( seed, matched[i] );\n									seed[ idx ] = !( matches[ idx ] = matched[i] );\n								}\n							}) :\n							function( elem ) {\n								return fn( elem, 0, args );\n							};\n					}\n\n					return fn;\n				}\n			},\n\n			pseudos: {\n				// Potentially complex pseudos\n				"not": markFunction(function( selector ) {\n					// Trim the selector passed to compile\n					// to avoid treating leading and trailing\n					// spaces as combinators\n					var input = [],\n						results = [],\n						matcher = compile( selector.replace( rtrim, "$1" ) );\n\n					return matcher[ expando ] ?\n						markFunction(function( seed, matches, context, xml ) {\n							var elem,\n								unmatched = matcher( seed, null, xml, [] ),\n								i = seed.length;\n\n							// Match elements unmatched by `matcher`\n							while ( i-- ) {\n								if ( (elem = unmatched[i]) ) {\n									seed[i] = !(matches[i] = elem);\n								}\n							}\n						}) :\n						function( elem, context, xml ) {\n							input[0] = elem;\n							matcher( input, null, xml, results );\n							return !results.pop();\n						};\n				}),\n\n				"has": markFunction(function( selector ) {\n					return function( elem ) {\n						return Sizzle( selector, elem ).length > 0;\n					};\n				}),\n\n				"contains": markFunction(function( text ) {\n					return function( elem ) {\n						return ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;\n					};\n				}),\n\n				// "Whether an element is represented by a :lang() selector\n				// is based solely on the element\'s language value\n				// being equal to the identifier C,\n				// or beginning with the identifier C immediately followed by "-".\n				// The matching of C against the element\'s language value is performed case-insensitively.\n				// The identifier C does not have to be a valid language name."\n				// http://www.w3.org/TR/selectors/#lang-pseudo\n				"lang": markFunction( function( lang ) {\n					// lang value must be a valid identifier\n					if ( !ridentifier.test(lang || "") ) {\n						Sizzle.error( "unsupported lang: " + lang );\n					}\n					lang = lang.replace( runescape, funescape ).toLowerCase();\n					return function( elem ) {\n						var elemLang;\n						do {\n							if ( (elemLang = documentIsHTML ?\n								elem.lang :\n								elem.getAttribute("xml:lang") || elem.getAttribute("lang")) ) {\n\n								elemLang = elemLang.toLowerCase();\n								return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;\n							}\n						} while ( (elem = elem.parentNode) && elem.nodeType === 1 );\n						return false;\n					};\n				}),\n\n				// Miscellaneous\n				"target": function( elem ) {\n					var hash = window.location && window.location.hash;\n					return hash && hash.slice( 1 ) === elem.id;\n				},\n\n				"root": function( elem ) {\n					return elem === docElem;\n				},\n\n				"focus": function( elem ) {\n					return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);\n				},\n\n				// Boolean properties\n				"enabled": function( elem ) {\n					return elem.disabled === false;\n				},\n\n				"disabled": function( elem ) {\n					return elem.disabled === true;\n				},\n\n				"checked": function( elem ) {\n					// In CSS3, :checked should return both checked and selected elements\n					// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\n					var nodeName = elem.nodeName.toLowerCase();\n					return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);\n				},\n\n				"selected": function( elem ) {\n					// Accessing this property makes selected-by-default\n					// options in Safari work properly\n					if ( elem.parentNode ) {\n						elem.parentNode.selectedIndex;\n					}\n\n					return elem.selected === true;\n				},\n\n				// Contents\n				"empty": function( elem ) {\n					// http://www.w3.org/TR/selectors/#empty-pseudo\n					// :empty is only affected by element nodes and content nodes(including text(3), cdata(4)),\n					//   not comment, processing instructions, or others\n					// Thanks to Diego Perini for the nodeName shortcut\n					//   Greater than "@" means alpha characters (specifically not starting with "#" or "?")\n					for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {\n						if ( elem.nodeName > "@" || elem.nodeType === 3 || elem.nodeType === 4 ) {\n							return false;\n						}\n					}\n					return true;\n				},\n\n				"parent": function( elem ) {\n					return !Expr.pseudos["empty"]( elem );\n				},\n\n				// Element/input types\n				"header": function( elem ) {\n					return rheader.test( elem.nodeName );\n				},\n\n				"input": function( elem ) {\n					return rinputs.test( elem.nodeName );\n				},\n\n				"button": function( elem ) {\n					var name = elem.nodeName.toLowerCase();\n					return name === "input" && elem.type === "button" || name === "button";\n				},\n\n				"text": function( elem ) {\n					var attr;\n					// IE6 and 7 will map elem.type to \'text\' for new HTML5 types (search, etc)\n					// use getAttribute instead to test this case\n					return elem.nodeName.toLowerCase() === "input" &&\n						elem.type === "text" &&\n						( (attr = elem.getAttribute("type")) == null || attr.toLowerCase() === elem.type );\n				},\n\n				// Position-in-collection\n				"first": createPositionalPseudo(function() {\n					return [ 0 ];\n				}),\n\n				"last": createPositionalPseudo(function( matchIndexes, length ) {\n					return [ length - 1 ];\n				}),\n\n				"eq": createPositionalPseudo(function( matchIndexes, length, argument ) {\n					return [ argument < 0 ? argument + length : argument ];\n				}),\n\n				"even": createPositionalPseudo(function( matchIndexes, length ) {\n					var i = 0;\n					for ( ; i < length; i += 2 ) {\n						matchIndexes.push( i );\n					}\n					return matchIndexes;\n				}),\n\n				"odd": createPositionalPseudo(function( matchIndexes, length ) {\n					var i = 1;\n					for ( ; i < length; i += 2 ) {\n						matchIndexes.push( i );\n					}\n					return matchIndexes;\n				}),\n\n				"lt": createPositionalPseudo(function( matchIndexes, length, argument ) {\n					var i = argument < 0 ? argument + length : argument;\n					for ( ; --i >= 0; ) {\n						matchIndexes.push( i );\n					}\n					return matchIndexes;\n				}),\n\n				"gt": createPositionalPseudo(function( matchIndexes, length, argument ) {\n					var i = argument < 0 ? argument + length : argument;\n					for ( ; ++i < length; ) {\n						matchIndexes.push( i );\n					}\n					return matchIndexes;\n				})\n			}\n		};\n\n		Expr.pseudos["nth"] = Expr.pseudos["eq"];\n\n// Add button/input type pseudos\n		for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {\n			Expr.pseudos[ i ] = createInputPseudo( i );\n		}\n		for ( i in { submit: true, reset: true } ) {\n			Expr.pseudos[ i ] = createButtonPseudo( i );\n		}\n\n// Easy API for creating new setFilters\n		function setFilters() {}\n		setFilters.prototype = Expr.filters = Expr.pseudos;\n		Expr.setFilters = new setFilters();\n\n		function tokenize( selector, parseOnly ) {\n			var matched, match, tokens, type,\n				soFar, groups, preFilters,\n				cached = tokenCache[ selector + " " ];\n\n			if ( cached ) {\n				return parseOnly ? 0 : cached.slice( 0 );\n			}\n\n			soFar = selector;\n			groups = [];\n			preFilters = Expr.preFilter;\n\n			while ( soFar ) {\n\n				// Comma and first run\n				if ( !matched || (match = rcomma.exec( soFar )) ) {\n					if ( match ) {\n						// Don\'t consume trailing commas as valid\n						soFar = soFar.slice( match[0].length ) || soFar;\n					}\n					groups.push( tokens = [] );\n				}\n\n				matched = false;\n\n				// Combinators\n				if ( (match = rcombinators.exec( soFar )) ) {\n					matched = match.shift();\n					tokens.push({\n						value: matched,\n						// Cast descendant combinators to space\n						type: match[0].replace( rtrim, " " )\n					});\n					soFar = soFar.slice( matched.length );\n				}\n\n				// Filters\n				for ( type in Expr.filter ) {\n					if ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||\n						(match = preFilters[ type ]( match ))) ) {\n						matched = match.shift();\n						tokens.push({\n							value: matched,\n							type: type,\n							matches: match\n						});\n						soFar = soFar.slice( matched.length );\n					}\n				}\n\n				if ( !matched ) {\n					break;\n				}\n			}\n\n			// Return the length of the invalid excess\n			// if we\'re just parsing\n			// Otherwise, throw an error or return tokens\n			return parseOnly ?\n				soFar.length :\n				soFar ?\n					Sizzle.error( selector ) :\n					// Cache the tokens\n					tokenCache( selector, groups ).slice( 0 );\n		}\n\n		function toSelector( tokens ) {\n			var i = 0,\n				len = tokens.length,\n				selector = "";\n			for ( ; i < len; i++ ) {\n				selector += tokens[i].value;\n			}\n			return selector;\n		}\n\n		function addCombinator( matcher, combinator, base ) {\n			var dir = combinator.dir,\n				checkNonElements = base && dir === "parentNode",\n				doneName = done++;\n\n			return combinator.first ?\n				// Check against closest ancestor/preceding element\n				function( elem, context, xml ) {\n					while ( (elem = elem[ dir ]) ) {\n						if ( elem.nodeType === 1 || checkNonElements ) {\n							return matcher( elem, context, xml );\n						}\n					}\n				} :\n\n				// Check against all ancestor/preceding elements\n				function( elem, context, xml ) {\n					var data, cache, outerCache,\n						dirkey = dirruns + " " + doneName;\n\n					// We can\'t set arbitrary data on XML nodes, so they don\'t benefit from dir caching\n					if ( xml ) {\n						while ( (elem = elem[ dir ]) ) {\n							if ( elem.nodeType === 1 || checkNonElements ) {\n								if ( matcher( elem, context, xml ) ) {\n									return true;\n								}\n							}\n						}\n					} else {\n						while ( (elem = elem[ dir ]) ) {\n							if ( elem.nodeType === 1 || checkNonElements ) {\n								outerCache = elem[ expando ] || (elem[ expando ] = {});\n								if ( (cache = outerCache[ dir ]) && cache[0] === dirkey ) {\n									if ( (data = cache[1]) === true || data === cachedruns ) {\n										return data === true;\n									}\n								} else {\n									cache = outerCache[ dir ] = [ dirkey ];\n									cache[1] = matcher( elem, context, xml ) || cachedruns;\n									if ( cache[1] === true ) {\n										return true;\n									}\n								}\n							}\n						}\n					}\n				};\n		}\n\n		function elementMatcher( matchers ) {\n			return matchers.length > 1 ?\n				function( elem, context, xml ) {\n					var i = matchers.length;\n					while ( i-- ) {\n						if ( !matchers[i]( elem, context, xml ) ) {\n							return false;\n						}\n					}\n					return true;\n				} :\n				matchers[0];\n		}\n\n		function condense( unmatched, map, filter, context, xml ) {\n			var elem,\n				newUnmatched = [],\n				i = 0,\n				len = unmatched.length,\n				mapped = map != null;\n\n			for ( ; i < len; i++ ) {\n				if ( (elem = unmatched[i]) ) {\n					if ( !filter || filter( elem, context, xml ) ) {\n						newUnmatched.push( elem );\n						if ( mapped ) {\n							map.push( i );\n						}\n					}\n				}\n			}\n\n			return newUnmatched;\n		}\n\n		function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {\n			if ( postFilter && !postFilter[ expando ] ) {\n				postFilter = setMatcher( postFilter );\n			}\n			if ( postFinder && !postFinder[ expando ] ) {\n				postFinder = setMatcher( postFinder, postSelector );\n			}\n			return markFunction(function( seed, results, context, xml ) {\n				var temp, i, elem,\n					preMap = [],\n					postMap = [],\n					preexisting = results.length,\n\n				// Get initial elements from seed or context\n					elems = seed || multipleContexts( selector || "*", context.nodeType ? [ context ] : context, [] ),\n\n				// Prefilter to get matcher input, preserving a map for seed-results synchronization\n					matcherIn = preFilter && ( seed || !selector ) ?\n						condense( elems, preMap, preFilter, context, xml ) :\n						elems,\n\n					matcherOut = matcher ?\n						// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,\n						postFinder || ( seed ? preFilter : preexisting || postFilter ) ?\n\n							// ...intermediate processing is necessary\n							[] :\n\n							// ...otherwise use results directly\n							results :\n						matcherIn;\n\n				// Find primary matches\n				if ( matcher ) {\n					matcher( matcherIn, matcherOut, context, xml );\n				}\n\n				// Apply postFilter\n				if ( postFilter ) {\n					temp = condense( matcherOut, postMap );\n					postFilter( temp, [], context, xml );\n\n					// Un-match failing elements by moving them back to matcherIn\n					i = temp.length;\n					while ( i-- ) {\n						if ( (elem = temp[i]) ) {\n							matcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);\n						}\n					}\n				}\n\n				if ( seed ) {\n					if ( postFinder || preFilter ) {\n						if ( postFinder ) {\n							// Get the final matcherOut by condensing this intermediate into postFinder contexts\n							temp = [];\n							i = matcherOut.length;\n							while ( i-- ) {\n								if ( (elem = matcherOut[i]) ) {\n									// Restore matcherIn since elem is not yet a final match\n									temp.push( (matcherIn[i] = elem) );\n								}\n							}\n							postFinder( null, (matcherOut = []), temp, xml );\n						}\n\n						// Move matched elements from seed to results to keep them synchronized\n						i = matcherOut.length;\n						while ( i-- ) {\n							if ( (elem = matcherOut[i]) &&\n								(temp = postFinder ? indexOf.call( seed, elem ) : preMap[i]) > -1 ) {\n\n								seed[temp] = !(results[temp] = elem);\n							}\n						}\n					}\n\n					// Add elements to results, through postFinder if defined\n				} else {\n					matcherOut = condense(\n						matcherOut === results ?\n							matcherOut.splice( preexisting, matcherOut.length ) :\n							matcherOut\n					);\n					if ( postFinder ) {\n						postFinder( null, results, matcherOut, xml );\n					} else {\n						push.apply( results, matcherOut );\n					}\n				}\n			});\n		}\n\n		function matcherFromTokens( tokens ) {\n			var checkContext, matcher, j,\n				len = tokens.length,\n				leadingRelative = Expr.relative[ tokens[0].type ],\n				implicitRelative = leadingRelative || Expr.relative[" "],\n				i = leadingRelative ? 1 : 0,\n\n			// The foundational matcher ensures that elements are reachable from top-level context(s)\n				matchContext = addCombinator( function( elem ) {\n					return elem === checkContext;\n				}, implicitRelative, true ),\n				matchAnyContext = addCombinator( function( elem ) {\n					return indexOf.call( checkContext, elem ) > -1;\n				}, implicitRelative, true ),\n				matchers = [ function( elem, context, xml ) {\n					return ( !leadingRelative && ( xml || context !== outermostContext ) ) || (\n						(checkContext = context).nodeType ?\n							matchContext( elem, context, xml ) :\n							matchAnyContext( elem, context, xml ) );\n				} ];\n\n			for ( ; i < len; i++ ) {\n				if ( (matcher = Expr.relative[ tokens[i].type ]) ) {\n					matchers = [ addCombinator(elementMatcher( matchers ), matcher) ];\n				} else {\n					matcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );\n\n					// Return special upon seeing a positional matcher\n					if ( matcher[ expando ] ) {\n						// Find the next relative operator (if any) for proper handling\n						j = ++i;\n						for ( ; j < len; j++ ) {\n							if ( Expr.relative[ tokens[j].type ] ) {\n								break;\n							}\n						}\n						return setMatcher(\n							i > 1 && elementMatcher( matchers ),\n							i > 1 && toSelector(\n								// If the preceding token was a descendant combinator, insert an implicit any-element `*`\n								tokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === " " ? "*" : "" })\n							).replace( rtrim, "$1" ),\n							matcher,\n							i < j && matcherFromTokens( tokens.slice( i, j ) ),\n							j < len && matcherFromTokens( (tokens = tokens.slice( j )) ),\n							j < len && toSelector( tokens )\n						);\n					}\n					matchers.push( matcher );\n				}\n			}\n\n			return elementMatcher( matchers );\n		}\n\n		function matcherFromGroupMatchers( elementMatchers, setMatchers ) {\n			// A counter to specify which element is currently being matched\n			var matcherCachedRuns = 0,\n				bySet = setMatchers.length > 0,\n				byElement = elementMatchers.length > 0,\n				superMatcher = function( seed, context, xml, results, expandContext ) {\n					var elem, j, matcher,\n						setMatched = [],\n						matchedCount = 0,\n						i = "0",\n						unmatched = seed && [],\n						outermost = expandContext != null,\n						contextBackup = outermostContext,\n					// We must always have either seed elements or context\n						elems = seed || byElement && Expr.find["TAG"]( "*", expandContext && context.parentNode || context ),\n					// Use integer dirruns iff this is the outermost matcher\n						dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1);\n\n					if ( outermost ) {\n						outermostContext = context !== document && context;\n						cachedruns = matcherCachedRuns;\n					}\n\n					// Add elements passing elementMatchers directly to results\n					// Keep `i` a string if there are no elements so `matchedCount` will be "00" below\n					for ( ; (elem = elems[i]) != null; i++ ) {\n						if ( byElement && elem ) {\n							j = 0;\n							while ( (matcher = elementMatchers[j++]) ) {\n								if ( matcher( elem, context, xml ) ) {\n									results.push( elem );\n									break;\n								}\n							}\n							if ( outermost ) {\n								dirruns = dirrunsUnique;\n								cachedruns = ++matcherCachedRuns;\n							}\n						}\n\n						// Track unmatched elements for set filters\n						if ( bySet ) {\n							// They will have gone through all possible matchers\n							if ( (elem = !matcher && elem) ) {\n								matchedCount--;\n							}\n\n							// Lengthen the array for every element, matched or not\n							if ( seed ) {\n								unmatched.push( elem );\n							}\n						}\n					}\n\n					// Apply set filters to unmatched elements\n					matchedCount += i;\n					if ( bySet && i !== matchedCount ) {\n						j = 0;\n						while ( (matcher = setMatchers[j++]) ) {\n							matcher( unmatched, setMatched, context, xml );\n						}\n\n						if ( seed ) {\n							// Reintegrate element matches to eliminate the need for sorting\n							if ( matchedCount > 0 ) {\n								while ( i-- ) {\n									if ( !(unmatched[i] || setMatched[i]) ) {\n										setMatched[i] = pop.call( results );\n									}\n								}\n							}\n\n							// Discard index placeholder values to get only actual matches\n							setMatched = condense( setMatched );\n						}\n\n						// Add matches to results\n						push.apply( results, setMatched );\n\n						// Seedless set matches succeeding multiple successful matchers stipulate sorting\n						if ( outermost && !seed && setMatched.length > 0 &&\n							( matchedCount + setMatchers.length ) > 1 ) {\n\n							Sizzle.uniqueSort( results );\n						}\n					}\n\n					// Override manipulation of globals by nested matchers\n					if ( outermost ) {\n						dirruns = dirrunsUnique;\n						outermostContext = contextBackup;\n					}\n\n					return unmatched;\n				};\n\n			return bySet ?\n				markFunction( superMatcher ) :\n				superMatcher;\n		}\n\n		compile = Sizzle.compile = function( selector, group /* Internal Use Only */ ) {\n			var i,\n				setMatchers = [],\n				elementMatchers = [],\n				cached = compilerCache[ selector + " " ];\n\n			if ( !cached ) {\n				// Generate a function of recursive functions that can be used to check each element\n				if ( !group ) {\n					group = tokenize( selector );\n				}\n				i = group.length;\n				while ( i-- ) {\n					cached = matcherFromTokens( group[i] );\n					if ( cached[ expando ] ) {\n						setMatchers.push( cached );\n					} else {\n						elementMatchers.push( cached );\n					}\n				}\n\n				// Cache the compiled function\n				cached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );\n			}\n			return cached;\n		};\n\n		function multipleContexts( selector, contexts, results ) {\n			var i = 0,\n				len = contexts.length;\n			for ( ; i < len; i++ ) {\n				Sizzle( selector, contexts[i], results );\n			}\n			return results;\n		}\n\n		function select( selector, context, results, seed ) {\n			var i, tokens, token, type, find,\n				match = tokenize( selector );\n\n			if ( !seed ) {\n				// Try to minimize operations if there is only one group\n				if ( match.length === 1 ) {\n\n					// Take a shortcut and set the context if the root selector is an ID\n					tokens = match[0] = match[0].slice( 0 );\n					if ( tokens.length > 2 && (token = tokens[0]).type === "ID" &&\n						support.getById && context.nodeType === 9 && documentIsHTML &&\n						Expr.relative[ tokens[1].type ] ) {\n\n						context = ( Expr.find["ID"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];\n						if ( !context ) {\n							return results;\n						}\n						selector = selector.slice( tokens.shift().value.length );\n					}\n\n					// Fetch a seed set for right-to-left matching\n					i = matchExpr["needsContext"].test( selector ) ? 0 : tokens.length;\n					while ( i-- ) {\n						token = tokens[i];\n\n						// Abort if we hit a combinator\n						if ( Expr.relative[ (type = token.type) ] ) {\n							break;\n						}\n						if ( (find = Expr.find[ type ]) ) {\n							// Search, expanding context for leading sibling combinators\n							if ( (seed = find(\n								token.matches[0].replace( runescape, funescape ),\n								rsibling.test( tokens[0].type ) && context.parentNode || context\n							)) ) {\n\n								// If seed is empty or no tokens remain, we can return early\n								tokens.splice( i, 1 );\n								selector = seed.length && toSelector( tokens );\n								if ( !selector ) {\n									push.apply( results, seed );\n									return results;\n								}\n\n								break;\n							}\n						}\n					}\n				}\n			}\n\n			// Compile and execute a filtering function\n			// Provide `match` to avoid retokenization if we modified the selector above\n			compile( selector, match )(\n				seed,\n				context,\n				!documentIsHTML,\n				results,\n				rsibling.test( selector )\n			);\n			return results;\n		}\n\n// One-time assignments\n\n// Sort stability\n		support.sortStable = expando.split("").sort( sortOrder ).join("") === expando;\n\n// Support: Chrome<14\n// Always assume duplicates if they aren\'t passed to the comparison function\n		support.detectDuplicates = hasDuplicate;\n\n// Initialize against the default document\n		setDocument();\n\n// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)\n// Detached nodes confoundingly follow *each other*\n		support.sortDetached = assert(function( div1 ) {\n			// Should return 1, but returns 4 (following)\n			return div1.compareDocumentPosition( document.createElement("div") ) & 1;\n		});\n\n// Support: IE<8\n// Prevent attribute/property "interpolation"\n// http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx\n		if ( !assert(function( div ) {\n			div.innerHTML = "<a href=\'#\'></a>";\n			return div.firstChild.getAttribute("href") === "#" ;\n		}) ) {\n			addHandle( "type|href|height|width", function( elem, name, isXML ) {\n				if ( !isXML ) {\n					return elem.getAttribute( name, name.toLowerCase() === "type" ? 1 : 2 );\n				}\n			});\n		}\n\n// Support: IE<9\n// Use defaultValue in place of getAttribute("value")\n		if ( !support.attributes || !assert(function( div ) {\n			div.innerHTML = "<input/>";\n			div.firstChild.setAttribute( "value", "" );\n			return div.firstChild.getAttribute( "value" ) === "";\n		}) ) {\n			addHandle( "value", function( elem, name, isXML ) {\n				if ( !isXML && elem.nodeName.toLowerCase() === "input" ) {\n					return elem.defaultValue;\n				}\n			});\n		}\n\n// Support: IE<9\n// Use getAttributeNode to fetch booleans when getAttribute lies\n		if ( !assert(function( div ) {\n			return div.getAttribute("disabled") == null;\n		}) ) {\n			addHandle( booleans, function( elem, name, isXML ) {\n				var val;\n				if ( !isXML ) {\n					return (val = elem.getAttributeNode( name )) && val.specified ?\n						val.value :\n						elem[ name ] === true ? name.toLowerCase() : null;\n				}\n			});\n		}\n\n		jQuery.find = Sizzle;\n		jQuery.expr = Sizzle.selectors;\n		jQuery.expr[":"] = jQuery.expr.pseudos;\n		jQuery.unique = Sizzle.uniqueSort;\n		jQuery.text = Sizzle.getText;\n		jQuery.isXMLDoc = Sizzle.isXML;\n		jQuery.contains = Sizzle.contains;\n\n\n	})( window );\n// String to Object options format cache\n	var optionsCache = {};\n\n// Convert String-formatted options into Object-formatted ones and store in cache\n	function createOptions( options ) {\n		var object = optionsCache[ options ] = {};\n		jQuery.each( options.match( core_rnotwhite ) || [], function( _, flag ) {\n			object[ flag ] = true;\n		});\n		return object;\n	}\n\n	/*\n	 * Create a callback list using the following parameters:\n	 *\n	 *	options: an optional list of space-separated options that will change how\n	 *			the callback list behaves or a more traditional option object\n	 *\n	 * By default a callback list will act like an event callback list and can be\n	 * "fired" multiple times.\n	 *\n	 * Possible options:\n	 *\n	 *	once:			will ensure the callback list can only be fired once (like a Deferred)\n	 *\n	 *	memory:			will keep track of previous values and will call any callback added\n	 *					after the list has been fired right away with the latest "memorized"\n	 *					values (like a Deferred)\n	 *\n	 *	unique:			will ensure a callback can only be added once (no duplicate in the list)\n	 *\n	 *	stopOnFalse:	interrupt callings when a callback returns false\n	 *\n	 */\n	jQuery.Callbacks = function( options ) {\n\n		// Convert options from String-formatted to Object-formatted if needed\n		// (we check in cache first)\n		options = typeof options === "string" ?\n			( optionsCache[ options ] || createOptions( options ) ) :\n			jQuery.extend( {}, options );\n\n		var // Flag to know if list is currently firing\n			firing,\n		// Last fire value (for non-forgettable lists)\n			memory,\n		// Flag to know if list was already fired\n			fired,\n		// End of the loop when firing\n			firingLength,\n		// Index of currently firing callback (modified by remove if needed)\n			firingIndex,\n		// First callback to fire (used internally by add and fireWith)\n			firingStart,\n		// Actual callback list\n			list = [],\n		// Stack of fire calls for repeatable lists\n			stack = !options.once && [],\n		// Fire callbacks\n			fire = function( data ) {\n				memory = options.memory && data;\n				fired = true;\n				firingIndex = firingStart || 0;\n				firingStart = 0;\n				firingLength = list.length;\n				firing = true;\n				for ( ; list && firingIndex < firingLength; firingIndex++ ) {\n					if ( list[ firingIndex ].apply( data[ 0 ], data[ 1 ] ) === false && options.stopOnFalse ) {\n						memory = false; // To prevent further calls using add\n						break;\n					}\n				}\n				firing = false;\n				if ( list ) {\n					if ( stack ) {\n						if ( stack.length ) {\n							fire( stack.shift() );\n						}\n					} else if ( memory ) {\n						list = [];\n					} else {\n						self.disable();\n					}\n				}\n			},\n		// Actual Callbacks object\n			self = {\n				// Add a callback or a collection of callbacks to the list\n				add: function() {\n					if ( list ) {\n						// First, we save the current length\n						var start = list.length;\n						(function add( args ) {\n							jQuery.each( args, function( _, arg ) {\n								var type = jQuery.type( arg );\n								if ( type === "function" ) {\n									if ( !options.unique || !self.has( arg ) ) {\n										list.push( arg );\n									}\n								} else if ( arg && arg.length && type !== "string" ) {\n									// Inspect recursively\n									add( arg );\n								}\n							});\n						})( arguments );\n						// Do we need to add the callbacks to the\n						// current firing batch?\n						if ( firing ) {\n							firingLength = list.length;\n							// With memory, if we\'re not firing then\n							// we should call right away\n						} else if ( memory ) {\n							firingStart = start;\n							fire( memory );\n						}\n					}\n					return this;\n				},\n				// Remove a callback from the list\n				remove: function() {\n					if ( list ) {\n						jQuery.each( arguments, function( _, arg ) {\n							var index;\n							while( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {\n								list.splice( index, 1 );\n								// Handle firing indexes\n								if ( firing ) {\n									if ( index <= firingLength ) {\n										firingLength--;\n									}\n									if ( index <= firingIndex ) {\n										firingIndex--;\n									}\n								}\n							}\n						});\n					}\n					return this;\n				},\n				// Check if a given callback is in the list.\n				// If no argument is given, return whether or not list has callbacks attached.\n				has: function( fn ) {\n					return fn ? jQuery.inArray( fn, list ) > -1 : !!( list && list.length );\n				},\n				// Remove all callbacks from the list\n				empty: function() {\n					list = [];\n					firingLength = 0;\n					return this;\n				},\n				// Have the list do nothing anymore\n				disable: function() {\n					list = stack = memory = undefined;\n					return this;\n				},\n				// Is it disabled?\n				disabled: function() {\n					return !list;\n				},\n				// Lock the list in its current state\n				lock: function() {\n					stack = undefined;\n					if ( !memory ) {\n						self.disable();\n					}\n					return this;\n				},\n				// Is it locked?\n				locked: function() {\n					return !stack;\n				},\n				// Call all callbacks with the given context and arguments\n				fireWith: function( context, args ) {\n					if ( list && ( !fired || stack ) ) {\n						args = args || [];\n						args = [ context, args.slice ? args.slice() : args ];\n						if ( firing ) {\n							stack.push( args );\n						} else {\n							fire( args );\n						}\n					}\n					return this;\n				},\n				// Call all the callbacks with the given arguments\n				fire: function() {\n					self.fireWith( this, arguments );\n					return this;\n				},\n				// To know if the callbacks have already been called at least once\n				fired: function() {\n					return !!fired;\n				}\n			};\n\n		return self;\n	};\n	jQuery.extend({\n\n		Deferred: function( func ) {\n			var tuples = [\n					// action, add listener, listener list, final state\n					[ "resolve", "done", jQuery.Callbacks("once memory"), "resolved" ],\n					[ "reject", "fail", jQuery.Callbacks("once memory"), "rejected" ],\n					[ "notify", "progress", jQuery.Callbacks("memory") ]\n				],\n				state = "pending",\n				promise = {\n					state: function() {\n						return state;\n					},\n					always: function() {\n						deferred.done( arguments ).fail( arguments );\n						return this;\n					},\n					then: function( /* fnDone, fnFail, fnProgress */ ) {\n						var fns = arguments;\n						return jQuery.Deferred(function( newDefer ) {\n							jQuery.each( tuples, function( i, tuple ) {\n								var action = tuple[ 0 ],\n									fn = jQuery.isFunction( fns[ i ] ) && fns[ i ];\n								// deferred[ done | fail | progress ] for forwarding actions to newDefer\n								deferred[ tuple[1] ](function() {\n									var returned = fn && fn.apply( this, arguments );\n									if ( returned && jQuery.isFunction( returned.promise ) ) {\n										returned.promise()\n											.done( newDefer.resolve )\n											.fail( newDefer.reject )\n											.progress( newDefer.notify );\n									} else {\n										newDefer[ action + "With" ]( this === promise ? newDefer.promise() : this, fn ? [ returned ] : arguments );\n									}\n								});\n							});\n							fns = null;\n						}).promise();\n					},\n					// Get a promise for this deferred\n					// If obj is provided, the promise aspect is added to the object\n					promise: function( obj ) {\n						return obj != null ? jQuery.extend( obj, promise ) : promise;\n					}\n				},\n				deferred = {};\n\n			// Keep pipe for back-compat\n			promise.pipe = promise.then;\n\n			// Add list-specific methods\n			jQuery.each( tuples, function( i, tuple ) {\n				var list = tuple[ 2 ],\n					stateString = tuple[ 3 ];\n\n				// promise[ done | fail | progress ] = list.add\n				promise[ tuple[1] ] = list.add;\n\n				// Handle state\n				if ( stateString ) {\n					list.add(function() {\n						// state = [ resolved | rejected ]\n						state = stateString;\n\n						// [ reject_list | resolve_list ].disable; progress_list.lock\n					}, tuples[ i ^ 1 ][ 2 ].disable, tuples[ 2 ][ 2 ].lock );\n				}\n\n				// deferred[ resolve | reject | notify ]\n				deferred[ tuple[0] ] = function() {\n					deferred[ tuple[0] + "With" ]( this === deferred ? promise : this, arguments );\n					return this;\n				};\n				deferred[ tuple[0] + "With" ] = list.fireWith;\n			});\n\n			// Make the deferred a promise\n			promise.promise( deferred );\n\n			// Call given func if any\n			if ( func ) {\n				func.call( deferred, deferred );\n			}\n\n			// All done!\n			return deferred;\n		},\n\n		// Deferred helper\n		when: function( subordinate /* , ..., subordinateN */ ) {\n			var i = 0,\n				resolveValues = core_slice.call( arguments ),\n				length = resolveValues.length,\n\n			// the count of uncompleted subordinates\n				remaining = length !== 1 || ( subordinate && jQuery.isFunction( subordinate.promise ) ) ? length : 0,\n\n			// the master Deferred. If resolveValues consist of only a single Deferred, just use that.\n				deferred = remaining === 1 ? subordinate : jQuery.Deferred(),\n\n			// Update function for both resolve and progress values\n				updateFunc = function( i, contexts, values ) {\n					return function( value ) {\n						contexts[ i ] = this;\n						values[ i ] = arguments.length > 1 ? core_slice.call( arguments ) : value;\n						if( values === progressValues ) {\n							deferred.notifyWith( contexts, values );\n						} else if ( !( --remaining ) ) {\n							deferred.resolveWith( contexts, values );\n						}\n					};\n				},\n\n				progressValues, progressContexts, resolveContexts;\n\n			// add listeners to Deferred subordinates; treat others as resolved\n			if ( length > 1 ) {\n				progressValues = new Array( length );\n				progressContexts = new Array( length );\n				resolveContexts = new Array( length );\n				for ( ; i < length; i++ ) {\n					if ( resolveValues[ i ] && jQuery.isFunction( resolveValues[ i ].promise ) ) {\n						resolveValues[ i ].promise()\n							.done( updateFunc( i, resolveContexts, resolveValues ) )\n							.fail( deferred.reject )\n							.progress( updateFunc( i, progressContexts, progressValues ) );\n					} else {\n						--remaining;\n					}\n				}\n			}\n\n			// if we\'re not waiting on anything, resolve the master\n			if ( !remaining ) {\n				deferred.resolveWith( resolveContexts, resolveValues );\n			}\n\n			return deferred.promise();\n		}\n	});\n	jQuery.support = (function( support ) {\n\n		var all, a, input, select, fragment, opt, eventName, isSupported, i,\n			div = document.createElement("div");\n\n		// Setup\n		div.setAttribute( "className", "t" );\n		div.innerHTML = "  <link/><table></table><a href=\'/a\'>a</a><input type=\'checkbox\'/>";\n\n		// Finish early in limited (non-browser) environments\n		all = div.getElementsByTagName("*") || [];\n		a = div.getElementsByTagName("a")[ 0 ];\n		if ( !a || !a.style || !all.length ) {\n			return support;\n		}\n\n		// First batch of tests\n		select = document.createElement("select");\n		opt = select.appendChild( document.createElement("option") );\n		input = div.getElementsByTagName("input")[ 0 ];\n\n		a.style.cssText = "top:1px;float:left;opacity:.5";\n\n		// Test setAttribute on camelCase class. If it works, we need attrFixes when doing get/setAttribute (ie6/7)\n		support.getSetAttribute = div.className !== "t";\n\n		// IE strips leading whitespace when .innerHTML is used\n		support.leadingWhitespace = div.firstChild.nodeType === 3;\n\n		// Make sure that tbody elements aren\'t automatically inserted\n		// IE will insert them into empty tables\n		support.tbody = !div.getElementsByTagName("tbody").length;\n\n		// Make sure that link elements get serialized correctly by innerHTML\n		// This requires a wrapper element in IE\n		support.htmlSerialize = !!div.getElementsByTagName("link").length;\n\n		// Get the style information from getAttribute\n		// (IE uses .cssText instead)\n		support.style = /top/.test( a.getAttribute("style") );\n\n		// Make sure that URLs aren\'t manipulated\n		// (IE normalizes it by default)\n		support.hrefNormalized = a.getAttribute("href") === "/a";\n\n		// Make sure that element opacity exists\n		// (IE uses filter instead)\n		// Use a regex to work around a WebKit issue. See #5145\n		support.opacity = /^0.5/.test( a.style.opacity );\n\n		// Verify style float existence\n		// (IE uses styleFloat instead of cssFloat)\n		support.cssFloat = !!a.style.cssFloat;\n\n		// Check the default checkbox/radio value ("" on WebKit; "on" elsewhere)\n		support.checkOn = !!input.value;\n\n		// Make sure that a selected-by-default option has a working selected property.\n		// (WebKit defaults to false instead of true, IE too, if it\'s in an optgroup)\n		support.optSelected = opt.selected;\n\n		// Tests for enctype support on a form (#6743)\n		support.enctype = !!document.createElement("form").enctype;\n\n		// Makes sure cloning an html5 element does not cause problems\n		// Where outerHTML is undefined, this still works\n		support.html5Clone = document.createElement("nav").cloneNode( true ).outerHTML !== "<:nav></:nav>";\n\n		// Will be defined later\n		support.inlineBlockNeedsLayout = false;\n		support.shrinkWrapBlocks = false;\n		support.pixelPosition = false;\n		support.deleteExpando = true;\n		support.noCloneEvent = true;\n		support.reliableMarginRight = true;\n		support.boxSizingReliable = true;\n\n		// Make sure checked status is properly cloned\n		input.checked = true;\n		support.noCloneChecked = input.cloneNode( true ).checked;\n\n		// Make sure that the options inside disabled selects aren\'t marked as disabled\n		// (WebKit marks them as disabled)\n		select.disabled = true;\n		support.optDisabled = !opt.disabled;\n\n		// Support: IE<9\n		try {\n			delete div.test;\n		} catch( e ) {\n			support.deleteExpando = false;\n		}\n\n		// Check if we can trust getAttribute("value")\n		input = document.createElement("input");\n		input.setAttribute( "value", "" );\n		support.input = input.getAttribute( "value" ) === "";\n\n		// Check if an input maintains its value after becoming a radio\n		input.value = "t";\n		input.setAttribute( "type", "radio" );\n		support.radioValue = input.value === "t";\n\n		// #11217 - WebKit loses check when the name is after the checked attribute\n		input.setAttribute( "checked", "t" );\n		input.setAttribute( "name", "t" );\n\n		fragment = document.createDocumentFragment();\n		fragment.appendChild( input );\n\n		// Check if a disconnected checkbox will retain its checked\n		// value of true after appended to the DOM (IE6/7)\n		support.appendChecked = input.checked;\n\n		// WebKit doesn\'t clone checked state correctly in fragments\n		support.checkClone = fragment.cloneNode( true ).cloneNode( true ).lastChild.checked;\n\n		// Support: IE<9\n		// Opera does not clone events (and typeof div.attachEvent === undefined).\n		// IE9-10 clones events bound via attachEvent, but they don\'t trigger with .click()\n		if ( div.attachEvent ) {\n			div.attachEvent( "onclick", function() {\n				support.noCloneEvent = false;\n			});\n\n			div.cloneNode( true ).click();\n		}\n\n		// Support: IE<9 (lack submit/change bubble), Firefox 17+ (lack focusin event)\n		// Beware of CSP restrictions (https://developer.mozilla.org/en/Security/CSP)\n		for ( i in { submit: true, change: true, focusin: true }) {\n			div.setAttribute( eventName = "on" + i, "t" );\n\n			support[ i + "Bubbles" ] = eventName in window || div.attributes[ eventName ].expando === false;\n		}\n\n		div.style.backgroundClip = "content-box";\n		div.cloneNode( true ).style.backgroundClip = "";\n		support.clearCloneStyle = div.style.backgroundClip === "content-box";\n\n		// Support: IE<9\n		// Iteration over object\'s inherited properties before its own.\n		for ( i in jQuery( support ) ) {\n			break;\n		}\n		support.ownLast = i !== "0";\n\n		// Run tests that need a body at doc ready\n		jQuery(function() {\n			var container, marginDiv, tds,\n				divReset = "padding:0;margin:0;border:0;display:block;box-sizing:content-box;-moz-box-sizing:content-box;-webkit-box-sizing:content-box;",\n				body = document.getElementsByTagName("body")[0];\n\n			if ( !body ) {\n				// Return for frameset docs that don\'t have a body\n				return;\n			}\n\n			container = document.createElement("div");\n			container.style.cssText = "border:0;width:0;height:0;position:absolute;top:0;left:-9999px;margin-top:1px";\n\n			body.appendChild( container ).appendChild( div );\n\n			// Support: IE8\n			// Check if table cells still have offsetWidth/Height when they are set\n			// to display:none and there are still other visible table cells in a\n			// table row; if so, offsetWidth/Height are not reliable for use when\n			// determining if an element has been hidden directly using\n			// display:none (it is still safe to use offsets if a parent element is\n			// hidden; don safety goggles and see bug #4512 for more information).\n			div.innerHTML = "<table><tr><td></td><td>t</td></tr></table>";\n			tds = div.getElementsByTagName("td");\n			tds[ 0 ].style.cssText = "padding:0;margin:0;border:0;display:none";\n			isSupported = ( tds[ 0 ].offsetHeight === 0 );\n\n			tds[ 0 ].style.display = "";\n			tds[ 1 ].style.display = "none";\n\n			// Support: IE8\n			// Check if empty table cells still have offsetWidth/Height\n			support.reliableHiddenOffsets = isSupported && ( tds[ 0 ].offsetHeight === 0 );\n\n			// Check box-sizing and margin behavior.\n			div.innerHTML = "";\n			div.style.cssText = "box-sizing:border-box;-moz-box-sizing:border-box;-webkit-box-sizing:border-box;padding:1px;border:1px;display:block;width:4px;margin-top:1%;position:absolute;top:1%;";\n\n			// Workaround failing boxSizing test due to offsetWidth returning wrong value\n			// with some non-1 values of body zoom, ticket #13543\n			jQuery.swap( body, body.style.zoom != null ? { zoom: 1 } : {}, function() {\n				support.boxSizing = div.offsetWidth === 4;\n			});\n\n			// Use window.getComputedStyle because jsdom on node.js will break without it.\n			if ( window.getComputedStyle ) {\n				support.pixelPosition = ( window.getComputedStyle( div, null ) || {} ).top !== "1%";\n				support.boxSizingReliable = ( window.getComputedStyle( div, null ) || { width: "4px" } ).width === "4px";\n\n				// Check if div with explicit width and no margin-right incorrectly\n				// gets computed margin-right based on width of container. (#3333)\n				// Fails in WebKit before Feb 2011 nightlies\n				// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right\n				marginDiv = div.appendChild( document.createElement("div") );\n				marginDiv.style.cssText = div.style.cssText = divReset;\n				marginDiv.style.marginRight = marginDiv.style.width = "0";\n				div.style.width = "1px";\n\n				support.reliableMarginRight =\n					!parseFloat( ( window.getComputedStyle( marginDiv, null ) || {} ).marginRight );\n			}\n\n			if ( typeof div.style.zoom !== core_strundefined ) {\n				// Support: IE<8\n				// Check if natively block-level elements act like inline-block\n				// elements when setting their display to \'inline\' and giving\n				// them layout\n				div.innerHTML = "";\n				div.style.cssText = divReset + "width:1px;padding:1px;display:inline;zoom:1";\n				support.inlineBlockNeedsLayout = ( div.offsetWidth === 3 );\n\n				// Support: IE6\n				// Check if elements with layout shrink-wrap their children\n				div.style.display = "block";\n				div.innerHTML = "<div></div>";\n				div.firstChild.style.width = "5px";\n				support.shrinkWrapBlocks = ( div.offsetWidth !== 3 );\n\n				if ( support.inlineBlockNeedsLayout ) {\n					// Prevent IE 6 from affecting layout for positioned elements #11048\n					// Prevent IE from shrinking the body in IE 7 mode #12869\n					// Support: IE<8\n					body.style.zoom = 1;\n				}\n			}\n\n			body.removeChild( container );\n\n			// Null elements to avoid leaks in IE\n			container = div = tds = marginDiv = null;\n		});\n\n		// Null elements to avoid leaks in IE\n		all = select = fragment = opt = a = input = null;\n\n		return support;\n	})({});\n\n	var rbrace = /(?:\\{[\\s\\S]*\\}|\\[[\\s\\S]*\\])$/,\n		rmultiDash = /([A-Z])/g;\n\n	function internalData( elem, name, data, pvt /* Internal Use Only */ ){\n		if ( !jQuery.acceptData( elem ) ) {\n			return;\n		}\n\n		var ret, thisCache,\n			internalKey = jQuery.expando,\n\n		// We have to handle DOM nodes and JS objects differently because IE6-7\n		// can\'t GC object references properly across the DOM-JS boundary\n			isNode = elem.nodeType,\n\n		// Only DOM nodes need the global jQuery cache; JS object data is\n		// attached directly to the object so GC can occur automatically\n			cache = isNode ? jQuery.cache : elem,\n\n		// Only defining an ID for JS objects if its cache already exists allows\n		// the code to shortcut on the same path as a DOM node with no cache\n			id = isNode ? elem[ internalKey ] : elem[ internalKey ] && internalKey;\n\n		// Avoid doing any more work than we need to when trying to get data on an\n		// object that has no data at all\n		if ( (!id || !cache[id] || (!pvt && !cache[id].data)) && data === undefined && typeof name === "string" ) {\n			return;\n		}\n\n		if ( !id ) {\n			// Only DOM nodes need a new unique ID for each element since their data\n			// ends up in the global cache\n			if ( isNode ) {\n				id = elem[ internalKey ] = core_deletedIds.pop() || jQuery.guid++;\n			} else {\n				id = internalKey;\n			}\n		}\n\n		if ( !cache[ id ] ) {\n			// Avoid exposing jQuery metadata on plain JS objects when the object\n			// is serialized using JSON.stringify\n			cache[ id ] = isNode ? {} : { toJSON: jQuery.noop };\n		}\n\n		// An object can be passed to jQuery.data instead of a key/value pair; this gets\n		// shallow copied over onto the existing cache\n		if ( typeof name === "object" || typeof name === "function" ) {\n			if ( pvt ) {\n				cache[ id ] = jQuery.extend( cache[ id ], name );\n			} else {\n				cache[ id ].data = jQuery.extend( cache[ id ].data, name );\n			}\n		}\n\n		thisCache = cache[ id ];\n\n		// jQuery data() is stored in a separate object inside the object\'s internal data\n		// cache in order to avoid key collisions between internal data and user-defined\n		// data.\n		if ( !pvt ) {\n			if ( !thisCache.data ) {\n				thisCache.data = {};\n			}\n\n			thisCache = thisCache.data;\n		}\n\n		if ( data !== undefined ) {\n			thisCache[ jQuery.camelCase( name ) ] = data;\n		}\n\n		// Check for both converted-to-camel and non-converted data property names\n		// If a data property was specified\n		if ( typeof name === "string" ) {\n\n			// First Try to find as-is property data\n			ret = thisCache[ name ];\n\n			// Test for null|undefined property data\n			if ( ret == null ) {\n\n				// Try to find the camelCased property\n				ret = thisCache[ jQuery.camelCase( name ) ];\n			}\n		} else {\n			ret = thisCache;\n		}\n\n		return ret;\n	}\n\n	function internalRemoveData( elem, name, pvt ) {\n		if ( !jQuery.acceptData( elem ) ) {\n			return;\n		}\n\n		var thisCache, i,\n			isNode = elem.nodeType,\n\n		// See jQuery.data for more information\n			cache = isNode ? jQuery.cache : elem,\n			id = isNode ? elem[ jQuery.expando ] : jQuery.expando;\n\n		// If there is already no cache entry for this object, there is no\n		// purpose in continuing\n		if ( !cache[ id ] ) {\n			return;\n		}\n\n		if ( name ) {\n\n			thisCache = pvt ? cache[ id ] : cache[ id ].data;\n\n			if ( thisCache ) {\n\n				// Support array or space separated string names for data keys\n				if ( !jQuery.isArray( name ) ) {\n\n					// try the string as a key before any manipulation\n					if ( name in thisCache ) {\n						name = [ name ];\n					} else {\n\n						// split the camel cased version by spaces unless a key with the spaces exists\n						name = jQuery.camelCase( name );\n						if ( name in thisCache ) {\n							name = [ name ];\n						} else {\n							name = name.split(" ");\n						}\n					}\n				} else {\n					// If "name" is an array of keys...\n					// When data is initially created, via ("key", "val") signature,\n					// keys will be converted to camelCase.\n					// Since there is no way to tell _how_ a key was added, remove\n					// both plain key and camelCase key. #12786\n					// This will only penalize the array argument path.\n					name = name.concat( jQuery.map( name, jQuery.camelCase ) );\n				}\n\n				i = name.length;\n				while ( i-- ) {\n					delete thisCache[ name[i] ];\n				}\n\n				// If there is no data left in the cache, we want to continue\n				// and let the cache object itself get destroyed\n				if ( pvt ? !isEmptyDataObject(thisCache) : !jQuery.isEmptyObject(thisCache) ) {\n					return;\n				}\n			}\n		}\n\n		// See jQuery.data for more information\n		if ( !pvt ) {\n			delete cache[ id ].data;\n\n			// Don\'t destroy the parent cache unless the internal data object\n			// had been the only thing left in it\n			if ( !isEmptyDataObject( cache[ id ] ) ) {\n				return;\n			}\n		}\n\n		// Destroy the cache\n		if ( isNode ) {\n			jQuery.cleanData( [ elem ], true );\n\n			// Use delete when supported for expandos or `cache` is not a window per isWindow (#10080)\n			/* jshint eqeqeq: false */\n		} else if ( jQuery.support.deleteExpando || cache != cache.window ) {\n			/* jshint eqeqeq: true */\n			delete cache[ id ];\n\n			// When all else fails, null\n		} else {\n			cache[ id ] = null;\n		}\n	}\n\n	jQuery.extend({\n		cache: {},\n\n		// The following elements throw uncatchable exceptions if you\n		// attempt to add expando properties to them.\n		noData: {\n			"applet": true,\n			"embed": true,\n			// Ban all objects except for Flash (which handle expandos)\n			"object": "clsid:D27CDB6E-AE6D-11cf-96B8-444553540000"\n		},\n\n		hasData: function( elem ) {\n			elem = elem.nodeType ? jQuery.cache[ elem[jQuery.expando] ] : elem[ jQuery.expando ];\n			return !!elem && !isEmptyDataObject( elem );\n		},\n\n		data: function( elem, name, data ) {\n			return internalData( elem, name, data );\n		},\n\n		removeData: function( elem, name ) {\n			return internalRemoveData( elem, name );\n		},\n\n		// For internal use only.\n		_data: function( elem, name, data ) {\n			return internalData( elem, name, data, true );\n		},\n\n		_removeData: function( elem, name ) {\n			return internalRemoveData( elem, name, true );\n		},\n\n		// A method for determining if a DOM node can handle the data expando\n		acceptData: function( elem ) {\n			// Do not set data on non-element because it will not be cleared (#8335).\n			if ( elem.nodeType && elem.nodeType !== 1 && elem.nodeType !== 9 ) {\n				return false;\n			}\n\n			var noData = elem.nodeName && jQuery.noData[ elem.nodeName.toLowerCase() ];\n\n			// nodes accept data unless otherwise specified; rejection can be conditional\n			return !noData || noData !== true && elem.getAttribute("classid") === noData;\n		}\n	});\n\n	jQuery.fn.extend({\n		data: function( key, value ) {\n			var attrs, name,\n				data = null,\n				i = 0,\n				elem = this[0];\n\n			// Special expections of .data basically thwart jQuery.access,\n			// so implement the relevant behavior ourselves\n\n			// Gets all values\n			if ( key === undefined ) {\n				if ( this.length ) {\n					data = jQuery.data( elem );\n\n					if ( elem.nodeType === 1 && !jQuery._data( elem, "parsedAttrs" ) ) {\n						attrs = elem.attributes;\n						for ( ; i < attrs.length; i++ ) {\n							name = attrs[i].name;\n\n							if ( name.indexOf("data-") === 0 ) {\n								name = jQuery.camelCase( name.slice(5) );\n\n								dataAttr( elem, name, data[ name ] );\n							}\n						}\n						jQuery._data( elem, "parsedAttrs", true );\n					}\n				}\n\n				return data;\n			}\n\n			// Sets multiple values\n			if ( typeof key === "object" ) {\n				return this.each(function() {\n					jQuery.data( this, key );\n				});\n			}\n\n			return arguments.length > 1 ?\n\n				// Sets one value\n				this.each(function() {\n					jQuery.data( this, key, value );\n				}) :\n\n				// Gets one value\n				// Try to fetch any internally stored data first\n				elem ? dataAttr( elem, key, jQuery.data( elem, key ) ) : null;\n		},\n\n		removeData: function( key ) {\n			return this.each(function() {\n				jQuery.removeData( this, key );\n			});\n		}\n	});\n\n	function dataAttr( elem, key, data ) {\n		// If nothing was found internally, try to fetch any\n		// data from the HTML5 data-* attribute\n		if ( data === undefined && elem.nodeType === 1 ) {\n\n			var name = "data-" + key.replace( rmultiDash, "-$1" ).toLowerCase();\n\n			data = elem.getAttribute( name );\n\n			if ( typeof data === "string" ) {\n				try {\n					data = data === "true" ? true :\n						data === "false" ? false :\n							data === "null" ? null :\n								// Only convert to a number if it doesn\'t change the string\n								+data + "" === data ? +data :\n									rbrace.test( data ) ? jQuery.parseJSON( data ) :\n										data;\n				} catch( e ) {}\n\n				// Make sure we set the data so it isn\'t changed later\n				jQuery.data( elem, key, data );\n\n			} else {\n				data = undefined;\n			}\n		}\n\n		return data;\n	}\n\n// checks a cache object for emptiness\n	function isEmptyDataObject( obj ) {\n		var name;\n		for ( name in obj ) {\n\n			// if the public data object is empty, the private is still empty\n			if ( name === "data" && jQuery.isEmptyObject( obj[name] ) ) {\n				continue;\n			}\n			if ( name !== "toJSON" ) {\n				return false;\n			}\n		}\n\n		return true;\n	}\n	jQuery.extend({\n		queue: function( elem, type, data ) {\n			var queue;\n\n			if ( elem ) {\n				type = ( type || "fx" ) + "queue";\n				queue = jQuery._data( elem, type );\n\n				// Speed up dequeue by getting out quickly if this is just a lookup\n				if ( data ) {\n					if ( !queue || jQuery.isArray(data) ) {\n						queue = jQuery._data( elem, type, jQuery.makeArray(data) );\n					} else {\n						queue.push( data );\n					}\n				}\n				return queue || [];\n			}\n		},\n\n		dequeue: function( elem, type ) {\n			type = type || "fx";\n\n			var queue = jQuery.queue( elem, type ),\n				startLength = queue.length,\n				fn = queue.shift(),\n				hooks = jQuery._queueHooks( elem, type ),\n				next = function() {\n					jQuery.dequeue( elem, type );\n				};\n\n			// If the fx queue is dequeued, always remove the progress sentinel\n			if ( fn === "inprogress" ) {\n				fn = queue.shift();\n				startLength--;\n			}\n\n			if ( fn ) {\n\n				// Add a progress sentinel to prevent the fx queue from being\n				// automatically dequeued\n				if ( type === "fx" ) {\n					queue.unshift( "inprogress" );\n				}\n\n				// clear up the last queue stop function\n				delete hooks.stop;\n				fn.call( elem, next, hooks );\n			}\n\n			if ( !startLength && hooks ) {\n				hooks.empty.fire();\n			}\n		},\n\n		// not intended for public consumption - generates a queueHooks object, or returns the current one\n		_queueHooks: function( elem, type ) {\n			var key = type + "queueHooks";\n			return jQuery._data( elem, key ) || jQuery._data( elem, key, {\n				empty: jQuery.Callbacks("once memory").add(function() {\n					jQuery._removeData( elem, type + "queue" );\n					jQuery._removeData( elem, key );\n				})\n			});\n		}\n	});\n\n	jQuery.fn.extend({\n		queue: function( type, data ) {\n			var setter = 2;\n\n			if ( typeof type !== "string" ) {\n				data = type;\n				type = "fx";\n				setter--;\n			}\n\n			if ( arguments.length < setter ) {\n				return jQuery.queue( this[0], type );\n			}\n\n			return data === undefined ?\n				this :\n				this.each(function() {\n					var queue = jQuery.queue( this, type, data );\n\n					// ensure a hooks for this queue\n					jQuery._queueHooks( this, type );\n\n					if ( type === "fx" && queue[0] !== "inprogress" ) {\n						jQuery.dequeue( this, type );\n					}\n				});\n		},\n		dequeue: function( type ) {\n			return this.each(function() {\n				jQuery.dequeue( this, type );\n			});\n		},\n		// Based off of the plugin by Clint Helfers, with permission.\n		// http://blindsignals.com/index.php/2009/07/jquery-delay/\n		delay: function( time, type ) {\n			time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;\n			type = type || "fx";\n\n			return this.queue( type, function( next, hooks ) {\n				var timeout = setTimeout( next, time );\n				hooks.stop = function() {\n					clearTimeout( timeout );\n				};\n			});\n		},\n		clearQueue: function( type ) {\n			return this.queue( type || "fx", [] );\n		},\n		// Get a promise resolved when queues of a certain type\n		// are emptied (fx is the type by default)\n		promise: function( type, obj ) {\n			var tmp,\n				count = 1,\n				defer = jQuery.Deferred(),\n				elements = this,\n				i = this.length,\n				resolve = function() {\n					if ( !( --count ) ) {\n						defer.resolveWith( elements, [ elements ] );\n					}\n				};\n\n			if ( typeof type !== "string" ) {\n				obj = type;\n				type = undefined;\n			}\n			type = type || "fx";\n\n			while( i-- ) {\n				tmp = jQuery._data( elements[ i ], type + "queueHooks" );\n				if ( tmp && tmp.empty ) {\n					count++;\n					tmp.empty.add( resolve );\n				}\n			}\n			resolve();\n			return defer.promise( obj );\n		}\n	});\n	var nodeHook, boolHook,\n		rclass = /[\\t\\r\\n\\f]/g,\n		rreturn = /\\r/g,\n		rfocusable = /^(?:input|select|textarea|button|object)$/i,\n		rclickable = /^(?:a|area)$/i,\n		ruseDefault = /^(?:checked|selected)$/i,\n		getSetAttribute = jQuery.support.getSetAttribute,\n		getSetInput = jQuery.support.input;\n\n	jQuery.fn.extend({\n		attr: function( name, value ) {\n			return jQuery.access( this, jQuery.attr, name, value, arguments.length > 1 );\n		},\n\n		removeAttr: function( name ) {\n			return this.each(function() {\n				jQuery.removeAttr( this, name );\n			});\n		},\n\n		prop: function( name, value ) {\n			return jQuery.access( this, jQuery.prop, name, value, arguments.length > 1 );\n		},\n\n		removeProp: function( name ) {\n			name = jQuery.propFix[ name ] || name;\n			return this.each(function() {\n				// try/catch handles cases where IE balks (such as removing a property on window)\n				try {\n					this[ name ] = undefined;\n					delete this[ name ];\n				} catch( e ) {}\n			});\n		},\n\n		addClass: function( value ) {\n			var classes, elem, cur, clazz, j,\n				i = 0,\n				len = this.length,\n				proceed = typeof value === "string" && value;\n\n			if ( jQuery.isFunction( value ) ) {\n				return this.each(function( j ) {\n					jQuery( this ).addClass( value.call( this, j, this.className ) );\n				});\n			}\n\n			if ( proceed ) {\n				// The disjunction here is for better compressibility (see removeClass)\n				classes = ( value || "" ).match( core_rnotwhite ) || [];\n\n				for ( ; i < len; i++ ) {\n					elem = this[ i ];\n					cur = elem.nodeType === 1 && ( elem.className ?\n						( " " + elem.className + " " ).replace( rclass, " " ) :\n						" "\n						);\n\n					if ( cur ) {\n						j = 0;\n						while ( (clazz = classes[j++]) ) {\n							if ( cur.indexOf( " " + clazz + " " ) < 0 ) {\n								cur += clazz + " ";\n							}\n						}\n						elem.className = jQuery.trim( cur );\n\n					}\n				}\n			}\n\n			return this;\n		},\n\n		removeClass: function( value ) {\n			var classes, elem, cur, clazz, j,\n				i = 0,\n				len = this.length,\n				proceed = arguments.length === 0 || typeof value === "string" && value;\n\n			if ( jQuery.isFunction( value ) ) {\n				return this.each(function( j ) {\n					jQuery( this ).removeClass( value.call( this, j, this.className ) );\n				});\n			}\n			if ( proceed ) {\n				classes = ( value || "" ).match( core_rnotwhite ) || [];\n\n				for ( ; i < len; i++ ) {\n					elem = this[ i ];\n					// This expression is here for better compressibility (see addClass)\n					cur = elem.nodeType === 1 && ( elem.className ?\n						( " " + elem.className + " " ).replace( rclass, " " ) :\n						""\n						);\n\n					if ( cur ) {\n						j = 0;\n						while ( (clazz = classes[j++]) ) {\n							// Remove *all* instances\n							while ( cur.indexOf( " " + clazz + " " ) >= 0 ) {\n								cur = cur.replace( " " + clazz + " ", " " );\n							}\n						}\n						elem.className = value ? jQuery.trim( cur ) : "";\n					}\n				}\n			}\n\n			return this;\n		},\n\n		toggleClass: function( value, stateVal ) {\n			var type = typeof value;\n\n			if ( typeof stateVal === "boolean" && type === "string" ) {\n				return stateVal ? this.addClass( value ) : this.removeClass( value );\n			}\n\n			if ( jQuery.isFunction( value ) ) {\n				return this.each(function( i ) {\n					jQuery( this ).toggleClass( value.call(this, i, this.className, stateVal), stateVal );\n				});\n			}\n\n			return this.each(function() {\n				if ( type === "string" ) {\n					// toggle individual class names\n					var className,\n						i = 0,\n						self = jQuery( this ),\n						classNames = value.match( core_rnotwhite ) || [];\n\n					while ( (className = classNames[ i++ ]) ) {\n						// check each className given, space separated list\n						if ( self.hasClass( className ) ) {\n							self.removeClass( className );\n						} else {\n							self.addClass( className );\n						}\n					}\n\n					// Toggle whole class name\n				} else if ( type === core_strundefined || type === "boolean" ) {\n					if ( this.className ) {\n						// store className if set\n						jQuery._data( this, "__className__", this.className );\n					}\n\n					// If the element has a class name or if we\'re passed "false",\n					// then remove the whole classname (if there was one, the above saved it).\n					// Otherwise bring back whatever was previously saved (if anything),\n					// falling back to the empty string if nothing was stored.\n					this.className = this.className || value === false ? "" : jQuery._data( this, "__className__" ) || "";\n				}\n			});\n		},\n\n		hasClass: function( selector ) {\n			var className = " " + selector + " ",\n				i = 0,\n				l = this.length;\n			for ( ; i < l; i++ ) {\n				if ( this[i].nodeType === 1 && (" " + this[i].className + " ").replace(rclass, " ").indexOf( className ) >= 0 ) {\n					return true;\n				}\n			}\n\n			return false;\n		},\n\n		val: function( value ) {\n			var ret, hooks, isFunction,\n				elem = this[0];\n\n			if ( !arguments.length ) {\n				if ( elem ) {\n					hooks = jQuery.valHooks[ elem.type ] || jQuery.valHooks[ elem.nodeName.toLowerCase() ];\n\n					if ( hooks && "get" in hooks && (ret = hooks.get( elem, "value" )) !== undefined ) {\n						return ret;\n					}\n\n					ret = elem.value;\n\n					return typeof ret === "string" ?\n						// handle most common string cases\n						ret.replace(rreturn, "") :\n						// handle cases where value is null/undef or number\n						ret == null ? "" : ret;\n				}\n\n				return;\n			}\n\n			isFunction = jQuery.isFunction( value );\n\n			return this.each(function( i ) {\n				var val;\n\n				if ( this.nodeType !== 1 ) {\n					return;\n				}\n\n				if ( isFunction ) {\n					val = value.call( this, i, jQuery( this ).val() );\n				} else {\n					val = value;\n				}\n\n				// Treat null/undefined as ""; convert numbers to string\n				if ( val == null ) {\n					val = "";\n				} else if ( typeof val === "number" ) {\n					val += "";\n				} else if ( jQuery.isArray( val ) ) {\n					val = jQuery.map(val, function ( value ) {\n						return value == null ? "" : value + "";\n					});\n				}\n\n				hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];\n\n				// If set returns undefined, fall back to normal setting\n				if ( !hooks || !("set" in hooks) || hooks.set( this, val, "value" ) === undefined ) {\n					this.value = val;\n				}\n			});\n		}\n	});\n\n	jQuery.extend({\n		valHooks: {\n			option: {\n				get: function( elem ) {\n					// Use proper attribute retrieval(#6932, #12072)\n					var val = jQuery.find.attr( elem, "value" );\n					return val != null ?\n						val :\n						elem.text;\n				}\n			},\n			select: {\n				get: function( elem ) {\n					var value, option,\n						options = elem.options,\n						index = elem.selectedIndex,\n						one = elem.type === "select-one" || index < 0,\n						values = one ? null : [],\n						max = one ? index + 1 : options.length,\n						i = index < 0 ?\n							max :\n							one ? index : 0;\n\n					// Loop through all the selected options\n					for ( ; i < max; i++ ) {\n						option = options[ i ];\n\n						// oldIE doesn\'t update selected after form reset (#2551)\n						if ( ( option.selected || i === index ) &&\n							// Don\'t return options that are disabled or in a disabled optgroup\n							( jQuery.support.optDisabled ? !option.disabled : option.getAttribute("disabled") === null ) &&\n							( !option.parentNode.disabled || !jQuery.nodeName( option.parentNode, "optgroup" ) ) ) {\n\n							// Get the specific value for the option\n							value = jQuery( option ).val();\n\n							// We don\'t need an array for one selects\n							if ( one ) {\n								return value;\n							}\n\n							// Multi-Selects return an array\n							values.push( value );\n						}\n					}\n\n					return values;\n				},\n\n				set: function( elem, value ) {\n					var optionSet, option,\n						options = elem.options,\n						values = jQuery.makeArray( value ),\n						i = options.length;\n\n					while ( i-- ) {\n						option = options[ i ];\n						if ( (option.selected = jQuery.inArray( jQuery(option).val(), values ) >= 0) ) {\n							optionSet = true;\n						}\n					}\n\n					// force browsers to behave consistently when non-matching value is set\n					if ( !optionSet ) {\n						elem.selectedIndex = -1;\n					}\n					return values;\n				}\n			}\n		},\n\n		attr: function( elem, name, value ) {\n			var hooks, ret,\n				nType = elem.nodeType;\n\n			// don\'t get/set attributes on text, comment and attribute nodes\n			if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {\n				return;\n			}\n\n			// Fallback to prop when attributes are not supported\n			if ( typeof elem.getAttribute === core_strundefined ) {\n				return jQuery.prop( elem, name, value );\n			}\n\n			// All attributes are lowercase\n			// Grab necessary hook if one is defined\n			if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {\n				name = name.toLowerCase();\n				hooks = jQuery.attrHooks[ name ] ||\n					( jQuery.expr.match.bool.test( name ) ? boolHook : nodeHook );\n			}\n\n			if ( value !== undefined ) {\n\n				if ( value === null ) {\n					jQuery.removeAttr( elem, name );\n\n				} else if ( hooks && "set" in hooks && (ret = hooks.set( elem, value, name )) !== undefined ) {\n					return ret;\n\n				} else {\n					elem.setAttribute( name, value + "" );\n					return value;\n				}\n\n			} else if ( hooks && "get" in hooks && (ret = hooks.get( elem, name )) !== null ) {\n				return ret;\n\n			} else {\n				ret = jQuery.find.attr( elem, name );\n\n				// Non-existent attributes return null, we normalize to undefined\n				return ret == null ?\n					undefined :\n					ret;\n			}\n		},\n\n		removeAttr: function( elem, value ) {\n			var name, propName,\n				i = 0,\n				attrNames = value && value.match( core_rnotwhite );\n\n			if ( attrNames && elem.nodeType === 1 ) {\n				while ( (name = attrNames[i++]) ) {\n					propName = jQuery.propFix[ name ] || name;\n\n					// Boolean attributes get special treatment (#10870)\n					if ( jQuery.expr.match.bool.test( name ) ) {\n						// Set corresponding property to false\n						if ( getSetInput && getSetAttribute || !ruseDefault.test( name ) ) {\n							elem[ propName ] = false;\n							// Support: IE<9\n							// Also clear defaultChecked/defaultSelected (if appropriate)\n						} else {\n							elem[ jQuery.camelCase( "default-" + name ) ] =\n								elem[ propName ] = false;\n						}\n\n						// See #9699 for explanation of this approach (setting first, then removal)\n					} else {\n						jQuery.attr( elem, name, "" );\n					}\n\n					elem.removeAttribute( getSetAttribute ? name : propName );\n				}\n			}\n		},\n\n		attrHooks: {\n			type: {\n				set: function( elem, value ) {\n					if ( !jQuery.support.radioValue && value === "radio" && jQuery.nodeName(elem, "input") ) {\n						// Setting the type on a radio button after the value resets the value in IE6-9\n						// Reset value to default in case type is set after value during creation\n						var val = elem.value;\n						elem.setAttribute( "type", value );\n						if ( val ) {\n							elem.value = val;\n						}\n						return value;\n					}\n				}\n			}\n		},\n\n		propFix: {\n			"for": "htmlFor",\n			"class": "className"\n		},\n\n		prop: function( elem, name, value ) {\n			var ret, hooks, notxml,\n				nType = elem.nodeType;\n\n			// don\'t get/set properties on text, comment and attribute nodes\n			if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {\n				return;\n			}\n\n			notxml = nType !== 1 || !jQuery.isXMLDoc( elem );\n\n			if ( notxml ) {\n				// Fix name and attach hooks\n				name = jQuery.propFix[ name ] || name;\n				hooks = jQuery.propHooks[ name ];\n			}\n\n			if ( value !== undefined ) {\n				return hooks && "set" in hooks && (ret = hooks.set( elem, value, name )) !== undefined ?\n					ret :\n					( elem[ name ] = value );\n\n			} else {\n				return hooks && "get" in hooks && (ret = hooks.get( elem, name )) !== null ?\n					ret :\n					elem[ name ];\n			}\n		},\n\n		propHooks: {\n			tabIndex: {\n				get: function( elem ) {\n					// elem.tabIndex doesn\'t always return the correct value when it hasn\'t been explicitly set\n					// http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/\n					// Use proper attribute retrieval(#12072)\n					var tabindex = jQuery.find.attr( elem, "tabindex" );\n\n					return tabindex ?\n						parseInt( tabindex, 10 ) :\n						rfocusable.test( elem.nodeName ) || rclickable.test( elem.nodeName ) && elem.href ?\n							0 :\n							-1;\n				}\n			}\n		}\n	});\n\n// Hooks for boolean attributes\n	boolHook = {\n		set: function( elem, value, name ) {\n			if ( value === false ) {\n				// Remove boolean attributes when set to false\n				jQuery.removeAttr( elem, name );\n			} else if ( getSetInput && getSetAttribute || !ruseDefault.test( name ) ) {\n				// IE<8 needs the *property* name\n				elem.setAttribute( !getSetAttribute && jQuery.propFix[ name ] || name, name );\n\n				// Use defaultChecked and defaultSelected for oldIE\n			} else {\n				elem[ jQuery.camelCase( "default-" + name ) ] = elem[ name ] = true;\n			}\n\n			return name;\n		}\n	};\n	jQuery.each( jQuery.expr.match.bool.source.match( /\\w+/g ), function( i, name ) {\n		var getter = jQuery.expr.attrHandle[ name ] || jQuery.find.attr;\n\n		jQuery.expr.attrHandle[ name ] = getSetInput && getSetAttribute || !ruseDefault.test( name ) ?\n			function( elem, name, isXML ) {\n				var fn = jQuery.expr.attrHandle[ name ],\n					ret = isXML ?\n						undefined :\n						/* jshint eqeqeq: false */\n						(jQuery.expr.attrHandle[ name ] = undefined) !=\n							getter( elem, name, isXML ) ?\n\n							name.toLowerCase() :\n							null;\n				jQuery.expr.attrHandle[ name ] = fn;\n				return ret;\n			} :\n			function( elem, name, isXML ) {\n				return isXML ?\n					undefined :\n					elem[ jQuery.camelCase( "default-" + name ) ] ?\n						name.toLowerCase() :\n						null;\n			};\n	});\n\n// fix oldIE attroperties\n	if ( !getSetInput || !getSetAttribute ) {\n		jQuery.attrHooks.value = {\n			set: function( elem, value, name ) {\n				if ( jQuery.nodeName( elem, "input" ) ) {\n					// Does not return so that setAttribute is also used\n					elem.defaultValue = value;\n				} else {\n					// Use nodeHook if defined (#1954); otherwise setAttribute is fine\n					return nodeHook && nodeHook.set( elem, value, name );\n				}\n			}\n		};\n	}\n\n// IE6/7 do not support getting/setting some attributes with get/setAttribute\n	if ( !getSetAttribute ) {\n\n		// Use this for any attribute in IE6/7\n		// This fixes almost every IE6/7 issue\n		nodeHook = {\n			set: function( elem, value, name ) {\n				// Set the existing or create a new attribute node\n				var ret = elem.getAttributeNode( name );\n				if ( !ret ) {\n					elem.setAttributeNode(\n						(ret = elem.ownerDocument.createAttribute( name ))\n					);\n				}\n\n				ret.value = value += "";\n\n				// Break association with cloned elements by also using setAttribute (#9646)\n				return name === "value" || value === elem.getAttribute( name ) ?\n					value :\n					undefined;\n			}\n		};\n		jQuery.expr.attrHandle.id = jQuery.expr.attrHandle.name = jQuery.expr.attrHandle.coords =\n			// Some attributes are constructed with empty-string values when not defined\n			function( elem, name, isXML ) {\n				var ret;\n				return isXML ?\n					undefined :\n					(ret = elem.getAttributeNode( name )) && ret.value !== "" ?\n						ret.value :\n						null;\n			};\n		jQuery.valHooks.button = {\n			get: function( elem, name ) {\n				var ret = elem.getAttributeNode( name );\n				return ret && ret.specified ?\n					ret.value :\n					undefined;\n			},\n			set: nodeHook.set\n		};\n\n		// Set contenteditable to false on removals(#10429)\n		// Setting to empty string throws an error as an invalid value\n		jQuery.attrHooks.contenteditable = {\n			set: function( elem, value, name ) {\n				nodeHook.set( elem, value === "" ? false : value, name );\n			}\n		};\n\n		// Set width and height to auto instead of 0 on empty string( Bug #8150 )\n		// This is for removals\n		jQuery.each([ "width", "height" ], function( i, name ) {\n			jQuery.attrHooks[ name ] = {\n				set: function( elem, value ) {\n					if ( value === "" ) {\n						elem.setAttribute( name, "auto" );\n						return value;\n					}\n				}\n			};\n		});\n	}\n\n\n// Some attributes require a special call on IE\n// http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx\n	if ( !jQuery.support.hrefNormalized ) {\n		// href/src property should get the full normalized URL (#10299/#12915)\n		jQuery.each([ "href", "src" ], function( i, name ) {\n			jQuery.propHooks[ name ] = {\n				get: function( elem ) {\n					return elem.getAttribute( name, 4 );\n				}\n			};\n		});\n	}\n\n	if ( !jQuery.support.style ) {\n		jQuery.attrHooks.style = {\n			get: function( elem ) {\n				// Return undefined in the case of empty string\n				// Note: IE uppercases css property names, but if we were to .toLowerCase()\n				// .cssText, that would destroy case senstitivity in URL\'s, like in "background"\n				return elem.style.cssText || undefined;\n			},\n			set: function( elem, value ) {\n				return ( elem.style.cssText = value + "" );\n			}\n		};\n	}\n\n// Safari mis-reports the default selected property of an option\n// Accessing the parent\'s selectedIndex property fixes it\n	if ( !jQuery.support.optSelected ) {\n		jQuery.propHooks.selected = {\n			get: function( elem ) {\n				var parent = elem.parentNode;\n\n				if ( parent ) {\n					parent.selectedIndex;\n\n					// Make sure that it also works with optgroups, see #5701\n					if ( parent.parentNode ) {\n						parent.parentNode.selectedIndex;\n					}\n				}\n				return null;\n			}\n		};\n	}\n\n	jQuery.each([\n		"tabIndex",\n		"readOnly",\n		"maxLength",\n		"cellSpacing",\n		"cellPadding",\n		"rowSpan",\n		"colSpan",\n		"useMap",\n		"frameBorder",\n		"contentEditable"\n	], function() {\n		jQuery.propFix[ this.toLowerCase() ] = this;\n	});\n\n// IE6/7 call enctype encoding\n	if ( !jQuery.support.enctype ) {\n		jQuery.propFix.enctype = "encoding";\n	}\n\n// Radios and checkboxes getter/setter\n	jQuery.each([ "radio", "checkbox" ], function() {\n		jQuery.valHooks[ this ] = {\n			set: function( elem, value ) {\n				if ( jQuery.isArray( value ) ) {\n					return ( elem.checked = jQuery.inArray( jQuery(elem).val(), value ) >= 0 );\n				}\n			}\n		};\n		if ( !jQuery.support.checkOn ) {\n			jQuery.valHooks[ this ].get = function( elem ) {\n				// Support: Webkit\n				// "" is returned instead of "on" if a value isn\'t specified\n				return elem.getAttribute("value") === null ? "on" : elem.value;\n			};\n		}\n	});\n	var rformElems = /^(?:input|select|textarea)$/i,\n		rkeyEvent = /^key/,\n		rmouseEvent = /^(?:mouse|contextmenu)|click/,\n		rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,\n		rtypenamespace = /^([^.]*)(?:\\.(.+)|)$/;\n\n	function returnTrue() {\n		return true;\n	}\n\n	function returnFalse() {\n		return false;\n	}\n\n	function safeActiveElement() {\n		try {\n			return document.activeElement;\n		} catch ( err ) { }\n	}\n\n	/*\n	 * Helper functions for managing events -- not part of the public interface.\n	 * Props to Dean Edwards\' addEvent library for many of the ideas.\n	 */\n	jQuery.event = {\n\n		global: {},\n\n		add: function( elem, types, handler, data, selector ) {\n			var tmp, events, t, handleObjIn,\n				special, eventHandle, handleObj,\n				handlers, type, namespaces, origType,\n				elemData = jQuery._data( elem );\n\n			// Don\'t attach events to noData or text/comment nodes (but allow plain objects)\n			if ( !elemData ) {\n				return;\n			}\n\n			// Caller can pass in an object of custom data in lieu of the handler\n			if ( handler.handler ) {\n				handleObjIn = handler;\n				handler = handleObjIn.handler;\n				selector = handleObjIn.selector;\n			}\n\n			// Make sure that the handler has a unique ID, used to find/remove it later\n			if ( !handler.guid ) {\n				handler.guid = jQuery.guid++;\n			}\n\n			// Init the element\'s event structure and main handler, if this is the first\n			if ( !(events = elemData.events) ) {\n				events = elemData.events = {};\n			}\n			if ( !(eventHandle = elemData.handle) ) {\n				eventHandle = elemData.handle = function( e ) {\n					// Discard the second event of a jQuery.event.trigger() and\n					// when an event is called after a page has unloaded\n					return typeof jQuery !== core_strundefined && (!e || jQuery.event.triggered !== e.type) ?\n						jQuery.event.dispatch.apply( eventHandle.elem, arguments ) :\n						undefined;\n				};\n				// Add elem as a property of the handle fn to prevent a memory leak with IE non-native events\n				eventHandle.elem = elem;\n			}\n\n			// Handle multiple events separated by a space\n			types = ( types || "" ).match( core_rnotwhite ) || [""];\n			t = types.length;\n			while ( t-- ) {\n				tmp = rtypenamespace.exec( types[t] ) || [];\n				type = origType = tmp[1];\n				namespaces = ( tmp[2] || "" ).split( "." ).sort();\n\n				// There *must* be a type, no attaching namespace-only handlers\n				if ( !type ) {\n					continue;\n				}\n\n				// If event changes its type, use the special event handlers for the changed type\n				special = jQuery.event.special[ type ] || {};\n\n				// If selector defined, determine special event api type, otherwise given type\n				type = ( selector ? special.delegateType : special.bindType ) || type;\n\n				// Update special based on newly reset type\n				special = jQuery.event.special[ type ] || {};\n\n				// handleObj is passed to all event handlers\n				handleObj = jQuery.extend({\n					type: type,\n					origType: origType,\n					data: data,\n					handler: handler,\n					guid: handler.guid,\n					selector: selector,\n					needsContext: selector && jQuery.expr.match.needsContext.test( selector ),\n					namespace: namespaces.join(".")\n				}, handleObjIn );\n\n				// Init the event handler queue if we\'re the first\n				if ( !(handlers = events[ type ]) ) {\n					handlers = events[ type ] = [];\n					handlers.delegateCount = 0;\n\n					// Only use addEventListener/attachEvent if the special events handler returns false\n					if ( !special.setup || special.setup.call( elem, data, namespaces, eventHandle ) === false ) {\n						// Bind the global event handler to the element\n						if ( elem.addEventListener ) {\n							elem.addEventListener( type, eventHandle, false );\n\n						} else if ( elem.attachEvent ) {\n							elem.attachEvent( "on" + type, eventHandle );\n						}\n					}\n				}\n\n				if ( special.add ) {\n					special.add.call( elem, handleObj );\n\n					if ( !handleObj.handler.guid ) {\n						handleObj.handler.guid = handler.guid;\n					}\n				}\n\n				// Add to the element\'s handler list, delegates in front\n				if ( selector ) {\n					handlers.splice( handlers.delegateCount++, 0, handleObj );\n				} else {\n					handlers.push( handleObj );\n				}\n\n				// Keep track of which events have ever been used, for event optimization\n				jQuery.event.global[ type ] = true;\n			}\n\n			// Nullify elem to prevent memory leaks in IE\n			elem = null;\n		},\n\n		// Detach an event or set of events from an element\n		remove: function( elem, types, handler, selector, mappedTypes ) {\n			var j, handleObj, tmp,\n				origCount, t, events,\n				special, handlers, type,\n				namespaces, origType,\n				elemData = jQuery.hasData( elem ) && jQuery._data( elem );\n\n			if ( !elemData || !(events = elemData.events) ) {\n				return;\n			}\n\n			// Once for each type.namespace in types; type may be omitted\n			types = ( types || "" ).match( core_rnotwhite ) || [""];\n			t = types.length;\n			while ( t-- ) {\n				tmp = rtypenamespace.exec( types[t] ) || [];\n				type = origType = tmp[1];\n				namespaces = ( tmp[2] || "" ).split( "." ).sort();\n\n				// Unbind all events (on this namespace, if provided) for the element\n				if ( !type ) {\n					for ( type in events ) {\n						jQuery.event.remove( elem, type + types[ t ], handler, selector, true );\n					}\n					continue;\n				}\n\n				special = jQuery.event.special[ type ] || {};\n				type = ( selector ? special.delegateType : special.bindType ) || type;\n				handlers = events[ type ] || [];\n				tmp = tmp[2] && new RegExp( "(^|\\\\.)" + namespaces.join("\\\\.(?:.*\\\\.|)") + "(\\\\.|$)" );\n\n				// Remove matching events\n				origCount = j = handlers.length;\n				while ( j-- ) {\n					handleObj = handlers[ j ];\n\n					if ( ( mappedTypes || origType === handleObj.origType ) &&\n						( !handler || handler.guid === handleObj.guid ) &&\n						( !tmp || tmp.test( handleObj.namespace ) ) &&\n						( !selector || selector === handleObj.selector || selector === "**" && handleObj.selector ) ) {\n						handlers.splice( j, 1 );\n\n						if ( handleObj.selector ) {\n							handlers.delegateCount--;\n						}\n						if ( special.remove ) {\n							special.remove.call( elem, handleObj );\n						}\n					}\n				}\n\n				// Remove generic event handler if we removed something and no more handlers exist\n				// (avoids potential for endless recursion during removal of special event handlers)\n				if ( origCount && !handlers.length ) {\n					if ( !special.teardown || special.teardown.call( elem, namespaces, elemData.handle ) === false ) {\n						jQuery.removeEvent( elem, type, elemData.handle );\n					}\n\n					delete events[ type ];\n				}\n			}\n\n			// Remove the expando if it\'s no longer used\n			if ( jQuery.isEmptyObject( events ) ) {\n				delete elemData.handle;\n\n				// removeData also checks for emptiness and clears the expando if empty\n				// so use it instead of delete\n				jQuery._removeData( elem, "events" );\n			}\n		},\n\n		trigger: function( event, data, elem, onlyHandlers ) {\n			var handle, ontype, cur,\n				bubbleType, special, tmp, i,\n				eventPath = [ elem || document ],\n				type = core_hasOwn.call( event, "type" ) ? event.type : event,\n				namespaces = core_hasOwn.call( event, "namespace" ) ? event.namespace.split(".") : [];\n\n			cur = tmp = elem = elem || document;\n\n			// Don\'t do events on text and comment nodes\n			if ( elem.nodeType === 3 || elem.nodeType === 8 ) {\n				return;\n			}\n\n			// focus/blur morphs to focusin/out; ensure we\'re not firing them right now\n			if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {\n				return;\n			}\n\n			if ( type.indexOf(".") >= 0 ) {\n				// Namespaced trigger; create a regexp to match event type in handle()\n				namespaces = type.split(".");\n				type = namespaces.shift();\n				namespaces.sort();\n			}\n			ontype = type.indexOf(":") < 0 && "on" + type;\n\n			// Caller can pass in a jQuery.Event object, Object, or just an event type string\n			event = event[ jQuery.expando ] ?\n				event :\n				new jQuery.Event( type, typeof event === "object" && event );\n\n			// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)\n			event.isTrigger = onlyHandlers ? 2 : 3;\n			event.namespace = namespaces.join(".");\n			event.namespace_re = event.namespace ?\n				new RegExp( "(^|\\\\.)" + namespaces.join("\\\\.(?:.*\\\\.|)") + "(\\\\.|$)" ) :\n				null;\n\n			// Clean up the event in case it is being reused\n			event.result = undefined;\n			if ( !event.target ) {\n				event.target = elem;\n			}\n\n			// Clone any incoming data and prepend the event, creating the handler arg list\n			data = data == null ?\n				[ event ] :\n				jQuery.makeArray( data, [ event ] );\n\n			// Allow special events to draw outside the lines\n			special = jQuery.event.special[ type ] || {};\n			if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {\n				return;\n			}\n\n			// Determine event propagation path in advance, per W3C events spec (#9951)\n			// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)\n			if ( !onlyHandlers && !special.noBubble && !jQuery.isWindow( elem ) ) {\n\n				bubbleType = special.delegateType || type;\n				if ( !rfocusMorph.test( bubbleType + type ) ) {\n					cur = cur.parentNode;\n				}\n				for ( ; cur; cur = cur.parentNode ) {\n					eventPath.push( cur );\n					tmp = cur;\n				}\n\n				// Only add window if we got to document (e.g., not plain obj or detached DOM)\n				if ( tmp === (elem.ownerDocument || document) ) {\n					eventPath.push( tmp.defaultView || tmp.parentWindow || window );\n				}\n			}\n\n			// Fire handlers on the event path\n			i = 0;\n			while ( (cur = eventPath[i++]) && !event.isPropagationStopped() ) {\n\n				event.type = i > 1 ?\n					bubbleType :\n					special.bindType || type;\n\n				// jQuery handler\n				handle = ( jQuery._data( cur, "events" ) || {} )[ event.type ] && jQuery._data( cur, "handle" );\n				if ( handle ) {\n					handle.apply( cur, data );\n				}\n\n				// Native handler\n				handle = ontype && cur[ ontype ];\n				if ( handle && jQuery.acceptData( cur ) && handle.apply && handle.apply( cur, data ) === false ) {\n					event.preventDefault();\n				}\n			}\n			event.type = type;\n\n			// If nobody prevented the default action, do it now\n			if ( !onlyHandlers && !event.isDefaultPrevented() ) {\n\n				if ( (!special._default || special._default.apply( eventPath.pop(), data ) === false) &&\n					jQuery.acceptData( elem ) ) {\n\n					// Call a native DOM method on the target with the same name name as the event.\n					// Can\'t use an .isFunction() check here because IE6/7 fails that test.\n					// Don\'t do default actions on window, that\'s where global variables be (#6170)\n					if ( ontype && elem[ type ] && !jQuery.isWindow( elem ) ) {\n\n						// Don\'t re-trigger an onFOO event when we call its FOO() method\n						tmp = elem[ ontype ];\n\n						if ( tmp ) {\n							elem[ ontype ] = null;\n						}\n\n						// Prevent re-triggering of the same event, since we already bubbled it above\n						jQuery.event.triggered = type;\n						try {\n							elem[ type ]();\n						} catch ( e ) {\n							// IE<9 dies on focus/blur to hidden element (#1486,#12518)\n							// only reproducible on winXP IE8 native, not IE9 in IE8 mode\n						}\n						jQuery.event.triggered = undefined;\n\n						if ( tmp ) {\n							elem[ ontype ] = tmp;\n						}\n					}\n				}\n			}\n\n			return event.result;\n		},\n\n		dispatch: function( event ) {\n\n			// Make a writable jQuery.Event from the native event object\n			event = jQuery.event.fix( event );\n\n			var i, ret, handleObj, matched, j,\n				handlerQueue = [],\n				args = core_slice.call( arguments ),\n				handlers = ( jQuery._data( this, "events" ) || {} )[ event.type ] || [],\n				special = jQuery.event.special[ event.type ] || {};\n\n			// Use the fix-ed jQuery.Event rather than the (read-only) native event\n			args[0] = event;\n			event.delegateTarget = this;\n\n			// Call the preDispatch hook for the mapped type, and let it bail if desired\n			if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {\n				return;\n			}\n\n			// Determine handlers\n			handlerQueue = jQuery.event.handlers.call( this, event, handlers );\n\n			// Run delegates first; they may want to stop propagation beneath us\n			i = 0;\n			while ( (matched = handlerQueue[ i++ ]) && !event.isPropagationStopped() ) {\n				event.currentTarget = matched.elem;\n\n				j = 0;\n				while ( (handleObj = matched.handlers[ j++ ]) && !event.isImmediatePropagationStopped() ) {\n\n					// Triggered event must either 1) have no namespace, or\n					// 2) have namespace(s) a subset or equal to those in the bound event (both can have no namespace).\n					if ( !event.namespace_re || event.namespace_re.test( handleObj.namespace ) ) {\n\n						event.handleObj = handleObj;\n						event.data = handleObj.data;\n\n						ret = ( (jQuery.event.special[ handleObj.origType ] || {}).handle || handleObj.handler )\n							.apply( matched.elem, args );\n\n						if ( ret !== undefined ) {\n							if ( (event.result = ret) === false ) {\n								event.preventDefault();\n								event.stopPropagation();\n							}\n						}\n					}\n				}\n			}\n\n			// Call the postDispatch hook for the mapped type\n			if ( special.postDispatch ) {\n				special.postDispatch.call( this, event );\n			}\n\n			return event.result;\n		},\n\n		handlers: function( event, handlers ) {\n			var sel, handleObj, matches, i,\n				handlerQueue = [],\n				delegateCount = handlers.delegateCount,\n				cur = event.target;\n\n			// Find delegate handlers\n			// Black-hole SVG <use> instance trees (#13180)\n			// Avoid non-left-click bubbling in Firefox (#3861)\n			if ( delegateCount && cur.nodeType && (!event.button || event.type !== "click") ) {\n\n				/* jshint eqeqeq: false */\n				for ( ; cur != this; cur = cur.parentNode || this ) {\n					/* jshint eqeqeq: true */\n\n					// Don\'t check non-elements (#13208)\n					// Don\'t process clicks on disabled elements (#6911, #8165, #11382, #11764)\n					if ( cur.nodeType === 1 && (cur.disabled !== true || event.type !== "click") ) {\n						matches = [];\n						for ( i = 0; i < delegateCount; i++ ) {\n							handleObj = handlers[ i ];\n\n							// Don\'t conflict with Object.prototype properties (#13203)\n							sel = handleObj.selector + " ";\n\n							if ( matches[ sel ] === undefined ) {\n								matches[ sel ] = handleObj.needsContext ?\n									jQuery( sel, this ).index( cur ) >= 0 :\n									jQuery.find( sel, this, null, [ cur ] ).length;\n							}\n							if ( matches[ sel ] ) {\n								matches.push( handleObj );\n							}\n						}\n						if ( matches.length ) {\n							handlerQueue.push({ elem: cur, handlers: matches });\n						}\n					}\n				}\n			}\n\n			// Add the remaining (directly-bound) handlers\n			if ( delegateCount < handlers.length ) {\n				handlerQueue.push({ elem: this, handlers: handlers.slice( delegateCount ) });\n			}\n\n			return handlerQueue;\n		},\n\n		fix: function( event ) {\n			if ( event[ jQuery.expando ] ) {\n				return event;\n			}\n\n			// Create a writable copy of the event object and normalize some properties\n			var i, prop, copy,\n				type = event.type,\n				originalEvent = event,\n				fixHook = this.fixHooks[ type ];\n\n			if ( !fixHook ) {\n				this.fixHooks[ type ] = fixHook =\n					rmouseEvent.test( type ) ? this.mouseHooks :\n						rkeyEvent.test( type ) ? this.keyHooks :\n						{};\n			}\n			copy = fixHook.props ? this.props.concat( fixHook.props ) : this.props;\n\n			event = new jQuery.Event( originalEvent );\n\n			i = copy.length;\n			while ( i-- ) {\n				prop = copy[ i ];\n				event[ prop ] = originalEvent[ prop ];\n			}\n\n			// Support: IE<9\n			// Fix target property (#1925)\n			if ( !event.target ) {\n				event.target = originalEvent.srcElement || document;\n			}\n\n			// Support: Chrome 23+, Safari?\n			// Target should not be a text node (#504, #13143)\n			if ( event.target.nodeType === 3 ) {\n				event.target = event.target.parentNode;\n			}\n\n			// Support: IE<9\n			// For mouse/key events, metaKey==false if it\'s undefined (#3368, #11328)\n			event.metaKey = !!event.metaKey;\n\n			return fixHook.filter ? fixHook.filter( event, originalEvent ) : event;\n		},\n\n		// Includes some event props shared by KeyEvent and MouseEvent\n		props: "altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),\n\n		fixHooks: {},\n\n		keyHooks: {\n			props: "char charCode key keyCode".split(" "),\n			filter: function( event, original ) {\n\n				// Add which for key events\n				if ( event.which == null ) {\n					event.which = original.charCode != null ? original.charCode : original.keyCode;\n				}\n\n				return event;\n			}\n		},\n\n		mouseHooks: {\n			props: "button buttons clientX clientY fromElement offsetX offsetY pageX pageY screenX screenY toElement".split(" "),\n			filter: function( event, original ) {\n				var body, eventDoc, doc,\n					button = original.button,\n					fromElement = original.fromElement;\n\n				// Calculate pageX/Y if missing and clientX/Y available\n				if ( event.pageX == null && original.clientX != null ) {\n					eventDoc = event.target.ownerDocument || document;\n					doc = eventDoc.documentElement;\n					body = eventDoc.body;\n\n					event.pageX = original.clientX + ( doc && doc.scrollLeft || body && body.scrollLeft || 0 ) - ( doc && doc.clientLeft || body && body.clientLeft || 0 );\n					event.pageY = original.clientY + ( doc && doc.scrollTop  || body && body.scrollTop  || 0 ) - ( doc && doc.clientTop  || body && body.clientTop  || 0 );\n				}\n\n				// Add relatedTarget, if necessary\n				if ( !event.relatedTarget && fromElement ) {\n					event.relatedTarget = fromElement === event.target ? original.toElement : fromElement;\n				}\n\n				// Add which for click: 1 === left; 2 === middle; 3 === right\n				// Note: button is not normalized, so don\'t use it\n				if ( !event.which && button !== undefined ) {\n					event.which = ( button & 1 ? 1 : ( button & 2 ? 3 : ( button & 4 ? 2 : 0 ) ) );\n				}\n\n				return event;\n			}\n		},\n\n		special: {\n			load: {\n				// Prevent triggered image.load events from bubbling to window.load\n				noBubble: true\n			},\n			focus: {\n				// Fire native event if possible so blur/focus sequence is correct\n				trigger: function() {\n					if ( this !== safeActiveElement() && this.focus ) {\n						try {\n							this.focus();\n							return false;\n						} catch ( e ) {\n							// Support: IE<9\n							// If we error on focus to hidden element (#1486, #12518),\n							// let .trigger() run the handlers\n						}\n					}\n				},\n				delegateType: "focusin"\n			},\n			blur: {\n				trigger: function() {\n					if ( this === safeActiveElement() && this.blur ) {\n						this.blur();\n						return false;\n					}\n				},\n				delegateType: "focusout"\n			},\n			click: {\n				// For checkbox, fire native event so checked state will be right\n				trigger: function() {\n					if ( jQuery.nodeName( this, "input" ) && this.type === "checkbox" && this.click ) {\n						this.click();\n						return false;\n					}\n				},\n\n				// For cross-browser consistency, don\'t fire native .click() on links\n				_default: function( event ) {\n					return jQuery.nodeName( event.target, "a" );\n				}\n			},\n\n			beforeunload: {\n				postDispatch: function( event ) {\n\n					// Even when returnValue equals to undefined Firefox will still show alert\n					if ( event.result !== undefined ) {\n						event.originalEvent.returnValue = event.result;\n					}\n				}\n			}\n		},\n\n		simulate: function( type, elem, event, bubble ) {\n			// Piggyback on a donor event to simulate a different one.\n			// Fake originalEvent to avoid donor\'s stopPropagation, but if the\n			// simulated event prevents default then we do the same on the donor.\n			var e = jQuery.extend(\n				new jQuery.Event(),\n				event,\n				{\n					type: type,\n					isSimulated: true,\n					originalEvent: {}\n				}\n			);\n			if ( bubble ) {\n				jQuery.event.trigger( e, null, elem );\n			} else {\n				jQuery.event.dispatch.call( elem, e );\n			}\n			if ( e.isDefaultPrevented() ) {\n				event.preventDefault();\n			}\n		}\n	};\n\n	jQuery.removeEvent = document.removeEventListener ?\n		function( elem, type, handle ) {\n			if ( elem.removeEventListener ) {\n				elem.removeEventListener( type, handle, false );\n			}\n		} :\n		function( elem, type, handle ) {\n			var name = "on" + type;\n\n			if ( elem.detachEvent ) {\n\n				// #8545, #7054, preventing memory leaks for custom events in IE6-8\n				// detachEvent needed property on element, by name of that event, to properly expose it to GC\n				if ( typeof elem[ name ] === core_strundefined ) {\n					elem[ name ] = null;\n				}\n\n				elem.detachEvent( name, handle );\n			}\n		};\n\n	jQuery.Event = function( src, props ) {\n		// Allow instantiation without the \'new\' keyword\n		if ( !(this instanceof jQuery.Event) ) {\n			return new jQuery.Event( src, props );\n		}\n\n		// Event object\n		if ( src && src.type ) {\n			this.originalEvent = src;\n			this.type = src.type;\n\n			// Events bubbling up the document may have been marked as prevented\n			// by a handler lower down the tree; reflect the correct value.\n			this.isDefaultPrevented = ( src.defaultPrevented || src.returnValue === false ||\n				src.getPreventDefault && src.getPreventDefault() ) ? returnTrue : returnFalse;\n\n			// Event type\n		} else {\n			this.type = src;\n		}\n\n		// Put explicitly provided properties onto the event object\n		if ( props ) {\n			jQuery.extend( this, props );\n		}\n\n		// Create a timestamp if incoming event doesn\'t have one\n		this.timeStamp = src && src.timeStamp || jQuery.now();\n\n		// Mark it as fixed\n		this[ jQuery.expando ] = true;\n	};\n\n// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding\n// http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html\n	jQuery.Event.prototype = {\n		isDefaultPrevented: returnFalse,\n		isPropagationStopped: returnFalse,\n		isImmediatePropagationStopped: returnFalse,\n\n		preventDefault: function() {\n			var e = this.originalEvent;\n\n			this.isDefaultPrevented = returnTrue;\n			if ( !e ) {\n				return;\n			}\n\n			// If preventDefault exists, run it on the original event\n			if ( e.preventDefault ) {\n				e.preventDefault();\n\n				// Support: IE\n				// Otherwise set the returnValue property of the original event to false\n			} else {\n				e.returnValue = false;\n			}\n		},\n		stopPropagation: function() {\n			var e = this.originalEvent;\n\n			this.isPropagationStopped = returnTrue;\n			if ( !e ) {\n				return;\n			}\n			// If stopPropagation exists, run it on the original event\n			if ( e.stopPropagation ) {\n				e.stopPropagation();\n			}\n\n			// Support: IE\n			// Set the cancelBubble property of the original event to true\n			e.cancelBubble = true;\n		},\n		stopImmediatePropagation: function() {\n			this.isImmediatePropagationStopped = returnTrue;\n			this.stopPropagation();\n		}\n	};\n\n// Create mouseenter/leave events using mouseover/out and event-time checks\n	jQuery.each({\n		mouseenter: "mouseover",\n		mouseleave: "mouseout"\n	}, function( orig, fix ) {\n		jQuery.event.special[ orig ] = {\n			delegateType: fix,\n			bindType: fix,\n\n			handle: function( event ) {\n				var ret,\n					target = this,\n					related = event.relatedTarget,\n					handleObj = event.handleObj;\n\n				// For mousenter/leave call the handler if related is outside the target.\n				// NB: No relatedTarget if the mouse left/entered the browser window\n				if ( !related || (related !== target && !jQuery.contains( target, related )) ) {\n					event.type = handleObj.origType;\n					ret = handleObj.handler.apply( this, arguments );\n					event.type = fix;\n				}\n				return ret;\n			}\n		};\n	});\n\n// IE submit delegation\n	if ( !jQuery.support.submitBubbles ) {\n\n		jQuery.event.special.submit = {\n			setup: function() {\n				// Only need this for delegated form submit events\n				if ( jQuery.nodeName( this, "form" ) ) {\n					return false;\n				}\n\n				// Lazy-add a submit handler when a descendant form may potentially be submitted\n				jQuery.event.add( this, "click._submit keypress._submit", function( e ) {\n					// Node name check avoids a VML-related crash in IE (#9807)\n					var elem = e.target,\n						form = jQuery.nodeName( elem, "input" ) || jQuery.nodeName( elem, "button" ) ? elem.form : undefined;\n					if ( form && !jQuery._data( form, "submitBubbles" ) ) {\n						jQuery.event.add( form, "submit._submit", function( event ) {\n							event._submit_bubble = true;\n						});\n						jQuery._data( form, "submitBubbles", true );\n					}\n				});\n				// return undefined since we don\'t need an event listener\n			},\n\n			postDispatch: function( event ) {\n				// If form was submitted by the user, bubble the event up the tree\n				if ( event._submit_bubble ) {\n					delete event._submit_bubble;\n					if ( this.parentNode && !event.isTrigger ) {\n						jQuery.event.simulate( "submit", this.parentNode, event, true );\n					}\n				}\n			},\n\n			teardown: function() {\n				// Only need this for delegated form submit events\n				if ( jQuery.nodeName( this, "form" ) ) {\n					return false;\n				}\n\n				// Remove delegated handlers; cleanData eventually reaps submit handlers attached above\n				jQuery.event.remove( this, "._submit" );\n			}\n		};\n	}\n\n// IE change delegation and checkbox/radio fix\n	if ( !jQuery.support.changeBubbles ) {\n\n		jQuery.event.special.change = {\n\n			setup: function() {\n\n				if ( rformElems.test( this.nodeName ) ) {\n					// IE doesn\'t fire change on a check/radio until blur; trigger it on click\n					// after a propertychange. Eat the blur-change in special.change.handle.\n					// This still fires onchange a second time for check/radio after blur.\n					if ( this.type === "checkbox" || this.type === "radio" ) {\n						jQuery.event.add( this, "propertychange._change", function( event ) {\n							if ( event.originalEvent.propertyName === "checked" ) {\n								this._just_changed = true;\n							}\n						});\n						jQuery.event.add( this, "click._change", function( event ) {\n							if ( this._just_changed && !event.isTrigger ) {\n								this._just_changed = false;\n							}\n							// Allow triggered, simulated change events (#11500)\n							jQuery.event.simulate( "change", this, event, true );\n						});\n					}\n					return false;\n				}\n				// Delegated event; lazy-add a change handler on descendant inputs\n				jQuery.event.add( this, "beforeactivate._change", function( e ) {\n					var elem = e.target;\n\n					if ( rformElems.test( elem.nodeName ) && !jQuery._data( elem, "changeBubbles" ) ) {\n						jQuery.event.add( elem, "change._change", function( event ) {\n							if ( this.parentNode && !event.isSimulated && !event.isTrigger ) {\n								jQuery.event.simulate( "change", this.parentNode, event, true );\n							}\n						});\n						jQuery._data( elem, "changeBubbles", true );\n					}\n				});\n			},\n\n			handle: function( event ) {\n				var elem = event.target;\n\n				// Swallow native change events from checkbox/radio, we already triggered them above\n				if ( this !== elem || event.isSimulated || event.isTrigger || (elem.type !== "radio" && elem.type !== "checkbox") ) {\n					return event.handleObj.handler.apply( this, arguments );\n				}\n			},\n\n			teardown: function() {\n				jQuery.event.remove( this, "._change" );\n\n				return !rformElems.test( this.nodeName );\n			}\n		};\n	}\n\n// Create "bubbling" focus and blur events\n	if ( !jQuery.support.focusinBubbles ) {\n		jQuery.each({ focus: "focusin", blur: "focusout" }, function( orig, fix ) {\n\n			// Attach a single capturing handler while someone wants focusin/focusout\n			var attaches = 0,\n				handler = function( event ) {\n					jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ), true );\n				};\n\n			jQuery.event.special[ fix ] = {\n				setup: function() {\n					if ( attaches++ === 0 ) {\n						document.addEventListener( orig, handler, true );\n					}\n				},\n				teardown: function() {\n					if ( --attaches === 0 ) {\n						document.removeEventListener( orig, handler, true );\n					}\n				}\n			};\n		});\n	}\n\n	jQuery.fn.extend({\n\n		on: function( types, selector, data, fn, /*INTERNAL*/ one ) {\n			var type, origFn;\n\n			// Types can be a map of types/handlers\n			if ( typeof types === "object" ) {\n				// ( types-Object, selector, data )\n				if ( typeof selector !== "string" ) {\n					// ( types-Object, data )\n					data = data || selector;\n					selector = undefined;\n				}\n				for ( type in types ) {\n					this.on( type, selector, data, types[ type ], one );\n				}\n				return this;\n			}\n\n			if ( data == null && fn == null ) {\n				// ( types, fn )\n				fn = selector;\n				data = selector = undefined;\n			} else if ( fn == null ) {\n				if ( typeof selector === "string" ) {\n					// ( types, selector, fn )\n					fn = data;\n					data = undefined;\n				} else {\n					// ( types, data, fn )\n					fn = data;\n					data = selector;\n					selector = undefined;\n				}\n			}\n			if ( fn === false ) {\n				fn = returnFalse;\n			} else if ( !fn ) {\n				return this;\n			}\n\n			if ( one === 1 ) {\n				origFn = fn;\n				fn = function( event ) {\n					// Can use an empty set, since event contains the info\n					jQuery().off( event );\n					return origFn.apply( this, arguments );\n				};\n				// Use same guid so caller can remove using origFn\n				fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );\n			}\n			return this.each( function() {\n				jQuery.event.add( this, types, fn, data, selector );\n			});\n		},\n		one: function( types, selector, data, fn ) {\n			return this.on( types, selector, data, fn, 1 );\n		},\n		off: function( types, selector, fn ) {\n			var handleObj, type;\n			if ( types && types.preventDefault && types.handleObj ) {\n				// ( event )  dispatched jQuery.Event\n				handleObj = types.handleObj;\n				jQuery( types.delegateTarget ).off(\n					handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType,\n					handleObj.selector,\n					handleObj.handler\n				);\n				return this;\n			}\n			if ( typeof types === "object" ) {\n				// ( types-object [, selector] )\n				for ( type in types ) {\n					this.off( type, selector, types[ type ] );\n				}\n				return this;\n			}\n			if ( selector === false || typeof selector === "function" ) {\n				// ( types [, fn] )\n				fn = selector;\n				selector = undefined;\n			}\n			if ( fn === false ) {\n				fn = returnFalse;\n			}\n			return this.each(function() {\n				jQuery.event.remove( this, types, fn, selector );\n			});\n		},\n\n		trigger: function( type, data ) {\n			return this.each(function() {\n				jQuery.event.trigger( type, data, this );\n			});\n		},\n		triggerHandler: function( type, data ) {\n			var elem = this[0];\n			if ( elem ) {\n				return jQuery.event.trigger( type, data, elem, true );\n			}\n		}\n	});\n	var isSimple = /^.[^:#\\[\\.,]*$/,\n		rparentsprev = /^(?:parents|prev(?:Until|All))/,\n		rneedsContext = jQuery.expr.match.needsContext,\n	// methods guaranteed to produce a unique set when starting from a unique set\n		guaranteedUnique = {\n			children: true,\n			contents: true,\n			next: true,\n			prev: true\n		};\n\n	jQuery.fn.extend({\n		find: function( selector ) {\n			var i,\n				ret = [],\n				self = this,\n				len = self.length;\n\n			if ( typeof selector !== "string" ) {\n				return this.pushStack( jQuery( selector ).filter(function() {\n					for ( i = 0; i < len; i++ ) {\n						if ( jQuery.contains( self[ i ], this ) ) {\n							return true;\n						}\n					}\n				}) );\n			}\n\n			for ( i = 0; i < len; i++ ) {\n				jQuery.find( selector, self[ i ], ret );\n			}\n\n			// Needed because $( selector, context ) becomes $( context ).find( selector )\n			ret = this.pushStack( len > 1 ? jQuery.unique( ret ) : ret );\n			ret.selector = this.selector ? this.selector + " " + selector : selector;\n			return ret;\n		},\n\n		has: function( target ) {\n			var i,\n				targets = jQuery( target, this ),\n				len = targets.length;\n\n			return this.filter(function() {\n				for ( i = 0; i < len; i++ ) {\n					if ( jQuery.contains( this, targets[i] ) ) {\n						return true;\n					}\n				}\n			});\n		},\n\n		not: function( selector ) {\n			return this.pushStack( winnow(this, selector || [], true) );\n		},\n\n		filter: function( selector ) {\n			return this.pushStack( winnow(this, selector || [], false) );\n		},\n\n		is: function( selector ) {\n			return !!winnow(\n				this,\n\n				// If this is a positional/relative selector, check membership in the returned set\n				// so $("p:first").is("p:last") won\'t return true for a doc with two "p".\n				typeof selector === "string" && rneedsContext.test( selector ) ?\n					jQuery( selector ) :\n					selector || [],\n				false\n			).length;\n		},\n\n		closest: function( selectors, context ) {\n			var cur,\n				i = 0,\n				l = this.length,\n				ret = [],\n				pos = rneedsContext.test( selectors ) || typeof selectors !== "string" ?\n					jQuery( selectors, context || this.context ) :\n					0;\n\n			for ( ; i < l; i++ ) {\n				for ( cur = this[i]; cur && cur !== context; cur = cur.parentNode ) {\n					// Always skip document fragments\n					if ( cur.nodeType < 11 && (pos ?\n						pos.index(cur) > -1 :\n\n						// Don\'t pass non-elements to Sizzle\n						cur.nodeType === 1 &&\n							jQuery.find.matchesSelector(cur, selectors)) ) {\n\n						cur = ret.push( cur );\n						break;\n					}\n				}\n			}\n\n			return this.pushStack( ret.length > 1 ? jQuery.unique( ret ) : ret );\n		},\n\n		// Determine the position of an element within\n		// the matched set of elements\n		index: function( elem ) {\n\n			// No argument, return index in parent\n			if ( !elem ) {\n				return ( this[0] && this[0].parentNode ) ? this.first().prevAll().length : -1;\n			}\n\n			// index in selector\n			if ( typeof elem === "string" ) {\n				return jQuery.inArray( this[0], jQuery( elem ) );\n			}\n\n			// Locate the position of the desired element\n			return jQuery.inArray(\n				// If it receives a jQuery object, the first element is used\n				elem.jquery ? elem[0] : elem, this );\n		},\n\n		add: function( selector, context ) {\n			var set = typeof selector === "string" ?\n					jQuery( selector, context ) :\n					jQuery.makeArray( selector && selector.nodeType ? [ selector ] : selector ),\n				all = jQuery.merge( this.get(), set );\n\n			return this.pushStack( jQuery.unique(all) );\n		},\n\n		addBack: function( selector ) {\n			return this.add( selector == null ?\n				this.prevObject : this.prevObject.filter(selector)\n			);\n		}\n	});\n\n	function sibling( cur, dir ) {\n		do {\n			cur = cur[ dir ];\n		} while ( cur && cur.nodeType !== 1 );\n\n		return cur;\n	}\n\n	jQuery.each({\n		parent: function( elem ) {\n			var parent = elem.parentNode;\n			return parent && parent.nodeType !== 11 ? parent : null;\n		},\n		parents: function( elem ) {\n			return jQuery.dir( elem, "parentNode" );\n		},\n		parentsUntil: function( elem, i, until ) {\n			return jQuery.dir( elem, "parentNode", until );\n		},\n		next: function( elem ) {\n			return sibling( elem, "nextSibling" );\n		},\n		prev: function( elem ) {\n			return sibling( elem, "previousSibling" );\n		},\n		nextAll: function( elem ) {\n			return jQuery.dir( elem, "nextSibling" );\n		},\n		prevAll: function( elem ) {\n			return jQuery.dir( elem, "previousSibling" );\n		},\n		nextUntil: function( elem, i, until ) {\n			return jQuery.dir( elem, "nextSibling", until );\n		},\n		prevUntil: function( elem, i, until ) {\n			return jQuery.dir( elem, "previousSibling", until );\n		},\n		siblings: function( elem ) {\n			return jQuery.sibling( ( elem.parentNode || {} ).firstChild, elem );\n		},\n		children: function( elem ) {\n			return jQuery.sibling( elem.firstChild );\n		},\n		contents: function( elem ) {\n			return jQuery.nodeName( elem, "iframe" ) ?\n				elem.contentDocument || elem.contentWindow.document :\n				jQuery.merge( [], elem.childNodes );\n		}\n	}, function( name, fn ) {\n		jQuery.fn[ name ] = function( until, selector ) {\n			var ret = jQuery.map( this, fn, until );\n\n			if ( name.slice( -5 ) !== "Until" ) {\n				selector = until;\n			}\n\n			if ( selector && typeof selector === "string" ) {\n				ret = jQuery.filter( selector, ret );\n			}\n\n			if ( this.length > 1 ) {\n				// Remove duplicates\n				if ( !guaranteedUnique[ name ] ) {\n					ret = jQuery.unique( ret );\n				}\n\n				// Reverse order for parents* and prev-derivatives\n				if ( rparentsprev.test( name ) ) {\n					ret = ret.reverse();\n				}\n			}\n\n			return this.pushStack( ret );\n		};\n	});\n\n	jQuery.extend({\n		filter: function( expr, elems, not ) {\n			var elem = elems[ 0 ];\n\n			if ( not ) {\n				expr = ":not(" + expr + ")";\n			}\n\n			return elems.length === 1 && elem.nodeType === 1 ?\n				jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [] :\n				jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {\n					return elem.nodeType === 1;\n				}));\n		},\n\n		dir: function( elem, dir, until ) {\n			var matched = [],\n				cur = elem[ dir ];\n\n			while ( cur && cur.nodeType !== 9 && (until === undefined || cur.nodeType !== 1 || !jQuery( cur ).is( until )) ) {\n				if ( cur.nodeType === 1 ) {\n					matched.push( cur );\n				}\n				cur = cur[dir];\n			}\n			return matched;\n		},\n\n		sibling: function( n, elem ) {\n			var r = [];\n\n			for ( ; n; n = n.nextSibling ) {\n				if ( n.nodeType === 1 && n !== elem ) {\n					r.push( n );\n				}\n			}\n\n			return r;\n		}\n	});\n\n// Implement the identical functionality for filter and not\n	function winnow( elements, qualifier, not ) {\n		if ( jQuery.isFunction( qualifier ) ) {\n			return jQuery.grep( elements, function( elem, i ) {\n				/* jshint -W018 */\n				return !!qualifier.call( elem, i, elem ) !== not;\n			});\n\n		}\n\n		if ( qualifier.nodeType ) {\n			return jQuery.grep( elements, function( elem ) {\n				return ( elem === qualifier ) !== not;\n			});\n\n		}\n\n		if ( typeof qualifier === "string" ) {\n			if ( isSimple.test( qualifier ) ) {\n				return jQuery.filter( qualifier, elements, not );\n			}\n\n			qualifier = jQuery.filter( qualifier, elements );\n		}\n\n		return jQuery.grep( elements, function( elem ) {\n			return ( jQuery.inArray( elem, qualifier ) >= 0 ) !== not;\n		});\n	}\n	function createSafeFragment( document ) {\n		var list = nodeNames.split( "|" ),\n			safeFrag = document.createDocumentFragment();\n\n		if ( safeFrag.createElement ) {\n			while ( list.length ) {\n				safeFrag.createElement(\n					list.pop()\n				);\n			}\n		}\n		return safeFrag;\n	}\n\n	var nodeNames = "abbr|article|aside|audio|bdi|canvas|data|datalist|details|figcaption|figure|footer|" +\n			"header|hgroup|mark|meter|nav|output|progress|section|summary|time|video",\n		rinlinejQuery = / jQuery\\d+="(?:null|\\d+)"/g,\n		rnoshimcache = new RegExp("<(?:" + nodeNames + ")[\\\\s/>]", "i"),\n		rleadingWhitespace = /^\\s+/,\n		rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\\w:]+)[^>]*)\\/>/gi,\n		rtagName = /<([\\w:]+)/,\n		rtbody = /<tbody/i,\n		rhtml = /<|&#?\\w+;/,\n		rnoInnerhtml = /<(?:script|style|link)/i,\n		manipulation_rcheckableType = /^(?:checkbox|radio)$/i,\n	// checked="checked" or checked\n		rchecked = /checked\\s*(?:[^=]|=\\s*.checked.)/i,\n		rscriptType = /^$|\\/(?:java|ecma)script/i,\n		rscriptTypeMasked = /^true\\/(.*)/,\n		rcleanScript = /^\\s*<!(?:\\[CDATA\\[|--)|(?:\\]\\]|--)>\\s*$/g,\n\n	// We have to close these tags to support XHTML (#13200)\n		wrapMap = {\n			option: [ 1, "<select multiple=\'multiple\'>", "</select>" ],\n			legend: [ 1, "<fieldset>", "</fieldset>" ],\n			area: [ 1, "<map>", "</map>" ],\n			param: [ 1, "<object>", "</object>" ],\n			thead: [ 1, "<table>", "</table>" ],\n			tr: [ 2, "<table><tbody>", "</tbody></table>" ],\n			col: [ 2, "<table><tbody></tbody><colgroup>", "</colgroup></table>" ],\n			td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],\n\n			// IE6-8 can\'t serialize link, script, style, or any html5 (NoScope) tags,\n			// unless wrapped in a div with non-breaking characters in front of it.\n			_default: jQuery.support.htmlSerialize ? [ 0, "", "" ] : [ 1, "X<div>", "</div>"  ]\n		},\n		safeFragment = createSafeFragment( document ),\n		fragmentDiv = safeFragment.appendChild( document.createElement("div") );\n\n	wrapMap.optgroup = wrapMap.option;\n	wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;\n	wrapMap.th = wrapMap.td;\n\n	jQuery.fn.extend({\n		text: function( value ) {\n			return jQuery.access( this, function( value ) {\n				return value === undefined ?\n					jQuery.text( this ) :\n					this.empty().append( ( this[0] && this[0].ownerDocument || document ).createTextNode( value ) );\n			}, null, value, arguments.length );\n		},\n\n		append: function() {\n			return this.domManip( arguments, function( elem ) {\n				if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {\n					var target = manipulationTarget( this, elem );\n					target.appendChild( elem );\n				}\n			});\n		},\n\n		prepend: function() {\n			return this.domManip( arguments, function( elem ) {\n				if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {\n					var target = manipulationTarget( this, elem );\n					target.insertBefore( elem, target.firstChild );\n				}\n			});\n		},\n\n		before: function() {\n			return this.domManip( arguments, function( elem ) {\n				if ( this.parentNode ) {\n					this.parentNode.insertBefore( elem, this );\n				}\n			});\n		},\n\n		after: function() {\n			return this.domManip( arguments, function( elem ) {\n				if ( this.parentNode ) {\n					this.parentNode.insertBefore( elem, this.nextSibling );\n				}\n			});\n		},\n\n		// keepData is for internal use only--do not document\n		remove: function( selector, keepData ) {\n			var elem,\n				elems = selector ? jQuery.filter( selector, this ) : this,\n				i = 0;\n\n			for ( ; (elem = elems[i]) != null; i++ ) {\n\n				if ( !keepData && elem.nodeType === 1 ) {\n					jQuery.cleanData( getAll( elem ) );\n				}\n\n				if ( elem.parentNode ) {\n					if ( keepData && jQuery.contains( elem.ownerDocument, elem ) ) {\n						setGlobalEval( getAll( elem, "script" ) );\n					}\n					elem.parentNode.removeChild( elem );\n				}\n			}\n\n			return this;\n		},\n\n		empty: function() {\n			var elem,\n				i = 0;\n\n			for ( ; (elem = this[i]) != null; i++ ) {\n				// Remove element nodes and prevent memory leaks\n				if ( elem.nodeType === 1 ) {\n					jQuery.cleanData( getAll( elem, false ) );\n				}\n\n				// Remove any remaining nodes\n				while ( elem.firstChild ) {\n					elem.removeChild( elem.firstChild );\n				}\n\n				// If this is a select, ensure that it displays empty (#12336)\n				// Support: IE<9\n				if ( elem.options && jQuery.nodeName( elem, "select" ) ) {\n					elem.options.length = 0;\n				}\n			}\n\n			return this;\n		},\n\n		clone: function( dataAndEvents, deepDataAndEvents ) {\n			dataAndEvents = dataAndEvents == null ? false : dataAndEvents;\n			deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;\n\n			return this.map( function () {\n				return jQuery.clone( this, dataAndEvents, deepDataAndEvents );\n			});\n		},\n\n		html: function( value ) {\n			return jQuery.access( this, function( value ) {\n				var elem = this[0] || {},\n					i = 0,\n					l = this.length;\n\n				if ( value === undefined ) {\n					return elem.nodeType === 1 ?\n						elem.innerHTML.replace( rinlinejQuery, "" ) :\n						undefined;\n				}\n\n				// See if we can take a shortcut and just use innerHTML\n				if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&\n					( jQuery.support.htmlSerialize || !rnoshimcache.test( value )  ) &&\n					( jQuery.support.leadingWhitespace || !rleadingWhitespace.test( value ) ) &&\n					!wrapMap[ ( rtagName.exec( value ) || ["", ""] )[1].toLowerCase() ] ) {\n\n					value = value.replace( rxhtmlTag, "<$1></$2>" );\n\n					try {\n						for (; i < l; i++ ) {\n							// Remove element nodes and prevent memory leaks\n							elem = this[i] || {};\n							if ( elem.nodeType === 1 ) {\n								jQuery.cleanData( getAll( elem, false ) );\n								elem.innerHTML = value;\n							}\n						}\n\n						elem = 0;\n\n						// If using innerHTML throws an exception, use the fallback method\n					} catch(e) {}\n				}\n\n				if ( elem ) {\n					this.empty().append( value );\n				}\n			}, null, value, arguments.length );\n		},\n\n		replaceWith: function() {\n			var\n			// Snapshot the DOM in case .domManip sweeps something relevant into its fragment\n				args = jQuery.map( this, function( elem ) {\n					return [ elem.nextSibling, elem.parentNode ];\n				}),\n				i = 0;\n\n			// Make the changes, replacing each context element with the new content\n			this.domManip( arguments, function( elem ) {\n				var next = args[ i++ ],\n					parent = args[ i++ ];\n\n				if ( parent ) {\n					// Don\'t use the snapshot next if it has moved (#13810)\n					if ( next && next.parentNode !== parent ) {\n						next = this.nextSibling;\n					}\n					jQuery( this ).remove();\n					parent.insertBefore( elem, next );\n				}\n				// Allow new content to include elements from the context set\n			}, true );\n\n			// Force removal if there was no new content (e.g., from empty arguments)\n			return i ? this : this.remove();\n		},\n\n		detach: function( selector ) {\n			return this.remove( selector, true );\n		},\n\n		domManip: function( args, callback, allowIntersection ) {\n\n			// Flatten any nested arrays\n			args = core_concat.apply( [], args );\n\n			var first, node, hasScripts,\n				scripts, doc, fragment,\n				i = 0,\n				l = this.length,\n				set = this,\n				iNoClone = l - 1,\n				value = args[0],\n				isFunction = jQuery.isFunction( value );\n\n			// We can\'t cloneNode fragments that contain checked, in WebKit\n			if ( isFunction || !( l <= 1 || typeof value !== "string" || jQuery.support.checkClone || !rchecked.test( value ) ) ) {\n				return this.each(function( index ) {\n					var self = set.eq( index );\n					if ( isFunction ) {\n						args[0] = value.call( this, index, self.html() );\n					}\n					self.domManip( args, callback, allowIntersection );\n				});\n			}\n\n			if ( l ) {\n				fragment = jQuery.buildFragment( args, this[ 0 ].ownerDocument, false, !allowIntersection && this );\n				first = fragment.firstChild;\n\n				if ( fragment.childNodes.length === 1 ) {\n					fragment = first;\n				}\n\n				if ( first ) {\n					scripts = jQuery.map( getAll( fragment, "script" ), disableScript );\n					hasScripts = scripts.length;\n\n					// Use the original fragment for the last item instead of the first because it can end up\n					// being emptied incorrectly in certain situations (#8070).\n					for ( ; i < l; i++ ) {\n						node = fragment;\n\n						if ( i !== iNoClone ) {\n							node = jQuery.clone( node, true, true );\n\n							// Keep references to cloned scripts for later restoration\n							if ( hasScripts ) {\n								jQuery.merge( scripts, getAll( node, "script" ) );\n							}\n						}\n\n						callback.call( this[i], node, i );\n					}\n\n					if ( hasScripts ) {\n						doc = scripts[ scripts.length - 1 ].ownerDocument;\n\n						// Reenable scripts\n						jQuery.map( scripts, restoreScript );\n\n						// Evaluate executable scripts on first document insertion\n						for ( i = 0; i < hasScripts; i++ ) {\n							node = scripts[ i ];\n							if ( rscriptType.test( node.type || "" ) &&\n								!jQuery._data( node, "globalEval" ) && jQuery.contains( doc, node ) ) {\n\n								if ( node.src ) {\n									// Hope ajax is available...\n									jQuery._evalUrl( node.src );\n								} else {\n									jQuery.globalEval( ( node.text || node.textContent || node.innerHTML || "" ).replace( rcleanScript, "" ) );\n								}\n							}\n						}\n					}\n\n					// Fix #11809: Avoid leaking memory\n					fragment = first = null;\n				}\n			}\n\n			return this;\n		}\n	});\n\n// Support: IE<8\n// Manipulating tables requires a tbody\n	function manipulationTarget( elem, content ) {\n		return jQuery.nodeName( elem, "table" ) &&\n			jQuery.nodeName( content.nodeType === 1 ? content : content.firstChild, "tr" ) ?\n\n			elem.getElementsByTagName("tbody")[0] ||\n				elem.appendChild( elem.ownerDocument.createElement("tbody") ) :\n			elem;\n	}\n\n// Replace/restore the type attribute of script elements for safe DOM manipulation\n	function disableScript( elem ) {\n		elem.type = (jQuery.find.attr( elem, "type" ) !== null) + "/" + elem.type;\n		return elem;\n	}\n	function restoreScript( elem ) {\n		var match = rscriptTypeMasked.exec( elem.type );\n		if ( match ) {\n			elem.type = match[1];\n		} else {\n			elem.removeAttribute("type");\n		}\n		return elem;\n	}\n\n// Mark scripts as having already been evaluated\n	function setGlobalEval( elems, refElements ) {\n		var elem,\n			i = 0;\n		for ( ; (elem = elems[i]) != null; i++ ) {\n			jQuery._data( elem, "globalEval", !refElements || jQuery._data( refElements[i], "globalEval" ) );\n		}\n	}\n\n	function cloneCopyEvent( src, dest ) {\n\n		if ( dest.nodeType !== 1 || !jQuery.hasData( src ) ) {\n			return;\n		}\n\n		var type, i, l,\n			oldData = jQuery._data( src ),\n			curData = jQuery._data( dest, oldData ),\n			events = oldData.events;\n\n		if ( events ) {\n			delete curData.handle;\n			curData.events = {};\n\n			for ( type in events ) {\n				for ( i = 0, l = events[ type ].length; i < l; i++ ) {\n					jQuery.event.add( dest, type, events[ type ][ i ] );\n				}\n			}\n		}\n\n		// make the cloned public data object a copy from the original\n		if ( curData.data ) {\n			curData.data = jQuery.extend( {}, curData.data );\n		}\n	}\n\n	function fixCloneNodeIssues( src, dest ) {\n		var nodeName, e, data;\n\n		// We do not need to do anything for non-Elements\n		if ( dest.nodeType !== 1 ) {\n			return;\n		}\n\n		nodeName = dest.nodeName.toLowerCase();\n\n		// IE6-8 copies events bound via attachEvent when using cloneNode.\n		if ( !jQuery.support.noCloneEvent && dest[ jQuery.expando ] ) {\n			data = jQuery._data( dest );\n\n			for ( e in data.events ) {\n				jQuery.removeEvent( dest, e, data.handle );\n			}\n\n			// Event data gets referenced instead of copied if the expando gets copied too\n			dest.removeAttribute( jQuery.expando );\n		}\n\n		// IE blanks contents when cloning scripts, and tries to evaluate newly-set text\n		if ( nodeName === "script" && dest.text !== src.text ) {\n			disableScript( dest ).text = src.text;\n			restoreScript( dest );\n\n			// IE6-10 improperly clones children of object elements using classid.\n			// IE10 throws NoModificationAllowedError if parent is null, #12132.\n		} else if ( nodeName === "object" ) {\n			if ( dest.parentNode ) {\n				dest.outerHTML = src.outerHTML;\n			}\n\n			// This path appears unavoidable for IE9. When cloning an object\n			// element in IE9, the outerHTML strategy above is not sufficient.\n			// If the src has innerHTML and the destination does not,\n			// copy the src.innerHTML into the dest.innerHTML. #10324\n			if ( jQuery.support.html5Clone && ( src.innerHTML && !jQuery.trim(dest.innerHTML) ) ) {\n				dest.innerHTML = src.innerHTML;\n			}\n\n		} else if ( nodeName === "input" && manipulation_rcheckableType.test( src.type ) ) {\n			// IE6-8 fails to persist the checked state of a cloned checkbox\n			// or radio button. Worse, IE6-7 fail to give the cloned element\n			// a checked appearance if the defaultChecked value isn\'t also set\n\n			dest.defaultChecked = dest.checked = src.checked;\n\n			// IE6-7 get confused and end up setting the value of a cloned\n			// checkbox/radio button to an empty string instead of "on"\n			if ( dest.value !== src.value ) {\n				dest.value = src.value;\n			}\n\n			// IE6-8 fails to return the selected option to the default selected\n			// state when cloning options\n		} else if ( nodeName === "option" ) {\n			dest.defaultSelected = dest.selected = src.defaultSelected;\n\n			// IE6-8 fails to set the defaultValue to the correct value when\n			// cloning other types of input fields\n		} else if ( nodeName === "input" || nodeName === "textarea" ) {\n			dest.defaultValue = src.defaultValue;\n		}\n	}\n\n	jQuery.each({\n		appendTo: "append",\n		prependTo: "prepend",\n		insertBefore: "before",\n		insertAfter: "after",\n		replaceAll: "replaceWith"\n	}, function( name, original ) {\n		jQuery.fn[ name ] = function( selector ) {\n			var elems,\n				i = 0,\n				ret = [],\n				insert = jQuery( selector ),\n				last = insert.length - 1;\n\n			for ( ; i <= last; i++ ) {\n				elems = i === last ? this : this.clone(true);\n				jQuery( insert[i] )[ original ]( elems );\n\n				// Modern browsers can apply jQuery collections as arrays, but oldIE needs a .get()\n				core_push.apply( ret, elems.get() );\n			}\n\n			return this.pushStack( ret );\n		};\n	});\n\n	function getAll( context, tag ) {\n		var elems, elem,\n			i = 0,\n			found = typeof context.getElementsByTagName !== core_strundefined ? context.getElementsByTagName( tag || "*" ) :\n				typeof context.querySelectorAll !== core_strundefined ? context.querySelectorAll( tag || "*" ) :\n					undefined;\n\n		if ( !found ) {\n			for ( found = [], elems = context.childNodes || context; (elem = elems[i]) != null; i++ ) {\n				if ( !tag || jQuery.nodeName( elem, tag ) ) {\n					found.push( elem );\n				} else {\n					jQuery.merge( found, getAll( elem, tag ) );\n				}\n			}\n		}\n\n		return tag === undefined || tag && jQuery.nodeName( context, tag ) ?\n			jQuery.merge( [ context ], found ) :\n			found;\n	}\n\n// Used in buildFragment, fixes the defaultChecked property\n	function fixDefaultChecked( elem ) {\n		if ( manipulation_rcheckableType.test( elem.type ) ) {\n			elem.defaultChecked = elem.checked;\n		}\n	}\n\n	jQuery.extend({\n		clone: function( elem, dataAndEvents, deepDataAndEvents ) {\n			var destElements, node, clone, i, srcElements,\n				inPage = jQuery.contains( elem.ownerDocument, elem );\n\n			if ( jQuery.support.html5Clone || jQuery.isXMLDoc(elem) || !rnoshimcache.test( "<" + elem.nodeName + ">" ) ) {\n				clone = elem.cloneNode( true );\n\n				// IE<=8 does not properly clone detached, unknown element nodes\n			} else {\n				fragmentDiv.innerHTML = elem.outerHTML;\n				fragmentDiv.removeChild( clone = fragmentDiv.firstChild );\n			}\n\n			if ( (!jQuery.support.noCloneEvent || !jQuery.support.noCloneChecked) &&\n				(elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem) ) {\n\n				// We eschew Sizzle here for performance reasons: http://jsperf.com/getall-vs-sizzle/2\n				destElements = getAll( clone );\n				srcElements = getAll( elem );\n\n				// Fix all IE cloning issues\n				for ( i = 0; (node = srcElements[i]) != null; ++i ) {\n					// Ensure that the destination node is not null; Fixes #9587\n					if ( destElements[i] ) {\n						fixCloneNodeIssues( node, destElements[i] );\n					}\n				}\n			}\n\n			// Copy the events from the original to the clone\n			if ( dataAndEvents ) {\n				if ( deepDataAndEvents ) {\n					srcElements = srcElements || getAll( elem );\n					destElements = destElements || getAll( clone );\n\n					for ( i = 0; (node = srcElements[i]) != null; i++ ) {\n						cloneCopyEvent( node, destElements[i] );\n					}\n				} else {\n					cloneCopyEvent( elem, clone );\n				}\n			}\n\n			// Preserve script evaluation history\n			destElements = getAll( clone, "script" );\n			if ( destElements.length > 0 ) {\n				setGlobalEval( destElements, !inPage && getAll( elem, "script" ) );\n			}\n\n			destElements = srcElements = node = null;\n\n			// Return the cloned set\n			return clone;\n		},\n\n		buildFragment: function( elems, context, scripts, selection ) {\n			var j, elem, contains,\n				tmp, tag, tbody, wrap,\n				l = elems.length,\n\n			// Ensure a safe fragment\n				safe = createSafeFragment( context ),\n\n				nodes = [],\n				i = 0;\n\n			for ( ; i < l; i++ ) {\n				elem = elems[ i ];\n\n				if ( elem || elem === 0 ) {\n\n					// Add nodes directly\n					if ( jQuery.type( elem ) === "object" ) {\n						jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );\n\n						// Convert non-html into a text node\n					} else if ( !rhtml.test( elem ) ) {\n						nodes.push( context.createTextNode( elem ) );\n\n						// Convert html into DOM nodes\n					} else {\n						tmp = tmp || safe.appendChild( context.createElement("div") );\n\n						// Deserialize a standard representation\n						tag = ( rtagName.exec( elem ) || ["", ""] )[1].toLowerCase();\n						wrap = wrapMap[ tag ] || wrapMap._default;\n\n						tmp.innerHTML = wrap[1] + elem.replace( rxhtmlTag, "<$1></$2>" ) + wrap[2];\n\n						// Descend through wrappers to the right content\n						j = wrap[0];\n						while ( j-- ) {\n							tmp = tmp.lastChild;\n						}\n\n						// Manually add leading whitespace removed by IE\n						if ( !jQuery.support.leadingWhitespace && rleadingWhitespace.test( elem ) ) {\n							nodes.push( context.createTextNode( rleadingWhitespace.exec( elem )[0] ) );\n						}\n\n						// Remove IE\'s autoinserted <tbody> from table fragments\n						if ( !jQuery.support.tbody ) {\n\n							// String was a <table>, *may* have spurious <tbody>\n							elem = tag === "table" && !rtbody.test( elem ) ?\n								tmp.firstChild :\n\n								// String was a bare <thead> or <tfoot>\n								wrap[1] === "<table>" && !rtbody.test( elem ) ?\n									tmp :\n									0;\n\n							j = elem && elem.childNodes.length;\n							while ( j-- ) {\n								if ( jQuery.nodeName( (tbody = elem.childNodes[j]), "tbody" ) && !tbody.childNodes.length ) {\n									elem.removeChild( tbody );\n								}\n							}\n						}\n\n						jQuery.merge( nodes, tmp.childNodes );\n\n						// Fix #12392 for WebKit and IE > 9\n						tmp.textContent = "";\n\n						// Fix #12392 for oldIE\n						while ( tmp.firstChild ) {\n							tmp.removeChild( tmp.firstChild );\n						}\n\n						// Remember the top-level container for proper cleanup\n						tmp = safe.lastChild;\n					}\n				}\n			}\n\n			// Fix #11356: Clear elements from fragment\n			if ( tmp ) {\n				safe.removeChild( tmp );\n			}\n\n			// Reset defaultChecked for any radios and checkboxes\n			// about to be appended to the DOM in IE 6/7 (#8060)\n			if ( !jQuery.support.appendChecked ) {\n				jQuery.grep( getAll( nodes, "input" ), fixDefaultChecked );\n			}\n\n			i = 0;\n			while ( (elem = nodes[ i++ ]) ) {\n\n				// #4087 - If origin and destination elements are the same, and this is\n				// that element, do not do anything\n				if ( selection && jQuery.inArray( elem, selection ) !== -1 ) {\n					continue;\n				}\n\n				contains = jQuery.contains( elem.ownerDocument, elem );\n\n				// Append to fragment\n				tmp = getAll( safe.appendChild( elem ), "script" );\n\n				// Preserve script evaluation history\n				if ( contains ) {\n					setGlobalEval( tmp );\n				}\n\n				// Capture executables\n				if ( scripts ) {\n					j = 0;\n					while ( (elem = tmp[ j++ ]) ) {\n						if ( rscriptType.test( elem.type || "" ) ) {\n							scripts.push( elem );\n						}\n					}\n				}\n			}\n\n			tmp = null;\n\n			return safe;\n		},\n\n		cleanData: function( elems, /* internal */ acceptData ) {\n			var elem, type, id, data,\n				i = 0,\n				internalKey = jQuery.expando,\n				cache = jQuery.cache,\n				deleteExpando = jQuery.support.deleteExpando,\n				special = jQuery.event.special;\n\n			for ( ; (elem = elems[i]) != null; i++ ) {\n\n				if ( acceptData || jQuery.acceptData( elem ) ) {\n\n					id = elem[ internalKey ];\n					data = id && cache[ id ];\n\n					if ( data ) {\n						if ( data.events ) {\n							for ( type in data.events ) {\n								if ( special[ type ] ) {\n									jQuery.event.remove( elem, type );\n\n									// This is a shortcut to avoid jQuery.event.remove\'s overhead\n								} else {\n									jQuery.removeEvent( elem, type, data.handle );\n								}\n							}\n						}\n\n						// Remove cache only if it was not already removed by jQuery.event.remove\n						if ( cache[ id ] ) {\n\n							delete cache[ id ];\n\n							// IE does not allow us to delete expando properties from nodes,\n							// nor does it have a removeAttribute function on Document nodes;\n							// we must handle all of these cases\n							if ( deleteExpando ) {\n								delete elem[ internalKey ];\n\n							} else if ( typeof elem.removeAttribute !== core_strundefined ) {\n								elem.removeAttribute( internalKey );\n\n							} else {\n								elem[ internalKey ] = null;\n							}\n\n							core_deletedIds.push( id );\n						}\n					}\n				}\n			}\n		},\n\n		_evalUrl: function( url ) {\n			return jQuery.ajax({\n				url: url,\n				type: "GET",\n				dataType: "script",\n				async: false,\n				global: false,\n				"throws": true\n			});\n		}\n	});\n	jQuery.fn.extend({\n		wrapAll: function( html ) {\n			if ( jQuery.isFunction( html ) ) {\n				return this.each(function(i) {\n					jQuery(this).wrapAll( html.call(this, i) );\n				});\n			}\n\n			if ( this[0] ) {\n				// The elements to wrap the target around\n				var wrap = jQuery( html, this[0].ownerDocument ).eq(0).clone(true);\n\n				if ( this[0].parentNode ) {\n					wrap.insertBefore( this[0] );\n				}\n\n				wrap.map(function() {\n					var elem = this;\n\n					while ( elem.firstChild && elem.firstChild.nodeType === 1 ) {\n						elem = elem.firstChild;\n					}\n\n					return elem;\n				}).append( this );\n			}\n\n			return this;\n		},\n\n		wrapInner: function( html ) {\n			if ( jQuery.isFunction( html ) ) {\n				return this.each(function(i) {\n					jQuery(this).wrapInner( html.call(this, i) );\n				});\n			}\n\n			return this.each(function() {\n				var self = jQuery( this ),\n					contents = self.contents();\n\n				if ( contents.length ) {\n					contents.wrapAll( html );\n\n				} else {\n					self.append( html );\n				}\n			});\n		},\n\n		wrap: function( html ) {\n			var isFunction = jQuery.isFunction( html );\n\n			return this.each(function(i) {\n				jQuery( this ).wrapAll( isFunction ? html.call(this, i) : html );\n			});\n		},\n\n		unwrap: function() {\n			return this.parent().each(function() {\n				if ( !jQuery.nodeName( this, "body" ) ) {\n					jQuery( this ).replaceWith( this.childNodes );\n				}\n			}).end();\n		}\n	});\n	var iframe, getStyles, curCSS,\n		ralpha = /alpha\\([^)]*\\)/i,\n		ropacity = /opacity\\s*=\\s*([^)]*)/,\n		rposition = /^(top|right|bottom|left)$/,\n	// swappable if display is none or starts with table except "table", "table-cell", or "table-caption"\n	// see here for display values: https://developer.mozilla.org/en-US/docs/CSS/display\n		rdisplayswap = /^(none|table(?!-c[ea]).+)/,\n		rmargin = /^margin/,\n		rnumsplit = new RegExp( "^(" + core_pnum + ")(.*)$", "i" ),\n		rnumnonpx = new RegExp( "^(" + core_pnum + ")(?!px)[a-z%]+$", "i" ),\n		rrelNum = new RegExp( "^([+-])=(" + core_pnum + ")", "i" ),\n		elemdisplay = { BODY: "block" },\n\n		cssShow = { position: "absolute", visibility: "hidden", display: "block" },\n		cssNormalTransform = {\n			letterSpacing: 0,\n			fontWeight: 400\n		},\n\n		cssExpand = [ "Top", "Right", "Bottom", "Left" ],\n		cssPrefixes = [ "Webkit", "O", "Moz", "ms" ];\n\n// return a css property mapped to a potentially vendor prefixed property\n	function vendorPropName( style, name ) {\n\n		// shortcut for names that are not vendor prefixed\n		if ( name in style ) {\n			return name;\n		}\n\n		// check for vendor prefixed names\n		var capName = name.charAt(0).toUpperCase() + name.slice(1),\n			origName = name,\n			i = cssPrefixes.length;\n\n		while ( i-- ) {\n			name = cssPrefixes[ i ] + capName;\n			if ( name in style ) {\n				return name;\n			}\n		}\n\n		return origName;\n	}\n\n	function isHidden( elem, el ) {\n		// isHidden might be called from jQuery#filter function;\n		// in that case, element will be second argument\n		elem = el || elem;\n		return jQuery.css( elem, "display" ) === "none" || !jQuery.contains( elem.ownerDocument, elem );\n	}\n\n	function showHide( elements, show ) {\n		var display, elem, hidden,\n			values = [],\n			index = 0,\n			length = elements.length;\n\n		for ( ; index < length; index++ ) {\n			elem = elements[ index ];\n			if ( !elem.style ) {\n				continue;\n			}\n\n			values[ index ] = jQuery._data( elem, "olddisplay" );\n			display = elem.style.display;\n			if ( show ) {\n				// Reset the inline display of this element to learn if it is\n				// being hidden by cascaded rules or not\n				if ( !values[ index ] && display === "none" ) {\n					elem.style.display = "";\n				}\n\n				// Set elements which have been overridden with display: none\n				// in a stylesheet to whatever the default browser style is\n				// for such an element\n				if ( elem.style.display === "" && isHidden( elem ) ) {\n					values[ index ] = jQuery._data( elem, "olddisplay", css_defaultDisplay(elem.nodeName) );\n				}\n			} else {\n\n				if ( !values[ index ] ) {\n					hidden = isHidden( elem );\n\n					if ( display && display !== "none" || !hidden ) {\n						jQuery._data( elem, "olddisplay", hidden ? display : jQuery.css( elem, "display" ) );\n					}\n				}\n			}\n		}\n\n		// Set the display of most of the elements in a second loop\n		// to avoid the constant reflow\n		for ( index = 0; index < length; index++ ) {\n			elem = elements[ index ];\n			if ( !elem.style ) {\n				continue;\n			}\n			if ( !show || elem.style.display === "none" || elem.style.display === "" ) {\n				elem.style.display = show ? values[ index ] || "" : "none";\n			}\n		}\n\n		return elements;\n	}\n\n	jQuery.fn.extend({\n		css: function( name, value ) {\n			return jQuery.access( this, function( elem, name, value ) {\n				var len, styles,\n					map = {},\n					i = 0;\n\n				if ( jQuery.isArray( name ) ) {\n					styles = getStyles( elem );\n					len = name.length;\n\n					for ( ; i < len; i++ ) {\n						map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );\n					}\n\n					return map;\n				}\n\n				return value !== undefined ?\n					jQuery.style( elem, name, value ) :\n					jQuery.css( elem, name );\n			}, name, value, arguments.length > 1 );\n		},\n		show: function() {\n			return showHide( this, true );\n		},\n		hide: function() {\n			return showHide( this );\n		},\n		toggle: function( state ) {\n			if ( typeof state === "boolean" ) {\n				return state ? this.show() : this.hide();\n			}\n\n			return this.each(function() {\n				if ( isHidden( this ) ) {\n					jQuery( this ).show();\n				} else {\n					jQuery( this ).hide();\n				}\n			});\n		}\n	});\n\n	jQuery.extend({\n		// Add in style property hooks for overriding the default\n		// behavior of getting and setting a style property\n		cssHooks: {\n			opacity: {\n				get: function( elem, computed ) {\n					if ( computed ) {\n						// We should always get a number back from opacity\n						var ret = curCSS( elem, "opacity" );\n						return ret === "" ? "1" : ret;\n					}\n				}\n			}\n		},\n\n		// Don\'t automatically add "px" to these possibly-unitless properties\n		cssNumber: {\n			"columnCount": true,\n			"fillOpacity": true,\n			"fontWeight": true,\n			"lineHeight": true,\n			"opacity": true,\n			"order": true,\n			"orphans": true,\n			"widows": true,\n			"zIndex": true,\n			"zoom": true\n		},\n\n		// Add in properties whose names you wish to fix before\n		// setting or getting the value\n		cssProps: {\n			// normalize float css property\n			"float": jQuery.support.cssFloat ? "cssFloat" : "styleFloat"\n		},\n\n		// Get and set the style property on a DOM Node\n		style: function( elem, name, value, extra ) {\n			// Don\'t set styles on text and comment nodes\n			if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {\n				return;\n			}\n\n			// Make sure that we\'re working with the right name\n			var ret, type, hooks,\n				origName = jQuery.camelCase( name ),\n				style = elem.style;\n\n			name = jQuery.cssProps[ origName ] || ( jQuery.cssProps[ origName ] = vendorPropName( style, origName ) );\n\n			// gets hook for the prefixed version\n			// followed by the unprefixed version\n			hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];\n\n			// Check if we\'re setting a value\n			if ( value !== undefined ) {\n				type = typeof value;\n\n				// convert relative number strings (+= or -=) to relative numbers. #7345\n				if ( type === "string" && (ret = rrelNum.exec( value )) ) {\n					value = ( ret[1] + 1 ) * ret[2] + parseFloat( jQuery.css( elem, name ) );\n					// Fixes bug #9237\n					type = "number";\n				}\n\n				// Make sure that NaN and null values aren\'t set. See: #7116\n				if ( value == null || type === "number" && isNaN( value ) ) {\n					return;\n				}\n\n				// If a number was passed in, add \'px\' to the (except for certain CSS properties)\n				if ( type === "number" && !jQuery.cssNumber[ origName ] ) {\n					value += "px";\n				}\n\n				// Fixes #8908, it can be done more correctly by specifing setters in cssHooks,\n				// but it would mean to define eight (for every problematic property) identical functions\n				if ( !jQuery.support.clearCloneStyle && value === "" && name.indexOf("background") === 0 ) {\n					style[ name ] = "inherit";\n				}\n\n				// If a hook was provided, use that value, otherwise just set the specified value\n				if ( !hooks || !("set" in hooks) || (value = hooks.set( elem, value, extra )) !== undefined ) {\n\n					// Wrapped to prevent IE from throwing errors when \'invalid\' values are provided\n					// Fixes bug #5509\n					try {\n						style[ name ] = value;\n					} catch(e) {}\n				}\n\n			} else {\n				// If a hook was provided get the non-computed value from there\n				if ( hooks && "get" in hooks && (ret = hooks.get( elem, false, extra )) !== undefined ) {\n					return ret;\n				}\n\n				// Otherwise just get the value from the style object\n				return style[ name ];\n			}\n		},\n\n		css: function( elem, name, extra, styles ) {\n			var num, val, hooks,\n				origName = jQuery.camelCase( name );\n\n			// Make sure that we\'re working with the right name\n			name = jQuery.cssProps[ origName ] || ( jQuery.cssProps[ origName ] = vendorPropName( elem.style, origName ) );\n\n			// gets hook for the prefixed version\n			// followed by the unprefixed version\n			hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];\n\n			// If a hook was provided get the computed value from there\n			if ( hooks && "get" in hooks ) {\n				val = hooks.get( elem, true, extra );\n			}\n\n			// Otherwise, if a way to get the computed value exists, use that\n			if ( val === undefined ) {\n				val = curCSS( elem, name, styles );\n			}\n\n			//convert "normal" to computed value\n			if ( val === "normal" && name in cssNormalTransform ) {\n				val = cssNormalTransform[ name ];\n			}\n\n			// Return, converting to number if forced or a qualifier was provided and val looks numeric\n			if ( extra === "" || extra ) {\n				num = parseFloat( val );\n				return extra === true || jQuery.isNumeric( num ) ? num || 0 : val;\n			}\n			return val;\n		}\n	});\n\n// NOTE: we\'ve included the "window" in window.getComputedStyle\n// because jsdom on node.js will break without it.\n	if ( window.getComputedStyle ) {\n		getStyles = function( elem ) {\n			return window.getComputedStyle( elem, null );\n		};\n\n		curCSS = function( elem, name, _computed ) {\n			var width, minWidth, maxWidth,\n				computed = _computed || getStyles( elem ),\n\n			// getPropertyValue is only needed for .css(\'filter\') in IE9, see #12537\n				ret = computed ? computed.getPropertyValue( name ) || computed[ name ] : undefined,\n				style = elem.style;\n\n			if ( computed ) {\n\n				if ( ret === "" && !jQuery.contains( elem.ownerDocument, elem ) ) {\n					ret = jQuery.style( elem, name );\n				}\n\n				// A tribute to the "awesome hack by Dean Edwards"\n				// Chrome < 17 and Safari 5.0 uses "computed value" instead of "used value" for margin-right\n				// Safari 5.1.7 (at least) returns percentage for a larger set of values, but width seems to be reliably pixels\n				// this is against the CSSOM draft spec: http://dev.w3.org/csswg/cssom/#resolved-values\n				if ( rnumnonpx.test( ret ) && rmargin.test( name ) ) {\n\n					// Remember the original values\n					width = style.width;\n					minWidth = style.minWidth;\n					maxWidth = style.maxWidth;\n\n					// Put in the new values to get a computed value out\n					style.minWidth = style.maxWidth = style.width = ret;\n					ret = computed.width;\n\n					// Revert the changed values\n					style.width = width;\n					style.minWidth = minWidth;\n					style.maxWidth = maxWidth;\n				}\n			}\n\n			return ret;\n		};\n	} else if ( document.documentElement.currentStyle ) {\n		getStyles = function( elem ) {\n			return elem.currentStyle;\n		};\n\n		curCSS = function( elem, name, _computed ) {\n			var left, rs, rsLeft,\n				computed = _computed || getStyles( elem ),\n				ret = computed ? computed[ name ] : undefined,\n				style = elem.style;\n\n			// Avoid setting ret to empty string here\n			// so we don\'t default to auto\n			if ( ret == null && style && style[ name ] ) {\n				ret = style[ name ];\n			}\n\n			// From the awesome hack by Dean Edwards\n			// http://erik.eae.net/archives/2007/07/27/18.54.15/#comment-102291\n\n			// If we\'re not dealing with a regular pixel number\n			// but a number that has a weird ending, we need to convert it to pixels\n			// but not position css attributes, as those are proportional to the parent element instead\n			// and we can\'t measure the parent instead because it might trigger a "stacking dolls" problem\n			if ( rnumnonpx.test( ret ) && !rposition.test( name ) ) {\n\n				// Remember the original values\n				left = style.left;\n				rs = elem.runtimeStyle;\n				rsLeft = rs && rs.left;\n\n				// Put in the new values to get a computed value out\n				if ( rsLeft ) {\n					rs.left = elem.currentStyle.left;\n				}\n				style.left = name === "fontSize" ? "1em" : ret;\n				ret = style.pixelLeft + "px";\n\n				// Revert the changed values\n				style.left = left;\n				if ( rsLeft ) {\n					rs.left = rsLeft;\n				}\n			}\n\n			return ret === "" ? "auto" : ret;\n		};\n	}\n\n	function setPositiveNumber( elem, value, subtract ) {\n		var matches = rnumsplit.exec( value );\n		return matches ?\n			// Guard against undefined "subtract", e.g., when used as in cssHooks\n			Math.max( 0, matches[ 1 ] - ( subtract || 0 ) ) + ( matches[ 2 ] || "px" ) :\n			value;\n	}\n\n	function augmentWidthOrHeight( elem, name, extra, isBorderBox, styles ) {\n		var i = extra === ( isBorderBox ? "border" : "content" ) ?\n				// If we already have the right measurement, avoid augmentation\n				4 :\n				// Otherwise initialize for horizontal or vertical properties\n				name === "width" ? 1 : 0,\n\n			val = 0;\n\n		for ( ; i < 4; i += 2 ) {\n			// both box models exclude margin, so add it if we want it\n			if ( extra === "margin" ) {\n				val += jQuery.css( elem, extra + cssExpand[ i ], true, styles );\n			}\n\n			if ( isBorderBox ) {\n				// border-box includes padding, so remove it if we want content\n				if ( extra === "content" ) {\n					val -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );\n				}\n\n				// at this point, extra isn\'t border nor margin, so remove border\n				if ( extra !== "margin" ) {\n					val -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );\n				}\n			} else {\n				// at this point, extra isn\'t content, so add padding\n				val += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );\n\n				// at this point, extra isn\'t content nor padding, so add border\n				if ( extra !== "padding" ) {\n					val += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );\n				}\n			}\n		}\n\n		return val;\n	}\n\n	function getWidthOrHeight( elem, name, extra ) {\n\n		// Start with offset property, which is equivalent to the border-box value\n		var valueIsBorderBox = true,\n			val = name === "width" ? elem.offsetWidth : elem.offsetHeight,\n			styles = getStyles( elem ),\n			isBorderBox = jQuery.support.boxSizing && jQuery.css( elem, "boxSizing", false, styles ) === "border-box";\n\n		// some non-html elements return undefined for offsetWidth, so check for null/undefined\n		// svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285\n		// MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668\n		if ( val <= 0 || val == null ) {\n			// Fall back to computed then uncomputed css if necessary\n			val = curCSS( elem, name, styles );\n			if ( val < 0 || val == null ) {\n				val = elem.style[ name ];\n			}\n\n			// Computed unit is not pixels. Stop here and return.\n			if ( rnumnonpx.test(val) ) {\n				return val;\n			}\n\n			// we need the check for style in case a browser which returns unreliable values\n			// for getComputedStyle silently falls back to the reliable elem.style\n			valueIsBorderBox = isBorderBox && ( jQuery.support.boxSizingReliable || val === elem.style[ name ] );\n\n			// Normalize "", auto, and prepare for extra\n			val = parseFloat( val ) || 0;\n		}\n\n		// use the active box-sizing model to add/subtract irrelevant styles\n		return ( val +\n			augmentWidthOrHeight(\n				elem,\n				name,\n				extra || ( isBorderBox ? "border" : "content" ),\n				valueIsBorderBox,\n				styles\n			)\n			) + "px";\n	}\n\n// Try to determine the default display value of an element\n	function css_defaultDisplay( nodeName ) {\n		var doc = document,\n			display = elemdisplay[ nodeName ];\n\n		if ( !display ) {\n			display = actualDisplay( nodeName, doc );\n\n			// If the simple way fails, read from inside an iframe\n			if ( display === "none" || !display ) {\n				// Use the already-created iframe if possible\n				iframe = ( iframe ||\n					jQuery("<iframe frameborder=\'0\' width=\'0\' height=\'0\'/>")\n						.css( "cssText", "display:block !important" )\n					).appendTo( doc.documentElement );\n\n				// Always write a new HTML skeleton so Webkit and Firefox don\'t choke on reuse\n				doc = ( iframe[0].contentWindow || iframe[0].contentDocument ).document;\n				doc.write("<!doctype html><html><body>");\n				doc.close();\n\n				display = actualDisplay( nodeName, doc );\n				iframe.detach();\n			}\n\n			// Store the correct default display\n			elemdisplay[ nodeName ] = display;\n		}\n\n		return display;\n	}\n\n// Called ONLY from within css_defaultDisplay\n	function actualDisplay( name, doc ) {\n		var elem = jQuery( doc.createElement( name ) ).appendTo( doc.body ),\n			display = jQuery.css( elem[0], "display" );\n		elem.remove();\n		return display;\n	}\n\n	jQuery.each([ "height", "width" ], function( i, name ) {\n		jQuery.cssHooks[ name ] = {\n			get: function( elem, computed, extra ) {\n				if ( computed ) {\n					// certain elements can have dimension info if we invisibly show them\n					// however, it must have a current display style that would benefit from this\n					return elem.offsetWidth === 0 && rdisplayswap.test( jQuery.css( elem, "display" ) ) ?\n						jQuery.swap( elem, cssShow, function() {\n							return getWidthOrHeight( elem, name, extra );\n						}) :\n						getWidthOrHeight( elem, name, extra );\n				}\n			},\n\n			set: function( elem, value, extra ) {\n				var styles = extra && getStyles( elem );\n				return setPositiveNumber( elem, value, extra ?\n					augmentWidthOrHeight(\n						elem,\n						name,\n						extra,\n						jQuery.support.boxSizing && jQuery.css( elem, "boxSizing", false, styles ) === "border-box",\n						styles\n					) : 0\n				);\n			}\n		};\n	});\n\n	if ( !jQuery.support.opacity ) {\n		jQuery.cssHooks.opacity = {\n			get: function( elem, computed ) {\n				// IE uses filters for opacity\n				return ropacity.test( (computed && elem.currentStyle ? elem.currentStyle.filter : elem.style.filter) || "" ) ?\n					( 0.01 * parseFloat( RegExp.$1 ) ) + "" :\n					computed ? "1" : "";\n			},\n\n			set: function( elem, value ) {\n				var style = elem.style,\n					currentStyle = elem.currentStyle,\n					opacity = jQuery.isNumeric( value ) ? "alpha(opacity=" + value * 100 + ")" : "",\n					filter = currentStyle && currentStyle.filter || style.filter || "";\n\n				// IE has trouble with opacity if it does not have layout\n				// Force it by setting the zoom level\n				style.zoom = 1;\n\n				// if setting opacity to 1, and no other filters exist - attempt to remove filter attribute #6652\n				// if value === "", then remove inline opacity #12685\n				if ( ( value >= 1 || value === "" ) &&\n					jQuery.trim( filter.replace( ralpha, "" ) ) === "" &&\n					style.removeAttribute ) {\n\n					// Setting style.filter to null, "" & " " still leave "filter:" in the cssText\n					// if "filter:" is present at all, clearType is disabled, we want to avoid this\n					// style.removeAttribute is IE Only, but so apparently is this code path...\n					style.removeAttribute( "filter" );\n\n					// if there is no filter style applied in a css rule or unset inline opacity, we are done\n					if ( value === "" || currentStyle && !currentStyle.filter ) {\n						return;\n					}\n				}\n\n				// otherwise, set new filter values\n				style.filter = ralpha.test( filter ) ?\n					filter.replace( ralpha, opacity ) :\n					filter + " " + opacity;\n			}\n		};\n	}\n\n// These hooks cannot be added until DOM ready because the support test\n// for it is not run until after DOM ready\n	jQuery(function() {\n		if ( !jQuery.support.reliableMarginRight ) {\n			jQuery.cssHooks.marginRight = {\n				get: function( elem, computed ) {\n					if ( computed ) {\n						// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right\n						// Work around by temporarily setting element display to inline-block\n						return jQuery.swap( elem, { "display": "inline-block" },\n							curCSS, [ elem, "marginRight" ] );\n					}\n				}\n			};\n		}\n\n		// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084\n		// getComputedStyle returns percent when specified for top/left/bottom/right\n		// rather than make the css module depend on the offset module, we just check for it here\n		if ( !jQuery.support.pixelPosition && jQuery.fn.position ) {\n			jQuery.each( [ "top", "left" ], function( i, prop ) {\n				jQuery.cssHooks[ prop ] = {\n					get: function( elem, computed ) {\n						if ( computed ) {\n							computed = curCSS( elem, prop );\n							// if curCSS returns percentage, fallback to offset\n							return rnumnonpx.test( computed ) ?\n								jQuery( elem ).position()[ prop ] + "px" :\n								computed;\n						}\n					}\n				};\n			});\n		}\n\n	});\n\n	if ( jQuery.expr && jQuery.expr.filters ) {\n		jQuery.expr.filters.hidden = function( elem ) {\n			// Support: Opera <= 12.12\n			// Opera reports offsetWidths and offsetHeights less than zero on some elements\n			return elem.offsetWidth <= 0 && elem.offsetHeight <= 0 ||\n				(!jQuery.support.reliableHiddenOffsets && ((elem.style && elem.style.display) || jQuery.css( elem, "display" )) === "none");\n		};\n\n		jQuery.expr.filters.visible = function( elem ) {\n			return !jQuery.expr.filters.hidden( elem );\n		};\n	}\n\n// These hooks are used by animate to expand properties\n	jQuery.each({\n		margin: "",\n		padding: "",\n		border: "Width"\n	}, function( prefix, suffix ) {\n		jQuery.cssHooks[ prefix + suffix ] = {\n			expand: function( value ) {\n				var i = 0,\n					expanded = {},\n\n				// assumes a single number if not a string\n					parts = typeof value === "string" ? value.split(" ") : [ value ];\n\n				for ( ; i < 4; i++ ) {\n					expanded[ prefix + cssExpand[ i ] + suffix ] =\n						parts[ i ] || parts[ i - 2 ] || parts[ 0 ];\n				}\n\n				return expanded;\n			}\n		};\n\n		if ( !rmargin.test( prefix ) ) {\n			jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;\n		}\n	});\n	var r20 = /%20/g,\n		rbracket = /\\[\\]$/,\n		rCRLF = /\\r?\\n/g,\n		rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,\n		rsubmittable = /^(?:input|select|textarea|keygen)/i;\n\n	jQuery.fn.extend({\n		serialize: function() {\n			return jQuery.param( this.serializeArray() );\n		},\n		serializeArray: function() {\n			return this.map(function(){\n				// Can add propHook for "elements" to filter or add form elements\n				var elements = jQuery.prop( this, "elements" );\n				return elements ? jQuery.makeArray( elements ) : this;\n			})\n				.filter(function(){\n					var type = this.type;\n					// Use .is(":disabled") so that fieldset[disabled] works\n					return this.name && !jQuery( this ).is( ":disabled" ) &&\n						rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&\n						( this.checked || !manipulation_rcheckableType.test( type ) );\n				})\n				.map(function( i, elem ){\n					var val = jQuery( this ).val();\n\n					return val == null ?\n						null :\n						jQuery.isArray( val ) ?\n							jQuery.map( val, function( val ){\n								return { name: elem.name, value: val.replace( rCRLF, "\\r\\n" ) };\n							}) :\n						{ name: elem.name, value: val.replace( rCRLF, "\\r\\n" ) };\n				}).get();\n		}\n	});\n\n//Serialize an array of form elements or a set of\n//key/values into a query string\n	jQuery.param = function( a, traditional ) {\n		var prefix,\n			s = [],\n			add = function( key, value ) {\n				// If value is a function, invoke it and return its value\n				value = jQuery.isFunction( value ) ? value() : ( value == null ? "" : value );\n				s[ s.length ] = encodeURIComponent( key ) + "=" + encodeURIComponent( value );\n			};\n\n		// Set traditional to true for jQuery <= 1.3.2 behavior.\n		if ( traditional === undefined ) {\n			traditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional;\n		}\n\n		// If an array was passed in, assume that it is an array of form elements.\n		if ( jQuery.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {\n			// Serialize the form elements\n			jQuery.each( a, function() {\n				add( this.name, this.value );\n			});\n\n		} else {\n			// If traditional, encode the "old" way (the way 1.3.2 or older\n			// did it), otherwise encode params recursively.\n			for ( prefix in a ) {\n				buildParams( prefix, a[ prefix ], traditional, add );\n			}\n		}\n\n		// Return the resulting serialization\n		return s.join( "&" ).replace( r20, "+" );\n	};\n\n	function buildParams( prefix, obj, traditional, add ) {\n		var name;\n\n		if ( jQuery.isArray( obj ) ) {\n			// Serialize array item.\n			jQuery.each( obj, function( i, v ) {\n				if ( traditional || rbracket.test( prefix ) ) {\n					// Treat each array item as a scalar.\n					add( prefix, v );\n\n				} else {\n					// Item is non-scalar (array or object), encode its numeric index.\n					buildParams( prefix + "[" + ( typeof v === "object" ? i : "" ) + "]", v, traditional, add );\n				}\n			});\n\n		} else if ( !traditional && jQuery.type( obj ) === "object" ) {\n			// Serialize object item.\n			for ( name in obj ) {\n				buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );\n			}\n\n		} else {\n			// Serialize scalar item.\n			add( prefix, obj );\n		}\n	}\n	jQuery.each( ("blur focus focusin focusout load resize scroll unload click dblclick " +\n		"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +\n		"change select submit keydown keypress keyup error contextmenu").split(" "), function( i, name ) {\n\n		// Handle event binding\n		jQuery.fn[ name ] = function( data, fn ) {\n			return arguments.length > 0 ?\n				this.on( name, null, data, fn ) :\n				this.trigger( name );\n		};\n	});\n\n	jQuery.fn.extend({\n		hover: function( fnOver, fnOut ) {\n			return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );\n		},\n\n		bind: function( types, data, fn ) {\n			return this.on( types, null, data, fn );\n		},\n		unbind: function( types, fn ) {\n			return this.off( types, null, fn );\n		},\n\n		delegate: function( selector, types, data, fn ) {\n			return this.on( types, selector, data, fn );\n		},\n		undelegate: function( selector, types, fn ) {\n			// ( namespace ) or ( selector, types [, fn] )\n			return arguments.length === 1 ? this.off( selector, "**" ) : this.off( types, selector || "**", fn );\n		}\n	});\n	var\n	// Document location\n		ajaxLocParts,\n		ajaxLocation,\n		ajax_nonce = jQuery.now(),\n\n		ajax_rquery = /\\?/,\n		rhash = /#.*$/,\n		rts = /([?&])_=[^&]*/,\n		rheaders = /^(.*?):[ \\t]*([^\\r\\n]*)\\r?$/mg, // IE leaves an \\r character at EOL\n	// #7653, #8125, #8152: local protocol detection\n		rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,\n		rnoContent = /^(?:GET|HEAD)$/,\n		rprotocol = /^\\/\\//,\n		rurl = /^([\\w.+-]+:)(?:\\/\\/([^\\/?#:]*)(?::(\\d+)|)|)/,\n\n	// Keep a copy of the old load method\n		_load = jQuery.fn.load,\n\n	/* Prefilters\n	 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)\n	 * 2) These are called:\n	 *    - BEFORE asking for a transport\n	 *    - AFTER param serialization (s.data is a string if s.processData is true)\n	 * 3) key is the dataType\n	 * 4) the catchall symbol "*" can be used\n	 * 5) execution will start with transport dataType and THEN continue down to "*" if needed\n	 */\n		prefilters = {},\n\n	/* Transports bindings\n	 * 1) key is the dataType\n	 * 2) the catchall symbol "*" can be used\n	 * 3) selection will start with transport dataType and THEN go to "*" if needed\n	 */\n		transports = {},\n\n	// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression\n		allTypes = "*/".concat("*");\n\n// #8138, IE may throw an exception when accessing\n// a field from window.location if document.domain has been set\n	try {\n		ajaxLocation = location.href;\n	} catch( e ) {\n		// Use the href attribute of an A element\n		// since IE will modify it given document.location\n		ajaxLocation = document.createElement( "a" );\n		ajaxLocation.href = "";\n		ajaxLocation = ajaxLocation.href;\n	}\n\n// Segment location into parts\n	ajaxLocParts = rurl.exec( ajaxLocation.toLowerCase() ) || [];\n\n// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport\n	function addToPrefiltersOrTransports( structure ) {\n\n		// dataTypeExpression is optional and defaults to "*"\n		return function( dataTypeExpression, func ) {\n\n			if ( typeof dataTypeExpression !== "string" ) {\n				func = dataTypeExpression;\n				dataTypeExpression = "*";\n			}\n\n			var dataType,\n				i = 0,\n				dataTypes = dataTypeExpression.toLowerCase().match( core_rnotwhite ) || [];\n\n			if ( jQuery.isFunction( func ) ) {\n				// For each dataType in the dataTypeExpression\n				while ( (dataType = dataTypes[i++]) ) {\n					// Prepend if requested\n					if ( dataType[0] === "+" ) {\n						dataType = dataType.slice( 1 ) || "*";\n						(structure[ dataType ] = structure[ dataType ] || []).unshift( func );\n\n						// Otherwise append\n					} else {\n						(structure[ dataType ] = structure[ dataType ] || []).push( func );\n					}\n				}\n			}\n		};\n	}\n\n// Base inspection function for prefilters and transports\n	function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {\n\n		var inspected = {},\n			seekingTransport = ( structure === transports );\n\n		function inspect( dataType ) {\n			var selected;\n			inspected[ dataType ] = true;\n			jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {\n				var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );\n				if( typeof dataTypeOrTransport === "string" && !seekingTransport && !inspected[ dataTypeOrTransport ] ) {\n					options.dataTypes.unshift( dataTypeOrTransport );\n					inspect( dataTypeOrTransport );\n					return false;\n				} else if ( seekingTransport ) {\n					return !( selected = dataTypeOrTransport );\n				}\n			});\n			return selected;\n		}\n\n		return inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );\n	}\n\n// A special extend for ajax options\n// that takes "flat" options (not to be deep extended)\n// Fixes #9887\n	function ajaxExtend( target, src ) {\n		var deep, key,\n			flatOptions = jQuery.ajaxSettings.flatOptions || {};\n\n		for ( key in src ) {\n			if ( src[ key ] !== undefined ) {\n				( flatOptions[ key ] ? target : ( deep || (deep = {}) ) )[ key ] = src[ key ];\n			}\n		}\n		if ( deep ) {\n			jQuery.extend( true, target, deep );\n		}\n\n		return target;\n	}\n\n	jQuery.fn.load = function( url, params, callback ) {\n		if ( typeof url !== "string" && _load ) {\n			return _load.apply( this, arguments );\n		}\n\n		var selector, response, type,\n			self = this,\n			off = url.indexOf(" ");\n\n		if ( off >= 0 ) {\n			selector = url.slice( off, url.length );\n			url = url.slice( 0, off );\n		}\n\n		// If it\'s a function\n		if ( jQuery.isFunction( params ) ) {\n\n			// We assume that it\'s the callback\n			callback = params;\n			params = undefined;\n\n			// Otherwise, build a param string\n		} else if ( params && typeof params === "object" ) {\n			type = "POST";\n		}\n\n		// If we have elements to modify, make the request\n		if ( self.length > 0 ) {\n			jQuery.ajax({\n				url: url,\n\n				// if "type" variable is undefined, then "GET" method will be used\n				type: type,\n				dataType: "html",\n				data: params\n			}).done(function( responseText ) {\n\n					// Save response for use in complete callback\n					response = arguments;\n\n					self.html( selector ?\n\n						// If a selector was specified, locate the right elements in a dummy div\n						// Exclude scripts to avoid IE \'Permission Denied\' errors\n						jQuery("<div>").append( jQuery.parseHTML( responseText ) ).find( selector ) :\n\n						// Otherwise use the full result\n						responseText );\n\n				}).complete( callback && function( jqXHR, status ) {\n					self.each( callback, response || [ jqXHR.responseText, status, jqXHR ] );\n				});\n		}\n\n		return this;\n	};\n\n// Attach a bunch of functions for handling common AJAX events\n	jQuery.each( [ "ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend" ], function( i, type ){\n		jQuery.fn[ type ] = function( fn ){\n			return this.on( type, fn );\n		};\n	});\n\n	jQuery.extend({\n\n		// Counter for holding the number of active queries\n		active: 0,\n\n		// Last-Modified header cache for next request\n		lastModified: {},\n		etag: {},\n\n		ajaxSettings: {\n			url: ajaxLocation,\n			type: "GET",\n			isLocal: rlocalProtocol.test( ajaxLocParts[ 1 ] ),\n			global: true,\n			processData: true,\n			async: true,\n			contentType: "application/x-www-form-urlencoded; charset=UTF-8",\n			/*\n			 timeout: 0,\n			 data: null,\n			 dataType: null,\n			 username: null,\n			 password: null,\n			 cache: null,\n			 throws: false,\n			 traditional: false,\n			 headers: {},\n			 */\n\n			accepts: {\n				"*": allTypes,\n				text: "text/plain",\n				html: "text/html",\n				xml: "application/xml, text/xml",\n				json: "application/json, text/javascript"\n			},\n\n			contents: {\n				xml: /xml/,\n				html: /html/,\n				json: /json/\n			},\n\n			responseFields: {\n				xml: "responseXML",\n				text: "responseText",\n				json: "responseJSON"\n			},\n\n			// Data converters\n			// Keys separate source (or catchall "*") and destination types with a single space\n			converters: {\n\n				// Convert anything to text\n				"* text": String,\n\n				// Text to html (true = no transformation)\n				"text html": true,\n\n				// Evaluate text as a json expression\n				"text json": jQuery.parseJSON,\n\n				// Parse text as xml\n				"text xml": jQuery.parseXML\n			},\n\n			// For options that shouldn\'t be deep extended:\n			// you can add your own custom options here if\n			// and when you create one that shouldn\'t be\n			// deep extended (see ajaxExtend)\n			flatOptions: {\n				url: true,\n				context: true\n			}\n		},\n\n		// Creates a full fledged settings object into target\n		// with both ajaxSettings and settings fields.\n		// If target is omitted, writes into ajaxSettings.\n		ajaxSetup: function( target, settings ) {\n			return settings ?\n\n				// Building a settings object\n				ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :\n\n				// Extending ajaxSettings\n				ajaxExtend( jQuery.ajaxSettings, target );\n		},\n\n		ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),\n		ajaxTransport: addToPrefiltersOrTransports( transports ),\n\n		// Main method\n		ajax: function( url, options ) {\n\n			// If url is an object, simulate pre-1.5 signature\n			if ( typeof url === "object" ) {\n				options = url;\n				url = undefined;\n			}\n\n			// Force options to be an object\n			options = options || {};\n\n			var // Cross-domain detection vars\n				parts,\n			// Loop variable\n				i,\n			// URL without anti-cache param\n				cacheURL,\n			// Response headers as string\n				responseHeadersString,\n			// timeout handle\n				timeoutTimer,\n\n			// To know if global events are to be dispatched\n				fireGlobals,\n\n				transport,\n			// Response headers\n				responseHeaders,\n			// Create the final options object\n				s = jQuery.ajaxSetup( {}, options ),\n			// Callbacks context\n				callbackContext = s.context || s,\n			// Context for global events is callbackContext if it is a DOM node or jQuery collection\n				globalEventContext = s.context && ( callbackContext.nodeType || callbackContext.jquery ) ?\n					jQuery( callbackContext ) :\n					jQuery.event,\n			// Deferreds\n				deferred = jQuery.Deferred(),\n				completeDeferred = jQuery.Callbacks("once memory"),\n			// Status-dependent callbacks\n				statusCode = s.statusCode || {},\n			// Headers (they are sent all at once)\n				requestHeaders = {},\n				requestHeadersNames = {},\n			// The jqXHR state\n				state = 0,\n			// Default abort message\n				strAbort = "canceled",\n			// Fake xhr\n				jqXHR = {\n					readyState: 0,\n\n					// Builds headers hashtable if needed\n					getResponseHeader: function( key ) {\n						var match;\n						if ( state === 2 ) {\n							if ( !responseHeaders ) {\n								responseHeaders = {};\n								while ( (match = rheaders.exec( responseHeadersString )) ) {\n									responseHeaders[ match[1].toLowerCase() ] = match[ 2 ];\n								}\n							}\n							match = responseHeaders[ key.toLowerCase() ];\n						}\n						return match == null ? null : match;\n					},\n\n					// Raw string\n					getAllResponseHeaders: function() {\n						return state === 2 ? responseHeadersString : null;\n					},\n\n					// Caches the header\n					setRequestHeader: function( name, value ) {\n						var lname = name.toLowerCase();\n						if ( !state ) {\n							name = requestHeadersNames[ lname ] = requestHeadersNames[ lname ] || name;\n							requestHeaders[ name ] = value;\n						}\n						return this;\n					},\n\n					// Overrides response content-type header\n					overrideMimeType: function( type ) {\n						if ( !state ) {\n							s.mimeType = type;\n						}\n						return this;\n					},\n\n					// Status-dependent callbacks\n					statusCode: function( map ) {\n						var code;\n						if ( map ) {\n							if ( state < 2 ) {\n								for ( code in map ) {\n									// Lazy-add the new callback in a way that preserves old ones\n									statusCode[ code ] = [ statusCode[ code ], map[ code ] ];\n								}\n							} else {\n								// Execute the appropriate callbacks\n								jqXHR.always( map[ jqXHR.status ] );\n							}\n						}\n						return this;\n					},\n\n					// Cancel the request\n					abort: function( statusText ) {\n						var finalText = statusText || strAbort;\n						if ( transport ) {\n							transport.abort( finalText );\n						}\n						done( 0, finalText );\n						return this;\n					}\n				};\n\n			// Attach deferreds\n			deferred.promise( jqXHR ).complete = completeDeferred.add;\n			jqXHR.success = jqXHR.done;\n			jqXHR.error = jqXHR.fail;\n\n			// Remove hash character (#7531: and string promotion)\n			// Add protocol if not provided (#5866: IE7 issue with protocol-less urls)\n			// Handle falsy url in the settings object (#10093: consistency with old signature)\n			// We also use the url parameter if available\n			s.url = ( ( url || s.url || ajaxLocation ) + "" ).replace( rhash, "" ).replace( rprotocol, ajaxLocParts[ 1 ] + "//" );\n\n			// Alias method option to type as per ticket #12004\n			s.type = options.method || options.type || s.method || s.type;\n\n			// Extract dataTypes list\n			s.dataTypes = jQuery.trim( s.dataType || "*" ).toLowerCase().match( core_rnotwhite ) || [""];\n\n			// A cross-domain request is in order when we have a protocol:host:port mismatch\n			if ( s.crossDomain == null ) {\n				parts = rurl.exec( s.url.toLowerCase() );\n				s.crossDomain = !!( parts &&\n					( parts[ 1 ] !== ajaxLocParts[ 1 ] || parts[ 2 ] !== ajaxLocParts[ 2 ] ||\n						( parts[ 3 ] || ( parts[ 1 ] === "http:" ? "80" : "443" ) ) !==\n							( ajaxLocParts[ 3 ] || ( ajaxLocParts[ 1 ] === "http:" ? "80" : "443" ) ) )\n					);\n			}\n\n			// Convert data if not already a string\n			if ( s.data && s.processData && typeof s.data !== "string" ) {\n				s.data = jQuery.param( s.data, s.traditional );\n			}\n\n			// Apply prefilters\n			inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );\n\n			// If request was aborted inside a prefilter, stop there\n			if ( state === 2 ) {\n				return jqXHR;\n			}\n\n			// We can fire global events as of now if asked to\n			fireGlobals = s.global;\n\n			// Watch for a new set of requests\n			if ( fireGlobals && jQuery.active++ === 0 ) {\n				jQuery.event.trigger("ajaxStart");\n			}\n\n			// Uppercase the type\n			s.type = s.type.toUpperCase();\n\n			// Determine if request has content\n			s.hasContent = !rnoContent.test( s.type );\n\n			// Save the URL in case we\'re toying with the If-Modified-Since\n			// and/or If-None-Match header later on\n			cacheURL = s.url;\n\n			// More options handling for requests with no content\n			if ( !s.hasContent ) {\n\n				// If data is available, append data to url\n				if ( s.data ) {\n					cacheURL = ( s.url += ( ajax_rquery.test( cacheURL ) ? "&" : "?" ) + s.data );\n					// #9682: remove data so that it\'s not used in an eventual retry\n					delete s.data;\n				}\n\n				// Add anti-cache in url if needed\n				if ( s.cache === false ) {\n					s.url = rts.test( cacheURL ) ?\n\n						// If there is already a \'_\' parameter, set its value\n						cacheURL.replace( rts, "$1_=" + ajax_nonce++ ) :\n\n						// Otherwise add one to the end\n						cacheURL + ( ajax_rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + ajax_nonce++;\n				}\n			}\n\n			// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\n			if ( s.ifModified ) {\n				if ( jQuery.lastModified[ cacheURL ] ) {\n					jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );\n				}\n				if ( jQuery.etag[ cacheURL ] ) {\n					jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );\n				}\n			}\n\n			// Set the correct header, if data is being sent\n			if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {\n				jqXHR.setRequestHeader( "Content-Type", s.contentType );\n			}\n\n			// Set the Accepts header for the server, depending on the dataType\n			jqXHR.setRequestHeader(\n				"Accept",\n				s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[0] ] ?\n					s.accepts[ s.dataTypes[0] ] + ( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :\n					s.accepts[ "*" ]\n			);\n\n			// Check for headers option\n			for ( i in s.headers ) {\n				jqXHR.setRequestHeader( i, s.headers[ i ] );\n			}\n\n			// Allow custom headers/mimetypes and early abort\n			if ( s.beforeSend && ( s.beforeSend.call( callbackContext, jqXHR, s ) === false || state === 2 ) ) {\n				// Abort if not done already and return\n				return jqXHR.abort();\n			}\n\n			// aborting is no longer a cancellation\n			strAbort = "abort";\n\n			// Install callbacks on deferreds\n			for ( i in { success: 1, error: 1, complete: 1 } ) {\n				jqXHR[ i ]( s[ i ] );\n			}\n\n			// Get transport\n			transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );\n\n			// If no transport, we auto-abort\n			if ( !transport ) {\n				done( -1, "No Transport" );\n			} else {\n				jqXHR.readyState = 1;\n\n				// Send global event\n				if ( fireGlobals ) {\n					globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );\n				}\n				// Timeout\n				if ( s.async && s.timeout > 0 ) {\n					timeoutTimer = setTimeout(function() {\n						jqXHR.abort("timeout");\n					}, s.timeout );\n				}\n\n				try {\n					state = 1;\n					transport.send( requestHeaders, done );\n				} catch ( e ) {\n					// Propagate exception as error if not done\n					if ( state < 2 ) {\n						done( -1, e );\n						// Simply rethrow otherwise\n					} else {\n						throw e;\n					}\n				}\n			}\n\n			// Callback for when everything is done\n			function done( status, nativeStatusText, responses, headers ) {\n				var isSuccess, success, error, response, modified,\n					statusText = nativeStatusText;\n\n				// Called once\n				if ( state === 2 ) {\n					return;\n				}\n\n				// State is "done" now\n				state = 2;\n\n				// Clear timeout if it exists\n				if ( timeoutTimer ) {\n					clearTimeout( timeoutTimer );\n				}\n\n				// Dereference transport for early garbage collection\n				// (no matter how long the jqXHR object will be used)\n				transport = undefined;\n\n				// Cache response headers\n				responseHeadersString = headers || "";\n\n				// Set readyState\n				jqXHR.readyState = status > 0 ? 4 : 0;\n\n				// Determine if successful\n				isSuccess = status >= 200 && status < 300 || status === 304;\n\n				// Get response data\n				if ( responses ) {\n					response = ajaxHandleResponses( s, jqXHR, responses );\n				}\n\n				// Convert no matter what (that way responseXXX fields are always set)\n				response = ajaxConvert( s, response, jqXHR, isSuccess );\n\n				// If successful, handle type chaining\n				if ( isSuccess ) {\n\n					// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\n					if ( s.ifModified ) {\n						modified = jqXHR.getResponseHeader("Last-Modified");\n						if ( modified ) {\n							jQuery.lastModified[ cacheURL ] = modified;\n						}\n						modified = jqXHR.getResponseHeader("etag");\n						if ( modified ) {\n							jQuery.etag[ cacheURL ] = modified;\n						}\n					}\n\n					// if no content\n					if ( status === 204 || s.type === "HEAD" ) {\n						statusText = "nocontent";\n\n						// if not modified\n					} else if ( status === 304 ) {\n						statusText = "notmodified";\n\n						// If we have data, let\'s convert it\n					} else {\n						statusText = response.state;\n						success = response.data;\n						error = response.error;\n						isSuccess = !error;\n					}\n				} else {\n					// We extract error from statusText\n					// then normalize statusText and status for non-aborts\n					error = statusText;\n					if ( status || !statusText ) {\n						statusText = "error";\n						if ( status < 0 ) {\n							status = 0;\n						}\n					}\n				}\n\n				// Set data for the fake xhr object\n				jqXHR.status = status;\n				jqXHR.statusText = ( nativeStatusText || statusText ) + "";\n\n				// Success/Error\n				if ( isSuccess ) {\n					deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );\n				} else {\n					deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );\n				}\n\n				// Status-dependent callbacks\n				jqXHR.statusCode( statusCode );\n				statusCode = undefined;\n\n				if ( fireGlobals ) {\n					globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",\n						[ jqXHR, s, isSuccess ? success : error ] );\n				}\n\n				// Complete\n				completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );\n\n				if ( fireGlobals ) {\n					globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );\n					// Handle the global AJAX counter\n					if ( !( --jQuery.active ) ) {\n						jQuery.event.trigger("ajaxStop");\n					}\n				}\n			}\n\n			return jqXHR;\n		},\n\n		getJSON: function( url, data, callback ) {\n			return jQuery.get( url, data, callback, "json" );\n		},\n\n		getScript: function( url, callback ) {\n			return jQuery.get( url, undefined, callback, "script" );\n		}\n	});\n\n	jQuery.each( [ "get", "post" ], function( i, method ) {\n		jQuery[ method ] = function( url, data, callback, type ) {\n			// shift arguments if data argument was omitted\n			if ( jQuery.isFunction( data ) ) {\n				type = type || callback;\n				callback = data;\n				data = undefined;\n			}\n\n			return jQuery.ajax({\n				url: url,\n				type: method,\n				dataType: type,\n				data: data,\n				success: callback\n			});\n		};\n	});\n\n	/* Handles responses to an ajax request:\n	 * - finds the right dataType (mediates between content-type and expected dataType)\n	 * - returns the corresponding response\n	 */\n	function ajaxHandleResponses( s, jqXHR, responses ) {\n		var firstDataType, ct, finalDataType, type,\n			contents = s.contents,\n			dataTypes = s.dataTypes;\n\n		// Remove auto dataType and get content-type in the process\n		while( dataTypes[ 0 ] === "*" ) {\n			dataTypes.shift();\n			if ( ct === undefined ) {\n				ct = s.mimeType || jqXHR.getResponseHeader("Content-Type");\n			}\n		}\n\n		// Check if we\'re dealing with a known content-type\n		if ( ct ) {\n			for ( type in contents ) {\n				if ( contents[ type ] && contents[ type ].test( ct ) ) {\n					dataTypes.unshift( type );\n					break;\n				}\n			}\n		}\n\n		// Check to see if we have a response for the expected dataType\n		if ( dataTypes[ 0 ] in responses ) {\n			finalDataType = dataTypes[ 0 ];\n		} else {\n			// Try convertible dataTypes\n			for ( type in responses ) {\n				if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[0] ] ) {\n					finalDataType = type;\n					break;\n				}\n				if ( !firstDataType ) {\n					firstDataType = type;\n				}\n			}\n			// Or just use first one\n			finalDataType = finalDataType || firstDataType;\n		}\n\n		// If we found a dataType\n		// We add the dataType to the list if needed\n		// and return the corresponding response\n		if ( finalDataType ) {\n			if ( finalDataType !== dataTypes[ 0 ] ) {\n				dataTypes.unshift( finalDataType );\n			}\n			return responses[ finalDataType ];\n		}\n	}\n\n	/* Chain conversions given the request and the original response\n	 * Also sets the responseXXX fields on the jqXHR instance\n	 */\n	function ajaxConvert( s, response, jqXHR, isSuccess ) {\n		var conv2, current, conv, tmp, prev,\n			converters = {},\n		// Work with a copy of dataTypes in case we need to modify it for conversion\n			dataTypes = s.dataTypes.slice();\n\n		// Create converters map with lowercased keys\n		if ( dataTypes[ 1 ] ) {\n			for ( conv in s.converters ) {\n				converters[ conv.toLowerCase() ] = s.converters[ conv ];\n			}\n		}\n\n		current = dataTypes.shift();\n\n		// Convert to each sequential dataType\n		while ( current ) {\n\n			if ( s.responseFields[ current ] ) {\n				jqXHR[ s.responseFields[ current ] ] = response;\n			}\n\n			// Apply the dataFilter if provided\n			if ( !prev && isSuccess && s.dataFilter ) {\n				response = s.dataFilter( response, s.dataType );\n			}\n\n			prev = current;\n			current = dataTypes.shift();\n\n			if ( current ) {\n\n				// There\'s only work to do if current dataType is non-auto\n				if ( current === "*" ) {\n\n					current = prev;\n\n					// Convert response if prev dataType is non-auto and differs from current\n				} else if ( prev !== "*" && prev !== current ) {\n\n					// Seek a direct converter\n					conv = converters[ prev + " " + current ] || converters[ "* " + current ];\n\n					// If none found, seek a pair\n					if ( !conv ) {\n						for ( conv2 in converters ) {\n\n							// If conv2 outputs current\n							tmp = conv2.split( " " );\n							if ( tmp[ 1 ] === current ) {\n\n								// If prev can be converted to accepted input\n								conv = converters[ prev + " " + tmp[ 0 ] ] ||\n									converters[ "* " + tmp[ 0 ] ];\n								if ( conv ) {\n									// Condense equivalence converters\n									if ( conv === true ) {\n										conv = converters[ conv2 ];\n\n										// Otherwise, insert the intermediate dataType\n									} else if ( converters[ conv2 ] !== true ) {\n										current = tmp[ 0 ];\n										dataTypes.unshift( tmp[ 1 ] );\n									}\n									break;\n								}\n							}\n						}\n					}\n\n					// Apply converter (if not an equivalence)\n					if ( conv !== true ) {\n\n						// Unless errors are allowed to bubble, catch and return them\n						if ( conv && s[ "throws" ] ) {\n							response = conv( response );\n						} else {\n							try {\n								response = conv( response );\n							} catch ( e ) {\n								return { state: "parsererror", error: conv ? e : "No conversion from " + prev + " to " + current };\n							}\n						}\n					}\n				}\n			}\n		}\n\n		return { state: "success", data: response };\n	}\n// Install script dataType\n	jQuery.ajaxSetup({\n		accepts: {\n			script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"\n		},\n		contents: {\n			script: /(?:java|ecma)script/\n		},\n		converters: {\n			"text script": function( text ) {\n				jQuery.globalEval( text );\n				return text;\n			}\n		}\n	});\n\n// Handle cache\'s special case and global\n	jQuery.ajaxPrefilter( "script", function( s ) {\n		if ( s.cache === undefined ) {\n			s.cache = false;\n		}\n		if ( s.crossDomain ) {\n			s.type = "GET";\n			s.global = false;\n		}\n	});\n\n// Bind script tag hack transport\n	jQuery.ajaxTransport( "script", function(s) {\n\n		// This transport only deals with cross domain requests\n		if ( s.crossDomain ) {\n\n			var script,\n				head = document.head || jQuery("head")[0] || document.documentElement;\n\n			return {\n\n				send: function( _, callback ) {\n\n					script = document.createElement("script");\n\n					script.async = true;\n\n					if ( s.scriptCharset ) {\n						script.charset = s.scriptCharset;\n					}\n\n					script.src = s.url;\n\n					// Attach handlers for all browsers\n					script.onload = script.onreadystatechange = function( _, isAbort ) {\n\n						if ( isAbort || !script.readyState || /loaded|complete/.test( script.readyState ) ) {\n\n							// Handle memory leak in IE\n							script.onload = script.onreadystatechange = null;\n\n							// Remove the script\n							if ( script.parentNode ) {\n								script.parentNode.removeChild( script );\n							}\n\n							// Dereference the script\n							script = null;\n\n							// Callback if not abort\n							if ( !isAbort ) {\n								callback( 200, "success" );\n							}\n						}\n					};\n\n					// Circumvent IE6 bugs with base elements (#2709 and #4378) by prepending\n					// Use native DOM manipulation to avoid our domManip AJAX trickery\n					head.insertBefore( script, head.firstChild );\n				},\n\n				abort: function() {\n					if ( script ) {\n						script.onload( undefined, true );\n					}\n				}\n			};\n		}\n	});\n	var oldCallbacks = [],\n		rjsonp = /(=)\\?(?=&|$)|\\?\\?/;\n\n// Default jsonp settings\n	jQuery.ajaxSetup({\n		jsonp: "callback",\n		jsonpCallback: function() {\n			var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( ajax_nonce++ ) );\n			this[ callback ] = true;\n			return callback;\n		}\n	});\n\n// Detect, normalize options and install callbacks for jsonp requests\n	jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {\n\n		var callbackName, overwritten, responseContainer,\n			jsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?\n				"url" :\n				typeof s.data === "string" && !( s.contentType || "" ).indexOf("application/x-www-form-urlencoded") && rjsonp.test( s.data ) && "data"\n				);\n\n		// Handle iff the expected data type is "jsonp" or we have a parameter to set\n		if ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {\n\n			// Get callback name, remembering preexisting value associated with it\n			callbackName = s.jsonpCallback = jQuery.isFunction( s.jsonpCallback ) ?\n				s.jsonpCallback() :\n				s.jsonpCallback;\n\n			// Insert callback into url or form data\n			if ( jsonProp ) {\n				s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );\n			} else if ( s.jsonp !== false ) {\n				s.url += ( ajax_rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;\n			}\n\n			// Use data converter to retrieve json after script execution\n			s.converters["script json"] = function() {\n				if ( !responseContainer ) {\n					jQuery.error( callbackName + " was not called" );\n				}\n				return responseContainer[ 0 ];\n			};\n\n			// force json dataType\n			s.dataTypes[ 0 ] = "json";\n\n			// Install callback\n			overwritten = window[ callbackName ];\n			window[ callbackName ] = function() {\n				responseContainer = arguments;\n			};\n\n			// Clean-up function (fires after converters)\n			jqXHR.always(function() {\n				// Restore preexisting value\n				window[ callbackName ] = overwritten;\n\n				// Save back as free\n				if ( s[ callbackName ] ) {\n					// make sure that re-using the options doesn\'t screw things around\n					s.jsonpCallback = originalSettings.jsonpCallback;\n\n					// save the callback name for future use\n					oldCallbacks.push( callbackName );\n				}\n\n				// Call if it was a function and we have a response\n				if ( responseContainer && jQuery.isFunction( overwritten ) ) {\n					overwritten( responseContainer[ 0 ] );\n				}\n\n				responseContainer = overwritten = undefined;\n			});\n\n			// Delegate to script\n			return "script";\n		}\n	});\n	var xhrCallbacks, xhrSupported,\n		xhrId = 0,\n	// #5280: Internet Explorer will keep connections alive if we don\'t abort on unload\n		xhrOnUnloadAbort = window.ActiveXObject && function() {\n			// Abort all pending requests\n			var key;\n			for ( key in xhrCallbacks ) {\n				xhrCallbacks[ key ]( undefined, true );\n			}\n		};\n\n// Functions to create xhrs\n	function createStandardXHR() {\n		try {\n			return new window.XMLHttpRequest();\n		} catch( e ) {}\n	}\n\n	function createActiveXHR() {\n		try {\n			return new window.ActiveXObject("Microsoft.XMLHTTP");\n		} catch( e ) {}\n	}\n\n// Create the request object\n// (This is still attached to ajaxSettings for backward compatibility)\n	jQuery.ajaxSettings.xhr = window.ActiveXObject ?\n		/* Microsoft failed to properly\n		 * implement the XMLHttpRequest in IE7 (can\'t request local files),\n		 * so we use the ActiveXObject when it is available\n		 * Additionally XMLHttpRequest can be disabled in IE7/IE8 so\n		 * we need a fallback.\n		 */\n		function() {\n			return !this.isLocal && createStandardXHR() || createActiveXHR();\n		} :\n		// For all other browsers, use the standard XMLHttpRequest object\n		createStandardXHR;\n\n// Determine support properties\n	xhrSupported = jQuery.ajaxSettings.xhr();\n	jQuery.support.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );\n	xhrSupported = jQuery.support.ajax = !!xhrSupported;\n\n// Create transport if the browser can provide an xhr\n	if ( xhrSupported ) {\n\n		jQuery.ajaxTransport(function( s ) {\n			// Cross domain only allowed if supported through XMLHttpRequest\n			if ( !s.crossDomain || jQuery.support.cors ) {\n\n				var callback;\n\n				return {\n					send: function( headers, complete ) {\n\n						// Get a new xhr\n						var handle, i,\n							xhr = s.xhr();\n\n						// Open the socket\n						// Passing null username, generates a login popup on Opera (#2865)\n						if ( s.username ) {\n							xhr.open( s.type, s.url, s.async, s.username, s.password );\n						} else {\n							xhr.open( s.type, s.url, s.async );\n						}\n\n						// Apply custom fields if provided\n						if ( s.xhrFields ) {\n							for ( i in s.xhrFields ) {\n								xhr[ i ] = s.xhrFields[ i ];\n							}\n						}\n\n						// Override mime type if needed\n						if ( s.mimeType && xhr.overrideMimeType ) {\n							xhr.overrideMimeType( s.mimeType );\n						}\n\n						// X-Requested-With header\n						// For cross-domain requests, seeing as conditions for a preflight are\n						// akin to a jigsaw puzzle, we simply never set it to be sure.\n						// (it can always be set on a per-request basis or even using ajaxSetup)\n						// For same-domain requests, won\'t change header if already provided.\n						if ( !s.crossDomain && !headers["X-Requested-With"] ) {\n							headers["X-Requested-With"] = "XMLHttpRequest";\n						}\n\n						// Need an extra try/catch for cross domain requests in Firefox 3\n						try {\n							for ( i in headers ) {\n								xhr.setRequestHeader( i, headers[ i ] );\n							}\n						} catch( err ) {}\n\n						// Do send the request\n						// This may raise an exception which is actually\n						// handled in jQuery.ajax (so no try/catch here)\n						xhr.send( ( s.hasContent && s.data ) || null );\n\n						// Listener\n						callback = function( _, isAbort ) {\n							var status, responseHeaders, statusText, responses;\n\n							// Firefox throws exceptions when accessing properties\n							// of an xhr when a network error occurred\n							// http://helpful.knobs-dials.com/index.php/Component_returned_failure_code:_0x80040111_(NS_ERROR_NOT_AVAILABLE)\n							try {\n\n								// Was never called and is aborted or complete\n								if ( callback && ( isAbort || xhr.readyState === 4 ) ) {\n\n									// Only called once\n									callback = undefined;\n\n									// Do not keep as active anymore\n									if ( handle ) {\n										xhr.onreadystatechange = jQuery.noop;\n										if ( xhrOnUnloadAbort ) {\n											delete xhrCallbacks[ handle ];\n										}\n									}\n\n									// If it\'s an abort\n									if ( isAbort ) {\n										// Abort it manually if needed\n										if ( xhr.readyState !== 4 ) {\n											xhr.abort();\n										}\n									} else {\n										responses = {};\n										status = xhr.status;\n										responseHeaders = xhr.getAllResponseHeaders();\n\n										// When requesting binary data, IE6-9 will throw an exception\n										// on any attempt to access responseText (#11426)\n										if ( typeof xhr.responseText === "string" ) {\n											responses.text = xhr.responseText;\n										}\n\n										// Firefox throws an exception when accessing\n										// statusText for faulty cross-domain requests\n										try {\n											statusText = xhr.statusText;\n										} catch( e ) {\n											// We normalize with Webkit giving an empty statusText\n											statusText = "";\n										}\n\n										// Filter status for non standard behaviors\n\n										// If the request is local and we have data: assume a success\n										// (success with no data won\'t get notified, that\'s the best we\n										// can do given current implementations)\n										if ( !status && s.isLocal && !s.crossDomain ) {\n											status = responses.text ? 200 : 404;\n											// IE - #1450: sometimes returns 1223 when it should be 204\n										} else if ( status === 1223 ) {\n											status = 204;\n										}\n									}\n								}\n							} catch( firefoxAccessException ) {\n								if ( !isAbort ) {\n									complete( -1, firefoxAccessException );\n								}\n							}\n\n							// Call complete if needed\n							if ( responses ) {\n								complete( status, statusText, responses, responseHeaders );\n							}\n						};\n\n						if ( !s.async ) {\n							// if we\'re in sync mode we fire the callback\n							callback();\n						} else if ( xhr.readyState === 4 ) {\n							// (IE6 & IE7) if it\'s in cache and has been\n							// retrieved directly we need to fire the callback\n							setTimeout( callback );\n						} else {\n							handle = ++xhrId;\n							if ( xhrOnUnloadAbort ) {\n								// Create the active xhrs callbacks list if needed\n								// and attach the unload handler\n								if ( !xhrCallbacks ) {\n									xhrCallbacks = {};\n									jQuery( window ).unload( xhrOnUnloadAbort );\n								}\n								// Add to list of active xhrs callbacks\n								xhrCallbacks[ handle ] = callback;\n							}\n							xhr.onreadystatechange = callback;\n						}\n					},\n\n					abort: function() {\n						if ( callback ) {\n							callback( undefined, true );\n						}\n					}\n				};\n			}\n		});\n	}\n	var fxNow, timerId,\n		rfxtypes = /^(?:toggle|show|hide)$/,\n		rfxnum = new RegExp( "^(?:([+-])=|)(" + core_pnum + ")([a-z%]*)$", "i" ),\n		rrun = /queueHooks$/,\n		animationPrefilters = [ defaultPrefilter ],\n		tweeners = {\n			"*": [function( prop, value ) {\n				var tween = this.createTween( prop, value ),\n					target = tween.cur(),\n					parts = rfxnum.exec( value ),\n					unit = parts && parts[ 3 ] || ( jQuery.cssNumber[ prop ] ? "" : "px" ),\n\n				// Starting value computation is required for potential unit mismatches\n					start = ( jQuery.cssNumber[ prop ] || unit !== "px" && +target ) &&\n						rfxnum.exec( jQuery.css( tween.elem, prop ) ),\n					scale = 1,\n					maxIterations = 20;\n\n				if ( start && start[ 3 ] !== unit ) {\n					// Trust units reported by jQuery.css\n					unit = unit || start[ 3 ];\n\n					// Make sure we update the tween properties later on\n					parts = parts || [];\n\n					// Iteratively approximate from a nonzero starting point\n					start = +target || 1;\n\n					do {\n						// If previous iteration zeroed out, double until we get *something*\n						// Use a string for doubling factor so we don\'t accidentally see scale as unchanged below\n						scale = scale || ".5";\n\n						// Adjust and apply\n						start = start / scale;\n						jQuery.style( tween.elem, prop, start + unit );\n\n						// Update scale, tolerating zero or NaN from tween.cur()\n						// And breaking the loop if scale is unchanged or perfect, or if we\'ve just had enough\n					} while ( scale !== (scale = tween.cur() / target) && scale !== 1 && --maxIterations );\n				}\n\n				// Update tween properties\n				if ( parts ) {\n					start = tween.start = +start || +target || 0;\n					tween.unit = unit;\n					// If a +=/-= token was provided, we\'re doing a relative animation\n					tween.end = parts[ 1 ] ?\n						start + ( parts[ 1 ] + 1 ) * parts[ 2 ] :\n						+parts[ 2 ];\n				}\n\n				return tween;\n			}]\n		};\n\n// Animations created synchronously will run synchronously\n	function createFxNow() {\n		setTimeout(function() {\n			fxNow = undefined;\n		});\n		return ( fxNow = jQuery.now() );\n	}\n\n	function createTween( value, prop, animation ) {\n		var tween,\n			collection = ( tweeners[ prop ] || [] ).concat( tweeners[ "*" ] ),\n			index = 0,\n			length = collection.length;\n		for ( ; index < length; index++ ) {\n			if ( (tween = collection[ index ].call( animation, prop, value )) ) {\n\n				// we\'re done with this property\n				return tween;\n			}\n		}\n	}\n\n	function Animation( elem, properties, options ) {\n		var result,\n			stopped,\n			index = 0,\n			length = animationPrefilters.length,\n			deferred = jQuery.Deferred().always( function() {\n				// don\'t match elem in the :animated selector\n				delete tick.elem;\n			}),\n			tick = function() {\n				if ( stopped ) {\n					return false;\n				}\n				var currentTime = fxNow || createFxNow(),\n					remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),\n				// archaic crash bug won\'t allow us to use 1 - ( 0.5 || 0 ) (#12497)\n					temp = remaining / animation.duration || 0,\n					percent = 1 - temp,\n					index = 0,\n					length = animation.tweens.length;\n\n				for ( ; index < length ; index++ ) {\n					animation.tweens[ index ].run( percent );\n				}\n\n				deferred.notifyWith( elem, [ animation, percent, remaining ]);\n\n				if ( percent < 1 && length ) {\n					return remaining;\n				} else {\n					deferred.resolveWith( elem, [ animation ] );\n					return false;\n				}\n			},\n			animation = deferred.promise({\n				elem: elem,\n				props: jQuery.extend( {}, properties ),\n				opts: jQuery.extend( true, { specialEasing: {} }, options ),\n				originalProperties: properties,\n				originalOptions: options,\n				startTime: fxNow || createFxNow(),\n				duration: options.duration,\n				tweens: [],\n				createTween: function( prop, end ) {\n					var tween = jQuery.Tween( elem, animation.opts, prop, end,\n						animation.opts.specialEasing[ prop ] || animation.opts.easing );\n					animation.tweens.push( tween );\n					return tween;\n				},\n				stop: function( gotoEnd ) {\n					var index = 0,\n					// if we are going to the end, we want to run all the tweens\n					// otherwise we skip this part\n						length = gotoEnd ? animation.tweens.length : 0;\n					if ( stopped ) {\n						return this;\n					}\n					stopped = true;\n					for ( ; index < length ; index++ ) {\n						animation.tweens[ index ].run( 1 );\n					}\n\n					// resolve when we played the last frame\n					// otherwise, reject\n					if ( gotoEnd ) {\n						deferred.resolveWith( elem, [ animation, gotoEnd ] );\n					} else {\n						deferred.rejectWith( elem, [ animation, gotoEnd ] );\n					}\n					return this;\n				}\n			}),\n			props = animation.props;\n\n		propFilter( props, animation.opts.specialEasing );\n\n		for ( ; index < length ; index++ ) {\n			result = animationPrefilters[ index ].call( animation, elem, props, animation.opts );\n			if ( result ) {\n				return result;\n			}\n		}\n\n		jQuery.map( props, createTween, animation );\n\n		if ( jQuery.isFunction( animation.opts.start ) ) {\n			animation.opts.start.call( elem, animation );\n		}\n\n		jQuery.fx.timer(\n			jQuery.extend( tick, {\n				elem: elem,\n				anim: animation,\n				queue: animation.opts.queue\n			})\n		);\n\n		// attach callbacks from options\n		return animation.progress( animation.opts.progress )\n			.done( animation.opts.done, animation.opts.complete )\n			.fail( animation.opts.fail )\n			.always( animation.opts.always );\n	}\n\n	function propFilter( props, specialEasing ) {\n		var index, name, easing, value, hooks;\n\n		// camelCase, specialEasing and expand cssHook pass\n		for ( index in props ) {\n			name = jQuery.camelCase( index );\n			easing = specialEasing[ name ];\n			value = props[ index ];\n			if ( jQuery.isArray( value ) ) {\n				easing = value[ 1 ];\n				value = props[ index ] = value[ 0 ];\n			}\n\n			if ( index !== name ) {\n				props[ name ] = value;\n				delete props[ index ];\n			}\n\n			hooks = jQuery.cssHooks[ name ];\n			if ( hooks && "expand" in hooks ) {\n				value = hooks.expand( value );\n				delete props[ name ];\n\n				// not quite $.extend, this wont overwrite keys already present.\n				// also - reusing \'index\' from above because we have the correct "name"\n				for ( index in value ) {\n					if ( !( index in props ) ) {\n						props[ index ] = value[ index ];\n						specialEasing[ index ] = easing;\n					}\n				}\n			} else {\n				specialEasing[ name ] = easing;\n			}\n		}\n	}\n\n	jQuery.Animation = jQuery.extend( Animation, {\n\n		tweener: function( props, callback ) {\n			if ( jQuery.isFunction( props ) ) {\n				callback = props;\n				props = [ "*" ];\n			} else {\n				props = props.split(" ");\n			}\n\n			var prop,\n				index = 0,\n				length = props.length;\n\n			for ( ; index < length ; index++ ) {\n				prop = props[ index ];\n				tweeners[ prop ] = tweeners[ prop ] || [];\n				tweeners[ prop ].unshift( callback );\n			}\n		},\n\n		prefilter: function( callback, prepend ) {\n			if ( prepend ) {\n				animationPrefilters.unshift( callback );\n			} else {\n				animationPrefilters.push( callback );\n			}\n		}\n	});\n\n	function defaultPrefilter( elem, props, opts ) {\n		/* jshint validthis: true */\n		var prop, value, toggle, tween, hooks, oldfire,\n			anim = this,\n			orig = {},\n			style = elem.style,\n			hidden = elem.nodeType && isHidden( elem ),\n			dataShow = jQuery._data( elem, "fxshow" );\n\n		// handle queue: false promises\n		if ( !opts.queue ) {\n			hooks = jQuery._queueHooks( elem, "fx" );\n			if ( hooks.unqueued == null ) {\n				hooks.unqueued = 0;\n				oldfire = hooks.empty.fire;\n				hooks.empty.fire = function() {\n					if ( !hooks.unqueued ) {\n						oldfire();\n					}\n				};\n			}\n			hooks.unqueued++;\n\n			anim.always(function() {\n				// doing this makes sure that the complete handler will be called\n				// before this completes\n				anim.always(function() {\n					hooks.unqueued--;\n					if ( !jQuery.queue( elem, "fx" ).length ) {\n						hooks.empty.fire();\n					}\n				});\n			});\n		}\n\n		// height/width overflow pass\n		if ( elem.nodeType === 1 && ( "height" in props || "width" in props ) ) {\n			// Make sure that nothing sneaks out\n			// Record all 3 overflow attributes because IE does not\n			// change the overflow attribute when overflowX and\n			// overflowY are set to the same value\n			opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];\n\n			// Set display property to inline-block for height/width\n			// animations on inline elements that are having width/height animated\n			if ( jQuery.css( elem, "display" ) === "inline" &&\n				jQuery.css( elem, "float" ) === "none" ) {\n\n				// inline-level elements accept inline-block;\n				// block-level elements need to be inline with layout\n				if ( !jQuery.support.inlineBlockNeedsLayout || css_defaultDisplay( elem.nodeName ) === "inline" ) {\n					style.display = "inline-block";\n\n				} else {\n					style.zoom = 1;\n				}\n			}\n		}\n\n		if ( opts.overflow ) {\n			style.overflow = "hidden";\n			if ( !jQuery.support.shrinkWrapBlocks ) {\n				anim.always(function() {\n					style.overflow = opts.overflow[ 0 ];\n					style.overflowX = opts.overflow[ 1 ];\n					style.overflowY = opts.overflow[ 2 ];\n				});\n			}\n		}\n\n\n		// show/hide pass\n		for ( prop in props ) {\n			value = props[ prop ];\n			if ( rfxtypes.exec( value ) ) {\n				delete props[ prop ];\n				toggle = toggle || value === "toggle";\n				if ( value === ( hidden ? "hide" : "show" ) ) {\n					continue;\n				}\n				orig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );\n			}\n		}\n\n		if ( !jQuery.isEmptyObject( orig ) ) {\n			if ( dataShow ) {\n				if ( "hidden" in dataShow ) {\n					hidden = dataShow.hidden;\n				}\n			} else {\n				dataShow = jQuery._data( elem, "fxshow", {} );\n			}\n\n			// store state if its toggle - enables .stop().toggle() to "reverse"\n			if ( toggle ) {\n				dataShow.hidden = !hidden;\n			}\n			if ( hidden ) {\n				jQuery( elem ).show();\n			} else {\n				anim.done(function() {\n					jQuery( elem ).hide();\n				});\n			}\n			anim.done(function() {\n				var prop;\n				jQuery._removeData( elem, "fxshow" );\n				for ( prop in orig ) {\n					jQuery.style( elem, prop, orig[ prop ] );\n				}\n			});\n			for ( prop in orig ) {\n				tween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );\n\n				if ( !( prop in dataShow ) ) {\n					dataShow[ prop ] = tween.start;\n					if ( hidden ) {\n						tween.end = tween.start;\n						tween.start = prop === "width" || prop === "height" ? 1 : 0;\n					}\n				}\n			}\n		}\n	}\n\n	function Tween( elem, options, prop, end, easing ) {\n		return new Tween.prototype.init( elem, options, prop, end, easing );\n	}\n	jQuery.Tween = Tween;\n\n	Tween.prototype = {\n		constructor: Tween,\n		init: function( elem, options, prop, end, easing, unit ) {\n			this.elem = elem;\n			this.prop = prop;\n			this.easing = easing || "swing";\n			this.options = options;\n			this.start = this.now = this.cur();\n			this.end = end;\n			this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );\n		},\n		cur: function() {\n			var hooks = Tween.propHooks[ this.prop ];\n\n			return hooks && hooks.get ?\n				hooks.get( this ) :\n				Tween.propHooks._default.get( this );\n		},\n		run: function( percent ) {\n			var eased,\n				hooks = Tween.propHooks[ this.prop ];\n\n			if ( this.options.duration ) {\n				this.pos = eased = jQuery.easing[ this.easing ](\n					percent, this.options.duration * percent, 0, 1, this.options.duration\n				);\n			} else {\n				this.pos = eased = percent;\n			}\n			this.now = ( this.end - this.start ) * eased + this.start;\n\n			if ( this.options.step ) {\n				this.options.step.call( this.elem, this.now, this );\n			}\n\n			if ( hooks && hooks.set ) {\n				hooks.set( this );\n			} else {\n				Tween.propHooks._default.set( this );\n			}\n			return this;\n		}\n	};\n\n	Tween.prototype.init.prototype = Tween.prototype;\n\n	Tween.propHooks = {\n		_default: {\n			get: function( tween ) {\n				var result;\n\n				if ( tween.elem[ tween.prop ] != null &&\n					(!tween.elem.style || tween.elem.style[ tween.prop ] == null) ) {\n					return tween.elem[ tween.prop ];\n				}\n\n				// passing an empty string as a 3rd parameter to .css will automatically\n				// attempt a parseFloat and fallback to a string if the parse fails\n				// so, simple values such as "10px" are parsed to Float.\n				// complex values such as "rotate(1rad)" are returned as is.\n				result = jQuery.css( tween.elem, tween.prop, "" );\n				// Empty strings, null, undefined and "auto" are converted to 0.\n				return !result || result === "auto" ? 0 : result;\n			},\n			set: function( tween ) {\n				// use step hook for back compat - use cssHook if its there - use .style if its\n				// available and use plain properties where available\n				if ( jQuery.fx.step[ tween.prop ] ) {\n					jQuery.fx.step[ tween.prop ]( tween );\n				} else if ( tween.elem.style && ( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null || jQuery.cssHooks[ tween.prop ] ) ) {\n					jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );\n				} else {\n					tween.elem[ tween.prop ] = tween.now;\n				}\n			}\n		}\n	};\n\n// Support: IE <=9\n// Panic based approach to setting things on disconnected nodes\n\n	Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {\n		set: function( tween ) {\n			if ( tween.elem.nodeType && tween.elem.parentNode ) {\n				tween.elem[ tween.prop ] = tween.now;\n			}\n		}\n	};\n\n	jQuery.each([ "toggle", "show", "hide" ], function( i, name ) {\n		var cssFn = jQuery.fn[ name ];\n		jQuery.fn[ name ] = function( speed, easing, callback ) {\n			return speed == null || typeof speed === "boolean" ?\n				cssFn.apply( this, arguments ) :\n				this.animate( genFx( name, true ), speed, easing, callback );\n		};\n	});\n\n	jQuery.fn.extend({\n		fadeTo: function( speed, to, easing, callback ) {\n\n			// show any hidden elements after setting opacity to 0\n			return this.filter( isHidden ).css( "opacity", 0 ).show()\n\n				// animate to the value specified\n				.end().animate({ opacity: to }, speed, easing, callback );\n		},\n		animate: function( prop, speed, easing, callback ) {\n			var empty = jQuery.isEmptyObject( prop ),\n				optall = jQuery.speed( speed, easing, callback ),\n				doAnimation = function() {\n					// Operate on a copy of prop so per-property easing won\'t be lost\n					var anim = Animation( this, jQuery.extend( {}, prop ), optall );\n\n					// Empty animations, or finishing resolves immediately\n					if ( empty || jQuery._data( this, "finish" ) ) {\n						anim.stop( true );\n					}\n				};\n			doAnimation.finish = doAnimation;\n\n			return empty || optall.queue === false ?\n				this.each( doAnimation ) :\n				this.queue( optall.queue, doAnimation );\n		},\n		stop: function( type, clearQueue, gotoEnd ) {\n			var stopQueue = function( hooks ) {\n				var stop = hooks.stop;\n				delete hooks.stop;\n				stop( gotoEnd );\n			};\n\n			if ( typeof type !== "string" ) {\n				gotoEnd = clearQueue;\n				clearQueue = type;\n				type = undefined;\n			}\n			if ( clearQueue && type !== false ) {\n				this.queue( type || "fx", [] );\n			}\n\n			return this.each(function() {\n				var dequeue = true,\n					index = type != null && type + "queueHooks",\n					timers = jQuery.timers,\n					data = jQuery._data( this );\n\n				if ( index ) {\n					if ( data[ index ] && data[ index ].stop ) {\n						stopQueue( data[ index ] );\n					}\n				} else {\n					for ( index in data ) {\n						if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {\n							stopQueue( data[ index ] );\n						}\n					}\n				}\n\n				for ( index = timers.length; index--; ) {\n					if ( timers[ index ].elem === this && (type == null || timers[ index ].queue === type) ) {\n						timers[ index ].anim.stop( gotoEnd );\n						dequeue = false;\n						timers.splice( index, 1 );\n					}\n				}\n\n				// start the next in the queue if the last step wasn\'t forced\n				// timers currently will call their complete callbacks, which will dequeue\n				// but only if they were gotoEnd\n				if ( dequeue || !gotoEnd ) {\n					jQuery.dequeue( this, type );\n				}\n			});\n		},\n		finish: function( type ) {\n			if ( type !== false ) {\n				type = type || "fx";\n			}\n			return this.each(function() {\n				var index,\n					data = jQuery._data( this ),\n					queue = data[ type + "queue" ],\n					hooks = data[ type + "queueHooks" ],\n					timers = jQuery.timers,\n					length = queue ? queue.length : 0;\n\n				// enable finishing flag on private data\n				data.finish = true;\n\n				// empty the queue first\n				jQuery.queue( this, type, [] );\n\n				if ( hooks && hooks.stop ) {\n					hooks.stop.call( this, true );\n				}\n\n				// look for any active animations, and finish them\n				for ( index = timers.length; index--; ) {\n					if ( timers[ index ].elem === this && timers[ index ].queue === type ) {\n						timers[ index ].anim.stop( true );\n						timers.splice( index, 1 );\n					}\n				}\n\n				// look for any animations in the old queue and finish them\n				for ( index = 0; index < length; index++ ) {\n					if ( queue[ index ] && queue[ index ].finish ) {\n						queue[ index ].finish.call( this );\n					}\n				}\n\n				// turn off finishing flag\n				delete data.finish;\n			});\n		}\n	});\n\n// Generate parameters to create a standard animation\n	function genFx( type, includeWidth ) {\n		var which,\n			attrs = { height: type },\n			i = 0;\n\n		// if we include width, step value is 1 to do all cssExpand values,\n		// if we don\'t include width, step value is 2 to skip over Left and Right\n		includeWidth = includeWidth? 1 : 0;\n		for( ; i < 4 ; i += 2 - includeWidth ) {\n			which = cssExpand[ i ];\n			attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;\n		}\n\n		if ( includeWidth ) {\n			attrs.opacity = attrs.width = type;\n		}\n\n		return attrs;\n	}\n\n// Generate shortcuts for custom animations\n	jQuery.each({\n		slideDown: genFx("show"),\n		slideUp: genFx("hide"),\n		slideToggle: genFx("toggle"),\n		fadeIn: { opacity: "show" },\n		fadeOut: { opacity: "hide" },\n		fadeToggle: { opacity: "toggle" }\n	}, function( name, props ) {\n		jQuery.fn[ name ] = function( speed, easing, callback ) {\n			return this.animate( props, speed, easing, callback );\n		};\n	});\n\n	jQuery.speed = function( speed, easing, fn ) {\n		var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {\n			complete: fn || !fn && easing ||\n				jQuery.isFunction( speed ) && speed,\n			duration: speed,\n			easing: fn && easing || easing && !jQuery.isFunction( easing ) && easing\n		};\n\n		opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === "number" ? opt.duration :\n			opt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[ opt.duration ] : jQuery.fx.speeds._default;\n\n		// normalize opt.queue - true/undefined/null -> "fx"\n		if ( opt.queue == null || opt.queue === true ) {\n			opt.queue = "fx";\n		}\n\n		// Queueing\n		opt.old = opt.complete;\n\n		opt.complete = function() {\n			if ( jQuery.isFunction( opt.old ) ) {\n				opt.old.call( this );\n			}\n\n			if ( opt.queue ) {\n				jQuery.dequeue( this, opt.queue );\n			}\n		};\n\n		return opt;\n	};\n\n	jQuery.easing = {\n		linear: function( p ) {\n			return p;\n		},\n		swing: function( p ) {\n			return 0.5 - Math.cos( p*Math.PI ) / 2;\n		}\n	};\n\n	jQuery.timers = [];\n	jQuery.fx = Tween.prototype.init;\n	jQuery.fx.tick = function() {\n		var timer,\n			timers = jQuery.timers,\n			i = 0;\n\n		fxNow = jQuery.now();\n\n		for ( ; i < timers.length; i++ ) {\n			timer = timers[ i ];\n			// Checks the timer has not already been removed\n			if ( !timer() && timers[ i ] === timer ) {\n				timers.splice( i--, 1 );\n			}\n		}\n\n		if ( !timers.length ) {\n			jQuery.fx.stop();\n		}\n		fxNow = undefined;\n	};\n\n	jQuery.fx.timer = function( timer ) {\n		if ( timer() && jQuery.timers.push( timer ) ) {\n			jQuery.fx.start();\n		}\n	};\n\n	jQuery.fx.interval = 13;\n\n	jQuery.fx.start = function() {\n		if ( !timerId ) {\n			timerId = setInterval( jQuery.fx.tick, jQuery.fx.interval );\n		}\n	};\n\n	jQuery.fx.stop = function() {\n		clearInterval( timerId );\n		timerId = null;\n	};\n\n	jQuery.fx.speeds = {\n		slow: 600,\n		fast: 200,\n		// Default speed\n		_default: 400\n	};\n\n// Back Compat <1.8 extension point\n	jQuery.fx.step = {};\n\n	if ( jQuery.expr && jQuery.expr.filters ) {\n		jQuery.expr.filters.animated = function( elem ) {\n			return jQuery.grep(jQuery.timers, function( fn ) {\n				return elem === fn.elem;\n			}).length;\n		};\n	}\n	jQuery.fn.offset = function( options ) {\n		if ( arguments.length ) {\n			return options === undefined ?\n				this :\n				this.each(function( i ) {\n					jQuery.offset.setOffset( this, options, i );\n				});\n		}\n\n		var docElem, win,\n			box = { top: 0, left: 0 },\n			elem = this[ 0 ],\n			doc = elem && elem.ownerDocument;\n\n		if ( !doc ) {\n			return;\n		}\n\n		docElem = doc.documentElement;\n\n		// Make sure it\'s not a disconnected DOM node\n		if ( !jQuery.contains( docElem, elem ) ) {\n			return box;\n		}\n\n		// If we don\'t have gBCR, just use 0,0 rather than error\n		// BlackBerry 5, iOS 3 (original iPhone)\n		if ( typeof elem.getBoundingClientRect !== core_strundefined ) {\n			box = elem.getBoundingClientRect();\n		}\n		win = getWindow( doc );\n		return {\n			top: box.top  + ( win.pageYOffset || docElem.scrollTop )  - ( docElem.clientTop  || 0 ),\n			left: box.left + ( win.pageXOffset || docElem.scrollLeft ) - ( docElem.clientLeft || 0 )\n		};\n	};\n\n	jQuery.offset = {\n\n		setOffset: function( elem, options, i ) {\n			var position = jQuery.css( elem, "position" );\n\n			// set position first, in-case top/left are set even on static elem\n			if ( position === "static" ) {\n				elem.style.position = "relative";\n			}\n\n			var curElem = jQuery( elem ),\n				curOffset = curElem.offset(),\n				curCSSTop = jQuery.css( elem, "top" ),\n				curCSSLeft = jQuery.css( elem, "left" ),\n				calculatePosition = ( position === "absolute" || position === "fixed" ) && jQuery.inArray("auto", [curCSSTop, curCSSLeft]) > -1,\n				props = {}, curPosition = {}, curTop, curLeft;\n\n			// need to be able to calculate position if either top or left is auto and position is either absolute or fixed\n			if ( calculatePosition ) {\n				curPosition = curElem.position();\n				curTop = curPosition.top;\n				curLeft = curPosition.left;\n			} else {\n				curTop = parseFloat( curCSSTop ) || 0;\n				curLeft = parseFloat( curCSSLeft ) || 0;\n			}\n\n			if ( jQuery.isFunction( options ) ) {\n				options = options.call( elem, i, curOffset );\n			}\n\n			if ( options.top != null ) {\n				props.top = ( options.top - curOffset.top ) + curTop;\n			}\n			if ( options.left != null ) {\n				props.left = ( options.left - curOffset.left ) + curLeft;\n			}\n\n			if ( "using" in options ) {\n				options.using.call( elem, props );\n			} else {\n				curElem.css( props );\n			}\n		}\n	};\n\n\n	jQuery.fn.extend({\n\n		position: function() {\n			if ( !this[ 0 ] ) {\n				return;\n			}\n\n			var offsetParent, offset,\n				parentOffset = { top: 0, left: 0 },\n				elem = this[ 0 ];\n\n			// fixed elements are offset from window (parentOffset = {top:0, left: 0}, because it is it\'s only offset parent\n			if ( jQuery.css( elem, "position" ) === "fixed" ) {\n				// we assume that getBoundingClientRect is available when computed position is fixed\n				offset = elem.getBoundingClientRect();\n			} else {\n				// Get *real* offsetParent\n				offsetParent = this.offsetParent();\n\n				// Get correct offsets\n				offset = this.offset();\n				if ( !jQuery.nodeName( offsetParent[ 0 ], "html" ) ) {\n					parentOffset = offsetParent.offset();\n				}\n\n				// Add offsetParent borders\n				parentOffset.top  += jQuery.css( offsetParent[ 0 ], "borderTopWidth", true );\n				parentOffset.left += jQuery.css( offsetParent[ 0 ], "borderLeftWidth", true );\n			}\n\n			// Subtract parent offsets and element margins\n			// note: when an element has margin: auto the offsetLeft and marginLeft\n			// are the same in Safari causing offset.left to incorrectly be 0\n			return {\n				top:  offset.top  - parentOffset.top - jQuery.css( elem, "marginTop", true ),\n				left: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true)\n			};\n		},\n\n		offsetParent: function() {\n			return this.map(function() {\n				var offsetParent = this.offsetParent || docElem;\n				while ( offsetParent && ( !jQuery.nodeName( offsetParent, "html" ) && jQuery.css( offsetParent, "position") === "static" ) ) {\n					offsetParent = offsetParent.offsetParent;\n				}\n				return offsetParent || docElem;\n			});\n		}\n	});\n\n\n// Create scrollLeft and scrollTop methods\n	jQuery.each( {scrollLeft: "pageXOffset", scrollTop: "pageYOffset"}, function( method, prop ) {\n		var top = /Y/.test( prop );\n\n		jQuery.fn[ method ] = function( val ) {\n			return jQuery.access( this, function( elem, method, val ) {\n				var win = getWindow( elem );\n\n				if ( val === undefined ) {\n					return win ? (prop in win) ? win[ prop ] :\n						win.document.documentElement[ method ] :\n						elem[ method ];\n				}\n\n				if ( win ) {\n					win.scrollTo(\n						!top ? val : jQuery( win ).scrollLeft(),\n						top ? val : jQuery( win ).scrollTop()\n					);\n\n				} else {\n					elem[ method ] = val;\n				}\n			}, method, val, arguments.length, null );\n		};\n	});\n\n	function getWindow( elem ) {\n		return jQuery.isWindow( elem ) ?\n			elem :\n			elem.nodeType === 9 ?\n				elem.defaultView || elem.parentWindow :\n				false;\n	}\n// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods\n	jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {\n		jQuery.each( { padding: "inner" + name, content: type, "": "outer" + name }, function( defaultExtra, funcName ) {\n			// margin is only for outerHeight, outerWidth\n			jQuery.fn[ funcName ] = function( margin, value ) {\n				var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),\n					extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );\n\n				return jQuery.access( this, function( elem, type, value ) {\n					var doc;\n\n					if ( jQuery.isWindow( elem ) ) {\n						// As of 5/8/2012 this will yield incorrect results for Mobile Safari, but there\n						// isn\'t a whole lot we can do. See pull request at this URL for discussion:\n						// https://github.com/jquery/jquery/pull/764\n						return elem.document.documentElement[ "client" + name ];\n					}\n\n					// Get document width or height\n					if ( elem.nodeType === 9 ) {\n						doc = elem.documentElement;\n\n						// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height], whichever is greatest\n						// unfortunately, this causes bug #3838 in IE6/8 only, but there is currently no good, small way to fix it.\n						return Math.max(\n							elem.body[ "scroll" + name ], doc[ "scroll" + name ],\n							elem.body[ "offset" + name ], doc[ "offset" + name ],\n							doc[ "client" + name ]\n						);\n					}\n\n					return value === undefined ?\n						// Get width or height on the element, requesting but not forcing parseFloat\n						jQuery.css( elem, type, extra ) :\n\n						// Set width or height on the element\n						jQuery.style( elem, type, value, extra );\n				}, type, chainable ? margin : undefined, chainable, null );\n			};\n		});\n	});\n// Limit scope pollution from any deprecated API\n// (function() {\n\n// The number of elements contained in the matched element set\n	jQuery.fn.size = function() {\n		return this.length;\n	};\n\n	jQuery.fn.andSelf = jQuery.fn.addBack;\n\n// })();\n	if ( typeof module === "object" && module && typeof module.exports === "object" ) {\n		// Expose jQuery as module.exports in loaders that implement the Node\n		// module pattern (including browserify). Do not create the global, since\n		// the user will be storing it themselves locally, and globals are frowned\n		// upon in the Node module world.\n		module.exports = jQuery;\n	} else {\n		// Otherwise expose jQuery to the global object as usual\n		window.jQuery = window.$ = jQuery;\n\n		// Register as a named AMD module, since jQuery can be concatenated with other\n		// files that may use define, but not via a proper concatenation script that\n		// understands anonymous AMD modules. A named AMD is safest and most robust\n		// way to register. Lowercase jquery is used because AMD module names are\n		// derived from file names, and jQuery is normally delivered in a lowercase\n		// file name. Do this after creating the global so that if an AMD module wants\n		// to call noConflict to hide this version of jQuery, it will work.\n		if ( typeof define === "function" && define.amd ) {\n			define( "jquery", [], function () { return jQuery; } );\n		}\n	}\n\n})( window );\n\n\n/*\nif(Object.defineProperty) {\n	(function(){\n		var html = $.fn.html;\n		Object.defineProperty($.fn,"html",{\n			get: function(){\n				return html;\n			},\n			set: function(){\n				console.log("setting")\n			}\n			\n		})\n	})()\n	\n}*/\n');

/*can/util/can*/
define("can/util/can",[],function(){var e;"undefined"!=typeof window?(e=window.can||{},("undefined"==typeof GLOBALCAN||GLOBALCAN!==!1)&&(window.can=e)):e={},e.k=function(){},e.isDeferred=function(e){var o=this.isFunction;return e&&o(e.then)&&o(e.pipe)};var o=0;return e.cid=function(e,n){return e._cid||(o++,e._cid=(n||"")+o),e._cid},e.VERSION="@EDGE",e.simpleExtend=function(e,o){for(var n in o)e[n]=o[n];return e},e.frag=function(o){var n;return o&&"string"!=typeof o?11===o.nodeType?o:"number"==typeof o.nodeType?(n=document.createDocumentFragment(),n.appendChild(o),n):"number"==typeof o.length?(n=document.createDocumentFragment(),e.each(o,function(o){n.appendChild(e.frag(o))}),n):(n=e.buildFragment(""+o,document.body),n.childNodes.length||n.appendChild(document.createTextNode("")),n):(n=e.buildFragment(null==o?"":""+o,document.body),n.childNodes.length||n.appendChild(document.createTextNode("")),n)},e.__reading=function(){},e.dev={warnTimeout:5e3,logLevel:0,warn:function(e){var o=this.logLevel;2>o&&(Array.prototype.unshift.call(arguments,"WARN:"),window.console&&console.warn?this._logger("warn",Array.prototype.slice.call(arguments)):window.console&&console.log?this._logger("log",Array.prototype.slice.call(arguments)):window.opera&&window.opera.postError&&window.opera.postError("steal.js WARNING: "+e))},log:function(e){var o=this.logLevel;1>o&&(window.console&&console.log?(Array.prototype.unshift.call(arguments,"Info:"),this._logger("log",Array.prototype.slice.call(arguments))):window.opera&&window.opera.postError&&window.opera.postError("steal.js INFO: "+e))},_logger:function(e,o){console.log.apply?console[e].apply(console,o):console[e](o)}},e});
/*can/util/attr/attr*/
define("can/util/attr/attr",["can/util/can"],function(t){var e="undefined"!=typeof window&&window.setImmediate||function(t){return setTimeout(t,0)},n={MutationObserver:"undefined"!=typeof window&&(window.MutationObserver||window.WebKitMutationObserver||window.MozMutationObserver),map:{"class":"className",value:"value",innerText:"innerText",textContent:"textContent",checked:!0,disabled:!0,readonly:!0,required:!0,src:function(t,e){return null==e||""===e?(t.removeAttribute("src"),null):(t.setAttribute("src",e),e)},style:function(t,e){return t.style.cssText=e||""}},defaultValue:["input","textarea"],set:function(e,r,u){var i;n.MutationObserver||(i=n.get(e,r));var a,o=e.nodeName.toString().toLowerCase(),d=n.map[r];"function"==typeof d?a=d(e,u):d===!0?(a=e[r]=!0,"checked"===r&&"radio"===e.type&&t.inArray(o,n.defaultValue)>=0&&(e.defaultChecked=!0)):d?(a=e[d]=u,"value"===d&&t.inArray(o,n.defaultValue)>=0&&(e.defaultValue=u)):(e.setAttribute(r,u),a=u),n.MutationObserver||a===i||n.trigger(e,r,i)},trigger:function(n,r,u){return t.data(t.$(n),"canHasAttributesBindings")?e(function(){t.trigger(n,{type:"attributes",attributeName:r,target:n,oldValue:u,bubbles:!1},[])}):void 0},get:function(t,e){var r=n.map[e];return"string"==typeof r&&t[r]?t[r]:t.getAttribute(e)},remove:function(t,e){var r;n.MutationObserver||(r=n.get(t,e));var u=n.map[e];"function"==typeof u&&u(t,void 0),u===!0?t[e]=!1:"string"==typeof u?t[u]="":t.removeAttribute(e),n.MutationObserver||null==r||n.trigger(t,e,r)},has:function(){if("undefined"!=typeof document){var t=document.createElement("div");return t.hasAttribute?function(t,e){return t.hasAttribute(e)}:function(t,e){return null!==t.getAttribute(e)}}return function(){}}()};return n});
/*can/event/event*/
define("can/event/event",["can/util/can"],function(n){return n.addEvent=function(n,e){var t=this.__bindEvents||(this.__bindEvents={}),i=t[n]||(t[n]=[]);return i.push({handler:e,name:n}),this},n.listenTo=function(e,t,i){var s=this.__listenToEvents;s||(s=this.__listenToEvents={});var r=n.cid(e),v=s[r];v||(v=s[r]={obj:e,events:{}});var a=v.events[t];a||(a=v.events[t]=[]),a.push(i),n.bind.call(e,t,i)},n.stopListening=function(e,t,i){var s=this.__listenToEvents,r=s,v=0;if(!s)return this;if(e){var a=n.cid(e);if((r={})[a]=s[a],!s[a])return this}for(var o in r){var d,l=r[o];e=s[o].obj,t?(d={})[t]=l.events[t]:d=l.events;for(var c in d){var h=d[c]||[];for(v=0;v<h.length;)i&&i===h[v]||!i?(n.unbind.call(e,c,h[v]),h.splice(v,1)):v++;h.length||delete l.events[c]}n.isEmptyObject(l.events)&&delete s[o]}return this},n.removeEvent=function(n,e,t){if(!this.__bindEvents)return this;for(var i,s=this.__bindEvents[n]||[],r=0,v="function"==typeof e;r<s.length;)i=s[r],(t?t(i,n,e):v&&i.handler===e||!v&&(i.cid===e||!e))?s.splice(r,1):r++;return this},n.dispatch=function(n,e){var t=this.__bindEvents;if(t){"string"==typeof n&&(n={type:n});var i=n.type,s=(t[i]||[]).slice(0);e=[n].concat(e||[]);for(var r=0,v=s.length;v>r;r++)s[r].handler.apply(this,e);return n}},n.one=function(e,t){var i=function(){return n.unbind.call(this,e,i),t.apply(this,arguments)};return n.bind.call(this,e,i),this},n.event={on:n.addEvent,off:n.removeEvent,bind:n.addEvent,unbind:n.removeEvent,delegate:function(e,t,i){return n.addEvent.call(t,i)},undelegate:function(e,t,i){return n.removeEvent.call(t,i)},trigger:n.dispatch,one:n.one,addEvent:n.addEvent,removeEvent:n.removeEvent,listenTo:n.listenTo,stopListening:n.stopListening,dispatch:n.dispatch},n.event});
/*can/util/array/each*/
define("can/util/array/each",["can/util/can"],function(t){var e=function(t){var e=t.length;return"function"!=typeof arr&&(0===e||"number"==typeof e&&e>0&&e-1 in t)};return t.each=function(n,a,r){var f,i,l,c=0;if(n)if(e(n))if(t.List&&n instanceof t.List)for(i=n.attr("length");i>c&&(l=n.attr(c),a.call(r||l,l,c,n)!==!1);c++);else for(i=n.length;i>c&&(l=n[c],a.call(r||l,l,c,n)!==!1);c++);else if("object"==typeof n)if(t.Map&&n instanceof t.Map||n===t.route){var o=t.Map.keys(n);for(c=0,i=o.length;i>c&&(f=o[c],l=n.attr(f),a.call(r||l,l,f,n)!==!1);c++);}else for(f in n)if(n.hasOwnProperty(f)&&a.call(r||n[f],n[f],f,n)===!1)break;return n},t});
/*can/util/inserted/inserted*/
define("can/util/inserted/inserted",["can/util/can"],function(e){e.inserted=function(n){n=e.makeArray(n);for(var r,i,t=!1,a=e.$(document.contains?document:document.body),d=0;void 0!==(i=n[d]);d++){if(!t){if(!i.getElementsByTagName)continue;if(!e.has(a,i).length)return;t=!0}if(t&&i.getElementsByTagName){r=e.makeArray(i.getElementsByTagName("*")),e.trigger(i,"inserted",[],!1);for(var o,s=0;void 0!==(o=r[s]);s++)e.trigger(o,"inserted",[],!1)}}},e.appendChild=function(n,r){var i;i=11===r.nodeType?e.makeArray(r.childNodes):[r],n.appendChild(r),e.inserted(i)},e.insertBefore=function(n,r,i){var t;t=11===r.nodeType?e.makeArray(r.childNodes):[r],n.insertBefore(r,i),e.inserted(t)}});
/*can/util/jquery/jquery*/
define("can/util/jquery/jquery",["jquery/jquery","can/util/can","can/util/attr/attr","can/event/event","can/util/array/each","can/util/inserted/inserted"],function(t,e,n){var r=function(t){return t.nodeName&&(1===t.nodeType||9===t.nodeType)||t==window};t.extend(e,t,{trigger:function(n,a,i,u){r(n)?t.event.trigger(a,i,n,!u):n.trigger?n.trigger(a,i):("string"==typeof a&&(a={type:a}),a.target=a.target||n,e.dispatch.call(n,a,i))},event:e.event,addEvent:e.addEvent,removeEvent:e.removeEvent,buildFragment:function(e,n){var r;return e=[e],n=n||document,n=!n.nodeType&&n[0]||n,n=n.ownerDocument||n,r=t.buildFragment(e,n),r.cacheable?t.clone(r.fragment):r.fragment||r},$:t,each:e.each,bind:function(n,a){return this.bind&&this.bind!==e.bind?this.bind(n,a):r(this)?t.event.add(this,n,a):e.addEvent.call(this,n,a),this},unbind:function(n,a){return this.unbind&&this.unbind!==e.unbind?this.unbind(n,a):r(this)?t.event.remove(this,n,a):e.removeEvent.call(this,n,a),this},delegate:function(n,a,i){return this.delegate?this.delegate(n,a,i):r(this)?t(this).delegate(n,a,i):e.bind.call(this,a,i),this},undelegate:function(n,a,i){return this.undelegate?this.undelegate(n,a,i):r(this)?t(this).undelegate(n,a,i):e.unbind.call(this,a,i),this},proxy:function(t,e){return function(){return t.apply(e,arguments)}},attr:n}),e.on=e.bind,e.off=e.unbind,t.each(["append","filter","addClass","remove","data","get","has"],function(t,n){e[n]=function(t){return t[n].apply(t,e.makeArray(arguments).slice(1))}});var a=t.cleanData;t.cleanData=function(n){t.each(n,function(t,n){n&&e.trigger(n,"removed",[],!1)}),a(n)};var i,u=t.fn.domManip;if(t.fn.domManip=function(){for(var t=1;t<arguments.length;t++)if("function"==typeof arguments[t]){i=t;break}return u.apply(this,arguments)},t(document.createElement("div")).append(document.createElement("div")),t.fn.domManip=2===i?function(t,n,r){return u.call(this,t,n,function(t){var n;11===t.nodeType&&(n=e.makeArray(t.childNodes));var a=r.apply(this,arguments);return e.inserted(n?n:[t]),a})}:function(t,n){return u.call(this,t,function(t){var r;11===t.nodeType&&(r=e.makeArray(t.childNodes));var a=n.apply(this,arguments);return e.inserted(r?r:[t]),a})},e.attr.MutationObserver)t.event.special.attributes={setup:function(){var t=this,n=new e.attr.MutationObserver(function(n){n.forEach(function(n){var r=e.simpleExtend({},n);e.trigger(t,r,[])})});n.observe(this,{attributes:!0,attributeOldValue:!0}),e.data(e.$(this),"canAttributesObserver",n)},teardown:function(){e.data(e.$(this),"canAttributesObserver").disconnect(),t.removeData(this,"canAttributesObserver")}};else{var s=t.attr;t.attr=function(t,n){var r,a;arguments.length>=3&&(r=s.call(this,t,n));var i=s.apply(this,arguments);return arguments.length>=3&&(a=s.call(this,t,n)),a!==r&&e.attr.trigger(t,n,r),i};var d=t.removeAttr;t.removeAttr=function(t,n){var r=s.call(this,t,n),a=d.apply(this,arguments);return null!=r&&e.attr.trigger(t,n,r),a},t.event.special.attributes={setup:function(){e.data(e.$(this),"canHasAttributesBindings",!0)},teardown:function(){t.removeData(this,"canHasAttributesBindings")}}}return function(){var t="<-\n>",n=e.buildFragment(t,document);if(t!==n.childNodes[0].nodeValue){var r=e.buildFragment;e.buildFragment=function(t,e){var n=r(t,e);return 1===n.childNodes.length&&3===n.childNodes[0].nodeType&&(n.childNodes[0].nodeValue=t),n}}}(),t.event.special.inserted={},t.event.special.removed={},e});
/*can/view/view*/
define("can/view/view",["can/util/util"],function(e){var r=e.isFunction,n=e.makeArray,t=1,i=function(e){var r=function(){return c.frag(e.apply(this,arguments))};return r.render=function(){return e.apply(e,arguments)},r},a=function(r,n){if(!r.length)throw e.dev.log("can/view/view.js: There is no template or an empty template at "+n),"can.view: No template or empty template:"+n},o=function(r,n){var t,i,o,d="string"==typeof r?r:r.url,u=r.engine&&"."+r.engine||d.match(/\.[\w\d]+$/);if(d.match(/^#/)&&(d=d.substr(1)),(i=document.getElementById(d))&&(u="."+i.type.match(/\/(x\-)?(.+)/)[2]),u||c.cached[d]||(d+=u=c.ext),e.isArray(u)&&(u=u[0]),o=c.toId(d),d.match(/^\/\//)&&(d=d.substr(2),d="undefined"!=typeof window&&window.steal?steal.config().root.mapJoin(""+steal.id(d)):d),window.require&&require.toUrl&&(d=require.toUrl(d)),t=c.types[u],c.cached[o])return c.cached[o];if(i)return c.registerView(o,i.innerHTML,t);var s=new e.Deferred;return e.ajax({async:n,url:d,dataType:"text",error:function(e){a("",d),s.reject(e)},success:function(e){a(e,d),c.registerView(o,e,t,s)}}),s},d=function(r){var n=[];if(e.isDeferred(r))return[r];for(var t in r)e.isDeferred(r[t])&&n.push(r[t]);return n},u=function(r){return e.isArray(r)&&"success"===r[1]?r[0]:r},c=e.view=e.template=function(e,n,t,i){r(t)&&(i=t,t=void 0);var a;return a=r(e)?e(n,t,i):c.renderAs("fragment",e,n,t,i)};return e.extend(c,{frag:function(e,r){return c.hookup(c.fragment(e),r)},fragment:function(r){if("string"!=typeof r&&11===r.nodeType)return r;var n=e.buildFragment(r,document.body);return n.childNodes.length||n.appendChild(document.createTextNode("")),n},toId:function(r){return e.map(r.toString().split(/\/|\./g),function(e){return e?e:void 0}).join("_")},toStr:function(e){return null==e?"":""+e},hookup:function(r,n){var t,i,a=[];return e.each(r.childNodes?e.makeArray(r.childNodes):r,function(r){1===r.nodeType&&(a.push(r),a.push.apply(a,e.makeArray(r.getElementsByTagName("*"))))}),e.each(a,function(e){e.getAttribute&&(t=e.getAttribute("data-view-id"))&&(i=c.hookups[t])&&(i(e,n,t),delete c.hookups[t],e.removeAttribute("data-view-id"))}),r},hookups:{},hook:function(e){return c.hookups[++t]=e," data-view-id='"+t+"'"},cached:{},cachedRenderers:{},cache:!0,register:function(r){this.types["."+r.suffix]=r,"undefined"!=typeof window&&window.steal&&steal.type&&steal.type(r.suffix+" view js",function(e,r){var n=c.types["."+e.type],t=c.toId(e.id+"");e.text=n.script(t,e.text),r()}),e[r.suffix]=c[r.suffix]=function(e,n){return n?r.fragRenderer?c.preload(e,r.fragRenderer(e,n)):c.preloadStringRenderer(e,r.renderer(e,n)):r.fragRenderer?r.fragRenderer(null,e):i(r.renderer(null,e))}},types:{},ext:".ejs",registerScript:function(e,r,n){return"can.view.preloadStringRenderer('"+r+"',"+c.types["."+e].script(r,n)+");"},preload:function(r,n){var t=c.cached[r]=(new e.Deferred).resolve(function(e,r){return n.call(e,e,r)});return t.__view_id=r,c.cachedRenderers[r]=n,n},preloadStringRenderer:function(e,r){return this.preload(e,i(r))},render:function(r,n,t,i){return e.view.renderAs("string",r,n,t,i)},renderTo:function(e,r,n,t){return("string"===e&&r.render?r.render:r)(n,t)},renderAs:function(t,i,a,s,f){r(s)&&(f=s,s=void 0);var p,l,v,w,g,h=d(a);if(h.length)return l=new e.Deferred,v=e.extend({},a),h.push(o(i,!0)),e.when.apply(e,h).then(function(r){var i,o=n(arguments),d=o.pop();if(e.isDeferred(a))v=u(r);else for(var c in a)e.isDeferred(a[c])&&(v[c]=u(o.shift()));i=e.view.renderTo(t,d,v,s),l.resolve(i,v),f&&f(i,v)},function(){l.reject.apply(l,arguments)}),l;if(p=e.__clearReading(),w=r(f),l=o(i,w),p&&e.__setReading(p),w)g=l,l.then(function(r){f(a?e.view.renderTo(t,r,a,s):r)});else{if("resolved"===l.state()&&l.__view_id){var y=c.cachedRenderers[l.__view_id];return a?e.view.renderTo(t,y,a,s):y}l.then(function(r){g=a?e.view.renderTo(t,r,a,s):r})}return g},registerView:function(r,n,t,a){var o,d="object"==typeof t?t:c.types[t||c.ext];return o=d.fragRenderer?d.fragRenderer(r,n):i(d.renderer(r,n)),a=a||new e.Deferred,c.cache&&(c.cached[r]=a,a.__view_id=r,c.cachedRenderers[r]=o),a.resolve(o)}}),"undefined"!=typeof window&&window.steal&&steal.type&&steal.type("view js",function(e,r){var n=c.types["."+e.type],t=c.toId(e.id),i=n.plugin||"can/view/"+e.type,a=n.fragRenderer?"preload":"preloadStringRenderer";e.text="steal('can/view','"+i+"',function(can){return can.view."+a+"('"+t+"',"+e.text+");\n})",r()}),e});
/*can/view/parser/parser*/
define("can/view/parser/parser",["can/view/view"],function(e){function t(e){for(var t={},r=e.split(","),a=0;a<r.length;a++)t[r[a]]=!0;return t}var r="-A-Za-z0-9_",a="[a-zA-Z_:]["+r+":.]+",s="\\s*=\\s*",n='"((?:\\\\.|[^"])*)"',i="'((?:\\\\.|[^'])*)'",l="(?:"+s+"(?:(?:\"[^\"]*\")|(?:'[^']*')|[^>\\s]+))?",o="\\{\\{[^\\}]*\\}\\}\\}?",c="\\{\\{([^\\}]*)\\}\\}\\}?",d=new RegExp("^<(["+r+"]+)((?:\\s*(?:(?:(?:"+a+")?"+l+")|(?:"+o+")+))*)\\s*(\\/?)>"),p=new RegExp("^<\\/(["+r+"]+)[^>]*>"),u=new RegExp("(?:(?:("+a+")|"+c+")(?:"+s+"(?:(?:"+n+")|(?:"+i+")|([^>\\s]+)))?)","g"),f=new RegExp(c,"g"),g=/<|\{\{/,h=t("area,base,basefont,br,col,frame,hr,img,input,isindex,link,meta,param,embed"),m=t("address,article,applet,aside,audio,blockquote,button,canvas,center,dd,del,dir,div,dl,dt,fieldset,figcaption,figure,footer,form,frameset,h1,h2,h3,h4,h5,h6,header,hgroup,hr,iframe,ins,isindex,li,map,menu,noframes,noscript,object,ol,output,p,pre,section,script,table,tbody,td,tfoot,th,thead,tr,ul,video"),b=t("a,abbr,acronym,applet,b,basefont,bdo,big,br,button,cite,code,del,dfn,em,font,i,iframe,img,input,ins,kbd,label,map,object,q,s,samp,script,select,small,span,strike,strong,sub,sup,textarea,tt,u,var"),x=t("colgroup,dd,dt,li,options,p,td,tfoot,th,thead,tr"),v=t("checked,compact,declare,defer,disabled,ismap,multiple,nohref,noresize,noshade,nowrap,readonly,selected"),w=t("script,style"),E=function(e,t){function r(e,r,s,n){if(r=r.toLowerCase(),m[r])for(;o.last()&&b[o.last()];)a("",o.last());x[r]&&o.last()===r&&a("",r),n=h[r]||!!n,t.start(r,n),n||o.push(r),E.parseAttrs(s,t),t.end(r,n)}function a(e,r){var a;if(r)for(a=o.length-1;a>=0&&o[a]!==r;a--);else a=0;if(a>=0){for(var s=o.length-1;s>=a;s--)t.close&&t.close(o[s]);o.length=a}}function s(e,r){t.special&&t.special(r)}var n,i,l,o=[],c=e;for(o.last=function(){return this[this.length-1]};e;){if(i=!0,o.last()&&w[o.last()])e=e.replace(new RegExp("([\\s\\S]*?)</"+o.last()+"[^>]*>"),function(e,r){return r=r.replace(/<!--([\s\S]*?)-->|<!\[CDATA\[([\s\S]*?)]]>/g,"$1$2"),t.chars&&t.chars(r),""}),a("",o.last());else if(0===e.indexOf("<!--")?(n=e.indexOf("-->"),n>=0&&(t.comment&&t.comment(e.substring(4,n)),e=e.substring(n+3),i=!1)):0===e.indexOf("</")?(l=e.match(p),l&&(e=e.substring(l[0].length),l[0].replace(p,a),i=!1)):0===e.indexOf("<")?(l=e.match(d),l&&(e=e.substring(l[0].length),l[0].replace(d,r),i=!1)):0===e.indexOf("{{")&&(l=e.match(f),l&&(e=e.substring(l[0].length),l[0].replace(f,s))),i){n=e.search(g);var u=0>n?e:e.substring(0,n);e=0>n?"":e.substring(n),t.chars&&u&&t.chars(u)}if(e===c)throw"Parse Error: "+e;c=e}a(),t.done()};return E.parseAttrs=function(e,t){(null!=e?e:"").replace(u,function(e,r,a,s,n,i){if(a&&t.special(a),r||s||n||i){var l=arguments[3]?arguments[3]:arguments[4]?arguments[4]:arguments[5]?arguments[5]:v[r.toLowerCase()]?r:"";t.attrStart(r||"");for(var o,c=f.lastIndex=0,d=f.exec(l);d;)o=l.substring(c,f.lastIndex-d[0].length),o.length&&t.attrValue(o),t.special(d[1]),c=f.lastIndex,d=f.exec(l);o=l.substr(c,l.length),o&&t.attrValue(o),t.attrEnd(r||"")}})},e.view.parser=E,E});
/*can/view/elements*/
define("can/view/elements",["can/util/util","can/view/view"],function(t){var e="undefined"!=typeof document?document:null,n=e&&function(){return 1===t.$(document.createComment("~")).length}(),o={tagToContentPropMap:{option:e&&"textContent"in document.createElement("option")?"textContent":"innerText",textarea:"value"},attrMap:t.attr.map,attrReg:/([^\s=]+)[\s]*=[\s]*/,defaultValue:t.attr.defaultValue,tagMap:{"":"span",table:"tbody",tr:"td",ol:"li",ul:"li",tbody:"tr",thead:"tr",tfoot:"tr",select:"option",optgroup:"option"},reverseTagMap:{tr:"tbody",option:"select",td:"tr",th:"tr",li:"ul"},getParentNode:function(t,e){return e&&11===t.parentNode.nodeType?e:t.parentNode},setAttr:t.attr.set,getAttr:t.attr.get,removeAttr:t.attr.remove,contentText:function(t){return"string"==typeof t?t:t||0===t?""+t:""},after:function(e,n){var o=e[e.length-1];o.nextSibling?t.insertBefore(o.parentNode,n,o.nextSibling):t.appendChild(o.parentNode,n)},replace:function(e,r){o.after(e,r),t.remove(t.$(e)).length<e.length&&!n&&t.each(e,function(t){8===t.nodeType&&t.parentNode.removeChild(t)})}};return t.view.elements=o,o});
/*can/view/target/target*/
define("can/view/target/target",["can/util/util","can/view/elements"],function(e,t){function a(e,a,n){var c,o,u,i,d,s=n,h=typeof e,f=function(){return c||(c={path:n,callbacks:[]},a.push(c),s=[]),c};if("object"===h){if(e.tag){if(o=document.createElement(e.tag),e.attrs)for(var m in e.attrs){var p=e.attrs[m];"function"==typeof p?f().callbacks.push({callback:p}):o.setAttribute(m,p)}if(e.attributes)for(i=0,d=e.attributes.length;d>i;i++)f().callbacks.push({callback:e.attributes[i]});e.children&&e.children.length&&(u=c?c.paths=[]:a,o.appendChild(r(e.children,u,s)))}else if(e.comment&&(o=document.createComment(e.comment),e.callbacks))for(i=0,d=e.attributes.length;d>i;i++)f().callbacks.push({callback:e.callbacks[i]})}else"string"===h?o=document.createTextNode(e):"function"===h&&(l?(o=document.createTextNode(""),f().callbacks.push({callback:e})):(o=document.createComment("~"),f().callbacks.push({callback:function(){var a=document.createTextNode("");return t.replace([this],a),e.apply(a,arguments)}})));return o}function n(e,t,a){for(var c,r=t.path,l=t.callbacks,o=t.paths,u=e,i=0,d=r.length;d>i;i++)u=u.childNodes[r[i]];for(i=0,d=l.length;d>i;i++)c=l[i],c.callback.apply(u,a);if(o&&o.length)for(i=0,d=o.length;d>i;i++)n(u,o[i],a)}function c(t){var a=[],c=r(t,a,[]);return{paths:a,clone:c,hydrate:function(){for(var t=this.clone.cloneNode(!0),c=e.makeArray(arguments),r=a.length-1;r>=0;r--)n(t,a[r],c);return t}}}var r=function(e,t,n){for(var c=document.createDocumentFragment(),r=0,l=e.length;l>r;r++){var o=e[r];c.appendChild(a(o,t,n.concat(r)))}return c},l="undefined"!=typeof document&&function(){var e=document.createDocumentFragment(),t=document.createElement("div");t.appendChild(document.createTextNode("")),t.appendChild(document.createTextNode("")),e.appendChild(t);var a=e.cloneNode(!0);return 2===a.childNodes[0].childNodes.length}();return c.keepsTextNodes=l,e.view.target=c,c});
/*can/view/stache/utils*/
define("can/view/stache/utils",["can/util/util"],function(){return{isArrayLike:function(t){return t&&t.splice&&"number"==typeof t.length},isObserveLike:function(t){return t instanceof can.Map||t&&!!t._get},emptyHandler:function(){},jsonParse:function(str){return"'"===str[0]?str.substr(1,str.length-2):"undefined"===str?void 0:window.JSON?JSON.parse(str):eval("("+str+")")},mixins:{last:function(){return this.stack[this.stack.length-1]},add:function(t){this.last().add(t)},subSectionDepth:function(){return this.stack.length-1}}}});
/*can/view/node_lists/node_lists*/
define("can/view/node_lists/node_lists",["can/util/util","can/view/elements"],function(e){var n=!0;try{document.createTextNode("")._=0}catch(r){n=!1}var t={},i={},u="ejs_"+Math.random(),a=0,s=function(e){if(n||3!==e.nodeType)return e[u]?e[u]:(++a,e[u]=(e.nodeName?"element_":"obj_")+a);for(var r in i)if(i[r]===e)return r;return++a,i["text_"+a]=e,"text_"+a},o=[].splice,d=[].push,c=function(e){for(var n=0,r=0,t=e.length;t>r;r++){var i=e[r];i.nodeType?n++:n+=c(i)}return n},l={id:s,update:function(n,r){var t=l.unregisterChildren(n);r=e.makeArray(r);var i=n.length;return o.apply(n,[0,i].concat(r)),l.nestList(n),t},nestList:function(e){for(var n=0;n<e.length;){var r=e[n],i=t[s(r)];i?i!==e&&e.splice(n,c(i),i):t[s(r)]=e,n++}},last:function(e){var n=e[e.length-1];return n.nodeType?n:l.last(n)},first:function(e){var n=e[0];return n.nodeType?n:l.first(n)},register:function(e,n){return e.unregistered=n,l.nestList(e),e},unregisterChildren:function(n){var r=[];return e.each(n,function(e){e.nodeType?(delete t[s(e)],r.push(e)):d.apply(r,l.unregister(e))}),r},unregister:function(e){var n=l.unregisterChildren(e);if(e.unregistered){var r=e.unregistered;delete e.unregistered,r()}return n},nodeMap:t};return e.view.nodeLists=l,l});
/*can/view/live/live*/
define("can/view/live/live",["can/util/util","can/view/elements","can/view/view","can/view/node_lists/node_lists","can/view/parser/parser"],function(e,t,n,r,i){t=t||e.view.elements,r=r||e.view.NodeLists,i=i||e.view.parser;var a=function(t,n,r){var i=!1,a=function(){return i||(i=!0,r(o),e.unbind.call(t,"removed",a)),!0},o={teardownCheck:function(e){return e?!1:a()}};return e.bind.call(t,"removed",a),n(o),o},o=function(e,t,n){return a(e,function(){t.bind("change",n)},function(e){t.unbind("change",n),e.nodeList&&r.unregister(e.nodeList)})},c=function(e){var t,n={};return i.parseAttrs(e,{attrStart:function(e){n[e]="",t=e},attrValue:function(e){n[t]+=e},attrEnd:function(){}}),n},u=[].splice,d=function(e){return e&&e.nodeType},s=function(e){e.childNodes.length||e.appendChild(document.createTextNode(""))},l={list:function(n,i,o,c,d){var s,f=[n],p=[],v=function(n,i,a){var d=document.createDocumentFragment(),s=[],l=[];e.each(i,function(t,n){var i=e.compute(n+a),u=o.call(c,t,i),f="string"==typeof u,p=e.frag(u);p=f?e.view.hookup(p):p;var v=e.makeArray(p.childNodes);s.push(r.register(v)),d.appendChild(p),l.push(i)});var v=a+1;if(f[v]){var h=r.first(f[v]);e.insertBefore(h.parentNode,d,h)}else t.after(1===v?[g]:[r.last(f[v-1])],d);u.apply(f,[v,0].concat(s)),u.apply(p,[a,0].concat(l));for(var b=a+l.length,m=p.length;m>b;b++)p[b](b)},h=function(t,n,i,a,o){if(a||!w.teardownCheck(g.parentNode)){var c=f.splice(i+1,n.length),u=[];e.each(c,function(e){var t=r.unregister(e);[].push.apply(u,t)}),p.splice(i,n.length);for(var d=i,s=p.length;s>d;d++)p[d](d);o||e.remove(e.$(u))}},g=document.createTextNode(""),b=function(e){s&&s.unbind&&s.unbind("add",v).unbind("remove",h),h({},{length:f.length-1},0,!0,e)},m=function(e,t){b(),s=t||[],s.bind&&s.bind("add",v).bind("remove",h),v({},s,0)};d=t.getParentNode(n,d);var w=a(d,function(){e.isFunction(i)&&i.bind("change",m)},function(){e.isFunction(i)&&i.unbind("change",m),b(!0)});l.replace(f,g,w.teardownCheck),m({},e.isFunction(i)?i():i)},html:function(n,i,a){var c;a=t.getParentNode(n,a),c=o(a,i,function(e,t){var n=r.first(u).parentNode;n&&l(t),c.teardownCheck(r.first(u).parentNode)});var u=[n],l=function(n){var i=!d(n),o=e.frag(n),c=e.makeArray(u);s(o),i&&(o=e.view.hookup(o,a)),c=r.update(u,o.childNodes),t.replace(c,o)};c.nodeList=u,r.register(u,c.teardownCheck),l(i())},replace:function(n,i,a){var o=n.slice(0),c=e.frag(i);return r.register(n,a),"string"==typeof i&&(c=e.view.hookup(c,n[0].parentNode)),r.update(n,c.childNodes),t.replace(o,c),n},text:function(n,r,i){var a=t.getParentNode(n,i),c=o(a,r,function(t,n){"unknown"!=typeof u.nodeValue&&(u.nodeValue=e.view.toStr(n)),c.teardownCheck(u.parentNode)}),u=document.createTextNode(e.view.toStr(r()));c.nodeList=l.replace([n],u,c.teardownCheck)},setAttributes:function(t,n){var r=c(n);for(var i in r)e.attr.set(t,i,r[i])},attributes:function(n,r,i){var a={},u=function(r){var i,o=c(r);for(i in o){var u=o[i],d=a[i];u!==d&&e.attr.set(n,i,u),delete a[i]}for(i in a)t.removeAttr(n,i);a=o};o(n,r,function(e,t){u(t)}),arguments.length>=3?a=c(i):u(r())},attributePlaceholder:"__!!__",attributeReplace:/__!!__/g,attribute:function(n,r,i){o(n,i,function(){t.setAttr(n,r,u.render())});var a,c=e.$(n);a=e.data(c,"hooks"),a||e.data(c,"hooks",a={});var u,d=t.getAttr(n,r),s=d.split(l.attributePlaceholder),f=[];f.push(s.shift(),s.join(l.attributePlaceholder)),a[r]?a[r].computes.push(i):a[r]={render:function(){var e=0,n=d?d.replace(l.attributeReplace,function(){return t.contentText(u.computes[e++]())}):t.contentText(u.computes[e++]());return n},computes:[i],batchNum:void 0},u=a[r],f.splice(1,0,i()),t.setAttr(n,r,f.join(""))},specialAttribute:function(e,n,r){o(e,r,function(r,i){t.setAttr(e,n,p(i))}),t.setAttr(e,n,p(r()))},simpleAttribute:function(e,n,r){o(e,r,function(r,i){t.setAttr(e,n,i)}),t.setAttr(e,n,r())}};l.attr=l.simpleAttribute,l.attrs=l.attributes;var f=/(\r|\n)+/g,p=function(e){var n=/^["'].*["']$/;return e=e.replace(t.attrReg,"").replace(f,""),n.test(e)?e.substr(1,e.length-2):e};return e.view.live=l,l});
/*can/view/stache/mustache_helpers*/
define("can/view/stache/mustache_helpers",["can/util/util","./utils","can/view/live/live"],function(e,n,t){t=t||e.view.live;var i=function(t){return n.isObserveLike(t)&&n.isArrayLike(t)&&t.attr("length")?t:e.isFunction(t)?t():t},o={each:function(o,r){var s,c,u,a=i(o),f=[];if(a instanceof e.List||o&&o.isComputed&&void 0===a)return function(e){var n=function(e,n){return r.fn(r.scope.add({"@index":n}).add(e))};t.list(e,o,n,r.context,e.parentNode)};var d=a;if(d&&n.isArrayLike(d))for(u=0;u<d.length;u++)f.push(r.fn(r.scope.add({"@index":u}).add(d[u])));else if(n.isObserveLike(d))for(s=e.Map.keys(d),u=0;u<s.length;u++)c=s[u],f.push(r.fn(r.scope.add({"@key":c}).add(d[c])));else if(d instanceof Object)for(c in d)f.push(r.fn(r.scope.add({"@key":c}).add(d[c])));return f},"if":function(n,t){var o;return o=e.isFunction(n)?e.compute.truthy(n)():!!i(n),o?t.fn(t.scope||this):t.inverse(t.scope||this)},unless:function(e,n){return i(e)?void 0:n.fn(n.scope||this)},"with":function(e,n){var t=e;return e=i(e),e?n.fn(t):void 0},log:function(e,n){"undefined"!=typeof console&&console.log&&(n?console.log(e,n.context):console.log(e.context))},data:function(n){var t=2===arguments.length?this:arguments[1];return function(i){e.data(e.$(i),n,t||this.context)}}};return{registerHelper:function(e,n){o[e]=n},getHelper:function(e,n){var t=n.attr("helpers."+e);return t||(t=o[e]),t?{fn:t}:void 0}}});
/*can/util/string/string*/
define("can/util/string/string",["can/util/util"],function(e){var r=/_|-/,n=/\=\=/,t=/([A-Z]+)([A-Z][a-z])/g,a=/([a-z\d])([A-Z])/g,u=/([a-z\d])([A-Z])/g,i=/\{([^\}]+)\}/g,c=/"/g,o=/'/g,l=/-+(.)?/g,p=/[a-z][A-Z]/g,f=function(e,r,n){var t=e[r];return void 0===t&&n===!0&&(t=e[r]={}),t},g=function(e){return/^f|^o/.test(typeof e)},d=function(e){var r=null===e||void 0===e||isNaN(e)&&""+e=="NaN";return""+(r?"":e)};return e.extend(e,{esc:function(e){return d(e).replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;").replace(c,"&#34;").replace(o,"&#39;")},getObject:function(r,n,t){var a,u,i,c,o=r?r.split("."):[],l=o.length,p=0;if(n=e.isArray(n)?n:[n||window],c=n.length,!l)return n[0];for(p;c>p;p++){for(a=n[p],i=void 0,u=0;l>u&&g(a);u++)i=a,a=f(i,o[u]);if(void 0!==i&&void 0!==a)break}if(t===!1&&void 0!==a&&delete i[o[u-1]],t===!0&&void 0===a)for(a=n[0],u=0;l>u&&g(a);u++)a=f(a,o[u],!0);return a},capitalize:function(e){return e.charAt(0).toUpperCase()+e.slice(1)},camelize:function(e){return d(e).replace(l,function(e,r){return r?r.toUpperCase():""})},hyphenate:function(e){return d(e).replace(p,function(e){return e.charAt(0)+"-"+e.charAt(1).toLowerCase()})},underscore:function(e){return e.replace(n,"/").replace(t,"$1_$2").replace(a,"$1_$2").replace(u,"_").toLowerCase()},sub:function(r,n,t){var a=[];return r=r||"",a.push(r.replace(i,function(r,u){var i=e.getObject(u,n,t===!0?!1:void 0);return void 0===i||null===i?(a=null,""):g(i)&&a?(a.push(i),""):""+i})),null===a?a:a.length<=1?a[0]:a},replacer:i,undHash:r}),e});
/*can/construct/construct*/
define("can/construct/construct",["can/util/string/string"],function(t){var n=0;return t.Construct=function(){return arguments.length?t.Construct.extend.apply(t.Construct,arguments):void 0},t.extend(t.Construct,{constructorExtends:!0,newInstance:function(){var t,n=this.instance();return n.setup&&(t=n.setup.apply(n,arguments)),n.init&&n.init.apply(n,t||arguments),n},_inherit:function(n,e,r){t.extend(r||n,n||{})},_overwrite:function(t,n,e,r){t[e]=r},setup:function(n){this.defaults=t.extend(!0,{},n.defaults,this.defaults)},instance:function(){n=1;var t=new this;return n=0,t},extend:function(e,r,s){function o(){return n?void 0:(this.constructor!==o&&arguments.length&&o.constructorExtends&&t.dev.warn("can/construct/construct.js: extending a can.Construct without calling extend"),this.constructor!==o&&arguments.length&&o.constructorExtends?o.extend.apply(o,arguments):o.newInstance.apply(o,arguments))}"string"!=typeof e&&(s=r,r=e,e=null),s||(s=r,r=null),s=s||{};var c,u,i,a,p,l,d,h,g=this,f=this.prototype;h=this.instance(),t.Construct._inherit(s,f,h);for(p in g)g.hasOwnProperty(p)&&(o[p]=g[p]);t.Construct._inherit(r,g,o),e&&(c=e.split("."),l=c.pop(),u=t.getObject(c.join("."),window,!0),d=u,i=t.underscore(e.replace(/\./g,"_")),a=t.underscore(l),u[l]&&t.dev.warn("can/construct/construct.js: There's already something called "+e),u[l]=o),t.extend(o,{constructor:o,prototype:h,namespace:d,_shortName:a,fullName:e,_fullName:i}),void 0!==l&&(o.shortName=l),o.prototype.constructor=o;var m=[g].concat(t.makeArray(arguments)),y=o.setup.apply(o,m);return o.init&&o.init.apply(o,y||m),o}}),t.Construct.prototype.setup=function(){},t.Construct.prototype.init=function(){},t.Construct});
/*can/util/bind/bind*/
define("can/util/bind/bind",["can/util/util"],function(i){return i.bindAndSetup=function(){return i.addEvent.apply(this,arguments),this._init||(this._bindings?this._bindings++:(this._bindings=1,this._bindsetup&&this._bindsetup())),this},i.unbindAndTeardown=function(){return i.removeEvent.apply(this,arguments),null===this._bindings?this._bindings=0:this._bindings--,!this._bindings&&this._bindteardown&&this._bindteardown(),this},i});
/*can/map/bubble*/
define("can/map/bubble",["can/util/util"],function(n){var e=n.bubble={event:function(n,e){return n.constructor._bubbleRule(e,n)},childrenOf:function(n,i){n._each(function(b,t){b&&b.bind&&e.toParent(b,n,t,i)})},teardownChildrenFrom:function(n,i){n._each(function(b){e.teardownFromParent(n,b,i)})},toParent:function(e,i,b,t){n.listenTo.call(i,e,t,function(){var t=n.makeArray(arguments),r=t.shift();t[0]=(n.List&&i instanceof n.List?i.indexOf(e):b)+(t[0]?"."+t[0]:""),r.triggeredNS=r.triggeredNS||{},r.triggeredNS[i._cid]||(r.triggeredNS[i._cid]=!0,n.trigger(i,r,t))})},teardownFromParent:function(e,i,b){i&&i.unbind&&n.stopListening.call(e,i,b)},bind:function(n,i){if(!n._init){var b=e.event(n,i);b&&(n._bubbleBindings||(n._bubbleBindings={}),n._bubbleBindings[b]?n._bubbleBindings[b]++:(n._bubbleBindings[b]=1,e.childrenOf(n,b)))}},unbind:function(i,b){var t=e.event(i,b);t&&(i._bubbleBindings&&i._bubbleBindings[t]--,i._bubbleBindings[t]||(delete i._bubbleBindings[t],e.teardownChildrenFrom(i,t),n.isEmptyObject(i._bubbleBindings)&&delete i._bubbleBindings))},add:function(i,b,t){if(b instanceof n.Map&&i._bubbleBindings)for(var r in i._bubbleBindings)i._bubbleBindings[r]&&(e.teardownFromParent(i,b,r),e.toParent(b,i,t,r))},removeMany:function(n,i){for(var b=0,t=i.length;t>b;b++)e.remove(n,i[b])},remove:function(i,b){if(b instanceof n.Map&&i._bubbleBindings)for(var t in i._bubbleBindings)i._bubbleBindings[t]&&e.teardownFromParent(i,b,t)},set:function(i,b,t,r){return n.Map.helpers.isObservable(t)&&e.add(i,t,b),n.Map.helpers.isObservable(r)&&e.remove(i,r),t}};return e});
/*can/util/batch/batch*/
define("can/util/batch/batch",["can/util/can"],function(t){var i=1,n=0,r=[],c=[];t.batch={start:function(t){n++,t&&c.push(t)},stop:function(a,e){if(a?n=0:n--,0===n){var f,g,h=r.slice(0),u=c.slice(0);for(r=[],c=[],i++,e&&t.batch.start(),f=0,g=h.length;g>f;f++)t.trigger.apply(t,h[f]);for(f=0,g=u.length;f<u.length;f++)u[f]()}},trigger:function(c,a,e){if(!c._init){if(0===n)return t.trigger(c,a,e);a="string"==typeof a?{type:a}:a,a.batchNum=i,r.push([c,a,e])}}}});
/*can/map/map*/
define("can/map/map",["can/util/util","can/util/bind/bind","./bubble","can/construct/construct","can/util/batch/batch"],function(t,e,i){var n=null,r=function(){for(var t in n)n[t].added&&delete n[t].obj._cid;n=null},s=function(t){return n&&n[t._cid]&&n[t._cid].instance},a=null,u=t.Map=t.Construct.extend({setup:function(){if(t.Construct.setup.apply(this,arguments),t.Map){this.defaults||(this.defaults={}),this._computes=[];for(var e in this.prototype)"define"!==e&&"function"!=typeof this.prototype[e]?this.defaults[e]=this.prototype[e]:this.prototype[e].isComputed&&this._computes.push(e);this.helpers.define(this)}!t.List||this.prototype instanceof t.List||(this.List=u.List.extend({Map:this},{}))},_bubble:i,_bubbleRule:function(t){return("change"===t||t.indexOf(".")>=0)&&"change"},_computes:[],bind:t.bindAndSetup,on:t.bindAndSetup,unbind:t.unbindAndTeardown,off:t.unbindAndTeardown,id:"id",helpers:{define:function(){},attrParts:function(e,i){return i?[e]:t.isArray(e)?e:(""+e).split(".")},addToMap:function(e,i){var s;n||(s=r,n={});var a=e._cid,u=t.cid(e);return n[u]||(n[u]={obj:e,instance:i,added:!a}),s},isObservable:function(e){return e instanceof t.Map||e&&e===t.route},canMakeObserve:function(e){return e&&!t.isDeferred(e)&&(t.isArray(e)||t.isPlainObject(e))},serialize:function(e,i,n){var r=t.cid(e),s=!1;return a||(s=!0,a={attr:{},serialize:{}}),a[i][r]=n,e.each(function(r,s){var o,h=u.helpers.isObservable(r),c=h&&a[i][t.cid(r)];o=c?c:"serialize"===i?u.helpers._serialize(e,s,r):u.helpers._getValue(e,s,r,i),void 0!==o&&(n[s]=o)}),t.__reading(e,"__keys"),s&&(a=null),n},_serialize:function(t,e,i){return u.helpers._getValue(t,e,i,"serialize")},_getValue:function(t,e,i,n){return u.helpers.isObservable(i)?i[n]():i}},keys:function(e){var i=[];t.__reading(e,"__keys");for(var n in e._data)i.push(n);return i}},{setup:function(e){this._data={},t.cid(this,".map"),this._init=1;var i=this._setupDefaults();this._setupComputes(i);var n=e&&t.Map.helpers.addToMap(e,this),r=t.extend(t.extend(!0,{},i),e);this.attr(r),n&&n(),this.bind("change",t.proxy(this._changes,this)),delete this._init},_setupComputes:function(){var t=this.constructor._computes;this._computedBindings={};for(var e,i=0,n=t.length;n>i;i++)e=t[i],this[e]=this[e].clone(this),this._computedBindings[e]={count:0}},_setupDefaults:function(){return this.constructor.defaults||{}},_bindsetup:function(){},_bindteardown:function(){},_changes:function(e,i,n,r,s){t.batch.trigger(this,{type:i,batchNum:e.batchNum},[r,s]),("remove"===n||"add"===n)&&t.batch.trigger(this,{type:"__keys",batchNum:e.batchNum})},_triggerChange:function(){t.batch.trigger(this,"change",t.makeArray(arguments))},_each:function(t){var e=this.__get();for(var i in e)e.hasOwnProperty(i)&&t(e[i],i)},attr:function(e,i){var n=typeof e;return"string"!==n&&"number"!==n?this._attrs(e,i):1===arguments.length?(t.__reading(this,e),this._get(e)):(this._set(e,i),this)},each:function(){return t.each.apply(void 0,[this].concat(t.makeArray(arguments)))},removeAttr:function(e){var i=t.List&&this instanceof t.List,n=t.Map.helpers.attrParts(e),r=n.shift(),s=i?this[r]:this._data[r];return n.length&&s?s.removeAttr(n):("string"==typeof e&&~e.indexOf(".")&&(r=e),this._remove(r,s),s)},_remove:function(t,e){t in this._data&&(delete this._data[t],t in this.constructor.prototype||delete this[t],this._triggerChange(t,"remove",void 0,e))},_get:function(e){var i;if("string"==typeof e&&~e.indexOf(".")&&(i=this.__get(e),void 0!==i))return i;var n=t.Map.helpers.attrParts(e),r=this.__get(n.shift());return n.length?r?r._get(n):void 0:r},__get:function(t){return t?this._computedBindings[t]?this[t]():this._data[t]:this._data},__type:function(e){if(!(e instanceof t.Map)&&t.Map.helpers.canMakeObserve(e)){var i=s(e);if(i)return i;if(t.isArray(e)){var n=t.List;return new n(e)}var r=this.constructor.Map||t.Map;return new r(e)}return e},_set:function(e,i,n){var r=t.Map.helpers.attrParts(e,n),s=r.shift(),a=this._init?void 0:this.__get(s);if(r.length&&u.helpers.isObservable(a))a._set(r,i);else{if(r.length)throw"can.Map: Object does not exist";this.__convert&&(i=this.__convert(s,i)),this.__set(s,this.__type(i,s),a)}},__set:function(t,e,i){if(e!==i){var n=this.__get().hasOwnProperty(t)?"set":"add";this.___set(t,this.constructor._bubble.set(this,t,e,i)),this._triggerChange(t,n,e,i),i&&this.constructor._bubble.teardownFromParent(this,i)}},___set:function(e,i){this._computedBindings[e]?this[e](i):this._data[e]=i,t.isFunction(this.constructor.prototype[e])||this._computedBindings[e]||(this[e]=i)},bind:function(e){var i=this._computedBindings&&this._computedBindings[e];if(i)if(i.count)i.count++;else{i.count=1;var n=this;i.handler=function(i,r,s){t.batch.trigger(n,{type:e,batchNum:i.batchNum},[r,s])},this[e].bind("change",i.handler)}return this.constructor._bubble.bind(this,e),t.bindAndSetup.apply(this,arguments)},unbind:function(e){var i=this._computedBindings&&this._computedBindings[e];return i&&(1===i.count?(i.count=0,this[e].unbind("change",i.handler),delete i.handler):i.count--),this.constructor._bubble.unbind(this,e),t.unbindAndTeardown.apply(this,arguments)},serialize:function(){return t.Map.helpers.serialize(this,"serialize",{})},_attrs:function(e,i){if(void 0===e)return u.helpers.serialize(this,"attr",{});e=t.simpleExtend({},e);var n,r,s=this;t.batch.start(),this.each(function(t,n){if("_cid"!==n){if(r=e[n],void 0===r)return void(i&&s.removeAttr(n));s.__convert&&(r=s.__convert(n,r)),u.helpers.isObservable(r)?s.__set(n,s.__type(r,n),t):u.helpers.isObservable(t)&&u.helpers.canMakeObserve(r)?t.attr(r,i):t!==r&&s.__set(n,s.__type(r,n),t),delete e[n]}});for(n in e)"_cid"!==n&&(r=e[n],this._set(n,r,!0));return t.batch.stop(),this},compute:function(e){if(t.isFunction(this.constructor.prototype[e]))return t.compute(this[e],this);var i=e.split("."),n=i.length-1,r={args:[]};return t.compute(function(e){return arguments.length?void t.compute.read(this,i.slice(0,n)).value.attr(i[n],e):t.compute.read(this,i,r).value},this)}});return u.prototype.on=u.prototype.bind,u.prototype.off=u.prototype.unbind,u});
/*can/list/list*/
define("can/list/list",["can/util/util","can/map/map","can/map/bubble"],function(t,e,i){var r=[].splice,s=function(){var t={0:"a",length:1};return r.call(t,0,1),!t[0]}(),h=e.extend({Map:e},{setup:function(e,i){this.length=0,t.cid(this,".map"),this._init=1,this._setupComputes(),e=e||[];var r;t.isDeferred(e)?this.replace(e):(r=e.length&&t.Map.helpers.addToMap(e,this),this.push.apply(this,t.makeArray(e||[]))),r&&r(),this.bind("change",t.proxy(this._changes,this)),t.simpleExtend(this,i),delete this._init},_triggerChange:function(i,r,s,h){e.prototype._triggerChange.apply(this,arguments);var n=+i;~i.indexOf(".")||isNaN(n)||("add"===r?(t.batch.trigger(this,r,[s,n]),t.batch.trigger(this,"length",[this.length])):"remove"===r?(t.batch.trigger(this,r,[h,n]),t.batch.trigger(this,"length",[this.length])):t.batch.trigger(this,r,[s,n]))},__get:function(e){return e?this[e]&&this[e].isComputed&&t.isFunction(this.constructor.prototype[e])?this[e]():this[e]:this},___set:function(t,e){this[t]=e,+t>=this.length&&(this.length=+t+1)},_remove:function(t,e){isNaN(+t)?(delete this[t],this._triggerChange(t,"remove",void 0,e)):this.splice(t,1)},_each:function(t){for(var e=this.__get(),i=0;i<e.length;i++)t(e[i],i)},serialize:function(){return e.helpers.serialize(this,"serialize",[])},splice:function(e,h){var n,a=t.makeArray(arguments);for(n=2;n<a.length;n++)a[n]=i.set(this,n,this.__type(a[n],n));void 0===h&&(h=a[1]=this.length-e);var l=r.apply(this,a);if(!s)for(n=this.length;n<l.length+this.length;n++)delete this[n];return t.batch.start(),h>0&&(this._triggerChange(""+e,"remove",void 0,l),i.removeMany(this,l)),a.length>2&&this._triggerChange(""+e,"add",a.slice(2),l),t.batch.stop(),l},_attrs:function(i,r){return void 0===i?e.helpers.serialize(this,"attr",[]):(i=t.makeArray(i),t.batch.start(),this._updateAttrs(i,r),void t.batch.stop())},_updateAttrs:function(t,i){for(var r=Math.min(t.length,this.length),s=0;r>s;s++){var h=this[s],n=t[s];e.helpers.isObservable(h)&&e.helpers.canMakeObserve(n)?h.attr(n,i):h!==n&&this._set(s,n)}t.length>this.length?this.push.apply(this,t.slice(this.length)):t.length<this.length&&i&&this.splice(t.length)}}),n=function(e){return e[0]&&t.isArray(e[0])?e[0]:t.makeArray(e)};return t.each({push:"length",unshift:0},function(t,e){var r=[][e];h.prototype[e]=function(){for(var e,s,h=[],n=t?this.length:0,a=arguments.length;a--;)s=arguments[a],h[a]=i.set(this,a,this.__type(s,a));return e=r.apply(this,h),(!this.comparator||h.length)&&this._triggerChange(""+n,"add",h,void 0),e}}),t.each({pop:"length",shift:0},function(t,e){h.prototype[e]=function(){var r=n(arguments),s=t&&this.length?this.length-1:0,h=[][e].apply(this,r);return this._triggerChange(""+s,"remove",void 0,[h]),h&&h.unbind&&i.remove(this,h),h}}),t.extend(h.prototype,{indexOf:function(e,i){return this.attr("length"),t.inArray(e,this,i)},join:function(){return[].join.apply(this.attr(),arguments)},reverse:function(){var e=t.makeArray([].reverse.call(this));this.replace(e)},slice:function(){var t=Array.prototype.slice.apply(this,arguments);return new this.constructor(t)},concat:function(){var e=[];return t.each(t.makeArray(arguments),function(i,r){e[r]=i instanceof t.List?i.serialize():i}),new this.constructor(Array.prototype.concat.apply(this.serialize(),e))},forEach:function(e,i){return t.each(this,e,i||this)},replace:function(e){return t.isDeferred(e)?e.then(t.proxy(this.replace,this)):this.splice.apply(this,[0,this.length].concat(t.makeArray(e||[]))),this},filter:function(e,i){var r,s=new t.List,h=this;return this.each(function(t,n){r=e.call(i|h,t,n,h),r&&s.push(t)}),s}}),t.List=e.List=h,t.List});
/*can/compute/compute*/
define("can/compute/compute",["can/util/util","can/util/bind/bind","can/util/batch/batch"],function(n){var e=[];n.__read=function(n,t){e.push({});var o=n.call(t);return{value:o,observed:e.pop()}},n.__reading=function(n,t){e.length&&(e[e.length-1][n._cid+"|"+t]={obj:n,event:t+""})},n.__clearReading=function(){if(e.length){var n=e[e.length-1];return e[e.length-1]={},n}},n.__setReading=function(n){e.length&&(e[e.length-1]=n)},n.__addReading=function(t){e.length&&n.simpleExtend(e[e.length-1],t)};var t=function(e,t,o,u){var r,i,c=n.__read(e,t),a=c.observed;for(i in a)o[i]?delete o[i]:(r=a[i],r.obj.bind(r.event,u));for(i in o)r=o[i],r.obj.unbind(r.event,u);return c},o=function(e,t,o,u){t!==o&&n.batch.trigger(e,u?{type:"change",batchNum:u}:"change",[t,o])},u=function(e,o,u,r){var i,c,a;return{on:function(f){c||(c=function(n){if(e.bound&&(void 0===n.batchNum||n.batchNum!==a)){var r=i.value;i=t(o,u,i.observed,c),f(i.value,r,n.batchNum),a=a=n.batchNum}}),i=t(o,u,{},c),r(i.value),e.hasDependencies=!n.isEmptyObject(i.observed)},off:function(){for(var n in i.observed){var e=i.observed[n];e.obj.unbind(e.event,c)}}}},r=function(e){return e instanceof n.Map||e&&e.__get},i=function(){};n.compute=function(t,r,c){if(t&&t.isComputed)return t;var a,f,l,d=i,s=i,b=function(){return f},p=function(n){f=n},v=p,h=n.makeArray(arguments),g=function(n,e,t){v(n),o(a,n,e,t)};if(a=function(t){if(arguments.length){var u=f,i=p.call(r,t,u);return a.hasDependencies?b.call(r):(f=void 0===i?b.call(r):i,o(a,f,u),f)}return e.length&&a.canReadForChangeEvent!==!1&&(n.__reading(a,"change"),a.bound||n.compute.temporarilyBind(a)),a.bound?f:b.call(r)},"function"==typeof t){p=t,b=t,a.canReadForChangeEvent=c===!1?!1:!0;var m=u(a,t,r||this,v);d=m.on,s=m.off}else if(r)if("string"==typeof r){var y=r,_=t instanceof n.Map;_&&(a.hasDependencies=!0),b=function(){return _?t.attr(y):t[y]},p=function(n){_?t.attr(y,n):t[y]=n};var C;d=function(e){C=function(){e(b(),f)},n.bind.call(t,c||y,C),f=n.__read(b).value},s=function(){n.unbind.call(t,c||y,C)}}else if("function"==typeof r)f=t,p=r,r=c,l="setter";else{f=t;var x=r,O=g;if(r=x.context||x,b=x.get||b,p=x.set||function(){return f},x.fn){var E,R=x.fn;b=function(){return R.call(r,f)},0===R.length?E=u(a,R,r,v):1===R.length?E=u(a,function(){return R.call(r,f)},r,v):(g=function(n){void 0!==n&&O(n,f)},E=u(a,function(){var n=R.call(r,f,function(n){O(n,f)});return void 0!==n?n:f},r,v)),d=E.on,s=E.off}else g=function(){var n=b.call(r);O(n,f)};d=x.on||d,s=x.off||s}else f=t;return n.cid(a,"compute"),n.simpleExtend(a,{isComputed:!0,_bindsetup:function(){this.bound=!0;var e=n.__clearReading();d.call(this,g),n.__setReading(e)},_bindteardown:function(){s.call(this,g),this.bound=!1},bind:n.bindAndSetup,unbind:n.unbindAndTeardown,clone:function(e){return e&&("setter"===l?h[2]=e:h[1]=e),n.compute.apply(n,h)}})};var c,a=function(){for(var n=0,e=c.length;e>n;n++)c[n].unbind("change",i);c=null};return n.compute.temporarilyBind=function(n){n.bind("change",i),c||(c=[],setTimeout(a,10)),c.push(n)},n.compute.truthy=function(e){return n.compute(function(){var n=e();return"function"==typeof n&&(n=n()),!!n})},n.compute.async=function(e,t,o){return n.compute(e,{fn:t,context:o})},n.compute.read=function(e,t,o){o=o||{};for(var u,i,c,a=e,f=0,l=t.length;l>f;f++)if(i=a,i&&i.isComputed&&(o.foundObservable&&o.foundObservable(i,f),i=i()),r(i)?(!c&&o.foundObservable&&o.foundObservable(i,f),c=1,a="function"==typeof i[t[f]]&&i.constructor.prototype[t[f]]===i[t[f]]?o.returnObserveMethods?a[t[f]]:"constructor"===t[f]&&i instanceof n.Construct?i[t[f]]:i[t[f]].apply(i,o.args||[]):a.attr(t[f])):a=i[t[f]],u=typeof a,a&&a.isComputed&&!o.isArgument&&l-1>f?(!c&&o.foundObservable&&o.foundObservable(i,f+1),a=a()):f<t.length-1&&"function"===u&&o.executeAnonymousFunctions&&!(n.Construct&&a.prototype instanceof n.Construct)&&(a=a()),f<t.length-1&&(null===a||"function"!==u&&"object"!==u))return o.earlyExit&&o.earlyExit(i,f,a),{value:void 0,parent:i};return"function"!=typeof a||n.Construct&&a.prototype instanceof n.Construct||(o.isArgument?a.isComputed||o.proxyMethods===!1||(a=n.proxy(a,i)):(a.isComputed&&!c&&o.foundObservable&&o.foundObservable(a,f),a=a.call(i))),void 0===a&&o.earlyExit&&o.earlyExit(i,f-1),{value:a,parent:i}},n.compute});
/*can/view/scope/scope*/
define("can/view/scope/scope",["can/util/util","can/construct/construct","can/map/map","can/list/list","can/view/view","can/compute/compute"],function(e){var t=/(\\)?\./g,n=/\\\./g,r=function(e){var r=[],a=0;return e.replace(t,function(t,u,i){u||(r.push(e.slice(a,i).replace(n,".")),a=i+t.length)}),r.push(e.slice(a).replace(n,".")),r},a=e.Construct.extend({read:e.compute.read},{init:function(e,t){this._context=e,this._parent=t,this.__cache={}},attr:function(t){var n=e.__clearReading(),r=this.read(t,{isArgument:!0,returnObserveMethods:!0,proxyMethods:!1}).value;return e.__setReading(n),r},add:function(e){return e!==this._context?new this.constructor(e,this):this},computeData:function(t,n){n=n||{args:[]};var r,a,u=this,i={compute:e.compute(function(c){if(!arguments.length){if(r)return e.compute.read(r,a,n).value;var s=u.read(t,n);return r=s.rootObserve,a=s.reads,i.scope=s.scope,i.initialValue=s.value,s.value}if(r.isComputed&&!a.length)r(c);else{var o=a.length-1;e.compute.read(r,a.slice(0,o)).value.attr(a[o],c)}})};return i},compute:function(e,t){return this.computeData(e,t).compute},read:function(t,n){var a;if("./"===t.substr(0,2))a=!0,t=t.substr(2);else{if("../"===t.substr(0,3))return this._parent.read(t.substr(3),n);if(".."===t)return{value:this._parent._context};if("."===t||"this"===t)return{value:this._context}}for(var u,i,c,s,o,l,p=-1===t.indexOf("\\.")?t.split("."):r(t),v=this,d=[],f=-1;v;){if(u=v._context,null!==u){var h=e.compute.read(u,p,e.simpleExtend({foundObservable:function(e,t){o=e,l=p.slice(t)},earlyExit:function(t,n){n>f&&(i=o,d=l,f=n,s=v,c=e.__clearReading())},executeAnonymousFunctions:!0},n));if(void 0!==h.value)return{scope:v,rootObserve:o,value:h.value,reads:l}}e.__clearReading(),v=a?null:v._parent}return i?(e.__setReading(c),{scope:s,rootObserve:i,reads:d,value:void 0}):{names:p,value:void 0}}});return e.view.Scope=a,a});
/*can/view/stache/mustache_core*/
define("can/view/stache/mustache_core",["can/util/util","./utils","./mustache_helpers","can/view/live/live","can/view/elements","can/view/scope/scope"],function(e,t,n,r,i){r=r||e.view.live,i=i||e.view.elements;var a=/((([^\s]+?=)?('.*?'|".*?"))|.*?)\s/g,s=/^(?:(?:('.*?'|".*?")|([0-9]+\.?[0-9]*|true|false|null|undefined))|(?:(.+?)=(?:(?:('.*?'|".*?")|([0-9]+\.?[0-9]*|true|false|null|undefined))|(.+))))$/,o=/(?:(?:^|(\r?)\n)(\s*)(\{\{([^\}]*)\}\}\}?)([^\S\n\r]*)($|\r?\n))|(\{\{([^\}]*)\}\}\}?)/g,u=function(e){return e&&"string"==typeof e.get},c=function(e,t,n,r){for(var i=document.createDocumentFragment(),a=0,s=e.length;s>a;a++)f(i,n.fn(t?e.attr(""+a):e[a],r));return i},f=function(e,t){t&&e.appendChild("string"==typeof t?document.createTextNode(t):t)},l=function(e,t,n,r){for(var i="",a=0,s=e.length;s>a;a++)i+=n.fn(t?e.attr(""+a):e[a],r);return i},p=function(t,n,r){var i=n.computeData(t,{isArgument:r,args:[n.attr("."),n]});return e.compute.temporarilyBind(i.compute),i},h=function(e,t){var n=p(e,t,!0);return n.compute.hasDependencies?n.compute:n.initialValue},d=function(e,t,n,r,i){r&&(e.fn=v(r,t,n)),i&&(e.inverse=v(i,t,n))},v=function(t,n,r){var i=function(e,r){return t(e||n,r)};return function(t,a){return void 0===t||t instanceof e.view.Scope||(t=n.add(t)),void 0===a||a instanceof g.Options||(a=r.add(a)),i(t,a||r)}},g={expressionData:function(n){var r=[],i={},o=0;return(e.trim(n)+" ").replace(a,function(e,n){var a;o&&(a=n.match(s))?a[1]||a[2]?r.push(t.jsonParse(a[1]||a[2])):i[a[3]]=a[6]?{get:a[6]}:t.jsonParse(a[4]||a[5]):r.push({get:n}),o++}),{name:r.shift(),args:r,hash:i}},makeEvaluator:function(r,i,a,s,o,f,v){for(var g,m,x=[],y={},w={fn:function(){},inverse:function(){}},_=r.attr("."),b=s.name,k=s.args.length||!e.isEmptyObject(s.hash),D=0,O=s.args.length;O>D;D++){var j=s.args[D];x.push(j&&u(j)?h(j.get,r,!0):j)}for(var E in s.hash)y[E]=u(s.hash[E])?h(s.hash[E].get,r):s.hash[E];if(u(b)){if(k&&(g=n.getHelper(b.get,i),g||"function"!=typeof _[b.get]||(g={fn:_[b.get]})),!g){var B=b.get,L=p(b.get,r,!1),R=L.compute;m=L.initialValue,b=L.compute.hasDependencies?R:m,k||void 0!==m?"function"==typeof m&&(g={fn:m}):g=n.getHelper(B,i)}g||void 0!==m||e.dev.warn(k?'can/view/stache/mustache_core.js: Unable to find helper "'+s.name.get+'".':'can/view/stache/mustache_core.js: Unable to find key or helper "'+s.name.get+'".')}if("^"===a){var S=o;o=f,f=S}return g?(d(w,r,i,o,f),e.extend(w,{context:_,scope:r,contexts:r,hash:y}),x.push(w),function(){return g.fn.apply(_,x)||""}):a?"#"===a||"^"===a?(d(w,r,i,o,f),function(){var n;if(n=e.isFunction(b)&&b.isComputed?b():b,t.isArrayLike(n)){var a=t.isObserveLike(n);return(a?n.attr("length"):n.length)?(v?l:c)(n,a,w,i):w.inverse(r,i)}return n?w.fn(n||r,i):w.inverse(r,i)}):void 0:b&&b.isComputed?function(){return b()}:function(){return""+(null!=b?b:"")}},makeLiveBindingPartialRenderer:function(t){return t=e.trim(t),function(n,i){var a,s=i.attr("partials."+t);a=s?s.render?s.render(n,i):s(n,i):e.view.render(t,n),r.replace([this],a)}},makeStringBranchRenderer:function(e,t){var n=x(t),r=e+t;return function(t,i,a,s){var o=t.__cache[r];o||(o=t.__cache[r]=m(t,i,e,n,a,s,!0));var u=o();return null==u?"":""+u}},makeLiveBindingBranchRenderer:function(t,n,a){var s=x(n);return function(n,o,u,c){var f=m(n,o,t,s,u,c,a.tag),l=e.compute(f,null,!1);l.bind("change",e.k);var p=l();if("function"==typeof p){var h=e.__clearReading();p(this),e.__setReading(h)}else l.hasDependencies?a.attr?r.simpleAttribute(this,a.attr,l):a.tag?r.attributes(this,l):a.text&&"object"!=typeof p?r.text(this,l,this.parentNode):r.html(this,l,this.parentNode):a.attr?e.attr.set(this,a.attr,p):a.tag?r.setAttributes(this,p):a.text&&"string"==typeof p?this.nodeValue=p:p&&i.replace([this],e.frag(p));l.unbind("change",e.k)}},splitModeFromExpression:function(t,n){t=e.trim(t);var r=t[0];return"#/{&^>!".indexOf(r)>=0?t=e.trim(t.substr(1)):r=null,"{"===r&&n.node&&(r=null),{mode:r,expression:t}},cleanLineEndings:function(e){return e.replace(o,function(e,t,n,r,i,a,s,o,u,c){a=a||"",t=t||"",n=n||"";var f=y(i||u,{});return o||">{".indexOf(f.mode)>=0?e:"^#!/".indexOf(f.mode)>=0?r+(0!==c&&s.length?t+"\n":""):n+r+a+(n.length||0!==c?t+"\n":"")})},Options:e.view.Scope.extend({init:function(t){t.helpers||t.partials||t.tags||(t={helpers:t}),e.view.Scope.prototype.init.apply(this,arguments)}})},m=g.makeEvaluator,x=g.expressionData,y=g.splitModeFromExpression;return g});
/*can/view/stache/html_section*/
define("can/view/stache/html_section",["can/util/util","can/view/target/target","./utils","./mustache_core"],function(t,e,i,n){var a="undefined"!=typeof document&&function(){var t=document.createElement("div");return function(e){return-1===e.indexOf("&")?e.replace(/\r\n/g,"\n"):(t.innerHTML=e,0===t.childNodes.length?"":t.childNodes[0].nodeValue)}}(),s=function(){this.stack=[new r]};t.extend(s.prototype,i.mixins),t.extend(s.prototype,{startSubSection:function(t){var e=new r(t);return this.stack.push(e),e},endSubSectionAndReturnRenderer:function(){if(this.last().isEmpty())return this.stack.pop(),null;var e=this.endSection();return t.proxy(e.compiled.hydrate,e.compiled)},startSection:function(t){var e=new r(t);this.last().add(e.targetCallback),this.stack.push(e)},endSection:function(){return this.last().compile(),this.stack.pop()},inverse:function(){this.last().inverse()},compile:function(){var e=this.stack.pop().compile();return function(i,a){return i instanceof t.view.Scope||(i=new t.view.Scope(i||{})),a instanceof n.Options||(a=new n.Options(a||{})),e.hydrate(i,a)}},push:function(t){this.last().push(t)},pop:function(){return this.last().pop()}});var r=function(e){this.data="targetData",this.targetData=[],this.targetStack=[];var i=this;this.targetCallback=function(n,a){e.call(this,n,a,t.proxy(i.compiled.hydrate,i.compiled),i.inverseCompiled&&t.proxy(i.inverseCompiled.hydrate,i.inverseCompiled))}};return t.extend(r.prototype,{inverse:function(){this.inverseData=[],this.data="inverseData"},push:function(t){this.add(t),this.targetStack.push(t)},pop:function(){return this.targetStack.pop()},add:function(t){"string"==typeof t&&(t=a(t)),this.targetStack.length?this.targetStack[this.targetStack.length-1].children.push(t):this[this.data].push(t)},compile:function(){return this.compiled=e(this.targetData),this.inverseData&&(this.inverseCompiled=e(this.inverseData),delete this.inverseData),delete this.targetData,delete this.targetStack,this.compiled},children:function(){return this.targetStack.length?this.targetStack[this.targetStack.length-1].children:this[this.data]},isEmpty:function(){return!this.targetData.length}}),s});
/*can/view/stache/text_section*/
define("can/view/stache/text_section",["can/util/util","can/view/live/live","./utils"],function(t,e,i){e=e||t.view.live;var n=function(){this.stack=[new a]},s=function(){};t.extend(n.prototype,i.mixins),t.extend(n.prototype,{startSection:function(t){var e=new a;this.last().add({process:t,truthy:e}),this.stack.push(e)},endSection:function(){this.stack.pop()},inverse:function(){this.pop();var t=new a;this.last().last().falsey=t,this.stack.push(t)},compile:function(i){var n=this.stack[0].compile();return function(r,a){var u=t.compute(function(){return n(r,a)},this,!1);u.bind("change",s);var c=u();u.hasDependencies?(i.attr?e.simpleAttribute(this,i.attr,u):e.attributes(this,u),u.unbind("change",s)):i.attr?t.attr.set(this,i.attr,c):e.setAttributes(this,c)}}});var r=function(t,e,i){return function(n,s){return t.call(this,n,s,e,i)}},a=function(){this.values=[]};return t.extend(a.prototype,{add:function(t){this.values.push(t)},last:function(){return this.values[this.values.length-1]},compile:function(){for(var t=this.values,e=t.length,i=0;e>i;i++){var n=this.values[i];"object"==typeof n&&(t[i]=r(n.process,n.truthy&&n.truthy.compile(),n.falsey&&n.falsey.compile()))}return function(i,n){for(var s,r="",a=0;e>a;a++)s=t[a],r+="string"==typeof s?s:s.call(this,i,n);return r}}}),n});
/*can/view/callbacks/callbacks*/
define("can/view/callbacks/callbacks",["can/util/util","can/view/view"],function(t){var e=t.view.attr=function(t,e){if(!e){var i=a[t];if(!i)for(var r=0,o=n.length;o>r;r++){var s=n[r];if(s.match.test(t)){i=s.handler;break}}return i}"string"==typeof t?a[t]=e:n.push({match:t,handler:e})},a={},n=[],i=/[-\:]/,r=t.view.tag=function(t,e){if(!e){var a=o[t.toLowerCase()];return!a&&i.test(t)&&(a=function(){}),a}"undefined"!=typeof window&&window.html5&&(window.html5.elements+=" "+t,window.html5.shivDocument()),o[t.toLowerCase()]=e},o={};return t.view.callbacks={_tags:o,_attributes:a,_regExpAttributes:n,tag:r,attr:e,tagHandler:function(e,a,n){var i=n.options.read("tags."+a,{isArgument:!0,proxyMethods:!1}).value,r=i||o[a],s=n.scope,c=r?r(e,n):s;if(r||t.dev.warn("can/view/scanner.js: No custom element found for "+a),c&&n.subtemplate){s!==c&&(s=s.add(c));var l=n.subtemplate(s,n.options),u="string"==typeof l?t.view.frag(l):l;t.appendChild(e,u)}}},t.view.callbacks});
/*can/view/stache/stache*/
define("can/view/stache/stache",["can/util/util","can/view/parser/parser","can/view/target/target","./html_section","./text_section","./mustache_core","./mustache_helpers","can/view/callbacks/callbacks"],function(e,t,n,a,i,r,o,s){function c(n){n=r.cleanLineEndings(n);var o=new a,c=function(e,t,n){if(">"===t)e.add(r.makeLiveBindingPartialRenderer(n));else if("/"===t)e.endSection();else if("else"===t)e.inverse();else{var i=e instanceof a?r.makeLiveBindingBranchRenderer:r.makeStringBranchRenderer;"{"===t||"&"===t?e.add(i(null,n,u())):"#"===t||"^"===t?e.startSection(i(t,n,u())):e.add(i(null,n,u({text:!0})))}},d={node:null,attr:null,section:null,text:!1},u=function(t){var n={tag:d.node&&d.node.tag,attr:d.attr&&d.attr.name};return t?e.simpleExtend(n,t):n},l=function(e,t){e.attributes||(e.attributes=[]),e.attributes.push(t)};return t(n,{start:function(e){d.node={tag:e,children:[]}},end:function(e,t){var n=s.tag(e);t?(o.add(d.node),n&&l(d.node,function(t,n){s.tagHandler(this,e,{scope:t,options:n,subtemplate:null,templateType:"stache"})})):(o.push(d.node),n&&o.startSubSection()),d.node=null},close:function(e){var t,n=s.tag(e);n&&(t=o.endSubSectionAndReturnRenderer());var a=o.pop();n&&l(a,function(n,a){s.tagHandler(this,e,{scope:n,options:a,subtemplate:t,templateType:"stache"})})},attrStart:function(e){d.node.section?d.node.section.add(e+'="'):d.attr={name:e,value:""}},attrEnd:function(e){if(d.node.section)d.node.section.add('" ');else{d.node.attrs||(d.node.attrs={}),d.node.attrs[d.attr.name]=d.attr.section?d.attr.section.compile(u()):d.attr.value;var t=s.attr(e);t&&(d.node.attributes||(d.node.attributes=[]),d.node.attributes.push(function(n,a){t(this,{attributeName:e,scope:n,options:a})})),d.attr=null}},attrValue:function(e){var t=d.node.section||d.attr.section;t?t.add(e):d.attr.value+=e},chars:function(e){o.add(e)},special:function(e){var t=r.splitModeFromExpression(e,d),n=t.mode,a=t.expression;if("else"===a)return void o.inverse();if("!"!==n)if(d.node&&d.node.section)c(d.node.section,n,a),0===d.node.section.subSectionDepth()&&(d.node.attributes.push(d.node.section.compile(u())),delete d.node.section);else if(d.attr)d.attr.section||(d.attr.section=new i,d.attr.value&&d.attr.section.add(d.attr.value)),c(d.attr.section,n,a);else if(d.node)if(d.node.attributes||(d.node.attributes=[]),n){if("#"!==n&&"^"!==n)throw n+" is currently not supported within a tag.";d.node.section||(d.node.section=new i),c(d.node.section,n,a)}else d.node.attributes.push(r.makeLiveBindingBranchRenderer(null,a,u()));else c(o,n,a)},comment:function(e){o.add({comment:e})},done:function(){}}),o.compile()}t=t||e.view.parser,s=s||e.view.callbacks;var d={"\n":"\\n","\r":"\\r","\u2028":"\\u2028","\u2029":"\\u2029"},u=function(e){return(""+e).replace(/["'\\\n\r\u2028\u2029]/g,function(e){return"'\"\\".indexOf(e)>=0?"\\"+e:d[e]})};return e.view.register({suffix:"stache",contentType:"x-stache-template",fragRenderer:function(e,t){return c(t)},script:function(e,t){return'can.stache("'+u(t)+'")'}}),e.view.ext=".stache",e.extend(e.stache,o),e.extend(c,o),e.stache.safeString=c.safeString=function(e){return{toString:function(){return e}}},c});
/*helloworld.stache!can/view/stache/system*/
define("helloworld.stache!can/view/stache/system",["can/view/stache/stache"],function(e){return console.log(e),e("<h1>{{message}}</h1>")});
/*app*/
define("app",["helloworld.stache!stache"],function(e){"use strict";e&&e.__esModule||(e={"default":e});var t=e.default;return $(document.body).append(t({message:"Hi There"})),{}});
